[
    {
        "func_name": "handle_connect",
        "original": "def handle_connect(user_name, table, connection_id):\n    \"\"\"\n    Handles new connections by adding the connection ID and user name to the\n    DynamoDB table.\n\n    :param user_name: The name of the user that started the connection.\n    :param table: The DynamoDB connection table.\n    :param connection_id: The websocket connection ID of the new connection.\n    :return: An HTTP status code that indicates the result of adding the connection\n             to the DynamoDB table.\n    \"\"\"\n    status_code = 200\n    try:\n        table.put_item(Item={'connection_id': connection_id, 'user_name': user_name})\n        logger.info('Added connection %s for user %s.', connection_id, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't add connection %s for user %s.\", connection_id, user_name)\n        status_code = 503\n    return status_code",
        "mutated": [
            "def handle_connect(user_name, table, connection_id):\n    if False:\n        i = 10\n    '\\n    Handles new connections by adding the connection ID and user name to the\\n    DynamoDB table.\\n\\n    :param user_name: The name of the user that started the connection.\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the new connection.\\n    :return: An HTTP status code that indicates the result of adding the connection\\n             to the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.put_item(Item={'connection_id': connection_id, 'user_name': user_name})\n        logger.info('Added connection %s for user %s.', connection_id, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't add connection %s for user %s.\", connection_id, user_name)\n        status_code = 503\n    return status_code",
            "def handle_connect(user_name, table, connection_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Handles new connections by adding the connection ID and user name to the\\n    DynamoDB table.\\n\\n    :param user_name: The name of the user that started the connection.\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the new connection.\\n    :return: An HTTP status code that indicates the result of adding the connection\\n             to the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.put_item(Item={'connection_id': connection_id, 'user_name': user_name})\n        logger.info('Added connection %s for user %s.', connection_id, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't add connection %s for user %s.\", connection_id, user_name)\n        status_code = 503\n    return status_code",
            "def handle_connect(user_name, table, connection_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Handles new connections by adding the connection ID and user name to the\\n    DynamoDB table.\\n\\n    :param user_name: The name of the user that started the connection.\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the new connection.\\n    :return: An HTTP status code that indicates the result of adding the connection\\n             to the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.put_item(Item={'connection_id': connection_id, 'user_name': user_name})\n        logger.info('Added connection %s for user %s.', connection_id, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't add connection %s for user %s.\", connection_id, user_name)\n        status_code = 503\n    return status_code",
            "def handle_connect(user_name, table, connection_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Handles new connections by adding the connection ID and user name to the\\n    DynamoDB table.\\n\\n    :param user_name: The name of the user that started the connection.\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the new connection.\\n    :return: An HTTP status code that indicates the result of adding the connection\\n             to the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.put_item(Item={'connection_id': connection_id, 'user_name': user_name})\n        logger.info('Added connection %s for user %s.', connection_id, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't add connection %s for user %s.\", connection_id, user_name)\n        status_code = 503\n    return status_code",
            "def handle_connect(user_name, table, connection_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Handles new connections by adding the connection ID and user name to the\\n    DynamoDB table.\\n\\n    :param user_name: The name of the user that started the connection.\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the new connection.\\n    :return: An HTTP status code that indicates the result of adding the connection\\n             to the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.put_item(Item={'connection_id': connection_id, 'user_name': user_name})\n        logger.info('Added connection %s for user %s.', connection_id, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't add connection %s for user %s.\", connection_id, user_name)\n        status_code = 503\n    return status_code"
        ]
    },
    {
        "func_name": "handle_disconnect",
        "original": "def handle_disconnect(table, connection_id):\n    \"\"\"\n    Handles disconnections by removing the connection record from the DynamoDB table.\n\n    :param table: The DynamoDB connection table.\n    :param connection_id: The websocket connection ID of the connection to remove.\n    :return: An HTTP status code that indicates the result of removing the connection\n             from the DynamoDB table.\n    \"\"\"\n    status_code = 200\n    try:\n        table.delete_item(Key={'connection_id': connection_id})\n        logger.info('Disconnected connection %s.', connection_id)\n    except ClientError:\n        logger.exception(\"Couldn't disconnect connection %s.\", connection_id)\n        status_code = 503\n    return status_code",
        "mutated": [
            "def handle_disconnect(table, connection_id):\n    if False:\n        i = 10\n    '\\n    Handles disconnections by removing the connection record from the DynamoDB table.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the connection to remove.\\n    :return: An HTTP status code that indicates the result of removing the connection\\n             from the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.delete_item(Key={'connection_id': connection_id})\n        logger.info('Disconnected connection %s.', connection_id)\n    except ClientError:\n        logger.exception(\"Couldn't disconnect connection %s.\", connection_id)\n        status_code = 503\n    return status_code",
            "def handle_disconnect(table, connection_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Handles disconnections by removing the connection record from the DynamoDB table.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the connection to remove.\\n    :return: An HTTP status code that indicates the result of removing the connection\\n             from the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.delete_item(Key={'connection_id': connection_id})\n        logger.info('Disconnected connection %s.', connection_id)\n    except ClientError:\n        logger.exception(\"Couldn't disconnect connection %s.\", connection_id)\n        status_code = 503\n    return status_code",
            "def handle_disconnect(table, connection_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Handles disconnections by removing the connection record from the DynamoDB table.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the connection to remove.\\n    :return: An HTTP status code that indicates the result of removing the connection\\n             from the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.delete_item(Key={'connection_id': connection_id})\n        logger.info('Disconnected connection %s.', connection_id)\n    except ClientError:\n        logger.exception(\"Couldn't disconnect connection %s.\", connection_id)\n        status_code = 503\n    return status_code",
            "def handle_disconnect(table, connection_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Handles disconnections by removing the connection record from the DynamoDB table.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the connection to remove.\\n    :return: An HTTP status code that indicates the result of removing the connection\\n             from the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.delete_item(Key={'connection_id': connection_id})\n        logger.info('Disconnected connection %s.', connection_id)\n    except ClientError:\n        logger.exception(\"Couldn't disconnect connection %s.\", connection_id)\n        status_code = 503\n    return status_code",
            "def handle_disconnect(table, connection_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Handles disconnections by removing the connection record from the DynamoDB table.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The websocket connection ID of the connection to remove.\\n    :return: An HTTP status code that indicates the result of removing the connection\\n             from the DynamoDB table.\\n    '\n    status_code = 200\n    try:\n        table.delete_item(Key={'connection_id': connection_id})\n        logger.info('Disconnected connection %s.', connection_id)\n    except ClientError:\n        logger.exception(\"Couldn't disconnect connection %s.\", connection_id)\n        status_code = 503\n    return status_code"
        ]
    },
    {
        "func_name": "handle_message",
        "original": "def handle_message(table, connection_id, event_body, apig_management_client):\n    \"\"\"\n    Handles messages sent by a participant in the chat. Looks up all connections\n    currently tracked in the DynamoDB table, and uses the API Gateway Management API\n    to post the message to each other connection.\n\n    When posting to a connection results in a GoneException, the connection is\n    considered disconnected and is removed from the table. This is necessary\n    because disconnect messages are not always sent when a client disconnects.\n\n    :param table: The DynamoDB connection table.\n    :param connection_id: The ID of the connection that sent the message.\n    :param event_body: The body of the message sent from API Gateway. This is a\n                       dict with a `msg` field that contains the message to send.\n    :param apig_management_client: A Boto3 API Gateway Management API client.\n    :return: An HTTP status code that indicates the result of posting the message\n             to all active connections.\n    \"\"\"\n    status_code = 200\n    user_name = 'guest'\n    try:\n        item_response = table.get_item(Key={'connection_id': connection_id})\n        user_name = item_response['Item']['user_name']\n        logger.info('Got user name %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't find user name. Using %s.\", user_name)\n    connection_ids = []\n    try:\n        scan_response = table.scan(ProjectionExpression='connection_id')\n        connection_ids = [item['connection_id'] for item in scan_response['Items']]\n        logger.info('Found %s active connections.', len(connection_ids))\n    except ClientError:\n        logger.exception(\"Couldn't get connections.\")\n        status_code = 404\n    message = f\"{user_name}: {event_body['msg']}\".encode('utf-8')\n    logger.info('Message: %s', message)\n    for other_conn_id in connection_ids:\n        try:\n            if other_conn_id != connection_id:\n                send_response = apig_management_client.post_to_connection(Data=message, ConnectionId=other_conn_id)\n                logger.info('Posted message to connection %s, got response %s.', other_conn_id, send_response)\n        except ClientError:\n            logger.exception(\"Couldn't post to connection %s.\", other_conn_id)\n        except apig_management_client.exceptions.GoneException:\n            logger.info('Connection %s is gone, removing.', other_conn_id)\n            try:\n                table.delete_item(Key={'connection_id': other_conn_id})\n            except ClientError:\n                logger.exception(\"Couldn't remove connection %s.\", other_conn_id)\n    return status_code",
        "mutated": [
            "def handle_message(table, connection_id, event_body, apig_management_client):\n    if False:\n        i = 10\n    '\\n    Handles messages sent by a participant in the chat. Looks up all connections\\n    currently tracked in the DynamoDB table, and uses the API Gateway Management API\\n    to post the message to each other connection.\\n\\n    When posting to a connection results in a GoneException, the connection is\\n    considered disconnected and is removed from the table. This is necessary\\n    because disconnect messages are not always sent when a client disconnects.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The ID of the connection that sent the message.\\n    :param event_body: The body of the message sent from API Gateway. This is a\\n                       dict with a `msg` field that contains the message to send.\\n    :param apig_management_client: A Boto3 API Gateway Management API client.\\n    :return: An HTTP status code that indicates the result of posting the message\\n             to all active connections.\\n    '\n    status_code = 200\n    user_name = 'guest'\n    try:\n        item_response = table.get_item(Key={'connection_id': connection_id})\n        user_name = item_response['Item']['user_name']\n        logger.info('Got user name %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't find user name. Using %s.\", user_name)\n    connection_ids = []\n    try:\n        scan_response = table.scan(ProjectionExpression='connection_id')\n        connection_ids = [item['connection_id'] for item in scan_response['Items']]\n        logger.info('Found %s active connections.', len(connection_ids))\n    except ClientError:\n        logger.exception(\"Couldn't get connections.\")\n        status_code = 404\n    message = f\"{user_name}: {event_body['msg']}\".encode('utf-8')\n    logger.info('Message: %s', message)\n    for other_conn_id in connection_ids:\n        try:\n            if other_conn_id != connection_id:\n                send_response = apig_management_client.post_to_connection(Data=message, ConnectionId=other_conn_id)\n                logger.info('Posted message to connection %s, got response %s.', other_conn_id, send_response)\n        except ClientError:\n            logger.exception(\"Couldn't post to connection %s.\", other_conn_id)\n        except apig_management_client.exceptions.GoneException:\n            logger.info('Connection %s is gone, removing.', other_conn_id)\n            try:\n                table.delete_item(Key={'connection_id': other_conn_id})\n            except ClientError:\n                logger.exception(\"Couldn't remove connection %s.\", other_conn_id)\n    return status_code",
            "def handle_message(table, connection_id, event_body, apig_management_client):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Handles messages sent by a participant in the chat. Looks up all connections\\n    currently tracked in the DynamoDB table, and uses the API Gateway Management API\\n    to post the message to each other connection.\\n\\n    When posting to a connection results in a GoneException, the connection is\\n    considered disconnected and is removed from the table. This is necessary\\n    because disconnect messages are not always sent when a client disconnects.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The ID of the connection that sent the message.\\n    :param event_body: The body of the message sent from API Gateway. This is a\\n                       dict with a `msg` field that contains the message to send.\\n    :param apig_management_client: A Boto3 API Gateway Management API client.\\n    :return: An HTTP status code that indicates the result of posting the message\\n             to all active connections.\\n    '\n    status_code = 200\n    user_name = 'guest'\n    try:\n        item_response = table.get_item(Key={'connection_id': connection_id})\n        user_name = item_response['Item']['user_name']\n        logger.info('Got user name %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't find user name. Using %s.\", user_name)\n    connection_ids = []\n    try:\n        scan_response = table.scan(ProjectionExpression='connection_id')\n        connection_ids = [item['connection_id'] for item in scan_response['Items']]\n        logger.info('Found %s active connections.', len(connection_ids))\n    except ClientError:\n        logger.exception(\"Couldn't get connections.\")\n        status_code = 404\n    message = f\"{user_name}: {event_body['msg']}\".encode('utf-8')\n    logger.info('Message: %s', message)\n    for other_conn_id in connection_ids:\n        try:\n            if other_conn_id != connection_id:\n                send_response = apig_management_client.post_to_connection(Data=message, ConnectionId=other_conn_id)\n                logger.info('Posted message to connection %s, got response %s.', other_conn_id, send_response)\n        except ClientError:\n            logger.exception(\"Couldn't post to connection %s.\", other_conn_id)\n        except apig_management_client.exceptions.GoneException:\n            logger.info('Connection %s is gone, removing.', other_conn_id)\n            try:\n                table.delete_item(Key={'connection_id': other_conn_id})\n            except ClientError:\n                logger.exception(\"Couldn't remove connection %s.\", other_conn_id)\n    return status_code",
            "def handle_message(table, connection_id, event_body, apig_management_client):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Handles messages sent by a participant in the chat. Looks up all connections\\n    currently tracked in the DynamoDB table, and uses the API Gateway Management API\\n    to post the message to each other connection.\\n\\n    When posting to a connection results in a GoneException, the connection is\\n    considered disconnected and is removed from the table. This is necessary\\n    because disconnect messages are not always sent when a client disconnects.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The ID of the connection that sent the message.\\n    :param event_body: The body of the message sent from API Gateway. This is a\\n                       dict with a `msg` field that contains the message to send.\\n    :param apig_management_client: A Boto3 API Gateway Management API client.\\n    :return: An HTTP status code that indicates the result of posting the message\\n             to all active connections.\\n    '\n    status_code = 200\n    user_name = 'guest'\n    try:\n        item_response = table.get_item(Key={'connection_id': connection_id})\n        user_name = item_response['Item']['user_name']\n        logger.info('Got user name %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't find user name. Using %s.\", user_name)\n    connection_ids = []\n    try:\n        scan_response = table.scan(ProjectionExpression='connection_id')\n        connection_ids = [item['connection_id'] for item in scan_response['Items']]\n        logger.info('Found %s active connections.', len(connection_ids))\n    except ClientError:\n        logger.exception(\"Couldn't get connections.\")\n        status_code = 404\n    message = f\"{user_name}: {event_body['msg']}\".encode('utf-8')\n    logger.info('Message: %s', message)\n    for other_conn_id in connection_ids:\n        try:\n            if other_conn_id != connection_id:\n                send_response = apig_management_client.post_to_connection(Data=message, ConnectionId=other_conn_id)\n                logger.info('Posted message to connection %s, got response %s.', other_conn_id, send_response)\n        except ClientError:\n            logger.exception(\"Couldn't post to connection %s.\", other_conn_id)\n        except apig_management_client.exceptions.GoneException:\n            logger.info('Connection %s is gone, removing.', other_conn_id)\n            try:\n                table.delete_item(Key={'connection_id': other_conn_id})\n            except ClientError:\n                logger.exception(\"Couldn't remove connection %s.\", other_conn_id)\n    return status_code",
            "def handle_message(table, connection_id, event_body, apig_management_client):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Handles messages sent by a participant in the chat. Looks up all connections\\n    currently tracked in the DynamoDB table, and uses the API Gateway Management API\\n    to post the message to each other connection.\\n\\n    When posting to a connection results in a GoneException, the connection is\\n    considered disconnected and is removed from the table. This is necessary\\n    because disconnect messages are not always sent when a client disconnects.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The ID of the connection that sent the message.\\n    :param event_body: The body of the message sent from API Gateway. This is a\\n                       dict with a `msg` field that contains the message to send.\\n    :param apig_management_client: A Boto3 API Gateway Management API client.\\n    :return: An HTTP status code that indicates the result of posting the message\\n             to all active connections.\\n    '\n    status_code = 200\n    user_name = 'guest'\n    try:\n        item_response = table.get_item(Key={'connection_id': connection_id})\n        user_name = item_response['Item']['user_name']\n        logger.info('Got user name %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't find user name. Using %s.\", user_name)\n    connection_ids = []\n    try:\n        scan_response = table.scan(ProjectionExpression='connection_id')\n        connection_ids = [item['connection_id'] for item in scan_response['Items']]\n        logger.info('Found %s active connections.', len(connection_ids))\n    except ClientError:\n        logger.exception(\"Couldn't get connections.\")\n        status_code = 404\n    message = f\"{user_name}: {event_body['msg']}\".encode('utf-8')\n    logger.info('Message: %s', message)\n    for other_conn_id in connection_ids:\n        try:\n            if other_conn_id != connection_id:\n                send_response = apig_management_client.post_to_connection(Data=message, ConnectionId=other_conn_id)\n                logger.info('Posted message to connection %s, got response %s.', other_conn_id, send_response)\n        except ClientError:\n            logger.exception(\"Couldn't post to connection %s.\", other_conn_id)\n        except apig_management_client.exceptions.GoneException:\n            logger.info('Connection %s is gone, removing.', other_conn_id)\n            try:\n                table.delete_item(Key={'connection_id': other_conn_id})\n            except ClientError:\n                logger.exception(\"Couldn't remove connection %s.\", other_conn_id)\n    return status_code",
            "def handle_message(table, connection_id, event_body, apig_management_client):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Handles messages sent by a participant in the chat. Looks up all connections\\n    currently tracked in the DynamoDB table, and uses the API Gateway Management API\\n    to post the message to each other connection.\\n\\n    When posting to a connection results in a GoneException, the connection is\\n    considered disconnected and is removed from the table. This is necessary\\n    because disconnect messages are not always sent when a client disconnects.\\n\\n    :param table: The DynamoDB connection table.\\n    :param connection_id: The ID of the connection that sent the message.\\n    :param event_body: The body of the message sent from API Gateway. This is a\\n                       dict with a `msg` field that contains the message to send.\\n    :param apig_management_client: A Boto3 API Gateway Management API client.\\n    :return: An HTTP status code that indicates the result of posting the message\\n             to all active connections.\\n    '\n    status_code = 200\n    user_name = 'guest'\n    try:\n        item_response = table.get_item(Key={'connection_id': connection_id})\n        user_name = item_response['Item']['user_name']\n        logger.info('Got user name %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't find user name. Using %s.\", user_name)\n    connection_ids = []\n    try:\n        scan_response = table.scan(ProjectionExpression='connection_id')\n        connection_ids = [item['connection_id'] for item in scan_response['Items']]\n        logger.info('Found %s active connections.', len(connection_ids))\n    except ClientError:\n        logger.exception(\"Couldn't get connections.\")\n        status_code = 404\n    message = f\"{user_name}: {event_body['msg']}\".encode('utf-8')\n    logger.info('Message: %s', message)\n    for other_conn_id in connection_ids:\n        try:\n            if other_conn_id != connection_id:\n                send_response = apig_management_client.post_to_connection(Data=message, ConnectionId=other_conn_id)\n                logger.info('Posted message to connection %s, got response %s.', other_conn_id, send_response)\n        except ClientError:\n            logger.exception(\"Couldn't post to connection %s.\", other_conn_id)\n        except apig_management_client.exceptions.GoneException:\n            logger.info('Connection %s is gone, removing.', other_conn_id)\n            try:\n                table.delete_item(Key={'connection_id': other_conn_id})\n            except ClientError:\n                logger.exception(\"Couldn't remove connection %s.\", other_conn_id)\n    return status_code"
        ]
    },
    {
        "func_name": "lambda_handler",
        "original": "def lambda_handler(event, context):\n    \"\"\"\n    An AWS Lambda handler that receives events from an API Gateway websocket API\n    and dispatches them to various handler functions.\n\n    This function looks up the name of a DynamoDB table in the `table_name` environment\n    variable. The table must have a primary key named `connection_id`.\n\n    This function handles three routes: $connect, $disconnect, and sendmessage. Any\n    other route results in a 404 status code.\n\n    The $connect route accepts a query string `name` parameter that is the name of\n    the user that originated the connection. This name is added to all chat messages\n    sent by that user.\n\n    :param event: A dict that contains request data, query string parameters, and\n                  other data sent by API Gateway.\n    :param context: Context around the request.\n    :return: A response dict that contains an HTTP status code that indicates the\n             result of handling the event.\n    \"\"\"\n    table_name = os.environ['table_name']\n    route_key = event.get('requestContext', {}).get('routeKey')\n    connection_id = event.get('requestContext', {}).get('connectionId')\n    if table_name is None or route_key is None or connection_id is None:\n        return {'statusCode': 400}\n    table = boto3.resource('dynamodb').Table(table_name)\n    logger.info('Request: %s, use table %s.', route_key, table.name)\n    response = {'statusCode': 200}\n    if route_key == '$connect':\n        user_name = event.get('queryStringParameters', {'name': 'guest'}).get('name')\n        response['statusCode'] = handle_connect(user_name, table, connection_id)\n    elif route_key == '$disconnect':\n        response['statusCode'] = handle_disconnect(table, connection_id)\n    elif route_key == 'sendmessage':\n        body = event.get('body')\n        body = json.loads(body if body is not None else '{\"msg\": \"\"}')\n        domain = event.get('requestContext', {}).get('domainName')\n        stage = event.get('requestContext', {}).get('stage')\n        if domain is None or stage is None:\n            logger.warning(\"Couldn't send message. Bad endpoint in request: domain '%s', stage '%s'\", domain, stage)\n            response['statusCode'] = 400\n        else:\n            apig_management_client = boto3.client('apigatewaymanagementapi', endpoint_url=f'https://{domain}/{stage}')\n            response['statusCode'] = handle_message(table, connection_id, body, apig_management_client)\n    else:\n        response['statusCode'] = 404\n    return response",
        "mutated": [
            "def lambda_handler(event, context):\n    if False:\n        i = 10\n    '\\n    An AWS Lambda handler that receives events from an API Gateway websocket API\\n    and dispatches them to various handler functions.\\n\\n    This function looks up the name of a DynamoDB table in the `table_name` environment\\n    variable. The table must have a primary key named `connection_id`.\\n\\n    This function handles three routes: $connect, $disconnect, and sendmessage. Any\\n    other route results in a 404 status code.\\n\\n    The $connect route accepts a query string `name` parameter that is the name of\\n    the user that originated the connection. This name is added to all chat messages\\n    sent by that user.\\n\\n    :param event: A dict that contains request data, query string parameters, and\\n                  other data sent by API Gateway.\\n    :param context: Context around the request.\\n    :return: A response dict that contains an HTTP status code that indicates the\\n             result of handling the event.\\n    '\n    table_name = os.environ['table_name']\n    route_key = event.get('requestContext', {}).get('routeKey')\n    connection_id = event.get('requestContext', {}).get('connectionId')\n    if table_name is None or route_key is None or connection_id is None:\n        return {'statusCode': 400}\n    table = boto3.resource('dynamodb').Table(table_name)\n    logger.info('Request: %s, use table %s.', route_key, table.name)\n    response = {'statusCode': 200}\n    if route_key == '$connect':\n        user_name = event.get('queryStringParameters', {'name': 'guest'}).get('name')\n        response['statusCode'] = handle_connect(user_name, table, connection_id)\n    elif route_key == '$disconnect':\n        response['statusCode'] = handle_disconnect(table, connection_id)\n    elif route_key == 'sendmessage':\n        body = event.get('body')\n        body = json.loads(body if body is not None else '{\"msg\": \"\"}')\n        domain = event.get('requestContext', {}).get('domainName')\n        stage = event.get('requestContext', {}).get('stage')\n        if domain is None or stage is None:\n            logger.warning(\"Couldn't send message. Bad endpoint in request: domain '%s', stage '%s'\", domain, stage)\n            response['statusCode'] = 400\n        else:\n            apig_management_client = boto3.client('apigatewaymanagementapi', endpoint_url=f'https://{domain}/{stage}')\n            response['statusCode'] = handle_message(table, connection_id, body, apig_management_client)\n    else:\n        response['statusCode'] = 404\n    return response",
            "def lambda_handler(event, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    An AWS Lambda handler that receives events from an API Gateway websocket API\\n    and dispatches them to various handler functions.\\n\\n    This function looks up the name of a DynamoDB table in the `table_name` environment\\n    variable. The table must have a primary key named `connection_id`.\\n\\n    This function handles three routes: $connect, $disconnect, and sendmessage. Any\\n    other route results in a 404 status code.\\n\\n    The $connect route accepts a query string `name` parameter that is the name of\\n    the user that originated the connection. This name is added to all chat messages\\n    sent by that user.\\n\\n    :param event: A dict that contains request data, query string parameters, and\\n                  other data sent by API Gateway.\\n    :param context: Context around the request.\\n    :return: A response dict that contains an HTTP status code that indicates the\\n             result of handling the event.\\n    '\n    table_name = os.environ['table_name']\n    route_key = event.get('requestContext', {}).get('routeKey')\n    connection_id = event.get('requestContext', {}).get('connectionId')\n    if table_name is None or route_key is None or connection_id is None:\n        return {'statusCode': 400}\n    table = boto3.resource('dynamodb').Table(table_name)\n    logger.info('Request: %s, use table %s.', route_key, table.name)\n    response = {'statusCode': 200}\n    if route_key == '$connect':\n        user_name = event.get('queryStringParameters', {'name': 'guest'}).get('name')\n        response['statusCode'] = handle_connect(user_name, table, connection_id)\n    elif route_key == '$disconnect':\n        response['statusCode'] = handle_disconnect(table, connection_id)\n    elif route_key == 'sendmessage':\n        body = event.get('body')\n        body = json.loads(body if body is not None else '{\"msg\": \"\"}')\n        domain = event.get('requestContext', {}).get('domainName')\n        stage = event.get('requestContext', {}).get('stage')\n        if domain is None or stage is None:\n            logger.warning(\"Couldn't send message. Bad endpoint in request: domain '%s', stage '%s'\", domain, stage)\n            response['statusCode'] = 400\n        else:\n            apig_management_client = boto3.client('apigatewaymanagementapi', endpoint_url=f'https://{domain}/{stage}')\n            response['statusCode'] = handle_message(table, connection_id, body, apig_management_client)\n    else:\n        response['statusCode'] = 404\n    return response",
            "def lambda_handler(event, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    An AWS Lambda handler that receives events from an API Gateway websocket API\\n    and dispatches them to various handler functions.\\n\\n    This function looks up the name of a DynamoDB table in the `table_name` environment\\n    variable. The table must have a primary key named `connection_id`.\\n\\n    This function handles three routes: $connect, $disconnect, and sendmessage. Any\\n    other route results in a 404 status code.\\n\\n    The $connect route accepts a query string `name` parameter that is the name of\\n    the user that originated the connection. This name is added to all chat messages\\n    sent by that user.\\n\\n    :param event: A dict that contains request data, query string parameters, and\\n                  other data sent by API Gateway.\\n    :param context: Context around the request.\\n    :return: A response dict that contains an HTTP status code that indicates the\\n             result of handling the event.\\n    '\n    table_name = os.environ['table_name']\n    route_key = event.get('requestContext', {}).get('routeKey')\n    connection_id = event.get('requestContext', {}).get('connectionId')\n    if table_name is None or route_key is None or connection_id is None:\n        return {'statusCode': 400}\n    table = boto3.resource('dynamodb').Table(table_name)\n    logger.info('Request: %s, use table %s.', route_key, table.name)\n    response = {'statusCode': 200}\n    if route_key == '$connect':\n        user_name = event.get('queryStringParameters', {'name': 'guest'}).get('name')\n        response['statusCode'] = handle_connect(user_name, table, connection_id)\n    elif route_key == '$disconnect':\n        response['statusCode'] = handle_disconnect(table, connection_id)\n    elif route_key == 'sendmessage':\n        body = event.get('body')\n        body = json.loads(body if body is not None else '{\"msg\": \"\"}')\n        domain = event.get('requestContext', {}).get('domainName')\n        stage = event.get('requestContext', {}).get('stage')\n        if domain is None or stage is None:\n            logger.warning(\"Couldn't send message. Bad endpoint in request: domain '%s', stage '%s'\", domain, stage)\n            response['statusCode'] = 400\n        else:\n            apig_management_client = boto3.client('apigatewaymanagementapi', endpoint_url=f'https://{domain}/{stage}')\n            response['statusCode'] = handle_message(table, connection_id, body, apig_management_client)\n    else:\n        response['statusCode'] = 404\n    return response",
            "def lambda_handler(event, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    An AWS Lambda handler that receives events from an API Gateway websocket API\\n    and dispatches them to various handler functions.\\n\\n    This function looks up the name of a DynamoDB table in the `table_name` environment\\n    variable. The table must have a primary key named `connection_id`.\\n\\n    This function handles three routes: $connect, $disconnect, and sendmessage. Any\\n    other route results in a 404 status code.\\n\\n    The $connect route accepts a query string `name` parameter that is the name of\\n    the user that originated the connection. This name is added to all chat messages\\n    sent by that user.\\n\\n    :param event: A dict that contains request data, query string parameters, and\\n                  other data sent by API Gateway.\\n    :param context: Context around the request.\\n    :return: A response dict that contains an HTTP status code that indicates the\\n             result of handling the event.\\n    '\n    table_name = os.environ['table_name']\n    route_key = event.get('requestContext', {}).get('routeKey')\n    connection_id = event.get('requestContext', {}).get('connectionId')\n    if table_name is None or route_key is None or connection_id is None:\n        return {'statusCode': 400}\n    table = boto3.resource('dynamodb').Table(table_name)\n    logger.info('Request: %s, use table %s.', route_key, table.name)\n    response = {'statusCode': 200}\n    if route_key == '$connect':\n        user_name = event.get('queryStringParameters', {'name': 'guest'}).get('name')\n        response['statusCode'] = handle_connect(user_name, table, connection_id)\n    elif route_key == '$disconnect':\n        response['statusCode'] = handle_disconnect(table, connection_id)\n    elif route_key == 'sendmessage':\n        body = event.get('body')\n        body = json.loads(body if body is not None else '{\"msg\": \"\"}')\n        domain = event.get('requestContext', {}).get('domainName')\n        stage = event.get('requestContext', {}).get('stage')\n        if domain is None or stage is None:\n            logger.warning(\"Couldn't send message. Bad endpoint in request: domain '%s', stage '%s'\", domain, stage)\n            response['statusCode'] = 400\n        else:\n            apig_management_client = boto3.client('apigatewaymanagementapi', endpoint_url=f'https://{domain}/{stage}')\n            response['statusCode'] = handle_message(table, connection_id, body, apig_management_client)\n    else:\n        response['statusCode'] = 404\n    return response",
            "def lambda_handler(event, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    An AWS Lambda handler that receives events from an API Gateway websocket API\\n    and dispatches them to various handler functions.\\n\\n    This function looks up the name of a DynamoDB table in the `table_name` environment\\n    variable. The table must have a primary key named `connection_id`.\\n\\n    This function handles three routes: $connect, $disconnect, and sendmessage. Any\\n    other route results in a 404 status code.\\n\\n    The $connect route accepts a query string `name` parameter that is the name of\\n    the user that originated the connection. This name is added to all chat messages\\n    sent by that user.\\n\\n    :param event: A dict that contains request data, query string parameters, and\\n                  other data sent by API Gateway.\\n    :param context: Context around the request.\\n    :return: A response dict that contains an HTTP status code that indicates the\\n             result of handling the event.\\n    '\n    table_name = os.environ['table_name']\n    route_key = event.get('requestContext', {}).get('routeKey')\n    connection_id = event.get('requestContext', {}).get('connectionId')\n    if table_name is None or route_key is None or connection_id is None:\n        return {'statusCode': 400}\n    table = boto3.resource('dynamodb').Table(table_name)\n    logger.info('Request: %s, use table %s.', route_key, table.name)\n    response = {'statusCode': 200}\n    if route_key == '$connect':\n        user_name = event.get('queryStringParameters', {'name': 'guest'}).get('name')\n        response['statusCode'] = handle_connect(user_name, table, connection_id)\n    elif route_key == '$disconnect':\n        response['statusCode'] = handle_disconnect(table, connection_id)\n    elif route_key == 'sendmessage':\n        body = event.get('body')\n        body = json.loads(body if body is not None else '{\"msg\": \"\"}')\n        domain = event.get('requestContext', {}).get('domainName')\n        stage = event.get('requestContext', {}).get('stage')\n        if domain is None or stage is None:\n            logger.warning(\"Couldn't send message. Bad endpoint in request: domain '%s', stage '%s'\", domain, stage)\n            response['statusCode'] = 400\n        else:\n            apig_management_client = boto3.client('apigatewaymanagementapi', endpoint_url=f'https://{domain}/{stage}')\n            response['statusCode'] = handle_message(table, connection_id, body, apig_management_client)\n    else:\n        response['statusCode'] = 404\n    return response"
        ]
    }
]