[
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_dims, num_classes, primitive_mode, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, feat_channels=(128, 128), upper_thresh=100.0, surface_thresh=0.5, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), objectness_loss=None, center_loss=None, semantic_reg_loss=None, semantic_cls_loss=None, init_cfg=None):\n    super(PrimitiveHead, self).__init__(init_cfg=init_cfg)\n    assert primitive_mode in ['z', 'xy', 'line']\n    self.num_dims = num_dims\n    self.num_classes = num_classes\n    self.primitive_mode = primitive_mode\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.gt_per_seed = vote_module_cfg['gt_per_seed']\n    self.num_proposal = vote_aggregation_cfg['num_point']\n    self.upper_thresh = upper_thresh\n    self.surface_thresh = surface_thresh\n    self.objectness_loss = build_loss(objectness_loss)\n    self.center_loss = build_loss(center_loss)\n    self.semantic_reg_loss = build_loss(semantic_reg_loss)\n    self.semantic_cls_loss = build_loss(semantic_cls_loss)\n    assert vote_aggregation_cfg['mlp_channels'][0] == vote_module_cfg['in_channels']\n    self.flag_conv = ConvModule(vote_module_cfg['conv_channels'][-1], vote_module_cfg['conv_channels'][-1] // 2, 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True)\n    self.flag_pred = torch.nn.Conv1d(vote_module_cfg['conv_channels'][-1] // 2, 2, 1)\n    self.vote_module = VoteModule(**vote_module_cfg)\n    self.vote_aggregation = build_sa_module(vote_aggregation_cfg)\n    prev_channel = vote_aggregation_cfg['mlp_channels'][-1]\n    conv_pred_list = list()\n    for k in range(len(feat_channels)):\n        conv_pred_list.append(ConvModule(prev_channel, feat_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True))\n        prev_channel = feat_channels[k]\n    self.conv_pred = nn.Sequential(*conv_pred_list)\n    conv_out_channel = 3 + num_dims + num_classes\n    self.conv_pred.add_module('conv_out', nn.Conv1d(prev_channel, conv_out_channel, 1))",
        "mutated": [
            "def __init__(self, num_dims, num_classes, primitive_mode, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, feat_channels=(128, 128), upper_thresh=100.0, surface_thresh=0.5, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), objectness_loss=None, center_loss=None, semantic_reg_loss=None, semantic_cls_loss=None, init_cfg=None):\n    if False:\n        i = 10\n    super(PrimitiveHead, self).__init__(init_cfg=init_cfg)\n    assert primitive_mode in ['z', 'xy', 'line']\n    self.num_dims = num_dims\n    self.num_classes = num_classes\n    self.primitive_mode = primitive_mode\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.gt_per_seed = vote_module_cfg['gt_per_seed']\n    self.num_proposal = vote_aggregation_cfg['num_point']\n    self.upper_thresh = upper_thresh\n    self.surface_thresh = surface_thresh\n    self.objectness_loss = build_loss(objectness_loss)\n    self.center_loss = build_loss(center_loss)\n    self.semantic_reg_loss = build_loss(semantic_reg_loss)\n    self.semantic_cls_loss = build_loss(semantic_cls_loss)\n    assert vote_aggregation_cfg['mlp_channels'][0] == vote_module_cfg['in_channels']\n    self.flag_conv = ConvModule(vote_module_cfg['conv_channels'][-1], vote_module_cfg['conv_channels'][-1] // 2, 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True)\n    self.flag_pred = torch.nn.Conv1d(vote_module_cfg['conv_channels'][-1] // 2, 2, 1)\n    self.vote_module = VoteModule(**vote_module_cfg)\n    self.vote_aggregation = build_sa_module(vote_aggregation_cfg)\n    prev_channel = vote_aggregation_cfg['mlp_channels'][-1]\n    conv_pred_list = list()\n    for k in range(len(feat_channels)):\n        conv_pred_list.append(ConvModule(prev_channel, feat_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True))\n        prev_channel = feat_channels[k]\n    self.conv_pred = nn.Sequential(*conv_pred_list)\n    conv_out_channel = 3 + num_dims + num_classes\n    self.conv_pred.add_module('conv_out', nn.Conv1d(prev_channel, conv_out_channel, 1))",
            "def __init__(self, num_dims, num_classes, primitive_mode, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, feat_channels=(128, 128), upper_thresh=100.0, surface_thresh=0.5, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), objectness_loss=None, center_loss=None, semantic_reg_loss=None, semantic_cls_loss=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(PrimitiveHead, self).__init__(init_cfg=init_cfg)\n    assert primitive_mode in ['z', 'xy', 'line']\n    self.num_dims = num_dims\n    self.num_classes = num_classes\n    self.primitive_mode = primitive_mode\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.gt_per_seed = vote_module_cfg['gt_per_seed']\n    self.num_proposal = vote_aggregation_cfg['num_point']\n    self.upper_thresh = upper_thresh\n    self.surface_thresh = surface_thresh\n    self.objectness_loss = build_loss(objectness_loss)\n    self.center_loss = build_loss(center_loss)\n    self.semantic_reg_loss = build_loss(semantic_reg_loss)\n    self.semantic_cls_loss = build_loss(semantic_cls_loss)\n    assert vote_aggregation_cfg['mlp_channels'][0] == vote_module_cfg['in_channels']\n    self.flag_conv = ConvModule(vote_module_cfg['conv_channels'][-1], vote_module_cfg['conv_channels'][-1] // 2, 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True)\n    self.flag_pred = torch.nn.Conv1d(vote_module_cfg['conv_channels'][-1] // 2, 2, 1)\n    self.vote_module = VoteModule(**vote_module_cfg)\n    self.vote_aggregation = build_sa_module(vote_aggregation_cfg)\n    prev_channel = vote_aggregation_cfg['mlp_channels'][-1]\n    conv_pred_list = list()\n    for k in range(len(feat_channels)):\n        conv_pred_list.append(ConvModule(prev_channel, feat_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True))\n        prev_channel = feat_channels[k]\n    self.conv_pred = nn.Sequential(*conv_pred_list)\n    conv_out_channel = 3 + num_dims + num_classes\n    self.conv_pred.add_module('conv_out', nn.Conv1d(prev_channel, conv_out_channel, 1))",
            "def __init__(self, num_dims, num_classes, primitive_mode, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, feat_channels=(128, 128), upper_thresh=100.0, surface_thresh=0.5, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), objectness_loss=None, center_loss=None, semantic_reg_loss=None, semantic_cls_loss=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(PrimitiveHead, self).__init__(init_cfg=init_cfg)\n    assert primitive_mode in ['z', 'xy', 'line']\n    self.num_dims = num_dims\n    self.num_classes = num_classes\n    self.primitive_mode = primitive_mode\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.gt_per_seed = vote_module_cfg['gt_per_seed']\n    self.num_proposal = vote_aggregation_cfg['num_point']\n    self.upper_thresh = upper_thresh\n    self.surface_thresh = surface_thresh\n    self.objectness_loss = build_loss(objectness_loss)\n    self.center_loss = build_loss(center_loss)\n    self.semantic_reg_loss = build_loss(semantic_reg_loss)\n    self.semantic_cls_loss = build_loss(semantic_cls_loss)\n    assert vote_aggregation_cfg['mlp_channels'][0] == vote_module_cfg['in_channels']\n    self.flag_conv = ConvModule(vote_module_cfg['conv_channels'][-1], vote_module_cfg['conv_channels'][-1] // 2, 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True)\n    self.flag_pred = torch.nn.Conv1d(vote_module_cfg['conv_channels'][-1] // 2, 2, 1)\n    self.vote_module = VoteModule(**vote_module_cfg)\n    self.vote_aggregation = build_sa_module(vote_aggregation_cfg)\n    prev_channel = vote_aggregation_cfg['mlp_channels'][-1]\n    conv_pred_list = list()\n    for k in range(len(feat_channels)):\n        conv_pred_list.append(ConvModule(prev_channel, feat_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True))\n        prev_channel = feat_channels[k]\n    self.conv_pred = nn.Sequential(*conv_pred_list)\n    conv_out_channel = 3 + num_dims + num_classes\n    self.conv_pred.add_module('conv_out', nn.Conv1d(prev_channel, conv_out_channel, 1))",
            "def __init__(self, num_dims, num_classes, primitive_mode, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, feat_channels=(128, 128), upper_thresh=100.0, surface_thresh=0.5, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), objectness_loss=None, center_loss=None, semantic_reg_loss=None, semantic_cls_loss=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(PrimitiveHead, self).__init__(init_cfg=init_cfg)\n    assert primitive_mode in ['z', 'xy', 'line']\n    self.num_dims = num_dims\n    self.num_classes = num_classes\n    self.primitive_mode = primitive_mode\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.gt_per_seed = vote_module_cfg['gt_per_seed']\n    self.num_proposal = vote_aggregation_cfg['num_point']\n    self.upper_thresh = upper_thresh\n    self.surface_thresh = surface_thresh\n    self.objectness_loss = build_loss(objectness_loss)\n    self.center_loss = build_loss(center_loss)\n    self.semantic_reg_loss = build_loss(semantic_reg_loss)\n    self.semantic_cls_loss = build_loss(semantic_cls_loss)\n    assert vote_aggregation_cfg['mlp_channels'][0] == vote_module_cfg['in_channels']\n    self.flag_conv = ConvModule(vote_module_cfg['conv_channels'][-1], vote_module_cfg['conv_channels'][-1] // 2, 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True)\n    self.flag_pred = torch.nn.Conv1d(vote_module_cfg['conv_channels'][-1] // 2, 2, 1)\n    self.vote_module = VoteModule(**vote_module_cfg)\n    self.vote_aggregation = build_sa_module(vote_aggregation_cfg)\n    prev_channel = vote_aggregation_cfg['mlp_channels'][-1]\n    conv_pred_list = list()\n    for k in range(len(feat_channels)):\n        conv_pred_list.append(ConvModule(prev_channel, feat_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True))\n        prev_channel = feat_channels[k]\n    self.conv_pred = nn.Sequential(*conv_pred_list)\n    conv_out_channel = 3 + num_dims + num_classes\n    self.conv_pred.add_module('conv_out', nn.Conv1d(prev_channel, conv_out_channel, 1))",
            "def __init__(self, num_dims, num_classes, primitive_mode, train_cfg=None, test_cfg=None, vote_module_cfg=None, vote_aggregation_cfg=None, feat_channels=(128, 128), upper_thresh=100.0, surface_thresh=0.5, conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), objectness_loss=None, center_loss=None, semantic_reg_loss=None, semantic_cls_loss=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(PrimitiveHead, self).__init__(init_cfg=init_cfg)\n    assert primitive_mode in ['z', 'xy', 'line']\n    self.num_dims = num_dims\n    self.num_classes = num_classes\n    self.primitive_mode = primitive_mode\n    self.train_cfg = train_cfg\n    self.test_cfg = test_cfg\n    self.gt_per_seed = vote_module_cfg['gt_per_seed']\n    self.num_proposal = vote_aggregation_cfg['num_point']\n    self.upper_thresh = upper_thresh\n    self.surface_thresh = surface_thresh\n    self.objectness_loss = build_loss(objectness_loss)\n    self.center_loss = build_loss(center_loss)\n    self.semantic_reg_loss = build_loss(semantic_reg_loss)\n    self.semantic_cls_loss = build_loss(semantic_cls_loss)\n    assert vote_aggregation_cfg['mlp_channels'][0] == vote_module_cfg['in_channels']\n    self.flag_conv = ConvModule(vote_module_cfg['conv_channels'][-1], vote_module_cfg['conv_channels'][-1] // 2, 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True)\n    self.flag_pred = torch.nn.Conv1d(vote_module_cfg['conv_channels'][-1] // 2, 2, 1)\n    self.vote_module = VoteModule(**vote_module_cfg)\n    self.vote_aggregation = build_sa_module(vote_aggregation_cfg)\n    prev_channel = vote_aggregation_cfg['mlp_channels'][-1]\n    conv_pred_list = list()\n    for k in range(len(feat_channels)):\n        conv_pred_list.append(ConvModule(prev_channel, feat_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, bias=True, inplace=True))\n        prev_channel = feat_channels[k]\n    self.conv_pred = nn.Sequential(*conv_pred_list)\n    conv_out_channel = 3 + num_dims + num_classes\n    self.conv_pred.add_module('conv_out', nn.Conv1d(prev_channel, conv_out_channel, 1))"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, feats_dict, sample_mod):\n    \"\"\"Forward pass.\n\n        Args:\n            feats_dict (dict): Feature dict from backbone.\n            sample_mod (str): Sample mode for vote aggregation layer.\n                valid modes are \"vote\", \"seed\" and \"random\".\n\n        Returns:\n            dict: Predictions of primitive head.\n        \"\"\"\n    assert sample_mod in ['vote', 'seed', 'random']\n    seed_points = feats_dict['fp_xyz_net0'][-1]\n    seed_features = feats_dict['hd_feature']\n    results = {}\n    primitive_flag = self.flag_conv(seed_features)\n    primitive_flag = self.flag_pred(primitive_flag)\n    results['pred_flag_' + self.primitive_mode] = primitive_flag\n    (vote_points, vote_features, _) = self.vote_module(seed_points, seed_features)\n    results['vote_' + self.primitive_mode] = vote_points\n    results['vote_features_' + self.primitive_mode] = vote_features\n    if sample_mod == 'vote':\n        sample_indices = None\n    elif sample_mod == 'seed':\n        sample_indices = furthest_point_sample(seed_points, self.num_proposal)\n    elif sample_mod == 'random':\n        (batch_size, num_seed) = seed_points.shape[:2]\n        sample_indices = torch.randint(0, num_seed, (batch_size, self.num_proposal), dtype=torch.int32, device=seed_points.device)\n    else:\n        raise NotImplementedError('Unsupported sample mod!')\n    vote_aggregation_ret = self.vote_aggregation(vote_points, vote_features, sample_indices)\n    (aggregated_points, features, aggregated_indices) = vote_aggregation_ret\n    results['aggregated_points_' + self.primitive_mode] = aggregated_points\n    results['aggregated_features_' + self.primitive_mode] = features\n    results['aggregated_indices_' + self.primitive_mode] = aggregated_indices\n    predictions = self.conv_pred(features)\n    decode_ret = self.primitive_decode_scores(predictions, aggregated_points)\n    results.update(decode_ret)\n    (center, pred_ind) = self.get_primitive_center(primitive_flag, decode_ret['center_' + self.primitive_mode])\n    results['pred_' + self.primitive_mode + '_ind'] = pred_ind\n    results['pred_' + self.primitive_mode + '_center'] = center\n    return results",
        "mutated": [
            "def forward(self, feats_dict, sample_mod):\n    if False:\n        i = 10\n    'Forward pass.\\n\\n        Args:\\n            feats_dict (dict): Feature dict from backbone.\\n            sample_mod (str): Sample mode for vote aggregation layer.\\n                valid modes are \"vote\", \"seed\" and \"random\".\\n\\n        Returns:\\n            dict: Predictions of primitive head.\\n        '\n    assert sample_mod in ['vote', 'seed', 'random']\n    seed_points = feats_dict['fp_xyz_net0'][-1]\n    seed_features = feats_dict['hd_feature']\n    results = {}\n    primitive_flag = self.flag_conv(seed_features)\n    primitive_flag = self.flag_pred(primitive_flag)\n    results['pred_flag_' + self.primitive_mode] = primitive_flag\n    (vote_points, vote_features, _) = self.vote_module(seed_points, seed_features)\n    results['vote_' + self.primitive_mode] = vote_points\n    results['vote_features_' + self.primitive_mode] = vote_features\n    if sample_mod == 'vote':\n        sample_indices = None\n    elif sample_mod == 'seed':\n        sample_indices = furthest_point_sample(seed_points, self.num_proposal)\n    elif sample_mod == 'random':\n        (batch_size, num_seed) = seed_points.shape[:2]\n        sample_indices = torch.randint(0, num_seed, (batch_size, self.num_proposal), dtype=torch.int32, device=seed_points.device)\n    else:\n        raise NotImplementedError('Unsupported sample mod!')\n    vote_aggregation_ret = self.vote_aggregation(vote_points, vote_features, sample_indices)\n    (aggregated_points, features, aggregated_indices) = vote_aggregation_ret\n    results['aggregated_points_' + self.primitive_mode] = aggregated_points\n    results['aggregated_features_' + self.primitive_mode] = features\n    results['aggregated_indices_' + self.primitive_mode] = aggregated_indices\n    predictions = self.conv_pred(features)\n    decode_ret = self.primitive_decode_scores(predictions, aggregated_points)\n    results.update(decode_ret)\n    (center, pred_ind) = self.get_primitive_center(primitive_flag, decode_ret['center_' + self.primitive_mode])\n    results['pred_' + self.primitive_mode + '_ind'] = pred_ind\n    results['pred_' + self.primitive_mode + '_center'] = center\n    return results",
            "def forward(self, feats_dict, sample_mod):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Forward pass.\\n\\n        Args:\\n            feats_dict (dict): Feature dict from backbone.\\n            sample_mod (str): Sample mode for vote aggregation layer.\\n                valid modes are \"vote\", \"seed\" and \"random\".\\n\\n        Returns:\\n            dict: Predictions of primitive head.\\n        '\n    assert sample_mod in ['vote', 'seed', 'random']\n    seed_points = feats_dict['fp_xyz_net0'][-1]\n    seed_features = feats_dict['hd_feature']\n    results = {}\n    primitive_flag = self.flag_conv(seed_features)\n    primitive_flag = self.flag_pred(primitive_flag)\n    results['pred_flag_' + self.primitive_mode] = primitive_flag\n    (vote_points, vote_features, _) = self.vote_module(seed_points, seed_features)\n    results['vote_' + self.primitive_mode] = vote_points\n    results['vote_features_' + self.primitive_mode] = vote_features\n    if sample_mod == 'vote':\n        sample_indices = None\n    elif sample_mod == 'seed':\n        sample_indices = furthest_point_sample(seed_points, self.num_proposal)\n    elif sample_mod == 'random':\n        (batch_size, num_seed) = seed_points.shape[:2]\n        sample_indices = torch.randint(0, num_seed, (batch_size, self.num_proposal), dtype=torch.int32, device=seed_points.device)\n    else:\n        raise NotImplementedError('Unsupported sample mod!')\n    vote_aggregation_ret = self.vote_aggregation(vote_points, vote_features, sample_indices)\n    (aggregated_points, features, aggregated_indices) = vote_aggregation_ret\n    results['aggregated_points_' + self.primitive_mode] = aggregated_points\n    results['aggregated_features_' + self.primitive_mode] = features\n    results['aggregated_indices_' + self.primitive_mode] = aggregated_indices\n    predictions = self.conv_pred(features)\n    decode_ret = self.primitive_decode_scores(predictions, aggregated_points)\n    results.update(decode_ret)\n    (center, pred_ind) = self.get_primitive_center(primitive_flag, decode_ret['center_' + self.primitive_mode])\n    results['pred_' + self.primitive_mode + '_ind'] = pred_ind\n    results['pred_' + self.primitive_mode + '_center'] = center\n    return results",
            "def forward(self, feats_dict, sample_mod):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Forward pass.\\n\\n        Args:\\n            feats_dict (dict): Feature dict from backbone.\\n            sample_mod (str): Sample mode for vote aggregation layer.\\n                valid modes are \"vote\", \"seed\" and \"random\".\\n\\n        Returns:\\n            dict: Predictions of primitive head.\\n        '\n    assert sample_mod in ['vote', 'seed', 'random']\n    seed_points = feats_dict['fp_xyz_net0'][-1]\n    seed_features = feats_dict['hd_feature']\n    results = {}\n    primitive_flag = self.flag_conv(seed_features)\n    primitive_flag = self.flag_pred(primitive_flag)\n    results['pred_flag_' + self.primitive_mode] = primitive_flag\n    (vote_points, vote_features, _) = self.vote_module(seed_points, seed_features)\n    results['vote_' + self.primitive_mode] = vote_points\n    results['vote_features_' + self.primitive_mode] = vote_features\n    if sample_mod == 'vote':\n        sample_indices = None\n    elif sample_mod == 'seed':\n        sample_indices = furthest_point_sample(seed_points, self.num_proposal)\n    elif sample_mod == 'random':\n        (batch_size, num_seed) = seed_points.shape[:2]\n        sample_indices = torch.randint(0, num_seed, (batch_size, self.num_proposal), dtype=torch.int32, device=seed_points.device)\n    else:\n        raise NotImplementedError('Unsupported sample mod!')\n    vote_aggregation_ret = self.vote_aggregation(vote_points, vote_features, sample_indices)\n    (aggregated_points, features, aggregated_indices) = vote_aggregation_ret\n    results['aggregated_points_' + self.primitive_mode] = aggregated_points\n    results['aggregated_features_' + self.primitive_mode] = features\n    results['aggregated_indices_' + self.primitive_mode] = aggregated_indices\n    predictions = self.conv_pred(features)\n    decode_ret = self.primitive_decode_scores(predictions, aggregated_points)\n    results.update(decode_ret)\n    (center, pred_ind) = self.get_primitive_center(primitive_flag, decode_ret['center_' + self.primitive_mode])\n    results['pred_' + self.primitive_mode + '_ind'] = pred_ind\n    results['pred_' + self.primitive_mode + '_center'] = center\n    return results",
            "def forward(self, feats_dict, sample_mod):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Forward pass.\\n\\n        Args:\\n            feats_dict (dict): Feature dict from backbone.\\n            sample_mod (str): Sample mode for vote aggregation layer.\\n                valid modes are \"vote\", \"seed\" and \"random\".\\n\\n        Returns:\\n            dict: Predictions of primitive head.\\n        '\n    assert sample_mod in ['vote', 'seed', 'random']\n    seed_points = feats_dict['fp_xyz_net0'][-1]\n    seed_features = feats_dict['hd_feature']\n    results = {}\n    primitive_flag = self.flag_conv(seed_features)\n    primitive_flag = self.flag_pred(primitive_flag)\n    results['pred_flag_' + self.primitive_mode] = primitive_flag\n    (vote_points, vote_features, _) = self.vote_module(seed_points, seed_features)\n    results['vote_' + self.primitive_mode] = vote_points\n    results['vote_features_' + self.primitive_mode] = vote_features\n    if sample_mod == 'vote':\n        sample_indices = None\n    elif sample_mod == 'seed':\n        sample_indices = furthest_point_sample(seed_points, self.num_proposal)\n    elif sample_mod == 'random':\n        (batch_size, num_seed) = seed_points.shape[:2]\n        sample_indices = torch.randint(0, num_seed, (batch_size, self.num_proposal), dtype=torch.int32, device=seed_points.device)\n    else:\n        raise NotImplementedError('Unsupported sample mod!')\n    vote_aggregation_ret = self.vote_aggregation(vote_points, vote_features, sample_indices)\n    (aggregated_points, features, aggregated_indices) = vote_aggregation_ret\n    results['aggregated_points_' + self.primitive_mode] = aggregated_points\n    results['aggregated_features_' + self.primitive_mode] = features\n    results['aggregated_indices_' + self.primitive_mode] = aggregated_indices\n    predictions = self.conv_pred(features)\n    decode_ret = self.primitive_decode_scores(predictions, aggregated_points)\n    results.update(decode_ret)\n    (center, pred_ind) = self.get_primitive_center(primitive_flag, decode_ret['center_' + self.primitive_mode])\n    results['pred_' + self.primitive_mode + '_ind'] = pred_ind\n    results['pred_' + self.primitive_mode + '_center'] = center\n    return results",
            "def forward(self, feats_dict, sample_mod):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Forward pass.\\n\\n        Args:\\n            feats_dict (dict): Feature dict from backbone.\\n            sample_mod (str): Sample mode for vote aggregation layer.\\n                valid modes are \"vote\", \"seed\" and \"random\".\\n\\n        Returns:\\n            dict: Predictions of primitive head.\\n        '\n    assert sample_mod in ['vote', 'seed', 'random']\n    seed_points = feats_dict['fp_xyz_net0'][-1]\n    seed_features = feats_dict['hd_feature']\n    results = {}\n    primitive_flag = self.flag_conv(seed_features)\n    primitive_flag = self.flag_pred(primitive_flag)\n    results['pred_flag_' + self.primitive_mode] = primitive_flag\n    (vote_points, vote_features, _) = self.vote_module(seed_points, seed_features)\n    results['vote_' + self.primitive_mode] = vote_points\n    results['vote_features_' + self.primitive_mode] = vote_features\n    if sample_mod == 'vote':\n        sample_indices = None\n    elif sample_mod == 'seed':\n        sample_indices = furthest_point_sample(seed_points, self.num_proposal)\n    elif sample_mod == 'random':\n        (batch_size, num_seed) = seed_points.shape[:2]\n        sample_indices = torch.randint(0, num_seed, (batch_size, self.num_proposal), dtype=torch.int32, device=seed_points.device)\n    else:\n        raise NotImplementedError('Unsupported sample mod!')\n    vote_aggregation_ret = self.vote_aggregation(vote_points, vote_features, sample_indices)\n    (aggregated_points, features, aggregated_indices) = vote_aggregation_ret\n    results['aggregated_points_' + self.primitive_mode] = aggregated_points\n    results['aggregated_features_' + self.primitive_mode] = features\n    results['aggregated_indices_' + self.primitive_mode] = aggregated_indices\n    predictions = self.conv_pred(features)\n    decode_ret = self.primitive_decode_scores(predictions, aggregated_points)\n    results.update(decode_ret)\n    (center, pred_ind) = self.get_primitive_center(primitive_flag, decode_ret['center_' + self.primitive_mode])\n    results['pred_' + self.primitive_mode + '_ind'] = pred_ind\n    results['pred_' + self.primitive_mode + '_center'] = center\n    return results"
        ]
    },
    {
        "func_name": "loss",
        "original": "def loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    \"\"\"Compute loss.\n\n        Args:\n            bbox_preds (dict): Predictions from forward of primitive head.\n            points (list[torch.Tensor]): Input points.\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\n                bboxes of each sample.\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\n                semantic mask.\n            pts_instance_mask (list[torch.Tensor]): Point-wise\n                instance mask.\n            img_metas (list[dict]): Contain pcd and img's meta info.\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\n                which bounding.\n\n        Returns:\n            dict: Losses of Primitive Head.\n        \"\"\"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask) = targets\n    losses = {}\n    pred_flag = bbox_preds['pred_flag_' + self.primitive_mode]\n    flag_loss = self.objectness_loss(pred_flag, gt_primitive_mask.long())\n    losses['flag_loss_' + self.primitive_mode] = flag_loss\n    vote_loss = self.vote_module.get_loss(bbox_preds['seed_points'], bbox_preds['vote_' + self.primitive_mode], bbox_preds['seed_indices'], point_mask, point_offset)\n    losses['vote_loss_' + self.primitive_mode] = vote_loss\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    primitive_center = bbox_preds['center_' + self.primitive_mode]\n    if self.primitive_mode != 'line':\n        primitive_semantic = bbox_preds['size_residuals_' + self.primitive_mode].contiguous()\n    else:\n        primitive_semantic = None\n    semancitc_scores = bbox_preds['sem_cls_scores_' + self.primitive_mode].transpose(2, 1)\n    gt_primitive_mask = gt_primitive_mask / (gt_primitive_mask.sum() + 1e-06)\n    (center_loss, size_loss, sem_cls_loss) = self.compute_primitive_loss(primitive_center, primitive_semantic, semancitc_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask)\n    losses['center_loss_' + self.primitive_mode] = center_loss\n    losses['size_loss_' + self.primitive_mode] = size_loss\n    losses['sem_loss_' + self.primitive_mode] = sem_cls_loss\n    return losses",
        "mutated": [
            "def loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of Primitive Head.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask) = targets\n    losses = {}\n    pred_flag = bbox_preds['pred_flag_' + self.primitive_mode]\n    flag_loss = self.objectness_loss(pred_flag, gt_primitive_mask.long())\n    losses['flag_loss_' + self.primitive_mode] = flag_loss\n    vote_loss = self.vote_module.get_loss(bbox_preds['seed_points'], bbox_preds['vote_' + self.primitive_mode], bbox_preds['seed_indices'], point_mask, point_offset)\n    losses['vote_loss_' + self.primitive_mode] = vote_loss\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    primitive_center = bbox_preds['center_' + self.primitive_mode]\n    if self.primitive_mode != 'line':\n        primitive_semantic = bbox_preds['size_residuals_' + self.primitive_mode].contiguous()\n    else:\n        primitive_semantic = None\n    semancitc_scores = bbox_preds['sem_cls_scores_' + self.primitive_mode].transpose(2, 1)\n    gt_primitive_mask = gt_primitive_mask / (gt_primitive_mask.sum() + 1e-06)\n    (center_loss, size_loss, sem_cls_loss) = self.compute_primitive_loss(primitive_center, primitive_semantic, semancitc_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask)\n    losses['center_loss_' + self.primitive_mode] = center_loss\n    losses['size_loss_' + self.primitive_mode] = size_loss\n    losses['sem_loss_' + self.primitive_mode] = sem_cls_loss\n    return losses",
            "def loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of Primitive Head.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask) = targets\n    losses = {}\n    pred_flag = bbox_preds['pred_flag_' + self.primitive_mode]\n    flag_loss = self.objectness_loss(pred_flag, gt_primitive_mask.long())\n    losses['flag_loss_' + self.primitive_mode] = flag_loss\n    vote_loss = self.vote_module.get_loss(bbox_preds['seed_points'], bbox_preds['vote_' + self.primitive_mode], bbox_preds['seed_indices'], point_mask, point_offset)\n    losses['vote_loss_' + self.primitive_mode] = vote_loss\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    primitive_center = bbox_preds['center_' + self.primitive_mode]\n    if self.primitive_mode != 'line':\n        primitive_semantic = bbox_preds['size_residuals_' + self.primitive_mode].contiguous()\n    else:\n        primitive_semantic = None\n    semancitc_scores = bbox_preds['sem_cls_scores_' + self.primitive_mode].transpose(2, 1)\n    gt_primitive_mask = gt_primitive_mask / (gt_primitive_mask.sum() + 1e-06)\n    (center_loss, size_loss, sem_cls_loss) = self.compute_primitive_loss(primitive_center, primitive_semantic, semancitc_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask)\n    losses['center_loss_' + self.primitive_mode] = center_loss\n    losses['size_loss_' + self.primitive_mode] = size_loss\n    losses['sem_loss_' + self.primitive_mode] = sem_cls_loss\n    return losses",
            "def loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of Primitive Head.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask) = targets\n    losses = {}\n    pred_flag = bbox_preds['pred_flag_' + self.primitive_mode]\n    flag_loss = self.objectness_loss(pred_flag, gt_primitive_mask.long())\n    losses['flag_loss_' + self.primitive_mode] = flag_loss\n    vote_loss = self.vote_module.get_loss(bbox_preds['seed_points'], bbox_preds['vote_' + self.primitive_mode], bbox_preds['seed_indices'], point_mask, point_offset)\n    losses['vote_loss_' + self.primitive_mode] = vote_loss\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    primitive_center = bbox_preds['center_' + self.primitive_mode]\n    if self.primitive_mode != 'line':\n        primitive_semantic = bbox_preds['size_residuals_' + self.primitive_mode].contiguous()\n    else:\n        primitive_semantic = None\n    semancitc_scores = bbox_preds['sem_cls_scores_' + self.primitive_mode].transpose(2, 1)\n    gt_primitive_mask = gt_primitive_mask / (gt_primitive_mask.sum() + 1e-06)\n    (center_loss, size_loss, sem_cls_loss) = self.compute_primitive_loss(primitive_center, primitive_semantic, semancitc_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask)\n    losses['center_loss_' + self.primitive_mode] = center_loss\n    losses['size_loss_' + self.primitive_mode] = size_loss\n    losses['sem_loss_' + self.primitive_mode] = sem_cls_loss\n    return losses",
            "def loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of Primitive Head.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask) = targets\n    losses = {}\n    pred_flag = bbox_preds['pred_flag_' + self.primitive_mode]\n    flag_loss = self.objectness_loss(pred_flag, gt_primitive_mask.long())\n    losses['flag_loss_' + self.primitive_mode] = flag_loss\n    vote_loss = self.vote_module.get_loss(bbox_preds['seed_points'], bbox_preds['vote_' + self.primitive_mode], bbox_preds['seed_indices'], point_mask, point_offset)\n    losses['vote_loss_' + self.primitive_mode] = vote_loss\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    primitive_center = bbox_preds['center_' + self.primitive_mode]\n    if self.primitive_mode != 'line':\n        primitive_semantic = bbox_preds['size_residuals_' + self.primitive_mode].contiguous()\n    else:\n        primitive_semantic = None\n    semancitc_scores = bbox_preds['sem_cls_scores_' + self.primitive_mode].transpose(2, 1)\n    gt_primitive_mask = gt_primitive_mask / (gt_primitive_mask.sum() + 1e-06)\n    (center_loss, size_loss, sem_cls_loss) = self.compute_primitive_loss(primitive_center, primitive_semantic, semancitc_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask)\n    losses['center_loss_' + self.primitive_mode] = center_loss\n    losses['size_loss_' + self.primitive_mode] = size_loss\n    losses['sem_loss_' + self.primitive_mode] = sem_cls_loss\n    return losses",
            "def loss(self, bbox_preds, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, img_metas=None, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Compute loss.\\n\\n        Args:\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n            points (list[torch.Tensor]): Input points.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each sample.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each sample.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise\\n                semantic mask.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise\\n                instance mask.\\n            img_metas (list[dict]): Contain pcd and img's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict: Losses of Primitive Head.\\n        \"\n    targets = self.get_targets(points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask, bbox_preds)\n    (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask) = targets\n    losses = {}\n    pred_flag = bbox_preds['pred_flag_' + self.primitive_mode]\n    flag_loss = self.objectness_loss(pred_flag, gt_primitive_mask.long())\n    losses['flag_loss_' + self.primitive_mode] = flag_loss\n    vote_loss = self.vote_module.get_loss(bbox_preds['seed_points'], bbox_preds['vote_' + self.primitive_mode], bbox_preds['seed_indices'], point_mask, point_offset)\n    losses['vote_loss_' + self.primitive_mode] = vote_loss\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    primitive_center = bbox_preds['center_' + self.primitive_mode]\n    if self.primitive_mode != 'line':\n        primitive_semantic = bbox_preds['size_residuals_' + self.primitive_mode].contiguous()\n    else:\n        primitive_semantic = None\n    semancitc_scores = bbox_preds['sem_cls_scores_' + self.primitive_mode].transpose(2, 1)\n    gt_primitive_mask = gt_primitive_mask / (gt_primitive_mask.sum() + 1e-06)\n    (center_loss, size_loss, sem_cls_loss) = self.compute_primitive_loss(primitive_center, primitive_semantic, semancitc_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask)\n    losses['center_loss_' + self.primitive_mode] = center_loss\n    losses['size_loss_' + self.primitive_mode] = size_loss\n    losses['sem_loss_' + self.primitive_mode] = sem_cls_loss\n    return losses"
        ]
    },
    {
        "func_name": "get_targets",
        "original": "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    \"\"\"Generate targets of primitive head.\n\n        Args:\n            points (list[torch.Tensor]): Points of each batch.\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\n                bboxes of each batch.\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\n                label of each batch.\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\n                label of each batch.\n            bbox_preds (dict): Predictions from forward of primitive head.\n\n        Returns:\n            tuple[torch.Tensor]: Targets of primitive head.\n        \"\"\"\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    (point_mask, point_sem, point_offset) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask)\n    point_mask = torch.stack(point_mask)\n    point_sem = torch.stack(point_sem)\n    point_offset = torch.stack(point_offset)\n    batch_size = point_mask.shape[0]\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    num_seed = bbox_preds['seed_points'].shape[1]\n    seed_inds = bbox_preds['seed_indices'].long()\n    seed_inds_expand = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 3)\n    seed_gt_votes = torch.gather(point_offset, 1, seed_inds_expand)\n    seed_gt_votes += bbox_preds['seed_points']\n    gt_primitive_center = seed_gt_votes.view(batch_size * num_proposal, 1, 3)\n    seed_inds_expand_sem = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 4 + self.num_dims)\n    seed_gt_sem = torch.gather(point_sem, 1, seed_inds_expand_sem)\n    gt_primitive_semantic = seed_gt_sem[:, :, 3:3 + self.num_dims].view(batch_size * num_proposal, 1, self.num_dims).contiguous()\n    gt_sem_cls_label = seed_gt_sem[:, :, -1].long()\n    gt_votes_mask = torch.gather(point_mask, 1, seed_inds)\n    return (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_votes_mask)",
        "mutated": [
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n    'Generate targets of primitive head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    (point_mask, point_sem, point_offset) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask)\n    point_mask = torch.stack(point_mask)\n    point_sem = torch.stack(point_sem)\n    point_offset = torch.stack(point_offset)\n    batch_size = point_mask.shape[0]\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    num_seed = bbox_preds['seed_points'].shape[1]\n    seed_inds = bbox_preds['seed_indices'].long()\n    seed_inds_expand = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 3)\n    seed_gt_votes = torch.gather(point_offset, 1, seed_inds_expand)\n    seed_gt_votes += bbox_preds['seed_points']\n    gt_primitive_center = seed_gt_votes.view(batch_size * num_proposal, 1, 3)\n    seed_inds_expand_sem = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 4 + self.num_dims)\n    seed_gt_sem = torch.gather(point_sem, 1, seed_inds_expand_sem)\n    gt_primitive_semantic = seed_gt_sem[:, :, 3:3 + self.num_dims].view(batch_size * num_proposal, 1, self.num_dims).contiguous()\n    gt_sem_cls_label = seed_gt_sem[:, :, -1].long()\n    gt_votes_mask = torch.gather(point_mask, 1, seed_inds)\n    return (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_votes_mask)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate targets of primitive head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    (point_mask, point_sem, point_offset) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask)\n    point_mask = torch.stack(point_mask)\n    point_sem = torch.stack(point_sem)\n    point_offset = torch.stack(point_offset)\n    batch_size = point_mask.shape[0]\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    num_seed = bbox_preds['seed_points'].shape[1]\n    seed_inds = bbox_preds['seed_indices'].long()\n    seed_inds_expand = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 3)\n    seed_gt_votes = torch.gather(point_offset, 1, seed_inds_expand)\n    seed_gt_votes += bbox_preds['seed_points']\n    gt_primitive_center = seed_gt_votes.view(batch_size * num_proposal, 1, 3)\n    seed_inds_expand_sem = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 4 + self.num_dims)\n    seed_gt_sem = torch.gather(point_sem, 1, seed_inds_expand_sem)\n    gt_primitive_semantic = seed_gt_sem[:, :, 3:3 + self.num_dims].view(batch_size * num_proposal, 1, self.num_dims).contiguous()\n    gt_sem_cls_label = seed_gt_sem[:, :, -1].long()\n    gt_votes_mask = torch.gather(point_mask, 1, seed_inds)\n    return (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_votes_mask)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate targets of primitive head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    (point_mask, point_sem, point_offset) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask)\n    point_mask = torch.stack(point_mask)\n    point_sem = torch.stack(point_sem)\n    point_offset = torch.stack(point_offset)\n    batch_size = point_mask.shape[0]\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    num_seed = bbox_preds['seed_points'].shape[1]\n    seed_inds = bbox_preds['seed_indices'].long()\n    seed_inds_expand = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 3)\n    seed_gt_votes = torch.gather(point_offset, 1, seed_inds_expand)\n    seed_gt_votes += bbox_preds['seed_points']\n    gt_primitive_center = seed_gt_votes.view(batch_size * num_proposal, 1, 3)\n    seed_inds_expand_sem = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 4 + self.num_dims)\n    seed_gt_sem = torch.gather(point_sem, 1, seed_inds_expand_sem)\n    gt_primitive_semantic = seed_gt_sem[:, :, 3:3 + self.num_dims].view(batch_size * num_proposal, 1, self.num_dims).contiguous()\n    gt_sem_cls_label = seed_gt_sem[:, :, -1].long()\n    gt_votes_mask = torch.gather(point_mask, 1, seed_inds)\n    return (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_votes_mask)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate targets of primitive head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    (point_mask, point_sem, point_offset) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask)\n    point_mask = torch.stack(point_mask)\n    point_sem = torch.stack(point_sem)\n    point_offset = torch.stack(point_offset)\n    batch_size = point_mask.shape[0]\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    num_seed = bbox_preds['seed_points'].shape[1]\n    seed_inds = bbox_preds['seed_indices'].long()\n    seed_inds_expand = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 3)\n    seed_gt_votes = torch.gather(point_offset, 1, seed_inds_expand)\n    seed_gt_votes += bbox_preds['seed_points']\n    gt_primitive_center = seed_gt_votes.view(batch_size * num_proposal, 1, 3)\n    seed_inds_expand_sem = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 4 + self.num_dims)\n    seed_gt_sem = torch.gather(point_sem, 1, seed_inds_expand_sem)\n    gt_primitive_semantic = seed_gt_sem[:, :, 3:3 + self.num_dims].view(batch_size * num_proposal, 1, self.num_dims).contiguous()\n    gt_sem_cls_label = seed_gt_sem[:, :, -1].long()\n    gt_votes_mask = torch.gather(point_mask, 1, seed_inds)\n    return (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_votes_mask)",
            "def get_targets(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None, bbox_preds=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate targets of primitive head.\\n\\n        Args:\\n            points (list[torch.Tensor]): Points of each batch.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                bboxes of each batch.\\n            gt_labels_3d (list[torch.Tensor]): Labels of each batch.\\n            pts_semantic_mask (list[torch.Tensor]): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (list[torch.Tensor]): Point-wise instance\\n                label of each batch.\\n            bbox_preds (dict): Predictions from forward of primitive head.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    for index in range(len(gt_labels_3d)):\n        if len(gt_labels_3d[index]) == 0:\n            fake_box = gt_bboxes_3d[index].tensor.new_zeros(1, gt_bboxes_3d[index].tensor.shape[-1])\n            gt_bboxes_3d[index] = gt_bboxes_3d[index].new_box(fake_box)\n            gt_labels_3d[index] = gt_labels_3d[index].new_zeros(1)\n    if pts_semantic_mask is None:\n        pts_semantic_mask = [None for i in range(len(gt_labels_3d))]\n        pts_instance_mask = [None for i in range(len(gt_labels_3d))]\n    (point_mask, point_sem, point_offset) = multi_apply(self.get_targets_single, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask, pts_instance_mask)\n    point_mask = torch.stack(point_mask)\n    point_sem = torch.stack(point_sem)\n    point_offset = torch.stack(point_offset)\n    batch_size = point_mask.shape[0]\n    num_proposal = bbox_preds['aggregated_points_' + self.primitive_mode].shape[1]\n    num_seed = bbox_preds['seed_points'].shape[1]\n    seed_inds = bbox_preds['seed_indices'].long()\n    seed_inds_expand = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 3)\n    seed_gt_votes = torch.gather(point_offset, 1, seed_inds_expand)\n    seed_gt_votes += bbox_preds['seed_points']\n    gt_primitive_center = seed_gt_votes.view(batch_size * num_proposal, 1, 3)\n    seed_inds_expand_sem = seed_inds.view(batch_size, num_seed, 1).repeat(1, 1, 4 + self.num_dims)\n    seed_gt_sem = torch.gather(point_sem, 1, seed_inds_expand_sem)\n    gt_primitive_semantic = seed_gt_sem[:, :, 3:3 + self.num_dims].view(batch_size * num_proposal, 1, self.num_dims).contiguous()\n    gt_sem_cls_label = seed_gt_sem[:, :, -1].long()\n    gt_votes_mask = torch.gather(point_mask, 1, seed_inds)\n    return (point_mask, point_offset, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_votes_mask)"
        ]
    },
    {
        "func_name": "get_targets_single",
        "original": "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None):\n    \"\"\"Generate targets of primitive head for single batch.\n\n        Args:\n            points (torch.Tensor): Points of each batch.\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\n                boxes of each batch.\n            gt_labels_3d (torch.Tensor): Labels of each batch.\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\n                label of each batch.\n            pts_instance_mask (torch.Tensor): Point-wise instance\n                label of each batch.\n\n        Returns:\n            tuple[torch.Tensor]: Targets of primitive head.\n        \"\"\"\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    num_points = points.shape[0]\n    point_mask = points.new_zeros(num_points)\n    point_offset = points.new_zeros([num_points, 3])\n    point_sem = points.new_zeros([num_points, 3 + self.num_dims + 1])\n    if pts_semantic_mask is None or pts_instance_mask is None:\n        points2box_mask = gt_bboxes_3d.points_in_boxes_all(points)\n        assignment = points2box_mask.argmax(1)\n        background_mask = points2box_mask.max(1)[0] == 0\n        if pts_semantic_mask is None:\n            pts_semantic_mask = gt_labels_3d[assignment]\n            pts_semantic_mask[background_mask] = self.num_classes\n        if pts_instance_mask is None:\n            pts_instance_mask = assignment\n            pts_instance_mask[background_mask] = gt_labels_3d.shape[0]\n    instance_flag = torch.nonzero(pts_semantic_mask != self.num_classes, as_tuple=False).squeeze(1)\n    instance_labels = pts_instance_mask[instance_flag].unique()\n    with_yaw = gt_bboxes_3d.with_yaw\n    for (i, i_instance) in enumerate(instance_labels):\n        indices = instance_flag[pts_instance_mask[instance_flag] == i_instance]\n        coords = points[indices, :3]\n        cur_cls_label = pts_semantic_mask[indices][0]\n        cur_corners = gt_bboxes_3d.corners[i]\n        plane_lower_temp = points.new_tensor([0, 0, 1, -cur_corners[7, -1]])\n        upper_points = cur_corners[[1, 2, 5, 6]]\n        refined_distance = (upper_points * plane_lower_temp[:3]).sum(dim=1)\n        if self.check_horizon(upper_points) and plane_lower_temp[0] + plane_lower_temp[1] < self.train_cfg['lower_thresh']:\n            plane_lower = points.new_tensor([0, 0, 1, plane_lower_temp[-1]])\n            plane_upper = points.new_tensor([0, 0, 1, -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Only horizontal plane is support!')\n        if self.check_dist(plane_upper, upper_points) is False:\n            raise NotImplementedError('Mean distance to plane should be lower than thresh!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_lower, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='bottom')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='bottom')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='bottom')\n        (point2plane_dist, selected) = self.match_point2plane(plane_upper, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='top')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='top')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='top')\n        plane_left_temp = self._get_plane_fomulation(cur_corners[2] - cur_corners[3], cur_corners[3] - cur_corners[0], cur_corners[0])\n        right_points = cur_corners[[4, 5, 7, 6]]\n        plane_left_temp /= torch.norm(plane_left_temp[:3])\n        refined_distance = (right_points * plane_left_temp[:3]).sum(dim=1)\n        if plane_left_temp[2] < self.train_cfg['lower_thresh']:\n            plane_left = plane_left_temp\n            plane_right = points.new_tensor([plane_left_temp[0], plane_left_temp[1], plane_left_temp[2], -refined_distance.mean()])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_left, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='left')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='left')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='left')\n        (point2plane_dist, selected) = self.match_point2plane(plane_right, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='right')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='right')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='right')\n        plane_front_temp = self._get_plane_fomulation(cur_corners[0] - cur_corners[4], cur_corners[4] - cur_corners[5], cur_corners[5])\n        back_points = cur_corners[[3, 2, 7, 6]]\n        plane_front_temp /= torch.norm(plane_front_temp[:3])\n        refined_distance = (back_points * plane_front_temp[:3]).sum(dim=1)\n        if plane_front_temp[2] < self.train_cfg['lower_thresh']:\n            plane_front = plane_front_temp\n            plane_back = points.new_tensor([plane_front_temp[0], plane_front_temp[1], plane_front_temp[2], -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_front, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='front')\n        (point2plane_dist, selected) = self.match_point2plane(plane_back, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='back')\n    return (point_mask, point_sem, point_offset)",
        "mutated": [
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None):\n    if False:\n        i = 10\n    'Generate targets of primitive head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    num_points = points.shape[0]\n    point_mask = points.new_zeros(num_points)\n    point_offset = points.new_zeros([num_points, 3])\n    point_sem = points.new_zeros([num_points, 3 + self.num_dims + 1])\n    if pts_semantic_mask is None or pts_instance_mask is None:\n        points2box_mask = gt_bboxes_3d.points_in_boxes_all(points)\n        assignment = points2box_mask.argmax(1)\n        background_mask = points2box_mask.max(1)[0] == 0\n        if pts_semantic_mask is None:\n            pts_semantic_mask = gt_labels_3d[assignment]\n            pts_semantic_mask[background_mask] = self.num_classes\n        if pts_instance_mask is None:\n            pts_instance_mask = assignment\n            pts_instance_mask[background_mask] = gt_labels_3d.shape[0]\n    instance_flag = torch.nonzero(pts_semantic_mask != self.num_classes, as_tuple=False).squeeze(1)\n    instance_labels = pts_instance_mask[instance_flag].unique()\n    with_yaw = gt_bboxes_3d.with_yaw\n    for (i, i_instance) in enumerate(instance_labels):\n        indices = instance_flag[pts_instance_mask[instance_flag] == i_instance]\n        coords = points[indices, :3]\n        cur_cls_label = pts_semantic_mask[indices][0]\n        cur_corners = gt_bboxes_3d.corners[i]\n        plane_lower_temp = points.new_tensor([0, 0, 1, -cur_corners[7, -1]])\n        upper_points = cur_corners[[1, 2, 5, 6]]\n        refined_distance = (upper_points * plane_lower_temp[:3]).sum(dim=1)\n        if self.check_horizon(upper_points) and plane_lower_temp[0] + plane_lower_temp[1] < self.train_cfg['lower_thresh']:\n            plane_lower = points.new_tensor([0, 0, 1, plane_lower_temp[-1]])\n            plane_upper = points.new_tensor([0, 0, 1, -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Only horizontal plane is support!')\n        if self.check_dist(plane_upper, upper_points) is False:\n            raise NotImplementedError('Mean distance to plane should be lower than thresh!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_lower, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='bottom')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='bottom')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='bottom')\n        (point2plane_dist, selected) = self.match_point2plane(plane_upper, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='top')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='top')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='top')\n        plane_left_temp = self._get_plane_fomulation(cur_corners[2] - cur_corners[3], cur_corners[3] - cur_corners[0], cur_corners[0])\n        right_points = cur_corners[[4, 5, 7, 6]]\n        plane_left_temp /= torch.norm(plane_left_temp[:3])\n        refined_distance = (right_points * plane_left_temp[:3]).sum(dim=1)\n        if plane_left_temp[2] < self.train_cfg['lower_thresh']:\n            plane_left = plane_left_temp\n            plane_right = points.new_tensor([plane_left_temp[0], plane_left_temp[1], plane_left_temp[2], -refined_distance.mean()])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_left, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='left')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='left')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='left')\n        (point2plane_dist, selected) = self.match_point2plane(plane_right, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='right')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='right')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='right')\n        plane_front_temp = self._get_plane_fomulation(cur_corners[0] - cur_corners[4], cur_corners[4] - cur_corners[5], cur_corners[5])\n        back_points = cur_corners[[3, 2, 7, 6]]\n        plane_front_temp /= torch.norm(plane_front_temp[:3])\n        refined_distance = (back_points * plane_front_temp[:3]).sum(dim=1)\n        if plane_front_temp[2] < self.train_cfg['lower_thresh']:\n            plane_front = plane_front_temp\n            plane_back = points.new_tensor([plane_front_temp[0], plane_front_temp[1], plane_front_temp[2], -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_front, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='front')\n        (point2plane_dist, selected) = self.match_point2plane(plane_back, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='back')\n    return (point_mask, point_sem, point_offset)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate targets of primitive head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    num_points = points.shape[0]\n    point_mask = points.new_zeros(num_points)\n    point_offset = points.new_zeros([num_points, 3])\n    point_sem = points.new_zeros([num_points, 3 + self.num_dims + 1])\n    if pts_semantic_mask is None or pts_instance_mask is None:\n        points2box_mask = gt_bboxes_3d.points_in_boxes_all(points)\n        assignment = points2box_mask.argmax(1)\n        background_mask = points2box_mask.max(1)[0] == 0\n        if pts_semantic_mask is None:\n            pts_semantic_mask = gt_labels_3d[assignment]\n            pts_semantic_mask[background_mask] = self.num_classes\n        if pts_instance_mask is None:\n            pts_instance_mask = assignment\n            pts_instance_mask[background_mask] = gt_labels_3d.shape[0]\n    instance_flag = torch.nonzero(pts_semantic_mask != self.num_classes, as_tuple=False).squeeze(1)\n    instance_labels = pts_instance_mask[instance_flag].unique()\n    with_yaw = gt_bboxes_3d.with_yaw\n    for (i, i_instance) in enumerate(instance_labels):\n        indices = instance_flag[pts_instance_mask[instance_flag] == i_instance]\n        coords = points[indices, :3]\n        cur_cls_label = pts_semantic_mask[indices][0]\n        cur_corners = gt_bboxes_3d.corners[i]\n        plane_lower_temp = points.new_tensor([0, 0, 1, -cur_corners[7, -1]])\n        upper_points = cur_corners[[1, 2, 5, 6]]\n        refined_distance = (upper_points * plane_lower_temp[:3]).sum(dim=1)\n        if self.check_horizon(upper_points) and plane_lower_temp[0] + plane_lower_temp[1] < self.train_cfg['lower_thresh']:\n            plane_lower = points.new_tensor([0, 0, 1, plane_lower_temp[-1]])\n            plane_upper = points.new_tensor([0, 0, 1, -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Only horizontal plane is support!')\n        if self.check_dist(plane_upper, upper_points) is False:\n            raise NotImplementedError('Mean distance to plane should be lower than thresh!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_lower, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='bottom')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='bottom')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='bottom')\n        (point2plane_dist, selected) = self.match_point2plane(plane_upper, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='top')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='top')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='top')\n        plane_left_temp = self._get_plane_fomulation(cur_corners[2] - cur_corners[3], cur_corners[3] - cur_corners[0], cur_corners[0])\n        right_points = cur_corners[[4, 5, 7, 6]]\n        plane_left_temp /= torch.norm(plane_left_temp[:3])\n        refined_distance = (right_points * plane_left_temp[:3]).sum(dim=1)\n        if plane_left_temp[2] < self.train_cfg['lower_thresh']:\n            plane_left = plane_left_temp\n            plane_right = points.new_tensor([plane_left_temp[0], plane_left_temp[1], plane_left_temp[2], -refined_distance.mean()])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_left, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='left')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='left')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='left')\n        (point2plane_dist, selected) = self.match_point2plane(plane_right, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='right')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='right')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='right')\n        plane_front_temp = self._get_plane_fomulation(cur_corners[0] - cur_corners[4], cur_corners[4] - cur_corners[5], cur_corners[5])\n        back_points = cur_corners[[3, 2, 7, 6]]\n        plane_front_temp /= torch.norm(plane_front_temp[:3])\n        refined_distance = (back_points * plane_front_temp[:3]).sum(dim=1)\n        if plane_front_temp[2] < self.train_cfg['lower_thresh']:\n            plane_front = plane_front_temp\n            plane_back = points.new_tensor([plane_front_temp[0], plane_front_temp[1], plane_front_temp[2], -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_front, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='front')\n        (point2plane_dist, selected) = self.match_point2plane(plane_back, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='back')\n    return (point_mask, point_sem, point_offset)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate targets of primitive head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    num_points = points.shape[0]\n    point_mask = points.new_zeros(num_points)\n    point_offset = points.new_zeros([num_points, 3])\n    point_sem = points.new_zeros([num_points, 3 + self.num_dims + 1])\n    if pts_semantic_mask is None or pts_instance_mask is None:\n        points2box_mask = gt_bboxes_3d.points_in_boxes_all(points)\n        assignment = points2box_mask.argmax(1)\n        background_mask = points2box_mask.max(1)[0] == 0\n        if pts_semantic_mask is None:\n            pts_semantic_mask = gt_labels_3d[assignment]\n            pts_semantic_mask[background_mask] = self.num_classes\n        if pts_instance_mask is None:\n            pts_instance_mask = assignment\n            pts_instance_mask[background_mask] = gt_labels_3d.shape[0]\n    instance_flag = torch.nonzero(pts_semantic_mask != self.num_classes, as_tuple=False).squeeze(1)\n    instance_labels = pts_instance_mask[instance_flag].unique()\n    with_yaw = gt_bboxes_3d.with_yaw\n    for (i, i_instance) in enumerate(instance_labels):\n        indices = instance_flag[pts_instance_mask[instance_flag] == i_instance]\n        coords = points[indices, :3]\n        cur_cls_label = pts_semantic_mask[indices][0]\n        cur_corners = gt_bboxes_3d.corners[i]\n        plane_lower_temp = points.new_tensor([0, 0, 1, -cur_corners[7, -1]])\n        upper_points = cur_corners[[1, 2, 5, 6]]\n        refined_distance = (upper_points * plane_lower_temp[:3]).sum(dim=1)\n        if self.check_horizon(upper_points) and plane_lower_temp[0] + plane_lower_temp[1] < self.train_cfg['lower_thresh']:\n            plane_lower = points.new_tensor([0, 0, 1, plane_lower_temp[-1]])\n            plane_upper = points.new_tensor([0, 0, 1, -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Only horizontal plane is support!')\n        if self.check_dist(plane_upper, upper_points) is False:\n            raise NotImplementedError('Mean distance to plane should be lower than thresh!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_lower, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='bottom')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='bottom')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='bottom')\n        (point2plane_dist, selected) = self.match_point2plane(plane_upper, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='top')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='top')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='top')\n        plane_left_temp = self._get_plane_fomulation(cur_corners[2] - cur_corners[3], cur_corners[3] - cur_corners[0], cur_corners[0])\n        right_points = cur_corners[[4, 5, 7, 6]]\n        plane_left_temp /= torch.norm(plane_left_temp[:3])\n        refined_distance = (right_points * plane_left_temp[:3]).sum(dim=1)\n        if plane_left_temp[2] < self.train_cfg['lower_thresh']:\n            plane_left = plane_left_temp\n            plane_right = points.new_tensor([plane_left_temp[0], plane_left_temp[1], plane_left_temp[2], -refined_distance.mean()])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_left, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='left')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='left')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='left')\n        (point2plane_dist, selected) = self.match_point2plane(plane_right, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='right')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='right')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='right')\n        plane_front_temp = self._get_plane_fomulation(cur_corners[0] - cur_corners[4], cur_corners[4] - cur_corners[5], cur_corners[5])\n        back_points = cur_corners[[3, 2, 7, 6]]\n        plane_front_temp /= torch.norm(plane_front_temp[:3])\n        refined_distance = (back_points * plane_front_temp[:3]).sum(dim=1)\n        if plane_front_temp[2] < self.train_cfg['lower_thresh']:\n            plane_front = plane_front_temp\n            plane_back = points.new_tensor([plane_front_temp[0], plane_front_temp[1], plane_front_temp[2], -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_front, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='front')\n        (point2plane_dist, selected) = self.match_point2plane(plane_back, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='back')\n    return (point_mask, point_sem, point_offset)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate targets of primitive head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    num_points = points.shape[0]\n    point_mask = points.new_zeros(num_points)\n    point_offset = points.new_zeros([num_points, 3])\n    point_sem = points.new_zeros([num_points, 3 + self.num_dims + 1])\n    if pts_semantic_mask is None or pts_instance_mask is None:\n        points2box_mask = gt_bboxes_3d.points_in_boxes_all(points)\n        assignment = points2box_mask.argmax(1)\n        background_mask = points2box_mask.max(1)[0] == 0\n        if pts_semantic_mask is None:\n            pts_semantic_mask = gt_labels_3d[assignment]\n            pts_semantic_mask[background_mask] = self.num_classes\n        if pts_instance_mask is None:\n            pts_instance_mask = assignment\n            pts_instance_mask[background_mask] = gt_labels_3d.shape[0]\n    instance_flag = torch.nonzero(pts_semantic_mask != self.num_classes, as_tuple=False).squeeze(1)\n    instance_labels = pts_instance_mask[instance_flag].unique()\n    with_yaw = gt_bboxes_3d.with_yaw\n    for (i, i_instance) in enumerate(instance_labels):\n        indices = instance_flag[pts_instance_mask[instance_flag] == i_instance]\n        coords = points[indices, :3]\n        cur_cls_label = pts_semantic_mask[indices][0]\n        cur_corners = gt_bboxes_3d.corners[i]\n        plane_lower_temp = points.new_tensor([0, 0, 1, -cur_corners[7, -1]])\n        upper_points = cur_corners[[1, 2, 5, 6]]\n        refined_distance = (upper_points * plane_lower_temp[:3]).sum(dim=1)\n        if self.check_horizon(upper_points) and plane_lower_temp[0] + plane_lower_temp[1] < self.train_cfg['lower_thresh']:\n            plane_lower = points.new_tensor([0, 0, 1, plane_lower_temp[-1]])\n            plane_upper = points.new_tensor([0, 0, 1, -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Only horizontal plane is support!')\n        if self.check_dist(plane_upper, upper_points) is False:\n            raise NotImplementedError('Mean distance to plane should be lower than thresh!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_lower, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='bottom')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='bottom')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='bottom')\n        (point2plane_dist, selected) = self.match_point2plane(plane_upper, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='top')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='top')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='top')\n        plane_left_temp = self._get_plane_fomulation(cur_corners[2] - cur_corners[3], cur_corners[3] - cur_corners[0], cur_corners[0])\n        right_points = cur_corners[[4, 5, 7, 6]]\n        plane_left_temp /= torch.norm(plane_left_temp[:3])\n        refined_distance = (right_points * plane_left_temp[:3]).sum(dim=1)\n        if plane_left_temp[2] < self.train_cfg['lower_thresh']:\n            plane_left = plane_left_temp\n            plane_right = points.new_tensor([plane_left_temp[0], plane_left_temp[1], plane_left_temp[2], -refined_distance.mean()])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_left, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='left')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='left')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='left')\n        (point2plane_dist, selected) = self.match_point2plane(plane_right, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='right')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='right')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='right')\n        plane_front_temp = self._get_plane_fomulation(cur_corners[0] - cur_corners[4], cur_corners[4] - cur_corners[5], cur_corners[5])\n        back_points = cur_corners[[3, 2, 7, 6]]\n        plane_front_temp /= torch.norm(plane_front_temp[:3])\n        refined_distance = (back_points * plane_front_temp[:3]).sum(dim=1)\n        if plane_front_temp[2] < self.train_cfg['lower_thresh']:\n            plane_front = plane_front_temp\n            plane_back = points.new_tensor([plane_front_temp[0], plane_front_temp[1], plane_front_temp[2], -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_front, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='front')\n        (point2plane_dist, selected) = self.match_point2plane(plane_back, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='back')\n    return (point_mask, point_sem, point_offset)",
            "def get_targets_single(self, points, gt_bboxes_3d, gt_labels_3d, pts_semantic_mask=None, pts_instance_mask=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate targets of primitive head for single batch.\\n\\n        Args:\\n            points (torch.Tensor): Points of each batch.\\n            gt_bboxes_3d (:obj:`BaseInstance3DBoxes`): Ground truth\\n                boxes of each batch.\\n            gt_labels_3d (torch.Tensor): Labels of each batch.\\n            pts_semantic_mask (torch.Tensor): Point-wise semantic\\n                label of each batch.\\n            pts_instance_mask (torch.Tensor): Point-wise instance\\n                label of each batch.\\n\\n        Returns:\\n            tuple[torch.Tensor]: Targets of primitive head.\\n        '\n    gt_bboxes_3d = gt_bboxes_3d.to(points.device)\n    num_points = points.shape[0]\n    point_mask = points.new_zeros(num_points)\n    point_offset = points.new_zeros([num_points, 3])\n    point_sem = points.new_zeros([num_points, 3 + self.num_dims + 1])\n    if pts_semantic_mask is None or pts_instance_mask is None:\n        points2box_mask = gt_bboxes_3d.points_in_boxes_all(points)\n        assignment = points2box_mask.argmax(1)\n        background_mask = points2box_mask.max(1)[0] == 0\n        if pts_semantic_mask is None:\n            pts_semantic_mask = gt_labels_3d[assignment]\n            pts_semantic_mask[background_mask] = self.num_classes\n        if pts_instance_mask is None:\n            pts_instance_mask = assignment\n            pts_instance_mask[background_mask] = gt_labels_3d.shape[0]\n    instance_flag = torch.nonzero(pts_semantic_mask != self.num_classes, as_tuple=False).squeeze(1)\n    instance_labels = pts_instance_mask[instance_flag].unique()\n    with_yaw = gt_bboxes_3d.with_yaw\n    for (i, i_instance) in enumerate(instance_labels):\n        indices = instance_flag[pts_instance_mask[instance_flag] == i_instance]\n        coords = points[indices, :3]\n        cur_cls_label = pts_semantic_mask[indices][0]\n        cur_corners = gt_bboxes_3d.corners[i]\n        plane_lower_temp = points.new_tensor([0, 0, 1, -cur_corners[7, -1]])\n        upper_points = cur_corners[[1, 2, 5, 6]]\n        refined_distance = (upper_points * plane_lower_temp[:3]).sum(dim=1)\n        if self.check_horizon(upper_points) and plane_lower_temp[0] + plane_lower_temp[1] < self.train_cfg['lower_thresh']:\n            plane_lower = points.new_tensor([0, 0, 1, plane_lower_temp[-1]])\n            plane_upper = points.new_tensor([0, 0, 1, -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Only horizontal plane is support!')\n        if self.check_dist(plane_upper, upper_points) is False:\n            raise NotImplementedError('Mean distance to plane should be lower than thresh!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_lower, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='bottom')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='bottom')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='bottom')\n        (point2plane_dist, selected) = self.match_point2plane(plane_upper, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='top')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching, cur_corners, [1, 1, 0, 0], with_yaw, mode='top')\n        if self.primitive_mode == 'z' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='top')\n        plane_left_temp = self._get_plane_fomulation(cur_corners[2] - cur_corners[3], cur_corners[3] - cur_corners[0], cur_corners[0])\n        right_points = cur_corners[[4, 5, 7, 6]]\n        plane_left_temp /= torch.norm(plane_left_temp[:3])\n        refined_distance = (right_points * plane_left_temp[:3]).sum(dim=1)\n        if plane_left_temp[2] < self.train_cfg['lower_thresh']:\n            plane_left = plane_left_temp\n            plane_right = points.new_tensor([plane_left_temp[0], plane_left_temp[1], plane_left_temp[2], -refined_distance.mean()])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_left, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='left')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='left')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='left')\n        (point2plane_dist, selected) = self.match_point2plane(plane_right, coords)\n        if self.primitive_mode == 'line':\n            point2line_matching = self.match_point2line(coords[selected], cur_corners, with_yaw, mode='right')\n            (point_mask, point_offset, point_sem) = self._assign_primitive_line_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, point2line_matching[2:], cur_corners, [2, 2], with_yaw, mode='right')\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='right')\n        plane_front_temp = self._get_plane_fomulation(cur_corners[0] - cur_corners[4], cur_corners[4] - cur_corners[5], cur_corners[5])\n        back_points = cur_corners[[3, 2, 7, 6]]\n        plane_front_temp /= torch.norm(plane_front_temp[:3])\n        refined_distance = (back_points * plane_front_temp[:3]).sum(dim=1)\n        if plane_front_temp[2] < self.train_cfg['lower_thresh']:\n            plane_front = plane_front_temp\n            plane_back = points.new_tensor([plane_front_temp[0], plane_front_temp[1], plane_front_temp[2], -torch.mean(refined_distance)])\n        else:\n            raise NotImplementedError('Normal vector of the plane should be horizontal!')\n        (point2plane_dist, selected) = self.match_point2plane(plane_front, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='front')\n        (point2plane_dist, selected) = self.match_point2plane(plane_back, coords)\n        if self.primitive_mode == 'xy' and selected.sum() > self.train_cfg['num_point'] and (point2plane_dist[selected].var() < self.train_cfg['var_thresh']):\n            (point_mask, point_offset, point_sem) = self._assign_primitive_surface_targets(point_mask, point_offset, point_sem, coords[selected], indices[selected], cur_cls_label, cur_corners, with_yaw, mode='back')\n    return (point_mask, point_sem, point_offset)"
        ]
    },
    {
        "func_name": "primitive_decode_scores",
        "original": "def primitive_decode_scores(self, predictions, aggregated_points):\n    \"\"\"Decode predicted parts to primitive head.\n\n        Args:\n            predictions (torch.Tensor): primitive pridictions of each batch.\n            aggregated_points (torch.Tensor): The aggregated points\n                of vote stage.\n\n        Returns:\n            Dict: Predictions of primitive head, including center,\n                semantic size and semantic scores.\n        \"\"\"\n    ret_dict = {}\n    pred_transposed = predictions.transpose(2, 1)\n    center = aggregated_points + pred_transposed[:, :, 0:3]\n    ret_dict['center_' + self.primitive_mode] = center\n    if self.primitive_mode in ['z', 'xy']:\n        ret_dict['size_residuals_' + self.primitive_mode] = pred_transposed[:, :, 3:3 + self.num_dims]\n    ret_dict['sem_cls_scores_' + self.primitive_mode] = pred_transposed[:, :, 3 + self.num_dims:]\n    return ret_dict",
        "mutated": [
            "def primitive_decode_scores(self, predictions, aggregated_points):\n    if False:\n        i = 10\n    'Decode predicted parts to primitive head.\\n\\n        Args:\\n            predictions (torch.Tensor): primitive pridictions of each batch.\\n            aggregated_points (torch.Tensor): The aggregated points\\n                of vote stage.\\n\\n        Returns:\\n            Dict: Predictions of primitive head, including center,\\n                semantic size and semantic scores.\\n        '\n    ret_dict = {}\n    pred_transposed = predictions.transpose(2, 1)\n    center = aggregated_points + pred_transposed[:, :, 0:3]\n    ret_dict['center_' + self.primitive_mode] = center\n    if self.primitive_mode in ['z', 'xy']:\n        ret_dict['size_residuals_' + self.primitive_mode] = pred_transposed[:, :, 3:3 + self.num_dims]\n    ret_dict['sem_cls_scores_' + self.primitive_mode] = pred_transposed[:, :, 3 + self.num_dims:]\n    return ret_dict",
            "def primitive_decode_scores(self, predictions, aggregated_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Decode predicted parts to primitive head.\\n\\n        Args:\\n            predictions (torch.Tensor): primitive pridictions of each batch.\\n            aggregated_points (torch.Tensor): The aggregated points\\n                of vote stage.\\n\\n        Returns:\\n            Dict: Predictions of primitive head, including center,\\n                semantic size and semantic scores.\\n        '\n    ret_dict = {}\n    pred_transposed = predictions.transpose(2, 1)\n    center = aggregated_points + pred_transposed[:, :, 0:3]\n    ret_dict['center_' + self.primitive_mode] = center\n    if self.primitive_mode in ['z', 'xy']:\n        ret_dict['size_residuals_' + self.primitive_mode] = pred_transposed[:, :, 3:3 + self.num_dims]\n    ret_dict['sem_cls_scores_' + self.primitive_mode] = pred_transposed[:, :, 3 + self.num_dims:]\n    return ret_dict",
            "def primitive_decode_scores(self, predictions, aggregated_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Decode predicted parts to primitive head.\\n\\n        Args:\\n            predictions (torch.Tensor): primitive pridictions of each batch.\\n            aggregated_points (torch.Tensor): The aggregated points\\n                of vote stage.\\n\\n        Returns:\\n            Dict: Predictions of primitive head, including center,\\n                semantic size and semantic scores.\\n        '\n    ret_dict = {}\n    pred_transposed = predictions.transpose(2, 1)\n    center = aggregated_points + pred_transposed[:, :, 0:3]\n    ret_dict['center_' + self.primitive_mode] = center\n    if self.primitive_mode in ['z', 'xy']:\n        ret_dict['size_residuals_' + self.primitive_mode] = pred_transposed[:, :, 3:3 + self.num_dims]\n    ret_dict['sem_cls_scores_' + self.primitive_mode] = pred_transposed[:, :, 3 + self.num_dims:]\n    return ret_dict",
            "def primitive_decode_scores(self, predictions, aggregated_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Decode predicted parts to primitive head.\\n\\n        Args:\\n            predictions (torch.Tensor): primitive pridictions of each batch.\\n            aggregated_points (torch.Tensor): The aggregated points\\n                of vote stage.\\n\\n        Returns:\\n            Dict: Predictions of primitive head, including center,\\n                semantic size and semantic scores.\\n        '\n    ret_dict = {}\n    pred_transposed = predictions.transpose(2, 1)\n    center = aggregated_points + pred_transposed[:, :, 0:3]\n    ret_dict['center_' + self.primitive_mode] = center\n    if self.primitive_mode in ['z', 'xy']:\n        ret_dict['size_residuals_' + self.primitive_mode] = pred_transposed[:, :, 3:3 + self.num_dims]\n    ret_dict['sem_cls_scores_' + self.primitive_mode] = pred_transposed[:, :, 3 + self.num_dims:]\n    return ret_dict",
            "def primitive_decode_scores(self, predictions, aggregated_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Decode predicted parts to primitive head.\\n\\n        Args:\\n            predictions (torch.Tensor): primitive pridictions of each batch.\\n            aggregated_points (torch.Tensor): The aggregated points\\n                of vote stage.\\n\\n        Returns:\\n            Dict: Predictions of primitive head, including center,\\n                semantic size and semantic scores.\\n        '\n    ret_dict = {}\n    pred_transposed = predictions.transpose(2, 1)\n    center = aggregated_points + pred_transposed[:, :, 0:3]\n    ret_dict['center_' + self.primitive_mode] = center\n    if self.primitive_mode in ['z', 'xy']:\n        ret_dict['size_residuals_' + self.primitive_mode] = pred_transposed[:, :, 3:3 + self.num_dims]\n    ret_dict['sem_cls_scores_' + self.primitive_mode] = pred_transposed[:, :, 3 + self.num_dims:]\n    return ret_dict"
        ]
    },
    {
        "func_name": "check_horizon",
        "original": "def check_horizon(self, points):\n    \"\"\"Check whether is a horizontal plane.\n\n        Args:\n            points (torch.Tensor): Points of input.\n\n        Returns:\n            Bool: Flag of result.\n        \"\"\"\n    return points[0][-1] == points[1][-1] and points[1][-1] == points[2][-1] and (points[2][-1] == points[3][-1])",
        "mutated": [
            "def check_horizon(self, points):\n    if False:\n        i = 10\n    'Check whether is a horizontal plane.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Bool: Flag of result.\\n        '\n    return points[0][-1] == points[1][-1] and points[1][-1] == points[2][-1] and (points[2][-1] == points[3][-1])",
            "def check_horizon(self, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Check whether is a horizontal plane.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Bool: Flag of result.\\n        '\n    return points[0][-1] == points[1][-1] and points[1][-1] == points[2][-1] and (points[2][-1] == points[3][-1])",
            "def check_horizon(self, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Check whether is a horizontal plane.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Bool: Flag of result.\\n        '\n    return points[0][-1] == points[1][-1] and points[1][-1] == points[2][-1] and (points[2][-1] == points[3][-1])",
            "def check_horizon(self, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Check whether is a horizontal plane.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Bool: Flag of result.\\n        '\n    return points[0][-1] == points[1][-1] and points[1][-1] == points[2][-1] and (points[2][-1] == points[3][-1])",
            "def check_horizon(self, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Check whether is a horizontal plane.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Bool: Flag of result.\\n        '\n    return points[0][-1] == points[1][-1] and points[1][-1] == points[2][-1] and (points[2][-1] == points[3][-1])"
        ]
    },
    {
        "func_name": "check_dist",
        "original": "def check_dist(self, plane_equ, points):\n    \"\"\"Whether the mean of points to plane distance is lower than thresh.\n\n        Args:\n            plane_equ (torch.Tensor): Plane to be checked.\n            points (torch.Tensor): Points to be checked.\n\n        Returns:\n            Tuple: Flag of result.\n        \"\"\"\n    return (points[:, 2] + plane_equ[-1]).sum() / 4.0 < self.train_cfg['lower_thresh']",
        "mutated": [
            "def check_dist(self, plane_equ, points):\n    if False:\n        i = 10\n    'Whether the mean of points to plane distance is lower than thresh.\\n\\n        Args:\\n            plane_equ (torch.Tensor): Plane to be checked.\\n            points (torch.Tensor): Points to be checked.\\n\\n        Returns:\\n            Tuple: Flag of result.\\n        '\n    return (points[:, 2] + plane_equ[-1]).sum() / 4.0 < self.train_cfg['lower_thresh']",
            "def check_dist(self, plane_equ, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Whether the mean of points to plane distance is lower than thresh.\\n\\n        Args:\\n            plane_equ (torch.Tensor): Plane to be checked.\\n            points (torch.Tensor): Points to be checked.\\n\\n        Returns:\\n            Tuple: Flag of result.\\n        '\n    return (points[:, 2] + plane_equ[-1]).sum() / 4.0 < self.train_cfg['lower_thresh']",
            "def check_dist(self, plane_equ, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Whether the mean of points to plane distance is lower than thresh.\\n\\n        Args:\\n            plane_equ (torch.Tensor): Plane to be checked.\\n            points (torch.Tensor): Points to be checked.\\n\\n        Returns:\\n            Tuple: Flag of result.\\n        '\n    return (points[:, 2] + plane_equ[-1]).sum() / 4.0 < self.train_cfg['lower_thresh']",
            "def check_dist(self, plane_equ, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Whether the mean of points to plane distance is lower than thresh.\\n\\n        Args:\\n            plane_equ (torch.Tensor): Plane to be checked.\\n            points (torch.Tensor): Points to be checked.\\n\\n        Returns:\\n            Tuple: Flag of result.\\n        '\n    return (points[:, 2] + plane_equ[-1]).sum() / 4.0 < self.train_cfg['lower_thresh']",
            "def check_dist(self, plane_equ, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Whether the mean of points to plane distance is lower than thresh.\\n\\n        Args:\\n            plane_equ (torch.Tensor): Plane to be checked.\\n            points (torch.Tensor): Points to be checked.\\n\\n        Returns:\\n            Tuple: Flag of result.\\n        '\n    return (points[:, 2] + plane_equ[-1]).sum() / 4.0 < self.train_cfg['lower_thresh']"
        ]
    },
    {
        "func_name": "point2line_dist",
        "original": "def point2line_dist(self, points, pts_a, pts_b):\n    \"\"\"Calculate the distance from point to line.\n\n        Args:\n            points (torch.Tensor): Points of input.\n            pts_a (torch.Tensor): Point on the specific line.\n            pts_b (torch.Tensor): Point on the specific line.\n\n        Returns:\n            torch.Tensor: Distance between each point to line.\n        \"\"\"\n    line_a2b = pts_b - pts_a\n    line_a2pts = points - pts_a\n    length = (line_a2pts * line_a2b.view(1, 3)).sum(1) / line_a2b.norm()\n    dist = (line_a2pts.norm(dim=1) ** 2 - length ** 2).sqrt()\n    return dist",
        "mutated": [
            "def point2line_dist(self, points, pts_a, pts_b):\n    if False:\n        i = 10\n    'Calculate the distance from point to line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            pts_a (torch.Tensor): Point on the specific line.\\n            pts_b (torch.Tensor): Point on the specific line.\\n\\n        Returns:\\n            torch.Tensor: Distance between each point to line.\\n        '\n    line_a2b = pts_b - pts_a\n    line_a2pts = points - pts_a\n    length = (line_a2pts * line_a2b.view(1, 3)).sum(1) / line_a2b.norm()\n    dist = (line_a2pts.norm(dim=1) ** 2 - length ** 2).sqrt()\n    return dist",
            "def point2line_dist(self, points, pts_a, pts_b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate the distance from point to line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            pts_a (torch.Tensor): Point on the specific line.\\n            pts_b (torch.Tensor): Point on the specific line.\\n\\n        Returns:\\n            torch.Tensor: Distance between each point to line.\\n        '\n    line_a2b = pts_b - pts_a\n    line_a2pts = points - pts_a\n    length = (line_a2pts * line_a2b.view(1, 3)).sum(1) / line_a2b.norm()\n    dist = (line_a2pts.norm(dim=1) ** 2 - length ** 2).sqrt()\n    return dist",
            "def point2line_dist(self, points, pts_a, pts_b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate the distance from point to line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            pts_a (torch.Tensor): Point on the specific line.\\n            pts_b (torch.Tensor): Point on the specific line.\\n\\n        Returns:\\n            torch.Tensor: Distance between each point to line.\\n        '\n    line_a2b = pts_b - pts_a\n    line_a2pts = points - pts_a\n    length = (line_a2pts * line_a2b.view(1, 3)).sum(1) / line_a2b.norm()\n    dist = (line_a2pts.norm(dim=1) ** 2 - length ** 2).sqrt()\n    return dist",
            "def point2line_dist(self, points, pts_a, pts_b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate the distance from point to line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            pts_a (torch.Tensor): Point on the specific line.\\n            pts_b (torch.Tensor): Point on the specific line.\\n\\n        Returns:\\n            torch.Tensor: Distance between each point to line.\\n        '\n    line_a2b = pts_b - pts_a\n    line_a2pts = points - pts_a\n    length = (line_a2pts * line_a2b.view(1, 3)).sum(1) / line_a2b.norm()\n    dist = (line_a2pts.norm(dim=1) ** 2 - length ** 2).sqrt()\n    return dist",
            "def point2line_dist(self, points, pts_a, pts_b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate the distance from point to line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            pts_a (torch.Tensor): Point on the specific line.\\n            pts_b (torch.Tensor): Point on the specific line.\\n\\n        Returns:\\n            torch.Tensor: Distance between each point to line.\\n        '\n    line_a2b = pts_b - pts_a\n    line_a2pts = points - pts_a\n    length = (line_a2pts * line_a2b.view(1, 3)).sum(1) / line_a2b.norm()\n    dist = (line_a2pts.norm(dim=1) ** 2 - length ** 2).sqrt()\n    return dist"
        ]
    },
    {
        "func_name": "match_point2line",
        "original": "def match_point2line(self, points, corners, with_yaw, mode='bottom'):\n    \"\"\"Match points to corresponding line.\n\n        Args:\n            points (torch.Tensor): Points of input.\n            corners (torch.Tensor): Eight corners of a bounding box.\n            with_yaw (Bool): Whether the boundind box is with rotation.\n            mode (str, optional): Specify which line should be matched,\n                available mode are ('bottom', 'top', 'left', 'right').\n                Defaults to 'bottom'.\n\n        Returns:\n            Tuple: Flag of matching correspondence.\n        \"\"\"\n    if with_yaw:\n        corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2], [0, 1], [3, 2]], 'right': [[4, 5], [7, 6], [4, 5], [7, 6]]}\n        selected_list = []\n        for pair_index in corners_pair[mode]:\n            selected = self.point2line_dist(points, corners[pair_index[0]], corners[pair_index[1]]) < self.train_cfg['line_thresh']\n            selected_list.append(selected)\n    else:\n        (xmin, ymin, _) = corners.min(0)[0]\n        (xmax, ymax, _) = corners.max(0)[0]\n        sel1 = torch.abs(points[:, 0] - xmin) < self.train_cfg['line_thresh']\n        sel2 = torch.abs(points[:, 0] - xmax) < self.train_cfg['line_thresh']\n        sel3 = torch.abs(points[:, 1] - ymin) < self.train_cfg['line_thresh']\n        sel4 = torch.abs(points[:, 1] - ymax) < self.train_cfg['line_thresh']\n        selected_list = [sel1, sel2, sel3, sel4]\n    return selected_list",
        "mutated": [
            "def match_point2line(self, points, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n    \"Match points to corresponding line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            corners (torch.Tensor): Eight corners of a bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Flag of matching correspondence.\\n        \"\n    if with_yaw:\n        corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2], [0, 1], [3, 2]], 'right': [[4, 5], [7, 6], [4, 5], [7, 6]]}\n        selected_list = []\n        for pair_index in corners_pair[mode]:\n            selected = self.point2line_dist(points, corners[pair_index[0]], corners[pair_index[1]]) < self.train_cfg['line_thresh']\n            selected_list.append(selected)\n    else:\n        (xmin, ymin, _) = corners.min(0)[0]\n        (xmax, ymax, _) = corners.max(0)[0]\n        sel1 = torch.abs(points[:, 0] - xmin) < self.train_cfg['line_thresh']\n        sel2 = torch.abs(points[:, 0] - xmax) < self.train_cfg['line_thresh']\n        sel3 = torch.abs(points[:, 1] - ymin) < self.train_cfg['line_thresh']\n        sel4 = torch.abs(points[:, 1] - ymax) < self.train_cfg['line_thresh']\n        selected_list = [sel1, sel2, sel3, sel4]\n    return selected_list",
            "def match_point2line(self, points, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Match points to corresponding line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            corners (torch.Tensor): Eight corners of a bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Flag of matching correspondence.\\n        \"\n    if with_yaw:\n        corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2], [0, 1], [3, 2]], 'right': [[4, 5], [7, 6], [4, 5], [7, 6]]}\n        selected_list = []\n        for pair_index in corners_pair[mode]:\n            selected = self.point2line_dist(points, corners[pair_index[0]], corners[pair_index[1]]) < self.train_cfg['line_thresh']\n            selected_list.append(selected)\n    else:\n        (xmin, ymin, _) = corners.min(0)[0]\n        (xmax, ymax, _) = corners.max(0)[0]\n        sel1 = torch.abs(points[:, 0] - xmin) < self.train_cfg['line_thresh']\n        sel2 = torch.abs(points[:, 0] - xmax) < self.train_cfg['line_thresh']\n        sel3 = torch.abs(points[:, 1] - ymin) < self.train_cfg['line_thresh']\n        sel4 = torch.abs(points[:, 1] - ymax) < self.train_cfg['line_thresh']\n        selected_list = [sel1, sel2, sel3, sel4]\n    return selected_list",
            "def match_point2line(self, points, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Match points to corresponding line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            corners (torch.Tensor): Eight corners of a bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Flag of matching correspondence.\\n        \"\n    if with_yaw:\n        corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2], [0, 1], [3, 2]], 'right': [[4, 5], [7, 6], [4, 5], [7, 6]]}\n        selected_list = []\n        for pair_index in corners_pair[mode]:\n            selected = self.point2line_dist(points, corners[pair_index[0]], corners[pair_index[1]]) < self.train_cfg['line_thresh']\n            selected_list.append(selected)\n    else:\n        (xmin, ymin, _) = corners.min(0)[0]\n        (xmax, ymax, _) = corners.max(0)[0]\n        sel1 = torch.abs(points[:, 0] - xmin) < self.train_cfg['line_thresh']\n        sel2 = torch.abs(points[:, 0] - xmax) < self.train_cfg['line_thresh']\n        sel3 = torch.abs(points[:, 1] - ymin) < self.train_cfg['line_thresh']\n        sel4 = torch.abs(points[:, 1] - ymax) < self.train_cfg['line_thresh']\n        selected_list = [sel1, sel2, sel3, sel4]\n    return selected_list",
            "def match_point2line(self, points, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Match points to corresponding line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            corners (torch.Tensor): Eight corners of a bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Flag of matching correspondence.\\n        \"\n    if with_yaw:\n        corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2], [0, 1], [3, 2]], 'right': [[4, 5], [7, 6], [4, 5], [7, 6]]}\n        selected_list = []\n        for pair_index in corners_pair[mode]:\n            selected = self.point2line_dist(points, corners[pair_index[0]], corners[pair_index[1]]) < self.train_cfg['line_thresh']\n            selected_list.append(selected)\n    else:\n        (xmin, ymin, _) = corners.min(0)[0]\n        (xmax, ymax, _) = corners.max(0)[0]\n        sel1 = torch.abs(points[:, 0] - xmin) < self.train_cfg['line_thresh']\n        sel2 = torch.abs(points[:, 0] - xmax) < self.train_cfg['line_thresh']\n        sel3 = torch.abs(points[:, 1] - ymin) < self.train_cfg['line_thresh']\n        sel4 = torch.abs(points[:, 1] - ymax) < self.train_cfg['line_thresh']\n        selected_list = [sel1, sel2, sel3, sel4]\n    return selected_list",
            "def match_point2line(self, points, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Match points to corresponding line.\\n\\n        Args:\\n            points (torch.Tensor): Points of input.\\n            corners (torch.Tensor): Eight corners of a bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Flag of matching correspondence.\\n        \"\n    if with_yaw:\n        corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2], [0, 1], [3, 2]], 'right': [[4, 5], [7, 6], [4, 5], [7, 6]]}\n        selected_list = []\n        for pair_index in corners_pair[mode]:\n            selected = self.point2line_dist(points, corners[pair_index[0]], corners[pair_index[1]]) < self.train_cfg['line_thresh']\n            selected_list.append(selected)\n    else:\n        (xmin, ymin, _) = corners.min(0)[0]\n        (xmax, ymax, _) = corners.max(0)[0]\n        sel1 = torch.abs(points[:, 0] - xmin) < self.train_cfg['line_thresh']\n        sel2 = torch.abs(points[:, 0] - xmax) < self.train_cfg['line_thresh']\n        sel3 = torch.abs(points[:, 1] - ymin) < self.train_cfg['line_thresh']\n        sel4 = torch.abs(points[:, 1] - ymax) < self.train_cfg['line_thresh']\n        selected_list = [sel1, sel2, sel3, sel4]\n    return selected_list"
        ]
    },
    {
        "func_name": "match_point2plane",
        "original": "def match_point2plane(self, plane, points):\n    \"\"\"Match points to plane.\n\n        Args:\n            plane (torch.Tensor): Equation of the plane.\n            points (torch.Tensor): Points of input.\n\n        Returns:\n            Tuple: Distance of each point to the plane and\n                flag of matching correspondence.\n        \"\"\"\n    point2plane_dist = torch.abs((points * plane[:3]).sum(dim=1) + plane[-1])\n    min_dist = point2plane_dist.min()\n    selected = torch.abs(point2plane_dist - min_dist) < self.train_cfg['dist_thresh']\n    return (point2plane_dist, selected)",
        "mutated": [
            "def match_point2plane(self, plane, points):\n    if False:\n        i = 10\n    'Match points to plane.\\n\\n        Args:\\n            plane (torch.Tensor): Equation of the plane.\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Tuple: Distance of each point to the plane and\\n                flag of matching correspondence.\\n        '\n    point2plane_dist = torch.abs((points * plane[:3]).sum(dim=1) + plane[-1])\n    min_dist = point2plane_dist.min()\n    selected = torch.abs(point2plane_dist - min_dist) < self.train_cfg['dist_thresh']\n    return (point2plane_dist, selected)",
            "def match_point2plane(self, plane, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Match points to plane.\\n\\n        Args:\\n            plane (torch.Tensor): Equation of the plane.\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Tuple: Distance of each point to the plane and\\n                flag of matching correspondence.\\n        '\n    point2plane_dist = torch.abs((points * plane[:3]).sum(dim=1) + plane[-1])\n    min_dist = point2plane_dist.min()\n    selected = torch.abs(point2plane_dist - min_dist) < self.train_cfg['dist_thresh']\n    return (point2plane_dist, selected)",
            "def match_point2plane(self, plane, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Match points to plane.\\n\\n        Args:\\n            plane (torch.Tensor): Equation of the plane.\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Tuple: Distance of each point to the plane and\\n                flag of matching correspondence.\\n        '\n    point2plane_dist = torch.abs((points * plane[:3]).sum(dim=1) + plane[-1])\n    min_dist = point2plane_dist.min()\n    selected = torch.abs(point2plane_dist - min_dist) < self.train_cfg['dist_thresh']\n    return (point2plane_dist, selected)",
            "def match_point2plane(self, plane, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Match points to plane.\\n\\n        Args:\\n            plane (torch.Tensor): Equation of the plane.\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Tuple: Distance of each point to the plane and\\n                flag of matching correspondence.\\n        '\n    point2plane_dist = torch.abs((points * plane[:3]).sum(dim=1) + plane[-1])\n    min_dist = point2plane_dist.min()\n    selected = torch.abs(point2plane_dist - min_dist) < self.train_cfg['dist_thresh']\n    return (point2plane_dist, selected)",
            "def match_point2plane(self, plane, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Match points to plane.\\n\\n        Args:\\n            plane (torch.Tensor): Equation of the plane.\\n            points (torch.Tensor): Points of input.\\n\\n        Returns:\\n            Tuple: Distance of each point to the plane and\\n                flag of matching correspondence.\\n        '\n    point2plane_dist = torch.abs((points * plane[:3]).sum(dim=1) + plane[-1])\n    min_dist = point2plane_dist.min()\n    selected = torch.abs(point2plane_dist - min_dist) < self.train_cfg['dist_thresh']\n    return (point2plane_dist, selected)"
        ]
    },
    {
        "func_name": "compute_primitive_loss",
        "original": "def compute_primitive_loss(self, primitive_center, primitive_semantic, semantic_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask):\n    \"\"\"Compute loss of primitive module.\n\n        Args:\n            primitive_center (torch.Tensor): Pridictions of primitive center.\n            primitive_semantic (torch.Tensor): Pridictions of primitive\n                semantic.\n            semantic_scores (torch.Tensor): Pridictions of primitive\n                semantic scores.\n            num_proposal (int): The number of primitive proposal.\n            gt_primitive_center (torch.Tensor): Ground truth of\n                primitive center.\n            gt_votes_sem (torch.Tensor): Ground truth of primitive semantic.\n            gt_sem_cls_label (torch.Tensor): Ground truth of primitive\n                semantic class.\n            gt_primitive_mask (torch.Tensor): Ground truth of primitive mask.\n\n        Returns:\n            Tuple: Loss of primitive module.\n        \"\"\"\n    batch_size = primitive_center.shape[0]\n    vote_xyz_reshape = primitive_center.view(batch_size * num_proposal, -1, 3)\n    center_loss = self.center_loss(vote_xyz_reshape, gt_primitive_center, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    if self.primitive_mode != 'line':\n        size_xyz_reshape = primitive_semantic.view(batch_size * num_proposal, -1, self.num_dims).contiguous()\n        size_loss = self.semantic_reg_loss(size_xyz_reshape, gt_primitive_semantic, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    else:\n        size_loss = center_loss.new_tensor(0.0)\n    sem_cls_loss = self.semantic_cls_loss(semantic_scores, gt_sem_cls_label, weight=gt_primitive_mask)\n    return (center_loss, size_loss, sem_cls_loss)",
        "mutated": [
            "def compute_primitive_loss(self, primitive_center, primitive_semantic, semantic_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask):\n    if False:\n        i = 10\n    'Compute loss of primitive module.\\n\\n        Args:\\n            primitive_center (torch.Tensor): Pridictions of primitive center.\\n            primitive_semantic (torch.Tensor): Pridictions of primitive\\n                semantic.\\n            semantic_scores (torch.Tensor): Pridictions of primitive\\n                semantic scores.\\n            num_proposal (int): The number of primitive proposal.\\n            gt_primitive_center (torch.Tensor): Ground truth of\\n                primitive center.\\n            gt_votes_sem (torch.Tensor): Ground truth of primitive semantic.\\n            gt_sem_cls_label (torch.Tensor): Ground truth of primitive\\n                semantic class.\\n            gt_primitive_mask (torch.Tensor): Ground truth of primitive mask.\\n\\n        Returns:\\n            Tuple: Loss of primitive module.\\n        '\n    batch_size = primitive_center.shape[0]\n    vote_xyz_reshape = primitive_center.view(batch_size * num_proposal, -1, 3)\n    center_loss = self.center_loss(vote_xyz_reshape, gt_primitive_center, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    if self.primitive_mode != 'line':\n        size_xyz_reshape = primitive_semantic.view(batch_size * num_proposal, -1, self.num_dims).contiguous()\n        size_loss = self.semantic_reg_loss(size_xyz_reshape, gt_primitive_semantic, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    else:\n        size_loss = center_loss.new_tensor(0.0)\n    sem_cls_loss = self.semantic_cls_loss(semantic_scores, gt_sem_cls_label, weight=gt_primitive_mask)\n    return (center_loss, size_loss, sem_cls_loss)",
            "def compute_primitive_loss(self, primitive_center, primitive_semantic, semantic_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute loss of primitive module.\\n\\n        Args:\\n            primitive_center (torch.Tensor): Pridictions of primitive center.\\n            primitive_semantic (torch.Tensor): Pridictions of primitive\\n                semantic.\\n            semantic_scores (torch.Tensor): Pridictions of primitive\\n                semantic scores.\\n            num_proposal (int): The number of primitive proposal.\\n            gt_primitive_center (torch.Tensor): Ground truth of\\n                primitive center.\\n            gt_votes_sem (torch.Tensor): Ground truth of primitive semantic.\\n            gt_sem_cls_label (torch.Tensor): Ground truth of primitive\\n                semantic class.\\n            gt_primitive_mask (torch.Tensor): Ground truth of primitive mask.\\n\\n        Returns:\\n            Tuple: Loss of primitive module.\\n        '\n    batch_size = primitive_center.shape[0]\n    vote_xyz_reshape = primitive_center.view(batch_size * num_proposal, -1, 3)\n    center_loss = self.center_loss(vote_xyz_reshape, gt_primitive_center, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    if self.primitive_mode != 'line':\n        size_xyz_reshape = primitive_semantic.view(batch_size * num_proposal, -1, self.num_dims).contiguous()\n        size_loss = self.semantic_reg_loss(size_xyz_reshape, gt_primitive_semantic, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    else:\n        size_loss = center_loss.new_tensor(0.0)\n    sem_cls_loss = self.semantic_cls_loss(semantic_scores, gt_sem_cls_label, weight=gt_primitive_mask)\n    return (center_loss, size_loss, sem_cls_loss)",
            "def compute_primitive_loss(self, primitive_center, primitive_semantic, semantic_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute loss of primitive module.\\n\\n        Args:\\n            primitive_center (torch.Tensor): Pridictions of primitive center.\\n            primitive_semantic (torch.Tensor): Pridictions of primitive\\n                semantic.\\n            semantic_scores (torch.Tensor): Pridictions of primitive\\n                semantic scores.\\n            num_proposal (int): The number of primitive proposal.\\n            gt_primitive_center (torch.Tensor): Ground truth of\\n                primitive center.\\n            gt_votes_sem (torch.Tensor): Ground truth of primitive semantic.\\n            gt_sem_cls_label (torch.Tensor): Ground truth of primitive\\n                semantic class.\\n            gt_primitive_mask (torch.Tensor): Ground truth of primitive mask.\\n\\n        Returns:\\n            Tuple: Loss of primitive module.\\n        '\n    batch_size = primitive_center.shape[0]\n    vote_xyz_reshape = primitive_center.view(batch_size * num_proposal, -1, 3)\n    center_loss = self.center_loss(vote_xyz_reshape, gt_primitive_center, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    if self.primitive_mode != 'line':\n        size_xyz_reshape = primitive_semantic.view(batch_size * num_proposal, -1, self.num_dims).contiguous()\n        size_loss = self.semantic_reg_loss(size_xyz_reshape, gt_primitive_semantic, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    else:\n        size_loss = center_loss.new_tensor(0.0)\n    sem_cls_loss = self.semantic_cls_loss(semantic_scores, gt_sem_cls_label, weight=gt_primitive_mask)\n    return (center_loss, size_loss, sem_cls_loss)",
            "def compute_primitive_loss(self, primitive_center, primitive_semantic, semantic_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute loss of primitive module.\\n\\n        Args:\\n            primitive_center (torch.Tensor): Pridictions of primitive center.\\n            primitive_semantic (torch.Tensor): Pridictions of primitive\\n                semantic.\\n            semantic_scores (torch.Tensor): Pridictions of primitive\\n                semantic scores.\\n            num_proposal (int): The number of primitive proposal.\\n            gt_primitive_center (torch.Tensor): Ground truth of\\n                primitive center.\\n            gt_votes_sem (torch.Tensor): Ground truth of primitive semantic.\\n            gt_sem_cls_label (torch.Tensor): Ground truth of primitive\\n                semantic class.\\n            gt_primitive_mask (torch.Tensor): Ground truth of primitive mask.\\n\\n        Returns:\\n            Tuple: Loss of primitive module.\\n        '\n    batch_size = primitive_center.shape[0]\n    vote_xyz_reshape = primitive_center.view(batch_size * num_proposal, -1, 3)\n    center_loss = self.center_loss(vote_xyz_reshape, gt_primitive_center, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    if self.primitive_mode != 'line':\n        size_xyz_reshape = primitive_semantic.view(batch_size * num_proposal, -1, self.num_dims).contiguous()\n        size_loss = self.semantic_reg_loss(size_xyz_reshape, gt_primitive_semantic, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    else:\n        size_loss = center_loss.new_tensor(0.0)\n    sem_cls_loss = self.semantic_cls_loss(semantic_scores, gt_sem_cls_label, weight=gt_primitive_mask)\n    return (center_loss, size_loss, sem_cls_loss)",
            "def compute_primitive_loss(self, primitive_center, primitive_semantic, semantic_scores, num_proposal, gt_primitive_center, gt_primitive_semantic, gt_sem_cls_label, gt_primitive_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute loss of primitive module.\\n\\n        Args:\\n            primitive_center (torch.Tensor): Pridictions of primitive center.\\n            primitive_semantic (torch.Tensor): Pridictions of primitive\\n                semantic.\\n            semantic_scores (torch.Tensor): Pridictions of primitive\\n                semantic scores.\\n            num_proposal (int): The number of primitive proposal.\\n            gt_primitive_center (torch.Tensor): Ground truth of\\n                primitive center.\\n            gt_votes_sem (torch.Tensor): Ground truth of primitive semantic.\\n            gt_sem_cls_label (torch.Tensor): Ground truth of primitive\\n                semantic class.\\n            gt_primitive_mask (torch.Tensor): Ground truth of primitive mask.\\n\\n        Returns:\\n            Tuple: Loss of primitive module.\\n        '\n    batch_size = primitive_center.shape[0]\n    vote_xyz_reshape = primitive_center.view(batch_size * num_proposal, -1, 3)\n    center_loss = self.center_loss(vote_xyz_reshape, gt_primitive_center, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    if self.primitive_mode != 'line':\n        size_xyz_reshape = primitive_semantic.view(batch_size * num_proposal, -1, self.num_dims).contiguous()\n        size_loss = self.semantic_reg_loss(size_xyz_reshape, gt_primitive_semantic, dst_weight=gt_primitive_mask.view(batch_size * num_proposal, 1))[1]\n    else:\n        size_loss = center_loss.new_tensor(0.0)\n    sem_cls_loss = self.semantic_cls_loss(semantic_scores, gt_sem_cls_label, weight=gt_primitive_mask)\n    return (center_loss, size_loss, sem_cls_loss)"
        ]
    },
    {
        "func_name": "get_primitive_center",
        "original": "def get_primitive_center(self, pred_flag, center):\n    \"\"\"Generate primitive center from predictions.\n\n        Args:\n            pred_flag (torch.Tensor): Scores of primitive center.\n            center (torch.Tensor): Pridictions of primitive center.\n\n        Returns:\n            Tuple: Primitive center and the prediction indices.\n        \"\"\"\n    ind_normal = F.softmax(pred_flag, dim=1)\n    pred_indices = (ind_normal[:, 1, :] > self.surface_thresh).detach().float()\n    selected = (ind_normal[:, 1, :] <= self.surface_thresh).detach().float()\n    offset = torch.ones_like(center) * self.upper_thresh\n    center = center + offset * selected.unsqueeze(-1)\n    return (center, pred_indices)",
        "mutated": [
            "def get_primitive_center(self, pred_flag, center):\n    if False:\n        i = 10\n    'Generate primitive center from predictions.\\n\\n        Args:\\n            pred_flag (torch.Tensor): Scores of primitive center.\\n            center (torch.Tensor): Pridictions of primitive center.\\n\\n        Returns:\\n            Tuple: Primitive center and the prediction indices.\\n        '\n    ind_normal = F.softmax(pred_flag, dim=1)\n    pred_indices = (ind_normal[:, 1, :] > self.surface_thresh).detach().float()\n    selected = (ind_normal[:, 1, :] <= self.surface_thresh).detach().float()\n    offset = torch.ones_like(center) * self.upper_thresh\n    center = center + offset * selected.unsqueeze(-1)\n    return (center, pred_indices)",
            "def get_primitive_center(self, pred_flag, center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate primitive center from predictions.\\n\\n        Args:\\n            pred_flag (torch.Tensor): Scores of primitive center.\\n            center (torch.Tensor): Pridictions of primitive center.\\n\\n        Returns:\\n            Tuple: Primitive center and the prediction indices.\\n        '\n    ind_normal = F.softmax(pred_flag, dim=1)\n    pred_indices = (ind_normal[:, 1, :] > self.surface_thresh).detach().float()\n    selected = (ind_normal[:, 1, :] <= self.surface_thresh).detach().float()\n    offset = torch.ones_like(center) * self.upper_thresh\n    center = center + offset * selected.unsqueeze(-1)\n    return (center, pred_indices)",
            "def get_primitive_center(self, pred_flag, center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate primitive center from predictions.\\n\\n        Args:\\n            pred_flag (torch.Tensor): Scores of primitive center.\\n            center (torch.Tensor): Pridictions of primitive center.\\n\\n        Returns:\\n            Tuple: Primitive center and the prediction indices.\\n        '\n    ind_normal = F.softmax(pred_flag, dim=1)\n    pred_indices = (ind_normal[:, 1, :] > self.surface_thresh).detach().float()\n    selected = (ind_normal[:, 1, :] <= self.surface_thresh).detach().float()\n    offset = torch.ones_like(center) * self.upper_thresh\n    center = center + offset * selected.unsqueeze(-1)\n    return (center, pred_indices)",
            "def get_primitive_center(self, pred_flag, center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate primitive center from predictions.\\n\\n        Args:\\n            pred_flag (torch.Tensor): Scores of primitive center.\\n            center (torch.Tensor): Pridictions of primitive center.\\n\\n        Returns:\\n            Tuple: Primitive center and the prediction indices.\\n        '\n    ind_normal = F.softmax(pred_flag, dim=1)\n    pred_indices = (ind_normal[:, 1, :] > self.surface_thresh).detach().float()\n    selected = (ind_normal[:, 1, :] <= self.surface_thresh).detach().float()\n    offset = torch.ones_like(center) * self.upper_thresh\n    center = center + offset * selected.unsqueeze(-1)\n    return (center, pred_indices)",
            "def get_primitive_center(self, pred_flag, center):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate primitive center from predictions.\\n\\n        Args:\\n            pred_flag (torch.Tensor): Scores of primitive center.\\n            center (torch.Tensor): Pridictions of primitive center.\\n\\n        Returns:\\n            Tuple: Primitive center and the prediction indices.\\n        '\n    ind_normal = F.softmax(pred_flag, dim=1)\n    pred_indices = (ind_normal[:, 1, :] > self.surface_thresh).detach().float()\n    selected = (ind_normal[:, 1, :] <= self.surface_thresh).detach().float()\n    offset = torch.ones_like(center) * self.upper_thresh\n    center = center + offset * selected.unsqueeze(-1)\n    return (center, pred_indices)"
        ]
    },
    {
        "func_name": "_assign_primitive_line_targets",
        "original": "def _assign_primitive_line_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, point2line_matching, corners, center_axises, with_yaw, mode='bottom'):\n    \"\"\"Generate targets of line primitive.\n\n        Args:\n            point_mask (torch.Tensor): Tensor to store the ground\n                truth of mask.\n            point_offset (torch.Tensor): Tensor to store the ground\n                truth of offset.\n            point_sem (torch.Tensor): Tensor to store the ground\n                truth of semantic.\n            coords (torch.Tensor): The selected points.\n            indices (torch.Tensor): Indices of the selected points.\n            cls_label (int): Class label of the ground truth bounding box.\n            point2line_matching (torch.Tensor): Flag indicate that\n                matching line of each point.\n            corners (torch.Tensor): Corners of the ground truth bounding box.\n            center_axises (list[int]): Indicate in which axis the line center\n                should be refined.\n            with_yaw (Bool): Whether the boundind box is with rotation.\n            mode (str, optional): Specify which line should be matched,\n                available mode are ('bottom', 'top', 'left', 'right').\n                Defaults to 'bottom'.\n\n        Returns:\n            Tuple: Targets of the line primitive.\n        \"\"\"\n    corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2]], 'right': [[4, 5], [7, 6]]}\n    corners_pair = corners_pair[mode]\n    assert len(corners_pair) == len(point2line_matching) == len(center_axises)\n    for (line_select, center_axis, pair_index) in zip(point2line_matching, center_axises, corners_pair):\n        if line_select.sum() > self.train_cfg['num_point_line']:\n            point_mask[indices[line_select]] = 1.0\n            if with_yaw:\n                line_center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2\n            else:\n                line_center = coords[line_select].mean(dim=0)\n                line_center[center_axis] = corners[:, center_axis].mean()\n            point_offset[indices[line_select]] = line_center - coords[line_select]\n            point_sem[indices[line_select]] = point_sem.new_tensor([line_center[0], line_center[1], line_center[2], cls_label])\n    return (point_mask, point_offset, point_sem)",
        "mutated": [
            "def _assign_primitive_line_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, point2line_matching, corners, center_axises, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n    \"Generate targets of line primitive.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            point2line_matching (torch.Tensor): Flag indicate that\\n                matching line of each point.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            center_axises (list[int]): Indicate in which axis the line center\\n                should be refined.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the line primitive.\\n        \"\n    corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2]], 'right': [[4, 5], [7, 6]]}\n    corners_pair = corners_pair[mode]\n    assert len(corners_pair) == len(point2line_matching) == len(center_axises)\n    for (line_select, center_axis, pair_index) in zip(point2line_matching, center_axises, corners_pair):\n        if line_select.sum() > self.train_cfg['num_point_line']:\n            point_mask[indices[line_select]] = 1.0\n            if with_yaw:\n                line_center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2\n            else:\n                line_center = coords[line_select].mean(dim=0)\n                line_center[center_axis] = corners[:, center_axis].mean()\n            point_offset[indices[line_select]] = line_center - coords[line_select]\n            point_sem[indices[line_select]] = point_sem.new_tensor([line_center[0], line_center[1], line_center[2], cls_label])\n    return (point_mask, point_offset, point_sem)",
            "def _assign_primitive_line_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, point2line_matching, corners, center_axises, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Generate targets of line primitive.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            point2line_matching (torch.Tensor): Flag indicate that\\n                matching line of each point.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            center_axises (list[int]): Indicate in which axis the line center\\n                should be refined.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the line primitive.\\n        \"\n    corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2]], 'right': [[4, 5], [7, 6]]}\n    corners_pair = corners_pair[mode]\n    assert len(corners_pair) == len(point2line_matching) == len(center_axises)\n    for (line_select, center_axis, pair_index) in zip(point2line_matching, center_axises, corners_pair):\n        if line_select.sum() > self.train_cfg['num_point_line']:\n            point_mask[indices[line_select]] = 1.0\n            if with_yaw:\n                line_center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2\n            else:\n                line_center = coords[line_select].mean(dim=0)\n                line_center[center_axis] = corners[:, center_axis].mean()\n            point_offset[indices[line_select]] = line_center - coords[line_select]\n            point_sem[indices[line_select]] = point_sem.new_tensor([line_center[0], line_center[1], line_center[2], cls_label])\n    return (point_mask, point_offset, point_sem)",
            "def _assign_primitive_line_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, point2line_matching, corners, center_axises, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Generate targets of line primitive.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            point2line_matching (torch.Tensor): Flag indicate that\\n                matching line of each point.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            center_axises (list[int]): Indicate in which axis the line center\\n                should be refined.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the line primitive.\\n        \"\n    corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2]], 'right': [[4, 5], [7, 6]]}\n    corners_pair = corners_pair[mode]\n    assert len(corners_pair) == len(point2line_matching) == len(center_axises)\n    for (line_select, center_axis, pair_index) in zip(point2line_matching, center_axises, corners_pair):\n        if line_select.sum() > self.train_cfg['num_point_line']:\n            point_mask[indices[line_select]] = 1.0\n            if with_yaw:\n                line_center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2\n            else:\n                line_center = coords[line_select].mean(dim=0)\n                line_center[center_axis] = corners[:, center_axis].mean()\n            point_offset[indices[line_select]] = line_center - coords[line_select]\n            point_sem[indices[line_select]] = point_sem.new_tensor([line_center[0], line_center[1], line_center[2], cls_label])\n    return (point_mask, point_offset, point_sem)",
            "def _assign_primitive_line_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, point2line_matching, corners, center_axises, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Generate targets of line primitive.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            point2line_matching (torch.Tensor): Flag indicate that\\n                matching line of each point.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            center_axises (list[int]): Indicate in which axis the line center\\n                should be refined.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the line primitive.\\n        \"\n    corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2]], 'right': [[4, 5], [7, 6]]}\n    corners_pair = corners_pair[mode]\n    assert len(corners_pair) == len(point2line_matching) == len(center_axises)\n    for (line_select, center_axis, pair_index) in zip(point2line_matching, center_axises, corners_pair):\n        if line_select.sum() > self.train_cfg['num_point_line']:\n            point_mask[indices[line_select]] = 1.0\n            if with_yaw:\n                line_center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2\n            else:\n                line_center = coords[line_select].mean(dim=0)\n                line_center[center_axis] = corners[:, center_axis].mean()\n            point_offset[indices[line_select]] = line_center - coords[line_select]\n            point_sem[indices[line_select]] = point_sem.new_tensor([line_center[0], line_center[1], line_center[2], cls_label])\n    return (point_mask, point_offset, point_sem)",
            "def _assign_primitive_line_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, point2line_matching, corners, center_axises, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Generate targets of line primitive.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            point2line_matching (torch.Tensor): Flag indicate that\\n                matching line of each point.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            center_axises (list[int]): Indicate in which axis the line center\\n                should be refined.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the line primitive.\\n        \"\n    corners_pair = {'bottom': [[0, 3], [4, 7], [0, 4], [3, 7]], 'top': [[1, 2], [5, 6], [1, 5], [2, 6]], 'left': [[0, 1], [3, 2]], 'right': [[4, 5], [7, 6]]}\n    corners_pair = corners_pair[mode]\n    assert len(corners_pair) == len(point2line_matching) == len(center_axises)\n    for (line_select, center_axis, pair_index) in zip(point2line_matching, center_axises, corners_pair):\n        if line_select.sum() > self.train_cfg['num_point_line']:\n            point_mask[indices[line_select]] = 1.0\n            if with_yaw:\n                line_center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2\n            else:\n                line_center = coords[line_select].mean(dim=0)\n                line_center[center_axis] = corners[:, center_axis].mean()\n            point_offset[indices[line_select]] = line_center - coords[line_select]\n            point_sem[indices[line_select]] = point_sem.new_tensor([line_center[0], line_center[1], line_center[2], cls_label])\n    return (point_mask, point_offset, point_sem)"
        ]
    },
    {
        "func_name": "_assign_primitive_surface_targets",
        "original": "def _assign_primitive_surface_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, corners, with_yaw, mode='bottom'):\n    \"\"\"Generate targets for primitive z and primitive xy.\n\n        Args:\n            point_mask (torch.Tensor): Tensor to store the ground\n                truth of mask.\n            point_offset (torch.Tensor): Tensor to store the ground\n                truth of offset.\n            point_sem (torch.Tensor): Tensor to store the ground\n                truth of semantic.\n            coords (torch.Tensor): The selected points.\n            indices (torch.Tensor): Indices of the selected points.\n            cls_label (int): Class label of the ground truth bounding box.\n            corners (torch.Tensor): Corners of the ground truth bounding box.\n            with_yaw (Bool): Whether the boundind box is with rotation.\n            mode (str, optional): Specify which line should be matched,\n                available mode are ('bottom', 'top', 'left', 'right',\n                'front', 'back').\n                Defaults to 'bottom'.\n\n        Returns:\n            Tuple: Targets of the center primitive.\n        \"\"\"\n    point_mask[indices] = 1.0\n    corners_pair = {'bottom': [0, 7], 'top': [1, 6], 'left': [0, 1], 'right': [4, 5], 'front': [0, 1], 'back': [3, 2]}\n    pair_index = corners_pair[mode]\n    if self.primitive_mode == 'z':\n        if with_yaw:\n            center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2.0\n            center[2] = coords[:, 2].mean()\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], (corners[4] - corners[0]).norm(), (corners[3] - corners[0]).norm(), cls_label])\n        else:\n            center = point_mask.new_tensor([corners[:, 0].mean(), corners[:, 1].mean(), coords[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 0].max() - corners[:, 0].min(), corners[:, 1].max() - corners[:, 1].min(), cls_label])\n    elif self.primitive_mode == 'xy':\n        if with_yaw:\n            center = coords.mean(0)\n            center[2] = (corners[pair_index[0], 2] + corners[pair_index[1], 2]) / 2.0\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[pair_index[1], 2] - corners[pair_index[0], 2], cls_label])\n        else:\n            center = point_mask.new_tensor([coords[:, 0].mean(), coords[:, 1].mean(), corners[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 2].max() - corners[:, 2].min(), cls_label])\n    point_offset[indices] = center - coords\n    return (point_mask, point_offset, point_sem)",
        "mutated": [
            "def _assign_primitive_surface_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n    \"Generate targets for primitive z and primitive xy.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right',\\n                'front', 'back').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the center primitive.\\n        \"\n    point_mask[indices] = 1.0\n    corners_pair = {'bottom': [0, 7], 'top': [1, 6], 'left': [0, 1], 'right': [4, 5], 'front': [0, 1], 'back': [3, 2]}\n    pair_index = corners_pair[mode]\n    if self.primitive_mode == 'z':\n        if with_yaw:\n            center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2.0\n            center[2] = coords[:, 2].mean()\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], (corners[4] - corners[0]).norm(), (corners[3] - corners[0]).norm(), cls_label])\n        else:\n            center = point_mask.new_tensor([corners[:, 0].mean(), corners[:, 1].mean(), coords[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 0].max() - corners[:, 0].min(), corners[:, 1].max() - corners[:, 1].min(), cls_label])\n    elif self.primitive_mode == 'xy':\n        if with_yaw:\n            center = coords.mean(0)\n            center[2] = (corners[pair_index[0], 2] + corners[pair_index[1], 2]) / 2.0\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[pair_index[1], 2] - corners[pair_index[0], 2], cls_label])\n        else:\n            center = point_mask.new_tensor([coords[:, 0].mean(), coords[:, 1].mean(), corners[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 2].max() - corners[:, 2].min(), cls_label])\n    point_offset[indices] = center - coords\n    return (point_mask, point_offset, point_sem)",
            "def _assign_primitive_surface_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Generate targets for primitive z and primitive xy.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right',\\n                'front', 'back').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the center primitive.\\n        \"\n    point_mask[indices] = 1.0\n    corners_pair = {'bottom': [0, 7], 'top': [1, 6], 'left': [0, 1], 'right': [4, 5], 'front': [0, 1], 'back': [3, 2]}\n    pair_index = corners_pair[mode]\n    if self.primitive_mode == 'z':\n        if with_yaw:\n            center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2.0\n            center[2] = coords[:, 2].mean()\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], (corners[4] - corners[0]).norm(), (corners[3] - corners[0]).norm(), cls_label])\n        else:\n            center = point_mask.new_tensor([corners[:, 0].mean(), corners[:, 1].mean(), coords[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 0].max() - corners[:, 0].min(), corners[:, 1].max() - corners[:, 1].min(), cls_label])\n    elif self.primitive_mode == 'xy':\n        if with_yaw:\n            center = coords.mean(0)\n            center[2] = (corners[pair_index[0], 2] + corners[pair_index[1], 2]) / 2.0\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[pair_index[1], 2] - corners[pair_index[0], 2], cls_label])\n        else:\n            center = point_mask.new_tensor([coords[:, 0].mean(), coords[:, 1].mean(), corners[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 2].max() - corners[:, 2].min(), cls_label])\n    point_offset[indices] = center - coords\n    return (point_mask, point_offset, point_sem)",
            "def _assign_primitive_surface_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Generate targets for primitive z and primitive xy.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right',\\n                'front', 'back').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the center primitive.\\n        \"\n    point_mask[indices] = 1.0\n    corners_pair = {'bottom': [0, 7], 'top': [1, 6], 'left': [0, 1], 'right': [4, 5], 'front': [0, 1], 'back': [3, 2]}\n    pair_index = corners_pair[mode]\n    if self.primitive_mode == 'z':\n        if with_yaw:\n            center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2.0\n            center[2] = coords[:, 2].mean()\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], (corners[4] - corners[0]).norm(), (corners[3] - corners[0]).norm(), cls_label])\n        else:\n            center = point_mask.new_tensor([corners[:, 0].mean(), corners[:, 1].mean(), coords[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 0].max() - corners[:, 0].min(), corners[:, 1].max() - corners[:, 1].min(), cls_label])\n    elif self.primitive_mode == 'xy':\n        if with_yaw:\n            center = coords.mean(0)\n            center[2] = (corners[pair_index[0], 2] + corners[pair_index[1], 2]) / 2.0\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[pair_index[1], 2] - corners[pair_index[0], 2], cls_label])\n        else:\n            center = point_mask.new_tensor([coords[:, 0].mean(), coords[:, 1].mean(), corners[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 2].max() - corners[:, 2].min(), cls_label])\n    point_offset[indices] = center - coords\n    return (point_mask, point_offset, point_sem)",
            "def _assign_primitive_surface_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Generate targets for primitive z and primitive xy.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right',\\n                'front', 'back').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the center primitive.\\n        \"\n    point_mask[indices] = 1.0\n    corners_pair = {'bottom': [0, 7], 'top': [1, 6], 'left': [0, 1], 'right': [4, 5], 'front': [0, 1], 'back': [3, 2]}\n    pair_index = corners_pair[mode]\n    if self.primitive_mode == 'z':\n        if with_yaw:\n            center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2.0\n            center[2] = coords[:, 2].mean()\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], (corners[4] - corners[0]).norm(), (corners[3] - corners[0]).norm(), cls_label])\n        else:\n            center = point_mask.new_tensor([corners[:, 0].mean(), corners[:, 1].mean(), coords[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 0].max() - corners[:, 0].min(), corners[:, 1].max() - corners[:, 1].min(), cls_label])\n    elif self.primitive_mode == 'xy':\n        if with_yaw:\n            center = coords.mean(0)\n            center[2] = (corners[pair_index[0], 2] + corners[pair_index[1], 2]) / 2.0\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[pair_index[1], 2] - corners[pair_index[0], 2], cls_label])\n        else:\n            center = point_mask.new_tensor([coords[:, 0].mean(), coords[:, 1].mean(), corners[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 2].max() - corners[:, 2].min(), cls_label])\n    point_offset[indices] = center - coords\n    return (point_mask, point_offset, point_sem)",
            "def _assign_primitive_surface_targets(self, point_mask, point_offset, point_sem, coords, indices, cls_label, corners, with_yaw, mode='bottom'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Generate targets for primitive z and primitive xy.\\n\\n        Args:\\n            point_mask (torch.Tensor): Tensor to store the ground\\n                truth of mask.\\n            point_offset (torch.Tensor): Tensor to store the ground\\n                truth of offset.\\n            point_sem (torch.Tensor): Tensor to store the ground\\n                truth of semantic.\\n            coords (torch.Tensor): The selected points.\\n            indices (torch.Tensor): Indices of the selected points.\\n            cls_label (int): Class label of the ground truth bounding box.\\n            corners (torch.Tensor): Corners of the ground truth bounding box.\\n            with_yaw (Bool): Whether the boundind box is with rotation.\\n            mode (str, optional): Specify which line should be matched,\\n                available mode are ('bottom', 'top', 'left', 'right',\\n                'front', 'back').\\n                Defaults to 'bottom'.\\n\\n        Returns:\\n            Tuple: Targets of the center primitive.\\n        \"\n    point_mask[indices] = 1.0\n    corners_pair = {'bottom': [0, 7], 'top': [1, 6], 'left': [0, 1], 'right': [4, 5], 'front': [0, 1], 'back': [3, 2]}\n    pair_index = corners_pair[mode]\n    if self.primitive_mode == 'z':\n        if with_yaw:\n            center = (corners[pair_index[0]] + corners[pair_index[1]]) / 2.0\n            center[2] = coords[:, 2].mean()\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], (corners[4] - corners[0]).norm(), (corners[3] - corners[0]).norm(), cls_label])\n        else:\n            center = point_mask.new_tensor([corners[:, 0].mean(), corners[:, 1].mean(), coords[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 0].max() - corners[:, 0].min(), corners[:, 1].max() - corners[:, 1].min(), cls_label])\n    elif self.primitive_mode == 'xy':\n        if with_yaw:\n            center = coords.mean(0)\n            center[2] = (corners[pair_index[0], 2] + corners[pair_index[1], 2]) / 2.0\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[pair_index[1], 2] - corners[pair_index[0], 2], cls_label])\n        else:\n            center = point_mask.new_tensor([coords[:, 0].mean(), coords[:, 1].mean(), corners[:, 2].mean()])\n            point_sem[indices] = point_sem.new_tensor([center[0], center[1], center[2], corners[:, 2].max() - corners[:, 2].min(), cls_label])\n    point_offset[indices] = center - coords\n    return (point_mask, point_offset, point_sem)"
        ]
    },
    {
        "func_name": "_get_plane_fomulation",
        "original": "def _get_plane_fomulation(self, vector1, vector2, point):\n    \"\"\"Compute the equation of the plane.\n\n        Args:\n            vector1 (torch.Tensor): Parallel vector of the plane.\n            vector2 (torch.Tensor): Parallel vector of the plane.\n            point (torch.Tensor): Point on the plane.\n\n        Returns:\n            torch.Tensor: Equation of the plane.\n        \"\"\"\n    surface_norm = torch.cross(vector1, vector2)\n    surface_dis = -torch.dot(surface_norm, point)\n    plane = point.new_tensor([surface_norm[0], surface_norm[1], surface_norm[2], surface_dis])\n    return plane",
        "mutated": [
            "def _get_plane_fomulation(self, vector1, vector2, point):\n    if False:\n        i = 10\n    'Compute the equation of the plane.\\n\\n        Args:\\n            vector1 (torch.Tensor): Parallel vector of the plane.\\n            vector2 (torch.Tensor): Parallel vector of the plane.\\n            point (torch.Tensor): Point on the plane.\\n\\n        Returns:\\n            torch.Tensor: Equation of the plane.\\n        '\n    surface_norm = torch.cross(vector1, vector2)\n    surface_dis = -torch.dot(surface_norm, point)\n    plane = point.new_tensor([surface_norm[0], surface_norm[1], surface_norm[2], surface_dis])\n    return plane",
            "def _get_plane_fomulation(self, vector1, vector2, point):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the equation of the plane.\\n\\n        Args:\\n            vector1 (torch.Tensor): Parallel vector of the plane.\\n            vector2 (torch.Tensor): Parallel vector of the plane.\\n            point (torch.Tensor): Point on the plane.\\n\\n        Returns:\\n            torch.Tensor: Equation of the plane.\\n        '\n    surface_norm = torch.cross(vector1, vector2)\n    surface_dis = -torch.dot(surface_norm, point)\n    plane = point.new_tensor([surface_norm[0], surface_norm[1], surface_norm[2], surface_dis])\n    return plane",
            "def _get_plane_fomulation(self, vector1, vector2, point):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the equation of the plane.\\n\\n        Args:\\n            vector1 (torch.Tensor): Parallel vector of the plane.\\n            vector2 (torch.Tensor): Parallel vector of the plane.\\n            point (torch.Tensor): Point on the plane.\\n\\n        Returns:\\n            torch.Tensor: Equation of the plane.\\n        '\n    surface_norm = torch.cross(vector1, vector2)\n    surface_dis = -torch.dot(surface_norm, point)\n    plane = point.new_tensor([surface_norm[0], surface_norm[1], surface_norm[2], surface_dis])\n    return plane",
            "def _get_plane_fomulation(self, vector1, vector2, point):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the equation of the plane.\\n\\n        Args:\\n            vector1 (torch.Tensor): Parallel vector of the plane.\\n            vector2 (torch.Tensor): Parallel vector of the plane.\\n            point (torch.Tensor): Point on the plane.\\n\\n        Returns:\\n            torch.Tensor: Equation of the plane.\\n        '\n    surface_norm = torch.cross(vector1, vector2)\n    surface_dis = -torch.dot(surface_norm, point)\n    plane = point.new_tensor([surface_norm[0], surface_norm[1], surface_norm[2], surface_dis])\n    return plane",
            "def _get_plane_fomulation(self, vector1, vector2, point):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the equation of the plane.\\n\\n        Args:\\n            vector1 (torch.Tensor): Parallel vector of the plane.\\n            vector2 (torch.Tensor): Parallel vector of the plane.\\n            point (torch.Tensor): Point on the plane.\\n\\n        Returns:\\n            torch.Tensor: Equation of the plane.\\n        '\n    surface_norm = torch.cross(vector1, vector2)\n    surface_dis = -torch.dot(surface_norm, point)\n    plane = point.new_tensor([surface_norm[0], surface_norm[1], surface_norm[2], surface_dis])\n    return plane"
        ]
    }
]