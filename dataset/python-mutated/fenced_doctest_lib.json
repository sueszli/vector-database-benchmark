[
    {
        "func_name": "load_from_files",
        "original": "def load_from_files(files, globs: Optional[Dict[str, Any]]=None, set_up: Optional[Callable[[Any], None]]=None, tear_down: Optional[Callable[[Any], None]]=None) -> doctest.DocFileSuite:\n    \"\"\"Creates a doctest suite from the files list.\n\n  Args:\n    files: A list of file paths to test.\n    globs: The global namespace the tests are run in.\n    set_up: Run before each test, receives the test as argument.\n    tear_down: Run after each test, receives the test as argument.\n\n  Returns:\n    A DocFileSuite containing the tests.\n  \"\"\"\n    if globs is None:\n        globs = {}\n    files = [os.fspath(f) for f in files]\n    globs['_print_if_not_none'] = _print_if_not_none\n    return doctest.DocFileSuite(*files, module_relative=False, parser=FencedCellParser(fence_label='python'), globs=globs, setUp=set_up, tearDown=tear_down, checker=FencedCellOutputChecker(), optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.IGNORE_EXCEPTION_DETAIL | doctest.DONT_ACCEPT_BLANKLINE)",
        "mutated": [
            "def load_from_files(files, globs: Optional[Dict[str, Any]]=None, set_up: Optional[Callable[[Any], None]]=None, tear_down: Optional[Callable[[Any], None]]=None) -> doctest.DocFileSuite:\n    if False:\n        i = 10\n    'Creates a doctest suite from the files list.\\n\\n  Args:\\n    files: A list of file paths to test.\\n    globs: The global namespace the tests are run in.\\n    set_up: Run before each test, receives the test as argument.\\n    tear_down: Run after each test, receives the test as argument.\\n\\n  Returns:\\n    A DocFileSuite containing the tests.\\n  '\n    if globs is None:\n        globs = {}\n    files = [os.fspath(f) for f in files]\n    globs['_print_if_not_none'] = _print_if_not_none\n    return doctest.DocFileSuite(*files, module_relative=False, parser=FencedCellParser(fence_label='python'), globs=globs, setUp=set_up, tearDown=tear_down, checker=FencedCellOutputChecker(), optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.IGNORE_EXCEPTION_DETAIL | doctest.DONT_ACCEPT_BLANKLINE)",
            "def load_from_files(files, globs: Optional[Dict[str, Any]]=None, set_up: Optional[Callable[[Any], None]]=None, tear_down: Optional[Callable[[Any], None]]=None) -> doctest.DocFileSuite:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Creates a doctest suite from the files list.\\n\\n  Args:\\n    files: A list of file paths to test.\\n    globs: The global namespace the tests are run in.\\n    set_up: Run before each test, receives the test as argument.\\n    tear_down: Run after each test, receives the test as argument.\\n\\n  Returns:\\n    A DocFileSuite containing the tests.\\n  '\n    if globs is None:\n        globs = {}\n    files = [os.fspath(f) for f in files]\n    globs['_print_if_not_none'] = _print_if_not_none\n    return doctest.DocFileSuite(*files, module_relative=False, parser=FencedCellParser(fence_label='python'), globs=globs, setUp=set_up, tearDown=tear_down, checker=FencedCellOutputChecker(), optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.IGNORE_EXCEPTION_DETAIL | doctest.DONT_ACCEPT_BLANKLINE)",
            "def load_from_files(files, globs: Optional[Dict[str, Any]]=None, set_up: Optional[Callable[[Any], None]]=None, tear_down: Optional[Callable[[Any], None]]=None) -> doctest.DocFileSuite:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Creates a doctest suite from the files list.\\n\\n  Args:\\n    files: A list of file paths to test.\\n    globs: The global namespace the tests are run in.\\n    set_up: Run before each test, receives the test as argument.\\n    tear_down: Run after each test, receives the test as argument.\\n\\n  Returns:\\n    A DocFileSuite containing the tests.\\n  '\n    if globs is None:\n        globs = {}\n    files = [os.fspath(f) for f in files]\n    globs['_print_if_not_none'] = _print_if_not_none\n    return doctest.DocFileSuite(*files, module_relative=False, parser=FencedCellParser(fence_label='python'), globs=globs, setUp=set_up, tearDown=tear_down, checker=FencedCellOutputChecker(), optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.IGNORE_EXCEPTION_DETAIL | doctest.DONT_ACCEPT_BLANKLINE)",
            "def load_from_files(files, globs: Optional[Dict[str, Any]]=None, set_up: Optional[Callable[[Any], None]]=None, tear_down: Optional[Callable[[Any], None]]=None) -> doctest.DocFileSuite:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Creates a doctest suite from the files list.\\n\\n  Args:\\n    files: A list of file paths to test.\\n    globs: The global namespace the tests are run in.\\n    set_up: Run before each test, receives the test as argument.\\n    tear_down: Run after each test, receives the test as argument.\\n\\n  Returns:\\n    A DocFileSuite containing the tests.\\n  '\n    if globs is None:\n        globs = {}\n    files = [os.fspath(f) for f in files]\n    globs['_print_if_not_none'] = _print_if_not_none\n    return doctest.DocFileSuite(*files, module_relative=False, parser=FencedCellParser(fence_label='python'), globs=globs, setUp=set_up, tearDown=tear_down, checker=FencedCellOutputChecker(), optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.IGNORE_EXCEPTION_DETAIL | doctest.DONT_ACCEPT_BLANKLINE)",
            "def load_from_files(files, globs: Optional[Dict[str, Any]]=None, set_up: Optional[Callable[[Any], None]]=None, tear_down: Optional[Callable[[Any], None]]=None) -> doctest.DocFileSuite:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Creates a doctest suite from the files list.\\n\\n  Args:\\n    files: A list of file paths to test.\\n    globs: The global namespace the tests are run in.\\n    set_up: Run before each test, receives the test as argument.\\n    tear_down: Run after each test, receives the test as argument.\\n\\n  Returns:\\n    A DocFileSuite containing the tests.\\n  '\n    if globs is None:\n        globs = {}\n    files = [os.fspath(f) for f in files]\n    globs['_print_if_not_none'] = _print_if_not_none\n    return doctest.DocFileSuite(*files, module_relative=False, parser=FencedCellParser(fence_label='python'), globs=globs, setUp=set_up, tearDown=tear_down, checker=FencedCellOutputChecker(), optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.IGNORE_EXCEPTION_DETAIL | doctest.DONT_ACCEPT_BLANKLINE)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, fence_label='python'):\n    super().__init__()\n    if not self.patched:\n        doctest.compile = _patch_compile\n        print(textwrap.dedent(\"\\n          *********************************************************************\\n          * Caution: `fenced_doctest` patches `doctest.compile` don't use this\\n          *   in the same binary as any other doctests.\\n          *********************************************************************\\n          \"))\n        type(self).patched = True\n    no_fence = '(.(?<!```))*?'\n    self.fence_cell_re = re.compile(f'\\n        ^(                             # After a newline\\n            \\\\s*```\\\\s*({fence_label})\\\\n   # Open a labeled ``` fence\\n            (?P<doctest>{no_fence})      # Match anything except a closing fence\\n            \\\\n\\\\s*```\\\\s*(\\\\n|$)            # Close the fence.\\n        )\\n        (                              # Optional!\\n            [\\\\s\\\\n]*                      # Any number of blank lines.\\n            ```\\\\s*\\\\n                     # Open ```\\n            (?P<output>{no_fence})       # Anything except a closing fence\\n            \\\\n\\\\s*```                     # Close the fence.\\n        )?\\n        ', re.MULTILINE | re.DOTALL | re.VERBOSE)",
        "mutated": [
            "def __init__(self, fence_label='python'):\n    if False:\n        i = 10\n    super().__init__()\n    if not self.patched:\n        doctest.compile = _patch_compile\n        print(textwrap.dedent(\"\\n          *********************************************************************\\n          * Caution: `fenced_doctest` patches `doctest.compile` don't use this\\n          *   in the same binary as any other doctests.\\n          *********************************************************************\\n          \"))\n        type(self).patched = True\n    no_fence = '(.(?<!```))*?'\n    self.fence_cell_re = re.compile(f'\\n        ^(                             # After a newline\\n            \\\\s*```\\\\s*({fence_label})\\\\n   # Open a labeled ``` fence\\n            (?P<doctest>{no_fence})      # Match anything except a closing fence\\n            \\\\n\\\\s*```\\\\s*(\\\\n|$)            # Close the fence.\\n        )\\n        (                              # Optional!\\n            [\\\\s\\\\n]*                      # Any number of blank lines.\\n            ```\\\\s*\\\\n                     # Open ```\\n            (?P<output>{no_fence})       # Anything except a closing fence\\n            \\\\n\\\\s*```                     # Close the fence.\\n        )?\\n        ', re.MULTILINE | re.DOTALL | re.VERBOSE)",
            "def __init__(self, fence_label='python'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__()\n    if not self.patched:\n        doctest.compile = _patch_compile\n        print(textwrap.dedent(\"\\n          *********************************************************************\\n          * Caution: `fenced_doctest` patches `doctest.compile` don't use this\\n          *   in the same binary as any other doctests.\\n          *********************************************************************\\n          \"))\n        type(self).patched = True\n    no_fence = '(.(?<!```))*?'\n    self.fence_cell_re = re.compile(f'\\n        ^(                             # After a newline\\n            \\\\s*```\\\\s*({fence_label})\\\\n   # Open a labeled ``` fence\\n            (?P<doctest>{no_fence})      # Match anything except a closing fence\\n            \\\\n\\\\s*```\\\\s*(\\\\n|$)            # Close the fence.\\n        )\\n        (                              # Optional!\\n            [\\\\s\\\\n]*                      # Any number of blank lines.\\n            ```\\\\s*\\\\n                     # Open ```\\n            (?P<output>{no_fence})       # Anything except a closing fence\\n            \\\\n\\\\s*```                     # Close the fence.\\n        )?\\n        ', re.MULTILINE | re.DOTALL | re.VERBOSE)",
            "def __init__(self, fence_label='python'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__()\n    if not self.patched:\n        doctest.compile = _patch_compile\n        print(textwrap.dedent(\"\\n          *********************************************************************\\n          * Caution: `fenced_doctest` patches `doctest.compile` don't use this\\n          *   in the same binary as any other doctests.\\n          *********************************************************************\\n          \"))\n        type(self).patched = True\n    no_fence = '(.(?<!```))*?'\n    self.fence_cell_re = re.compile(f'\\n        ^(                             # After a newline\\n            \\\\s*```\\\\s*({fence_label})\\\\n   # Open a labeled ``` fence\\n            (?P<doctest>{no_fence})      # Match anything except a closing fence\\n            \\\\n\\\\s*```\\\\s*(\\\\n|$)            # Close the fence.\\n        )\\n        (                              # Optional!\\n            [\\\\s\\\\n]*                      # Any number of blank lines.\\n            ```\\\\s*\\\\n                     # Open ```\\n            (?P<output>{no_fence})       # Anything except a closing fence\\n            \\\\n\\\\s*```                     # Close the fence.\\n        )?\\n        ', re.MULTILINE | re.DOTALL | re.VERBOSE)",
            "def __init__(self, fence_label='python'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__()\n    if not self.patched:\n        doctest.compile = _patch_compile\n        print(textwrap.dedent(\"\\n          *********************************************************************\\n          * Caution: `fenced_doctest` patches `doctest.compile` don't use this\\n          *   in the same binary as any other doctests.\\n          *********************************************************************\\n          \"))\n        type(self).patched = True\n    no_fence = '(.(?<!```))*?'\n    self.fence_cell_re = re.compile(f'\\n        ^(                             # After a newline\\n            \\\\s*```\\\\s*({fence_label})\\\\n   # Open a labeled ``` fence\\n            (?P<doctest>{no_fence})      # Match anything except a closing fence\\n            \\\\n\\\\s*```\\\\s*(\\\\n|$)            # Close the fence.\\n        )\\n        (                              # Optional!\\n            [\\\\s\\\\n]*                      # Any number of blank lines.\\n            ```\\\\s*\\\\n                     # Open ```\\n            (?P<output>{no_fence})       # Anything except a closing fence\\n            \\\\n\\\\s*```                     # Close the fence.\\n        )?\\n        ', re.MULTILINE | re.DOTALL | re.VERBOSE)",
            "def __init__(self, fence_label='python'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__()\n    if not self.patched:\n        doctest.compile = _patch_compile\n        print(textwrap.dedent(\"\\n          *********************************************************************\\n          * Caution: `fenced_doctest` patches `doctest.compile` don't use this\\n          *   in the same binary as any other doctests.\\n          *********************************************************************\\n          \"))\n        type(self).patched = True\n    no_fence = '(.(?<!```))*?'\n    self.fence_cell_re = re.compile(f'\\n        ^(                             # After a newline\\n            \\\\s*```\\\\s*({fence_label})\\\\n   # Open a labeled ``` fence\\n            (?P<doctest>{no_fence})      # Match anything except a closing fence\\n            \\\\n\\\\s*```\\\\s*(\\\\n|$)            # Close the fence.\\n        )\\n        (                              # Optional!\\n            [\\\\s\\\\n]*                      # Any number of blank lines.\\n            ```\\\\s*\\\\n                     # Open ```\\n            (?P<output>{no_fence})       # Anything except a closing fence\\n            \\\\n\\\\s*```                     # Close the fence.\\n        )?\\n        ', re.MULTILINE | re.DOTALL | re.VERBOSE)"
        ]
    },
    {
        "func_name": "get_examples",
        "original": "def get_examples(self, string: str, name: str='<string>') -> Iterable[doctest.Example]:\n    if re.search('<!--.*?doctest.*?skip.*?all.*?-->', string, re.IGNORECASE):\n        return\n    for match in self.fence_cell_re.finditer(string):\n        if re.search('doctest.*skip', match.group(0), re.IGNORECASE):\n            continue\n        groups = match.groupdict()\n        source = textwrap.dedent(groups['doctest'])\n        want = groups['output']\n        if want is not None:\n            want = textwrap.dedent(want)\n        yield doctest.Example(lineno=string[:match.start()].count('\\n') + 1, source=source, want=want)",
        "mutated": [
            "def get_examples(self, string: str, name: str='<string>') -> Iterable[doctest.Example]:\n    if False:\n        i = 10\n    if re.search('<!--.*?doctest.*?skip.*?all.*?-->', string, re.IGNORECASE):\n        return\n    for match in self.fence_cell_re.finditer(string):\n        if re.search('doctest.*skip', match.group(0), re.IGNORECASE):\n            continue\n        groups = match.groupdict()\n        source = textwrap.dedent(groups['doctest'])\n        want = groups['output']\n        if want is not None:\n            want = textwrap.dedent(want)\n        yield doctest.Example(lineno=string[:match.start()].count('\\n') + 1, source=source, want=want)",
            "def get_examples(self, string: str, name: str='<string>') -> Iterable[doctest.Example]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if re.search('<!--.*?doctest.*?skip.*?all.*?-->', string, re.IGNORECASE):\n        return\n    for match in self.fence_cell_re.finditer(string):\n        if re.search('doctest.*skip', match.group(0), re.IGNORECASE):\n            continue\n        groups = match.groupdict()\n        source = textwrap.dedent(groups['doctest'])\n        want = groups['output']\n        if want is not None:\n            want = textwrap.dedent(want)\n        yield doctest.Example(lineno=string[:match.start()].count('\\n') + 1, source=source, want=want)",
            "def get_examples(self, string: str, name: str='<string>') -> Iterable[doctest.Example]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if re.search('<!--.*?doctest.*?skip.*?all.*?-->', string, re.IGNORECASE):\n        return\n    for match in self.fence_cell_re.finditer(string):\n        if re.search('doctest.*skip', match.group(0), re.IGNORECASE):\n            continue\n        groups = match.groupdict()\n        source = textwrap.dedent(groups['doctest'])\n        want = groups['output']\n        if want is not None:\n            want = textwrap.dedent(want)\n        yield doctest.Example(lineno=string[:match.start()].count('\\n') + 1, source=source, want=want)",
            "def get_examples(self, string: str, name: str='<string>') -> Iterable[doctest.Example]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if re.search('<!--.*?doctest.*?skip.*?all.*?-->', string, re.IGNORECASE):\n        return\n    for match in self.fence_cell_re.finditer(string):\n        if re.search('doctest.*skip', match.group(0), re.IGNORECASE):\n            continue\n        groups = match.groupdict()\n        source = textwrap.dedent(groups['doctest'])\n        want = groups['output']\n        if want is not None:\n            want = textwrap.dedent(want)\n        yield doctest.Example(lineno=string[:match.start()].count('\\n') + 1, source=source, want=want)",
            "def get_examples(self, string: str, name: str='<string>') -> Iterable[doctest.Example]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if re.search('<!--.*?doctest.*?skip.*?all.*?-->', string, re.IGNORECASE):\n        return\n    for match in self.fence_cell_re.finditer(string):\n        if re.search('doctest.*skip', match.group(0), re.IGNORECASE):\n            continue\n        groups = match.groupdict()\n        source = textwrap.dedent(groups['doctest'])\n        want = groups['output']\n        if want is not None:\n            want = textwrap.dedent(want)\n        yield doctest.Example(lineno=string[:match.start()].count('\\n') + 1, source=source, want=want)"
        ]
    },
    {
        "func_name": "_print_if_not_none",
        "original": "def _print_if_not_none(obj):\n    \"\"\"Print like a notebook: Show the repr if the object is not None.\n\n  `_patch_compile` Uses this on the final expression in each cell.\n\n  This way the outputs feel like notebooks.\n\n  Args:\n    obj: the object to print.\n  \"\"\"\n    if obj is not None:\n        print(repr(obj))",
        "mutated": [
            "def _print_if_not_none(obj):\n    if False:\n        i = 10\n    'Print like a notebook: Show the repr if the object is not None.\\n\\n  `_patch_compile` Uses this on the final expression in each cell.\\n\\n  This way the outputs feel like notebooks.\\n\\n  Args:\\n    obj: the object to print.\\n  '\n    if obj is not None:\n        print(repr(obj))",
            "def _print_if_not_none(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Print like a notebook: Show the repr if the object is not None.\\n\\n  `_patch_compile` Uses this on the final expression in each cell.\\n\\n  This way the outputs feel like notebooks.\\n\\n  Args:\\n    obj: the object to print.\\n  '\n    if obj is not None:\n        print(repr(obj))",
            "def _print_if_not_none(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Print like a notebook: Show the repr if the object is not None.\\n\\n  `_patch_compile` Uses this on the final expression in each cell.\\n\\n  This way the outputs feel like notebooks.\\n\\n  Args:\\n    obj: the object to print.\\n  '\n    if obj is not None:\n        print(repr(obj))",
            "def _print_if_not_none(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Print like a notebook: Show the repr if the object is not None.\\n\\n  `_patch_compile` Uses this on the final expression in each cell.\\n\\n  This way the outputs feel like notebooks.\\n\\n  Args:\\n    obj: the object to print.\\n  '\n    if obj is not None:\n        print(repr(obj))",
            "def _print_if_not_none(obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Print like a notebook: Show the repr if the object is not None.\\n\\n  `_patch_compile` Uses this on the final expression in each cell.\\n\\n  This way the outputs feel like notebooks.\\n\\n  Args:\\n    obj: the object to print.\\n  '\n    if obj is not None:\n        print(repr(obj))"
        ]
    },
    {
        "func_name": "_patch_compile",
        "original": "def _patch_compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1):\n    \"\"\"Patch `doctest.compile` to make doctest to behave like a notebook.\n\n  Default settings for doctest are configured to run like a repl: one statement\n  at a time. The doctest source uses `compile(..., mode=\"single\")`\n\n  So to let doctest act like a notebook:\n\n  1. We need `mode=\"exec\"` (easy)\n  2. We need the last expression to be printed (harder).\n\n  To print the last expression, just wrap the last expression in\n  `_print_if_not_none(expr)`. To detect the last expression use `AST`.\n  If the last node is an expression modify the ast to call\n  `_print_if_not_none` on it, convert the ast back to source and compile that.\n\n  https://docs.python.org/3/library/functions.html#compile\n\n  Args:\n    source: Can either be a normal string, a byte string, or an AST object.\n    filename: Argument should give the file from which the code was read; pass\n      some recognizable value if it wasn\u2019t read from a file ('<string>' is\n      commonly used).\n    mode: [Ignored] always use exec.\n    flags: Compiler options.\n    dont_inherit: Compiler options.\n    optimize: Compiler options.\n\n  Returns:\n    The resulting code object.\n  \"\"\"\n    del filename\n    del mode\n    source_ast = ast.parse(source)\n    final = source_ast.body[-1]\n    if isinstance(final, ast.Expr):\n        print_it = ast.Expr(lineno=-1, col_offset=-1, value=ast.Call(func=ast.Name(id='_print_if_not_none', ctx=ast.Load(), lineno=-1, col_offset=-1), lineno=-1, col_offset=-1, args=[final], keywords=[]))\n        source_ast.body[-1] = print_it\n        source = astor.to_source(source_ast)\n    return compile(source, filename='dummy.py', mode='exec', flags=flags, dont_inherit=dont_inherit, optimize=optimize)",
        "mutated": [
            "def _patch_compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1):\n    if False:\n        i = 10\n    'Patch `doctest.compile` to make doctest to behave like a notebook.\\n\\n  Default settings for doctest are configured to run like a repl: one statement\\n  at a time. The doctest source uses `compile(..., mode=\"single\")`\\n\\n  So to let doctest act like a notebook:\\n\\n  1. We need `mode=\"exec\"` (easy)\\n  2. We need the last expression to be printed (harder).\\n\\n  To print the last expression, just wrap the last expression in\\n  `_print_if_not_none(expr)`. To detect the last expression use `AST`.\\n  If the last node is an expression modify the ast to call\\n  `_print_if_not_none` on it, convert the ast back to source and compile that.\\n\\n  https://docs.python.org/3/library/functions.html#compile\\n\\n  Args:\\n    source: Can either be a normal string, a byte string, or an AST object.\\n    filename: Argument should give the file from which the code was read; pass\\n      some recognizable value if it wasn\u2019t read from a file (\\'<string>\\' is\\n      commonly used).\\n    mode: [Ignored] always use exec.\\n    flags: Compiler options.\\n    dont_inherit: Compiler options.\\n    optimize: Compiler options.\\n\\n  Returns:\\n    The resulting code object.\\n  '\n    del filename\n    del mode\n    source_ast = ast.parse(source)\n    final = source_ast.body[-1]\n    if isinstance(final, ast.Expr):\n        print_it = ast.Expr(lineno=-1, col_offset=-1, value=ast.Call(func=ast.Name(id='_print_if_not_none', ctx=ast.Load(), lineno=-1, col_offset=-1), lineno=-1, col_offset=-1, args=[final], keywords=[]))\n        source_ast.body[-1] = print_it\n        source = astor.to_source(source_ast)\n    return compile(source, filename='dummy.py', mode='exec', flags=flags, dont_inherit=dont_inherit, optimize=optimize)",
            "def _patch_compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Patch `doctest.compile` to make doctest to behave like a notebook.\\n\\n  Default settings for doctest are configured to run like a repl: one statement\\n  at a time. The doctest source uses `compile(..., mode=\"single\")`\\n\\n  So to let doctest act like a notebook:\\n\\n  1. We need `mode=\"exec\"` (easy)\\n  2. We need the last expression to be printed (harder).\\n\\n  To print the last expression, just wrap the last expression in\\n  `_print_if_not_none(expr)`. To detect the last expression use `AST`.\\n  If the last node is an expression modify the ast to call\\n  `_print_if_not_none` on it, convert the ast back to source and compile that.\\n\\n  https://docs.python.org/3/library/functions.html#compile\\n\\n  Args:\\n    source: Can either be a normal string, a byte string, or an AST object.\\n    filename: Argument should give the file from which the code was read; pass\\n      some recognizable value if it wasn\u2019t read from a file (\\'<string>\\' is\\n      commonly used).\\n    mode: [Ignored] always use exec.\\n    flags: Compiler options.\\n    dont_inherit: Compiler options.\\n    optimize: Compiler options.\\n\\n  Returns:\\n    The resulting code object.\\n  '\n    del filename\n    del mode\n    source_ast = ast.parse(source)\n    final = source_ast.body[-1]\n    if isinstance(final, ast.Expr):\n        print_it = ast.Expr(lineno=-1, col_offset=-1, value=ast.Call(func=ast.Name(id='_print_if_not_none', ctx=ast.Load(), lineno=-1, col_offset=-1), lineno=-1, col_offset=-1, args=[final], keywords=[]))\n        source_ast.body[-1] = print_it\n        source = astor.to_source(source_ast)\n    return compile(source, filename='dummy.py', mode='exec', flags=flags, dont_inherit=dont_inherit, optimize=optimize)",
            "def _patch_compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Patch `doctest.compile` to make doctest to behave like a notebook.\\n\\n  Default settings for doctest are configured to run like a repl: one statement\\n  at a time. The doctest source uses `compile(..., mode=\"single\")`\\n\\n  So to let doctest act like a notebook:\\n\\n  1. We need `mode=\"exec\"` (easy)\\n  2. We need the last expression to be printed (harder).\\n\\n  To print the last expression, just wrap the last expression in\\n  `_print_if_not_none(expr)`. To detect the last expression use `AST`.\\n  If the last node is an expression modify the ast to call\\n  `_print_if_not_none` on it, convert the ast back to source and compile that.\\n\\n  https://docs.python.org/3/library/functions.html#compile\\n\\n  Args:\\n    source: Can either be a normal string, a byte string, or an AST object.\\n    filename: Argument should give the file from which the code was read; pass\\n      some recognizable value if it wasn\u2019t read from a file (\\'<string>\\' is\\n      commonly used).\\n    mode: [Ignored] always use exec.\\n    flags: Compiler options.\\n    dont_inherit: Compiler options.\\n    optimize: Compiler options.\\n\\n  Returns:\\n    The resulting code object.\\n  '\n    del filename\n    del mode\n    source_ast = ast.parse(source)\n    final = source_ast.body[-1]\n    if isinstance(final, ast.Expr):\n        print_it = ast.Expr(lineno=-1, col_offset=-1, value=ast.Call(func=ast.Name(id='_print_if_not_none', ctx=ast.Load(), lineno=-1, col_offset=-1), lineno=-1, col_offset=-1, args=[final], keywords=[]))\n        source_ast.body[-1] = print_it\n        source = astor.to_source(source_ast)\n    return compile(source, filename='dummy.py', mode='exec', flags=flags, dont_inherit=dont_inherit, optimize=optimize)",
            "def _patch_compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Patch `doctest.compile` to make doctest to behave like a notebook.\\n\\n  Default settings for doctest are configured to run like a repl: one statement\\n  at a time. The doctest source uses `compile(..., mode=\"single\")`\\n\\n  So to let doctest act like a notebook:\\n\\n  1. We need `mode=\"exec\"` (easy)\\n  2. We need the last expression to be printed (harder).\\n\\n  To print the last expression, just wrap the last expression in\\n  `_print_if_not_none(expr)`. To detect the last expression use `AST`.\\n  If the last node is an expression modify the ast to call\\n  `_print_if_not_none` on it, convert the ast back to source and compile that.\\n\\n  https://docs.python.org/3/library/functions.html#compile\\n\\n  Args:\\n    source: Can either be a normal string, a byte string, or an AST object.\\n    filename: Argument should give the file from which the code was read; pass\\n      some recognizable value if it wasn\u2019t read from a file (\\'<string>\\' is\\n      commonly used).\\n    mode: [Ignored] always use exec.\\n    flags: Compiler options.\\n    dont_inherit: Compiler options.\\n    optimize: Compiler options.\\n\\n  Returns:\\n    The resulting code object.\\n  '\n    del filename\n    del mode\n    source_ast = ast.parse(source)\n    final = source_ast.body[-1]\n    if isinstance(final, ast.Expr):\n        print_it = ast.Expr(lineno=-1, col_offset=-1, value=ast.Call(func=ast.Name(id='_print_if_not_none', ctx=ast.Load(), lineno=-1, col_offset=-1), lineno=-1, col_offset=-1, args=[final], keywords=[]))\n        source_ast.body[-1] = print_it\n        source = astor.to_source(source_ast)\n    return compile(source, filename='dummy.py', mode='exec', flags=flags, dont_inherit=dont_inherit, optimize=optimize)",
            "def _patch_compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Patch `doctest.compile` to make doctest to behave like a notebook.\\n\\n  Default settings for doctest are configured to run like a repl: one statement\\n  at a time. The doctest source uses `compile(..., mode=\"single\")`\\n\\n  So to let doctest act like a notebook:\\n\\n  1. We need `mode=\"exec\"` (easy)\\n  2. We need the last expression to be printed (harder).\\n\\n  To print the last expression, just wrap the last expression in\\n  `_print_if_not_none(expr)`. To detect the last expression use `AST`.\\n  If the last node is an expression modify the ast to call\\n  `_print_if_not_none` on it, convert the ast back to source and compile that.\\n\\n  https://docs.python.org/3/library/functions.html#compile\\n\\n  Args:\\n    source: Can either be a normal string, a byte string, or an AST object.\\n    filename: Argument should give the file from which the code was read; pass\\n      some recognizable value if it wasn\u2019t read from a file (\\'<string>\\' is\\n      commonly used).\\n    mode: [Ignored] always use exec.\\n    flags: Compiler options.\\n    dont_inherit: Compiler options.\\n    optimize: Compiler options.\\n\\n  Returns:\\n    The resulting code object.\\n  '\n    del filename\n    del mode\n    source_ast = ast.parse(source)\n    final = source_ast.body[-1]\n    if isinstance(final, ast.Expr):\n        print_it = ast.Expr(lineno=-1, col_offset=-1, value=ast.Call(func=ast.Name(id='_print_if_not_none', ctx=ast.Load(), lineno=-1, col_offset=-1), lineno=-1, col_offset=-1, args=[final], keywords=[]))\n        source_ast.body[-1] = print_it\n        source = astor.to_source(source_ast)\n    return compile(source, filename='dummy.py', mode='exec', flags=flags, dont_inherit=dont_inherit, optimize=optimize)"
        ]
    }
]