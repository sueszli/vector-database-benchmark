[
    {
        "func_name": "_get_tracked_frame",
        "original": "def _get_tracked_frame(frame_id):\n    expr = ExprNode()\n    expr._cache._id = frame_id\n    return h2o.H2OFrame._expr(expr)",
        "mutated": [
            "def _get_tracked_frame(frame_id):\n    if False:\n        i = 10\n    expr = ExprNode()\n    expr._cache._id = frame_id\n    return h2o.H2OFrame._expr(expr)",
            "def _get_tracked_frame(frame_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    expr = ExprNode()\n    expr._cache._id = frame_id\n    return h2o.H2OFrame._expr(expr)",
            "def _get_tracked_frame(frame_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    expr = ExprNode()\n    expr._cache._id = frame_id\n    return h2o.H2OFrame._expr(expr)",
            "def _get_tracked_frame(frame_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    expr = ExprNode()\n    expr._cache._id = frame_id\n    return h2o.H2OFrame._expr(expr)",
            "def _get_tracked_frame(frame_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    expr = ExprNode()\n    expr._cache._id = frame_id\n    return h2o.H2OFrame._expr(expr)"
        ]
    },
    {
        "func_name": "fairness_metrics",
        "original": "def fairness_metrics(self, frame, protected_columns, reference, favorable_class):\n    \"\"\"\n        Calculate intersectional fairness metrics.\n\n        :param frame: Frame used to calculate the metrics.\n        :param protected_columns: List of categorical columns that contain sensitive information\n                                  such as race, gender, age etc.\n        :param reference: List of values corresponding to a reference for each protected columns.\n                          If set to None, it will use the biggest group as the reference.\n        :param favorable_class: Positive/favorable outcome class of the response.\n\n        :return: Dictionary of frames. One frame is the overview, other frames contain dependence\n                 of performance on threshold for each protected group.\n\n        :examples:\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\n        >>> x = ['LIMIT_BAL', 'AGE', 'PAY_0', 'PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', 'PAY_6', 'BILL_AMT1', 'BILL_AMT2', 'BILL_AMT3',\n        >>>      'BILL_AMT4', 'BILL_AMT5', 'BILL_AMT6', 'PAY_AMT1', 'PAY_AMT2', 'PAY_AMT3', 'PAY_AMT4', 'PAY_AMT5', 'PAY_AMT6']\n        >>> y = \"default payment next month\"\n        >>> protected_columns = ['SEX', 'EDUCATION']\n        >>>\n        >>> for c in [y] + protected_columns:\n        >>>     data[c] = data[c].asfactor()\n        >>>\n        >>> train, test = data.split_frame([0.8])\n        >>>\n        >>> reference = [\"1\", \"2\"]  # university educated single man\n        >>> favorable_class = \"0\"  # no default next month\n        >>>\n        >>> gbm = H2OGradientBoostingEstimator()\n        >>> gbm.train(x, y, training_frame=train)\n        >>>\n        >>> fairness_metrics = gbm.fairness_metrics(test, protected_columns, reference, favorable_class)\n        >>> display(fairness_metrics[\"overview\"])\n        \"\"\"\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.expr import ExprNode\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str], None)\n    assert_is_type(favorable_class, str)\n    expr = ExprNode('fairnessMetrics', self, frame, protected_columns, reference, favorable_class)\n    res = expr._eager_map_frame()\n\n    def _get_tracked_frame(frame_id):\n        expr = ExprNode()\n        expr._cache._id = frame_id\n        return h2o.H2OFrame._expr(expr)\n    return {n: _get_tracked_frame(f['key']['name']) for (n, f) in zip(res.map_keys['string'], res.frames)}",
        "mutated": [
            "def fairness_metrics(self, frame, protected_columns, reference, favorable_class):\n    if False:\n        i = 10\n    '\\n        Calculate intersectional fairness metrics.\\n\\n        :param frame: Frame used to calculate the metrics.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n\\n        :return: Dictionary of frames. One frame is the overview, other frames contain dependence\\n                 of performance on threshold for each protected group.\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> fairness_metrics = gbm.fairness_metrics(test, protected_columns, reference, favorable_class)\\n        >>> display(fairness_metrics[\"overview\"])\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.expr import ExprNode\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str], None)\n    assert_is_type(favorable_class, str)\n    expr = ExprNode('fairnessMetrics', self, frame, protected_columns, reference, favorable_class)\n    res = expr._eager_map_frame()\n\n    def _get_tracked_frame(frame_id):\n        expr = ExprNode()\n        expr._cache._id = frame_id\n        return h2o.H2OFrame._expr(expr)\n    return {n: _get_tracked_frame(f['key']['name']) for (n, f) in zip(res.map_keys['string'], res.frames)}",
            "def fairness_metrics(self, frame, protected_columns, reference, favorable_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Calculate intersectional fairness metrics.\\n\\n        :param frame: Frame used to calculate the metrics.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n\\n        :return: Dictionary of frames. One frame is the overview, other frames contain dependence\\n                 of performance on threshold for each protected group.\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> fairness_metrics = gbm.fairness_metrics(test, protected_columns, reference, favorable_class)\\n        >>> display(fairness_metrics[\"overview\"])\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.expr import ExprNode\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str], None)\n    assert_is_type(favorable_class, str)\n    expr = ExprNode('fairnessMetrics', self, frame, protected_columns, reference, favorable_class)\n    res = expr._eager_map_frame()\n\n    def _get_tracked_frame(frame_id):\n        expr = ExprNode()\n        expr._cache._id = frame_id\n        return h2o.H2OFrame._expr(expr)\n    return {n: _get_tracked_frame(f['key']['name']) for (n, f) in zip(res.map_keys['string'], res.frames)}",
            "def fairness_metrics(self, frame, protected_columns, reference, favorable_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Calculate intersectional fairness metrics.\\n\\n        :param frame: Frame used to calculate the metrics.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n\\n        :return: Dictionary of frames. One frame is the overview, other frames contain dependence\\n                 of performance on threshold for each protected group.\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> fairness_metrics = gbm.fairness_metrics(test, protected_columns, reference, favorable_class)\\n        >>> display(fairness_metrics[\"overview\"])\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.expr import ExprNode\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str], None)\n    assert_is_type(favorable_class, str)\n    expr = ExprNode('fairnessMetrics', self, frame, protected_columns, reference, favorable_class)\n    res = expr._eager_map_frame()\n\n    def _get_tracked_frame(frame_id):\n        expr = ExprNode()\n        expr._cache._id = frame_id\n        return h2o.H2OFrame._expr(expr)\n    return {n: _get_tracked_frame(f['key']['name']) for (n, f) in zip(res.map_keys['string'], res.frames)}",
            "def fairness_metrics(self, frame, protected_columns, reference, favorable_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Calculate intersectional fairness metrics.\\n\\n        :param frame: Frame used to calculate the metrics.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n\\n        :return: Dictionary of frames. One frame is the overview, other frames contain dependence\\n                 of performance on threshold for each protected group.\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> fairness_metrics = gbm.fairness_metrics(test, protected_columns, reference, favorable_class)\\n        >>> display(fairness_metrics[\"overview\"])\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.expr import ExprNode\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str], None)\n    assert_is_type(favorable_class, str)\n    expr = ExprNode('fairnessMetrics', self, frame, protected_columns, reference, favorable_class)\n    res = expr._eager_map_frame()\n\n    def _get_tracked_frame(frame_id):\n        expr = ExprNode()\n        expr._cache._id = frame_id\n        return h2o.H2OFrame._expr(expr)\n    return {n: _get_tracked_frame(f['key']['name']) for (n, f) in zip(res.map_keys['string'], res.frames)}",
            "def fairness_metrics(self, frame, protected_columns, reference, favorable_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Calculate intersectional fairness metrics.\\n\\n        :param frame: Frame used to calculate the metrics.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n\\n        :return: Dictionary of frames. One frame is the overview, other frames contain dependence\\n                 of performance on threshold for each protected group.\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> fairness_metrics = gbm.fairness_metrics(test, protected_columns, reference, favorable_class)\\n        >>> display(fairness_metrics[\"overview\"])\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.expr import ExprNode\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str], None)\n    assert_is_type(favorable_class, str)\n    expr = ExprNode('fairnessMetrics', self, frame, protected_columns, reference, favorable_class)\n    res = expr._eager_map_frame()\n\n    def _get_tracked_frame(frame_id):\n        expr = ExprNode()\n        expr._cache._id = frame_id\n        return h2o.H2OFrame._expr(expr)\n    return {n: _get_tracked_frame(f['key']['name']) for (n, f) in zip(res.map_keys['string'], res.frames)}"
        ]
    },
    {
        "func_name": "fair_pd_plot",
        "original": "def fair_pd_plot(self, frame, column, protected_columns, figsize=(16, 9), autoscale=True, save_plot_path=None):\n    \"\"\"\n        Partial dependence plot per protected group.\n\n        :param model: H2O Model Object\n        :param frame: H2OFrame\n        :param column: String containing column name.\n        :param protected_columns: List of categorical columns that contain sensitive information\n                                      such as race, gender, age etc.\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\n        :return: Matplotlib Figure object\n\n        :examples:\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\n        >>> x = ['LIMIT_BAL', 'AGE', 'PAY_0', 'PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', 'PAY_6', 'BILL_AMT1', 'BILL_AMT2', 'BILL_AMT3',\n        >>>      'BILL_AMT4', 'BILL_AMT5', 'BILL_AMT6', 'PAY_AMT1', 'PAY_AMT2', 'PAY_AMT3', 'PAY_AMT4', 'PAY_AMT5', 'PAY_AMT6']\n        >>> y = \"default payment next month\"\n        >>> protected_columns = ['SEX', 'EDUCATION']\n        >>>\n        >>> for c in [y] + protected_columns:\n        >>>     data[c] = data[c].asfactor()\n        >>>\n        >>> train, test = data.split_frame([0.8])\n        >>>\n        >>> reference = [\"1\", \"2\"]  # university educated man\n        >>> favorable_class = \"0\"  # no default next month\n        >>>\n        >>> gbm = H2OGradientBoostingEstimator()\n        >>> gbm.train(x, y, training_frame=train)\n        >>>\n        >>> gbm.fair_pd_plot(test, \"AGE\", protected_columns)\n        \"\"\"\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pd_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type, is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(autoscale, bool)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    plt.figure(figsize=figsize)\n    results = []\n    maxes = []\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            pd = self.partial_plot(filtered_hdf, cols=[column], plot=False, nbins=40)[0]\n            results.append((pg, pd))\n            if is_type(pd[column.lower()][0], str):\n                maxes.append(1)\n            else:\n                maxes.append(np.nanmax(pd[column.lower()]))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    is_factor = frame[column].isfactor()[0]\n    autoscale = autoscale and (not is_factor) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    for (pg, pd) in results:\n        x = pd[column.lower()]\n        if autoscale:\n            x = np.log1p(x)\n        mean_response = pd['mean_response']\n        stdev_response = pd['std_error_mean_response']\n        if is_factor:\n            plt.errorbar(x, mean_response, yerr=stdev_response, label=', '.join(pg), fmt='o', elinewidth=3, capsize=0, markersize=10)\n        else:\n            plt.plot(x, mean_response, label=', '.join(pg))\n            plt.fill_between(x, [m[0] - m[1] for m in zip(mean_response, stdev_response)], [m[0] + m[1] for m in zip(mean_response, stdev_response)], label='_noLabel', alpha=0.2)\n    plt.title('PDP for {}'.format(column))\n    plt.xlabel('log({})'.format(column) if autoscale else column)\n    plt.ylabel('Response')\n    plt.legend()\n    plt.grid()\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
        "mutated": [
            "def fair_pd_plot(self, frame, column, protected_columns, figsize=(16, 9), autoscale=True, save_plot_path=None):\n    if False:\n        i = 10\n    '\\n        Partial dependence plot per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                      such as race, gender, age etc.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pd_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pd_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type, is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(autoscale, bool)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    plt.figure(figsize=figsize)\n    results = []\n    maxes = []\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            pd = self.partial_plot(filtered_hdf, cols=[column], plot=False, nbins=40)[0]\n            results.append((pg, pd))\n            if is_type(pd[column.lower()][0], str):\n                maxes.append(1)\n            else:\n                maxes.append(np.nanmax(pd[column.lower()]))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    is_factor = frame[column].isfactor()[0]\n    autoscale = autoscale and (not is_factor) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    for (pg, pd) in results:\n        x = pd[column.lower()]\n        if autoscale:\n            x = np.log1p(x)\n        mean_response = pd['mean_response']\n        stdev_response = pd['std_error_mean_response']\n        if is_factor:\n            plt.errorbar(x, mean_response, yerr=stdev_response, label=', '.join(pg), fmt='o', elinewidth=3, capsize=0, markersize=10)\n        else:\n            plt.plot(x, mean_response, label=', '.join(pg))\n            plt.fill_between(x, [m[0] - m[1] for m in zip(mean_response, stdev_response)], [m[0] + m[1] for m in zip(mean_response, stdev_response)], label='_noLabel', alpha=0.2)\n    plt.title('PDP for {}'.format(column))\n    plt.xlabel('log({})'.format(column) if autoscale else column)\n    plt.ylabel('Response')\n    plt.legend()\n    plt.grid()\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_pd_plot(self, frame, column, protected_columns, figsize=(16, 9), autoscale=True, save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Partial dependence plot per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                      such as race, gender, age etc.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pd_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pd_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type, is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(autoscale, bool)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    plt.figure(figsize=figsize)\n    results = []\n    maxes = []\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            pd = self.partial_plot(filtered_hdf, cols=[column], plot=False, nbins=40)[0]\n            results.append((pg, pd))\n            if is_type(pd[column.lower()][0], str):\n                maxes.append(1)\n            else:\n                maxes.append(np.nanmax(pd[column.lower()]))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    is_factor = frame[column].isfactor()[0]\n    autoscale = autoscale and (not is_factor) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    for (pg, pd) in results:\n        x = pd[column.lower()]\n        if autoscale:\n            x = np.log1p(x)\n        mean_response = pd['mean_response']\n        stdev_response = pd['std_error_mean_response']\n        if is_factor:\n            plt.errorbar(x, mean_response, yerr=stdev_response, label=', '.join(pg), fmt='o', elinewidth=3, capsize=0, markersize=10)\n        else:\n            plt.plot(x, mean_response, label=', '.join(pg))\n            plt.fill_between(x, [m[0] - m[1] for m in zip(mean_response, stdev_response)], [m[0] + m[1] for m in zip(mean_response, stdev_response)], label='_noLabel', alpha=0.2)\n    plt.title('PDP for {}'.format(column))\n    plt.xlabel('log({})'.format(column) if autoscale else column)\n    plt.ylabel('Response')\n    plt.legend()\n    plt.grid()\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_pd_plot(self, frame, column, protected_columns, figsize=(16, 9), autoscale=True, save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Partial dependence plot per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                      such as race, gender, age etc.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pd_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pd_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type, is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(autoscale, bool)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    plt.figure(figsize=figsize)\n    results = []\n    maxes = []\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            pd = self.partial_plot(filtered_hdf, cols=[column], plot=False, nbins=40)[0]\n            results.append((pg, pd))\n            if is_type(pd[column.lower()][0], str):\n                maxes.append(1)\n            else:\n                maxes.append(np.nanmax(pd[column.lower()]))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    is_factor = frame[column].isfactor()[0]\n    autoscale = autoscale and (not is_factor) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    for (pg, pd) in results:\n        x = pd[column.lower()]\n        if autoscale:\n            x = np.log1p(x)\n        mean_response = pd['mean_response']\n        stdev_response = pd['std_error_mean_response']\n        if is_factor:\n            plt.errorbar(x, mean_response, yerr=stdev_response, label=', '.join(pg), fmt='o', elinewidth=3, capsize=0, markersize=10)\n        else:\n            plt.plot(x, mean_response, label=', '.join(pg))\n            plt.fill_between(x, [m[0] - m[1] for m in zip(mean_response, stdev_response)], [m[0] + m[1] for m in zip(mean_response, stdev_response)], label='_noLabel', alpha=0.2)\n    plt.title('PDP for {}'.format(column))\n    plt.xlabel('log({})'.format(column) if autoscale else column)\n    plt.ylabel('Response')\n    plt.legend()\n    plt.grid()\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_pd_plot(self, frame, column, protected_columns, figsize=(16, 9), autoscale=True, save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Partial dependence plot per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                      such as race, gender, age etc.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pd_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pd_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type, is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(autoscale, bool)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    plt.figure(figsize=figsize)\n    results = []\n    maxes = []\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            pd = self.partial_plot(filtered_hdf, cols=[column], plot=False, nbins=40)[0]\n            results.append((pg, pd))\n            if is_type(pd[column.lower()][0], str):\n                maxes.append(1)\n            else:\n                maxes.append(np.nanmax(pd[column.lower()]))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    is_factor = frame[column].isfactor()[0]\n    autoscale = autoscale and (not is_factor) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    for (pg, pd) in results:\n        x = pd[column.lower()]\n        if autoscale:\n            x = np.log1p(x)\n        mean_response = pd['mean_response']\n        stdev_response = pd['std_error_mean_response']\n        if is_factor:\n            plt.errorbar(x, mean_response, yerr=stdev_response, label=', '.join(pg), fmt='o', elinewidth=3, capsize=0, markersize=10)\n        else:\n            plt.plot(x, mean_response, label=', '.join(pg))\n            plt.fill_between(x, [m[0] - m[1] for m in zip(mean_response, stdev_response)], [m[0] + m[1] for m in zip(mean_response, stdev_response)], label='_noLabel', alpha=0.2)\n    plt.title('PDP for {}'.format(column))\n    plt.xlabel('log({})'.format(column) if autoscale else column)\n    plt.ylabel('Response')\n    plt.legend()\n    plt.grid()\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_pd_plot(self, frame, column, protected_columns, figsize=(16, 9), autoscale=True, save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Partial dependence plot per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                      such as race, gender, age etc.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pd_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pd_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type, is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(autoscale, bool)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    plt.figure(figsize=figsize)\n    results = []\n    maxes = []\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            pd = self.partial_plot(filtered_hdf, cols=[column], plot=False, nbins=40)[0]\n            results.append((pg, pd))\n            if is_type(pd[column.lower()][0], str):\n                maxes.append(1)\n            else:\n                maxes.append(np.nanmax(pd[column.lower()]))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    is_factor = frame[column].isfactor()[0]\n    autoscale = autoscale and (not is_factor) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    for (pg, pd) in results:\n        x = pd[column.lower()]\n        if autoscale:\n            x = np.log1p(x)\n        mean_response = pd['mean_response']\n        stdev_response = pd['std_error_mean_response']\n        if is_factor:\n            plt.errorbar(x, mean_response, yerr=stdev_response, label=', '.join(pg), fmt='o', elinewidth=3, capsize=0, markersize=10)\n        else:\n            plt.plot(x, mean_response, label=', '.join(pg))\n            plt.fill_between(x, [m[0] - m[1] for m in zip(mean_response, stdev_response)], [m[0] + m[1] for m in zip(mean_response, stdev_response)], label='_noLabel', alpha=0.2)\n    plt.title('PDP for {}'.format(column))\n    plt.xlabel('log({})'.format(column) if autoscale else column)\n    plt.ylabel('Response')\n    plt.legend()\n    plt.grid()\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()"
        ]
    },
    {
        "func_name": "fair_roc_plot",
        "original": "def fair_roc_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    \"\"\"\n        Plot ROC curve per protected group.\n\n        :param model: H2O Model Object\n        :param frame: H2OFrame\n        :param protected_columns: List of categorical columns that contain sensitive information\n                                  such as race, gender, age etc.\n        :param reference: List of values corresponding to a reference for each protected columns.\n                          If set to ``None``, it will use the biggest group as the reference.\n        :param favorable_class: Positive/favorable outcome class of the response.\n        :param figsize: Figure size; passed directly to Matplotlib\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\n\n        :return: Matplotlib Figure object\n\n        :examples:\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\n        >>> x = ['LIMIT_BAL', 'AGE', 'PAY_0', 'PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', 'PAY_6', 'BILL_AMT1', 'BILL_AMT2', 'BILL_AMT3',\n        >>>      'BILL_AMT4', 'BILL_AMT5', 'BILL_AMT6', 'PAY_AMT1', 'PAY_AMT2', 'PAY_AMT3', 'PAY_AMT4', 'PAY_AMT5', 'PAY_AMT6']\n        >>> y = \"default payment next month\"\n        >>> protected_columns = ['SEX', 'EDUCATION']\n        >>>\n        >>> for c in [y] + protected_columns:\n        >>>     data[c] = data[c].asfactor()\n        >>>\n        >>> train, test = data.split_frame([0.8])\n        >>>\n        >>> reference = [\"1\", \"2\"]  # university educated man\n        >>> favorable_class = \"0\"  # no default next month\n        >>>\n        >>> gbm = H2OGradientBoostingEstimator()\n        >>> gbm.train(x, y, training_frame=train)\n        >>>\n        >>> gbm.fair_roc_plot(test, protected_columns, reference, favorable_class)\n        \"\"\"\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_roc_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['fpr'], df['tpr'], label=roc[len(roc_prefix):])\n    plt.plot([0, 1], [0, 1], c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
        "mutated": [
            "def fair_roc_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n    '\\n        Plot ROC curve per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_roc_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_roc_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['fpr'], df['tpr'], label=roc[len(roc_prefix):])\n    plt.plot([0, 1], [0, 1], c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_roc_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Plot ROC curve per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_roc_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_roc_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['fpr'], df['tpr'], label=roc[len(roc_prefix):])\n    plt.plot([0, 1], [0, 1], c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_roc_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Plot ROC curve per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_roc_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_roc_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['fpr'], df['tpr'], label=roc[len(roc_prefix):])\n    plt.plot([0, 1], [0, 1], c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_roc_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Plot ROC curve per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_roc_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_roc_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['fpr'], df['tpr'], label=roc[len(roc_prefix):])\n    plt.plot([0, 1], [0, 1], c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_roc_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Plot ROC curve per protected group.\\n\\n        :param model: H2O Model Object\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_roc_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_roc_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['fpr'], df['tpr'], label=roc[len(roc_prefix):])\n    plt.plot([0, 1], [0, 1], c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()"
        ]
    },
    {
        "func_name": "fair_pr_plot",
        "original": "def fair_pr_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    \"\"\"\n        Plot PR curve per protected group.\n        :param frame: H2OFrame\n        :param protected_columns: List of categorical columns that contain sensitive information\n                                  such as race, gender, age etc.\n        :param reference: List of values corresponding to a reference for each protected columns.\n                          If set to ``None``, it will use the biggest group as the reference.\n        :param favorable_class: Positive/favorable outcome class of the response.\n        :param figsize: Figure size; passed directly to Matplotlib\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\n\n        :return: Matplotlib Figure object\n\n        :examples:\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\n        >>> x = ['LIMIT_BAL', 'AGE', 'PAY_0', 'PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', 'PAY_6', 'BILL_AMT1', 'BILL_AMT2', 'BILL_AMT3',\n        >>>      'BILL_AMT4', 'BILL_AMT5', 'BILL_AMT6', 'PAY_AMT1', 'PAY_AMT2', 'PAY_AMT3', 'PAY_AMT4', 'PAY_AMT5', 'PAY_AMT6']\n        >>> y = \"default payment next month\"\n        >>> protected_columns = ['SEX', 'EDUCATION']\n        >>>\n        >>> for c in [y] + protected_columns:\n        >>>     data[c] = data[c].asfactor()\n        >>>\n        >>> train, test = data.split_frame([0.8])\n        >>>\n        >>> reference = [\"1\", \"2\"]  # university educated man\n        >>> favorable_class = \"0\"  # no default next month\n        >>>\n        >>> gbm = H2OGradientBoostingEstimator()\n        >>> gbm.train(x, y, training_frame=train)\n        >>>\n        >>> gbm.fair_pr_plot(test, protected_columns, reference, favorable_class)\n        \"\"\"\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pr_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['recall'], df['precision'], label=roc[len(roc_prefix):])\n    mean = frame[self.actual_params['response_column']].mean()\n    if isinstance(mean, list):\n        mean = mean[0]\n    else:\n        mean = float(mean.as_data_frame(False, False)[0][0])\n    plt.axhline(y=mean, c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('Recall')\n    plt.ylabel('Precision')\n    plt.title('Precision-Recall Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
        "mutated": [
            "def fair_pr_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n    '\\n        Plot PR curve per protected group.\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pr_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pr_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['recall'], df['precision'], label=roc[len(roc_prefix):])\n    mean = frame[self.actual_params['response_column']].mean()\n    if isinstance(mean, list):\n        mean = mean[0]\n    else:\n        mean = float(mean.as_data_frame(False, False)[0][0])\n    plt.axhline(y=mean, c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('Recall')\n    plt.ylabel('Precision')\n    plt.title('Precision-Recall Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_pr_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Plot PR curve per protected group.\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pr_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pr_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['recall'], df['precision'], label=roc[len(roc_prefix):])\n    mean = frame[self.actual_params['response_column']].mean()\n    if isinstance(mean, list):\n        mean = mean[0]\n    else:\n        mean = float(mean.as_data_frame(False, False)[0][0])\n    plt.axhline(y=mean, c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('Recall')\n    plt.ylabel('Precision')\n    plt.title('Precision-Recall Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_pr_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Plot PR curve per protected group.\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pr_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pr_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['recall'], df['precision'], label=roc[len(roc_prefix):])\n    mean = frame[self.actual_params['response_column']].mean()\n    if isinstance(mean, list):\n        mean = mean[0]\n    else:\n        mean = float(mean.as_data_frame(False, False)[0][0])\n    plt.axhline(y=mean, c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('Recall')\n    plt.ylabel('Precision')\n    plt.title('Precision-Recall Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_pr_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Plot PR curve per protected group.\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pr_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pr_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['recall'], df['precision'], label=roc[len(roc_prefix):])\n    mean = frame[self.actual_params['response_column']].mean()\n    if isinstance(mean, list):\n        mean = mean[0]\n    else:\n        mean = float(mean.as_data_frame(False, False)[0][0])\n    plt.axhline(y=mean, c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('Recall')\n    plt.ylabel('Precision')\n    plt.title('Precision-Recall Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()",
            "def fair_pr_plot(self, frame, protected_columns, reference, favorable_class, figsize=(16, 9), save_plot_path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Plot PR curve per protected group.\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to ``None``, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param save_plot_path: A path to save the plot via using matplotlib function savefig.\\n\\n        :return: Matplotlib Figure object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_pr_plot(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.typechecks import assert_is_type\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_pr_plot.')\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.plot import get_matplotlib_pyplot\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(figsize, tuple, list)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    roc_prefix = 'thresholds_and_metrics_'\n    rocs = [k for k in fair.keys() if k.startswith(roc_prefix)]\n    plt.figure(figsize=figsize)\n    for roc in rocs:\n        df = NumpyFrame(fair[roc])\n        plt.plot(df['recall'], df['precision'], label=roc[len(roc_prefix):])\n    mean = frame[self.actual_params['response_column']].mean()\n    if isinstance(mean, list):\n        mean = mean[0]\n    else:\n        mean = float(mean.as_data_frame(False, False)[0][0])\n    plt.axhline(y=mean, c='gray', linestyle='dashed')\n    plt.grid()\n    plt.legend()\n    plt.xlabel('Recall')\n    plt.ylabel('Precision')\n    plt.title('Precision-Recall Curve')\n    if save_plot_path is not None:\n        plt.savefig(fname=save_plot_path)\n    return plt.gcf()"
        ]
    },
    {
        "func_name": "fair_shap_plot",
        "original": "def fair_shap_plot(self, frame, column, protected_columns, autoscale=True, figsize=(16, 9), jitter=0.35, alpha=1, save_plot_path_prefix=None, background_frame=None):\n    \"\"\"\n        SHAP summary plot for one feature with protected groups on y-axis.\n\n        :param frame: H2OFrame\n        :param column: String containing column name.\n        :param protected_columns: List of categorical columns that contain sensitive information\n                                  such as race, gender, age etc.\n        :param category: Used to specify what category to inspect when categorical feature is one hot encoded, typically in XGBoost.\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\n        :param jitter: Amount of jitter used to show the point density.\n        :param alpha: Transparency of the points.\n        :param save_plot_path_prefix: A prefix of the path to save the plot via using matplotlib function savefig. \n                                      The suffix of the path will be determined from a column name for which SHAP values\n                                      were calculated for.\n        :background_frame: Optional frame, that is used as the source of baselines for the marginal SHAP.\n        :return: H2OExplanation object\n\n        :examples:\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\n        >>> x = ['LIMIT_BAL', 'AGE', 'PAY_0', 'PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', 'PAY_6', 'BILL_AMT1', 'BILL_AMT2', 'BILL_AMT3',\n        >>>      'BILL_AMT4', 'BILL_AMT5', 'BILL_AMT6', 'PAY_AMT1', 'PAY_AMT2', 'PAY_AMT3', 'PAY_AMT4', 'PAY_AMT5', 'PAY_AMT6']\n        >>> y = \"default payment next month\"\n        >>> protected_columns = ['SEX', 'EDUCATION']\n        >>>\n        >>> for c in [y] + protected_columns:\n        >>>     data[c] = data[c].asfactor()\n        >>>\n        >>> train, test = data.split_frame([0.8])\n        >>>\n        >>> reference = [\"1\", \"2\"]  # university educated man\n        >>> favorable_class = \"0\"  # no default next month\n        >>>\n        >>> gbm = H2OGradientBoostingEstimator()\n        >>> gbm.train(x, y, training_frame=train)\n        >>>\n        >>> gbm.fair_shap_plot(test, \"AGE\", protected_columns)\n        \"\"\"\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_shap_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _density\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(jitter, float)\n    assert_is_type(alpha, float, int)\n    assert_is_type(autoscale, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    from h2o.plot import get_matplotlib_pyplot\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    results = defaultdict(list)\n    maxes = []\n    contr_columns = [column]\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            cont = NumpyFrame(self.predict_contributions(filtered_hdf, output_format='compact', background_frame=background_frame))\n            vals = NumpyFrame(filtered_hdf)[column]\n            if not np.all(np.isnan(vals)):\n                maxes.append(np.nanmax(vals))\n            if len(contr_columns) == 1 and all((c not in cont.columns for c in contr_columns)):\n                contr_columns = [c for c in cont.columns if c.startswith('{}.'.format(contr_columns[0]))]\n            for cc in contr_columns:\n                results[cc].append((pg, cont[cc], vals))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    autoscale = autoscale and (not frame[column].isfactor()[0]) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    plots = H2OExplanation()\n    for (contr_column, result) in results.items():\n        plt.figure(figsize=figsize)\n        for (i, (pg, contr, vals)) in enumerate(result):\n            if not np.any(np.isfinite(vals)) or np.nanmin(vals) == np.nanmax(vals):\n                plt.scatter(0, i, label=', '.join(pg), alpha=alpha, c='grey')\n                continue\n            indices = np.arange(len(contr))\n            np.random.shuffle(indices)\n            contr = contr[indices]\n            vals = vals[indices]\n            dens = _density(contr)\n            plt.scatter(x=contr, y=i + dens * np.random.uniform(-jitter, jitter, size=len(contr)), label=', '.join(pg), alpha=alpha, c=np.log1p(vals) if autoscale else vals)\n        plt.axvline(x=0, c='k')\n        plt.title('SHAP Contributions for {}'.format(contr_column))\n        plt.xlabel('Contribution of {}'.format(contr_column))\n        plt.ylabel('Sensitive Features')\n        plt.yticks(range(len(result)), [', '.join(pg) for (pg, _, _) in result])\n        plt.grid()\n        plt.colorbar().set_label('log({})'.format(contr_column) if autoscale else contr_column)\n        if save_plot_path_prefix is not None:\n            plt.savefig(fname=save_plot_path_prefix + '_' + contr_column)\n        plots[contr_column] = plt.gcf()\n    return plots",
        "mutated": [
            "def fair_shap_plot(self, frame, column, protected_columns, autoscale=True, figsize=(16, 9), jitter=0.35, alpha=1, save_plot_path_prefix=None, background_frame=None):\n    if False:\n        i = 10\n    '\\n        SHAP summary plot for one feature with protected groups on y-axis.\\n\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param category: Used to specify what category to inspect when categorical feature is one hot encoded, typically in XGBoost.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param jitter: Amount of jitter used to show the point density.\\n        :param alpha: Transparency of the points.\\n        :param save_plot_path_prefix: A prefix of the path to save the plot via using matplotlib function savefig. \\n                                      The suffix of the path will be determined from a column name for which SHAP values\\n                                      were calculated for.\\n        :background_frame: Optional frame, that is used as the source of baselines for the marginal SHAP.\\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_shap_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_shap_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _density\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(jitter, float)\n    assert_is_type(alpha, float, int)\n    assert_is_type(autoscale, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    from h2o.plot import get_matplotlib_pyplot\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    results = defaultdict(list)\n    maxes = []\n    contr_columns = [column]\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            cont = NumpyFrame(self.predict_contributions(filtered_hdf, output_format='compact', background_frame=background_frame))\n            vals = NumpyFrame(filtered_hdf)[column]\n            if not np.all(np.isnan(vals)):\n                maxes.append(np.nanmax(vals))\n            if len(contr_columns) == 1 and all((c not in cont.columns for c in contr_columns)):\n                contr_columns = [c for c in cont.columns if c.startswith('{}.'.format(contr_columns[0]))]\n            for cc in contr_columns:\n                results[cc].append((pg, cont[cc], vals))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    autoscale = autoscale and (not frame[column].isfactor()[0]) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    plots = H2OExplanation()\n    for (contr_column, result) in results.items():\n        plt.figure(figsize=figsize)\n        for (i, (pg, contr, vals)) in enumerate(result):\n            if not np.any(np.isfinite(vals)) or np.nanmin(vals) == np.nanmax(vals):\n                plt.scatter(0, i, label=', '.join(pg), alpha=alpha, c='grey')\n                continue\n            indices = np.arange(len(contr))\n            np.random.shuffle(indices)\n            contr = contr[indices]\n            vals = vals[indices]\n            dens = _density(contr)\n            plt.scatter(x=contr, y=i + dens * np.random.uniform(-jitter, jitter, size=len(contr)), label=', '.join(pg), alpha=alpha, c=np.log1p(vals) if autoscale else vals)\n        plt.axvline(x=0, c='k')\n        plt.title('SHAP Contributions for {}'.format(contr_column))\n        plt.xlabel('Contribution of {}'.format(contr_column))\n        plt.ylabel('Sensitive Features')\n        plt.yticks(range(len(result)), [', '.join(pg) for (pg, _, _) in result])\n        plt.grid()\n        plt.colorbar().set_label('log({})'.format(contr_column) if autoscale else contr_column)\n        if save_plot_path_prefix is not None:\n            plt.savefig(fname=save_plot_path_prefix + '_' + contr_column)\n        plots[contr_column] = plt.gcf()\n    return plots",
            "def fair_shap_plot(self, frame, column, protected_columns, autoscale=True, figsize=(16, 9), jitter=0.35, alpha=1, save_plot_path_prefix=None, background_frame=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        SHAP summary plot for one feature with protected groups on y-axis.\\n\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param category: Used to specify what category to inspect when categorical feature is one hot encoded, typically in XGBoost.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param jitter: Amount of jitter used to show the point density.\\n        :param alpha: Transparency of the points.\\n        :param save_plot_path_prefix: A prefix of the path to save the plot via using matplotlib function savefig. \\n                                      The suffix of the path will be determined from a column name for which SHAP values\\n                                      were calculated for.\\n        :background_frame: Optional frame, that is used as the source of baselines for the marginal SHAP.\\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_shap_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_shap_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _density\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(jitter, float)\n    assert_is_type(alpha, float, int)\n    assert_is_type(autoscale, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    from h2o.plot import get_matplotlib_pyplot\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    results = defaultdict(list)\n    maxes = []\n    contr_columns = [column]\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            cont = NumpyFrame(self.predict_contributions(filtered_hdf, output_format='compact', background_frame=background_frame))\n            vals = NumpyFrame(filtered_hdf)[column]\n            if not np.all(np.isnan(vals)):\n                maxes.append(np.nanmax(vals))\n            if len(contr_columns) == 1 and all((c not in cont.columns for c in contr_columns)):\n                contr_columns = [c for c in cont.columns if c.startswith('{}.'.format(contr_columns[0]))]\n            for cc in contr_columns:\n                results[cc].append((pg, cont[cc], vals))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    autoscale = autoscale and (not frame[column].isfactor()[0]) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    plots = H2OExplanation()\n    for (contr_column, result) in results.items():\n        plt.figure(figsize=figsize)\n        for (i, (pg, contr, vals)) in enumerate(result):\n            if not np.any(np.isfinite(vals)) or np.nanmin(vals) == np.nanmax(vals):\n                plt.scatter(0, i, label=', '.join(pg), alpha=alpha, c='grey')\n                continue\n            indices = np.arange(len(contr))\n            np.random.shuffle(indices)\n            contr = contr[indices]\n            vals = vals[indices]\n            dens = _density(contr)\n            plt.scatter(x=contr, y=i + dens * np.random.uniform(-jitter, jitter, size=len(contr)), label=', '.join(pg), alpha=alpha, c=np.log1p(vals) if autoscale else vals)\n        plt.axvline(x=0, c='k')\n        plt.title('SHAP Contributions for {}'.format(contr_column))\n        plt.xlabel('Contribution of {}'.format(contr_column))\n        plt.ylabel('Sensitive Features')\n        plt.yticks(range(len(result)), [', '.join(pg) for (pg, _, _) in result])\n        plt.grid()\n        plt.colorbar().set_label('log({})'.format(contr_column) if autoscale else contr_column)\n        if save_plot_path_prefix is not None:\n            plt.savefig(fname=save_plot_path_prefix + '_' + contr_column)\n        plots[contr_column] = plt.gcf()\n    return plots",
            "def fair_shap_plot(self, frame, column, protected_columns, autoscale=True, figsize=(16, 9), jitter=0.35, alpha=1, save_plot_path_prefix=None, background_frame=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        SHAP summary plot for one feature with protected groups on y-axis.\\n\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param category: Used to specify what category to inspect when categorical feature is one hot encoded, typically in XGBoost.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param jitter: Amount of jitter used to show the point density.\\n        :param alpha: Transparency of the points.\\n        :param save_plot_path_prefix: A prefix of the path to save the plot via using matplotlib function savefig. \\n                                      The suffix of the path will be determined from a column name for which SHAP values\\n                                      were calculated for.\\n        :background_frame: Optional frame, that is used as the source of baselines for the marginal SHAP.\\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_shap_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_shap_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _density\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(jitter, float)\n    assert_is_type(alpha, float, int)\n    assert_is_type(autoscale, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    from h2o.plot import get_matplotlib_pyplot\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    results = defaultdict(list)\n    maxes = []\n    contr_columns = [column]\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            cont = NumpyFrame(self.predict_contributions(filtered_hdf, output_format='compact', background_frame=background_frame))\n            vals = NumpyFrame(filtered_hdf)[column]\n            if not np.all(np.isnan(vals)):\n                maxes.append(np.nanmax(vals))\n            if len(contr_columns) == 1 and all((c not in cont.columns for c in contr_columns)):\n                contr_columns = [c for c in cont.columns if c.startswith('{}.'.format(contr_columns[0]))]\n            for cc in contr_columns:\n                results[cc].append((pg, cont[cc], vals))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    autoscale = autoscale and (not frame[column].isfactor()[0]) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    plots = H2OExplanation()\n    for (contr_column, result) in results.items():\n        plt.figure(figsize=figsize)\n        for (i, (pg, contr, vals)) in enumerate(result):\n            if not np.any(np.isfinite(vals)) or np.nanmin(vals) == np.nanmax(vals):\n                plt.scatter(0, i, label=', '.join(pg), alpha=alpha, c='grey')\n                continue\n            indices = np.arange(len(contr))\n            np.random.shuffle(indices)\n            contr = contr[indices]\n            vals = vals[indices]\n            dens = _density(contr)\n            plt.scatter(x=contr, y=i + dens * np.random.uniform(-jitter, jitter, size=len(contr)), label=', '.join(pg), alpha=alpha, c=np.log1p(vals) if autoscale else vals)\n        plt.axvline(x=0, c='k')\n        plt.title('SHAP Contributions for {}'.format(contr_column))\n        plt.xlabel('Contribution of {}'.format(contr_column))\n        plt.ylabel('Sensitive Features')\n        plt.yticks(range(len(result)), [', '.join(pg) for (pg, _, _) in result])\n        plt.grid()\n        plt.colorbar().set_label('log({})'.format(contr_column) if autoscale else contr_column)\n        if save_plot_path_prefix is not None:\n            plt.savefig(fname=save_plot_path_prefix + '_' + contr_column)\n        plots[contr_column] = plt.gcf()\n    return plots",
            "def fair_shap_plot(self, frame, column, protected_columns, autoscale=True, figsize=(16, 9), jitter=0.35, alpha=1, save_plot_path_prefix=None, background_frame=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        SHAP summary plot for one feature with protected groups on y-axis.\\n\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param category: Used to specify what category to inspect when categorical feature is one hot encoded, typically in XGBoost.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param jitter: Amount of jitter used to show the point density.\\n        :param alpha: Transparency of the points.\\n        :param save_plot_path_prefix: A prefix of the path to save the plot via using matplotlib function savefig. \\n                                      The suffix of the path will be determined from a column name for which SHAP values\\n                                      were calculated for.\\n        :background_frame: Optional frame, that is used as the source of baselines for the marginal SHAP.\\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_shap_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_shap_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _density\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(jitter, float)\n    assert_is_type(alpha, float, int)\n    assert_is_type(autoscale, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    from h2o.plot import get_matplotlib_pyplot\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    results = defaultdict(list)\n    maxes = []\n    contr_columns = [column]\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            cont = NumpyFrame(self.predict_contributions(filtered_hdf, output_format='compact', background_frame=background_frame))\n            vals = NumpyFrame(filtered_hdf)[column]\n            if not np.all(np.isnan(vals)):\n                maxes.append(np.nanmax(vals))\n            if len(contr_columns) == 1 and all((c not in cont.columns for c in contr_columns)):\n                contr_columns = [c for c in cont.columns if c.startswith('{}.'.format(contr_columns[0]))]\n            for cc in contr_columns:\n                results[cc].append((pg, cont[cc], vals))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    autoscale = autoscale and (not frame[column].isfactor()[0]) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    plots = H2OExplanation()\n    for (contr_column, result) in results.items():\n        plt.figure(figsize=figsize)\n        for (i, (pg, contr, vals)) in enumerate(result):\n            if not np.any(np.isfinite(vals)) or np.nanmin(vals) == np.nanmax(vals):\n                plt.scatter(0, i, label=', '.join(pg), alpha=alpha, c='grey')\n                continue\n            indices = np.arange(len(contr))\n            np.random.shuffle(indices)\n            contr = contr[indices]\n            vals = vals[indices]\n            dens = _density(contr)\n            plt.scatter(x=contr, y=i + dens * np.random.uniform(-jitter, jitter, size=len(contr)), label=', '.join(pg), alpha=alpha, c=np.log1p(vals) if autoscale else vals)\n        plt.axvline(x=0, c='k')\n        plt.title('SHAP Contributions for {}'.format(contr_column))\n        plt.xlabel('Contribution of {}'.format(contr_column))\n        plt.ylabel('Sensitive Features')\n        plt.yticks(range(len(result)), [', '.join(pg) for (pg, _, _) in result])\n        plt.grid()\n        plt.colorbar().set_label('log({})'.format(contr_column) if autoscale else contr_column)\n        if save_plot_path_prefix is not None:\n            plt.savefig(fname=save_plot_path_prefix + '_' + contr_column)\n        plots[contr_column] = plt.gcf()\n    return plots",
            "def fair_shap_plot(self, frame, column, protected_columns, autoscale=True, figsize=(16, 9), jitter=0.35, alpha=1, save_plot_path_prefix=None, background_frame=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        SHAP summary plot for one feature with protected groups on y-axis.\\n\\n        :param frame: H2OFrame\\n        :param column: String containing column name.\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param category: Used to specify what category to inspect when categorical feature is one hot encoded, typically in XGBoost.\\n        :param autoscale: If ``True``, try to guess when to use log transformation on X axis.\\n        :param figsize: Tuple with figure size; passed directly to matplotlib.\\n        :param jitter: Amount of jitter used to show the point density.\\n        :param alpha: Transparency of the points.\\n        :param save_plot_path_prefix: A prefix of the path to save the plot via using matplotlib function savefig. \\n                                      The suffix of the path will be determined from a column name for which SHAP values\\n                                      were calculated for.\\n        :background_frame: Optional frame, that is used as the source of baselines for the marginal SHAP.\\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.fair_shap_plot(test, \"AGE\", protected_columns)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for fair_shap_plot.')\n    import numpy as np\n    from h2o.explanation._explain import no_progress_block\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _density\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(column, str)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(jitter, float)\n    assert_is_type(alpha, float, int)\n    assert_is_type(autoscale, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    from h2o.plot import get_matplotlib_pyplot\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    pgs = product(*[frame[col].unique()['C1'].as_data_frame(False, False) for col in protected_columns])\n    results = defaultdict(list)\n    maxes = []\n    contr_columns = [column]\n    with no_progress_block():\n        for pg in pgs:\n            pg = [p[0] for p in pg]\n            filtered_hdf = frame\n            for i in range(len(protected_columns)):\n                filtered_hdf = filtered_hdf[filtered_hdf[protected_columns[i]] == pg[i], :]\n            if filtered_hdf.nrow == 0:\n                continue\n            cont = NumpyFrame(self.predict_contributions(filtered_hdf, output_format='compact', background_frame=background_frame))\n            vals = NumpyFrame(filtered_hdf)[column]\n            if not np.all(np.isnan(vals)):\n                maxes.append(np.nanmax(vals))\n            if len(contr_columns) == 1 and all((c not in cont.columns for c in contr_columns)):\n                contr_columns = [c for c in cont.columns if c.startswith('{}.'.format(contr_columns[0]))]\n            for cc in contr_columns:\n                results[cc].append((pg, cont[cc], vals))\n    maxes = np.array(maxes) - np.min(maxes) + 1\n    autoscale = autoscale and (not frame[column].isfactor()[0]) and (frame[column].min() > -1) and (np.nanmax(np.log(maxes)) - np.nanmin(np.log(maxes)) > 1).all()\n    plots = H2OExplanation()\n    for (contr_column, result) in results.items():\n        plt.figure(figsize=figsize)\n        for (i, (pg, contr, vals)) in enumerate(result):\n            if not np.any(np.isfinite(vals)) or np.nanmin(vals) == np.nanmax(vals):\n                plt.scatter(0, i, label=', '.join(pg), alpha=alpha, c='grey')\n                continue\n            indices = np.arange(len(contr))\n            np.random.shuffle(indices)\n            contr = contr[indices]\n            vals = vals[indices]\n            dens = _density(contr)\n            plt.scatter(x=contr, y=i + dens * np.random.uniform(-jitter, jitter, size=len(contr)), label=', '.join(pg), alpha=alpha, c=np.log1p(vals) if autoscale else vals)\n        plt.axvline(x=0, c='k')\n        plt.title('SHAP Contributions for {}'.format(contr_column))\n        plt.xlabel('Contribution of {}'.format(contr_column))\n        plt.ylabel('Sensitive Features')\n        plt.yticks(range(len(result)), [', '.join(pg) for (pg, _, _) in result])\n        plt.grid()\n        plt.colorbar().set_label('log({})'.format(contr_column) if autoscale else contr_column)\n        if save_plot_path_prefix is not None:\n            plt.savefig(fname=save_plot_path_prefix + '_' + contr_column)\n        plots[contr_column] = plt.gcf()\n    return plots"
        ]
    },
    {
        "func_name": "_permute",
        "original": "def _permute(x):\n    return [x[i] for i in permutation]",
        "mutated": [
            "def _permute(x):\n    if False:\n        i = 10\n    return [x[i] for i in permutation]",
            "def _permute(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [x[i] for i in permutation]",
            "def _permute(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [x[i] for i in permutation]",
            "def _permute(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [x[i] for i in permutation]",
            "def _permute(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [x[i] for i in permutation]"
        ]
    },
    {
        "func_name": "inspect_model_fairness",
        "original": "def inspect_model_fairness(self, frame, protected_columns, reference, favorable_class, metrics=('auc', 'aucpr', 'f1', 'p.value', 'selectedRatio', 'total'), figsize=(16, 9), render=True, background_frame=None):\n    \"\"\"\n         Produce plots and dataframes related to a single model fairness.\n\n        :param frame: H2OFrame\n        :param protected_columns: List of categorical columns that contain sensitive information\n                                  such as race, gender, age etc.\n        :param reference: List of values corresponding to a reference for each protected columns.\n                          If set to None, it will use the biggest group as the reference.\n        :param favorable_class: Positive/favorable outcome class of the response.\n        :param metrics: List of metrics to show.\n        :param figsize: Figure size; passed directly to Matplotlib\n        :param render: if ``True``, render the model explanations; otherwise model explanations are just returned.\n        :param background_frame: optional frame, that is used as the source of baselines for the marginal SHAP.\n                                 Setting it enables calculating SHAP in more models but it can be more time and memory consuming. \n        :return: H2OExplanation object\n\n        :examples:\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\n        >>> x = ['LIMIT_BAL', 'AGE', 'PAY_0', 'PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', 'PAY_6', 'BILL_AMT1', 'BILL_AMT2', 'BILL_AMT3',\n        >>>      'BILL_AMT4', 'BILL_AMT5', 'BILL_AMT6', 'PAY_AMT1', 'PAY_AMT2', 'PAY_AMT3', 'PAY_AMT4', 'PAY_AMT5', 'PAY_AMT6']\n        >>> y = \"default payment next month\"\n        >>> protected_columns = ['SEX', 'EDUCATION']\n        >>>\n        >>> for c in [y] + protected_columns:\n        >>>     data[c] = data[c].asfactor()\n        >>>\n        >>> train, test = data.split_frame([0.8])\n        >>>\n        >>> reference = [\"1\", \"2\"]  # university educated single man\n        >>> favorable_class = \"0\"  # no default next month\n        >>>\n        >>> gbm = H2OGradientBoostingEstimator()\n        >>> gbm.train(x, y, training_frame=train)\n        >>>\n        >>> gbm.inspect_model_fairness(test, protected_columns, reference, favorable_class)\n        \"\"\"\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for inspect_model_fairness.')\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation import Description\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _display, _dont_display, Header, _is_tree_model\n    from h2o.model.extensions import has_extension\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(metrics, [str], tuple)\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(render, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    reference_frame = frame\n    for (i, pc) in enumerate(protected_columns):\n        reference_frame = reference_frame[reference_frame[pc] == reference[i], :]\n    cols_to_show = sorted(list(set(metrics).union({'AIR_{}'.format(m) for m in metrics}).intersection(fair['overview'].columns)))\n    overview = fair['overview']\n    if render:\n        display = _display\n    else:\n        display = _dont_display\n    result = H2OExplanation()\n    result['overview'] = H2OExplanation()\n    result['overview']['header'] = display(Header('Overview for model ' + self.model_id))\n    result['overview']['description'] = display(Description('fairness_metrics'))\n    with local_context(rows=overview.nrow):\n        result['overview']['data'] = display(overview[:, protected_columns + cols_to_show])\n    groups = [', '.join(r) for r in overview[:, protected_columns].as_data_frame(False, False)]\n    reference_name = ', '.join(reference)\n    result['overview']['plots'] = H2OExplanation()\n    overview = NumpyFrame(overview)\n    permutation = sorted(range(overview.nrow), key=lambda i: -overview[i, 'auc'])\n\n    def _permute(x):\n        return [x[i] for i in permutation]\n    groups = _permute(groups)\n    for col in cols_to_show:\n        plt.figure(figsize=figsize)\n        plt.title(col)\n        if 'AIR_' in col:\n            plt.bar(groups, _permute([a - 1 for a in overview[col]]), bottom=1)\n            plt.axhline(1, c='k')\n            plt.axhline(0.8, c='gray', linestyle='dashed')\n            plt.axhline(1.25, c='gray', linestyle='dashed')\n        elif 'p-value' in col:\n            plt.bar(groups, _permute(overview[col]))\n            plt.axhline(0.05, c='r')\n            plt.axhspan(0, 0.05, color='r', alpha=0.1)\n        else:\n            plt.bar(groups, _permute(overview[col]), color=['C1' if g == reference_name else 'C0' for g in groups])\n        plt.grid()\n        plt.xticks(rotation=90)\n        result['overview']['plots'][col] = display(plt.gcf())\n    result['ROC'] = H2OExplanation()\n    result['ROC']['header'] = display(Header('ROC'))\n    result['ROC']['description'] = display(Description('fairness_roc'))\n    result['ROC']['plot'] = display(self.fair_roc_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    result['PR'] = H2OExplanation()\n    result['PR']['header'] = display(Header('Precision-Recall Curve'))\n    result['PR']['description'] = display(Description('fairness_prc'))\n    result['PR']['plot'] = display(self.fair_pr_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    perm = self.permutation_importance(frame)\n    result['permutation_importance'] = H2OExplanation()\n    result['permutation_importance']['header'] = display(Header('Permutation Variable Importance'))\n    result['permutation_importance']['description'] = display(Description('fairness_varimp'))\n    result['permutation_importance']['data'] = display(perm)\n    sorted_features = list(perm['Variable'])\n    result['pdp'] = H2OExplanation()\n    result['pdp']['header'] = display(Header('Partial Dependence Plots for Individual Protected Groups'))\n    result['pdp']['description'] = display(Description('fairness_pdp'))\n    result['pdp']['plots'] = H2OExplanation()\n    for col in sorted_features:\n        result['pdp']['plots'][col] = display(self.fair_pd_plot(frame, col, protected_columns, figsize=figsize))\n    if has_extension(self, 'Contributions') and (_is_tree_model(self) or background_frame is not None):\n        result['shap'] = H2OExplanation()\n        result['shap']['header'] = display(Header('SHAP for Individual Protected Groups'))\n        result['shap']['description'] = display(Description('fairness_shap'))\n        result['shap']['plots'] = H2OExplanation()\n        for col in sorted_features:\n            result['shap']['plots'][col] = display(self.fair_shap_plot(frame, col, protected_columns, figsize=figsize, background_frame=background_frame))\n    return result",
        "mutated": [
            "def inspect_model_fairness(self, frame, protected_columns, reference, favorable_class, metrics=('auc', 'aucpr', 'f1', 'p.value', 'selectedRatio', 'total'), figsize=(16, 9), render=True, background_frame=None):\n    if False:\n        i = 10\n    '\\n         Produce plots and dataframes related to a single model fairness.\\n\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param metrics: List of metrics to show.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param render: if ``True``, render the model explanations; otherwise model explanations are just returned.\\n        :param background_frame: optional frame, that is used as the source of baselines for the marginal SHAP.\\n                                 Setting it enables calculating SHAP in more models but it can be more time and memory consuming. \\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.inspect_model_fairness(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for inspect_model_fairness.')\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation import Description\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _display, _dont_display, Header, _is_tree_model\n    from h2o.model.extensions import has_extension\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(metrics, [str], tuple)\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(render, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    reference_frame = frame\n    for (i, pc) in enumerate(protected_columns):\n        reference_frame = reference_frame[reference_frame[pc] == reference[i], :]\n    cols_to_show = sorted(list(set(metrics).union({'AIR_{}'.format(m) for m in metrics}).intersection(fair['overview'].columns)))\n    overview = fair['overview']\n    if render:\n        display = _display\n    else:\n        display = _dont_display\n    result = H2OExplanation()\n    result['overview'] = H2OExplanation()\n    result['overview']['header'] = display(Header('Overview for model ' + self.model_id))\n    result['overview']['description'] = display(Description('fairness_metrics'))\n    with local_context(rows=overview.nrow):\n        result['overview']['data'] = display(overview[:, protected_columns + cols_to_show])\n    groups = [', '.join(r) for r in overview[:, protected_columns].as_data_frame(False, False)]\n    reference_name = ', '.join(reference)\n    result['overview']['plots'] = H2OExplanation()\n    overview = NumpyFrame(overview)\n    permutation = sorted(range(overview.nrow), key=lambda i: -overview[i, 'auc'])\n\n    def _permute(x):\n        return [x[i] for i in permutation]\n    groups = _permute(groups)\n    for col in cols_to_show:\n        plt.figure(figsize=figsize)\n        plt.title(col)\n        if 'AIR_' in col:\n            plt.bar(groups, _permute([a - 1 for a in overview[col]]), bottom=1)\n            plt.axhline(1, c='k')\n            plt.axhline(0.8, c='gray', linestyle='dashed')\n            plt.axhline(1.25, c='gray', linestyle='dashed')\n        elif 'p-value' in col:\n            plt.bar(groups, _permute(overview[col]))\n            plt.axhline(0.05, c='r')\n            plt.axhspan(0, 0.05, color='r', alpha=0.1)\n        else:\n            plt.bar(groups, _permute(overview[col]), color=['C1' if g == reference_name else 'C0' for g in groups])\n        plt.grid()\n        plt.xticks(rotation=90)\n        result['overview']['plots'][col] = display(plt.gcf())\n    result['ROC'] = H2OExplanation()\n    result['ROC']['header'] = display(Header('ROC'))\n    result['ROC']['description'] = display(Description('fairness_roc'))\n    result['ROC']['plot'] = display(self.fair_roc_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    result['PR'] = H2OExplanation()\n    result['PR']['header'] = display(Header('Precision-Recall Curve'))\n    result['PR']['description'] = display(Description('fairness_prc'))\n    result['PR']['plot'] = display(self.fair_pr_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    perm = self.permutation_importance(frame)\n    result['permutation_importance'] = H2OExplanation()\n    result['permutation_importance']['header'] = display(Header('Permutation Variable Importance'))\n    result['permutation_importance']['description'] = display(Description('fairness_varimp'))\n    result['permutation_importance']['data'] = display(perm)\n    sorted_features = list(perm['Variable'])\n    result['pdp'] = H2OExplanation()\n    result['pdp']['header'] = display(Header('Partial Dependence Plots for Individual Protected Groups'))\n    result['pdp']['description'] = display(Description('fairness_pdp'))\n    result['pdp']['plots'] = H2OExplanation()\n    for col in sorted_features:\n        result['pdp']['plots'][col] = display(self.fair_pd_plot(frame, col, protected_columns, figsize=figsize))\n    if has_extension(self, 'Contributions') and (_is_tree_model(self) or background_frame is not None):\n        result['shap'] = H2OExplanation()\n        result['shap']['header'] = display(Header('SHAP for Individual Protected Groups'))\n        result['shap']['description'] = display(Description('fairness_shap'))\n        result['shap']['plots'] = H2OExplanation()\n        for col in sorted_features:\n            result['shap']['plots'][col] = display(self.fair_shap_plot(frame, col, protected_columns, figsize=figsize, background_frame=background_frame))\n    return result",
            "def inspect_model_fairness(self, frame, protected_columns, reference, favorable_class, metrics=('auc', 'aucpr', 'f1', 'p.value', 'selectedRatio', 'total'), figsize=(16, 9), render=True, background_frame=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n         Produce plots and dataframes related to a single model fairness.\\n\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param metrics: List of metrics to show.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param render: if ``True``, render the model explanations; otherwise model explanations are just returned.\\n        :param background_frame: optional frame, that is used as the source of baselines for the marginal SHAP.\\n                                 Setting it enables calculating SHAP in more models but it can be more time and memory consuming. \\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.inspect_model_fairness(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for inspect_model_fairness.')\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation import Description\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _display, _dont_display, Header, _is_tree_model\n    from h2o.model.extensions import has_extension\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(metrics, [str], tuple)\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(render, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    reference_frame = frame\n    for (i, pc) in enumerate(protected_columns):\n        reference_frame = reference_frame[reference_frame[pc] == reference[i], :]\n    cols_to_show = sorted(list(set(metrics).union({'AIR_{}'.format(m) for m in metrics}).intersection(fair['overview'].columns)))\n    overview = fair['overview']\n    if render:\n        display = _display\n    else:\n        display = _dont_display\n    result = H2OExplanation()\n    result['overview'] = H2OExplanation()\n    result['overview']['header'] = display(Header('Overview for model ' + self.model_id))\n    result['overview']['description'] = display(Description('fairness_metrics'))\n    with local_context(rows=overview.nrow):\n        result['overview']['data'] = display(overview[:, protected_columns + cols_to_show])\n    groups = [', '.join(r) for r in overview[:, protected_columns].as_data_frame(False, False)]\n    reference_name = ', '.join(reference)\n    result['overview']['plots'] = H2OExplanation()\n    overview = NumpyFrame(overview)\n    permutation = sorted(range(overview.nrow), key=lambda i: -overview[i, 'auc'])\n\n    def _permute(x):\n        return [x[i] for i in permutation]\n    groups = _permute(groups)\n    for col in cols_to_show:\n        plt.figure(figsize=figsize)\n        plt.title(col)\n        if 'AIR_' in col:\n            plt.bar(groups, _permute([a - 1 for a in overview[col]]), bottom=1)\n            plt.axhline(1, c='k')\n            plt.axhline(0.8, c='gray', linestyle='dashed')\n            plt.axhline(1.25, c='gray', linestyle='dashed')\n        elif 'p-value' in col:\n            plt.bar(groups, _permute(overview[col]))\n            plt.axhline(0.05, c='r')\n            plt.axhspan(0, 0.05, color='r', alpha=0.1)\n        else:\n            plt.bar(groups, _permute(overview[col]), color=['C1' if g == reference_name else 'C0' for g in groups])\n        plt.grid()\n        plt.xticks(rotation=90)\n        result['overview']['plots'][col] = display(plt.gcf())\n    result['ROC'] = H2OExplanation()\n    result['ROC']['header'] = display(Header('ROC'))\n    result['ROC']['description'] = display(Description('fairness_roc'))\n    result['ROC']['plot'] = display(self.fair_roc_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    result['PR'] = H2OExplanation()\n    result['PR']['header'] = display(Header('Precision-Recall Curve'))\n    result['PR']['description'] = display(Description('fairness_prc'))\n    result['PR']['plot'] = display(self.fair_pr_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    perm = self.permutation_importance(frame)\n    result['permutation_importance'] = H2OExplanation()\n    result['permutation_importance']['header'] = display(Header('Permutation Variable Importance'))\n    result['permutation_importance']['description'] = display(Description('fairness_varimp'))\n    result['permutation_importance']['data'] = display(perm)\n    sorted_features = list(perm['Variable'])\n    result['pdp'] = H2OExplanation()\n    result['pdp']['header'] = display(Header('Partial Dependence Plots for Individual Protected Groups'))\n    result['pdp']['description'] = display(Description('fairness_pdp'))\n    result['pdp']['plots'] = H2OExplanation()\n    for col in sorted_features:\n        result['pdp']['plots'][col] = display(self.fair_pd_plot(frame, col, protected_columns, figsize=figsize))\n    if has_extension(self, 'Contributions') and (_is_tree_model(self) or background_frame is not None):\n        result['shap'] = H2OExplanation()\n        result['shap']['header'] = display(Header('SHAP for Individual Protected Groups'))\n        result['shap']['description'] = display(Description('fairness_shap'))\n        result['shap']['plots'] = H2OExplanation()\n        for col in sorted_features:\n            result['shap']['plots'][col] = display(self.fair_shap_plot(frame, col, protected_columns, figsize=figsize, background_frame=background_frame))\n    return result",
            "def inspect_model_fairness(self, frame, protected_columns, reference, favorable_class, metrics=('auc', 'aucpr', 'f1', 'p.value', 'selectedRatio', 'total'), figsize=(16, 9), render=True, background_frame=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n         Produce plots and dataframes related to a single model fairness.\\n\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param metrics: List of metrics to show.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param render: if ``True``, render the model explanations; otherwise model explanations are just returned.\\n        :param background_frame: optional frame, that is used as the source of baselines for the marginal SHAP.\\n                                 Setting it enables calculating SHAP in more models but it can be more time and memory consuming. \\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.inspect_model_fairness(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for inspect_model_fairness.')\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation import Description\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _display, _dont_display, Header, _is_tree_model\n    from h2o.model.extensions import has_extension\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(metrics, [str], tuple)\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(render, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    reference_frame = frame\n    for (i, pc) in enumerate(protected_columns):\n        reference_frame = reference_frame[reference_frame[pc] == reference[i], :]\n    cols_to_show = sorted(list(set(metrics).union({'AIR_{}'.format(m) for m in metrics}).intersection(fair['overview'].columns)))\n    overview = fair['overview']\n    if render:\n        display = _display\n    else:\n        display = _dont_display\n    result = H2OExplanation()\n    result['overview'] = H2OExplanation()\n    result['overview']['header'] = display(Header('Overview for model ' + self.model_id))\n    result['overview']['description'] = display(Description('fairness_metrics'))\n    with local_context(rows=overview.nrow):\n        result['overview']['data'] = display(overview[:, protected_columns + cols_to_show])\n    groups = [', '.join(r) for r in overview[:, protected_columns].as_data_frame(False, False)]\n    reference_name = ', '.join(reference)\n    result['overview']['plots'] = H2OExplanation()\n    overview = NumpyFrame(overview)\n    permutation = sorted(range(overview.nrow), key=lambda i: -overview[i, 'auc'])\n\n    def _permute(x):\n        return [x[i] for i in permutation]\n    groups = _permute(groups)\n    for col in cols_to_show:\n        plt.figure(figsize=figsize)\n        plt.title(col)\n        if 'AIR_' in col:\n            plt.bar(groups, _permute([a - 1 for a in overview[col]]), bottom=1)\n            plt.axhline(1, c='k')\n            plt.axhline(0.8, c='gray', linestyle='dashed')\n            plt.axhline(1.25, c='gray', linestyle='dashed')\n        elif 'p-value' in col:\n            plt.bar(groups, _permute(overview[col]))\n            plt.axhline(0.05, c='r')\n            plt.axhspan(0, 0.05, color='r', alpha=0.1)\n        else:\n            plt.bar(groups, _permute(overview[col]), color=['C1' if g == reference_name else 'C0' for g in groups])\n        plt.grid()\n        plt.xticks(rotation=90)\n        result['overview']['plots'][col] = display(plt.gcf())\n    result['ROC'] = H2OExplanation()\n    result['ROC']['header'] = display(Header('ROC'))\n    result['ROC']['description'] = display(Description('fairness_roc'))\n    result['ROC']['plot'] = display(self.fair_roc_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    result['PR'] = H2OExplanation()\n    result['PR']['header'] = display(Header('Precision-Recall Curve'))\n    result['PR']['description'] = display(Description('fairness_prc'))\n    result['PR']['plot'] = display(self.fair_pr_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    perm = self.permutation_importance(frame)\n    result['permutation_importance'] = H2OExplanation()\n    result['permutation_importance']['header'] = display(Header('Permutation Variable Importance'))\n    result['permutation_importance']['description'] = display(Description('fairness_varimp'))\n    result['permutation_importance']['data'] = display(perm)\n    sorted_features = list(perm['Variable'])\n    result['pdp'] = H2OExplanation()\n    result['pdp']['header'] = display(Header('Partial Dependence Plots for Individual Protected Groups'))\n    result['pdp']['description'] = display(Description('fairness_pdp'))\n    result['pdp']['plots'] = H2OExplanation()\n    for col in sorted_features:\n        result['pdp']['plots'][col] = display(self.fair_pd_plot(frame, col, protected_columns, figsize=figsize))\n    if has_extension(self, 'Contributions') and (_is_tree_model(self) or background_frame is not None):\n        result['shap'] = H2OExplanation()\n        result['shap']['header'] = display(Header('SHAP for Individual Protected Groups'))\n        result['shap']['description'] = display(Description('fairness_shap'))\n        result['shap']['plots'] = H2OExplanation()\n        for col in sorted_features:\n            result['shap']['plots'][col] = display(self.fair_shap_plot(frame, col, protected_columns, figsize=figsize, background_frame=background_frame))\n    return result",
            "def inspect_model_fairness(self, frame, protected_columns, reference, favorable_class, metrics=('auc', 'aucpr', 'f1', 'p.value', 'selectedRatio', 'total'), figsize=(16, 9), render=True, background_frame=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n         Produce plots and dataframes related to a single model fairness.\\n\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param metrics: List of metrics to show.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param render: if ``True``, render the model explanations; otherwise model explanations are just returned.\\n        :param background_frame: optional frame, that is used as the source of baselines for the marginal SHAP.\\n                                 Setting it enables calculating SHAP in more models but it can be more time and memory consuming. \\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.inspect_model_fairness(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for inspect_model_fairness.')\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation import Description\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _display, _dont_display, Header, _is_tree_model\n    from h2o.model.extensions import has_extension\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(metrics, [str], tuple)\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(render, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    reference_frame = frame\n    for (i, pc) in enumerate(protected_columns):\n        reference_frame = reference_frame[reference_frame[pc] == reference[i], :]\n    cols_to_show = sorted(list(set(metrics).union({'AIR_{}'.format(m) for m in metrics}).intersection(fair['overview'].columns)))\n    overview = fair['overview']\n    if render:\n        display = _display\n    else:\n        display = _dont_display\n    result = H2OExplanation()\n    result['overview'] = H2OExplanation()\n    result['overview']['header'] = display(Header('Overview for model ' + self.model_id))\n    result['overview']['description'] = display(Description('fairness_metrics'))\n    with local_context(rows=overview.nrow):\n        result['overview']['data'] = display(overview[:, protected_columns + cols_to_show])\n    groups = [', '.join(r) for r in overview[:, protected_columns].as_data_frame(False, False)]\n    reference_name = ', '.join(reference)\n    result['overview']['plots'] = H2OExplanation()\n    overview = NumpyFrame(overview)\n    permutation = sorted(range(overview.nrow), key=lambda i: -overview[i, 'auc'])\n\n    def _permute(x):\n        return [x[i] for i in permutation]\n    groups = _permute(groups)\n    for col in cols_to_show:\n        plt.figure(figsize=figsize)\n        plt.title(col)\n        if 'AIR_' in col:\n            plt.bar(groups, _permute([a - 1 for a in overview[col]]), bottom=1)\n            plt.axhline(1, c='k')\n            plt.axhline(0.8, c='gray', linestyle='dashed')\n            plt.axhline(1.25, c='gray', linestyle='dashed')\n        elif 'p-value' in col:\n            plt.bar(groups, _permute(overview[col]))\n            plt.axhline(0.05, c='r')\n            plt.axhspan(0, 0.05, color='r', alpha=0.1)\n        else:\n            plt.bar(groups, _permute(overview[col]), color=['C1' if g == reference_name else 'C0' for g in groups])\n        plt.grid()\n        plt.xticks(rotation=90)\n        result['overview']['plots'][col] = display(plt.gcf())\n    result['ROC'] = H2OExplanation()\n    result['ROC']['header'] = display(Header('ROC'))\n    result['ROC']['description'] = display(Description('fairness_roc'))\n    result['ROC']['plot'] = display(self.fair_roc_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    result['PR'] = H2OExplanation()\n    result['PR']['header'] = display(Header('Precision-Recall Curve'))\n    result['PR']['description'] = display(Description('fairness_prc'))\n    result['PR']['plot'] = display(self.fair_pr_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    perm = self.permutation_importance(frame)\n    result['permutation_importance'] = H2OExplanation()\n    result['permutation_importance']['header'] = display(Header('Permutation Variable Importance'))\n    result['permutation_importance']['description'] = display(Description('fairness_varimp'))\n    result['permutation_importance']['data'] = display(perm)\n    sorted_features = list(perm['Variable'])\n    result['pdp'] = H2OExplanation()\n    result['pdp']['header'] = display(Header('Partial Dependence Plots for Individual Protected Groups'))\n    result['pdp']['description'] = display(Description('fairness_pdp'))\n    result['pdp']['plots'] = H2OExplanation()\n    for col in sorted_features:\n        result['pdp']['plots'][col] = display(self.fair_pd_plot(frame, col, protected_columns, figsize=figsize))\n    if has_extension(self, 'Contributions') and (_is_tree_model(self) or background_frame is not None):\n        result['shap'] = H2OExplanation()\n        result['shap']['header'] = display(Header('SHAP for Individual Protected Groups'))\n        result['shap']['description'] = display(Description('fairness_shap'))\n        result['shap']['plots'] = H2OExplanation()\n        for col in sorted_features:\n            result['shap']['plots'][col] = display(self.fair_shap_plot(frame, col, protected_columns, figsize=figsize, background_frame=background_frame))\n    return result",
            "def inspect_model_fairness(self, frame, protected_columns, reference, favorable_class, metrics=('auc', 'aucpr', 'f1', 'p.value', 'selectedRatio', 'total'), figsize=(16, 9), render=True, background_frame=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n         Produce plots and dataframes related to a single model fairness.\\n\\n        :param frame: H2OFrame\\n        :param protected_columns: List of categorical columns that contain sensitive information\\n                                  such as race, gender, age etc.\\n        :param reference: List of values corresponding to a reference for each protected columns.\\n                          If set to None, it will use the biggest group as the reference.\\n        :param favorable_class: Positive/favorable outcome class of the response.\\n        :param metrics: List of metrics to show.\\n        :param figsize: Figure size; passed directly to Matplotlib\\n        :param render: if ``True``, render the model explanations; otherwise model explanations are just returned.\\n        :param background_frame: optional frame, that is used as the source of baselines for the marginal SHAP.\\n                                 Setting it enables calculating SHAP in more models but it can be more time and memory consuming. \\n        :return: H2OExplanation object\\n\\n        :examples:\\n        >>> from h2o.estimators import H2OGradientBoostingEstimator\\n        >>> data = h2o.import_file(\"https://s3.amazonaws.com/h2o-public-test-data/smalldata/admissibleml_test/taiwan_credit_card_uci.csv\")\\n        >>> x = [\\'LIMIT_BAL\\', \\'AGE\\', \\'PAY_0\\', \\'PAY_2\\', \\'PAY_3\\', \\'PAY_4\\', \\'PAY_5\\', \\'PAY_6\\', \\'BILL_AMT1\\', \\'BILL_AMT2\\', \\'BILL_AMT3\\',\\n        >>>      \\'BILL_AMT4\\', \\'BILL_AMT5\\', \\'BILL_AMT6\\', \\'PAY_AMT1\\', \\'PAY_AMT2\\', \\'PAY_AMT3\\', \\'PAY_AMT4\\', \\'PAY_AMT5\\', \\'PAY_AMT6\\']\\n        >>> y = \"default payment next month\"\\n        >>> protected_columns = [\\'SEX\\', \\'EDUCATION\\']\\n        >>>\\n        >>> for c in [y] + protected_columns:\\n        >>>     data[c] = data[c].asfactor()\\n        >>>\\n        >>> train, test = data.split_frame([0.8])\\n        >>>\\n        >>> reference = [\"1\", \"2\"]  # university educated single man\\n        >>> favorable_class = \"0\"  # no default next month\\n        >>>\\n        >>> gbm = H2OGradientBoostingEstimator()\\n        >>> gbm.train(x, y, training_frame=train)\\n        >>>\\n        >>> gbm.inspect_model_fairness(test, protected_columns, reference, favorable_class)\\n        '\n    import h2o\n    from h2o.utils.shared_utils import can_use_numpy\n    if not can_use_numpy():\n        raise ImportError('numpy is required for inspect_model_fairness.')\n    from h2o.explanation import H2OExplanation\n    from h2o.explanation import Description\n    from h2o.explanation._explain import NumpyFrame\n    from h2o.explanation._explain import _display, _dont_display, Header, _is_tree_model\n    from h2o.model.extensions import has_extension\n    from h2o.plot import get_matplotlib_pyplot\n    from h2o.utils.typechecks import assert_is_type\n    assert_is_type(frame, h2o.H2OFrame)\n    assert_is_type(protected_columns, [str])\n    assert_is_type(reference, [str])\n    assert_is_type(favorable_class, str)\n    assert_is_type(metrics, [str], tuple)\n    assert_is_type(figsize, tuple, list)\n    assert_is_type(render, bool)\n    assert_is_type(background_frame, None, h2o.H2OFrame)\n    plt = get_matplotlib_pyplot(False, raise_if_not_available=True)\n    fair = self.fairness_metrics(frame=frame, protected_columns=protected_columns, reference=reference, favorable_class=favorable_class)\n    reference_frame = frame\n    for (i, pc) in enumerate(protected_columns):\n        reference_frame = reference_frame[reference_frame[pc] == reference[i], :]\n    cols_to_show = sorted(list(set(metrics).union({'AIR_{}'.format(m) for m in metrics}).intersection(fair['overview'].columns)))\n    overview = fair['overview']\n    if render:\n        display = _display\n    else:\n        display = _dont_display\n    result = H2OExplanation()\n    result['overview'] = H2OExplanation()\n    result['overview']['header'] = display(Header('Overview for model ' + self.model_id))\n    result['overview']['description'] = display(Description('fairness_metrics'))\n    with local_context(rows=overview.nrow):\n        result['overview']['data'] = display(overview[:, protected_columns + cols_to_show])\n    groups = [', '.join(r) for r in overview[:, protected_columns].as_data_frame(False, False)]\n    reference_name = ', '.join(reference)\n    result['overview']['plots'] = H2OExplanation()\n    overview = NumpyFrame(overview)\n    permutation = sorted(range(overview.nrow), key=lambda i: -overview[i, 'auc'])\n\n    def _permute(x):\n        return [x[i] for i in permutation]\n    groups = _permute(groups)\n    for col in cols_to_show:\n        plt.figure(figsize=figsize)\n        plt.title(col)\n        if 'AIR_' in col:\n            plt.bar(groups, _permute([a - 1 for a in overview[col]]), bottom=1)\n            plt.axhline(1, c='k')\n            plt.axhline(0.8, c='gray', linestyle='dashed')\n            plt.axhline(1.25, c='gray', linestyle='dashed')\n        elif 'p-value' in col:\n            plt.bar(groups, _permute(overview[col]))\n            plt.axhline(0.05, c='r')\n            plt.axhspan(0, 0.05, color='r', alpha=0.1)\n        else:\n            plt.bar(groups, _permute(overview[col]), color=['C1' if g == reference_name else 'C0' for g in groups])\n        plt.grid()\n        plt.xticks(rotation=90)\n        result['overview']['plots'][col] = display(plt.gcf())\n    result['ROC'] = H2OExplanation()\n    result['ROC']['header'] = display(Header('ROC'))\n    result['ROC']['description'] = display(Description('fairness_roc'))\n    result['ROC']['plot'] = display(self.fair_roc_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    result['PR'] = H2OExplanation()\n    result['PR']['header'] = display(Header('Precision-Recall Curve'))\n    result['PR']['description'] = display(Description('fairness_prc'))\n    result['PR']['plot'] = display(self.fair_pr_plot(frame, protected_columns, reference, favorable_class, figsize=figsize))\n    perm = self.permutation_importance(frame)\n    result['permutation_importance'] = H2OExplanation()\n    result['permutation_importance']['header'] = display(Header('Permutation Variable Importance'))\n    result['permutation_importance']['description'] = display(Description('fairness_varimp'))\n    result['permutation_importance']['data'] = display(perm)\n    sorted_features = list(perm['Variable'])\n    result['pdp'] = H2OExplanation()\n    result['pdp']['header'] = display(Header('Partial Dependence Plots for Individual Protected Groups'))\n    result['pdp']['description'] = display(Description('fairness_pdp'))\n    result['pdp']['plots'] = H2OExplanation()\n    for col in sorted_features:\n        result['pdp']['plots'][col] = display(self.fair_pd_plot(frame, col, protected_columns, figsize=figsize))\n    if has_extension(self, 'Contributions') and (_is_tree_model(self) or background_frame is not None):\n        result['shap'] = H2OExplanation()\n        result['shap']['header'] = display(Header('SHAP for Individual Protected Groups'))\n        result['shap']['description'] = display(Description('fairness_shap'))\n        result['shap']['plots'] = H2OExplanation()\n        for col in sorted_features:\n            result['shap']['plots'][col] = display(self.fair_shap_plot(frame, col, protected_columns, figsize=figsize, background_frame=background_frame))\n    return result"
        ]
    }
]