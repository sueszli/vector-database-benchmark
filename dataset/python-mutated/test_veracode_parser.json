[
    {
        "func_name": "setUp",
        "original": "def setUp(self):\n    (product_type, _) = Product_Type.objects.get_or_create(name='Fake unit tests')\n    (product, _) = Product.objects.get_or_create(name='product', prod_type=product_type)\n    engagement = Engagement(product=product)\n    self.test = Test(engagement=engagement)",
        "mutated": [
            "def setUp(self):\n    if False:\n        i = 10\n    (product_type, _) = Product_Type.objects.get_or_create(name='Fake unit tests')\n    (product, _) = Product.objects.get_or_create(name='product', prod_type=product_type)\n    engagement = Engagement(product=product)\n    self.test = Test(engagement=engagement)",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (product_type, _) = Product_Type.objects.get_or_create(name='Fake unit tests')\n    (product, _) = Product.objects.get_or_create(name='product', prod_type=product_type)\n    engagement = Engagement(product=product)\n    self.test = Test(engagement=engagement)",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (product_type, _) = Product_Type.objects.get_or_create(name='Fake unit tests')\n    (product, _) = Product.objects.get_or_create(name='product', prod_type=product_type)\n    engagement = Engagement(product=product)\n    self.test = Test(engagement=engagement)",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (product_type, _) = Product_Type.objects.get_or_create(name='Fake unit tests')\n    (product, _) = Product.objects.get_or_create(name='product', prod_type=product_type)\n    engagement = Engagement(product=product)\n    self.test = Test(engagement=engagement)",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (product_type, _) = Product_Type.objects.get_or_create(name='Fake unit tests')\n    (product, _) = Product.objects.get_or_create(name='product', prod_type=product_type)\n    engagement = Engagement(product=product)\n    self.test = Test(engagement=engagement)"
        ]
    },
    {
        "func_name": "test_parse_file_with_one_finding",
        "original": "def test_parse_file_with_one_finding(self):\n    testfile = open('unittests/scans/veracode/one_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))",
        "mutated": [
            "def test_parse_file_with_one_finding(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/one_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))",
            "def test_parse_file_with_one_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/one_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))",
            "def test_parse_file_with_one_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/one_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))",
            "def test_parse_file_with_one_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/one_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))",
            "def test_parse_file_with_one_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/one_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))"
        ]
    },
    {
        "func_name": "test_parse_file_many_findings_different_hash_code_different_unique_id",
        "original": "def test_parse_file_many_findings_different_hash_code_different_unique_id(self):\n    testfile = open('unittests/scans/veracode/many_findings_different_hash_code_different_unique_id.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp2.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-12345_issue-1', finding.unique_id_from_tool)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.dynamic_finding)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)",
        "mutated": [
            "def test_parse_file_many_findings_different_hash_code_different_unique_id(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/many_findings_different_hash_code_different_unique_id.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp2.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-12345_issue-1', finding.unique_id_from_tool)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.dynamic_finding)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)",
            "def test_parse_file_many_findings_different_hash_code_different_unique_id(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/many_findings_different_hash_code_different_unique_id.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp2.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-12345_issue-1', finding.unique_id_from_tool)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.dynamic_finding)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)",
            "def test_parse_file_many_findings_different_hash_code_different_unique_id(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/many_findings_different_hash_code_different_unique_id.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp2.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-12345_issue-1', finding.unique_id_from_tool)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.dynamic_finding)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)",
            "def test_parse_file_many_findings_different_hash_code_different_unique_id(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/many_findings_different_hash_code_different_unique_id.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp2.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-12345_issue-1', finding.unique_id_from_tool)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.dynamic_finding)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)",
            "def test_parse_file_many_findings_different_hash_code_different_unique_id(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/many_findings_different_hash_code_different_unique_id.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp2.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-12345_issue-1', finding.unique_id_from_tool)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.dynamic_finding)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)"
        ]
    },
    {
        "func_name": "test_parse_file_with_multiple_finding",
        "original": "def test_parse_file_with_multiple_finding(self):\n    testfile = open('unittests/scans/veracode/many_findings.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertTrue(finding.static_finding)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertIn('sast', finding.unsaved_tags)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertIn('dast', finding.unsaved_tags)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-5678-5678', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library1:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)",
        "mutated": [
            "def test_parse_file_with_multiple_finding(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/many_findings.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertTrue(finding.static_finding)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertIn('sast', finding.unsaved_tags)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertIn('dast', finding.unsaved_tags)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-5678-5678', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library1:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)",
            "def test_parse_file_with_multiple_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/many_findings.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertTrue(finding.static_finding)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertIn('sast', finding.unsaved_tags)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertIn('dast', finding.unsaved_tags)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-5678-5678', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library1:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)",
            "def test_parse_file_with_multiple_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/many_findings.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertTrue(finding.static_finding)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertIn('sast', finding.unsaved_tags)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertIn('dast', finding.unsaved_tags)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-5678-5678', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library1:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)",
            "def test_parse_file_with_multiple_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/many_findings.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertTrue(finding.static_finding)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertIn('sast', finding.unsaved_tags)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertIn('dast', finding.unsaved_tags)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-5678-5678', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library1:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)",
            "def test_parse_file_with_multiple_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/many_findings.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(123, finding.cwe)\n    self.assertEqual('catname', finding.title)\n    self.assertTrue(finding.static_finding)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual('sourcefilepathMyApp.java', finding.file_path)\n    self.assertEqual(2, finding.line)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertIn('sast', finding.unsaved_tags)\n    finding = findings[1]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertIn('dast', finding.unsaved_tags)\n    finding = findings[2]\n    self.assertEqual('High', finding.severity)\n    self.assertIsNone(finding.cwe)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-1234-1234', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-5678-5678', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('Vulnerable component: library1:1234', finding.title)\n    self.assertFalse(finding.is_mitigated)\n    self.assertIn('sca', finding.unsaved_tags)"
        ]
    },
    {
        "func_name": "test_parse_file_with_multiple_finding2",
        "original": "def test_parse_file_with_multiple_finding2(self):\n    testfile = open('unittests/scans/veracode/veracode_scan.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual('Information Exposure Through Sent Data', finding.title)\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual(datetime.datetime(2018, 2, 17, 0, 35, 18), finding.date)\n    finding = findings[1]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual('/devTools/utility.jsp', finding.file_path)\n    self.assertEqual(361, finding.line)\n    self.assertIsNone(finding.component_name)\n    self.assertIsNone(finding.component_version)\n    finding = findings[6]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
        "mutated": [
            "def test_parse_file_with_multiple_finding2(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/veracode_scan.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual('Information Exposure Through Sent Data', finding.title)\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual(datetime.datetime(2018, 2, 17, 0, 35, 18), finding.date)\n    finding = findings[1]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual('/devTools/utility.jsp', finding.file_path)\n    self.assertEqual(361, finding.line)\n    self.assertIsNone(finding.component_name)\n    self.assertIsNone(finding.component_version)\n    finding = findings[6]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
            "def test_parse_file_with_multiple_finding2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/veracode_scan.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual('Information Exposure Through Sent Data', finding.title)\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual(datetime.datetime(2018, 2, 17, 0, 35, 18), finding.date)\n    finding = findings[1]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual('/devTools/utility.jsp', finding.file_path)\n    self.assertEqual(361, finding.line)\n    self.assertIsNone(finding.component_name)\n    self.assertIsNone(finding.component_version)\n    finding = findings[6]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
            "def test_parse_file_with_multiple_finding2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/veracode_scan.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual('Information Exposure Through Sent Data', finding.title)\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual(datetime.datetime(2018, 2, 17, 0, 35, 18), finding.date)\n    finding = findings[1]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual('/devTools/utility.jsp', finding.file_path)\n    self.assertEqual(361, finding.line)\n    self.assertIsNone(finding.component_name)\n    self.assertIsNone(finding.component_version)\n    finding = findings[6]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
            "def test_parse_file_with_multiple_finding2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/veracode_scan.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual('Information Exposure Through Sent Data', finding.title)\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual(datetime.datetime(2018, 2, 17, 0, 35, 18), finding.date)\n    finding = findings[1]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual('/devTools/utility.jsp', finding.file_path)\n    self.assertEqual(361, finding.line)\n    self.assertIsNone(finding.component_name)\n    self.assertIsNone(finding.component_version)\n    finding = findings[6]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
            "def test_parse_file_with_multiple_finding2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/veracode_scan.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual('Information Exposure Through Sent Data', finding.title)\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual(datetime.datetime(2018, 2, 17, 0, 35, 18), finding.date)\n    finding = findings[1]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(201, finding.cwe)\n    self.assertEqual('/devTools/utility.jsp', finding.file_path)\n    self.assertEqual(361, finding.line)\n    self.assertIsNone(finding.component_name)\n    self.assertIsNone(finding.component_version)\n    finding = findings[6]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)"
        ]
    },
    {
        "func_name": "test_parse_file_with_mitigated_finding",
        "original": "def test_parse_file_with_mitigated_finding(self):\n    testfile = open('unittests/scans/veracode/mitigated_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, self.test)\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2020, 6, 1, 10, 2, 1), finding.mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertEqual(0, finding.sla_age)\n    self.assertEqual(90, finding.sla_days_remaining())\n    self.assertEqual((datetime.datetime(2020, 6, 1, 10, 2, 1) + datetime.timedelta(days=90)).date(), finding.sla_deadline())",
        "mutated": [
            "def test_parse_file_with_mitigated_finding(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/mitigated_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, self.test)\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2020, 6, 1, 10, 2, 1), finding.mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertEqual(0, finding.sla_age)\n    self.assertEqual(90, finding.sla_days_remaining())\n    self.assertEqual((datetime.datetime(2020, 6, 1, 10, 2, 1) + datetime.timedelta(days=90)).date(), finding.sla_deadline())",
            "def test_parse_file_with_mitigated_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/mitigated_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, self.test)\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2020, 6, 1, 10, 2, 1), finding.mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertEqual(0, finding.sla_age)\n    self.assertEqual(90, finding.sla_days_remaining())\n    self.assertEqual((datetime.datetime(2020, 6, 1, 10, 2, 1) + datetime.timedelta(days=90)).date(), finding.sla_deadline())",
            "def test_parse_file_with_mitigated_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/mitigated_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, self.test)\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2020, 6, 1, 10, 2, 1), finding.mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertEqual(0, finding.sla_age)\n    self.assertEqual(90, finding.sla_days_remaining())\n    self.assertEqual((datetime.datetime(2020, 6, 1, 10, 2, 1) + datetime.timedelta(days=90)).date(), finding.sla_deadline())",
            "def test_parse_file_with_mitigated_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/mitigated_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, self.test)\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2020, 6, 1, 10, 2, 1), finding.mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertEqual(0, finding.sla_age)\n    self.assertEqual(90, finding.sla_days_remaining())\n    self.assertEqual((datetime.datetime(2020, 6, 1, 10, 2, 1) + datetime.timedelta(days=90)).date(), finding.sla_deadline())",
            "def test_parse_file_with_mitigated_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/mitigated_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, self.test)\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2020, 6, 1, 10, 2, 1), finding.mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)\n    self.assertEqual(0, finding.sla_age)\n    self.assertEqual(90, finding.sla_days_remaining())\n    self.assertEqual((datetime.datetime(2020, 6, 1, 10, 2, 1) + datetime.timedelta(days=90)).date(), finding.sla_deadline())"
        ]
    },
    {
        "func_name": "test_parse_file_with_mitigated_fixed_finding",
        "original": "def test_parse_file_with_mitigated_fixed_finding(self):\n    testfile = open('unittests/scans/veracode/mitigated_fixed_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)",
        "mutated": [
            "def test_parse_file_with_mitigated_fixed_finding(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/mitigated_fixed_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)",
            "def test_parse_file_with_mitigated_fixed_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/mitigated_fixed_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)",
            "def test_parse_file_with_mitigated_fixed_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/mitigated_fixed_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)",
            "def test_parse_file_with_mitigated_fixed_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/mitigated_fixed_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)",
            "def test_parse_file_with_mitigated_fixed_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/mitigated_fixed_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual('app-1234_issue-1', finding.unique_id_from_tool)"
        ]
    },
    {
        "func_name": "test_parse_file_with_mitigated_sca_finding",
        "original": "def test_parse_file_with_mitigated_sca_finding(self):\n    testfile = open('unittests/scans/veracode/veracode_scan_sca_mitigated.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2022, 9, 12, 14, 29, 18), finding.mitigated)",
        "mutated": [
            "def test_parse_file_with_mitigated_sca_finding(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/veracode_scan_sca_mitigated.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2022, 9, 12, 14, 29, 18), finding.mitigated)",
            "def test_parse_file_with_mitigated_sca_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/veracode_scan_sca_mitigated.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2022, 9, 12, 14, 29, 18), finding.mitigated)",
            "def test_parse_file_with_mitigated_sca_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/veracode_scan_sca_mitigated.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2022, 9, 12, 14, 29, 18), finding.mitigated)",
            "def test_parse_file_with_mitigated_sca_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/veracode_scan_sca_mitigated.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2022, 9, 12, 14, 29, 18), finding.mitigated)",
            "def test_parse_file_with_mitigated_sca_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/veracode_scan_sca_mitigated.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertTrue(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2022, 9, 12, 14, 29, 18), finding.mitigated)"
        ]
    },
    {
        "func_name": "test_parse_file_with_dynamic_finding",
        "original": "def test_parse_file_with_dynamic_finding(self):\n    testfile = open('unittests/scans/veracode/dynamic_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertEqual('catname', finding.title)\n    self.assertEqual('Description', finding.description)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2021, 9, 3, 10, 0, 0), finding.date)\n    self.assertIn('dast', finding.unsaved_tags)\n    self.assertEqual(1, len(finding.unsaved_endpoints))\n    endpoint = finding.unsaved_endpoints[0]\n    self.assertEqual('https', endpoint.protocol)\n    self.assertEqual('www.example.com', endpoint.host)\n    self.assertEqual('index.html', endpoint.path)",
        "mutated": [
            "def test_parse_file_with_dynamic_finding(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/dynamic_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertEqual('catname', finding.title)\n    self.assertEqual('Description', finding.description)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2021, 9, 3, 10, 0, 0), finding.date)\n    self.assertIn('dast', finding.unsaved_tags)\n    self.assertEqual(1, len(finding.unsaved_endpoints))\n    endpoint = finding.unsaved_endpoints[0]\n    self.assertEqual('https', endpoint.protocol)\n    self.assertEqual('www.example.com', endpoint.host)\n    self.assertEqual('index.html', endpoint.path)",
            "def test_parse_file_with_dynamic_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/dynamic_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertEqual('catname', finding.title)\n    self.assertEqual('Description', finding.description)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2021, 9, 3, 10, 0, 0), finding.date)\n    self.assertIn('dast', finding.unsaved_tags)\n    self.assertEqual(1, len(finding.unsaved_endpoints))\n    endpoint = finding.unsaved_endpoints[0]\n    self.assertEqual('https', endpoint.protocol)\n    self.assertEqual('www.example.com', endpoint.host)\n    self.assertEqual('index.html', endpoint.path)",
            "def test_parse_file_with_dynamic_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/dynamic_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertEqual('catname', finding.title)\n    self.assertEqual('Description', finding.description)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2021, 9, 3, 10, 0, 0), finding.date)\n    self.assertIn('dast', finding.unsaved_tags)\n    self.assertEqual(1, len(finding.unsaved_endpoints))\n    endpoint = finding.unsaved_endpoints[0]\n    self.assertEqual('https', endpoint.protocol)\n    self.assertEqual('www.example.com', endpoint.host)\n    self.assertEqual('index.html', endpoint.path)",
            "def test_parse_file_with_dynamic_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/dynamic_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertEqual('catname', finding.title)\n    self.assertEqual('Description', finding.description)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2021, 9, 3, 10, 0, 0), finding.date)\n    self.assertIn('dast', finding.unsaved_tags)\n    self.assertEqual(1, len(finding.unsaved_endpoints))\n    endpoint = finding.unsaved_endpoints[0]\n    self.assertEqual('https', endpoint.protocol)\n    self.assertEqual('www.example.com', endpoint.host)\n    self.assertEqual('index.html', endpoint.path)",
            "def test_parse_file_with_dynamic_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/dynamic_finding.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Medium', finding.severity)\n    self.assertEqual(456, finding.cwe)\n    self.assertTrue(finding.dynamic_finding)\n    self.assertEqual('catname', finding.title)\n    self.assertEqual('Description', finding.description)\n    self.assertFalse(finding.is_mitigated)\n    self.assertEqual(datetime.datetime(2021, 9, 3, 10, 0, 0), finding.date)\n    self.assertIn('dast', finding.unsaved_tags)\n    self.assertEqual(1, len(finding.unsaved_endpoints))\n    endpoint = finding.unsaved_endpoints[0]\n    self.assertEqual('https', endpoint.protocol)\n    self.assertEqual('www.example.com', endpoint.host)\n    self.assertEqual('index.html', endpoint.path)"
        ]
    },
    {
        "func_name": "test_parse_file_with_changed_severity",
        "original": "def test_parse_file_with_changed_severity(self):\n    testfile = open('unittests/scans/veracode/veracode_scan_changed_severity.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[6]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
        "mutated": [
            "def test_parse_file_with_changed_severity(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/veracode_scan_changed_severity.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[6]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
            "def test_parse_file_with_changed_severity(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/veracode_scan_changed_severity.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[6]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
            "def test_parse_file_with_changed_severity(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/veracode_scan_changed_severity.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[6]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
            "def test_parse_file_with_changed_severity(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/veracode_scan_changed_severity.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[6]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)",
            "def test_parse_file_with_changed_severity(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/veracode_scan_changed_severity.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[6]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2012-6153', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual(20, finding.cwe)\n    self.assertEqual('commons-httpclient', finding.component_name)\n    self.assertEqual('3.1', finding.component_version)\n    self.assertEqual(4.3, finding.cvssv3_score)"
        ]
    },
    {
        "func_name": "test_maven_component_name",
        "original": "def test_maven_component_name(self):\n    testfile = open('unittests/scans/veracode/veracode_maven.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2022-41852', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('commons-jxpath', finding.component_name)\n    self.assertEqual('1.3', finding.component_version)\n    self.assertEqual(9.8, finding.cvssv3_score)",
        "mutated": [
            "def test_maven_component_name(self):\n    if False:\n        i = 10\n    testfile = open('unittests/scans/veracode/veracode_maven.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2022-41852', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('commons-jxpath', finding.component_name)\n    self.assertEqual('1.3', finding.component_version)\n    self.assertEqual(9.8, finding.cvssv3_score)",
            "def test_maven_component_name(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open('unittests/scans/veracode/veracode_maven.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2022-41852', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('commons-jxpath', finding.component_name)\n    self.assertEqual('1.3', finding.component_version)\n    self.assertEqual(9.8, finding.cvssv3_score)",
            "def test_maven_component_name(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open('unittests/scans/veracode/veracode_maven.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2022-41852', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('commons-jxpath', finding.component_name)\n    self.assertEqual('1.3', finding.component_version)\n    self.assertEqual(9.8, finding.cvssv3_score)",
            "def test_maven_component_name(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open('unittests/scans/veracode/veracode_maven.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2022-41852', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('commons-jxpath', finding.component_name)\n    self.assertEqual('1.3', finding.component_version)\n    self.assertEqual(9.8, finding.cvssv3_score)",
            "def test_maven_component_name(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open('unittests/scans/veracode/veracode_maven.xml')\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('Critical', finding.severity)\n    self.assertEqual(1, len(finding.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2022-41852', finding.unsaved_vulnerability_ids[0])\n    self.assertEqual('commons-jxpath', finding.component_name)\n    self.assertEqual('1.3', finding.component_version)\n    self.assertEqual(9.8, finding.cvssv3_score)"
        ]
    },
    {
        "func_name": "json_static_findings_test",
        "original": "def json_static_findings_test(self, file_name):\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Cross-Site Scripting (XSS)')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 80)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Exploitability Predication**: Likely\\n**Attack Vector**: page.html\\n**Module**: CoolProduct.jsa\\n### Details\\nThis call to page.html() contains a cross-site scripting (XSS) flaw.  The application populates the HTTP response with untrusted input, allowing an attacker to embed malicious content, such as Javascript code, which will be executed in the context of the victim's browser.  XSS vulnerabilities are commonly exploited to steal or manipulate cookies, modify presentation of content, and compromise confidential information, with new attack vectors being discovered on a regular basis.\")\n    self.assertEqual(finding.mitigation, 'Use contextual escaping on all untrusted data before using it to construct any portion of an HTTP response.  The escaping method should be chosen based on the specific use case of the untrusted data, otherwise it may not protect fully against the attack. For example, if the data is being written to the body of an HTML page, use HTML entity escaping; if the data is being written to an attribute, use attribute escaping; etc.  Both the OWASP Java Encoder library and the Microsoft AntiXSS library provide contextual escaping methods. For more details on contextual escaping, see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md. In addition, as a best practice, always validate untrusted input to ensure that it conforms to the expected format, using centralized data validation routines when possible.')\n    self.assertEqual(finding.references, '- [CWE](https://cwe.mitre.org/data/definitions/79.html)\\n- [OWASP](https://owasp.org/www-community/attacks/xss/)\\n- [Supported Cleansers](https://docs.veracode.com/r/review_cleansers)\\n')\n    self.assertEqual(finding.line, 50)\n    self.assertEqual(finding.sast_source_line, 50)\n    self.assertEqual(finding.sast_sink_line, 50)\n    self.assertEqual(finding.file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_sink_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_object, 'lambda_3')\n    self.assertEqual(finding.sast_sink_object, 'lambda_3')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])",
        "mutated": [
            "def json_static_findings_test(self, file_name):\n    if False:\n        i = 10\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Cross-Site Scripting (XSS)')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 80)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Exploitability Predication**: Likely\\n**Attack Vector**: page.html\\n**Module**: CoolProduct.jsa\\n### Details\\nThis call to page.html() contains a cross-site scripting (XSS) flaw.  The application populates the HTTP response with untrusted input, allowing an attacker to embed malicious content, such as Javascript code, which will be executed in the context of the victim's browser.  XSS vulnerabilities are commonly exploited to steal or manipulate cookies, modify presentation of content, and compromise confidential information, with new attack vectors being discovered on a regular basis.\")\n    self.assertEqual(finding.mitigation, 'Use contextual escaping on all untrusted data before using it to construct any portion of an HTTP response.  The escaping method should be chosen based on the specific use case of the untrusted data, otherwise it may not protect fully against the attack. For example, if the data is being written to the body of an HTML page, use HTML entity escaping; if the data is being written to an attribute, use attribute escaping; etc.  Both the OWASP Java Encoder library and the Microsoft AntiXSS library provide contextual escaping methods. For more details on contextual escaping, see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md. In addition, as a best practice, always validate untrusted input to ensure that it conforms to the expected format, using centralized data validation routines when possible.')\n    self.assertEqual(finding.references, '- [CWE](https://cwe.mitre.org/data/definitions/79.html)\\n- [OWASP](https://owasp.org/www-community/attacks/xss/)\\n- [Supported Cleansers](https://docs.veracode.com/r/review_cleansers)\\n')\n    self.assertEqual(finding.line, 50)\n    self.assertEqual(finding.sast_source_line, 50)\n    self.assertEqual(finding.sast_sink_line, 50)\n    self.assertEqual(finding.file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_sink_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_object, 'lambda_3')\n    self.assertEqual(finding.sast_sink_object, 'lambda_3')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])",
            "def json_static_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Cross-Site Scripting (XSS)')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 80)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Exploitability Predication**: Likely\\n**Attack Vector**: page.html\\n**Module**: CoolProduct.jsa\\n### Details\\nThis call to page.html() contains a cross-site scripting (XSS) flaw.  The application populates the HTTP response with untrusted input, allowing an attacker to embed malicious content, such as Javascript code, which will be executed in the context of the victim's browser.  XSS vulnerabilities are commonly exploited to steal or manipulate cookies, modify presentation of content, and compromise confidential information, with new attack vectors being discovered on a regular basis.\")\n    self.assertEqual(finding.mitigation, 'Use contextual escaping on all untrusted data before using it to construct any portion of an HTTP response.  The escaping method should be chosen based on the specific use case of the untrusted data, otherwise it may not protect fully against the attack. For example, if the data is being written to the body of an HTML page, use HTML entity escaping; if the data is being written to an attribute, use attribute escaping; etc.  Both the OWASP Java Encoder library and the Microsoft AntiXSS library provide contextual escaping methods. For more details on contextual escaping, see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md. In addition, as a best practice, always validate untrusted input to ensure that it conforms to the expected format, using centralized data validation routines when possible.')\n    self.assertEqual(finding.references, '- [CWE](https://cwe.mitre.org/data/definitions/79.html)\\n- [OWASP](https://owasp.org/www-community/attacks/xss/)\\n- [Supported Cleansers](https://docs.veracode.com/r/review_cleansers)\\n')\n    self.assertEqual(finding.line, 50)\n    self.assertEqual(finding.sast_source_line, 50)\n    self.assertEqual(finding.sast_sink_line, 50)\n    self.assertEqual(finding.file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_sink_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_object, 'lambda_3')\n    self.assertEqual(finding.sast_sink_object, 'lambda_3')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])",
            "def json_static_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Cross-Site Scripting (XSS)')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 80)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Exploitability Predication**: Likely\\n**Attack Vector**: page.html\\n**Module**: CoolProduct.jsa\\n### Details\\nThis call to page.html() contains a cross-site scripting (XSS) flaw.  The application populates the HTTP response with untrusted input, allowing an attacker to embed malicious content, such as Javascript code, which will be executed in the context of the victim's browser.  XSS vulnerabilities are commonly exploited to steal or manipulate cookies, modify presentation of content, and compromise confidential information, with new attack vectors being discovered on a regular basis.\")\n    self.assertEqual(finding.mitigation, 'Use contextual escaping on all untrusted data before using it to construct any portion of an HTTP response.  The escaping method should be chosen based on the specific use case of the untrusted data, otherwise it may not protect fully against the attack. For example, if the data is being written to the body of an HTML page, use HTML entity escaping; if the data is being written to an attribute, use attribute escaping; etc.  Both the OWASP Java Encoder library and the Microsoft AntiXSS library provide contextual escaping methods. For more details on contextual escaping, see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md. In addition, as a best practice, always validate untrusted input to ensure that it conforms to the expected format, using centralized data validation routines when possible.')\n    self.assertEqual(finding.references, '- [CWE](https://cwe.mitre.org/data/definitions/79.html)\\n- [OWASP](https://owasp.org/www-community/attacks/xss/)\\n- [Supported Cleansers](https://docs.veracode.com/r/review_cleansers)\\n')\n    self.assertEqual(finding.line, 50)\n    self.assertEqual(finding.sast_source_line, 50)\n    self.assertEqual(finding.sast_sink_line, 50)\n    self.assertEqual(finding.file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_sink_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_object, 'lambda_3')\n    self.assertEqual(finding.sast_sink_object, 'lambda_3')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])",
            "def json_static_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Cross-Site Scripting (XSS)')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 80)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Exploitability Predication**: Likely\\n**Attack Vector**: page.html\\n**Module**: CoolProduct.jsa\\n### Details\\nThis call to page.html() contains a cross-site scripting (XSS) flaw.  The application populates the HTTP response with untrusted input, allowing an attacker to embed malicious content, such as Javascript code, which will be executed in the context of the victim's browser.  XSS vulnerabilities are commonly exploited to steal or manipulate cookies, modify presentation of content, and compromise confidential information, with new attack vectors being discovered on a regular basis.\")\n    self.assertEqual(finding.mitigation, 'Use contextual escaping on all untrusted data before using it to construct any portion of an HTTP response.  The escaping method should be chosen based on the specific use case of the untrusted data, otherwise it may not protect fully against the attack. For example, if the data is being written to the body of an HTML page, use HTML entity escaping; if the data is being written to an attribute, use attribute escaping; etc.  Both the OWASP Java Encoder library and the Microsoft AntiXSS library provide contextual escaping methods. For more details on contextual escaping, see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md. In addition, as a best practice, always validate untrusted input to ensure that it conforms to the expected format, using centralized data validation routines when possible.')\n    self.assertEqual(finding.references, '- [CWE](https://cwe.mitre.org/data/definitions/79.html)\\n- [OWASP](https://owasp.org/www-community/attacks/xss/)\\n- [Supported Cleansers](https://docs.veracode.com/r/review_cleansers)\\n')\n    self.assertEqual(finding.line, 50)\n    self.assertEqual(finding.sast_source_line, 50)\n    self.assertEqual(finding.sast_sink_line, 50)\n    self.assertEqual(finding.file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_sink_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_object, 'lambda_3')\n    self.assertEqual(finding.sast_sink_object, 'lambda_3')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])",
            "def json_static_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Cross-Site Scripting (XSS)')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 80)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Exploitability Predication**: Likely\\n**Attack Vector**: page.html\\n**Module**: CoolProduct.jsa\\n### Details\\nThis call to page.html() contains a cross-site scripting (XSS) flaw.  The application populates the HTTP response with untrusted input, allowing an attacker to embed malicious content, such as Javascript code, which will be executed in the context of the victim's browser.  XSS vulnerabilities are commonly exploited to steal or manipulate cookies, modify presentation of content, and compromise confidential information, with new attack vectors being discovered on a regular basis.\")\n    self.assertEqual(finding.mitigation, 'Use contextual escaping on all untrusted data before using it to construct any portion of an HTTP response.  The escaping method should be chosen based on the specific use case of the untrusted data, otherwise it may not protect fully against the attack. For example, if the data is being written to the body of an HTML page, use HTML entity escaping; if the data is being written to an attribute, use attribute escaping; etc.  Both the OWASP Java Encoder library and the Microsoft AntiXSS library provide contextual escaping methods. For more details on contextual escaping, see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md. In addition, as a best practice, always validate untrusted input to ensure that it conforms to the expected format, using centralized data validation routines when possible.')\n    self.assertEqual(finding.references, '- [CWE](https://cwe.mitre.org/data/definitions/79.html)\\n- [OWASP](https://owasp.org/www-community/attacks/xss/)\\n- [Supported Cleansers](https://docs.veracode.com/r/review_cleansers)\\n')\n    self.assertEqual(finding.line, 50)\n    self.assertEqual(finding.sast_source_line, 50)\n    self.assertEqual(finding.sast_sink_line, 50)\n    self.assertEqual(finding.file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_sink_file_path, '/WEB-INF/views/contact.jsp')\n    self.assertEqual(finding.sast_source_object, 'lambda_3')\n    self.assertEqual(finding.sast_sink_object, 'lambda_3')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])"
        ]
    },
    {
        "func_name": "test_json_static_findings_list_format",
        "original": "def test_json_static_findings_list_format(self):\n    self.json_static_findings_test('unittests/scans/veracode/static_findings_list_format.json')",
        "mutated": [
            "def test_json_static_findings_list_format(self):\n    if False:\n        i = 10\n    self.json_static_findings_test('unittests/scans/veracode/static_findings_list_format.json')",
            "def test_json_static_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.json_static_findings_test('unittests/scans/veracode/static_findings_list_format.json')",
            "def test_json_static_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.json_static_findings_test('unittests/scans/veracode/static_findings_list_format.json')",
            "def test_json_static_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.json_static_findings_test('unittests/scans/veracode/static_findings_list_format.json')",
            "def test_json_static_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.json_static_findings_test('unittests/scans/veracode/static_findings_list_format.json')"
        ]
    },
    {
        "func_name": "test_json_static_embedded_format",
        "original": "def test_json_static_embedded_format(self):\n    self.json_static_findings_test('unittests/scans/veracode/static_embedded_format.json')",
        "mutated": [
            "def test_json_static_embedded_format(self):\n    if False:\n        i = 10\n    self.json_static_findings_test('unittests/scans/veracode/static_embedded_format.json')",
            "def test_json_static_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.json_static_findings_test('unittests/scans/veracode/static_embedded_format.json')",
            "def test_json_static_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.json_static_findings_test('unittests/scans/veracode/static_embedded_format.json')",
            "def test_json_static_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.json_static_findings_test('unittests/scans/veracode/static_embedded_format.json')",
            "def test_json_static_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.json_static_findings_test('unittests/scans/veracode/static_embedded_format.json')"
        ]
    },
    {
        "func_name": "json_dynamic_findings_test",
        "original": "def json_dynamic_findings_test(self, file_name):\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Code Injection')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 74)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Plugin**: Code Injection\\n**Attack Vector**: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\\n**Vulnerable Parameter**: api\\n### Details\\nInjections happen when untrusted data is inserted into an interpreted syntax and subsequently evaluated on the server side. This syntax may be a SQL query, a parsed JSON or XML document, an executed script or other syntax that may be in use within the application. Although the target syntax has not been identified, the application behavior demonstrates that the input HTTP parameter may be inserted without proper escaping. It was observed by sending valid and invalid payloads that should throw or should not throw errors. By inserting a proper and improper comments such as ``, `*/_/*`, `/*_*/` into the `api` parameter, the scanner was able to spot a difference in the responses, which is a good indicator of a potential vulnerability. Confidence: medium. Response codes: `404`, `404`, `404`. Similarities: `` vs `*/_/*`: 0.0; `*/_/*` vs `/*_*/`: 0.0; `` vs `/*_*/`: 1.0.\")\n    self.assertEqual(finding.mitigation, 'It is recommended to identify how the current parameter is used in the application source code, and make sure it is escaped before inserting into any syntax or query. You can add valid values to an allowlist and invalid values to a blocklist.')\n    self.assertEqual(finding.references, '- [CWE](http://cwe.mitre.org/cgi-bin/jumpmenu.cgi?id=74)\\n')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_endpoints[0], Endpoint(protocol='https', host='application.insecure-company-alliance.com', port=443, path='api/*_*//new_user_sign_up', query='param=wild-things'))",
        "mutated": [
            "def json_dynamic_findings_test(self, file_name):\n    if False:\n        i = 10\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Code Injection')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 74)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Plugin**: Code Injection\\n**Attack Vector**: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\\n**Vulnerable Parameter**: api\\n### Details\\nInjections happen when untrusted data is inserted into an interpreted syntax and subsequently evaluated on the server side. This syntax may be a SQL query, a parsed JSON or XML document, an executed script or other syntax that may be in use within the application. Although the target syntax has not been identified, the application behavior demonstrates that the input HTTP parameter may be inserted without proper escaping. It was observed by sending valid and invalid payloads that should throw or should not throw errors. By inserting a proper and improper comments such as ``, `*/_/*`, `/*_*/` into the `api` parameter, the scanner was able to spot a difference in the responses, which is a good indicator of a potential vulnerability. Confidence: medium. Response codes: `404`, `404`, `404`. Similarities: `` vs `*/_/*`: 0.0; `*/_/*` vs `/*_*/`: 0.0; `` vs `/*_*/`: 1.0.\")\n    self.assertEqual(finding.mitigation, 'It is recommended to identify how the current parameter is used in the application source code, and make sure it is escaped before inserting into any syntax or query. You can add valid values to an allowlist and invalid values to a blocklist.')\n    self.assertEqual(finding.references, '- [CWE](http://cwe.mitre.org/cgi-bin/jumpmenu.cgi?id=74)\\n')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_endpoints[0], Endpoint(protocol='https', host='application.insecure-company-alliance.com', port=443, path='api/*_*//new_user_sign_up', query='param=wild-things'))",
            "def json_dynamic_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Code Injection')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 74)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Plugin**: Code Injection\\n**Attack Vector**: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\\n**Vulnerable Parameter**: api\\n### Details\\nInjections happen when untrusted data is inserted into an interpreted syntax and subsequently evaluated on the server side. This syntax may be a SQL query, a parsed JSON or XML document, an executed script or other syntax that may be in use within the application. Although the target syntax has not been identified, the application behavior demonstrates that the input HTTP parameter may be inserted without proper escaping. It was observed by sending valid and invalid payloads that should throw or should not throw errors. By inserting a proper and improper comments such as ``, `*/_/*`, `/*_*/` into the `api` parameter, the scanner was able to spot a difference in the responses, which is a good indicator of a potential vulnerability. Confidence: medium. Response codes: `404`, `404`, `404`. Similarities: `` vs `*/_/*`: 0.0; `*/_/*` vs `/*_*/`: 0.0; `` vs `/*_*/`: 1.0.\")\n    self.assertEqual(finding.mitigation, 'It is recommended to identify how the current parameter is used in the application source code, and make sure it is escaped before inserting into any syntax or query. You can add valid values to an allowlist and invalid values to a blocklist.')\n    self.assertEqual(finding.references, '- [CWE](http://cwe.mitre.org/cgi-bin/jumpmenu.cgi?id=74)\\n')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_endpoints[0], Endpoint(protocol='https', host='application.insecure-company-alliance.com', port=443, path='api/*_*//new_user_sign_up', query='param=wild-things'))",
            "def json_dynamic_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Code Injection')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 74)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Plugin**: Code Injection\\n**Attack Vector**: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\\n**Vulnerable Parameter**: api\\n### Details\\nInjections happen when untrusted data is inserted into an interpreted syntax and subsequently evaluated on the server side. This syntax may be a SQL query, a parsed JSON or XML document, an executed script or other syntax that may be in use within the application. Although the target syntax has not been identified, the application behavior demonstrates that the input HTTP parameter may be inserted without proper escaping. It was observed by sending valid and invalid payloads that should throw or should not throw errors. By inserting a proper and improper comments such as ``, `*/_/*`, `/*_*/` into the `api` parameter, the scanner was able to spot a difference in the responses, which is a good indicator of a potential vulnerability. Confidence: medium. Response codes: `404`, `404`, `404`. Similarities: `` vs `*/_/*`: 0.0; `*/_/*` vs `/*_*/`: 0.0; `` vs `/*_*/`: 1.0.\")\n    self.assertEqual(finding.mitigation, 'It is recommended to identify how the current parameter is used in the application source code, and make sure it is escaped before inserting into any syntax or query. You can add valid values to an allowlist and invalid values to a blocklist.')\n    self.assertEqual(finding.references, '- [CWE](http://cwe.mitre.org/cgi-bin/jumpmenu.cgi?id=74)\\n')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_endpoints[0], Endpoint(protocol='https', host='application.insecure-company-alliance.com', port=443, path='api/*_*//new_user_sign_up', query='param=wild-things'))",
            "def json_dynamic_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Code Injection')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 74)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Plugin**: Code Injection\\n**Attack Vector**: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\\n**Vulnerable Parameter**: api\\n### Details\\nInjections happen when untrusted data is inserted into an interpreted syntax and subsequently evaluated on the server side. This syntax may be a SQL query, a parsed JSON or XML document, an executed script or other syntax that may be in use within the application. Although the target syntax has not been identified, the application behavior demonstrates that the input HTTP parameter may be inserted without proper escaping. It was observed by sending valid and invalid payloads that should throw or should not throw errors. By inserting a proper and improper comments such as ``, `*/_/*`, `/*_*/` into the `api` parameter, the scanner was able to spot a difference in the responses, which is a good indicator of a potential vulnerability. Confidence: medium. Response codes: `404`, `404`, `404`. Similarities: `` vs `*/_/*`: 0.0; `*/_/*` vs `/*_*/`: 0.0; `` vs `/*_*/`: 1.0.\")\n    self.assertEqual(finding.mitigation, 'It is recommended to identify how the current parameter is used in the application source code, and make sure it is escaped before inserting into any syntax or query. You can add valid values to an allowlist and invalid values to a blocklist.')\n    self.assertEqual(finding.references, '- [CWE](http://cwe.mitre.org/cgi-bin/jumpmenu.cgi?id=74)\\n')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_endpoints[0], Endpoint(protocol='https', host='application.insecure-company-alliance.com', port=443, path='api/*_*//new_user_sign_up', query='param=wild-things'))",
            "def json_dynamic_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(3, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Code Injection')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 74)\n    self.assertEqual(finding.description, \"### Meta Information\\n**Plugin**: Code Injection\\n**Attack Vector**: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\\n**Vulnerable Parameter**: api\\n### Details\\nInjections happen when untrusted data is inserted into an interpreted syntax and subsequently evaluated on the server side. This syntax may be a SQL query, a parsed JSON or XML document, an executed script or other syntax that may be in use within the application. Although the target syntax has not been identified, the application behavior demonstrates that the input HTTP parameter may be inserted without proper escaping. It was observed by sending valid and invalid payloads that should throw or should not throw errors. By inserting a proper and improper comments such as ``, `*/_/*`, `/*_*/` into the `api` parameter, the scanner was able to spot a difference in the responses, which is a good indicator of a potential vulnerability. Confidence: medium. Response codes: `404`, `404`, `404`. Similarities: `` vs `*/_/*`: 0.0; `*/_/*` vs `/*_*/`: 0.0; `` vs `/*_*/`: 1.0.\")\n    self.assertEqual(finding.mitigation, 'It is recommended to identify how the current parameter is used in the application source code, and make sure it is escaped before inserting into any syntax or query. You can add valid values to an allowlist and invalid values to a blocklist.')\n    self.assertEqual(finding.references, '- [CWE](http://cwe.mitre.org/cgi-bin/jumpmenu.cgi?id=74)\\n')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_endpoints[0], Endpoint(protocol='https', host='application.insecure-company-alliance.com', port=443, path='api/*_*//new_user_sign_up', query='param=wild-things'))"
        ]
    },
    {
        "func_name": "test_json_dynamic_findings_list_format",
        "original": "def test_json_dynamic_findings_list_format(self):\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_findings_list_format.json')",
        "mutated": [
            "def test_json_dynamic_findings_list_format(self):\n    if False:\n        i = 10\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_findings_list_format.json')",
            "def test_json_dynamic_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_findings_list_format.json')",
            "def test_json_dynamic_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_findings_list_format.json')",
            "def test_json_dynamic_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_findings_list_format.json')",
            "def test_json_dynamic_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_findings_list_format.json')"
        ]
    },
    {
        "func_name": "test_json_dynamic_embedded_format",
        "original": "def test_json_dynamic_embedded_format(self):\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_embedded_format.json')",
        "mutated": [
            "def test_json_dynamic_embedded_format(self):\n    if False:\n        i = 10\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_embedded_format.json')",
            "def test_json_dynamic_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_embedded_format.json')",
            "def test_json_dynamic_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_embedded_format.json')",
            "def test_json_dynamic_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_embedded_format.json')",
            "def test_json_dynamic_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.json_dynamic_findings_test('unittests/scans/veracode/dynamic_embedded_format.json')"
        ]
    },
    {
        "func_name": "json_sca_findings_test",
        "original": "def json_sca_findings_test(self, file_name):\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Uncontrolled Resource Consumption')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 400)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVA\\n#### Component Locations\\n- path/to/alpha/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/beta/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/charlie/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/delta/spring-boot-autoconfigure-2.5.14.jar\\n#### Licenses\\n- apache-2.0: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\nspring-boot-autoconfigure is vulnerable to Denial Of Service (DoS). The vulnerability is applicable when the application has Spring MVC auto-configuration enabled and uses the Spring Boot welcome page, which can be either static or templated, and the application is deployed behind a proxy which caches the 404 responses. An attacker can cause the application to crash by submitting a request to the welcome page which the server is unable to properly respond to.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'spring-boot-autoconfigure.jar')\n    self.assertEqual(finding.component_version, '2.5.14')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['CVE-2023-20883'])\n    finding = findings[3]\n    self.assertEqual(finding.title, 'inflight - SRCCLR-SID-41137')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 0)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVASCRIPT\\n#### Component Locations\\n- path/to/alpha/node_modules:inflight\\n#### Licenses\\n- isc: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\ninflight is vulnerable to a Memory Leak. The vulnerability is caused by improper memory management due to a lack of resource freeing, which can result in Denial of Service conditions.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'inflight')\n    self.assertEqual(finding.component_version, '1.0.6')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['SRCCLR-SID-41137'])",
        "mutated": [
            "def json_sca_findings_test(self, file_name):\n    if False:\n        i = 10\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Uncontrolled Resource Consumption')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 400)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVA\\n#### Component Locations\\n- path/to/alpha/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/beta/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/charlie/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/delta/spring-boot-autoconfigure-2.5.14.jar\\n#### Licenses\\n- apache-2.0: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\nspring-boot-autoconfigure is vulnerable to Denial Of Service (DoS). The vulnerability is applicable when the application has Spring MVC auto-configuration enabled and uses the Spring Boot welcome page, which can be either static or templated, and the application is deployed behind a proxy which caches the 404 responses. An attacker can cause the application to crash by submitting a request to the welcome page which the server is unable to properly respond to.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'spring-boot-autoconfigure.jar')\n    self.assertEqual(finding.component_version, '2.5.14')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['CVE-2023-20883'])\n    finding = findings[3]\n    self.assertEqual(finding.title, 'inflight - SRCCLR-SID-41137')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 0)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVASCRIPT\\n#### Component Locations\\n- path/to/alpha/node_modules:inflight\\n#### Licenses\\n- isc: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\ninflight is vulnerable to a Memory Leak. The vulnerability is caused by improper memory management due to a lack of resource freeing, which can result in Denial of Service conditions.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'inflight')\n    self.assertEqual(finding.component_version, '1.0.6')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['SRCCLR-SID-41137'])",
            "def json_sca_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Uncontrolled Resource Consumption')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 400)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVA\\n#### Component Locations\\n- path/to/alpha/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/beta/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/charlie/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/delta/spring-boot-autoconfigure-2.5.14.jar\\n#### Licenses\\n- apache-2.0: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\nspring-boot-autoconfigure is vulnerable to Denial Of Service (DoS). The vulnerability is applicable when the application has Spring MVC auto-configuration enabled and uses the Spring Boot welcome page, which can be either static or templated, and the application is deployed behind a proxy which caches the 404 responses. An attacker can cause the application to crash by submitting a request to the welcome page which the server is unable to properly respond to.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'spring-boot-autoconfigure.jar')\n    self.assertEqual(finding.component_version, '2.5.14')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['CVE-2023-20883'])\n    finding = findings[3]\n    self.assertEqual(finding.title, 'inflight - SRCCLR-SID-41137')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 0)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVASCRIPT\\n#### Component Locations\\n- path/to/alpha/node_modules:inflight\\n#### Licenses\\n- isc: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\ninflight is vulnerable to a Memory Leak. The vulnerability is caused by improper memory management due to a lack of resource freeing, which can result in Denial of Service conditions.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'inflight')\n    self.assertEqual(finding.component_version, '1.0.6')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['SRCCLR-SID-41137'])",
            "def json_sca_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Uncontrolled Resource Consumption')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 400)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVA\\n#### Component Locations\\n- path/to/alpha/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/beta/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/charlie/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/delta/spring-boot-autoconfigure-2.5.14.jar\\n#### Licenses\\n- apache-2.0: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\nspring-boot-autoconfigure is vulnerable to Denial Of Service (DoS). The vulnerability is applicable when the application has Spring MVC auto-configuration enabled and uses the Spring Boot welcome page, which can be either static or templated, and the application is deployed behind a proxy which caches the 404 responses. An attacker can cause the application to crash by submitting a request to the welcome page which the server is unable to properly respond to.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'spring-boot-autoconfigure.jar')\n    self.assertEqual(finding.component_version, '2.5.14')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['CVE-2023-20883'])\n    finding = findings[3]\n    self.assertEqual(finding.title, 'inflight - SRCCLR-SID-41137')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 0)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVASCRIPT\\n#### Component Locations\\n- path/to/alpha/node_modules:inflight\\n#### Licenses\\n- isc: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\ninflight is vulnerable to a Memory Leak. The vulnerability is caused by improper memory management due to a lack of resource freeing, which can result in Denial of Service conditions.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'inflight')\n    self.assertEqual(finding.component_version, '1.0.6')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['SRCCLR-SID-41137'])",
            "def json_sca_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Uncontrolled Resource Consumption')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 400)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVA\\n#### Component Locations\\n- path/to/alpha/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/beta/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/charlie/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/delta/spring-boot-autoconfigure-2.5.14.jar\\n#### Licenses\\n- apache-2.0: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\nspring-boot-autoconfigure is vulnerable to Denial Of Service (DoS). The vulnerability is applicable when the application has Spring MVC auto-configuration enabled and uses the Spring Boot welcome page, which can be either static or templated, and the application is deployed behind a proxy which caches the 404 responses. An attacker can cause the application to crash by submitting a request to the welcome page which the server is unable to properly respond to.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'spring-boot-autoconfigure.jar')\n    self.assertEqual(finding.component_version, '2.5.14')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['CVE-2023-20883'])\n    finding = findings[3]\n    self.assertEqual(finding.title, 'inflight - SRCCLR-SID-41137')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 0)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVASCRIPT\\n#### Component Locations\\n- path/to/alpha/node_modules:inflight\\n#### Licenses\\n- isc: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\ninflight is vulnerable to a Memory Leak. The vulnerability is caused by improper memory management due to a lack of resource freeing, which can result in Denial of Service conditions.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'inflight')\n    self.assertEqual(finding.component_version, '1.0.6')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['SRCCLR-SID-41137'])",
            "def json_sca_findings_test(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(file_name)\n    parser = VeracodeParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(7, len(findings))\n    finding = findings[0]\n    self.assertEqual(finding.title, 'Uncontrolled Resource Consumption')\n    self.assertEqual(finding.severity, 'High')\n    self.assertEqual(finding.cwe, 400)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVA\\n#### Component Locations\\n- path/to/alpha/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/beta/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/charlie/spring-boot-autoconfigure-2.5.14.jar\\n- path/to/delta/spring-boot-autoconfigure-2.5.14.jar\\n#### Licenses\\n- apache-2.0: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\nspring-boot-autoconfigure is vulnerable to Denial Of Service (DoS). The vulnerability is applicable when the application has Spring MVC auto-configuration enabled and uses the Spring Boot welcome page, which can be either static or templated, and the application is deployed behind a proxy which caches the 404 responses. An attacker can cause the application to crash by submitting a request to the welcome page which the server is unable to properly respond to.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'spring-boot-autoconfigure.jar')\n    self.assertEqual(finding.component_version, '2.5.14')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['CVE-2023-20883'])\n    finding = findings[3]\n    self.assertEqual(finding.title, 'inflight - SRCCLR-SID-41137')\n    self.assertEqual(finding.severity, 'Medium')\n    self.assertEqual(finding.cwe, 0)\n    self.assertEqual(finding.description, '### Meta Information\\n**Product ID**: abc123-bca321\\n**Component ID**: efg456-gfe654\\n**Language**: JAVASCRIPT\\n#### Component Locations\\n- path/to/alpha/node_modules:inflight\\n#### Licenses\\n- isc: Low\\n    - Low-risk licenses are typically permissive licenses that require you to preserve the copyright and license notices, but allow distribution under different terms without disclosing source code.\\n### Details\\ninflight is vulnerable to a Memory Leak. The vulnerability is caused by improper memory management due to a lack of resource freeing, which can result in Denial of Service conditions.')\n    self.assertEqual(finding.cvssv3, 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H')\n    self.assertEqual(finding.component_name, 'inflight')\n    self.assertEqual(finding.component_version, '1.0.6')\n    self.assertEqual(finding.unsaved_tags, ['policy-violation'])\n    self.assertEqual(finding.unsaved_vulnerability_ids, ['SRCCLR-SID-41137'])"
        ]
    },
    {
        "func_name": "test_json_sca_findings_list_format",
        "original": "def test_json_sca_findings_list_format(self):\n    self.json_sca_findings_test('unittests/scans/veracode/sca_findings_list_format.json')",
        "mutated": [
            "def test_json_sca_findings_list_format(self):\n    if False:\n        i = 10\n    self.json_sca_findings_test('unittests/scans/veracode/sca_findings_list_format.json')",
            "def test_json_sca_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.json_sca_findings_test('unittests/scans/veracode/sca_findings_list_format.json')",
            "def test_json_sca_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.json_sca_findings_test('unittests/scans/veracode/sca_findings_list_format.json')",
            "def test_json_sca_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.json_sca_findings_test('unittests/scans/veracode/sca_findings_list_format.json')",
            "def test_json_sca_findings_list_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.json_sca_findings_test('unittests/scans/veracode/sca_findings_list_format.json')"
        ]
    },
    {
        "func_name": "test_json_sca_embedded_format",
        "original": "def test_json_sca_embedded_format(self):\n    self.json_sca_findings_test('unittests/scans/veracode/sca_embedded_format.json')",
        "mutated": [
            "def test_json_sca_embedded_format(self):\n    if False:\n        i = 10\n    self.json_sca_findings_test('unittests/scans/veracode/sca_embedded_format.json')",
            "def test_json_sca_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.json_sca_findings_test('unittests/scans/veracode/sca_embedded_format.json')",
            "def test_json_sca_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.json_sca_findings_test('unittests/scans/veracode/sca_embedded_format.json')",
            "def test_json_sca_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.json_sca_findings_test('unittests/scans/veracode/sca_embedded_format.json')",
            "def test_json_sca_embedded_format(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.json_sca_findings_test('unittests/scans/veracode/sca_embedded_format.json')"
        ]
    }
]