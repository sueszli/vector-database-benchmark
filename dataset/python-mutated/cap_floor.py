"""Pricing of Interest rate Caps/Floors using Heath-Jarrow-Morton model."""
from typing import Callable, Union
import tensorflow.compat.v2 as tf
from tf_quant_finance import types
from tf_quant_finance.math import random
from tf_quant_finance.models.hjm import zero_coupon_bond_option as zcb
__all__ = ['cap_floor_price']

def cap_floor_price(*, strikes: types.RealTensor, expiries: types.RealTensor, maturities: types.RealTensor, daycount_fractions: types.RealTensor, reference_rate_fn: Callable[..., types.RealTensor], dim: int, mean_reversion: types.RealTensor, volatility: Union[types.RealTensor, Callable[..., types.RealTensor]], corr_matrix: types.RealTensor=None, notional: types.RealTensor=1.0, is_cap: types.BoolTensor=True, num_samples: types.IntTensor=1, random_type: random.RandomType=None, seed: types.IntTensor=None, skip: types.IntTensor=0, time_step: types.RealTensor=None, dtype: tf.DType=None, name: str=None) -> types.RealTensor:
    if False:
        print('Hello World!')
    "Calculates the prices of interest rate Caps/Floors using the HJM model.\n\n  An interest Cap (or Floor) is a portfolio of call (or put) options where the\n  underlying for the individual options are successive forward rates. The\n  individual options comprising a Cap are called Caplets and the corresponding\n  options comprising a Floor are called Floorlets. For example, a\n  caplet on forward rate `F(T_i, T_{i+1})` has the following payoff at time\n  `T_{i_1}`:\n\n  ```None\n\n   caplet payoff = tau_i * max[F(T_i, T_{i+1}) - X, 0]\n\n  ```\n  where where `X` is the strake rate and `tau_i` is the daycount fraction. The\n  caplet payoff (at `T_{i+1}`) can be expressed as the following at `T_i`:\n\n  ```None\n\n  caplet_payoff = (1.0 + tau_i * X) *\n                  max[1.0 / (1 + tau_i * X) - P(T_i, T_{t+1}), 0]\n\n  ```\n\n  where `P(T_i, T_{i+1})` is the price at `T_i` of a zero coupon bond with\n  maturity `T_{i+1}. Thus, a caplet can be priced as a put option on zero\n  coupon bond [1].\n\n  #### References\n    [1]: D. Brigo, F. Mercurio. Interest Rate Models-Theory and Practice.\n    Second Edition. 2007.\n\n  #### Example\n  The example shows how value a batch containing spot starting 1-year and\n  2-year Caps and with quarterly frequency.\n\n  ````python\n  import numpy as np\n  import tensorflow.compat.v2 as tf\n  import tf_quant_finance as tff\n\n  dtype = tf.float64\n\n  reference_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n  expiries = np.array([[0.0, 0.25, 0.5, 0.75, 1.0, 1.0, 1.0, 1.0],\n                       [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75]])\n  maturities = np.array([[0.25, 0.5, 0.75, 1.0, 1.0, 1.0, 1.0, 1.0],\n                       [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]])\n  strikes = 0.01 * np.ones_like(expiries)\n  daycount_fractions = np.array([[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0],\n                       [0.0, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]])\n  price = tff.models.hjm.cap_floor_price(\n      strikes=strikes,\n      expiries=expiries,\n      maturities=maturities,\n      daycount_fractions=daycount_fractions,\n      notional=1.0e6,\n      dim=1,\n      mean_reversion=[0.03],\n      volatility=[0.02],\n      reference_rate_fn=reference_rate_fn,\n      num_samples=500000,\n      time_step=0.025,\n      random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC,\n      seed=[1, 2],\n      dtype=dtype)\n  # Expected value: [[4071.821182], [15518.53244292]]\n  ````\n\n  Args:\n    strikes: A real `Tensor` of any shape and dtype. The strike rate of the\n      caplets or floorlets. The shape of this input determines the number (and\n      shape) of the options to be priced and the shape of the output. For an\n      N-dimensional input `Tensor`, the first N-1 dimensions correspond to the\n      batch dimension, i.e., the distinct caps and floors and the last dimension\n      correspond to the caplets or floorlets contained with an instrument.\n    expiries: A real `Tensor` of the same dtype and compatible shape as\n      `strikes`.  The reset time of each caplet (or floorlet).\n    maturities: A real `Tensor` of the same dtype and compatible shape as\n      `strikes`.  The maturity time of each caplet (or floorlet) and also the\n      time at which payment is made.\n    daycount_fractions: A real `Tensor` of the same dtype and compatible shape\n      as `strikes`. The daycount fractions associated with the underlying\n      forward rates.\n    reference_rate_fn: A Python callable that accepts expiry time as a real\n      `Tensor` and returns a `Tensor` of shape `input_shape`. Returns the\n      continuously compounded zero rate at the present time for the input expiry\n      time.\n    dim: A Python scalar which corresponds to the number of factors within a\n      single HJM model.\n    mean_reversion: A real positive `Tensor` of shape `[dim]`. Corresponds to\n      the mean reversion rate of each factor.\n    volatility: A real positive `Tensor` of the same `dtype` and shape as\n      `mean_reversion` or a callable with the following properties: (a)  The\n        callable should accept a scalar `Tensor` `t` and a 1-D `Tensor` `r(t)`\n        of shape `[num_samples]` and returns a 2-D `Tensor` of shape\n        `[num_samples, dim]`. The variable `t`  stands for time and `r(t)` is\n        the short rate at time `t`.  The function returns instantaneous\n        volatility `sigma(t) = sigma(t, r(t))`. When `volatility` is specified\n        is a real `Tensor`, each factor is assumed to have a constant\n        instantaneous volatility  and the  model is effectively a Gaussian HJM\n        model. Corresponds to the instantaneous volatility of each factor.\n    corr_matrix: A `Tensor` of shape `[dim, dim]` and the same `dtype` as\n      `mean_reversion`. Corresponds to the correlation matrix `Rho`.\n      Default value: None, meaning the factors are uncorrelated.\n    notional: An optional `Tensor` of same dtype and compatible shape as\n      `strikes`specifying the notional amount for the cap (or floor).\n       Default value: None in which case the notional is set to 1.\n    is_cap: A boolean `Tensor` of a shape compatible with `strikes`. Indicates\n      whether the option is a Cap (if True) or a Floor (if False). If not\n      supplied, Caps are assumed.\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\n      paths during Monte-Carlo valuation.\n      Default value: The default value is 1.\n    random_type: Enum value of `RandomType`. The type of (quasi)-random number\n      generator to use to generate the simulation paths.\n      Default value: `None` which maps to the standard pseudo-random numbers.\n    seed: Seed for the random number generator. The seed is only relevant if\n      `random_type` is one of `[STATELESS, PSEUDO, HALTON_RANDOMIZED,\n      PSEUDO_ANTITHETIC, STATELESS_ANTITHETIC]`. For `PSEUDO`,\n      `PSEUDO_ANTITHETIC` and `HALTON_RANDOMIZED` the seed should be an Python\n      integer. For `STATELESS` and  `STATELESS_ANTITHETIC `must be supplied as\n      an integer `Tensor` of shape `[2]`.\n      Default value: `None` which means no seed is set.\n    skip: `int32` 0-d `Tensor`. The number of initial points of the Sobol or\n      Halton sequence to skip. Used only when `random_type` is 'SOBOL',\n      'HALTON', or 'HALTON_RANDOMIZED', otherwise ignored.\n      Default value: `0`.\n    time_step: Scalar real `Tensor`. Maximal distance between time grid points\n      in Euler scheme. Relevant when Euler scheme is used for simulation.\n      Default value: `None`.\n    dtype: The default dtype to use when converting values to `Tensor`s.\n      Default value: `None` which means that default dtypes inferred by\n        TensorFlow are used.\n    name: Python string. The name to give to the ops created by this class.\n      Default value: `None` which maps to the default name\n        `hjm_cap_floor_price`.\n\n  Returns:\n    A `Tensor` of real dtype and shape  strikes.shape[:-1] containing\n    the computed option prices. For caplets that have reset in the past\n    (expiries<0), the function sets the corresponding caplet prices to 0.0.\n  "
    name = name or 'hjm_cap_floor_price'
    with tf.name_scope(name):
        strikes = tf.convert_to_tensor(strikes, dtype=dtype, name='strikes')
        dtype = dtype or strikes.dtype
        expiries = tf.convert_to_tensor(expiries, dtype=dtype, name='expiries')
        maturities = tf.convert_to_tensor(maturities, dtype=dtype, name='maturities')
        daycount_fractions = tf.convert_to_tensor(daycount_fractions, dtype=dtype, name='daycount_fractions')
        notional = tf.convert_to_tensor(notional, dtype=dtype, name='notional')
        is_cap = tf.convert_to_tensor(is_cap, dtype=tf.bool, name='is_cap')
        is_call_options = ~is_cap
        bond_option_strikes = 1.0 / (1.0 + daycount_fractions * strikes)
        caplet_prices = zcb.bond_option_price(strikes=bond_option_strikes, expiries=expiries, maturities=maturities, discount_rate_fn=reference_rate_fn, dim=dim, mean_reversion=mean_reversion, volatility=volatility, corr_matrix=corr_matrix, is_call_options=is_call_options, num_samples=num_samples, random_type=random_type, seed=seed, skip=skip, time_step=time_step, dtype=dtype, name=name + '_bond_option')
        caplet_prices = tf.where(expiries < 0.0, tf.zeros_like(expiries), caplet_prices)
        cap_prices = tf.math.reduce_sum(notional * (1.0 + daycount_fractions * strikes) * caplet_prices, axis=-1)
        return cap_prices