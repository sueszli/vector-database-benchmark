[
    {
        "func_name": "contains_alias",
        "original": "@util.deprecated('1.4', 'The :class:`.AliasOption` object is not necessary for entities to be matched up to a query that is established via :meth:`.Query.from_statement` and now does nothing.', enable_warnings=False)\ndef contains_alias(alias: Union[Alias, Subquery]) -> AliasOption:\n    \"\"\"Return a :class:`.MapperOption` that will indicate to the\n    :class:`_query.Query`\n    that the main table has been aliased.\n\n    \"\"\"\n    return AliasOption(alias)",
        "mutated": [
            "@util.deprecated('1.4', 'The :class:`.AliasOption` object is not necessary for entities to be matched up to a query that is established via :meth:`.Query.from_statement` and now does nothing.', enable_warnings=False)\ndef contains_alias(alias: Union[Alias, Subquery]) -> AliasOption:\n    if False:\n        i = 10\n    'Return a :class:`.MapperOption` that will indicate to the\\n    :class:`_query.Query`\\n    that the main table has been aliased.\\n\\n    '\n    return AliasOption(alias)",
            "@util.deprecated('1.4', 'The :class:`.AliasOption` object is not necessary for entities to be matched up to a query that is established via :meth:`.Query.from_statement` and now does nothing.', enable_warnings=False)\ndef contains_alias(alias: Union[Alias, Subquery]) -> AliasOption:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a :class:`.MapperOption` that will indicate to the\\n    :class:`_query.Query`\\n    that the main table has been aliased.\\n\\n    '\n    return AliasOption(alias)",
            "@util.deprecated('1.4', 'The :class:`.AliasOption` object is not necessary for entities to be matched up to a query that is established via :meth:`.Query.from_statement` and now does nothing.', enable_warnings=False)\ndef contains_alias(alias: Union[Alias, Subquery]) -> AliasOption:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a :class:`.MapperOption` that will indicate to the\\n    :class:`_query.Query`\\n    that the main table has been aliased.\\n\\n    '\n    return AliasOption(alias)",
            "@util.deprecated('1.4', 'The :class:`.AliasOption` object is not necessary for entities to be matched up to a query that is established via :meth:`.Query.from_statement` and now does nothing.', enable_warnings=False)\ndef contains_alias(alias: Union[Alias, Subquery]) -> AliasOption:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a :class:`.MapperOption` that will indicate to the\\n    :class:`_query.Query`\\n    that the main table has been aliased.\\n\\n    '\n    return AliasOption(alias)",
            "@util.deprecated('1.4', 'The :class:`.AliasOption` object is not necessary for entities to be matched up to a query that is established via :meth:`.Query.from_statement` and now does nothing.', enable_warnings=False)\ndef contains_alias(alias: Union[Alias, Subquery]) -> AliasOption:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a :class:`.MapperOption` that will indicate to the\\n    :class:`_query.Query`\\n    that the main table has been aliased.\\n\\n    '\n    return AliasOption(alias)"
        ]
    },
    {
        "func_name": "mapped_column",
        "original": "def mapped_column(__name_pos: Optional[Union[str, _TypeEngineArgument[Any], SchemaEventTarget]]=None, __type_pos: Optional[Union[_TypeEngineArgument[Any], SchemaEventTarget]]=None, /, *args: SchemaEventTarget, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, nullable: Optional[Union[bool, Literal[SchemaConst.NULL_UNSPECIFIED]]]=SchemaConst.NULL_UNSPECIFIED, primary_key: Optional[bool]=False, deferred: Union[_NoArg, bool]=_NoArg.NO_ARG, deferred_group: Optional[str]=None, deferred_raiseload: Optional[bool]=None, use_existing_column: bool=False, name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, autoincrement: _AutoIncrementType='auto', doc: Optional[str]=None, key: Optional[str]=None, index: Optional[bool]=None, unique: Optional[bool]=None, info: Optional[_InfoType]=None, onupdate: Optional[Any]=None, insert_default: Optional[Any]=_NoArg.NO_ARG, server_default: Optional[_ServerDefaultArgument]=None, server_onupdate: Optional[FetchedValue]=None, active_history: bool=False, quote: Optional[bool]=None, system: bool=False, comment: Optional[str]=None, sort_order: Union[_NoArg, int]=_NoArg.NO_ARG, **kw: Any) -> MappedColumn[Any]:\n    \"\"\"declare a new ORM-mapped :class:`_schema.Column` construct\n    for use within :ref:`Declarative Table <orm_declarative_table>`\n    configuration.\n\n    The :func:`_orm.mapped_column` function provides an ORM-aware and\n    Python-typing-compatible construct which is used with\n    :ref:`declarative <orm_declarative_mapping>` mappings to indicate an\n    attribute that's mapped to a Core :class:`_schema.Column` object.  It\n    provides the equivalent feature as mapping an attribute to a\n    :class:`_schema.Column` object directly when using Declarative,\n    specifically when using :ref:`Declarative Table <orm_declarative_table>`\n    configuration.\n\n    .. versionadded:: 2.0\n\n    :func:`_orm.mapped_column` is normally used with explicit typing along with\n    the :class:`_orm.Mapped` annotation type, where it can derive the SQL\n    type and nullability for the column based on what's present within the\n    :class:`_orm.Mapped` annotation.   It also may be used without annotations\n    as a drop-in replacement for how :class:`_schema.Column` is used in\n    Declarative mappings in SQLAlchemy 1.x style.\n\n    For usage examples of :func:`_orm.mapped_column`, see the documentation\n    at :ref:`orm_declarative_table`.\n\n    .. seealso::\n\n        :ref:`orm_declarative_table` - complete documentation\n\n        :ref:`whatsnew_20_orm_declarative_typing` - migration notes for\n        Declarative mappings using 1.x style mappings\n\n    :param __name: String name to give to the :class:`_schema.Column`.  This\n     is an optional, positional only argument that if present must be the\n     first positional argument passed.  If omitted, the attribute name to\n     which the :func:`_orm.mapped_column`  is mapped will be used as the SQL\n     column name.\n    :param __type: :class:`_types.TypeEngine` type or instance which will\n     indicate the datatype to be associated with the :class:`_schema.Column`.\n     This is an optional, positional-only argument that if present must\n     immediately follow the ``__name`` parameter if present also, or otherwise\n     be the first positional parameter.  If omitted, the ultimate type for\n     the column may be derived either from the annotated type, or if a\n     :class:`_schema.ForeignKey` is present, from the datatype of the\n     referenced column.\n    :param \\\\*args: Additional positional arguments include constructs such\n     as :class:`_schema.ForeignKey`, :class:`_schema.CheckConstraint`,\n     and :class:`_schema.Identity`, which are passed through to the constructed\n     :class:`_schema.Column`.\n    :param nullable: Optional bool, whether the column should be \"NULL\" or\n     \"NOT NULL\". If omitted, the nullability is derived from the type\n     annotation based on whether or not ``typing.Optional`` is present.\n     ``nullable`` defaults to ``True`` otherwise for non-primary key columns,\n     and ``False`` for primary key columns.\n    :param primary_key: optional bool, indicates the :class:`_schema.Column`\n     would be part of the table's primary key or not.\n    :param deferred: Optional bool - this keyword argument is consumed by the\n     ORM declarative process, and is not part of the :class:`_schema.Column`\n     itself; instead, it indicates that this column should be \"deferred\" for\n     loading as though mapped by :func:`_orm.deferred`.\n\n     .. seealso::\n\n        :ref:`orm_queryguide_deferred_declarative`\n\n    :param deferred_group: Implies :paramref:`_orm.mapped_column.deferred`\n     to ``True``, and set the :paramref:`_orm.deferred.group` parameter.\n\n     .. seealso::\n\n        :ref:`orm_queryguide_deferred_group`\n\n    :param deferred_raiseload: Implies :paramref:`_orm.mapped_column.deferred`\n     to ``True``, and set the :paramref:`_orm.deferred.raiseload` parameter.\n\n     .. seealso::\n\n        :ref:`orm_queryguide_deferred_raiseload`\n\n    :param use_existing_column: if True, will attempt to locate the given\n     column name on an inherited superclass (typically single inheriting\n     superclass), and if present, will not produce a new column, mapping\n     to the superclass column as though it were omitted from this class.\n     This is used for mixins that add new columns to an inherited superclass.\n\n     .. seealso::\n\n        :ref:`orm_inheritance_column_conflicts`\n\n     .. versionadded:: 2.0.0b4\n\n    :param default: Passed directly to the\n     :paramref:`_schema.Column.default` parameter if the\n     :paramref:`_orm.mapped_column.insert_default` parameter is not present.\n     Additionally, when used with :ref:`orm_declarative_native_dataclasses`,\n     indicates a default Python value that should be applied to the keyword\n     constructor within the generated ``__init__()`` method.\n\n     Note that in the case of dataclass generation when\n     :paramref:`_orm.mapped_column.insert_default` is not present, this means\n     the :paramref:`_orm.mapped_column.default` value is used in **two**\n     places, both the ``__init__()`` method as well as the\n     :paramref:`_schema.Column.default` parameter. While this behavior may\n     change in a future release, for the moment this tends to \"work out\"; a\n     default of ``None`` will mean that the :class:`_schema.Column` gets no\n     default generator, whereas a default that refers to a non-``None`` Python\n     or SQL expression value will be assigned up front on the object when\n     ``__init__()`` is called, which is the same value that the Core\n     :class:`_sql.Insert` construct would use in any case, leading to the same\n     end result.\n\n     .. note:: When using Core level column defaults that are callables to\n        be interpreted by the underlying :class:`_schema.Column` in conjunction\n        with :ref:`ORM-mapped dataclasses\n        <orm_declarative_native_dataclasses>`, especially those that are\n        :ref:`context-aware default functions <context_default_functions>`,\n        **the** :paramref:`_orm.mapped_column.insert_default` **parameter must\n        be used instead**.  This is necessary to disambiguate the callable from\n        being interpreted as a dataclass level default.\n\n    :param insert_default: Passed directly to the\n     :paramref:`_schema.Column.default` parameter; will supersede the value\n     of :paramref:`_orm.mapped_column.default` when present, however\n     :paramref:`_orm.mapped_column.default` will always apply to the\n     constructor default for a dataclasses mapping.\n\n    :param sort_order: An integer that indicates how this mapped column\n     should be sorted compared to the others when the ORM is creating a\n     :class:`_schema.Table`. Among mapped columns that have the same\n     value the default ordering is used, placing first the mapped columns\n     defined in the main class, then the ones in the super classes.\n     Defaults to 0. The sort is ascending.\n\n     .. versionadded:: 2.0.4\n\n    :param active_history=False:\n\n        When ``True``, indicates that the \"previous\" value for a\n        scalar attribute should be loaded when replaced, if not\n        already loaded. Normally, history tracking logic for\n        simple non-primary-key scalar values only needs to be\n        aware of the \"new\" value in order to perform a flush. This\n        flag is available for applications that make use of\n        :func:`.attributes.get_history` or :meth:`.Session.is_modified`\n        which also need to know the \"previous\" value of the attribute.\n\n        .. versionadded:: 2.0.10\n\n\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\n     specifies if the mapped attribute should be part of the ``__init__()``\n     method as generated by the dataclass process.\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\n     specifies if the mapped attribute should be part of the ``__repr__()``\n     method as generated by the dataclass process.\n    :param default_factory: Specific to\n     :ref:`orm_declarative_native_dataclasses`,\n     specifies a default-value generation function that will take place\n     as part of the ``__init__()``\n     method as generated by the dataclass process.\n    :param compare: Specific to\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\n     should be included in comparison operations when generating the\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\n\n     .. versionadded:: 2.0.0b4\n\n    :param kw_only: Specific to\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\n     should be marked as keyword-only when generating the ``__init__()``.\n\n    :param \\\\**kw: All remaining keyword arguments are passed through to the\n     constructor for the :class:`_schema.Column`.\n\n    \"\"\"\n    return MappedColumn(__name_pos, __type_pos, *args, name=name, type_=type_, autoincrement=autoincrement, insert_default=insert_default, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, key=key, index=index, unique=unique, info=info, active_history=active_history, nullable=nullable, onupdate=onupdate, primary_key=primary_key, server_default=server_default, server_onupdate=server_onupdate, use_existing_column=use_existing_column, quote=quote, comment=comment, system=system, deferred=deferred, deferred_group=deferred_group, deferred_raiseload=deferred_raiseload, sort_order=sort_order, **kw)",
        "mutated": [
            "def mapped_column(__name_pos: Optional[Union[str, _TypeEngineArgument[Any], SchemaEventTarget]]=None, __type_pos: Optional[Union[_TypeEngineArgument[Any], SchemaEventTarget]]=None, /, *args: SchemaEventTarget, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, nullable: Optional[Union[bool, Literal[SchemaConst.NULL_UNSPECIFIED]]]=SchemaConst.NULL_UNSPECIFIED, primary_key: Optional[bool]=False, deferred: Union[_NoArg, bool]=_NoArg.NO_ARG, deferred_group: Optional[str]=None, deferred_raiseload: Optional[bool]=None, use_existing_column: bool=False, name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, autoincrement: _AutoIncrementType='auto', doc: Optional[str]=None, key: Optional[str]=None, index: Optional[bool]=None, unique: Optional[bool]=None, info: Optional[_InfoType]=None, onupdate: Optional[Any]=None, insert_default: Optional[Any]=_NoArg.NO_ARG, server_default: Optional[_ServerDefaultArgument]=None, server_onupdate: Optional[FetchedValue]=None, active_history: bool=False, quote: Optional[bool]=None, system: bool=False, comment: Optional[str]=None, sort_order: Union[_NoArg, int]=_NoArg.NO_ARG, **kw: Any) -> MappedColumn[Any]:\n    if False:\n        i = 10\n    'declare a new ORM-mapped :class:`_schema.Column` construct\\n    for use within :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    The :func:`_orm.mapped_column` function provides an ORM-aware and\\n    Python-typing-compatible construct which is used with\\n    :ref:`declarative <orm_declarative_mapping>` mappings to indicate an\\n    attribute that\\'s mapped to a Core :class:`_schema.Column` object.  It\\n    provides the equivalent feature as mapping an attribute to a\\n    :class:`_schema.Column` object directly when using Declarative,\\n    specifically when using :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    .. versionadded:: 2.0\\n\\n    :func:`_orm.mapped_column` is normally used with explicit typing along with\\n    the :class:`_orm.Mapped` annotation type, where it can derive the SQL\\n    type and nullability for the column based on what\\'s present within the\\n    :class:`_orm.Mapped` annotation.   It also may be used without annotations\\n    as a drop-in replacement for how :class:`_schema.Column` is used in\\n    Declarative mappings in SQLAlchemy 1.x style.\\n\\n    For usage examples of :func:`_orm.mapped_column`, see the documentation\\n    at :ref:`orm_declarative_table`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_declarative_table` - complete documentation\\n\\n        :ref:`whatsnew_20_orm_declarative_typing` - migration notes for\\n        Declarative mappings using 1.x style mappings\\n\\n    :param __name: String name to give to the :class:`_schema.Column`.  This\\n     is an optional, positional only argument that if present must be the\\n     first positional argument passed.  If omitted, the attribute name to\\n     which the :func:`_orm.mapped_column`  is mapped will be used as the SQL\\n     column name.\\n    :param __type: :class:`_types.TypeEngine` type or instance which will\\n     indicate the datatype to be associated with the :class:`_schema.Column`.\\n     This is an optional, positional-only argument that if present must\\n     immediately follow the ``__name`` parameter if present also, or otherwise\\n     be the first positional parameter.  If omitted, the ultimate type for\\n     the column may be derived either from the annotated type, or if a\\n     :class:`_schema.ForeignKey` is present, from the datatype of the\\n     referenced column.\\n    :param \\\\*args: Additional positional arguments include constructs such\\n     as :class:`_schema.ForeignKey`, :class:`_schema.CheckConstraint`,\\n     and :class:`_schema.Identity`, which are passed through to the constructed\\n     :class:`_schema.Column`.\\n    :param nullable: Optional bool, whether the column should be \"NULL\" or\\n     \"NOT NULL\". If omitted, the nullability is derived from the type\\n     annotation based on whether or not ``typing.Optional`` is present.\\n     ``nullable`` defaults to ``True`` otherwise for non-primary key columns,\\n     and ``False`` for primary key columns.\\n    :param primary_key: optional bool, indicates the :class:`_schema.Column`\\n     would be part of the table\\'s primary key or not.\\n    :param deferred: Optional bool - this keyword argument is consumed by the\\n     ORM declarative process, and is not part of the :class:`_schema.Column`\\n     itself; instead, it indicates that this column should be \"deferred\" for\\n     loading as though mapped by :func:`_orm.deferred`.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_declarative`\\n\\n    :param deferred_group: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.group` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_group`\\n\\n    :param deferred_raiseload: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.raiseload` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param use_existing_column: if True, will attempt to locate the given\\n     column name on an inherited superclass (typically single inheriting\\n     superclass), and if present, will not produce a new column, mapping\\n     to the superclass column as though it were omitted from this class.\\n     This is used for mixins that add new columns to an inherited superclass.\\n\\n     .. seealso::\\n\\n        :ref:`orm_inheritance_column_conflicts`\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter if the\\n     :paramref:`_orm.mapped_column.insert_default` parameter is not present.\\n     Additionally, when used with :ref:`orm_declarative_native_dataclasses`,\\n     indicates a default Python value that should be applied to the keyword\\n     constructor within the generated ``__init__()`` method.\\n\\n     Note that in the case of dataclass generation when\\n     :paramref:`_orm.mapped_column.insert_default` is not present, this means\\n     the :paramref:`_orm.mapped_column.default` value is used in **two**\\n     places, both the ``__init__()`` method as well as the\\n     :paramref:`_schema.Column.default` parameter. While this behavior may\\n     change in a future release, for the moment this tends to \"work out\"; a\\n     default of ``None`` will mean that the :class:`_schema.Column` gets no\\n     default generator, whereas a default that refers to a non-``None`` Python\\n     or SQL expression value will be assigned up front on the object when\\n     ``__init__()`` is called, which is the same value that the Core\\n     :class:`_sql.Insert` construct would use in any case, leading to the same\\n     end result.\\n\\n     .. note:: When using Core level column defaults that are callables to\\n        be interpreted by the underlying :class:`_schema.Column` in conjunction\\n        with :ref:`ORM-mapped dataclasses\\n        <orm_declarative_native_dataclasses>`, especially those that are\\n        :ref:`context-aware default functions <context_default_functions>`,\\n        **the** :paramref:`_orm.mapped_column.insert_default` **parameter must\\n        be used instead**.  This is necessary to disambiguate the callable from\\n        being interpreted as a dataclass level default.\\n\\n    :param insert_default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter; will supersede the value\\n     of :paramref:`_orm.mapped_column.default` when present, however\\n     :paramref:`_orm.mapped_column.default` will always apply to the\\n     constructor default for a dataclasses mapping.\\n\\n    :param sort_order: An integer that indicates how this mapped column\\n     should be sorted compared to the others when the ORM is creating a\\n     :class:`_schema.Table`. Among mapped columns that have the same\\n     value the default ordering is used, placing first the mapped columns\\n     defined in the main class, then the ones in the super classes.\\n     Defaults to 0. The sort is ascending.\\n\\n     .. versionadded:: 2.0.4\\n\\n    :param active_history=False:\\n\\n        When ``True``, indicates that the \"previous\" value for a\\n        scalar attribute should be loaded when replaced, if not\\n        already loaded. Normally, history tracking logic for\\n        simple non-primary-key scalar values only needs to be\\n        aware of the \"new\" value in order to perform a flush. This\\n        flag is available for applications that make use of\\n        :func:`.attributes.get_history` or :meth:`.Session.is_modified`\\n        which also need to know the \"previous\" value of the attribute.\\n\\n        .. versionadded:: 2.0.10\\n\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    :param \\\\**kw: All remaining keyword arguments are passed through to the\\n     constructor for the :class:`_schema.Column`.\\n\\n    '\n    return MappedColumn(__name_pos, __type_pos, *args, name=name, type_=type_, autoincrement=autoincrement, insert_default=insert_default, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, key=key, index=index, unique=unique, info=info, active_history=active_history, nullable=nullable, onupdate=onupdate, primary_key=primary_key, server_default=server_default, server_onupdate=server_onupdate, use_existing_column=use_existing_column, quote=quote, comment=comment, system=system, deferred=deferred, deferred_group=deferred_group, deferred_raiseload=deferred_raiseload, sort_order=sort_order, **kw)",
            "def mapped_column(__name_pos: Optional[Union[str, _TypeEngineArgument[Any], SchemaEventTarget]]=None, __type_pos: Optional[Union[_TypeEngineArgument[Any], SchemaEventTarget]]=None, /, *args: SchemaEventTarget, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, nullable: Optional[Union[bool, Literal[SchemaConst.NULL_UNSPECIFIED]]]=SchemaConst.NULL_UNSPECIFIED, primary_key: Optional[bool]=False, deferred: Union[_NoArg, bool]=_NoArg.NO_ARG, deferred_group: Optional[str]=None, deferred_raiseload: Optional[bool]=None, use_existing_column: bool=False, name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, autoincrement: _AutoIncrementType='auto', doc: Optional[str]=None, key: Optional[str]=None, index: Optional[bool]=None, unique: Optional[bool]=None, info: Optional[_InfoType]=None, onupdate: Optional[Any]=None, insert_default: Optional[Any]=_NoArg.NO_ARG, server_default: Optional[_ServerDefaultArgument]=None, server_onupdate: Optional[FetchedValue]=None, active_history: bool=False, quote: Optional[bool]=None, system: bool=False, comment: Optional[str]=None, sort_order: Union[_NoArg, int]=_NoArg.NO_ARG, **kw: Any) -> MappedColumn[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'declare a new ORM-mapped :class:`_schema.Column` construct\\n    for use within :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    The :func:`_orm.mapped_column` function provides an ORM-aware and\\n    Python-typing-compatible construct which is used with\\n    :ref:`declarative <orm_declarative_mapping>` mappings to indicate an\\n    attribute that\\'s mapped to a Core :class:`_schema.Column` object.  It\\n    provides the equivalent feature as mapping an attribute to a\\n    :class:`_schema.Column` object directly when using Declarative,\\n    specifically when using :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    .. versionadded:: 2.0\\n\\n    :func:`_orm.mapped_column` is normally used with explicit typing along with\\n    the :class:`_orm.Mapped` annotation type, where it can derive the SQL\\n    type and nullability for the column based on what\\'s present within the\\n    :class:`_orm.Mapped` annotation.   It also may be used without annotations\\n    as a drop-in replacement for how :class:`_schema.Column` is used in\\n    Declarative mappings in SQLAlchemy 1.x style.\\n\\n    For usage examples of :func:`_orm.mapped_column`, see the documentation\\n    at :ref:`orm_declarative_table`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_declarative_table` - complete documentation\\n\\n        :ref:`whatsnew_20_orm_declarative_typing` - migration notes for\\n        Declarative mappings using 1.x style mappings\\n\\n    :param __name: String name to give to the :class:`_schema.Column`.  This\\n     is an optional, positional only argument that if present must be the\\n     first positional argument passed.  If omitted, the attribute name to\\n     which the :func:`_orm.mapped_column`  is mapped will be used as the SQL\\n     column name.\\n    :param __type: :class:`_types.TypeEngine` type or instance which will\\n     indicate the datatype to be associated with the :class:`_schema.Column`.\\n     This is an optional, positional-only argument that if present must\\n     immediately follow the ``__name`` parameter if present also, or otherwise\\n     be the first positional parameter.  If omitted, the ultimate type for\\n     the column may be derived either from the annotated type, or if a\\n     :class:`_schema.ForeignKey` is present, from the datatype of the\\n     referenced column.\\n    :param \\\\*args: Additional positional arguments include constructs such\\n     as :class:`_schema.ForeignKey`, :class:`_schema.CheckConstraint`,\\n     and :class:`_schema.Identity`, which are passed through to the constructed\\n     :class:`_schema.Column`.\\n    :param nullable: Optional bool, whether the column should be \"NULL\" or\\n     \"NOT NULL\". If omitted, the nullability is derived from the type\\n     annotation based on whether or not ``typing.Optional`` is present.\\n     ``nullable`` defaults to ``True`` otherwise for non-primary key columns,\\n     and ``False`` for primary key columns.\\n    :param primary_key: optional bool, indicates the :class:`_schema.Column`\\n     would be part of the table\\'s primary key or not.\\n    :param deferred: Optional bool - this keyword argument is consumed by the\\n     ORM declarative process, and is not part of the :class:`_schema.Column`\\n     itself; instead, it indicates that this column should be \"deferred\" for\\n     loading as though mapped by :func:`_orm.deferred`.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_declarative`\\n\\n    :param deferred_group: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.group` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_group`\\n\\n    :param deferred_raiseload: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.raiseload` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param use_existing_column: if True, will attempt to locate the given\\n     column name on an inherited superclass (typically single inheriting\\n     superclass), and if present, will not produce a new column, mapping\\n     to the superclass column as though it were omitted from this class.\\n     This is used for mixins that add new columns to an inherited superclass.\\n\\n     .. seealso::\\n\\n        :ref:`orm_inheritance_column_conflicts`\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter if the\\n     :paramref:`_orm.mapped_column.insert_default` parameter is not present.\\n     Additionally, when used with :ref:`orm_declarative_native_dataclasses`,\\n     indicates a default Python value that should be applied to the keyword\\n     constructor within the generated ``__init__()`` method.\\n\\n     Note that in the case of dataclass generation when\\n     :paramref:`_orm.mapped_column.insert_default` is not present, this means\\n     the :paramref:`_orm.mapped_column.default` value is used in **two**\\n     places, both the ``__init__()`` method as well as the\\n     :paramref:`_schema.Column.default` parameter. While this behavior may\\n     change in a future release, for the moment this tends to \"work out\"; a\\n     default of ``None`` will mean that the :class:`_schema.Column` gets no\\n     default generator, whereas a default that refers to a non-``None`` Python\\n     or SQL expression value will be assigned up front on the object when\\n     ``__init__()`` is called, which is the same value that the Core\\n     :class:`_sql.Insert` construct would use in any case, leading to the same\\n     end result.\\n\\n     .. note:: When using Core level column defaults that are callables to\\n        be interpreted by the underlying :class:`_schema.Column` in conjunction\\n        with :ref:`ORM-mapped dataclasses\\n        <orm_declarative_native_dataclasses>`, especially those that are\\n        :ref:`context-aware default functions <context_default_functions>`,\\n        **the** :paramref:`_orm.mapped_column.insert_default` **parameter must\\n        be used instead**.  This is necessary to disambiguate the callable from\\n        being interpreted as a dataclass level default.\\n\\n    :param insert_default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter; will supersede the value\\n     of :paramref:`_orm.mapped_column.default` when present, however\\n     :paramref:`_orm.mapped_column.default` will always apply to the\\n     constructor default for a dataclasses mapping.\\n\\n    :param sort_order: An integer that indicates how this mapped column\\n     should be sorted compared to the others when the ORM is creating a\\n     :class:`_schema.Table`. Among mapped columns that have the same\\n     value the default ordering is used, placing first the mapped columns\\n     defined in the main class, then the ones in the super classes.\\n     Defaults to 0. The sort is ascending.\\n\\n     .. versionadded:: 2.0.4\\n\\n    :param active_history=False:\\n\\n        When ``True``, indicates that the \"previous\" value for a\\n        scalar attribute should be loaded when replaced, if not\\n        already loaded. Normally, history tracking logic for\\n        simple non-primary-key scalar values only needs to be\\n        aware of the \"new\" value in order to perform a flush. This\\n        flag is available for applications that make use of\\n        :func:`.attributes.get_history` or :meth:`.Session.is_modified`\\n        which also need to know the \"previous\" value of the attribute.\\n\\n        .. versionadded:: 2.0.10\\n\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    :param \\\\**kw: All remaining keyword arguments are passed through to the\\n     constructor for the :class:`_schema.Column`.\\n\\n    '\n    return MappedColumn(__name_pos, __type_pos, *args, name=name, type_=type_, autoincrement=autoincrement, insert_default=insert_default, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, key=key, index=index, unique=unique, info=info, active_history=active_history, nullable=nullable, onupdate=onupdate, primary_key=primary_key, server_default=server_default, server_onupdate=server_onupdate, use_existing_column=use_existing_column, quote=quote, comment=comment, system=system, deferred=deferred, deferred_group=deferred_group, deferred_raiseload=deferred_raiseload, sort_order=sort_order, **kw)",
            "def mapped_column(__name_pos: Optional[Union[str, _TypeEngineArgument[Any], SchemaEventTarget]]=None, __type_pos: Optional[Union[_TypeEngineArgument[Any], SchemaEventTarget]]=None, /, *args: SchemaEventTarget, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, nullable: Optional[Union[bool, Literal[SchemaConst.NULL_UNSPECIFIED]]]=SchemaConst.NULL_UNSPECIFIED, primary_key: Optional[bool]=False, deferred: Union[_NoArg, bool]=_NoArg.NO_ARG, deferred_group: Optional[str]=None, deferred_raiseload: Optional[bool]=None, use_existing_column: bool=False, name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, autoincrement: _AutoIncrementType='auto', doc: Optional[str]=None, key: Optional[str]=None, index: Optional[bool]=None, unique: Optional[bool]=None, info: Optional[_InfoType]=None, onupdate: Optional[Any]=None, insert_default: Optional[Any]=_NoArg.NO_ARG, server_default: Optional[_ServerDefaultArgument]=None, server_onupdate: Optional[FetchedValue]=None, active_history: bool=False, quote: Optional[bool]=None, system: bool=False, comment: Optional[str]=None, sort_order: Union[_NoArg, int]=_NoArg.NO_ARG, **kw: Any) -> MappedColumn[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'declare a new ORM-mapped :class:`_schema.Column` construct\\n    for use within :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    The :func:`_orm.mapped_column` function provides an ORM-aware and\\n    Python-typing-compatible construct which is used with\\n    :ref:`declarative <orm_declarative_mapping>` mappings to indicate an\\n    attribute that\\'s mapped to a Core :class:`_schema.Column` object.  It\\n    provides the equivalent feature as mapping an attribute to a\\n    :class:`_schema.Column` object directly when using Declarative,\\n    specifically when using :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    .. versionadded:: 2.0\\n\\n    :func:`_orm.mapped_column` is normally used with explicit typing along with\\n    the :class:`_orm.Mapped` annotation type, where it can derive the SQL\\n    type and nullability for the column based on what\\'s present within the\\n    :class:`_orm.Mapped` annotation.   It also may be used without annotations\\n    as a drop-in replacement for how :class:`_schema.Column` is used in\\n    Declarative mappings in SQLAlchemy 1.x style.\\n\\n    For usage examples of :func:`_orm.mapped_column`, see the documentation\\n    at :ref:`orm_declarative_table`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_declarative_table` - complete documentation\\n\\n        :ref:`whatsnew_20_orm_declarative_typing` - migration notes for\\n        Declarative mappings using 1.x style mappings\\n\\n    :param __name: String name to give to the :class:`_schema.Column`.  This\\n     is an optional, positional only argument that if present must be the\\n     first positional argument passed.  If omitted, the attribute name to\\n     which the :func:`_orm.mapped_column`  is mapped will be used as the SQL\\n     column name.\\n    :param __type: :class:`_types.TypeEngine` type or instance which will\\n     indicate the datatype to be associated with the :class:`_schema.Column`.\\n     This is an optional, positional-only argument that if present must\\n     immediately follow the ``__name`` parameter if present also, or otherwise\\n     be the first positional parameter.  If omitted, the ultimate type for\\n     the column may be derived either from the annotated type, or if a\\n     :class:`_schema.ForeignKey` is present, from the datatype of the\\n     referenced column.\\n    :param \\\\*args: Additional positional arguments include constructs such\\n     as :class:`_schema.ForeignKey`, :class:`_schema.CheckConstraint`,\\n     and :class:`_schema.Identity`, which are passed through to the constructed\\n     :class:`_schema.Column`.\\n    :param nullable: Optional bool, whether the column should be \"NULL\" or\\n     \"NOT NULL\". If omitted, the nullability is derived from the type\\n     annotation based on whether or not ``typing.Optional`` is present.\\n     ``nullable`` defaults to ``True`` otherwise for non-primary key columns,\\n     and ``False`` for primary key columns.\\n    :param primary_key: optional bool, indicates the :class:`_schema.Column`\\n     would be part of the table\\'s primary key or not.\\n    :param deferred: Optional bool - this keyword argument is consumed by the\\n     ORM declarative process, and is not part of the :class:`_schema.Column`\\n     itself; instead, it indicates that this column should be \"deferred\" for\\n     loading as though mapped by :func:`_orm.deferred`.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_declarative`\\n\\n    :param deferred_group: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.group` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_group`\\n\\n    :param deferred_raiseload: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.raiseload` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param use_existing_column: if True, will attempt to locate the given\\n     column name on an inherited superclass (typically single inheriting\\n     superclass), and if present, will not produce a new column, mapping\\n     to the superclass column as though it were omitted from this class.\\n     This is used for mixins that add new columns to an inherited superclass.\\n\\n     .. seealso::\\n\\n        :ref:`orm_inheritance_column_conflicts`\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter if the\\n     :paramref:`_orm.mapped_column.insert_default` parameter is not present.\\n     Additionally, when used with :ref:`orm_declarative_native_dataclasses`,\\n     indicates a default Python value that should be applied to the keyword\\n     constructor within the generated ``__init__()`` method.\\n\\n     Note that in the case of dataclass generation when\\n     :paramref:`_orm.mapped_column.insert_default` is not present, this means\\n     the :paramref:`_orm.mapped_column.default` value is used in **two**\\n     places, both the ``__init__()`` method as well as the\\n     :paramref:`_schema.Column.default` parameter. While this behavior may\\n     change in a future release, for the moment this tends to \"work out\"; a\\n     default of ``None`` will mean that the :class:`_schema.Column` gets no\\n     default generator, whereas a default that refers to a non-``None`` Python\\n     or SQL expression value will be assigned up front on the object when\\n     ``__init__()`` is called, which is the same value that the Core\\n     :class:`_sql.Insert` construct would use in any case, leading to the same\\n     end result.\\n\\n     .. note:: When using Core level column defaults that are callables to\\n        be interpreted by the underlying :class:`_schema.Column` in conjunction\\n        with :ref:`ORM-mapped dataclasses\\n        <orm_declarative_native_dataclasses>`, especially those that are\\n        :ref:`context-aware default functions <context_default_functions>`,\\n        **the** :paramref:`_orm.mapped_column.insert_default` **parameter must\\n        be used instead**.  This is necessary to disambiguate the callable from\\n        being interpreted as a dataclass level default.\\n\\n    :param insert_default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter; will supersede the value\\n     of :paramref:`_orm.mapped_column.default` when present, however\\n     :paramref:`_orm.mapped_column.default` will always apply to the\\n     constructor default for a dataclasses mapping.\\n\\n    :param sort_order: An integer that indicates how this mapped column\\n     should be sorted compared to the others when the ORM is creating a\\n     :class:`_schema.Table`. Among mapped columns that have the same\\n     value the default ordering is used, placing first the mapped columns\\n     defined in the main class, then the ones in the super classes.\\n     Defaults to 0. The sort is ascending.\\n\\n     .. versionadded:: 2.0.4\\n\\n    :param active_history=False:\\n\\n        When ``True``, indicates that the \"previous\" value for a\\n        scalar attribute should be loaded when replaced, if not\\n        already loaded. Normally, history tracking logic for\\n        simple non-primary-key scalar values only needs to be\\n        aware of the \"new\" value in order to perform a flush. This\\n        flag is available for applications that make use of\\n        :func:`.attributes.get_history` or :meth:`.Session.is_modified`\\n        which also need to know the \"previous\" value of the attribute.\\n\\n        .. versionadded:: 2.0.10\\n\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    :param \\\\**kw: All remaining keyword arguments are passed through to the\\n     constructor for the :class:`_schema.Column`.\\n\\n    '\n    return MappedColumn(__name_pos, __type_pos, *args, name=name, type_=type_, autoincrement=autoincrement, insert_default=insert_default, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, key=key, index=index, unique=unique, info=info, active_history=active_history, nullable=nullable, onupdate=onupdate, primary_key=primary_key, server_default=server_default, server_onupdate=server_onupdate, use_existing_column=use_existing_column, quote=quote, comment=comment, system=system, deferred=deferred, deferred_group=deferred_group, deferred_raiseload=deferred_raiseload, sort_order=sort_order, **kw)",
            "def mapped_column(__name_pos: Optional[Union[str, _TypeEngineArgument[Any], SchemaEventTarget]]=None, __type_pos: Optional[Union[_TypeEngineArgument[Any], SchemaEventTarget]]=None, /, *args: SchemaEventTarget, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, nullable: Optional[Union[bool, Literal[SchemaConst.NULL_UNSPECIFIED]]]=SchemaConst.NULL_UNSPECIFIED, primary_key: Optional[bool]=False, deferred: Union[_NoArg, bool]=_NoArg.NO_ARG, deferred_group: Optional[str]=None, deferred_raiseload: Optional[bool]=None, use_existing_column: bool=False, name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, autoincrement: _AutoIncrementType='auto', doc: Optional[str]=None, key: Optional[str]=None, index: Optional[bool]=None, unique: Optional[bool]=None, info: Optional[_InfoType]=None, onupdate: Optional[Any]=None, insert_default: Optional[Any]=_NoArg.NO_ARG, server_default: Optional[_ServerDefaultArgument]=None, server_onupdate: Optional[FetchedValue]=None, active_history: bool=False, quote: Optional[bool]=None, system: bool=False, comment: Optional[str]=None, sort_order: Union[_NoArg, int]=_NoArg.NO_ARG, **kw: Any) -> MappedColumn[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'declare a new ORM-mapped :class:`_schema.Column` construct\\n    for use within :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    The :func:`_orm.mapped_column` function provides an ORM-aware and\\n    Python-typing-compatible construct which is used with\\n    :ref:`declarative <orm_declarative_mapping>` mappings to indicate an\\n    attribute that\\'s mapped to a Core :class:`_schema.Column` object.  It\\n    provides the equivalent feature as mapping an attribute to a\\n    :class:`_schema.Column` object directly when using Declarative,\\n    specifically when using :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    .. versionadded:: 2.0\\n\\n    :func:`_orm.mapped_column` is normally used with explicit typing along with\\n    the :class:`_orm.Mapped` annotation type, where it can derive the SQL\\n    type and nullability for the column based on what\\'s present within the\\n    :class:`_orm.Mapped` annotation.   It also may be used without annotations\\n    as a drop-in replacement for how :class:`_schema.Column` is used in\\n    Declarative mappings in SQLAlchemy 1.x style.\\n\\n    For usage examples of :func:`_orm.mapped_column`, see the documentation\\n    at :ref:`orm_declarative_table`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_declarative_table` - complete documentation\\n\\n        :ref:`whatsnew_20_orm_declarative_typing` - migration notes for\\n        Declarative mappings using 1.x style mappings\\n\\n    :param __name: String name to give to the :class:`_schema.Column`.  This\\n     is an optional, positional only argument that if present must be the\\n     first positional argument passed.  If omitted, the attribute name to\\n     which the :func:`_orm.mapped_column`  is mapped will be used as the SQL\\n     column name.\\n    :param __type: :class:`_types.TypeEngine` type or instance which will\\n     indicate the datatype to be associated with the :class:`_schema.Column`.\\n     This is an optional, positional-only argument that if present must\\n     immediately follow the ``__name`` parameter if present also, or otherwise\\n     be the first positional parameter.  If omitted, the ultimate type for\\n     the column may be derived either from the annotated type, or if a\\n     :class:`_schema.ForeignKey` is present, from the datatype of the\\n     referenced column.\\n    :param \\\\*args: Additional positional arguments include constructs such\\n     as :class:`_schema.ForeignKey`, :class:`_schema.CheckConstraint`,\\n     and :class:`_schema.Identity`, which are passed through to the constructed\\n     :class:`_schema.Column`.\\n    :param nullable: Optional bool, whether the column should be \"NULL\" or\\n     \"NOT NULL\". If omitted, the nullability is derived from the type\\n     annotation based on whether or not ``typing.Optional`` is present.\\n     ``nullable`` defaults to ``True`` otherwise for non-primary key columns,\\n     and ``False`` for primary key columns.\\n    :param primary_key: optional bool, indicates the :class:`_schema.Column`\\n     would be part of the table\\'s primary key or not.\\n    :param deferred: Optional bool - this keyword argument is consumed by the\\n     ORM declarative process, and is not part of the :class:`_schema.Column`\\n     itself; instead, it indicates that this column should be \"deferred\" for\\n     loading as though mapped by :func:`_orm.deferred`.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_declarative`\\n\\n    :param deferred_group: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.group` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_group`\\n\\n    :param deferred_raiseload: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.raiseload` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param use_existing_column: if True, will attempt to locate the given\\n     column name on an inherited superclass (typically single inheriting\\n     superclass), and if present, will not produce a new column, mapping\\n     to the superclass column as though it were omitted from this class.\\n     This is used for mixins that add new columns to an inherited superclass.\\n\\n     .. seealso::\\n\\n        :ref:`orm_inheritance_column_conflicts`\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter if the\\n     :paramref:`_orm.mapped_column.insert_default` parameter is not present.\\n     Additionally, when used with :ref:`orm_declarative_native_dataclasses`,\\n     indicates a default Python value that should be applied to the keyword\\n     constructor within the generated ``__init__()`` method.\\n\\n     Note that in the case of dataclass generation when\\n     :paramref:`_orm.mapped_column.insert_default` is not present, this means\\n     the :paramref:`_orm.mapped_column.default` value is used in **two**\\n     places, both the ``__init__()`` method as well as the\\n     :paramref:`_schema.Column.default` parameter. While this behavior may\\n     change in a future release, for the moment this tends to \"work out\"; a\\n     default of ``None`` will mean that the :class:`_schema.Column` gets no\\n     default generator, whereas a default that refers to a non-``None`` Python\\n     or SQL expression value will be assigned up front on the object when\\n     ``__init__()`` is called, which is the same value that the Core\\n     :class:`_sql.Insert` construct would use in any case, leading to the same\\n     end result.\\n\\n     .. note:: When using Core level column defaults that are callables to\\n        be interpreted by the underlying :class:`_schema.Column` in conjunction\\n        with :ref:`ORM-mapped dataclasses\\n        <orm_declarative_native_dataclasses>`, especially those that are\\n        :ref:`context-aware default functions <context_default_functions>`,\\n        **the** :paramref:`_orm.mapped_column.insert_default` **parameter must\\n        be used instead**.  This is necessary to disambiguate the callable from\\n        being interpreted as a dataclass level default.\\n\\n    :param insert_default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter; will supersede the value\\n     of :paramref:`_orm.mapped_column.default` when present, however\\n     :paramref:`_orm.mapped_column.default` will always apply to the\\n     constructor default for a dataclasses mapping.\\n\\n    :param sort_order: An integer that indicates how this mapped column\\n     should be sorted compared to the others when the ORM is creating a\\n     :class:`_schema.Table`. Among mapped columns that have the same\\n     value the default ordering is used, placing first the mapped columns\\n     defined in the main class, then the ones in the super classes.\\n     Defaults to 0. The sort is ascending.\\n\\n     .. versionadded:: 2.0.4\\n\\n    :param active_history=False:\\n\\n        When ``True``, indicates that the \"previous\" value for a\\n        scalar attribute should be loaded when replaced, if not\\n        already loaded. Normally, history tracking logic for\\n        simple non-primary-key scalar values only needs to be\\n        aware of the \"new\" value in order to perform a flush. This\\n        flag is available for applications that make use of\\n        :func:`.attributes.get_history` or :meth:`.Session.is_modified`\\n        which also need to know the \"previous\" value of the attribute.\\n\\n        .. versionadded:: 2.0.10\\n\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    :param \\\\**kw: All remaining keyword arguments are passed through to the\\n     constructor for the :class:`_schema.Column`.\\n\\n    '\n    return MappedColumn(__name_pos, __type_pos, *args, name=name, type_=type_, autoincrement=autoincrement, insert_default=insert_default, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, key=key, index=index, unique=unique, info=info, active_history=active_history, nullable=nullable, onupdate=onupdate, primary_key=primary_key, server_default=server_default, server_onupdate=server_onupdate, use_existing_column=use_existing_column, quote=quote, comment=comment, system=system, deferred=deferred, deferred_group=deferred_group, deferred_raiseload=deferred_raiseload, sort_order=sort_order, **kw)",
            "def mapped_column(__name_pos: Optional[Union[str, _TypeEngineArgument[Any], SchemaEventTarget]]=None, __type_pos: Optional[Union[_TypeEngineArgument[Any], SchemaEventTarget]]=None, /, *args: SchemaEventTarget, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, nullable: Optional[Union[bool, Literal[SchemaConst.NULL_UNSPECIFIED]]]=SchemaConst.NULL_UNSPECIFIED, primary_key: Optional[bool]=False, deferred: Union[_NoArg, bool]=_NoArg.NO_ARG, deferred_group: Optional[str]=None, deferred_raiseload: Optional[bool]=None, use_existing_column: bool=False, name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, autoincrement: _AutoIncrementType='auto', doc: Optional[str]=None, key: Optional[str]=None, index: Optional[bool]=None, unique: Optional[bool]=None, info: Optional[_InfoType]=None, onupdate: Optional[Any]=None, insert_default: Optional[Any]=_NoArg.NO_ARG, server_default: Optional[_ServerDefaultArgument]=None, server_onupdate: Optional[FetchedValue]=None, active_history: bool=False, quote: Optional[bool]=None, system: bool=False, comment: Optional[str]=None, sort_order: Union[_NoArg, int]=_NoArg.NO_ARG, **kw: Any) -> MappedColumn[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'declare a new ORM-mapped :class:`_schema.Column` construct\\n    for use within :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    The :func:`_orm.mapped_column` function provides an ORM-aware and\\n    Python-typing-compatible construct which is used with\\n    :ref:`declarative <orm_declarative_mapping>` mappings to indicate an\\n    attribute that\\'s mapped to a Core :class:`_schema.Column` object.  It\\n    provides the equivalent feature as mapping an attribute to a\\n    :class:`_schema.Column` object directly when using Declarative,\\n    specifically when using :ref:`Declarative Table <orm_declarative_table>`\\n    configuration.\\n\\n    .. versionadded:: 2.0\\n\\n    :func:`_orm.mapped_column` is normally used with explicit typing along with\\n    the :class:`_orm.Mapped` annotation type, where it can derive the SQL\\n    type and nullability for the column based on what\\'s present within the\\n    :class:`_orm.Mapped` annotation.   It also may be used without annotations\\n    as a drop-in replacement for how :class:`_schema.Column` is used in\\n    Declarative mappings in SQLAlchemy 1.x style.\\n\\n    For usage examples of :func:`_orm.mapped_column`, see the documentation\\n    at :ref:`orm_declarative_table`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_declarative_table` - complete documentation\\n\\n        :ref:`whatsnew_20_orm_declarative_typing` - migration notes for\\n        Declarative mappings using 1.x style mappings\\n\\n    :param __name: String name to give to the :class:`_schema.Column`.  This\\n     is an optional, positional only argument that if present must be the\\n     first positional argument passed.  If omitted, the attribute name to\\n     which the :func:`_orm.mapped_column`  is mapped will be used as the SQL\\n     column name.\\n    :param __type: :class:`_types.TypeEngine` type or instance which will\\n     indicate the datatype to be associated with the :class:`_schema.Column`.\\n     This is an optional, positional-only argument that if present must\\n     immediately follow the ``__name`` parameter if present also, or otherwise\\n     be the first positional parameter.  If omitted, the ultimate type for\\n     the column may be derived either from the annotated type, or if a\\n     :class:`_schema.ForeignKey` is present, from the datatype of the\\n     referenced column.\\n    :param \\\\*args: Additional positional arguments include constructs such\\n     as :class:`_schema.ForeignKey`, :class:`_schema.CheckConstraint`,\\n     and :class:`_schema.Identity`, which are passed through to the constructed\\n     :class:`_schema.Column`.\\n    :param nullable: Optional bool, whether the column should be \"NULL\" or\\n     \"NOT NULL\". If omitted, the nullability is derived from the type\\n     annotation based on whether or not ``typing.Optional`` is present.\\n     ``nullable`` defaults to ``True`` otherwise for non-primary key columns,\\n     and ``False`` for primary key columns.\\n    :param primary_key: optional bool, indicates the :class:`_schema.Column`\\n     would be part of the table\\'s primary key or not.\\n    :param deferred: Optional bool - this keyword argument is consumed by the\\n     ORM declarative process, and is not part of the :class:`_schema.Column`\\n     itself; instead, it indicates that this column should be \"deferred\" for\\n     loading as though mapped by :func:`_orm.deferred`.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_declarative`\\n\\n    :param deferred_group: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.group` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_group`\\n\\n    :param deferred_raiseload: Implies :paramref:`_orm.mapped_column.deferred`\\n     to ``True``, and set the :paramref:`_orm.deferred.raiseload` parameter.\\n\\n     .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param use_existing_column: if True, will attempt to locate the given\\n     column name on an inherited superclass (typically single inheriting\\n     superclass), and if present, will not produce a new column, mapping\\n     to the superclass column as though it were omitted from this class.\\n     This is used for mixins that add new columns to an inherited superclass.\\n\\n     .. seealso::\\n\\n        :ref:`orm_inheritance_column_conflicts`\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter if the\\n     :paramref:`_orm.mapped_column.insert_default` parameter is not present.\\n     Additionally, when used with :ref:`orm_declarative_native_dataclasses`,\\n     indicates a default Python value that should be applied to the keyword\\n     constructor within the generated ``__init__()`` method.\\n\\n     Note that in the case of dataclass generation when\\n     :paramref:`_orm.mapped_column.insert_default` is not present, this means\\n     the :paramref:`_orm.mapped_column.default` value is used in **two**\\n     places, both the ``__init__()`` method as well as the\\n     :paramref:`_schema.Column.default` parameter. While this behavior may\\n     change in a future release, for the moment this tends to \"work out\"; a\\n     default of ``None`` will mean that the :class:`_schema.Column` gets no\\n     default generator, whereas a default that refers to a non-``None`` Python\\n     or SQL expression value will be assigned up front on the object when\\n     ``__init__()`` is called, which is the same value that the Core\\n     :class:`_sql.Insert` construct would use in any case, leading to the same\\n     end result.\\n\\n     .. note:: When using Core level column defaults that are callables to\\n        be interpreted by the underlying :class:`_schema.Column` in conjunction\\n        with :ref:`ORM-mapped dataclasses\\n        <orm_declarative_native_dataclasses>`, especially those that are\\n        :ref:`context-aware default functions <context_default_functions>`,\\n        **the** :paramref:`_orm.mapped_column.insert_default` **parameter must\\n        be used instead**.  This is necessary to disambiguate the callable from\\n        being interpreted as a dataclass level default.\\n\\n    :param insert_default: Passed directly to the\\n     :paramref:`_schema.Column.default` parameter; will supersede the value\\n     of :paramref:`_orm.mapped_column.default` when present, however\\n     :paramref:`_orm.mapped_column.default` will always apply to the\\n     constructor default for a dataclasses mapping.\\n\\n    :param sort_order: An integer that indicates how this mapped column\\n     should be sorted compared to the others when the ORM is creating a\\n     :class:`_schema.Table`. Among mapped columns that have the same\\n     value the default ordering is used, placing first the mapped columns\\n     defined in the main class, then the ones in the super classes.\\n     Defaults to 0. The sort is ascending.\\n\\n     .. versionadded:: 2.0.4\\n\\n    :param active_history=False:\\n\\n        When ``True``, indicates that the \"previous\" value for a\\n        scalar attribute should be loaded when replaced, if not\\n        already loaded. Normally, history tracking logic for\\n        simple non-primary-key scalar values only needs to be\\n        aware of the \"new\" value in order to perform a flush. This\\n        flag is available for applications that make use of\\n        :func:`.attributes.get_history` or :meth:`.Session.is_modified`\\n        which also need to know the \"previous\" value of the attribute.\\n\\n        .. versionadded:: 2.0.10\\n\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    :param \\\\**kw: All remaining keyword arguments are passed through to the\\n     constructor for the :class:`_schema.Column`.\\n\\n    '\n    return MappedColumn(__name_pos, __type_pos, *args, name=name, type_=type_, autoincrement=autoincrement, insert_default=insert_default, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, key=key, index=index, unique=unique, info=info, active_history=active_history, nullable=nullable, onupdate=onupdate, primary_key=primary_key, server_default=server_default, server_onupdate=server_onupdate, use_existing_column=use_existing_column, quote=quote, comment=comment, system=system, deferred=deferred, deferred_group=deferred_group, deferred_raiseload=deferred_raiseload, sort_order=sort_order, **kw)"
        ]
    },
    {
        "func_name": "orm_insert_sentinel",
        "original": "def orm_insert_sentinel(name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, *, default: Optional[Any]=None, omit_from_statements: bool=True) -> MappedColumn[Any]:\n    \"\"\"Provides a surrogate :func:`_orm.mapped_column` that generates\n    a so-called :term:`sentinel` column, allowing efficient bulk\n    inserts with deterministic RETURNING sorting for tables that don't\n    otherwise have qualifying primary key configurations.\n\n    Use of :func:`_orm.orm_insert_sentinel` is analogous to the use of the\n    :func:`_schema.insert_sentinel` construct within a Core\n    :class:`_schema.Table` construct.\n\n    Guidelines for adding this construct to a Declarative mapped class\n    are the same as that of the :func:`_schema.insert_sentinel` construct;\n    the database table itself also needs to have a column with this name\n    present.\n\n    For background on how this object is used, see the section\n    :ref:`engine_insertmanyvalues_sentinel_columns` as part of the\n    section :ref:`engine_insertmanyvalues`.\n\n    .. seealso::\n\n        :func:`_schema.insert_sentinel`\n\n        :ref:`engine_insertmanyvalues`\n\n        :ref:`engine_insertmanyvalues_sentinel_columns`\n\n\n    .. versionadded:: 2.0.10\n\n    \"\"\"\n    return mapped_column(name=name, default=default if default is not None else _InsertSentinelColumnDefault(), _omit_from_statements=omit_from_statements, insert_sentinel=True, use_existing_column=True, nullable=True)",
        "mutated": [
            "def orm_insert_sentinel(name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, *, default: Optional[Any]=None, omit_from_statements: bool=True) -> MappedColumn[Any]:\n    if False:\n        i = 10\n    \"Provides a surrogate :func:`_orm.mapped_column` that generates\\n    a so-called :term:`sentinel` column, allowing efficient bulk\\n    inserts with deterministic RETURNING sorting for tables that don't\\n    otherwise have qualifying primary key configurations.\\n\\n    Use of :func:`_orm.orm_insert_sentinel` is analogous to the use of the\\n    :func:`_schema.insert_sentinel` construct within a Core\\n    :class:`_schema.Table` construct.\\n\\n    Guidelines for adding this construct to a Declarative mapped class\\n    are the same as that of the :func:`_schema.insert_sentinel` construct;\\n    the database table itself also needs to have a column with this name\\n    present.\\n\\n    For background on how this object is used, see the section\\n    :ref:`engine_insertmanyvalues_sentinel_columns` as part of the\\n    section :ref:`engine_insertmanyvalues`.\\n\\n    .. seealso::\\n\\n        :func:`_schema.insert_sentinel`\\n\\n        :ref:`engine_insertmanyvalues`\\n\\n        :ref:`engine_insertmanyvalues_sentinel_columns`\\n\\n\\n    .. versionadded:: 2.0.10\\n\\n    \"\n    return mapped_column(name=name, default=default if default is not None else _InsertSentinelColumnDefault(), _omit_from_statements=omit_from_statements, insert_sentinel=True, use_existing_column=True, nullable=True)",
            "def orm_insert_sentinel(name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, *, default: Optional[Any]=None, omit_from_statements: bool=True) -> MappedColumn[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Provides a surrogate :func:`_orm.mapped_column` that generates\\n    a so-called :term:`sentinel` column, allowing efficient bulk\\n    inserts with deterministic RETURNING sorting for tables that don't\\n    otherwise have qualifying primary key configurations.\\n\\n    Use of :func:`_orm.orm_insert_sentinel` is analogous to the use of the\\n    :func:`_schema.insert_sentinel` construct within a Core\\n    :class:`_schema.Table` construct.\\n\\n    Guidelines for adding this construct to a Declarative mapped class\\n    are the same as that of the :func:`_schema.insert_sentinel` construct;\\n    the database table itself also needs to have a column with this name\\n    present.\\n\\n    For background on how this object is used, see the section\\n    :ref:`engine_insertmanyvalues_sentinel_columns` as part of the\\n    section :ref:`engine_insertmanyvalues`.\\n\\n    .. seealso::\\n\\n        :func:`_schema.insert_sentinel`\\n\\n        :ref:`engine_insertmanyvalues`\\n\\n        :ref:`engine_insertmanyvalues_sentinel_columns`\\n\\n\\n    .. versionadded:: 2.0.10\\n\\n    \"\n    return mapped_column(name=name, default=default if default is not None else _InsertSentinelColumnDefault(), _omit_from_statements=omit_from_statements, insert_sentinel=True, use_existing_column=True, nullable=True)",
            "def orm_insert_sentinel(name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, *, default: Optional[Any]=None, omit_from_statements: bool=True) -> MappedColumn[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Provides a surrogate :func:`_orm.mapped_column` that generates\\n    a so-called :term:`sentinel` column, allowing efficient bulk\\n    inserts with deterministic RETURNING sorting for tables that don't\\n    otherwise have qualifying primary key configurations.\\n\\n    Use of :func:`_orm.orm_insert_sentinel` is analogous to the use of the\\n    :func:`_schema.insert_sentinel` construct within a Core\\n    :class:`_schema.Table` construct.\\n\\n    Guidelines for adding this construct to a Declarative mapped class\\n    are the same as that of the :func:`_schema.insert_sentinel` construct;\\n    the database table itself also needs to have a column with this name\\n    present.\\n\\n    For background on how this object is used, see the section\\n    :ref:`engine_insertmanyvalues_sentinel_columns` as part of the\\n    section :ref:`engine_insertmanyvalues`.\\n\\n    .. seealso::\\n\\n        :func:`_schema.insert_sentinel`\\n\\n        :ref:`engine_insertmanyvalues`\\n\\n        :ref:`engine_insertmanyvalues_sentinel_columns`\\n\\n\\n    .. versionadded:: 2.0.10\\n\\n    \"\n    return mapped_column(name=name, default=default if default is not None else _InsertSentinelColumnDefault(), _omit_from_statements=omit_from_statements, insert_sentinel=True, use_existing_column=True, nullable=True)",
            "def orm_insert_sentinel(name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, *, default: Optional[Any]=None, omit_from_statements: bool=True) -> MappedColumn[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Provides a surrogate :func:`_orm.mapped_column` that generates\\n    a so-called :term:`sentinel` column, allowing efficient bulk\\n    inserts with deterministic RETURNING sorting for tables that don't\\n    otherwise have qualifying primary key configurations.\\n\\n    Use of :func:`_orm.orm_insert_sentinel` is analogous to the use of the\\n    :func:`_schema.insert_sentinel` construct within a Core\\n    :class:`_schema.Table` construct.\\n\\n    Guidelines for adding this construct to a Declarative mapped class\\n    are the same as that of the :func:`_schema.insert_sentinel` construct;\\n    the database table itself also needs to have a column with this name\\n    present.\\n\\n    For background on how this object is used, see the section\\n    :ref:`engine_insertmanyvalues_sentinel_columns` as part of the\\n    section :ref:`engine_insertmanyvalues`.\\n\\n    .. seealso::\\n\\n        :func:`_schema.insert_sentinel`\\n\\n        :ref:`engine_insertmanyvalues`\\n\\n        :ref:`engine_insertmanyvalues_sentinel_columns`\\n\\n\\n    .. versionadded:: 2.0.10\\n\\n    \"\n    return mapped_column(name=name, default=default if default is not None else _InsertSentinelColumnDefault(), _omit_from_statements=omit_from_statements, insert_sentinel=True, use_existing_column=True, nullable=True)",
            "def orm_insert_sentinel(name: Optional[str]=None, type_: Optional[_TypeEngineArgument[Any]]=None, *, default: Optional[Any]=None, omit_from_statements: bool=True) -> MappedColumn[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Provides a surrogate :func:`_orm.mapped_column` that generates\\n    a so-called :term:`sentinel` column, allowing efficient bulk\\n    inserts with deterministic RETURNING sorting for tables that don't\\n    otherwise have qualifying primary key configurations.\\n\\n    Use of :func:`_orm.orm_insert_sentinel` is analogous to the use of the\\n    :func:`_schema.insert_sentinel` construct within a Core\\n    :class:`_schema.Table` construct.\\n\\n    Guidelines for adding this construct to a Declarative mapped class\\n    are the same as that of the :func:`_schema.insert_sentinel` construct;\\n    the database table itself also needs to have a column with this name\\n    present.\\n\\n    For background on how this object is used, see the section\\n    :ref:`engine_insertmanyvalues_sentinel_columns` as part of the\\n    section :ref:`engine_insertmanyvalues`.\\n\\n    .. seealso::\\n\\n        :func:`_schema.insert_sentinel`\\n\\n        :ref:`engine_insertmanyvalues`\\n\\n        :ref:`engine_insertmanyvalues_sentinel_columns`\\n\\n\\n    .. versionadded:: 2.0.10\\n\\n    \"\n    return mapped_column(name=name, default=default if default is not None else _InsertSentinelColumnDefault(), _omit_from_statements=omit_from_statements, insert_sentinel=True, use_existing_column=True, nullable=True)"
        ]
    },
    {
        "func_name": "column_property",
        "original": "@util.deprecated_params(**{arg: ('2.0', f'The :paramref:`_orm.column_property.{arg}` parameter is deprecated for :func:`_orm.column_property`.  This parameter applies to a writeable-attribute in a Declarative Dataclasses configuration only, and :func:`_orm.column_property` is treated as a read-only attribute in this context.') for arg in ('init', 'kw_only', 'default', 'default_factory')})\ndef column_property(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    \"\"\"Provide a column-level property for use with a mapping.\n\n    With Declarative mappings, :func:`_orm.column_property` is used to\n    map read-only SQL expressions to a mapped class.\n\n    When using Imperative mappings, :func:`_orm.column_property` also\n    takes on the role of mapping table columns with additional features.\n    When using fully Declarative mappings, the :func:`_orm.mapped_column`\n    construct should be used for this purpose.\n\n    With Declarative Dataclass mappings, :func:`_orm.column_property`\n    is considered to be **read only**, and will not be included in the\n    Dataclass ``__init__()`` constructor.\n\n    The :func:`_orm.column_property` function returns an instance of\n    :class:`.ColumnProperty`.\n\n    .. seealso::\n\n        :ref:`mapper_column_property_sql_expressions` - general use of\n        :func:`_orm.column_property` to map SQL expressions\n\n        :ref:`orm_imperative_table_column_options` - usage of\n        :func:`_orm.column_property` with Imperative Table mappings to apply\n        additional options to a plain :class:`_schema.Column` object\n\n    :param \\\\*cols:\n        list of Column objects to be mapped.\n\n    :param active_history=False:\n\n        Used only for Imperative Table mappings, or legacy-style Declarative\n        mappings (i.e. which have not been upgraded to\n        :func:`_orm.mapped_column`), for column-based attributes that are\n        expected to be writeable; use :func:`_orm.mapped_column` with\n        :paramref:`_orm.mapped_column.active_history` for Declarative mappings.\n        See that parameter for functional details.\n\n    :param comparator_factory: a class which extends\n        :class:`.ColumnProperty.Comparator` which provides custom SQL\n        clause generation for comparison operations.\n\n    :param group:\n        a group name for this property when marked as deferred.\n\n    :param deferred:\n        when True, the column property is \"deferred\", meaning that\n        it does not load immediately, and is instead loaded when the\n        attribute is first accessed on an instance.  See also\n        :func:`~sqlalchemy.orm.deferred`.\n\n    :param doc:\n        optional string that will be applied as the doc on the\n        class-bound descriptor.\n\n    :param expire_on_flush=True:\n        Disable expiry on flush.   A column_property() which refers\n        to a SQL expression (and not a single table-bound column)\n        is considered to be a \"read only\" property; populating it\n        has no effect on the state of data, and it can only return\n        database state.   For this reason a column_property()'s value\n        is expired whenever the parent object is involved in a\n        flush, that is, has any kind of \"dirty\" state within a flush.\n        Setting this parameter to ``False`` will have the effect of\n        leaving any existing value present after the flush proceeds.\n        Note that the :class:`.Session` with default expiration\n        settings still expires\n        all attributes after a :meth:`.Session.commit` call, however.\n\n    :param info: Optional data dictionary which will be populated into the\n        :attr:`.MapperProperty.info` attribute of this object.\n\n    :param raiseload: if True, indicates the column should raise an error\n        when undeferred, rather than loading the value.  This can be\n        altered at query time by using the :func:`.deferred` option with\n        raiseload=False.\n\n        .. versionadded:: 1.4\n\n        .. seealso::\n\n            :ref:`orm_queryguide_deferred_raiseload`\n\n    :param init:\n\n    :param default:\n\n    :param default_factory:\n\n    :param kw_only:\n\n    \"\"\"\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(False if init is _NoArg.NO_ARG else init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)",
        "mutated": [
            "@util.deprecated_params(**{arg: ('2.0', f'The :paramref:`_orm.column_property.{arg}` parameter is deprecated for :func:`_orm.column_property`.  This parameter applies to a writeable-attribute in a Declarative Dataclasses configuration only, and :func:`_orm.column_property` is treated as a read-only attribute in this context.') for arg in ('init', 'kw_only', 'default', 'default_factory')})\ndef column_property(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n    'Provide a column-level property for use with a mapping.\\n\\n    With Declarative mappings, :func:`_orm.column_property` is used to\\n    map read-only SQL expressions to a mapped class.\\n\\n    When using Imperative mappings, :func:`_orm.column_property` also\\n    takes on the role of mapping table columns with additional features.\\n    When using fully Declarative mappings, the :func:`_orm.mapped_column`\\n    construct should be used for this purpose.\\n\\n    With Declarative Dataclass mappings, :func:`_orm.column_property`\\n    is considered to be **read only**, and will not be included in the\\n    Dataclass ``__init__()`` constructor.\\n\\n    The :func:`_orm.column_property` function returns an instance of\\n    :class:`.ColumnProperty`.\\n\\n    .. seealso::\\n\\n        :ref:`mapper_column_property_sql_expressions` - general use of\\n        :func:`_orm.column_property` to map SQL expressions\\n\\n        :ref:`orm_imperative_table_column_options` - usage of\\n        :func:`_orm.column_property` with Imperative Table mappings to apply\\n        additional options to a plain :class:`_schema.Column` object\\n\\n    :param \\\\*cols:\\n        list of Column objects to be mapped.\\n\\n    :param active_history=False:\\n\\n        Used only for Imperative Table mappings, or legacy-style Declarative\\n        mappings (i.e. which have not been upgraded to\\n        :func:`_orm.mapped_column`), for column-based attributes that are\\n        expected to be writeable; use :func:`_orm.mapped_column` with\\n        :paramref:`_orm.mapped_column.active_history` for Declarative mappings.\\n        See that parameter for functional details.\\n\\n    :param comparator_factory: a class which extends\\n        :class:`.ColumnProperty.Comparator` which provides custom SQL\\n        clause generation for comparison operations.\\n\\n    :param group:\\n        a group name for this property when marked as deferred.\\n\\n    :param deferred:\\n        when True, the column property is \"deferred\", meaning that\\n        it does not load immediately, and is instead loaded when the\\n        attribute is first accessed on an instance.  See also\\n        :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param doc:\\n        optional string that will be applied as the doc on the\\n        class-bound descriptor.\\n\\n    :param expire_on_flush=True:\\n        Disable expiry on flush.   A column_property() which refers\\n        to a SQL expression (and not a single table-bound column)\\n        is considered to be a \"read only\" property; populating it\\n        has no effect on the state of data, and it can only return\\n        database state.   For this reason a column_property()\\'s value\\n        is expired whenever the parent object is involved in a\\n        flush, that is, has any kind of \"dirty\" state within a flush.\\n        Setting this parameter to ``False`` will have the effect of\\n        leaving any existing value present after the flush proceeds.\\n        Note that the :class:`.Session` with default expiration\\n        settings still expires\\n        all attributes after a :meth:`.Session.commit` call, however.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param raiseload: if True, indicates the column should raise an error\\n        when undeferred, rather than loading the value.  This can be\\n        altered at query time by using the :func:`.deferred` option with\\n        raiseload=False.\\n\\n        .. versionadded:: 1.4\\n\\n        .. seealso::\\n\\n            :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param init:\\n\\n    :param default:\\n\\n    :param default_factory:\\n\\n    :param kw_only:\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(False if init is _NoArg.NO_ARG else init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)",
            "@util.deprecated_params(**{arg: ('2.0', f'The :paramref:`_orm.column_property.{arg}` parameter is deprecated for :func:`_orm.column_property`.  This parameter applies to a writeable-attribute in a Declarative Dataclasses configuration only, and :func:`_orm.column_property` is treated as a read-only attribute in this context.') for arg in ('init', 'kw_only', 'default', 'default_factory')})\ndef column_property(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Provide a column-level property for use with a mapping.\\n\\n    With Declarative mappings, :func:`_orm.column_property` is used to\\n    map read-only SQL expressions to a mapped class.\\n\\n    When using Imperative mappings, :func:`_orm.column_property` also\\n    takes on the role of mapping table columns with additional features.\\n    When using fully Declarative mappings, the :func:`_orm.mapped_column`\\n    construct should be used for this purpose.\\n\\n    With Declarative Dataclass mappings, :func:`_orm.column_property`\\n    is considered to be **read only**, and will not be included in the\\n    Dataclass ``__init__()`` constructor.\\n\\n    The :func:`_orm.column_property` function returns an instance of\\n    :class:`.ColumnProperty`.\\n\\n    .. seealso::\\n\\n        :ref:`mapper_column_property_sql_expressions` - general use of\\n        :func:`_orm.column_property` to map SQL expressions\\n\\n        :ref:`orm_imperative_table_column_options` - usage of\\n        :func:`_orm.column_property` with Imperative Table mappings to apply\\n        additional options to a plain :class:`_schema.Column` object\\n\\n    :param \\\\*cols:\\n        list of Column objects to be mapped.\\n\\n    :param active_history=False:\\n\\n        Used only for Imperative Table mappings, or legacy-style Declarative\\n        mappings (i.e. which have not been upgraded to\\n        :func:`_orm.mapped_column`), for column-based attributes that are\\n        expected to be writeable; use :func:`_orm.mapped_column` with\\n        :paramref:`_orm.mapped_column.active_history` for Declarative mappings.\\n        See that parameter for functional details.\\n\\n    :param comparator_factory: a class which extends\\n        :class:`.ColumnProperty.Comparator` which provides custom SQL\\n        clause generation for comparison operations.\\n\\n    :param group:\\n        a group name for this property when marked as deferred.\\n\\n    :param deferred:\\n        when True, the column property is \"deferred\", meaning that\\n        it does not load immediately, and is instead loaded when the\\n        attribute is first accessed on an instance.  See also\\n        :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param doc:\\n        optional string that will be applied as the doc on the\\n        class-bound descriptor.\\n\\n    :param expire_on_flush=True:\\n        Disable expiry on flush.   A column_property() which refers\\n        to a SQL expression (and not a single table-bound column)\\n        is considered to be a \"read only\" property; populating it\\n        has no effect on the state of data, and it can only return\\n        database state.   For this reason a column_property()\\'s value\\n        is expired whenever the parent object is involved in a\\n        flush, that is, has any kind of \"dirty\" state within a flush.\\n        Setting this parameter to ``False`` will have the effect of\\n        leaving any existing value present after the flush proceeds.\\n        Note that the :class:`.Session` with default expiration\\n        settings still expires\\n        all attributes after a :meth:`.Session.commit` call, however.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param raiseload: if True, indicates the column should raise an error\\n        when undeferred, rather than loading the value.  This can be\\n        altered at query time by using the :func:`.deferred` option with\\n        raiseload=False.\\n\\n        .. versionadded:: 1.4\\n\\n        .. seealso::\\n\\n            :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param init:\\n\\n    :param default:\\n\\n    :param default_factory:\\n\\n    :param kw_only:\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(False if init is _NoArg.NO_ARG else init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)",
            "@util.deprecated_params(**{arg: ('2.0', f'The :paramref:`_orm.column_property.{arg}` parameter is deprecated for :func:`_orm.column_property`.  This parameter applies to a writeable-attribute in a Declarative Dataclasses configuration only, and :func:`_orm.column_property` is treated as a read-only attribute in this context.') for arg in ('init', 'kw_only', 'default', 'default_factory')})\ndef column_property(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Provide a column-level property for use with a mapping.\\n\\n    With Declarative mappings, :func:`_orm.column_property` is used to\\n    map read-only SQL expressions to a mapped class.\\n\\n    When using Imperative mappings, :func:`_orm.column_property` also\\n    takes on the role of mapping table columns with additional features.\\n    When using fully Declarative mappings, the :func:`_orm.mapped_column`\\n    construct should be used for this purpose.\\n\\n    With Declarative Dataclass mappings, :func:`_orm.column_property`\\n    is considered to be **read only**, and will not be included in the\\n    Dataclass ``__init__()`` constructor.\\n\\n    The :func:`_orm.column_property` function returns an instance of\\n    :class:`.ColumnProperty`.\\n\\n    .. seealso::\\n\\n        :ref:`mapper_column_property_sql_expressions` - general use of\\n        :func:`_orm.column_property` to map SQL expressions\\n\\n        :ref:`orm_imperative_table_column_options` - usage of\\n        :func:`_orm.column_property` with Imperative Table mappings to apply\\n        additional options to a plain :class:`_schema.Column` object\\n\\n    :param \\\\*cols:\\n        list of Column objects to be mapped.\\n\\n    :param active_history=False:\\n\\n        Used only for Imperative Table mappings, or legacy-style Declarative\\n        mappings (i.e. which have not been upgraded to\\n        :func:`_orm.mapped_column`), for column-based attributes that are\\n        expected to be writeable; use :func:`_orm.mapped_column` with\\n        :paramref:`_orm.mapped_column.active_history` for Declarative mappings.\\n        See that parameter for functional details.\\n\\n    :param comparator_factory: a class which extends\\n        :class:`.ColumnProperty.Comparator` which provides custom SQL\\n        clause generation for comparison operations.\\n\\n    :param group:\\n        a group name for this property when marked as deferred.\\n\\n    :param deferred:\\n        when True, the column property is \"deferred\", meaning that\\n        it does not load immediately, and is instead loaded when the\\n        attribute is first accessed on an instance.  See also\\n        :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param doc:\\n        optional string that will be applied as the doc on the\\n        class-bound descriptor.\\n\\n    :param expire_on_flush=True:\\n        Disable expiry on flush.   A column_property() which refers\\n        to a SQL expression (and not a single table-bound column)\\n        is considered to be a \"read only\" property; populating it\\n        has no effect on the state of data, and it can only return\\n        database state.   For this reason a column_property()\\'s value\\n        is expired whenever the parent object is involved in a\\n        flush, that is, has any kind of \"dirty\" state within a flush.\\n        Setting this parameter to ``False`` will have the effect of\\n        leaving any existing value present after the flush proceeds.\\n        Note that the :class:`.Session` with default expiration\\n        settings still expires\\n        all attributes after a :meth:`.Session.commit` call, however.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param raiseload: if True, indicates the column should raise an error\\n        when undeferred, rather than loading the value.  This can be\\n        altered at query time by using the :func:`.deferred` option with\\n        raiseload=False.\\n\\n        .. versionadded:: 1.4\\n\\n        .. seealso::\\n\\n            :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param init:\\n\\n    :param default:\\n\\n    :param default_factory:\\n\\n    :param kw_only:\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(False if init is _NoArg.NO_ARG else init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)",
            "@util.deprecated_params(**{arg: ('2.0', f'The :paramref:`_orm.column_property.{arg}` parameter is deprecated for :func:`_orm.column_property`.  This parameter applies to a writeable-attribute in a Declarative Dataclasses configuration only, and :func:`_orm.column_property` is treated as a read-only attribute in this context.') for arg in ('init', 'kw_only', 'default', 'default_factory')})\ndef column_property(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Provide a column-level property for use with a mapping.\\n\\n    With Declarative mappings, :func:`_orm.column_property` is used to\\n    map read-only SQL expressions to a mapped class.\\n\\n    When using Imperative mappings, :func:`_orm.column_property` also\\n    takes on the role of mapping table columns with additional features.\\n    When using fully Declarative mappings, the :func:`_orm.mapped_column`\\n    construct should be used for this purpose.\\n\\n    With Declarative Dataclass mappings, :func:`_orm.column_property`\\n    is considered to be **read only**, and will not be included in the\\n    Dataclass ``__init__()`` constructor.\\n\\n    The :func:`_orm.column_property` function returns an instance of\\n    :class:`.ColumnProperty`.\\n\\n    .. seealso::\\n\\n        :ref:`mapper_column_property_sql_expressions` - general use of\\n        :func:`_orm.column_property` to map SQL expressions\\n\\n        :ref:`orm_imperative_table_column_options` - usage of\\n        :func:`_orm.column_property` with Imperative Table mappings to apply\\n        additional options to a plain :class:`_schema.Column` object\\n\\n    :param \\\\*cols:\\n        list of Column objects to be mapped.\\n\\n    :param active_history=False:\\n\\n        Used only for Imperative Table mappings, or legacy-style Declarative\\n        mappings (i.e. which have not been upgraded to\\n        :func:`_orm.mapped_column`), for column-based attributes that are\\n        expected to be writeable; use :func:`_orm.mapped_column` with\\n        :paramref:`_orm.mapped_column.active_history` for Declarative mappings.\\n        See that parameter for functional details.\\n\\n    :param comparator_factory: a class which extends\\n        :class:`.ColumnProperty.Comparator` which provides custom SQL\\n        clause generation for comparison operations.\\n\\n    :param group:\\n        a group name for this property when marked as deferred.\\n\\n    :param deferred:\\n        when True, the column property is \"deferred\", meaning that\\n        it does not load immediately, and is instead loaded when the\\n        attribute is first accessed on an instance.  See also\\n        :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param doc:\\n        optional string that will be applied as the doc on the\\n        class-bound descriptor.\\n\\n    :param expire_on_flush=True:\\n        Disable expiry on flush.   A column_property() which refers\\n        to a SQL expression (and not a single table-bound column)\\n        is considered to be a \"read only\" property; populating it\\n        has no effect on the state of data, and it can only return\\n        database state.   For this reason a column_property()\\'s value\\n        is expired whenever the parent object is involved in a\\n        flush, that is, has any kind of \"dirty\" state within a flush.\\n        Setting this parameter to ``False`` will have the effect of\\n        leaving any existing value present after the flush proceeds.\\n        Note that the :class:`.Session` with default expiration\\n        settings still expires\\n        all attributes after a :meth:`.Session.commit` call, however.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param raiseload: if True, indicates the column should raise an error\\n        when undeferred, rather than loading the value.  This can be\\n        altered at query time by using the :func:`.deferred` option with\\n        raiseload=False.\\n\\n        .. versionadded:: 1.4\\n\\n        .. seealso::\\n\\n            :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param init:\\n\\n    :param default:\\n\\n    :param default_factory:\\n\\n    :param kw_only:\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(False if init is _NoArg.NO_ARG else init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)",
            "@util.deprecated_params(**{arg: ('2.0', f'The :paramref:`_orm.column_property.{arg}` parameter is deprecated for :func:`_orm.column_property`.  This parameter applies to a writeable-attribute in a Declarative Dataclasses configuration only, and :func:`_orm.column_property` is treated as a read-only attribute in this context.') for arg in ('init', 'kw_only', 'default', 'default_factory')})\ndef column_property(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Provide a column-level property for use with a mapping.\\n\\n    With Declarative mappings, :func:`_orm.column_property` is used to\\n    map read-only SQL expressions to a mapped class.\\n\\n    When using Imperative mappings, :func:`_orm.column_property` also\\n    takes on the role of mapping table columns with additional features.\\n    When using fully Declarative mappings, the :func:`_orm.mapped_column`\\n    construct should be used for this purpose.\\n\\n    With Declarative Dataclass mappings, :func:`_orm.column_property`\\n    is considered to be **read only**, and will not be included in the\\n    Dataclass ``__init__()`` constructor.\\n\\n    The :func:`_orm.column_property` function returns an instance of\\n    :class:`.ColumnProperty`.\\n\\n    .. seealso::\\n\\n        :ref:`mapper_column_property_sql_expressions` - general use of\\n        :func:`_orm.column_property` to map SQL expressions\\n\\n        :ref:`orm_imperative_table_column_options` - usage of\\n        :func:`_orm.column_property` with Imperative Table mappings to apply\\n        additional options to a plain :class:`_schema.Column` object\\n\\n    :param \\\\*cols:\\n        list of Column objects to be mapped.\\n\\n    :param active_history=False:\\n\\n        Used only for Imperative Table mappings, or legacy-style Declarative\\n        mappings (i.e. which have not been upgraded to\\n        :func:`_orm.mapped_column`), for column-based attributes that are\\n        expected to be writeable; use :func:`_orm.mapped_column` with\\n        :paramref:`_orm.mapped_column.active_history` for Declarative mappings.\\n        See that parameter for functional details.\\n\\n    :param comparator_factory: a class which extends\\n        :class:`.ColumnProperty.Comparator` which provides custom SQL\\n        clause generation for comparison operations.\\n\\n    :param group:\\n        a group name for this property when marked as deferred.\\n\\n    :param deferred:\\n        when True, the column property is \"deferred\", meaning that\\n        it does not load immediately, and is instead loaded when the\\n        attribute is first accessed on an instance.  See also\\n        :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param doc:\\n        optional string that will be applied as the doc on the\\n        class-bound descriptor.\\n\\n    :param expire_on_flush=True:\\n        Disable expiry on flush.   A column_property() which refers\\n        to a SQL expression (and not a single table-bound column)\\n        is considered to be a \"read only\" property; populating it\\n        has no effect on the state of data, and it can only return\\n        database state.   For this reason a column_property()\\'s value\\n        is expired whenever the parent object is involved in a\\n        flush, that is, has any kind of \"dirty\" state within a flush.\\n        Setting this parameter to ``False`` will have the effect of\\n        leaving any existing value present after the flush proceeds.\\n        Note that the :class:`.Session` with default expiration\\n        settings still expires\\n        all attributes after a :meth:`.Session.commit` call, however.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param raiseload: if True, indicates the column should raise an error\\n        when undeferred, rather than loading the value.  This can be\\n        altered at query time by using the :func:`.deferred` option with\\n        raiseload=False.\\n\\n        .. versionadded:: 1.4\\n\\n        .. seealso::\\n\\n            :ref:`orm_queryguide_deferred_raiseload`\\n\\n    :param init:\\n\\n    :param default:\\n\\n    :param default_factory:\\n\\n    :param kw_only:\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(False if init is _NoArg.NO_ARG else init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)"
        ]
    },
    {
        "func_name": "composite",
        "original": "@overload\ndef composite(_class_or_attr: _CompositeAttrType[Any], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    ...",
        "mutated": [
            "@overload\ndef composite(_class_or_attr: _CompositeAttrType[Any], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef composite(_class_or_attr: _CompositeAttrType[Any], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef composite(_class_or_attr: _CompositeAttrType[Any], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef composite(_class_or_attr: _CompositeAttrType[Any], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef composite(_class_or_attr: _CompositeAttrType[Any], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "composite",
        "original": "@overload\ndef composite(_class_or_attr: Type[_CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    ...",
        "mutated": [
            "@overload\ndef composite(_class_or_attr: Type[_CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef composite(_class_or_attr: Type[_CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef composite(_class_or_attr: Type[_CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef composite(_class_or_attr: Type[_CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef composite(_class_or_attr: Type[_CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "composite",
        "original": "@overload\ndef composite(_class_or_attr: Callable[..., _CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    ...",
        "mutated": [
            "@overload\ndef composite(_class_or_attr: Callable[..., _CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef composite(_class_or_attr: Callable[..., _CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef composite(_class_or_attr: Callable[..., _CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef composite(_class_or_attr: Callable[..., _CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef composite(_class_or_attr: Callable[..., _CC], /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[_CC]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "composite",
        "original": "def composite(_class_or_attr: Union[None, Type[_CC], Callable[..., _CC], _CompositeAttrType[Any]]=None, /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    \"\"\"Return a composite column-based property for use with a Mapper.\n\n    See the mapping documentation section :ref:`mapper_composite` for a\n    full usage example.\n\n    The :class:`.MapperProperty` returned by :func:`.composite`\n    is the :class:`.Composite`.\n\n    :param class\\\\_:\n      The \"composite type\" class, or any classmethod or callable which\n      will produce a new instance of the composite object given the\n      column values in order.\n\n    :param \\\\*attrs:\n      List of elements to be mapped, which may include:\n\n      * :class:`_schema.Column` objects\n      * :func:`_orm.mapped_column` constructs\n      * string names of other attributes on the mapped class, which may be\n        any other SQL or object-mapped attribute.  This can for\n        example allow a composite that refers to a many-to-one relationship\n\n    :param active_history=False:\n      When ``True``, indicates that the \"previous\" value for a\n      scalar attribute should be loaded when replaced, if not\n      already loaded.  See the same flag on :func:`.column_property`.\n\n    :param group:\n      A group name for this property when marked as deferred.\n\n    :param deferred:\n      When True, the column property is \"deferred\", meaning that it does\n      not load immediately, and is instead loaded when the attribute is\n      first accessed on an instance.  See also\n      :func:`~sqlalchemy.orm.deferred`.\n\n    :param comparator_factory:  a class which extends\n      :class:`.Composite.Comparator` which provides custom SQL\n      clause generation for comparison operations.\n\n    :param doc:\n      optional string that will be applied as the doc on the\n      class-bound descriptor.\n\n    :param info: Optional data dictionary which will be populated into the\n        :attr:`.MapperProperty.info` attribute of this object.\n\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\n     specifies if the mapped attribute should be part of the ``__init__()``\n     method as generated by the dataclass process.\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\n     specifies if the mapped attribute should be part of the ``__repr__()``\n     method as generated by the dataclass process.\n    :param default_factory: Specific to\n     :ref:`orm_declarative_native_dataclasses`,\n     specifies a default-value generation function that will take place\n     as part of the ``__init__()``\n     method as generated by the dataclass process.\n\n    :param compare: Specific to\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\n     should be included in comparison operations when generating the\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\n\n     .. versionadded:: 2.0.0b4\n\n    :param kw_only: Specific to\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\n     should be marked as keyword-only when generating the ``__init__()``.\n\n    \"\"\"\n    if __kw:\n        raise _no_kw()\n    return Composite(_class_or_attr, *attrs, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, info=info, doc=doc)",
        "mutated": [
            "def composite(_class_or_attr: Union[None, Type[_CC], Callable[..., _CC], _CompositeAttrType[Any]]=None, /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n    'Return a composite column-based property for use with a Mapper.\\n\\n    See the mapping documentation section :ref:`mapper_composite` for a\\n    full usage example.\\n\\n    The :class:`.MapperProperty` returned by :func:`.composite`\\n    is the :class:`.Composite`.\\n\\n    :param class\\\\_:\\n      The \"composite type\" class, or any classmethod or callable which\\n      will produce a new instance of the composite object given the\\n      column values in order.\\n\\n    :param \\\\*attrs:\\n      List of elements to be mapped, which may include:\\n\\n      * :class:`_schema.Column` objects\\n      * :func:`_orm.mapped_column` constructs\\n      * string names of other attributes on the mapped class, which may be\\n        any other SQL or object-mapped attribute.  This can for\\n        example allow a composite that refers to a many-to-one relationship\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      scalar attribute should be loaded when replaced, if not\\n      already loaded.  See the same flag on :func:`.column_property`.\\n\\n    :param group:\\n      A group name for this property when marked as deferred.\\n\\n    :param deferred:\\n      When True, the column property is \"deferred\", meaning that it does\\n      not load immediately, and is instead loaded when the attribute is\\n      first accessed on an instance.  See also\\n      :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param comparator_factory:  a class which extends\\n      :class:`.Composite.Comparator` which provides custom SQL\\n      clause generation for comparison operations.\\n\\n    :param doc:\\n      optional string that will be applied as the doc on the\\n      class-bound descriptor.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    '\n    if __kw:\n        raise _no_kw()\n    return Composite(_class_or_attr, *attrs, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, info=info, doc=doc)",
            "def composite(_class_or_attr: Union[None, Type[_CC], Callable[..., _CC], _CompositeAttrType[Any]]=None, /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a composite column-based property for use with a Mapper.\\n\\n    See the mapping documentation section :ref:`mapper_composite` for a\\n    full usage example.\\n\\n    The :class:`.MapperProperty` returned by :func:`.composite`\\n    is the :class:`.Composite`.\\n\\n    :param class\\\\_:\\n      The \"composite type\" class, or any classmethod or callable which\\n      will produce a new instance of the composite object given the\\n      column values in order.\\n\\n    :param \\\\*attrs:\\n      List of elements to be mapped, which may include:\\n\\n      * :class:`_schema.Column` objects\\n      * :func:`_orm.mapped_column` constructs\\n      * string names of other attributes on the mapped class, which may be\\n        any other SQL or object-mapped attribute.  This can for\\n        example allow a composite that refers to a many-to-one relationship\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      scalar attribute should be loaded when replaced, if not\\n      already loaded.  See the same flag on :func:`.column_property`.\\n\\n    :param group:\\n      A group name for this property when marked as deferred.\\n\\n    :param deferred:\\n      When True, the column property is \"deferred\", meaning that it does\\n      not load immediately, and is instead loaded when the attribute is\\n      first accessed on an instance.  See also\\n      :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param comparator_factory:  a class which extends\\n      :class:`.Composite.Comparator` which provides custom SQL\\n      clause generation for comparison operations.\\n\\n    :param doc:\\n      optional string that will be applied as the doc on the\\n      class-bound descriptor.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    '\n    if __kw:\n        raise _no_kw()\n    return Composite(_class_or_attr, *attrs, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, info=info, doc=doc)",
            "def composite(_class_or_attr: Union[None, Type[_CC], Callable[..., _CC], _CompositeAttrType[Any]]=None, /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a composite column-based property for use with a Mapper.\\n\\n    See the mapping documentation section :ref:`mapper_composite` for a\\n    full usage example.\\n\\n    The :class:`.MapperProperty` returned by :func:`.composite`\\n    is the :class:`.Composite`.\\n\\n    :param class\\\\_:\\n      The \"composite type\" class, or any classmethod or callable which\\n      will produce a new instance of the composite object given the\\n      column values in order.\\n\\n    :param \\\\*attrs:\\n      List of elements to be mapped, which may include:\\n\\n      * :class:`_schema.Column` objects\\n      * :func:`_orm.mapped_column` constructs\\n      * string names of other attributes on the mapped class, which may be\\n        any other SQL or object-mapped attribute.  This can for\\n        example allow a composite that refers to a many-to-one relationship\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      scalar attribute should be loaded when replaced, if not\\n      already loaded.  See the same flag on :func:`.column_property`.\\n\\n    :param group:\\n      A group name for this property when marked as deferred.\\n\\n    :param deferred:\\n      When True, the column property is \"deferred\", meaning that it does\\n      not load immediately, and is instead loaded when the attribute is\\n      first accessed on an instance.  See also\\n      :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param comparator_factory:  a class which extends\\n      :class:`.Composite.Comparator` which provides custom SQL\\n      clause generation for comparison operations.\\n\\n    :param doc:\\n      optional string that will be applied as the doc on the\\n      class-bound descriptor.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    '\n    if __kw:\n        raise _no_kw()\n    return Composite(_class_or_attr, *attrs, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, info=info, doc=doc)",
            "def composite(_class_or_attr: Union[None, Type[_CC], Callable[..., _CC], _CompositeAttrType[Any]]=None, /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a composite column-based property for use with a Mapper.\\n\\n    See the mapping documentation section :ref:`mapper_composite` for a\\n    full usage example.\\n\\n    The :class:`.MapperProperty` returned by :func:`.composite`\\n    is the :class:`.Composite`.\\n\\n    :param class\\\\_:\\n      The \"composite type\" class, or any classmethod or callable which\\n      will produce a new instance of the composite object given the\\n      column values in order.\\n\\n    :param \\\\*attrs:\\n      List of elements to be mapped, which may include:\\n\\n      * :class:`_schema.Column` objects\\n      * :func:`_orm.mapped_column` constructs\\n      * string names of other attributes on the mapped class, which may be\\n        any other SQL or object-mapped attribute.  This can for\\n        example allow a composite that refers to a many-to-one relationship\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      scalar attribute should be loaded when replaced, if not\\n      already loaded.  See the same flag on :func:`.column_property`.\\n\\n    :param group:\\n      A group name for this property when marked as deferred.\\n\\n    :param deferred:\\n      When True, the column property is \"deferred\", meaning that it does\\n      not load immediately, and is instead loaded when the attribute is\\n      first accessed on an instance.  See also\\n      :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param comparator_factory:  a class which extends\\n      :class:`.Composite.Comparator` which provides custom SQL\\n      clause generation for comparison operations.\\n\\n    :param doc:\\n      optional string that will be applied as the doc on the\\n      class-bound descriptor.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    '\n    if __kw:\n        raise _no_kw()\n    return Composite(_class_or_attr, *attrs, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, info=info, doc=doc)",
            "def composite(_class_or_attr: Union[None, Type[_CC], Callable[..., _CC], _CompositeAttrType[Any]]=None, /, *attrs: _CompositeAttrType[Any], group: Optional[str]=None, deferred: bool=False, raiseload: bool=False, comparator_factory: Optional[Type[Composite.Comparator[_T]]]=None, active_history: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None, **__kw: Any) -> Composite[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a composite column-based property for use with a Mapper.\\n\\n    See the mapping documentation section :ref:`mapper_composite` for a\\n    full usage example.\\n\\n    The :class:`.MapperProperty` returned by :func:`.composite`\\n    is the :class:`.Composite`.\\n\\n    :param class\\\\_:\\n      The \"composite type\" class, or any classmethod or callable which\\n      will produce a new instance of the composite object given the\\n      column values in order.\\n\\n    :param \\\\*attrs:\\n      List of elements to be mapped, which may include:\\n\\n      * :class:`_schema.Column` objects\\n      * :func:`_orm.mapped_column` constructs\\n      * string names of other attributes on the mapped class, which may be\\n        any other SQL or object-mapped attribute.  This can for\\n        example allow a composite that refers to a many-to-one relationship\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      scalar attribute should be loaded when replaced, if not\\n      already loaded.  See the same flag on :func:`.column_property`.\\n\\n    :param group:\\n      A group name for this property when marked as deferred.\\n\\n    :param deferred:\\n      When True, the column property is \"deferred\", meaning that it does\\n      not load immediately, and is instead loaded when the attribute is\\n      first accessed on an instance.  See also\\n      :func:`~sqlalchemy.orm.deferred`.\\n\\n    :param comparator_factory:  a class which extends\\n      :class:`.Composite.Comparator` which provides custom SQL\\n      clause generation for comparison operations.\\n\\n    :param doc:\\n      optional string that will be applied as the doc on the\\n      class-bound descriptor.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n    '\n    if __kw:\n        raise _no_kw()\n    return Composite(_class_or_attr, *attrs, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=deferred, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, info=info, doc=doc)"
        ]
    },
    {
        "func_name": "with_loader_criteria",
        "original": "def with_loader_criteria(entity_or_base: _EntityType[Any], where_criteria: _ColumnExpressionArgument[bool], loader_only: bool=False, include_aliases: bool=False, propagate_to_loaders: bool=True, track_closure_variables: bool=True) -> LoaderCriteriaOption:\n    \"\"\"Add additional WHERE criteria to the load for all occurrences of\n    a particular entity.\n\n    .. versionadded:: 1.4\n\n    The :func:`_orm.with_loader_criteria` option is intended to add\n    limiting criteria to a particular kind of entity in a query,\n    **globally**, meaning it will apply to the entity as it appears\n    in the SELECT query as well as within any subqueries, join\n    conditions, and relationship loads, including both eager and lazy\n    loaders, without the need for it to be specified in any particular\n    part of the query.    The rendering logic uses the same system used by\n    single table inheritance to ensure a certain discriminator is applied\n    to a table.\n\n    E.g., using :term:`2.0-style` queries, we can limit the way the\n    ``User.addresses`` collection is loaded, regardless of the kind\n    of loading used::\n\n        from sqlalchemy.orm import with_loader_criteria\n\n        stmt = select(User).options(\n            selectinload(User.addresses),\n            with_loader_criteria(Address, Address.email_address != 'foo'))\n        )\n\n    Above, the \"selectinload\" for ``User.addresses`` will apply the\n    given filtering criteria to the WHERE clause.\n\n    Another example, where the filtering will be applied to the\n    ON clause of the join, in this example using :term:`1.x style`\n    queries::\n\n        q = session.query(User).outerjoin(User.addresses).options(\n            with_loader_criteria(Address, Address.email_address != 'foo'))\n        )\n\n    The primary purpose of :func:`_orm.with_loader_criteria` is to use\n    it in the :meth:`_orm.SessionEvents.do_orm_execute` event handler\n    to ensure that all occurrences of a particular entity are filtered\n    in a certain way, such as filtering for access control roles.    It\n    also can be used to apply criteria to relationship loads.  In the\n    example below, we can apply a certain set of rules to all queries\n    emitted by a particular :class:`_orm.Session`::\n\n        session = Session(bind=engine)\n\n        @event.listens_for(\"do_orm_execute\", session)\n        def _add_filtering_criteria(execute_state):\n\n            if (\n                execute_state.is_select\n                and not execute_state.is_column_load\n                and not execute_state.is_relationship_load\n            ):\n                execute_state.statement = execute_state.statement.options(\n                    with_loader_criteria(\n                        SecurityRole,\n                        lambda cls: cls.role.in_(['some_role']),\n                        include_aliases=True\n                    )\n                )\n\n    In the above example, the :meth:`_orm.SessionEvents.do_orm_execute`\n    event will intercept all queries emitted using the\n    :class:`_orm.Session`. For those queries which are SELECT statements\n    and are not attribute or relationship loads a custom\n    :func:`_orm.with_loader_criteria` option is added to the query.    The\n    :func:`_orm.with_loader_criteria` option will be used in the given\n    statement and will also be automatically propagated to all relationship\n    loads that descend from this query.\n\n    The criteria argument given is a ``lambda`` that accepts a ``cls``\n    argument.  The given class will expand to include all mapped subclass\n    and need not itself be a mapped class.\n\n    .. tip::\n\n       When using :func:`_orm.with_loader_criteria` option in\n       conjunction with the :func:`_orm.contains_eager` loader option,\n       it's important to note that :func:`_orm.with_loader_criteria` only\n       affects the part of the query that determines what SQL is rendered\n       in terms of the WHERE and FROM clauses. The\n       :func:`_orm.contains_eager` option does not affect the rendering of\n       the SELECT statement outside of the columns clause, so does not have\n       any interaction with the :func:`_orm.with_loader_criteria` option.\n       However, the way things \"work\" is that :func:`_orm.contains_eager`\n       is meant to be used with a query that is already selecting from the\n       additional entities in some way, where\n       :func:`_orm.with_loader_criteria` can apply it's additional\n       criteria.\n\n       In the example below, assuming a mapping relationship as\n       ``A -> A.bs -> B``, the given :func:`_orm.with_loader_criteria`\n       option will affect the way in which the JOIN is rendered::\n\n            stmt = select(A).join(A.bs).options(\n                contains_eager(A.bs),\n                with_loader_criteria(B, B.flag == 1)\n            )\n\n       Above, the given :func:`_orm.with_loader_criteria` option will\n       affect the ON clause of the JOIN that is specified by\n       ``.join(A.bs)``, so is applied as expected. The\n       :func:`_orm.contains_eager` option has the effect that columns from\n       ``B`` are added to the columns clause::\n\n            SELECT\n                b.id, b.a_id, b.data, b.flag,\n                a.id AS id_1,\n                a.data AS data_1\n            FROM a JOIN b ON a.id = b.a_id AND b.flag = :flag_1\n\n\n       The use of the :func:`_orm.contains_eager` option within the above\n       statement has no effect on the behavior of the\n       :func:`_orm.with_loader_criteria` option. If the\n       :func:`_orm.contains_eager` option were omitted, the SQL would be\n       the same as regards the FROM and WHERE clauses, where\n       :func:`_orm.with_loader_criteria` continues to add its criteria to\n       the ON clause of the JOIN. The addition of\n       :func:`_orm.contains_eager` only affects the columns clause, in that\n       additional columns against ``b`` are added which are then consumed\n       by the ORM to produce ``B`` instances.\n\n    .. warning:: The use of a lambda inside of the call to\n      :func:`_orm.with_loader_criteria` is only invoked **once per unique\n      class**. Custom functions should not be invoked within this lambda.\n      See :ref:`engine_lambda_caching` for an overview of the \"lambda SQL\"\n      feature, which is for advanced use only.\n\n    :param entity_or_base: a mapped class, or a class that is a super\n     class of a particular set of mapped classes, to which the rule\n     will apply.\n\n    :param where_criteria: a Core SQL expression that applies limiting\n     criteria.   This may also be a \"lambda:\" or Python function that\n     accepts a target class as an argument, when the given class is\n     a base with many different mapped subclasses.\n\n     .. note:: To support pickling, use a module-level Python function to\n        produce the SQL expression instead of a lambda or a fixed SQL\n        expression, which tend to not be picklable.\n\n    :param include_aliases: if True, apply the rule to :func:`_orm.aliased`\n     constructs as well.\n\n    :param propagate_to_loaders: defaults to True, apply to relationship\n     loaders such as lazy loaders.   This indicates that the\n     option object itself including SQL expression is carried along with\n     each loaded instance.  Set to ``False`` to prevent the object from\n     being assigned to individual instances.\n\n\n     .. seealso::\n\n        :ref:`examples_session_orm_events` - includes examples of using\n        :func:`_orm.with_loader_criteria`.\n\n        :ref:`do_orm_execute_global_criteria` - basic example on how to\n        combine :func:`_orm.with_loader_criteria` with the\n        :meth:`_orm.SessionEvents.do_orm_execute` event.\n\n    :param track_closure_variables: when False, closure variables inside\n     of a lambda expression will not be used as part of\n     any cache key.    This allows more complex expressions to be used\n     inside of a lambda expression but requires that the lambda ensures\n     it returns the identical SQL every time given a particular class.\n\n     .. versionadded:: 1.4.0b2\n\n    \"\"\"\n    return LoaderCriteriaOption(entity_or_base, where_criteria, loader_only, include_aliases, propagate_to_loaders, track_closure_variables)",
        "mutated": [
            "def with_loader_criteria(entity_or_base: _EntityType[Any], where_criteria: _ColumnExpressionArgument[bool], loader_only: bool=False, include_aliases: bool=False, propagate_to_loaders: bool=True, track_closure_variables: bool=True) -> LoaderCriteriaOption:\n    if False:\n        i = 10\n    'Add additional WHERE criteria to the load for all occurrences of\\n    a particular entity.\\n\\n    .. versionadded:: 1.4\\n\\n    The :func:`_orm.with_loader_criteria` option is intended to add\\n    limiting criteria to a particular kind of entity in a query,\\n    **globally**, meaning it will apply to the entity as it appears\\n    in the SELECT query as well as within any subqueries, join\\n    conditions, and relationship loads, including both eager and lazy\\n    loaders, without the need for it to be specified in any particular\\n    part of the query.    The rendering logic uses the same system used by\\n    single table inheritance to ensure a certain discriminator is applied\\n    to a table.\\n\\n    E.g., using :term:`2.0-style` queries, we can limit the way the\\n    ``User.addresses`` collection is loaded, regardless of the kind\\n    of loading used::\\n\\n        from sqlalchemy.orm import with_loader_criteria\\n\\n        stmt = select(User).options(\\n            selectinload(User.addresses),\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    Above, the \"selectinload\" for ``User.addresses`` will apply the\\n    given filtering criteria to the WHERE clause.\\n\\n    Another example, where the filtering will be applied to the\\n    ON clause of the join, in this example using :term:`1.x style`\\n    queries::\\n\\n        q = session.query(User).outerjoin(User.addresses).options(\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    The primary purpose of :func:`_orm.with_loader_criteria` is to use\\n    it in the :meth:`_orm.SessionEvents.do_orm_execute` event handler\\n    to ensure that all occurrences of a particular entity are filtered\\n    in a certain way, such as filtering for access control roles.    It\\n    also can be used to apply criteria to relationship loads.  In the\\n    example below, we can apply a certain set of rules to all queries\\n    emitted by a particular :class:`_orm.Session`::\\n\\n        session = Session(bind=engine)\\n\\n        @event.listens_for(\"do_orm_execute\", session)\\n        def _add_filtering_criteria(execute_state):\\n\\n            if (\\n                execute_state.is_select\\n                and not execute_state.is_column_load\\n                and not execute_state.is_relationship_load\\n            ):\\n                execute_state.statement = execute_state.statement.options(\\n                    with_loader_criteria(\\n                        SecurityRole,\\n                        lambda cls: cls.role.in_([\\'some_role\\']),\\n                        include_aliases=True\\n                    )\\n                )\\n\\n    In the above example, the :meth:`_orm.SessionEvents.do_orm_execute`\\n    event will intercept all queries emitted using the\\n    :class:`_orm.Session`. For those queries which are SELECT statements\\n    and are not attribute or relationship loads a custom\\n    :func:`_orm.with_loader_criteria` option is added to the query.    The\\n    :func:`_orm.with_loader_criteria` option will be used in the given\\n    statement and will also be automatically propagated to all relationship\\n    loads that descend from this query.\\n\\n    The criteria argument given is a ``lambda`` that accepts a ``cls``\\n    argument.  The given class will expand to include all mapped subclass\\n    and need not itself be a mapped class.\\n\\n    .. tip::\\n\\n       When using :func:`_orm.with_loader_criteria` option in\\n       conjunction with the :func:`_orm.contains_eager` loader option,\\n       it\\'s important to note that :func:`_orm.with_loader_criteria` only\\n       affects the part of the query that determines what SQL is rendered\\n       in terms of the WHERE and FROM clauses. The\\n       :func:`_orm.contains_eager` option does not affect the rendering of\\n       the SELECT statement outside of the columns clause, so does not have\\n       any interaction with the :func:`_orm.with_loader_criteria` option.\\n       However, the way things \"work\" is that :func:`_orm.contains_eager`\\n       is meant to be used with a query that is already selecting from the\\n       additional entities in some way, where\\n       :func:`_orm.with_loader_criteria` can apply it\\'s additional\\n       criteria.\\n\\n       In the example below, assuming a mapping relationship as\\n       ``A -> A.bs -> B``, the given :func:`_orm.with_loader_criteria`\\n       option will affect the way in which the JOIN is rendered::\\n\\n            stmt = select(A).join(A.bs).options(\\n                contains_eager(A.bs),\\n                with_loader_criteria(B, B.flag == 1)\\n            )\\n\\n       Above, the given :func:`_orm.with_loader_criteria` option will\\n       affect the ON clause of the JOIN that is specified by\\n       ``.join(A.bs)``, so is applied as expected. The\\n       :func:`_orm.contains_eager` option has the effect that columns from\\n       ``B`` are added to the columns clause::\\n\\n            SELECT\\n                b.id, b.a_id, b.data, b.flag,\\n                a.id AS id_1,\\n                a.data AS data_1\\n            FROM a JOIN b ON a.id = b.a_id AND b.flag = :flag_1\\n\\n\\n       The use of the :func:`_orm.contains_eager` option within the above\\n       statement has no effect on the behavior of the\\n       :func:`_orm.with_loader_criteria` option. If the\\n       :func:`_orm.contains_eager` option were omitted, the SQL would be\\n       the same as regards the FROM and WHERE clauses, where\\n       :func:`_orm.with_loader_criteria` continues to add its criteria to\\n       the ON clause of the JOIN. The addition of\\n       :func:`_orm.contains_eager` only affects the columns clause, in that\\n       additional columns against ``b`` are added which are then consumed\\n       by the ORM to produce ``B`` instances.\\n\\n    .. warning:: The use of a lambda inside of the call to\\n      :func:`_orm.with_loader_criteria` is only invoked **once per unique\\n      class**. Custom functions should not be invoked within this lambda.\\n      See :ref:`engine_lambda_caching` for an overview of the \"lambda SQL\"\\n      feature, which is for advanced use only.\\n\\n    :param entity_or_base: a mapped class, or a class that is a super\\n     class of a particular set of mapped classes, to which the rule\\n     will apply.\\n\\n    :param where_criteria: a Core SQL expression that applies limiting\\n     criteria.   This may also be a \"lambda:\" or Python function that\\n     accepts a target class as an argument, when the given class is\\n     a base with many different mapped subclasses.\\n\\n     .. note:: To support pickling, use a module-level Python function to\\n        produce the SQL expression instead of a lambda or a fixed SQL\\n        expression, which tend to not be picklable.\\n\\n    :param include_aliases: if True, apply the rule to :func:`_orm.aliased`\\n     constructs as well.\\n\\n    :param propagate_to_loaders: defaults to True, apply to relationship\\n     loaders such as lazy loaders.   This indicates that the\\n     option object itself including SQL expression is carried along with\\n     each loaded instance.  Set to ``False`` to prevent the object from\\n     being assigned to individual instances.\\n\\n\\n     .. seealso::\\n\\n        :ref:`examples_session_orm_events` - includes examples of using\\n        :func:`_orm.with_loader_criteria`.\\n\\n        :ref:`do_orm_execute_global_criteria` - basic example on how to\\n        combine :func:`_orm.with_loader_criteria` with the\\n        :meth:`_orm.SessionEvents.do_orm_execute` event.\\n\\n    :param track_closure_variables: when False, closure variables inside\\n     of a lambda expression will not be used as part of\\n     any cache key.    This allows more complex expressions to be used\\n     inside of a lambda expression but requires that the lambda ensures\\n     it returns the identical SQL every time given a particular class.\\n\\n     .. versionadded:: 1.4.0b2\\n\\n    '\n    return LoaderCriteriaOption(entity_or_base, where_criteria, loader_only, include_aliases, propagate_to_loaders, track_closure_variables)",
            "def with_loader_criteria(entity_or_base: _EntityType[Any], where_criteria: _ColumnExpressionArgument[bool], loader_only: bool=False, include_aliases: bool=False, propagate_to_loaders: bool=True, track_closure_variables: bool=True) -> LoaderCriteriaOption:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Add additional WHERE criteria to the load for all occurrences of\\n    a particular entity.\\n\\n    .. versionadded:: 1.4\\n\\n    The :func:`_orm.with_loader_criteria` option is intended to add\\n    limiting criteria to a particular kind of entity in a query,\\n    **globally**, meaning it will apply to the entity as it appears\\n    in the SELECT query as well as within any subqueries, join\\n    conditions, and relationship loads, including both eager and lazy\\n    loaders, without the need for it to be specified in any particular\\n    part of the query.    The rendering logic uses the same system used by\\n    single table inheritance to ensure a certain discriminator is applied\\n    to a table.\\n\\n    E.g., using :term:`2.0-style` queries, we can limit the way the\\n    ``User.addresses`` collection is loaded, regardless of the kind\\n    of loading used::\\n\\n        from sqlalchemy.orm import with_loader_criteria\\n\\n        stmt = select(User).options(\\n            selectinload(User.addresses),\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    Above, the \"selectinload\" for ``User.addresses`` will apply the\\n    given filtering criteria to the WHERE clause.\\n\\n    Another example, where the filtering will be applied to the\\n    ON clause of the join, in this example using :term:`1.x style`\\n    queries::\\n\\n        q = session.query(User).outerjoin(User.addresses).options(\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    The primary purpose of :func:`_orm.with_loader_criteria` is to use\\n    it in the :meth:`_orm.SessionEvents.do_orm_execute` event handler\\n    to ensure that all occurrences of a particular entity are filtered\\n    in a certain way, such as filtering for access control roles.    It\\n    also can be used to apply criteria to relationship loads.  In the\\n    example below, we can apply a certain set of rules to all queries\\n    emitted by a particular :class:`_orm.Session`::\\n\\n        session = Session(bind=engine)\\n\\n        @event.listens_for(\"do_orm_execute\", session)\\n        def _add_filtering_criteria(execute_state):\\n\\n            if (\\n                execute_state.is_select\\n                and not execute_state.is_column_load\\n                and not execute_state.is_relationship_load\\n            ):\\n                execute_state.statement = execute_state.statement.options(\\n                    with_loader_criteria(\\n                        SecurityRole,\\n                        lambda cls: cls.role.in_([\\'some_role\\']),\\n                        include_aliases=True\\n                    )\\n                )\\n\\n    In the above example, the :meth:`_orm.SessionEvents.do_orm_execute`\\n    event will intercept all queries emitted using the\\n    :class:`_orm.Session`. For those queries which are SELECT statements\\n    and are not attribute or relationship loads a custom\\n    :func:`_orm.with_loader_criteria` option is added to the query.    The\\n    :func:`_orm.with_loader_criteria` option will be used in the given\\n    statement and will also be automatically propagated to all relationship\\n    loads that descend from this query.\\n\\n    The criteria argument given is a ``lambda`` that accepts a ``cls``\\n    argument.  The given class will expand to include all mapped subclass\\n    and need not itself be a mapped class.\\n\\n    .. tip::\\n\\n       When using :func:`_orm.with_loader_criteria` option in\\n       conjunction with the :func:`_orm.contains_eager` loader option,\\n       it\\'s important to note that :func:`_orm.with_loader_criteria` only\\n       affects the part of the query that determines what SQL is rendered\\n       in terms of the WHERE and FROM clauses. The\\n       :func:`_orm.contains_eager` option does not affect the rendering of\\n       the SELECT statement outside of the columns clause, so does not have\\n       any interaction with the :func:`_orm.with_loader_criteria` option.\\n       However, the way things \"work\" is that :func:`_orm.contains_eager`\\n       is meant to be used with a query that is already selecting from the\\n       additional entities in some way, where\\n       :func:`_orm.with_loader_criteria` can apply it\\'s additional\\n       criteria.\\n\\n       In the example below, assuming a mapping relationship as\\n       ``A -> A.bs -> B``, the given :func:`_orm.with_loader_criteria`\\n       option will affect the way in which the JOIN is rendered::\\n\\n            stmt = select(A).join(A.bs).options(\\n                contains_eager(A.bs),\\n                with_loader_criteria(B, B.flag == 1)\\n            )\\n\\n       Above, the given :func:`_orm.with_loader_criteria` option will\\n       affect the ON clause of the JOIN that is specified by\\n       ``.join(A.bs)``, so is applied as expected. The\\n       :func:`_orm.contains_eager` option has the effect that columns from\\n       ``B`` are added to the columns clause::\\n\\n            SELECT\\n                b.id, b.a_id, b.data, b.flag,\\n                a.id AS id_1,\\n                a.data AS data_1\\n            FROM a JOIN b ON a.id = b.a_id AND b.flag = :flag_1\\n\\n\\n       The use of the :func:`_orm.contains_eager` option within the above\\n       statement has no effect on the behavior of the\\n       :func:`_orm.with_loader_criteria` option. If the\\n       :func:`_orm.contains_eager` option were omitted, the SQL would be\\n       the same as regards the FROM and WHERE clauses, where\\n       :func:`_orm.with_loader_criteria` continues to add its criteria to\\n       the ON clause of the JOIN. The addition of\\n       :func:`_orm.contains_eager` only affects the columns clause, in that\\n       additional columns against ``b`` are added which are then consumed\\n       by the ORM to produce ``B`` instances.\\n\\n    .. warning:: The use of a lambda inside of the call to\\n      :func:`_orm.with_loader_criteria` is only invoked **once per unique\\n      class**. Custom functions should not be invoked within this lambda.\\n      See :ref:`engine_lambda_caching` for an overview of the \"lambda SQL\"\\n      feature, which is for advanced use only.\\n\\n    :param entity_or_base: a mapped class, or a class that is a super\\n     class of a particular set of mapped classes, to which the rule\\n     will apply.\\n\\n    :param where_criteria: a Core SQL expression that applies limiting\\n     criteria.   This may also be a \"lambda:\" or Python function that\\n     accepts a target class as an argument, when the given class is\\n     a base with many different mapped subclasses.\\n\\n     .. note:: To support pickling, use a module-level Python function to\\n        produce the SQL expression instead of a lambda or a fixed SQL\\n        expression, which tend to not be picklable.\\n\\n    :param include_aliases: if True, apply the rule to :func:`_orm.aliased`\\n     constructs as well.\\n\\n    :param propagate_to_loaders: defaults to True, apply to relationship\\n     loaders such as lazy loaders.   This indicates that the\\n     option object itself including SQL expression is carried along with\\n     each loaded instance.  Set to ``False`` to prevent the object from\\n     being assigned to individual instances.\\n\\n\\n     .. seealso::\\n\\n        :ref:`examples_session_orm_events` - includes examples of using\\n        :func:`_orm.with_loader_criteria`.\\n\\n        :ref:`do_orm_execute_global_criteria` - basic example on how to\\n        combine :func:`_orm.with_loader_criteria` with the\\n        :meth:`_orm.SessionEvents.do_orm_execute` event.\\n\\n    :param track_closure_variables: when False, closure variables inside\\n     of a lambda expression will not be used as part of\\n     any cache key.    This allows more complex expressions to be used\\n     inside of a lambda expression but requires that the lambda ensures\\n     it returns the identical SQL every time given a particular class.\\n\\n     .. versionadded:: 1.4.0b2\\n\\n    '\n    return LoaderCriteriaOption(entity_or_base, where_criteria, loader_only, include_aliases, propagate_to_loaders, track_closure_variables)",
            "def with_loader_criteria(entity_or_base: _EntityType[Any], where_criteria: _ColumnExpressionArgument[bool], loader_only: bool=False, include_aliases: bool=False, propagate_to_loaders: bool=True, track_closure_variables: bool=True) -> LoaderCriteriaOption:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Add additional WHERE criteria to the load for all occurrences of\\n    a particular entity.\\n\\n    .. versionadded:: 1.4\\n\\n    The :func:`_orm.with_loader_criteria` option is intended to add\\n    limiting criteria to a particular kind of entity in a query,\\n    **globally**, meaning it will apply to the entity as it appears\\n    in the SELECT query as well as within any subqueries, join\\n    conditions, and relationship loads, including both eager and lazy\\n    loaders, without the need for it to be specified in any particular\\n    part of the query.    The rendering logic uses the same system used by\\n    single table inheritance to ensure a certain discriminator is applied\\n    to a table.\\n\\n    E.g., using :term:`2.0-style` queries, we can limit the way the\\n    ``User.addresses`` collection is loaded, regardless of the kind\\n    of loading used::\\n\\n        from sqlalchemy.orm import with_loader_criteria\\n\\n        stmt = select(User).options(\\n            selectinload(User.addresses),\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    Above, the \"selectinload\" for ``User.addresses`` will apply the\\n    given filtering criteria to the WHERE clause.\\n\\n    Another example, where the filtering will be applied to the\\n    ON clause of the join, in this example using :term:`1.x style`\\n    queries::\\n\\n        q = session.query(User).outerjoin(User.addresses).options(\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    The primary purpose of :func:`_orm.with_loader_criteria` is to use\\n    it in the :meth:`_orm.SessionEvents.do_orm_execute` event handler\\n    to ensure that all occurrences of a particular entity are filtered\\n    in a certain way, such as filtering for access control roles.    It\\n    also can be used to apply criteria to relationship loads.  In the\\n    example below, we can apply a certain set of rules to all queries\\n    emitted by a particular :class:`_orm.Session`::\\n\\n        session = Session(bind=engine)\\n\\n        @event.listens_for(\"do_orm_execute\", session)\\n        def _add_filtering_criteria(execute_state):\\n\\n            if (\\n                execute_state.is_select\\n                and not execute_state.is_column_load\\n                and not execute_state.is_relationship_load\\n            ):\\n                execute_state.statement = execute_state.statement.options(\\n                    with_loader_criteria(\\n                        SecurityRole,\\n                        lambda cls: cls.role.in_([\\'some_role\\']),\\n                        include_aliases=True\\n                    )\\n                )\\n\\n    In the above example, the :meth:`_orm.SessionEvents.do_orm_execute`\\n    event will intercept all queries emitted using the\\n    :class:`_orm.Session`. For those queries which are SELECT statements\\n    and are not attribute or relationship loads a custom\\n    :func:`_orm.with_loader_criteria` option is added to the query.    The\\n    :func:`_orm.with_loader_criteria` option will be used in the given\\n    statement and will also be automatically propagated to all relationship\\n    loads that descend from this query.\\n\\n    The criteria argument given is a ``lambda`` that accepts a ``cls``\\n    argument.  The given class will expand to include all mapped subclass\\n    and need not itself be a mapped class.\\n\\n    .. tip::\\n\\n       When using :func:`_orm.with_loader_criteria` option in\\n       conjunction with the :func:`_orm.contains_eager` loader option,\\n       it\\'s important to note that :func:`_orm.with_loader_criteria` only\\n       affects the part of the query that determines what SQL is rendered\\n       in terms of the WHERE and FROM clauses. The\\n       :func:`_orm.contains_eager` option does not affect the rendering of\\n       the SELECT statement outside of the columns clause, so does not have\\n       any interaction with the :func:`_orm.with_loader_criteria` option.\\n       However, the way things \"work\" is that :func:`_orm.contains_eager`\\n       is meant to be used with a query that is already selecting from the\\n       additional entities in some way, where\\n       :func:`_orm.with_loader_criteria` can apply it\\'s additional\\n       criteria.\\n\\n       In the example below, assuming a mapping relationship as\\n       ``A -> A.bs -> B``, the given :func:`_orm.with_loader_criteria`\\n       option will affect the way in which the JOIN is rendered::\\n\\n            stmt = select(A).join(A.bs).options(\\n                contains_eager(A.bs),\\n                with_loader_criteria(B, B.flag == 1)\\n            )\\n\\n       Above, the given :func:`_orm.with_loader_criteria` option will\\n       affect the ON clause of the JOIN that is specified by\\n       ``.join(A.bs)``, so is applied as expected. The\\n       :func:`_orm.contains_eager` option has the effect that columns from\\n       ``B`` are added to the columns clause::\\n\\n            SELECT\\n                b.id, b.a_id, b.data, b.flag,\\n                a.id AS id_1,\\n                a.data AS data_1\\n            FROM a JOIN b ON a.id = b.a_id AND b.flag = :flag_1\\n\\n\\n       The use of the :func:`_orm.contains_eager` option within the above\\n       statement has no effect on the behavior of the\\n       :func:`_orm.with_loader_criteria` option. If the\\n       :func:`_orm.contains_eager` option were omitted, the SQL would be\\n       the same as regards the FROM and WHERE clauses, where\\n       :func:`_orm.with_loader_criteria` continues to add its criteria to\\n       the ON clause of the JOIN. The addition of\\n       :func:`_orm.contains_eager` only affects the columns clause, in that\\n       additional columns against ``b`` are added which are then consumed\\n       by the ORM to produce ``B`` instances.\\n\\n    .. warning:: The use of a lambda inside of the call to\\n      :func:`_orm.with_loader_criteria` is only invoked **once per unique\\n      class**. Custom functions should not be invoked within this lambda.\\n      See :ref:`engine_lambda_caching` for an overview of the \"lambda SQL\"\\n      feature, which is for advanced use only.\\n\\n    :param entity_or_base: a mapped class, or a class that is a super\\n     class of a particular set of mapped classes, to which the rule\\n     will apply.\\n\\n    :param where_criteria: a Core SQL expression that applies limiting\\n     criteria.   This may also be a \"lambda:\" or Python function that\\n     accepts a target class as an argument, when the given class is\\n     a base with many different mapped subclasses.\\n\\n     .. note:: To support pickling, use a module-level Python function to\\n        produce the SQL expression instead of a lambda or a fixed SQL\\n        expression, which tend to not be picklable.\\n\\n    :param include_aliases: if True, apply the rule to :func:`_orm.aliased`\\n     constructs as well.\\n\\n    :param propagate_to_loaders: defaults to True, apply to relationship\\n     loaders such as lazy loaders.   This indicates that the\\n     option object itself including SQL expression is carried along with\\n     each loaded instance.  Set to ``False`` to prevent the object from\\n     being assigned to individual instances.\\n\\n\\n     .. seealso::\\n\\n        :ref:`examples_session_orm_events` - includes examples of using\\n        :func:`_orm.with_loader_criteria`.\\n\\n        :ref:`do_orm_execute_global_criteria` - basic example on how to\\n        combine :func:`_orm.with_loader_criteria` with the\\n        :meth:`_orm.SessionEvents.do_orm_execute` event.\\n\\n    :param track_closure_variables: when False, closure variables inside\\n     of a lambda expression will not be used as part of\\n     any cache key.    This allows more complex expressions to be used\\n     inside of a lambda expression but requires that the lambda ensures\\n     it returns the identical SQL every time given a particular class.\\n\\n     .. versionadded:: 1.4.0b2\\n\\n    '\n    return LoaderCriteriaOption(entity_or_base, where_criteria, loader_only, include_aliases, propagate_to_loaders, track_closure_variables)",
            "def with_loader_criteria(entity_or_base: _EntityType[Any], where_criteria: _ColumnExpressionArgument[bool], loader_only: bool=False, include_aliases: bool=False, propagate_to_loaders: bool=True, track_closure_variables: bool=True) -> LoaderCriteriaOption:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Add additional WHERE criteria to the load for all occurrences of\\n    a particular entity.\\n\\n    .. versionadded:: 1.4\\n\\n    The :func:`_orm.with_loader_criteria` option is intended to add\\n    limiting criteria to a particular kind of entity in a query,\\n    **globally**, meaning it will apply to the entity as it appears\\n    in the SELECT query as well as within any subqueries, join\\n    conditions, and relationship loads, including both eager and lazy\\n    loaders, without the need for it to be specified in any particular\\n    part of the query.    The rendering logic uses the same system used by\\n    single table inheritance to ensure a certain discriminator is applied\\n    to a table.\\n\\n    E.g., using :term:`2.0-style` queries, we can limit the way the\\n    ``User.addresses`` collection is loaded, regardless of the kind\\n    of loading used::\\n\\n        from sqlalchemy.orm import with_loader_criteria\\n\\n        stmt = select(User).options(\\n            selectinload(User.addresses),\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    Above, the \"selectinload\" for ``User.addresses`` will apply the\\n    given filtering criteria to the WHERE clause.\\n\\n    Another example, where the filtering will be applied to the\\n    ON clause of the join, in this example using :term:`1.x style`\\n    queries::\\n\\n        q = session.query(User).outerjoin(User.addresses).options(\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    The primary purpose of :func:`_orm.with_loader_criteria` is to use\\n    it in the :meth:`_orm.SessionEvents.do_orm_execute` event handler\\n    to ensure that all occurrences of a particular entity are filtered\\n    in a certain way, such as filtering for access control roles.    It\\n    also can be used to apply criteria to relationship loads.  In the\\n    example below, we can apply a certain set of rules to all queries\\n    emitted by a particular :class:`_orm.Session`::\\n\\n        session = Session(bind=engine)\\n\\n        @event.listens_for(\"do_orm_execute\", session)\\n        def _add_filtering_criteria(execute_state):\\n\\n            if (\\n                execute_state.is_select\\n                and not execute_state.is_column_load\\n                and not execute_state.is_relationship_load\\n            ):\\n                execute_state.statement = execute_state.statement.options(\\n                    with_loader_criteria(\\n                        SecurityRole,\\n                        lambda cls: cls.role.in_([\\'some_role\\']),\\n                        include_aliases=True\\n                    )\\n                )\\n\\n    In the above example, the :meth:`_orm.SessionEvents.do_orm_execute`\\n    event will intercept all queries emitted using the\\n    :class:`_orm.Session`. For those queries which are SELECT statements\\n    and are not attribute or relationship loads a custom\\n    :func:`_orm.with_loader_criteria` option is added to the query.    The\\n    :func:`_orm.with_loader_criteria` option will be used in the given\\n    statement and will also be automatically propagated to all relationship\\n    loads that descend from this query.\\n\\n    The criteria argument given is a ``lambda`` that accepts a ``cls``\\n    argument.  The given class will expand to include all mapped subclass\\n    and need not itself be a mapped class.\\n\\n    .. tip::\\n\\n       When using :func:`_orm.with_loader_criteria` option in\\n       conjunction with the :func:`_orm.contains_eager` loader option,\\n       it\\'s important to note that :func:`_orm.with_loader_criteria` only\\n       affects the part of the query that determines what SQL is rendered\\n       in terms of the WHERE and FROM clauses. The\\n       :func:`_orm.contains_eager` option does not affect the rendering of\\n       the SELECT statement outside of the columns clause, so does not have\\n       any interaction with the :func:`_orm.with_loader_criteria` option.\\n       However, the way things \"work\" is that :func:`_orm.contains_eager`\\n       is meant to be used with a query that is already selecting from the\\n       additional entities in some way, where\\n       :func:`_orm.with_loader_criteria` can apply it\\'s additional\\n       criteria.\\n\\n       In the example below, assuming a mapping relationship as\\n       ``A -> A.bs -> B``, the given :func:`_orm.with_loader_criteria`\\n       option will affect the way in which the JOIN is rendered::\\n\\n            stmt = select(A).join(A.bs).options(\\n                contains_eager(A.bs),\\n                with_loader_criteria(B, B.flag == 1)\\n            )\\n\\n       Above, the given :func:`_orm.with_loader_criteria` option will\\n       affect the ON clause of the JOIN that is specified by\\n       ``.join(A.bs)``, so is applied as expected. The\\n       :func:`_orm.contains_eager` option has the effect that columns from\\n       ``B`` are added to the columns clause::\\n\\n            SELECT\\n                b.id, b.a_id, b.data, b.flag,\\n                a.id AS id_1,\\n                a.data AS data_1\\n            FROM a JOIN b ON a.id = b.a_id AND b.flag = :flag_1\\n\\n\\n       The use of the :func:`_orm.contains_eager` option within the above\\n       statement has no effect on the behavior of the\\n       :func:`_orm.with_loader_criteria` option. If the\\n       :func:`_orm.contains_eager` option were omitted, the SQL would be\\n       the same as regards the FROM and WHERE clauses, where\\n       :func:`_orm.with_loader_criteria` continues to add its criteria to\\n       the ON clause of the JOIN. The addition of\\n       :func:`_orm.contains_eager` only affects the columns clause, in that\\n       additional columns against ``b`` are added which are then consumed\\n       by the ORM to produce ``B`` instances.\\n\\n    .. warning:: The use of a lambda inside of the call to\\n      :func:`_orm.with_loader_criteria` is only invoked **once per unique\\n      class**. Custom functions should not be invoked within this lambda.\\n      See :ref:`engine_lambda_caching` for an overview of the \"lambda SQL\"\\n      feature, which is for advanced use only.\\n\\n    :param entity_or_base: a mapped class, or a class that is a super\\n     class of a particular set of mapped classes, to which the rule\\n     will apply.\\n\\n    :param where_criteria: a Core SQL expression that applies limiting\\n     criteria.   This may also be a \"lambda:\" or Python function that\\n     accepts a target class as an argument, when the given class is\\n     a base with many different mapped subclasses.\\n\\n     .. note:: To support pickling, use a module-level Python function to\\n        produce the SQL expression instead of a lambda or a fixed SQL\\n        expression, which tend to not be picklable.\\n\\n    :param include_aliases: if True, apply the rule to :func:`_orm.aliased`\\n     constructs as well.\\n\\n    :param propagate_to_loaders: defaults to True, apply to relationship\\n     loaders such as lazy loaders.   This indicates that the\\n     option object itself including SQL expression is carried along with\\n     each loaded instance.  Set to ``False`` to prevent the object from\\n     being assigned to individual instances.\\n\\n\\n     .. seealso::\\n\\n        :ref:`examples_session_orm_events` - includes examples of using\\n        :func:`_orm.with_loader_criteria`.\\n\\n        :ref:`do_orm_execute_global_criteria` - basic example on how to\\n        combine :func:`_orm.with_loader_criteria` with the\\n        :meth:`_orm.SessionEvents.do_orm_execute` event.\\n\\n    :param track_closure_variables: when False, closure variables inside\\n     of a lambda expression will not be used as part of\\n     any cache key.    This allows more complex expressions to be used\\n     inside of a lambda expression but requires that the lambda ensures\\n     it returns the identical SQL every time given a particular class.\\n\\n     .. versionadded:: 1.4.0b2\\n\\n    '\n    return LoaderCriteriaOption(entity_or_base, where_criteria, loader_only, include_aliases, propagate_to_loaders, track_closure_variables)",
            "def with_loader_criteria(entity_or_base: _EntityType[Any], where_criteria: _ColumnExpressionArgument[bool], loader_only: bool=False, include_aliases: bool=False, propagate_to_loaders: bool=True, track_closure_variables: bool=True) -> LoaderCriteriaOption:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Add additional WHERE criteria to the load for all occurrences of\\n    a particular entity.\\n\\n    .. versionadded:: 1.4\\n\\n    The :func:`_orm.with_loader_criteria` option is intended to add\\n    limiting criteria to a particular kind of entity in a query,\\n    **globally**, meaning it will apply to the entity as it appears\\n    in the SELECT query as well as within any subqueries, join\\n    conditions, and relationship loads, including both eager and lazy\\n    loaders, without the need for it to be specified in any particular\\n    part of the query.    The rendering logic uses the same system used by\\n    single table inheritance to ensure a certain discriminator is applied\\n    to a table.\\n\\n    E.g., using :term:`2.0-style` queries, we can limit the way the\\n    ``User.addresses`` collection is loaded, regardless of the kind\\n    of loading used::\\n\\n        from sqlalchemy.orm import with_loader_criteria\\n\\n        stmt = select(User).options(\\n            selectinload(User.addresses),\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    Above, the \"selectinload\" for ``User.addresses`` will apply the\\n    given filtering criteria to the WHERE clause.\\n\\n    Another example, where the filtering will be applied to the\\n    ON clause of the join, in this example using :term:`1.x style`\\n    queries::\\n\\n        q = session.query(User).outerjoin(User.addresses).options(\\n            with_loader_criteria(Address, Address.email_address != \\'foo\\'))\\n        )\\n\\n    The primary purpose of :func:`_orm.with_loader_criteria` is to use\\n    it in the :meth:`_orm.SessionEvents.do_orm_execute` event handler\\n    to ensure that all occurrences of a particular entity are filtered\\n    in a certain way, such as filtering for access control roles.    It\\n    also can be used to apply criteria to relationship loads.  In the\\n    example below, we can apply a certain set of rules to all queries\\n    emitted by a particular :class:`_orm.Session`::\\n\\n        session = Session(bind=engine)\\n\\n        @event.listens_for(\"do_orm_execute\", session)\\n        def _add_filtering_criteria(execute_state):\\n\\n            if (\\n                execute_state.is_select\\n                and not execute_state.is_column_load\\n                and not execute_state.is_relationship_load\\n            ):\\n                execute_state.statement = execute_state.statement.options(\\n                    with_loader_criteria(\\n                        SecurityRole,\\n                        lambda cls: cls.role.in_([\\'some_role\\']),\\n                        include_aliases=True\\n                    )\\n                )\\n\\n    In the above example, the :meth:`_orm.SessionEvents.do_orm_execute`\\n    event will intercept all queries emitted using the\\n    :class:`_orm.Session`. For those queries which are SELECT statements\\n    and are not attribute or relationship loads a custom\\n    :func:`_orm.with_loader_criteria` option is added to the query.    The\\n    :func:`_orm.with_loader_criteria` option will be used in the given\\n    statement and will also be automatically propagated to all relationship\\n    loads that descend from this query.\\n\\n    The criteria argument given is a ``lambda`` that accepts a ``cls``\\n    argument.  The given class will expand to include all mapped subclass\\n    and need not itself be a mapped class.\\n\\n    .. tip::\\n\\n       When using :func:`_orm.with_loader_criteria` option in\\n       conjunction with the :func:`_orm.contains_eager` loader option,\\n       it\\'s important to note that :func:`_orm.with_loader_criteria` only\\n       affects the part of the query that determines what SQL is rendered\\n       in terms of the WHERE and FROM clauses. The\\n       :func:`_orm.contains_eager` option does not affect the rendering of\\n       the SELECT statement outside of the columns clause, so does not have\\n       any interaction with the :func:`_orm.with_loader_criteria` option.\\n       However, the way things \"work\" is that :func:`_orm.contains_eager`\\n       is meant to be used with a query that is already selecting from the\\n       additional entities in some way, where\\n       :func:`_orm.with_loader_criteria` can apply it\\'s additional\\n       criteria.\\n\\n       In the example below, assuming a mapping relationship as\\n       ``A -> A.bs -> B``, the given :func:`_orm.with_loader_criteria`\\n       option will affect the way in which the JOIN is rendered::\\n\\n            stmt = select(A).join(A.bs).options(\\n                contains_eager(A.bs),\\n                with_loader_criteria(B, B.flag == 1)\\n            )\\n\\n       Above, the given :func:`_orm.with_loader_criteria` option will\\n       affect the ON clause of the JOIN that is specified by\\n       ``.join(A.bs)``, so is applied as expected. The\\n       :func:`_orm.contains_eager` option has the effect that columns from\\n       ``B`` are added to the columns clause::\\n\\n            SELECT\\n                b.id, b.a_id, b.data, b.flag,\\n                a.id AS id_1,\\n                a.data AS data_1\\n            FROM a JOIN b ON a.id = b.a_id AND b.flag = :flag_1\\n\\n\\n       The use of the :func:`_orm.contains_eager` option within the above\\n       statement has no effect on the behavior of the\\n       :func:`_orm.with_loader_criteria` option. If the\\n       :func:`_orm.contains_eager` option were omitted, the SQL would be\\n       the same as regards the FROM and WHERE clauses, where\\n       :func:`_orm.with_loader_criteria` continues to add its criteria to\\n       the ON clause of the JOIN. The addition of\\n       :func:`_orm.contains_eager` only affects the columns clause, in that\\n       additional columns against ``b`` are added which are then consumed\\n       by the ORM to produce ``B`` instances.\\n\\n    .. warning:: The use of a lambda inside of the call to\\n      :func:`_orm.with_loader_criteria` is only invoked **once per unique\\n      class**. Custom functions should not be invoked within this lambda.\\n      See :ref:`engine_lambda_caching` for an overview of the \"lambda SQL\"\\n      feature, which is for advanced use only.\\n\\n    :param entity_or_base: a mapped class, or a class that is a super\\n     class of a particular set of mapped classes, to which the rule\\n     will apply.\\n\\n    :param where_criteria: a Core SQL expression that applies limiting\\n     criteria.   This may also be a \"lambda:\" or Python function that\\n     accepts a target class as an argument, when the given class is\\n     a base with many different mapped subclasses.\\n\\n     .. note:: To support pickling, use a module-level Python function to\\n        produce the SQL expression instead of a lambda or a fixed SQL\\n        expression, which tend to not be picklable.\\n\\n    :param include_aliases: if True, apply the rule to :func:`_orm.aliased`\\n     constructs as well.\\n\\n    :param propagate_to_loaders: defaults to True, apply to relationship\\n     loaders such as lazy loaders.   This indicates that the\\n     option object itself including SQL expression is carried along with\\n     each loaded instance.  Set to ``False`` to prevent the object from\\n     being assigned to individual instances.\\n\\n\\n     .. seealso::\\n\\n        :ref:`examples_session_orm_events` - includes examples of using\\n        :func:`_orm.with_loader_criteria`.\\n\\n        :ref:`do_orm_execute_global_criteria` - basic example on how to\\n        combine :func:`_orm.with_loader_criteria` with the\\n        :meth:`_orm.SessionEvents.do_orm_execute` event.\\n\\n    :param track_closure_variables: when False, closure variables inside\\n     of a lambda expression will not be used as part of\\n     any cache key.    This allows more complex expressions to be used\\n     inside of a lambda expression but requires that the lambda ensures\\n     it returns the identical SQL every time given a particular class.\\n\\n     .. versionadded:: 1.4.0b2\\n\\n    '\n    return LoaderCriteriaOption(entity_or_base, where_criteria, loader_only, include_aliases, propagate_to_loaders, track_closure_variables)"
        ]
    },
    {
        "func_name": "relationship",
        "original": "def relationship(argument: Optional[_RelationshipArgumentType[Any]]=None, secondary: Optional[_RelationshipSecondaryArgument]=None, *, uselist: Optional[bool]=None, collection_class: Optional[Union[Type[Collection[Any]], Callable[[], Collection[Any]]]]=None, primaryjoin: Optional[_RelationshipJoinConditionArgument]=None, secondaryjoin: Optional[_RelationshipJoinConditionArgument]=None, back_populates: Optional[str]=None, order_by: _ORMOrderByArgument=False, backref: Optional[ORMBackrefArgument]=None, overlaps: Optional[str]=None, post_update: bool=False, cascade: str='save-update, merge', viewonly: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, lazy: _LazyLoadArgumentType='select', passive_deletes: Union[Literal['all'], bool]=False, passive_updates: bool=True, active_history: bool=False, enable_typechecks: bool=True, foreign_keys: Optional[_ORMColCollectionArgument]=None, remote_side: Optional[_ORMColCollectionArgument]=None, join_depth: Optional[int]=None, comparator_factory: Optional[Type[RelationshipProperty.Comparator[Any]]]=None, single_parent: bool=False, innerjoin: bool=False, distinct_target_key: Optional[bool]=None, load_on_pending: bool=False, query_class: Optional[Type[Query[Any]]]=None, info: Optional[_InfoType]=None, omit_join: Literal[None, False]=None, sync_backref: Optional[bool]=None, **kw: Any) -> Relationship[Any]:\n    \"\"\"Provide a relationship between two mapped classes.\n\n    This corresponds to a parent-child or associative table relationship.\n    The constructed class is an instance of :class:`.Relationship`.\n\n    .. seealso::\n\n        :ref:`tutorial_orm_related_objects` - tutorial introduction\n        to :func:`_orm.relationship` in the :ref:`unified_tutorial`\n\n        :ref:`relationship_config_toplevel` - narrative documentation\n\n    :param argument:\n      This parameter refers to the class that is to be related.   It\n      accepts several forms, including a direct reference to the target\n      class itself, the :class:`_orm.Mapper` instance for the target class,\n      a Python callable / lambda that will return a reference to the\n      class or :class:`_orm.Mapper` when called, and finally a string\n      name for the class, which will be resolved from the\n      :class:`_orm.registry` in use in order to locate the class, e.g.::\n\n            class SomeClass(Base):\n                # ...\n\n                related = relationship(\"RelatedClass\")\n\n      The :paramref:`_orm.relationship.argument` may also be omitted from the\n      :func:`_orm.relationship` construct entirely, and instead placed inside\n      a :class:`_orm.Mapped` annotation on the left side, which should\n      include a Python collection type if the relationship is expected\n      to be a collection, such as::\n\n            class SomeClass(Base):\n                # ...\n\n                related_items: Mapped[List[\"RelatedItem\"]] = relationship()\n\n      Or for a many-to-one or one-to-one relationship::\n\n            class SomeClass(Base):\n                # ...\n\n                related_item: Mapped[\"RelatedItem\"] = relationship()\n\n      .. seealso::\n\n        :ref:`orm_declarative_properties` - further detail\n        on relationship configuration when using Declarative.\n\n    :param secondary:\n      For a many-to-many relationship, specifies the intermediary\n      table, and is typically an instance of :class:`_schema.Table`.\n      In less common circumstances, the argument may also be specified\n      as an :class:`_expression.Alias` construct, or even a\n      :class:`_expression.Join` construct.\n\n      :paramref:`_orm.relationship.secondary` may\n      also be passed as a callable function which is evaluated at\n      mapper initialization time.  When using Declarative, it may also\n      be a string argument noting the name of a :class:`_schema.Table`\n      that is\n      present in the :class:`_schema.MetaData`\n      collection associated with the\n      parent-mapped :class:`_schema.Table`.\n\n      .. warning:: When passed as a Python-evaluable string, the\n         argument is interpreted using Python's ``eval()`` function.\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\n         See :ref:`declarative_relationship_eval` for details on\n         declarative evaluation of :func:`_orm.relationship` arguments.\n\n      The :paramref:`_orm.relationship.secondary` keyword argument is\n      typically applied in the case where the intermediary\n      :class:`_schema.Table`\n      is not otherwise expressed in any direct class mapping. If the\n      \"secondary\" table is also explicitly mapped elsewhere (e.g. as in\n      :ref:`association_pattern`), one should consider applying the\n      :paramref:`_orm.relationship.viewonly` flag so that this\n      :func:`_orm.relationship`\n      is not used for persistence operations which\n      may conflict with those of the association object pattern.\n\n      .. seealso::\n\n          :ref:`relationships_many_to_many` - Reference example of \"many\n          to many\".\n\n          :ref:`self_referential_many_to_many` - Specifics on using\n          many-to-many in a self-referential case.\n\n          :ref:`declarative_many_to_many` - Additional options when using\n          Declarative.\n\n          :ref:`association_pattern` - an alternative to\n          :paramref:`_orm.relationship.secondary`\n          when composing association\n          table relationships, allowing additional attributes to be\n          specified on the association table.\n\n          :ref:`composite_secondary_join` - a lesser-used pattern which\n          in some cases can enable complex :func:`_orm.relationship` SQL\n          conditions to be used.\n\n    :param active_history=False:\n      When ``True``, indicates that the \"previous\" value for a\n      many-to-one reference should be loaded when replaced, if\n      not already loaded. Normally, history tracking logic for\n      simple many-to-ones only needs to be aware of the \"new\"\n      value in order to perform a flush. This flag is available\n      for applications that make use of\n      :func:`.attributes.get_history` which also need to know\n      the \"previous\" value of the attribute.\n\n    :param backref:\n      A reference to a string relationship name, or a :func:`_orm.backref`\n      construct, which will be used to automatically generate a new\n      :func:`_orm.relationship` on the related class, which then refers to this\n      one using a bi-directional :paramref:`_orm.relationship.back_populates`\n      configuration.\n\n      In modern Python, explicit use of :func:`_orm.relationship`\n      with :paramref:`_orm.relationship.back_populates` should be preferred,\n      as it is more robust in terms of mapper configuration as well as\n      more conceptually straightforward.  It also integrates with\n      new :pep:`484` typing features introduced in SQLAlchemy 2.0 which\n      is not possible with dynamically generated attributes.\n\n      .. seealso::\n\n        :ref:`relationships_backref` - notes on using\n        :paramref:`_orm.relationship.backref`\n\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\n        presents an overview of bi-directional relationship configuration\n        and behaviors using :paramref:`_orm.relationship.back_populates`\n\n        :func:`.backref` - allows control over :func:`_orm.relationship`\n        configuration when using :paramref:`_orm.relationship.backref`.\n\n\n    :param back_populates:\n      Indicates the name of a :func:`_orm.relationship` on the related\n      class that will be synchronized with this one.   It is usually\n      expected that the :func:`_orm.relationship` on the related class\n      also refer to this one.  This allows objects on both sides of\n      each :func:`_orm.relationship` to synchronize in-Python state\n      changes and also provides directives to the :term:`unit of work`\n      flush process how changes along these relationships should\n      be persisted.\n\n      .. seealso::\n\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\n        presents an overview of bi-directional relationship configuration\n        and behaviors.\n\n        :ref:`relationship_patterns` - includes many examples of\n        :paramref:`_orm.relationship.back_populates`.\n\n        :paramref:`_orm.relationship.backref` - legacy form which allows\n        more succinct configuration, but does not support explicit typing\n\n    :param overlaps:\n       A string name or comma-delimited set of names of other relationships\n       on either this mapper, a descendant mapper, or a target mapper with\n       which this relationship may write to the same foreign keys upon\n       persistence.   The only effect this has is to eliminate the\n       warning that this relationship will conflict with another upon\n       persistence.   This is used for such relationships that are truly\n       capable of conflicting with each other on write, but the application\n       will ensure that no such conflicts occur.\n\n       .. versionadded:: 1.4\n\n       .. seealso::\n\n            :ref:`error_qzyx` - usage example\n\n    :param cascade:\n      A comma-separated list of cascade rules which determines how\n      Session operations should be \"cascaded\" from parent to child.\n      This defaults to ``False``, which means the default cascade\n      should be used - this default cascade is ``\"save-update, merge\"``.\n\n      The available cascades are ``save-update``, ``merge``,\n      ``expunge``, ``delete``, ``delete-orphan``, and ``refresh-expire``.\n      An additional option, ``all`` indicates shorthand for\n      ``\"save-update, merge, refresh-expire,\n      expunge, delete\"``, and is often used as in ``\"all, delete-orphan\"``\n      to indicate that related objects should follow along with the\n      parent object in all cases, and be deleted when de-associated.\n\n      .. seealso::\n\n        :ref:`unitofwork_cascades` - Full detail on each of the available\n        cascade options.\n\n    :param cascade_backrefs=False:\n      Legacy; this flag is always False.\n\n      .. versionchanged:: 2.0 \"cascade_backrefs\" functionality has been\n         removed.\n\n    :param collection_class:\n      A class or callable that returns a new list-holding object. will\n      be used in place of a plain list for storing elements.\n\n      .. seealso::\n\n        :ref:`custom_collections` - Introductory documentation and\n        examples.\n\n    :param comparator_factory:\n      A class which extends :class:`.Relationship.Comparator`\n      which provides custom SQL clause generation for comparison\n      operations.\n\n      .. seealso::\n\n        :class:`.PropComparator` - some detail on redefining comparators\n        at this level.\n\n        :ref:`custom_comparators` - Brief intro to this feature.\n\n\n    :param distinct_target_key=None:\n      Indicate if a \"subquery\" eager load should apply the DISTINCT\n      keyword to the innermost SELECT statement.  When left as ``None``,\n      the DISTINCT keyword will be applied in those cases when the target\n      columns do not comprise the full primary key of the target table.\n      When set to ``True``, the DISTINCT keyword is applied to the\n      innermost SELECT unconditionally.\n\n      It may be desirable to set this flag to False when the DISTINCT is\n      reducing performance of the innermost subquery beyond that of what\n      duplicate innermost rows may be causing.\n\n      .. seealso::\n\n        :ref:`loading_toplevel` - includes an introduction to subquery\n        eager loading.\n\n    :param doc:\n      Docstring which will be applied to the resulting descriptor.\n\n    :param foreign_keys:\n\n      A list of columns which are to be used as \"foreign key\"\n      columns, or columns which refer to the value in a remote\n      column, within the context of this :func:`_orm.relationship`\n      object's :paramref:`_orm.relationship.primaryjoin` condition.\n      That is, if the :paramref:`_orm.relationship.primaryjoin`\n      condition of this :func:`_orm.relationship` is ``a.id ==\n      b.a_id``, and the values in ``b.a_id`` are required to be\n      present in ``a.id``, then the \"foreign key\" column of this\n      :func:`_orm.relationship` is ``b.a_id``.\n\n      In normal cases, the :paramref:`_orm.relationship.foreign_keys`\n      parameter is **not required.** :func:`_orm.relationship` will\n      automatically determine which columns in the\n      :paramref:`_orm.relationship.primaryjoin` condition are to be\n      considered \"foreign key\" columns based on those\n      :class:`_schema.Column` objects that specify\n      :class:`_schema.ForeignKey`,\n      or are otherwise listed as referencing columns in a\n      :class:`_schema.ForeignKeyConstraint` construct.\n      :paramref:`_orm.relationship.foreign_keys` is only needed when:\n\n        1. There is more than one way to construct a join from the local\n           table to the remote table, as there are multiple foreign key\n           references present.  Setting ``foreign_keys`` will limit the\n           :func:`_orm.relationship`\n           to consider just those columns specified\n           here as \"foreign\".\n\n        2. The :class:`_schema.Table` being mapped does not actually have\n           :class:`_schema.ForeignKey` or\n           :class:`_schema.ForeignKeyConstraint`\n           constructs present, often because the table\n           was reflected from a database that does not support foreign key\n           reflection (MySQL MyISAM).\n\n        3. The :paramref:`_orm.relationship.primaryjoin`\n           argument is used to\n           construct a non-standard join condition, which makes use of\n           columns or expressions that do not normally refer to their\n           \"parent\" column, such as a join condition expressed by a\n           complex comparison using a SQL function.\n\n      The :func:`_orm.relationship` construct will raise informative\n      error messages that suggest the use of the\n      :paramref:`_orm.relationship.foreign_keys` parameter when\n      presented with an ambiguous condition.   In typical cases,\n      if :func:`_orm.relationship` doesn't raise any exceptions, the\n      :paramref:`_orm.relationship.foreign_keys` parameter is usually\n      not needed.\n\n      :paramref:`_orm.relationship.foreign_keys` may also be passed as a\n      callable function which is evaluated at mapper initialization time,\n      and may be passed as a Python-evaluable string when using\n      Declarative.\n\n      .. warning:: When passed as a Python-evaluable string, the\n         argument is interpreted using Python's ``eval()`` function.\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\n         See :ref:`declarative_relationship_eval` for details on\n         declarative evaluation of :func:`_orm.relationship` arguments.\n\n      .. seealso::\n\n        :ref:`relationship_foreign_keys`\n\n        :ref:`relationship_custom_foreign`\n\n        :func:`.foreign` - allows direct annotation of the \"foreign\"\n        columns within a :paramref:`_orm.relationship.primaryjoin`\n        condition.\n\n    :param info: Optional data dictionary which will be populated into the\n        :attr:`.MapperProperty.info` attribute of this object.\n\n    :param innerjoin=False:\n      When ``True``, joined eager loads will use an inner join to join\n      against related tables instead of an outer join.  The purpose\n      of this option is generally one of performance, as inner joins\n      generally perform better than outer joins.\n\n      This flag can be set to ``True`` when the relationship references an\n      object via many-to-one using local foreign keys that are not\n      nullable, or when the reference is one-to-one or a collection that\n      is guaranteed to have one or at least one entry.\n\n      The option supports the same \"nested\" and \"unnested\" options as\n      that of :paramref:`_orm.joinedload.innerjoin`.  See that flag\n      for details on nested / unnested behaviors.\n\n      .. seealso::\n\n        :paramref:`_orm.joinedload.innerjoin` - the option as specified by\n        loader option, including detail on nesting behavior.\n\n        :ref:`what_kind_of_loading` - Discussion of some details of\n        various loader options.\n\n\n    :param join_depth:\n      When non-``None``, an integer value indicating how many levels\n      deep \"eager\" loaders should join on a self-referring or cyclical\n      relationship.  The number counts how many times the same Mapper\n      shall be present in the loading condition along a particular join\n      branch.  When left at its default of ``None``, eager loaders\n      will stop chaining when they encounter a the same target mapper\n      which is already higher up in the chain.  This option applies\n      both to joined- and subquery- eager loaders.\n\n      .. seealso::\n\n        :ref:`self_referential_eager_loading` - Introductory documentation\n        and examples.\n\n    :param lazy='select': specifies\n      How the related items should be loaded.  Default value is\n      ``select``.  Values include:\n\n      * ``select`` - items should be loaded lazily when the property is\n        first accessed, using a separate SELECT statement, or identity map\n        fetch for simple many-to-one references.\n\n      * ``immediate`` - items should be loaded as the parents are loaded,\n        using a separate SELECT statement, or identity map fetch for\n        simple many-to-one references.\n\n      * ``joined`` - items should be loaded \"eagerly\" in the same query as\n        that of the parent, using a JOIN or LEFT OUTER JOIN.  Whether\n        the join is \"outer\" or not is determined by the\n        :paramref:`_orm.relationship.innerjoin` parameter.\n\n      * ``subquery`` - items should be loaded \"eagerly\" as the parents are\n        loaded, using one additional SQL statement, which issues a JOIN to\n        a subquery of the original statement, for each collection\n        requested.\n\n      * ``selectin`` - items should be loaded \"eagerly\" as the parents\n        are loaded, using one or more additional SQL statements, which\n        issues a JOIN to the immediate parent object, specifying primary\n        key identifiers using an IN clause.\n\n      * ``noload`` - no loading should occur at any time.  The related\n        collection will remain empty.   The ``noload`` strategy is not\n        recommended for general use.  For a general use \"never load\"\n        approach, see :ref:`write_only_relationship`\n\n      * ``raise`` - lazy loading is disallowed; accessing\n        the attribute, if its value were not already loaded via eager\n        loading, will raise an :exc:`~sqlalchemy.exc.InvalidRequestError`.\n        This strategy can be used when objects are to be detached from\n        their attached :class:`.Session` after they are loaded.\n\n      * ``raise_on_sql`` - lazy loading that emits SQL is disallowed;\n        accessing the attribute, if its value were not already loaded via\n        eager loading, will raise an\n        :exc:`~sqlalchemy.exc.InvalidRequestError`, **if the lazy load\n        needs to emit SQL**.  If the lazy load can pull the related value\n        from the identity map or determine that it should be None, the\n        value is loaded.  This strategy can be used when objects will\n        remain associated with the attached :class:`.Session`, however\n        additional SELECT statements should be blocked.\n\n      * ``write_only`` - the attribute will be configured with a special\n        \"virtual collection\" that may receive\n        :meth:`_orm.WriteOnlyCollection.add` and\n        :meth:`_orm.WriteOnlyCollection.remove` commands to add or remove\n        individual objects, but will not under any circumstances load or\n        iterate the full set of objects from the database directly. Instead,\n        methods such as :meth:`_orm.WriteOnlyCollection.select`,\n        :meth:`_orm.WriteOnlyCollection.insert`,\n        :meth:`_orm.WriteOnlyCollection.update` and\n        :meth:`_orm.WriteOnlyCollection.delete` are provided which generate SQL\n        constructs that may be used to load and modify rows in bulk. Used for\n        large collections that are never appropriate to load at once into\n        memory.\n\n        The ``write_only`` loader style is configured automatically when\n        the :class:`_orm.WriteOnlyMapped` annotation is provided on the\n        left hand side within a Declarative mapping.  See the section\n        :ref:`write_only_relationship` for examples.\n\n        .. versionadded:: 2.0\n\n        .. seealso::\n\n            :ref:`write_only_relationship` - in the :ref:`queryguide_toplevel`\n\n      * ``dynamic`` - the attribute will return a pre-configured\n        :class:`_query.Query` object for all read\n        operations, onto which further filtering operations can be\n        applied before iterating the results.\n\n        The ``dynamic`` loader style is configured automatically when\n        the :class:`_orm.DynamicMapped` annotation is provided on the\n        left hand side within a Declarative mapping.  See the section\n        :ref:`dynamic_relationship` for examples.\n\n        .. legacy::  The \"dynamic\" lazy loader strategy is the legacy form of\n           what is now the \"write_only\" strategy described in the section\n           :ref:`write_only_relationship`.\n\n        .. seealso::\n\n            :ref:`dynamic_relationship` - in the :ref:`queryguide_toplevel`\n\n            :ref:`write_only_relationship` - more generally useful approach\n            for large collections that should not fully load into memory\n\n      * True - a synonym for 'select'\n\n      * False - a synonym for 'joined'\n\n      * None - a synonym for 'noload'\n\n      .. seealso::\n\n        :ref:`orm_queryguide_relationship_loaders` - Full documentation on\n        relationship loader configuration in the :ref:`queryguide_toplevel`.\n\n\n    :param load_on_pending=False:\n      Indicates loading behavior for transient or pending parent objects.\n\n      When set to ``True``, causes the lazy-loader to\n      issue a query for a parent object that is not persistent, meaning it\n      has never been flushed.  This may take effect for a pending object\n      when autoflush is disabled, or for a transient object that has been\n      \"attached\" to a :class:`.Session` but is not part of its pending\n      collection.\n\n      The :paramref:`_orm.relationship.load_on_pending`\n      flag does not improve\n      behavior when the ORM is used normally - object references should be\n      constructed at the object level, not at the foreign key level, so\n      that they are present in an ordinary way before a flush proceeds.\n      This flag is not not intended for general use.\n\n      .. seealso::\n\n          :meth:`.Session.enable_relationship_loading` - this method\n          establishes \"load on pending\" behavior for the whole object, and\n          also allows loading on objects that remain transient or\n          detached.\n\n    :param order_by:\n      Indicates the ordering that should be applied when loading these\n      items.  :paramref:`_orm.relationship.order_by`\n      is expected to refer to\n      one of the :class:`_schema.Column`\n      objects to which the target class is\n      mapped, or the attribute itself bound to the target class which\n      refers to the column.\n\n      :paramref:`_orm.relationship.order_by`\n      may also be passed as a callable\n      function which is evaluated at mapper initialization time, and may\n      be passed as a Python-evaluable string when using Declarative.\n\n      .. warning:: When passed as a Python-evaluable string, the\n         argument is interpreted using Python's ``eval()`` function.\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\n         See :ref:`declarative_relationship_eval` for details on\n         declarative evaluation of :func:`_orm.relationship` arguments.\n\n    :param passive_deletes=False:\n       Indicates loading behavior during delete operations.\n\n       A value of True indicates that unloaded child items should not\n       be loaded during a delete operation on the parent.  Normally,\n       when a parent item is deleted, all child items are loaded so\n       that they can either be marked as deleted, or have their\n       foreign key to the parent set to NULL.  Marking this flag as\n       True usually implies an ON DELETE <CASCADE|SET NULL> rule is in\n       place which will handle updating/deleting child rows on the\n       database side.\n\n       Additionally, setting the flag to the string value 'all' will\n       disable the \"nulling out\" of the child foreign keys, when the parent\n       object is deleted and there is no delete or delete-orphan cascade\n       enabled.  This is typically used when a triggering or error raise\n       scenario is in place on the database side.  Note that the foreign\n       key attributes on in-session child objects will not be changed after\n       a flush occurs so this is a very special use-case setting.\n       Additionally, the \"nulling out\" will still occur if the child\n       object is de-associated with the parent.\n\n       .. seealso::\n\n            :ref:`passive_deletes` - Introductory documentation\n            and examples.\n\n    :param passive_updates=True:\n      Indicates the persistence behavior to take when a referenced\n      primary key value changes in place, indicating that the referencing\n      foreign key columns will also need their value changed.\n\n      When True, it is assumed that ``ON UPDATE CASCADE`` is configured on\n      the foreign key in the database, and that the database will\n      handle propagation of an UPDATE from a source column to\n      dependent rows.  When False, the SQLAlchemy\n      :func:`_orm.relationship`\n      construct will attempt to emit its own UPDATE statements to\n      modify related targets.  However note that SQLAlchemy **cannot**\n      emit an UPDATE for more than one level of cascade.  Also,\n      setting this flag to False is not compatible in the case where\n      the database is in fact enforcing referential integrity, unless\n      those constraints are explicitly \"deferred\", if the target backend\n      supports it.\n\n      It is highly advised that an application which is employing\n      mutable primary keys keeps ``passive_updates`` set to True,\n      and instead uses the referential integrity features of the database\n      itself in order to handle the change efficiently and fully.\n\n      .. seealso::\n\n          :ref:`passive_updates` - Introductory documentation and\n          examples.\n\n          :paramref:`.mapper.passive_updates` - a similar flag which\n          takes effect for joined-table inheritance mappings.\n\n    :param post_update:\n      This indicates that the relationship should be handled by a\n      second UPDATE statement after an INSERT or before a\n      DELETE. This flag is used to handle saving bi-directional\n      dependencies between two individual rows (i.e. each row\n      references the other), where it would otherwise be impossible to\n      INSERT or DELETE both rows fully since one row exists before the\n      other. Use this flag when a particular mapping arrangement will\n      incur two rows that are dependent on each other, such as a table\n      that has a one-to-many relationship to a set of child rows, and\n      also has a column that references a single child row within that\n      list (i.e. both tables contain a foreign key to each other). If\n      a flush operation returns an error that a \"cyclical\n      dependency\" was detected, this is a cue that you might want to\n      use :paramref:`_orm.relationship.post_update` to \"break\" the cycle.\n\n      .. seealso::\n\n          :ref:`post_update` - Introductory documentation and examples.\n\n    :param primaryjoin:\n      A SQL expression that will be used as the primary\n      join of the child object against the parent object, or in a\n      many-to-many relationship the join of the parent object to the\n      association table. By default, this value is computed based on the\n      foreign key relationships of the parent and child tables (or\n      association table).\n\n      :paramref:`_orm.relationship.primaryjoin` may also be passed as a\n      callable function which is evaluated at mapper initialization time,\n      and may be passed as a Python-evaluable string when using\n      Declarative.\n\n      .. warning:: When passed as a Python-evaluable string, the\n         argument is interpreted using Python's ``eval()`` function.\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\n         See :ref:`declarative_relationship_eval` for details on\n         declarative evaluation of :func:`_orm.relationship` arguments.\n\n      .. seealso::\n\n          :ref:`relationship_primaryjoin`\n\n    :param remote_side:\n      Used for self-referential relationships, indicates the column or\n      list of columns that form the \"remote side\" of the relationship.\n\n      :paramref:`_orm.relationship.remote_side` may also be passed as a\n      callable function which is evaluated at mapper initialization time,\n      and may be passed as a Python-evaluable string when using\n      Declarative.\n\n      .. warning:: When passed as a Python-evaluable string, the\n         argument is interpreted using Python's ``eval()`` function.\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\n         See :ref:`declarative_relationship_eval` for details on\n         declarative evaluation of :func:`_orm.relationship` arguments.\n\n      .. seealso::\n\n        :ref:`self_referential` - in-depth explanation of how\n        :paramref:`_orm.relationship.remote_side`\n        is used to configure self-referential relationships.\n\n        :func:`.remote` - an annotation function that accomplishes the\n        same purpose as :paramref:`_orm.relationship.remote_side`,\n        typically\n        when a custom :paramref:`_orm.relationship.primaryjoin` condition\n        is used.\n\n    :param query_class:\n      A :class:`_query.Query`\n      subclass that will be used internally by the\n      ``AppenderQuery`` returned by a \"dynamic\" relationship, that\n      is, a relationship that specifies ``lazy=\"dynamic\"`` or was\n      otherwise constructed using the :func:`_orm.dynamic_loader`\n      function.\n\n      .. seealso::\n\n        :ref:`dynamic_relationship` - Introduction to \"dynamic\"\n        relationship loaders.\n\n    :param secondaryjoin:\n      A SQL expression that will be used as the join of\n      an association table to the child object. By default, this value is\n      computed based on the foreign key relationships of the association\n      and child tables.\n\n      :paramref:`_orm.relationship.secondaryjoin` may also be passed as a\n      callable function which is evaluated at mapper initialization time,\n      and may be passed as a Python-evaluable string when using\n      Declarative.\n\n      .. warning:: When passed as a Python-evaluable string, the\n         argument is interpreted using Python's ``eval()`` function.\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\n         See :ref:`declarative_relationship_eval` for details on\n         declarative evaluation of :func:`_orm.relationship` arguments.\n\n      .. seealso::\n\n          :ref:`relationship_primaryjoin`\n\n    :param single_parent:\n      When True, installs a validator which will prevent objects\n      from being associated with more than one parent at a time.\n      This is used for many-to-one or many-to-many relationships that\n      should be treated either as one-to-one or one-to-many.  Its usage\n      is optional, except for :func:`_orm.relationship` constructs which\n      are many-to-one or many-to-many and also\n      specify the ``delete-orphan`` cascade option.  The\n      :func:`_orm.relationship` construct itself will raise an error\n      instructing when this option is required.\n\n      .. seealso::\n\n        :ref:`unitofwork_cascades` - includes detail on when the\n        :paramref:`_orm.relationship.single_parent`\n        flag may be appropriate.\n\n    :param uselist:\n      A boolean that indicates if this property should be loaded as a\n      list or a scalar. In most cases, this value is determined\n      automatically by :func:`_orm.relationship` at mapper configuration\n      time.  When using explicit :class:`_orm.Mapped` annotations,\n      :paramref:`_orm.relationship.uselist` may be derived from the\n      whether or not the annotation within :class:`_orm.Mapped` contains\n      a collection class.\n      Otherwise, :paramref:`_orm.relationship.uselist` may be derived from\n      the type and direction\n      of the relationship - one to many forms a list, many to one\n      forms a scalar, many to many is a list. If a scalar is desired\n      where normally a list would be present, such as a bi-directional\n      one-to-one relationship, use an appropriate :class:`_orm.Mapped`\n      annotation or set :paramref:`_orm.relationship.uselist` to False.\n\n      The :paramref:`_orm.relationship.uselist`\n      flag is also available on an\n      existing :func:`_orm.relationship`\n      construct as a read-only attribute,\n      which can be used to determine if this :func:`_orm.relationship`\n      deals\n      with collections or scalar attributes::\n\n          >>> User.addresses.property.uselist\n          True\n\n      .. seealso::\n\n          :ref:`relationships_one_to_one` - Introduction to the \"one to\n          one\" relationship pattern, which is typically when an alternate\n          setting for :paramref:`_orm.relationship.uselist` is involved.\n\n    :param viewonly=False:\n      When set to ``True``, the relationship is used only for loading\n      objects, and not for any persistence operation.  A\n      :func:`_orm.relationship` which specifies\n      :paramref:`_orm.relationship.viewonly` can work\n      with a wider range of SQL operations within the\n      :paramref:`_orm.relationship.primaryjoin` condition, including\n      operations that feature the use of a variety of comparison operators\n      as well as SQL functions such as :func:`_expression.cast`.  The\n      :paramref:`_orm.relationship.viewonly`\n      flag is also of general use when defining any kind of\n      :func:`_orm.relationship` that doesn't represent\n      the full set of related objects, to prevent modifications of the\n      collection from resulting in persistence operations.\n\n      When using the :paramref:`_orm.relationship.viewonly` flag in\n      conjunction with backrefs, the originating relationship for a\n      particular state change will not produce state changes within the\n      viewonly relationship.   This is the behavior implied by\n      :paramref:`_orm.relationship.sync_backref` being set to False.\n\n      .. versionchanged:: 1.3.17 - the\n         :paramref:`_orm.relationship.sync_backref` flag is set to False\n             when using viewonly in conjunction with backrefs.\n\n      .. seealso::\n\n        :paramref:`_orm.relationship.sync_backref`\n\n    :param sync_backref:\n      A boolean that enables the events used to synchronize the in-Python\n      attributes when this relationship is target of either\n      :paramref:`_orm.relationship.backref` or\n      :paramref:`_orm.relationship.back_populates`.\n\n      Defaults to ``None``, which indicates that an automatic value should\n      be selected based on the value of the\n      :paramref:`_orm.relationship.viewonly` flag.  When left at its\n      default, changes in state will be back-populated only if neither\n      sides of a relationship is viewonly.\n\n      .. versionadded:: 1.3.17\n\n      .. versionchanged:: 1.4 - A relationship that specifies\n         :paramref:`_orm.relationship.viewonly` automatically implies\n         that :paramref:`_orm.relationship.sync_backref` is ``False``.\n\n      .. seealso::\n\n        :paramref:`_orm.relationship.viewonly`\n\n    :param omit_join:\n      Allows manual control over the \"selectin\" automatic join\n      optimization.  Set to ``False`` to disable the \"omit join\" feature\n      added in SQLAlchemy 1.3; or leave as ``None`` to leave automatic\n      optimization in place.\n\n      .. note:: This flag may only be set to ``False``.   It is not\n         necessary to set it to ``True`` as the \"omit_join\" optimization is\n         automatically detected; if it is not detected, then the\n         optimization is not supported.\n\n         .. versionchanged:: 1.3.11  setting ``omit_join`` to True will now\n            emit a warning as this was not the intended use of this flag.\n\n      .. versionadded:: 1.3\n\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\n     specifies if the mapped attribute should be part of the ``__init__()``\n     method as generated by the dataclass process.\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\n     specifies if the mapped attribute should be part of the ``__repr__()``\n     method as generated by the dataclass process.\n    :param default_factory: Specific to\n     :ref:`orm_declarative_native_dataclasses`,\n     specifies a default-value generation function that will take place\n     as part of the ``__init__()``\n     method as generated by the dataclass process.\n    :param compare: Specific to\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\n     should be included in comparison operations when generating the\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\n\n     .. versionadded:: 2.0.0b4\n\n    :param kw_only: Specific to\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\n     should be marked as keyword-only when generating the ``__init__()``.\n\n\n    \"\"\"\n    return Relationship(argument, secondary=secondary, uselist=uselist, collection_class=collection_class, primaryjoin=primaryjoin, secondaryjoin=secondaryjoin, back_populates=back_populates, order_by=order_by, backref=backref, overlaps=overlaps, post_update=post_update, cascade=cascade, viewonly=viewonly, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), lazy=lazy, passive_deletes=passive_deletes, passive_updates=passive_updates, active_history=active_history, enable_typechecks=enable_typechecks, foreign_keys=foreign_keys, remote_side=remote_side, join_depth=join_depth, comparator_factory=comparator_factory, single_parent=single_parent, innerjoin=innerjoin, distinct_target_key=distinct_target_key, load_on_pending=load_on_pending, query_class=query_class, info=info, omit_join=omit_join, sync_backref=sync_backref, **kw)",
        "mutated": [
            "def relationship(argument: Optional[_RelationshipArgumentType[Any]]=None, secondary: Optional[_RelationshipSecondaryArgument]=None, *, uselist: Optional[bool]=None, collection_class: Optional[Union[Type[Collection[Any]], Callable[[], Collection[Any]]]]=None, primaryjoin: Optional[_RelationshipJoinConditionArgument]=None, secondaryjoin: Optional[_RelationshipJoinConditionArgument]=None, back_populates: Optional[str]=None, order_by: _ORMOrderByArgument=False, backref: Optional[ORMBackrefArgument]=None, overlaps: Optional[str]=None, post_update: bool=False, cascade: str='save-update, merge', viewonly: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, lazy: _LazyLoadArgumentType='select', passive_deletes: Union[Literal['all'], bool]=False, passive_updates: bool=True, active_history: bool=False, enable_typechecks: bool=True, foreign_keys: Optional[_ORMColCollectionArgument]=None, remote_side: Optional[_ORMColCollectionArgument]=None, join_depth: Optional[int]=None, comparator_factory: Optional[Type[RelationshipProperty.Comparator[Any]]]=None, single_parent: bool=False, innerjoin: bool=False, distinct_target_key: Optional[bool]=None, load_on_pending: bool=False, query_class: Optional[Type[Query[Any]]]=None, info: Optional[_InfoType]=None, omit_join: Literal[None, False]=None, sync_backref: Optional[bool]=None, **kw: Any) -> Relationship[Any]:\n    if False:\n        i = 10\n    'Provide a relationship between two mapped classes.\\n\\n    This corresponds to a parent-child or associative table relationship.\\n    The constructed class is an instance of :class:`.Relationship`.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - tutorial introduction\\n        to :func:`_orm.relationship` in the :ref:`unified_tutorial`\\n\\n        :ref:`relationship_config_toplevel` - narrative documentation\\n\\n    :param argument:\\n      This parameter refers to the class that is to be related.   It\\n      accepts several forms, including a direct reference to the target\\n      class itself, the :class:`_orm.Mapper` instance for the target class,\\n      a Python callable / lambda that will return a reference to the\\n      class or :class:`_orm.Mapper` when called, and finally a string\\n      name for the class, which will be resolved from the\\n      :class:`_orm.registry` in use in order to locate the class, e.g.::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related = relationship(\"RelatedClass\")\\n\\n      The :paramref:`_orm.relationship.argument` may also be omitted from the\\n      :func:`_orm.relationship` construct entirely, and instead placed inside\\n      a :class:`_orm.Mapped` annotation on the left side, which should\\n      include a Python collection type if the relationship is expected\\n      to be a collection, such as::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_items: Mapped[List[\"RelatedItem\"]] = relationship()\\n\\n      Or for a many-to-one or one-to-one relationship::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_item: Mapped[\"RelatedItem\"] = relationship()\\n\\n      .. seealso::\\n\\n        :ref:`orm_declarative_properties` - further detail\\n        on relationship configuration when using Declarative.\\n\\n    :param secondary:\\n      For a many-to-many relationship, specifies the intermediary\\n      table, and is typically an instance of :class:`_schema.Table`.\\n      In less common circumstances, the argument may also be specified\\n      as an :class:`_expression.Alias` construct, or even a\\n      :class:`_expression.Join` construct.\\n\\n      :paramref:`_orm.relationship.secondary` may\\n      also be passed as a callable function which is evaluated at\\n      mapper initialization time.  When using Declarative, it may also\\n      be a string argument noting the name of a :class:`_schema.Table`\\n      that is\\n      present in the :class:`_schema.MetaData`\\n      collection associated with the\\n      parent-mapped :class:`_schema.Table`.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      The :paramref:`_orm.relationship.secondary` keyword argument is\\n      typically applied in the case where the intermediary\\n      :class:`_schema.Table`\\n      is not otherwise expressed in any direct class mapping. If the\\n      \"secondary\" table is also explicitly mapped elsewhere (e.g. as in\\n      :ref:`association_pattern`), one should consider applying the\\n      :paramref:`_orm.relationship.viewonly` flag so that this\\n      :func:`_orm.relationship`\\n      is not used for persistence operations which\\n      may conflict with those of the association object pattern.\\n\\n      .. seealso::\\n\\n          :ref:`relationships_many_to_many` - Reference example of \"many\\n          to many\".\\n\\n          :ref:`self_referential_many_to_many` - Specifics on using\\n          many-to-many in a self-referential case.\\n\\n          :ref:`declarative_many_to_many` - Additional options when using\\n          Declarative.\\n\\n          :ref:`association_pattern` - an alternative to\\n          :paramref:`_orm.relationship.secondary`\\n          when composing association\\n          table relationships, allowing additional attributes to be\\n          specified on the association table.\\n\\n          :ref:`composite_secondary_join` - a lesser-used pattern which\\n          in some cases can enable complex :func:`_orm.relationship` SQL\\n          conditions to be used.\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      many-to-one reference should be loaded when replaced, if\\n      not already loaded. Normally, history tracking logic for\\n      simple many-to-ones only needs to be aware of the \"new\"\\n      value in order to perform a flush. This flag is available\\n      for applications that make use of\\n      :func:`.attributes.get_history` which also need to know\\n      the \"previous\" value of the attribute.\\n\\n    :param backref:\\n      A reference to a string relationship name, or a :func:`_orm.backref`\\n      construct, which will be used to automatically generate a new\\n      :func:`_orm.relationship` on the related class, which then refers to this\\n      one using a bi-directional :paramref:`_orm.relationship.back_populates`\\n      configuration.\\n\\n      In modern Python, explicit use of :func:`_orm.relationship`\\n      with :paramref:`_orm.relationship.back_populates` should be preferred,\\n      as it is more robust in terms of mapper configuration as well as\\n      more conceptually straightforward.  It also integrates with\\n      new :pep:`484` typing features introduced in SQLAlchemy 2.0 which\\n      is not possible with dynamically generated attributes.\\n\\n      .. seealso::\\n\\n        :ref:`relationships_backref` - notes on using\\n        :paramref:`_orm.relationship.backref`\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors using :paramref:`_orm.relationship.back_populates`\\n\\n        :func:`.backref` - allows control over :func:`_orm.relationship`\\n        configuration when using :paramref:`_orm.relationship.backref`.\\n\\n\\n    :param back_populates:\\n      Indicates the name of a :func:`_orm.relationship` on the related\\n      class that will be synchronized with this one.   It is usually\\n      expected that the :func:`_orm.relationship` on the related class\\n      also refer to this one.  This allows objects on both sides of\\n      each :func:`_orm.relationship` to synchronize in-Python state\\n      changes and also provides directives to the :term:`unit of work`\\n      flush process how changes along these relationships should\\n      be persisted.\\n\\n      .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors.\\n\\n        :ref:`relationship_patterns` - includes many examples of\\n        :paramref:`_orm.relationship.back_populates`.\\n\\n        :paramref:`_orm.relationship.backref` - legacy form which allows\\n        more succinct configuration, but does not support explicit typing\\n\\n    :param overlaps:\\n       A string name or comma-delimited set of names of other relationships\\n       on either this mapper, a descendant mapper, or a target mapper with\\n       which this relationship may write to the same foreign keys upon\\n       persistence.   The only effect this has is to eliminate the\\n       warning that this relationship will conflict with another upon\\n       persistence.   This is used for such relationships that are truly\\n       capable of conflicting with each other on write, but the application\\n       will ensure that no such conflicts occur.\\n\\n       .. versionadded:: 1.4\\n\\n       .. seealso::\\n\\n            :ref:`error_qzyx` - usage example\\n\\n    :param cascade:\\n      A comma-separated list of cascade rules which determines how\\n      Session operations should be \"cascaded\" from parent to child.\\n      This defaults to ``False``, which means the default cascade\\n      should be used - this default cascade is ``\"save-update, merge\"``.\\n\\n      The available cascades are ``save-update``, ``merge``,\\n      ``expunge``, ``delete``, ``delete-orphan``, and ``refresh-expire``.\\n      An additional option, ``all`` indicates shorthand for\\n      ``\"save-update, merge, refresh-expire,\\n      expunge, delete\"``, and is often used as in ``\"all, delete-orphan\"``\\n      to indicate that related objects should follow along with the\\n      parent object in all cases, and be deleted when de-associated.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - Full detail on each of the available\\n        cascade options.\\n\\n    :param cascade_backrefs=False:\\n      Legacy; this flag is always False.\\n\\n      .. versionchanged:: 2.0 \"cascade_backrefs\" functionality has been\\n         removed.\\n\\n    :param collection_class:\\n      A class or callable that returns a new list-holding object. will\\n      be used in place of a plain list for storing elements.\\n\\n      .. seealso::\\n\\n        :ref:`custom_collections` - Introductory documentation and\\n        examples.\\n\\n    :param comparator_factory:\\n      A class which extends :class:`.Relationship.Comparator`\\n      which provides custom SQL clause generation for comparison\\n      operations.\\n\\n      .. seealso::\\n\\n        :class:`.PropComparator` - some detail on redefining comparators\\n        at this level.\\n\\n        :ref:`custom_comparators` - Brief intro to this feature.\\n\\n\\n    :param distinct_target_key=None:\\n      Indicate if a \"subquery\" eager load should apply the DISTINCT\\n      keyword to the innermost SELECT statement.  When left as ``None``,\\n      the DISTINCT keyword will be applied in those cases when the target\\n      columns do not comprise the full primary key of the target table.\\n      When set to ``True``, the DISTINCT keyword is applied to the\\n      innermost SELECT unconditionally.\\n\\n      It may be desirable to set this flag to False when the DISTINCT is\\n      reducing performance of the innermost subquery beyond that of what\\n      duplicate innermost rows may be causing.\\n\\n      .. seealso::\\n\\n        :ref:`loading_toplevel` - includes an introduction to subquery\\n        eager loading.\\n\\n    :param doc:\\n      Docstring which will be applied to the resulting descriptor.\\n\\n    :param foreign_keys:\\n\\n      A list of columns which are to be used as \"foreign key\"\\n      columns, or columns which refer to the value in a remote\\n      column, within the context of this :func:`_orm.relationship`\\n      object\\'s :paramref:`_orm.relationship.primaryjoin` condition.\\n      That is, if the :paramref:`_orm.relationship.primaryjoin`\\n      condition of this :func:`_orm.relationship` is ``a.id ==\\n      b.a_id``, and the values in ``b.a_id`` are required to be\\n      present in ``a.id``, then the \"foreign key\" column of this\\n      :func:`_orm.relationship` is ``b.a_id``.\\n\\n      In normal cases, the :paramref:`_orm.relationship.foreign_keys`\\n      parameter is **not required.** :func:`_orm.relationship` will\\n      automatically determine which columns in the\\n      :paramref:`_orm.relationship.primaryjoin` condition are to be\\n      considered \"foreign key\" columns based on those\\n      :class:`_schema.Column` objects that specify\\n      :class:`_schema.ForeignKey`,\\n      or are otherwise listed as referencing columns in a\\n      :class:`_schema.ForeignKeyConstraint` construct.\\n      :paramref:`_orm.relationship.foreign_keys` is only needed when:\\n\\n        1. There is more than one way to construct a join from the local\\n           table to the remote table, as there are multiple foreign key\\n           references present.  Setting ``foreign_keys`` will limit the\\n           :func:`_orm.relationship`\\n           to consider just those columns specified\\n           here as \"foreign\".\\n\\n        2. The :class:`_schema.Table` being mapped does not actually have\\n           :class:`_schema.ForeignKey` or\\n           :class:`_schema.ForeignKeyConstraint`\\n           constructs present, often because the table\\n           was reflected from a database that does not support foreign key\\n           reflection (MySQL MyISAM).\\n\\n        3. The :paramref:`_orm.relationship.primaryjoin`\\n           argument is used to\\n           construct a non-standard join condition, which makes use of\\n           columns or expressions that do not normally refer to their\\n           \"parent\" column, such as a join condition expressed by a\\n           complex comparison using a SQL function.\\n\\n      The :func:`_orm.relationship` construct will raise informative\\n      error messages that suggest the use of the\\n      :paramref:`_orm.relationship.foreign_keys` parameter when\\n      presented with an ambiguous condition.   In typical cases,\\n      if :func:`_orm.relationship` doesn\\'t raise any exceptions, the\\n      :paramref:`_orm.relationship.foreign_keys` parameter is usually\\n      not needed.\\n\\n      :paramref:`_orm.relationship.foreign_keys` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`relationship_foreign_keys`\\n\\n        :ref:`relationship_custom_foreign`\\n\\n        :func:`.foreign` - allows direct annotation of the \"foreign\"\\n        columns within a :paramref:`_orm.relationship.primaryjoin`\\n        condition.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param innerjoin=False:\\n      When ``True``, joined eager loads will use an inner join to join\\n      against related tables instead of an outer join.  The purpose\\n      of this option is generally one of performance, as inner joins\\n      generally perform better than outer joins.\\n\\n      This flag can be set to ``True`` when the relationship references an\\n      object via many-to-one using local foreign keys that are not\\n      nullable, or when the reference is one-to-one or a collection that\\n      is guaranteed to have one or at least one entry.\\n\\n      The option supports the same \"nested\" and \"unnested\" options as\\n      that of :paramref:`_orm.joinedload.innerjoin`.  See that flag\\n      for details on nested / unnested behaviors.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.joinedload.innerjoin` - the option as specified by\\n        loader option, including detail on nesting behavior.\\n\\n        :ref:`what_kind_of_loading` - Discussion of some details of\\n        various loader options.\\n\\n\\n    :param join_depth:\\n      When non-``None``, an integer value indicating how many levels\\n      deep \"eager\" loaders should join on a self-referring or cyclical\\n      relationship.  The number counts how many times the same Mapper\\n      shall be present in the loading condition along a particular join\\n      branch.  When left at its default of ``None``, eager loaders\\n      will stop chaining when they encounter a the same target mapper\\n      which is already higher up in the chain.  This option applies\\n      both to joined- and subquery- eager loaders.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential_eager_loading` - Introductory documentation\\n        and examples.\\n\\n    :param lazy=\\'select\\': specifies\\n      How the related items should be loaded.  Default value is\\n      ``select``.  Values include:\\n\\n      * ``select`` - items should be loaded lazily when the property is\\n        first accessed, using a separate SELECT statement, or identity map\\n        fetch for simple many-to-one references.\\n\\n      * ``immediate`` - items should be loaded as the parents are loaded,\\n        using a separate SELECT statement, or identity map fetch for\\n        simple many-to-one references.\\n\\n      * ``joined`` - items should be loaded \"eagerly\" in the same query as\\n        that of the parent, using a JOIN or LEFT OUTER JOIN.  Whether\\n        the join is \"outer\" or not is determined by the\\n        :paramref:`_orm.relationship.innerjoin` parameter.\\n\\n      * ``subquery`` - items should be loaded \"eagerly\" as the parents are\\n        loaded, using one additional SQL statement, which issues a JOIN to\\n        a subquery of the original statement, for each collection\\n        requested.\\n\\n      * ``selectin`` - items should be loaded \"eagerly\" as the parents\\n        are loaded, using one or more additional SQL statements, which\\n        issues a JOIN to the immediate parent object, specifying primary\\n        key identifiers using an IN clause.\\n\\n      * ``noload`` - no loading should occur at any time.  The related\\n        collection will remain empty.   The ``noload`` strategy is not\\n        recommended for general use.  For a general use \"never load\"\\n        approach, see :ref:`write_only_relationship`\\n\\n      * ``raise`` - lazy loading is disallowed; accessing\\n        the attribute, if its value were not already loaded via eager\\n        loading, will raise an :exc:`~sqlalchemy.exc.InvalidRequestError`.\\n        This strategy can be used when objects are to be detached from\\n        their attached :class:`.Session` after they are loaded.\\n\\n      * ``raise_on_sql`` - lazy loading that emits SQL is disallowed;\\n        accessing the attribute, if its value were not already loaded via\\n        eager loading, will raise an\\n        :exc:`~sqlalchemy.exc.InvalidRequestError`, **if the lazy load\\n        needs to emit SQL**.  If the lazy load can pull the related value\\n        from the identity map or determine that it should be None, the\\n        value is loaded.  This strategy can be used when objects will\\n        remain associated with the attached :class:`.Session`, however\\n        additional SELECT statements should be blocked.\\n\\n      * ``write_only`` - the attribute will be configured with a special\\n        \"virtual collection\" that may receive\\n        :meth:`_orm.WriteOnlyCollection.add` and\\n        :meth:`_orm.WriteOnlyCollection.remove` commands to add or remove\\n        individual objects, but will not under any circumstances load or\\n        iterate the full set of objects from the database directly. Instead,\\n        methods such as :meth:`_orm.WriteOnlyCollection.select`,\\n        :meth:`_orm.WriteOnlyCollection.insert`,\\n        :meth:`_orm.WriteOnlyCollection.update` and\\n        :meth:`_orm.WriteOnlyCollection.delete` are provided which generate SQL\\n        constructs that may be used to load and modify rows in bulk. Used for\\n        large collections that are never appropriate to load at once into\\n        memory.\\n\\n        The ``write_only`` loader style is configured automatically when\\n        the :class:`_orm.WriteOnlyMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`write_only_relationship` for examples.\\n\\n        .. versionadded:: 2.0\\n\\n        .. seealso::\\n\\n            :ref:`write_only_relationship` - in the :ref:`queryguide_toplevel`\\n\\n      * ``dynamic`` - the attribute will return a pre-configured\\n        :class:`_query.Query` object for all read\\n        operations, onto which further filtering operations can be\\n        applied before iterating the results.\\n\\n        The ``dynamic`` loader style is configured automatically when\\n        the :class:`_orm.DynamicMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`dynamic_relationship` for examples.\\n\\n        .. legacy::  The \"dynamic\" lazy loader strategy is the legacy form of\\n           what is now the \"write_only\" strategy described in the section\\n           :ref:`write_only_relationship`.\\n\\n        .. seealso::\\n\\n            :ref:`dynamic_relationship` - in the :ref:`queryguide_toplevel`\\n\\n            :ref:`write_only_relationship` - more generally useful approach\\n            for large collections that should not fully load into memory\\n\\n      * True - a synonym for \\'select\\'\\n\\n      * False - a synonym for \\'joined\\'\\n\\n      * None - a synonym for \\'noload\\'\\n\\n      .. seealso::\\n\\n        :ref:`orm_queryguide_relationship_loaders` - Full documentation on\\n        relationship loader configuration in the :ref:`queryguide_toplevel`.\\n\\n\\n    :param load_on_pending=False:\\n      Indicates loading behavior for transient or pending parent objects.\\n\\n      When set to ``True``, causes the lazy-loader to\\n      issue a query for a parent object that is not persistent, meaning it\\n      has never been flushed.  This may take effect for a pending object\\n      when autoflush is disabled, or for a transient object that has been\\n      \"attached\" to a :class:`.Session` but is not part of its pending\\n      collection.\\n\\n      The :paramref:`_orm.relationship.load_on_pending`\\n      flag does not improve\\n      behavior when the ORM is used normally - object references should be\\n      constructed at the object level, not at the foreign key level, so\\n      that they are present in an ordinary way before a flush proceeds.\\n      This flag is not not intended for general use.\\n\\n      .. seealso::\\n\\n          :meth:`.Session.enable_relationship_loading` - this method\\n          establishes \"load on pending\" behavior for the whole object, and\\n          also allows loading on objects that remain transient or\\n          detached.\\n\\n    :param order_by:\\n      Indicates the ordering that should be applied when loading these\\n      items.  :paramref:`_orm.relationship.order_by`\\n      is expected to refer to\\n      one of the :class:`_schema.Column`\\n      objects to which the target class is\\n      mapped, or the attribute itself bound to the target class which\\n      refers to the column.\\n\\n      :paramref:`_orm.relationship.order_by`\\n      may also be passed as a callable\\n      function which is evaluated at mapper initialization time, and may\\n      be passed as a Python-evaluable string when using Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n    :param passive_deletes=False:\\n       Indicates loading behavior during delete operations.\\n\\n       A value of True indicates that unloaded child items should not\\n       be loaded during a delete operation on the parent.  Normally,\\n       when a parent item is deleted, all child items are loaded so\\n       that they can either be marked as deleted, or have their\\n       foreign key to the parent set to NULL.  Marking this flag as\\n       True usually implies an ON DELETE <CASCADE|SET NULL> rule is in\\n       place which will handle updating/deleting child rows on the\\n       database side.\\n\\n       Additionally, setting the flag to the string value \\'all\\' will\\n       disable the \"nulling out\" of the child foreign keys, when the parent\\n       object is deleted and there is no delete or delete-orphan cascade\\n       enabled.  This is typically used when a triggering or error raise\\n       scenario is in place on the database side.  Note that the foreign\\n       key attributes on in-session child objects will not be changed after\\n       a flush occurs so this is a very special use-case setting.\\n       Additionally, the \"nulling out\" will still occur if the child\\n       object is de-associated with the parent.\\n\\n       .. seealso::\\n\\n            :ref:`passive_deletes` - Introductory documentation\\n            and examples.\\n\\n    :param passive_updates=True:\\n      Indicates the persistence behavior to take when a referenced\\n      primary key value changes in place, indicating that the referencing\\n      foreign key columns will also need their value changed.\\n\\n      When True, it is assumed that ``ON UPDATE CASCADE`` is configured on\\n      the foreign key in the database, and that the database will\\n      handle propagation of an UPDATE from a source column to\\n      dependent rows.  When False, the SQLAlchemy\\n      :func:`_orm.relationship`\\n      construct will attempt to emit its own UPDATE statements to\\n      modify related targets.  However note that SQLAlchemy **cannot**\\n      emit an UPDATE for more than one level of cascade.  Also,\\n      setting this flag to False is not compatible in the case where\\n      the database is in fact enforcing referential integrity, unless\\n      those constraints are explicitly \"deferred\", if the target backend\\n      supports it.\\n\\n      It is highly advised that an application which is employing\\n      mutable primary keys keeps ``passive_updates`` set to True,\\n      and instead uses the referential integrity features of the database\\n      itself in order to handle the change efficiently and fully.\\n\\n      .. seealso::\\n\\n          :ref:`passive_updates` - Introductory documentation and\\n          examples.\\n\\n          :paramref:`.mapper.passive_updates` - a similar flag which\\n          takes effect for joined-table inheritance mappings.\\n\\n    :param post_update:\\n      This indicates that the relationship should be handled by a\\n      second UPDATE statement after an INSERT or before a\\n      DELETE. This flag is used to handle saving bi-directional\\n      dependencies between two individual rows (i.e. each row\\n      references the other), where it would otherwise be impossible to\\n      INSERT or DELETE both rows fully since one row exists before the\\n      other. Use this flag when a particular mapping arrangement will\\n      incur two rows that are dependent on each other, such as a table\\n      that has a one-to-many relationship to a set of child rows, and\\n      also has a column that references a single child row within that\\n      list (i.e. both tables contain a foreign key to each other). If\\n      a flush operation returns an error that a \"cyclical\\n      dependency\" was detected, this is a cue that you might want to\\n      use :paramref:`_orm.relationship.post_update` to \"break\" the cycle.\\n\\n      .. seealso::\\n\\n          :ref:`post_update` - Introductory documentation and examples.\\n\\n    :param primaryjoin:\\n      A SQL expression that will be used as the primary\\n      join of the child object against the parent object, or in a\\n      many-to-many relationship the join of the parent object to the\\n      association table. By default, this value is computed based on the\\n      foreign key relationships of the parent and child tables (or\\n      association table).\\n\\n      :paramref:`_orm.relationship.primaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param remote_side:\\n      Used for self-referential relationships, indicates the column or\\n      list of columns that form the \"remote side\" of the relationship.\\n\\n      :paramref:`_orm.relationship.remote_side` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential` - in-depth explanation of how\\n        :paramref:`_orm.relationship.remote_side`\\n        is used to configure self-referential relationships.\\n\\n        :func:`.remote` - an annotation function that accomplishes the\\n        same purpose as :paramref:`_orm.relationship.remote_side`,\\n        typically\\n        when a custom :paramref:`_orm.relationship.primaryjoin` condition\\n        is used.\\n\\n    :param query_class:\\n      A :class:`_query.Query`\\n      subclass that will be used internally by the\\n      ``AppenderQuery`` returned by a \"dynamic\" relationship, that\\n      is, a relationship that specifies ``lazy=\"dynamic\"`` or was\\n      otherwise constructed using the :func:`_orm.dynamic_loader`\\n      function.\\n\\n      .. seealso::\\n\\n        :ref:`dynamic_relationship` - Introduction to \"dynamic\"\\n        relationship loaders.\\n\\n    :param secondaryjoin:\\n      A SQL expression that will be used as the join of\\n      an association table to the child object. By default, this value is\\n      computed based on the foreign key relationships of the association\\n      and child tables.\\n\\n      :paramref:`_orm.relationship.secondaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param single_parent:\\n      When True, installs a validator which will prevent objects\\n      from being associated with more than one parent at a time.\\n      This is used for many-to-one or many-to-many relationships that\\n      should be treated either as one-to-one or one-to-many.  Its usage\\n      is optional, except for :func:`_orm.relationship` constructs which\\n      are many-to-one or many-to-many and also\\n      specify the ``delete-orphan`` cascade option.  The\\n      :func:`_orm.relationship` construct itself will raise an error\\n      instructing when this option is required.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - includes detail on when the\\n        :paramref:`_orm.relationship.single_parent`\\n        flag may be appropriate.\\n\\n    :param uselist:\\n      A boolean that indicates if this property should be loaded as a\\n      list or a scalar. In most cases, this value is determined\\n      automatically by :func:`_orm.relationship` at mapper configuration\\n      time.  When using explicit :class:`_orm.Mapped` annotations,\\n      :paramref:`_orm.relationship.uselist` may be derived from the\\n      whether or not the annotation within :class:`_orm.Mapped` contains\\n      a collection class.\\n      Otherwise, :paramref:`_orm.relationship.uselist` may be derived from\\n      the type and direction\\n      of the relationship - one to many forms a list, many to one\\n      forms a scalar, many to many is a list. If a scalar is desired\\n      where normally a list would be present, such as a bi-directional\\n      one-to-one relationship, use an appropriate :class:`_orm.Mapped`\\n      annotation or set :paramref:`_orm.relationship.uselist` to False.\\n\\n      The :paramref:`_orm.relationship.uselist`\\n      flag is also available on an\\n      existing :func:`_orm.relationship`\\n      construct as a read-only attribute,\\n      which can be used to determine if this :func:`_orm.relationship`\\n      deals\\n      with collections or scalar attributes::\\n\\n          >>> User.addresses.property.uselist\\n          True\\n\\n      .. seealso::\\n\\n          :ref:`relationships_one_to_one` - Introduction to the \"one to\\n          one\" relationship pattern, which is typically when an alternate\\n          setting for :paramref:`_orm.relationship.uselist` is involved.\\n\\n    :param viewonly=False:\\n      When set to ``True``, the relationship is used only for loading\\n      objects, and not for any persistence operation.  A\\n      :func:`_orm.relationship` which specifies\\n      :paramref:`_orm.relationship.viewonly` can work\\n      with a wider range of SQL operations within the\\n      :paramref:`_orm.relationship.primaryjoin` condition, including\\n      operations that feature the use of a variety of comparison operators\\n      as well as SQL functions such as :func:`_expression.cast`.  The\\n      :paramref:`_orm.relationship.viewonly`\\n      flag is also of general use when defining any kind of\\n      :func:`_orm.relationship` that doesn\\'t represent\\n      the full set of related objects, to prevent modifications of the\\n      collection from resulting in persistence operations.\\n\\n      When using the :paramref:`_orm.relationship.viewonly` flag in\\n      conjunction with backrefs, the originating relationship for a\\n      particular state change will not produce state changes within the\\n      viewonly relationship.   This is the behavior implied by\\n      :paramref:`_orm.relationship.sync_backref` being set to False.\\n\\n      .. versionchanged:: 1.3.17 - the\\n         :paramref:`_orm.relationship.sync_backref` flag is set to False\\n             when using viewonly in conjunction with backrefs.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.sync_backref`\\n\\n    :param sync_backref:\\n      A boolean that enables the events used to synchronize the in-Python\\n      attributes when this relationship is target of either\\n      :paramref:`_orm.relationship.backref` or\\n      :paramref:`_orm.relationship.back_populates`.\\n\\n      Defaults to ``None``, which indicates that an automatic value should\\n      be selected based on the value of the\\n      :paramref:`_orm.relationship.viewonly` flag.  When left at its\\n      default, changes in state will be back-populated only if neither\\n      sides of a relationship is viewonly.\\n\\n      .. versionadded:: 1.3.17\\n\\n      .. versionchanged:: 1.4 - A relationship that specifies\\n         :paramref:`_orm.relationship.viewonly` automatically implies\\n         that :paramref:`_orm.relationship.sync_backref` is ``False``.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.viewonly`\\n\\n    :param omit_join:\\n      Allows manual control over the \"selectin\" automatic join\\n      optimization.  Set to ``False`` to disable the \"omit join\" feature\\n      added in SQLAlchemy 1.3; or leave as ``None`` to leave automatic\\n      optimization in place.\\n\\n      .. note:: This flag may only be set to ``False``.   It is not\\n         necessary to set it to ``True`` as the \"omit_join\" optimization is\\n         automatically detected; if it is not detected, then the\\n         optimization is not supported.\\n\\n         .. versionchanged:: 1.3.11  setting ``omit_join`` to True will now\\n            emit a warning as this was not the intended use of this flag.\\n\\n      .. versionadded:: 1.3\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n\\n    '\n    return Relationship(argument, secondary=secondary, uselist=uselist, collection_class=collection_class, primaryjoin=primaryjoin, secondaryjoin=secondaryjoin, back_populates=back_populates, order_by=order_by, backref=backref, overlaps=overlaps, post_update=post_update, cascade=cascade, viewonly=viewonly, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), lazy=lazy, passive_deletes=passive_deletes, passive_updates=passive_updates, active_history=active_history, enable_typechecks=enable_typechecks, foreign_keys=foreign_keys, remote_side=remote_side, join_depth=join_depth, comparator_factory=comparator_factory, single_parent=single_parent, innerjoin=innerjoin, distinct_target_key=distinct_target_key, load_on_pending=load_on_pending, query_class=query_class, info=info, omit_join=omit_join, sync_backref=sync_backref, **kw)",
            "def relationship(argument: Optional[_RelationshipArgumentType[Any]]=None, secondary: Optional[_RelationshipSecondaryArgument]=None, *, uselist: Optional[bool]=None, collection_class: Optional[Union[Type[Collection[Any]], Callable[[], Collection[Any]]]]=None, primaryjoin: Optional[_RelationshipJoinConditionArgument]=None, secondaryjoin: Optional[_RelationshipJoinConditionArgument]=None, back_populates: Optional[str]=None, order_by: _ORMOrderByArgument=False, backref: Optional[ORMBackrefArgument]=None, overlaps: Optional[str]=None, post_update: bool=False, cascade: str='save-update, merge', viewonly: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, lazy: _LazyLoadArgumentType='select', passive_deletes: Union[Literal['all'], bool]=False, passive_updates: bool=True, active_history: bool=False, enable_typechecks: bool=True, foreign_keys: Optional[_ORMColCollectionArgument]=None, remote_side: Optional[_ORMColCollectionArgument]=None, join_depth: Optional[int]=None, comparator_factory: Optional[Type[RelationshipProperty.Comparator[Any]]]=None, single_parent: bool=False, innerjoin: bool=False, distinct_target_key: Optional[bool]=None, load_on_pending: bool=False, query_class: Optional[Type[Query[Any]]]=None, info: Optional[_InfoType]=None, omit_join: Literal[None, False]=None, sync_backref: Optional[bool]=None, **kw: Any) -> Relationship[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Provide a relationship between two mapped classes.\\n\\n    This corresponds to a parent-child or associative table relationship.\\n    The constructed class is an instance of :class:`.Relationship`.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - tutorial introduction\\n        to :func:`_orm.relationship` in the :ref:`unified_tutorial`\\n\\n        :ref:`relationship_config_toplevel` - narrative documentation\\n\\n    :param argument:\\n      This parameter refers to the class that is to be related.   It\\n      accepts several forms, including a direct reference to the target\\n      class itself, the :class:`_orm.Mapper` instance for the target class,\\n      a Python callable / lambda that will return a reference to the\\n      class or :class:`_orm.Mapper` when called, and finally a string\\n      name for the class, which will be resolved from the\\n      :class:`_orm.registry` in use in order to locate the class, e.g.::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related = relationship(\"RelatedClass\")\\n\\n      The :paramref:`_orm.relationship.argument` may also be omitted from the\\n      :func:`_orm.relationship` construct entirely, and instead placed inside\\n      a :class:`_orm.Mapped` annotation on the left side, which should\\n      include a Python collection type if the relationship is expected\\n      to be a collection, such as::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_items: Mapped[List[\"RelatedItem\"]] = relationship()\\n\\n      Or for a many-to-one or one-to-one relationship::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_item: Mapped[\"RelatedItem\"] = relationship()\\n\\n      .. seealso::\\n\\n        :ref:`orm_declarative_properties` - further detail\\n        on relationship configuration when using Declarative.\\n\\n    :param secondary:\\n      For a many-to-many relationship, specifies the intermediary\\n      table, and is typically an instance of :class:`_schema.Table`.\\n      In less common circumstances, the argument may also be specified\\n      as an :class:`_expression.Alias` construct, or even a\\n      :class:`_expression.Join` construct.\\n\\n      :paramref:`_orm.relationship.secondary` may\\n      also be passed as a callable function which is evaluated at\\n      mapper initialization time.  When using Declarative, it may also\\n      be a string argument noting the name of a :class:`_schema.Table`\\n      that is\\n      present in the :class:`_schema.MetaData`\\n      collection associated with the\\n      parent-mapped :class:`_schema.Table`.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      The :paramref:`_orm.relationship.secondary` keyword argument is\\n      typically applied in the case where the intermediary\\n      :class:`_schema.Table`\\n      is not otherwise expressed in any direct class mapping. If the\\n      \"secondary\" table is also explicitly mapped elsewhere (e.g. as in\\n      :ref:`association_pattern`), one should consider applying the\\n      :paramref:`_orm.relationship.viewonly` flag so that this\\n      :func:`_orm.relationship`\\n      is not used for persistence operations which\\n      may conflict with those of the association object pattern.\\n\\n      .. seealso::\\n\\n          :ref:`relationships_many_to_many` - Reference example of \"many\\n          to many\".\\n\\n          :ref:`self_referential_many_to_many` - Specifics on using\\n          many-to-many in a self-referential case.\\n\\n          :ref:`declarative_many_to_many` - Additional options when using\\n          Declarative.\\n\\n          :ref:`association_pattern` - an alternative to\\n          :paramref:`_orm.relationship.secondary`\\n          when composing association\\n          table relationships, allowing additional attributes to be\\n          specified on the association table.\\n\\n          :ref:`composite_secondary_join` - a lesser-used pattern which\\n          in some cases can enable complex :func:`_orm.relationship` SQL\\n          conditions to be used.\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      many-to-one reference should be loaded when replaced, if\\n      not already loaded. Normally, history tracking logic for\\n      simple many-to-ones only needs to be aware of the \"new\"\\n      value in order to perform a flush. This flag is available\\n      for applications that make use of\\n      :func:`.attributes.get_history` which also need to know\\n      the \"previous\" value of the attribute.\\n\\n    :param backref:\\n      A reference to a string relationship name, or a :func:`_orm.backref`\\n      construct, which will be used to automatically generate a new\\n      :func:`_orm.relationship` on the related class, which then refers to this\\n      one using a bi-directional :paramref:`_orm.relationship.back_populates`\\n      configuration.\\n\\n      In modern Python, explicit use of :func:`_orm.relationship`\\n      with :paramref:`_orm.relationship.back_populates` should be preferred,\\n      as it is more robust in terms of mapper configuration as well as\\n      more conceptually straightforward.  It also integrates with\\n      new :pep:`484` typing features introduced in SQLAlchemy 2.0 which\\n      is not possible with dynamically generated attributes.\\n\\n      .. seealso::\\n\\n        :ref:`relationships_backref` - notes on using\\n        :paramref:`_orm.relationship.backref`\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors using :paramref:`_orm.relationship.back_populates`\\n\\n        :func:`.backref` - allows control over :func:`_orm.relationship`\\n        configuration when using :paramref:`_orm.relationship.backref`.\\n\\n\\n    :param back_populates:\\n      Indicates the name of a :func:`_orm.relationship` on the related\\n      class that will be synchronized with this one.   It is usually\\n      expected that the :func:`_orm.relationship` on the related class\\n      also refer to this one.  This allows objects on both sides of\\n      each :func:`_orm.relationship` to synchronize in-Python state\\n      changes and also provides directives to the :term:`unit of work`\\n      flush process how changes along these relationships should\\n      be persisted.\\n\\n      .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors.\\n\\n        :ref:`relationship_patterns` - includes many examples of\\n        :paramref:`_orm.relationship.back_populates`.\\n\\n        :paramref:`_orm.relationship.backref` - legacy form which allows\\n        more succinct configuration, but does not support explicit typing\\n\\n    :param overlaps:\\n       A string name or comma-delimited set of names of other relationships\\n       on either this mapper, a descendant mapper, or a target mapper with\\n       which this relationship may write to the same foreign keys upon\\n       persistence.   The only effect this has is to eliminate the\\n       warning that this relationship will conflict with another upon\\n       persistence.   This is used for such relationships that are truly\\n       capable of conflicting with each other on write, but the application\\n       will ensure that no such conflicts occur.\\n\\n       .. versionadded:: 1.4\\n\\n       .. seealso::\\n\\n            :ref:`error_qzyx` - usage example\\n\\n    :param cascade:\\n      A comma-separated list of cascade rules which determines how\\n      Session operations should be \"cascaded\" from parent to child.\\n      This defaults to ``False``, which means the default cascade\\n      should be used - this default cascade is ``\"save-update, merge\"``.\\n\\n      The available cascades are ``save-update``, ``merge``,\\n      ``expunge``, ``delete``, ``delete-orphan``, and ``refresh-expire``.\\n      An additional option, ``all`` indicates shorthand for\\n      ``\"save-update, merge, refresh-expire,\\n      expunge, delete\"``, and is often used as in ``\"all, delete-orphan\"``\\n      to indicate that related objects should follow along with the\\n      parent object in all cases, and be deleted when de-associated.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - Full detail on each of the available\\n        cascade options.\\n\\n    :param cascade_backrefs=False:\\n      Legacy; this flag is always False.\\n\\n      .. versionchanged:: 2.0 \"cascade_backrefs\" functionality has been\\n         removed.\\n\\n    :param collection_class:\\n      A class or callable that returns a new list-holding object. will\\n      be used in place of a plain list for storing elements.\\n\\n      .. seealso::\\n\\n        :ref:`custom_collections` - Introductory documentation and\\n        examples.\\n\\n    :param comparator_factory:\\n      A class which extends :class:`.Relationship.Comparator`\\n      which provides custom SQL clause generation for comparison\\n      operations.\\n\\n      .. seealso::\\n\\n        :class:`.PropComparator` - some detail on redefining comparators\\n        at this level.\\n\\n        :ref:`custom_comparators` - Brief intro to this feature.\\n\\n\\n    :param distinct_target_key=None:\\n      Indicate if a \"subquery\" eager load should apply the DISTINCT\\n      keyword to the innermost SELECT statement.  When left as ``None``,\\n      the DISTINCT keyword will be applied in those cases when the target\\n      columns do not comprise the full primary key of the target table.\\n      When set to ``True``, the DISTINCT keyword is applied to the\\n      innermost SELECT unconditionally.\\n\\n      It may be desirable to set this flag to False when the DISTINCT is\\n      reducing performance of the innermost subquery beyond that of what\\n      duplicate innermost rows may be causing.\\n\\n      .. seealso::\\n\\n        :ref:`loading_toplevel` - includes an introduction to subquery\\n        eager loading.\\n\\n    :param doc:\\n      Docstring which will be applied to the resulting descriptor.\\n\\n    :param foreign_keys:\\n\\n      A list of columns which are to be used as \"foreign key\"\\n      columns, or columns which refer to the value in a remote\\n      column, within the context of this :func:`_orm.relationship`\\n      object\\'s :paramref:`_orm.relationship.primaryjoin` condition.\\n      That is, if the :paramref:`_orm.relationship.primaryjoin`\\n      condition of this :func:`_orm.relationship` is ``a.id ==\\n      b.a_id``, and the values in ``b.a_id`` are required to be\\n      present in ``a.id``, then the \"foreign key\" column of this\\n      :func:`_orm.relationship` is ``b.a_id``.\\n\\n      In normal cases, the :paramref:`_orm.relationship.foreign_keys`\\n      parameter is **not required.** :func:`_orm.relationship` will\\n      automatically determine which columns in the\\n      :paramref:`_orm.relationship.primaryjoin` condition are to be\\n      considered \"foreign key\" columns based on those\\n      :class:`_schema.Column` objects that specify\\n      :class:`_schema.ForeignKey`,\\n      or are otherwise listed as referencing columns in a\\n      :class:`_schema.ForeignKeyConstraint` construct.\\n      :paramref:`_orm.relationship.foreign_keys` is only needed when:\\n\\n        1. There is more than one way to construct a join from the local\\n           table to the remote table, as there are multiple foreign key\\n           references present.  Setting ``foreign_keys`` will limit the\\n           :func:`_orm.relationship`\\n           to consider just those columns specified\\n           here as \"foreign\".\\n\\n        2. The :class:`_schema.Table` being mapped does not actually have\\n           :class:`_schema.ForeignKey` or\\n           :class:`_schema.ForeignKeyConstraint`\\n           constructs present, often because the table\\n           was reflected from a database that does not support foreign key\\n           reflection (MySQL MyISAM).\\n\\n        3. The :paramref:`_orm.relationship.primaryjoin`\\n           argument is used to\\n           construct a non-standard join condition, which makes use of\\n           columns or expressions that do not normally refer to their\\n           \"parent\" column, such as a join condition expressed by a\\n           complex comparison using a SQL function.\\n\\n      The :func:`_orm.relationship` construct will raise informative\\n      error messages that suggest the use of the\\n      :paramref:`_orm.relationship.foreign_keys` parameter when\\n      presented with an ambiguous condition.   In typical cases,\\n      if :func:`_orm.relationship` doesn\\'t raise any exceptions, the\\n      :paramref:`_orm.relationship.foreign_keys` parameter is usually\\n      not needed.\\n\\n      :paramref:`_orm.relationship.foreign_keys` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`relationship_foreign_keys`\\n\\n        :ref:`relationship_custom_foreign`\\n\\n        :func:`.foreign` - allows direct annotation of the \"foreign\"\\n        columns within a :paramref:`_orm.relationship.primaryjoin`\\n        condition.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param innerjoin=False:\\n      When ``True``, joined eager loads will use an inner join to join\\n      against related tables instead of an outer join.  The purpose\\n      of this option is generally one of performance, as inner joins\\n      generally perform better than outer joins.\\n\\n      This flag can be set to ``True`` when the relationship references an\\n      object via many-to-one using local foreign keys that are not\\n      nullable, or when the reference is one-to-one or a collection that\\n      is guaranteed to have one or at least one entry.\\n\\n      The option supports the same \"nested\" and \"unnested\" options as\\n      that of :paramref:`_orm.joinedload.innerjoin`.  See that flag\\n      for details on nested / unnested behaviors.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.joinedload.innerjoin` - the option as specified by\\n        loader option, including detail on nesting behavior.\\n\\n        :ref:`what_kind_of_loading` - Discussion of some details of\\n        various loader options.\\n\\n\\n    :param join_depth:\\n      When non-``None``, an integer value indicating how many levels\\n      deep \"eager\" loaders should join on a self-referring or cyclical\\n      relationship.  The number counts how many times the same Mapper\\n      shall be present in the loading condition along a particular join\\n      branch.  When left at its default of ``None``, eager loaders\\n      will stop chaining when they encounter a the same target mapper\\n      which is already higher up in the chain.  This option applies\\n      both to joined- and subquery- eager loaders.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential_eager_loading` - Introductory documentation\\n        and examples.\\n\\n    :param lazy=\\'select\\': specifies\\n      How the related items should be loaded.  Default value is\\n      ``select``.  Values include:\\n\\n      * ``select`` - items should be loaded lazily when the property is\\n        first accessed, using a separate SELECT statement, or identity map\\n        fetch for simple many-to-one references.\\n\\n      * ``immediate`` - items should be loaded as the parents are loaded,\\n        using a separate SELECT statement, or identity map fetch for\\n        simple many-to-one references.\\n\\n      * ``joined`` - items should be loaded \"eagerly\" in the same query as\\n        that of the parent, using a JOIN or LEFT OUTER JOIN.  Whether\\n        the join is \"outer\" or not is determined by the\\n        :paramref:`_orm.relationship.innerjoin` parameter.\\n\\n      * ``subquery`` - items should be loaded \"eagerly\" as the parents are\\n        loaded, using one additional SQL statement, which issues a JOIN to\\n        a subquery of the original statement, for each collection\\n        requested.\\n\\n      * ``selectin`` - items should be loaded \"eagerly\" as the parents\\n        are loaded, using one or more additional SQL statements, which\\n        issues a JOIN to the immediate parent object, specifying primary\\n        key identifiers using an IN clause.\\n\\n      * ``noload`` - no loading should occur at any time.  The related\\n        collection will remain empty.   The ``noload`` strategy is not\\n        recommended for general use.  For a general use \"never load\"\\n        approach, see :ref:`write_only_relationship`\\n\\n      * ``raise`` - lazy loading is disallowed; accessing\\n        the attribute, if its value were not already loaded via eager\\n        loading, will raise an :exc:`~sqlalchemy.exc.InvalidRequestError`.\\n        This strategy can be used when objects are to be detached from\\n        their attached :class:`.Session` after they are loaded.\\n\\n      * ``raise_on_sql`` - lazy loading that emits SQL is disallowed;\\n        accessing the attribute, if its value were not already loaded via\\n        eager loading, will raise an\\n        :exc:`~sqlalchemy.exc.InvalidRequestError`, **if the lazy load\\n        needs to emit SQL**.  If the lazy load can pull the related value\\n        from the identity map or determine that it should be None, the\\n        value is loaded.  This strategy can be used when objects will\\n        remain associated with the attached :class:`.Session`, however\\n        additional SELECT statements should be blocked.\\n\\n      * ``write_only`` - the attribute will be configured with a special\\n        \"virtual collection\" that may receive\\n        :meth:`_orm.WriteOnlyCollection.add` and\\n        :meth:`_orm.WriteOnlyCollection.remove` commands to add or remove\\n        individual objects, but will not under any circumstances load or\\n        iterate the full set of objects from the database directly. Instead,\\n        methods such as :meth:`_orm.WriteOnlyCollection.select`,\\n        :meth:`_orm.WriteOnlyCollection.insert`,\\n        :meth:`_orm.WriteOnlyCollection.update` and\\n        :meth:`_orm.WriteOnlyCollection.delete` are provided which generate SQL\\n        constructs that may be used to load and modify rows in bulk. Used for\\n        large collections that are never appropriate to load at once into\\n        memory.\\n\\n        The ``write_only`` loader style is configured automatically when\\n        the :class:`_orm.WriteOnlyMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`write_only_relationship` for examples.\\n\\n        .. versionadded:: 2.0\\n\\n        .. seealso::\\n\\n            :ref:`write_only_relationship` - in the :ref:`queryguide_toplevel`\\n\\n      * ``dynamic`` - the attribute will return a pre-configured\\n        :class:`_query.Query` object for all read\\n        operations, onto which further filtering operations can be\\n        applied before iterating the results.\\n\\n        The ``dynamic`` loader style is configured automatically when\\n        the :class:`_orm.DynamicMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`dynamic_relationship` for examples.\\n\\n        .. legacy::  The \"dynamic\" lazy loader strategy is the legacy form of\\n           what is now the \"write_only\" strategy described in the section\\n           :ref:`write_only_relationship`.\\n\\n        .. seealso::\\n\\n            :ref:`dynamic_relationship` - in the :ref:`queryguide_toplevel`\\n\\n            :ref:`write_only_relationship` - more generally useful approach\\n            for large collections that should not fully load into memory\\n\\n      * True - a synonym for \\'select\\'\\n\\n      * False - a synonym for \\'joined\\'\\n\\n      * None - a synonym for \\'noload\\'\\n\\n      .. seealso::\\n\\n        :ref:`orm_queryguide_relationship_loaders` - Full documentation on\\n        relationship loader configuration in the :ref:`queryguide_toplevel`.\\n\\n\\n    :param load_on_pending=False:\\n      Indicates loading behavior for transient or pending parent objects.\\n\\n      When set to ``True``, causes the lazy-loader to\\n      issue a query for a parent object that is not persistent, meaning it\\n      has never been flushed.  This may take effect for a pending object\\n      when autoflush is disabled, or for a transient object that has been\\n      \"attached\" to a :class:`.Session` but is not part of its pending\\n      collection.\\n\\n      The :paramref:`_orm.relationship.load_on_pending`\\n      flag does not improve\\n      behavior when the ORM is used normally - object references should be\\n      constructed at the object level, not at the foreign key level, so\\n      that they are present in an ordinary way before a flush proceeds.\\n      This flag is not not intended for general use.\\n\\n      .. seealso::\\n\\n          :meth:`.Session.enable_relationship_loading` - this method\\n          establishes \"load on pending\" behavior for the whole object, and\\n          also allows loading on objects that remain transient or\\n          detached.\\n\\n    :param order_by:\\n      Indicates the ordering that should be applied when loading these\\n      items.  :paramref:`_orm.relationship.order_by`\\n      is expected to refer to\\n      one of the :class:`_schema.Column`\\n      objects to which the target class is\\n      mapped, or the attribute itself bound to the target class which\\n      refers to the column.\\n\\n      :paramref:`_orm.relationship.order_by`\\n      may also be passed as a callable\\n      function which is evaluated at mapper initialization time, and may\\n      be passed as a Python-evaluable string when using Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n    :param passive_deletes=False:\\n       Indicates loading behavior during delete operations.\\n\\n       A value of True indicates that unloaded child items should not\\n       be loaded during a delete operation on the parent.  Normally,\\n       when a parent item is deleted, all child items are loaded so\\n       that they can either be marked as deleted, or have their\\n       foreign key to the parent set to NULL.  Marking this flag as\\n       True usually implies an ON DELETE <CASCADE|SET NULL> rule is in\\n       place which will handle updating/deleting child rows on the\\n       database side.\\n\\n       Additionally, setting the flag to the string value \\'all\\' will\\n       disable the \"nulling out\" of the child foreign keys, when the parent\\n       object is deleted and there is no delete or delete-orphan cascade\\n       enabled.  This is typically used when a triggering or error raise\\n       scenario is in place on the database side.  Note that the foreign\\n       key attributes on in-session child objects will not be changed after\\n       a flush occurs so this is a very special use-case setting.\\n       Additionally, the \"nulling out\" will still occur if the child\\n       object is de-associated with the parent.\\n\\n       .. seealso::\\n\\n            :ref:`passive_deletes` - Introductory documentation\\n            and examples.\\n\\n    :param passive_updates=True:\\n      Indicates the persistence behavior to take when a referenced\\n      primary key value changes in place, indicating that the referencing\\n      foreign key columns will also need their value changed.\\n\\n      When True, it is assumed that ``ON UPDATE CASCADE`` is configured on\\n      the foreign key in the database, and that the database will\\n      handle propagation of an UPDATE from a source column to\\n      dependent rows.  When False, the SQLAlchemy\\n      :func:`_orm.relationship`\\n      construct will attempt to emit its own UPDATE statements to\\n      modify related targets.  However note that SQLAlchemy **cannot**\\n      emit an UPDATE for more than one level of cascade.  Also,\\n      setting this flag to False is not compatible in the case where\\n      the database is in fact enforcing referential integrity, unless\\n      those constraints are explicitly \"deferred\", if the target backend\\n      supports it.\\n\\n      It is highly advised that an application which is employing\\n      mutable primary keys keeps ``passive_updates`` set to True,\\n      and instead uses the referential integrity features of the database\\n      itself in order to handle the change efficiently and fully.\\n\\n      .. seealso::\\n\\n          :ref:`passive_updates` - Introductory documentation and\\n          examples.\\n\\n          :paramref:`.mapper.passive_updates` - a similar flag which\\n          takes effect for joined-table inheritance mappings.\\n\\n    :param post_update:\\n      This indicates that the relationship should be handled by a\\n      second UPDATE statement after an INSERT or before a\\n      DELETE. This flag is used to handle saving bi-directional\\n      dependencies between two individual rows (i.e. each row\\n      references the other), where it would otherwise be impossible to\\n      INSERT or DELETE both rows fully since one row exists before the\\n      other. Use this flag when a particular mapping arrangement will\\n      incur two rows that are dependent on each other, such as a table\\n      that has a one-to-many relationship to a set of child rows, and\\n      also has a column that references a single child row within that\\n      list (i.e. both tables contain a foreign key to each other). If\\n      a flush operation returns an error that a \"cyclical\\n      dependency\" was detected, this is a cue that you might want to\\n      use :paramref:`_orm.relationship.post_update` to \"break\" the cycle.\\n\\n      .. seealso::\\n\\n          :ref:`post_update` - Introductory documentation and examples.\\n\\n    :param primaryjoin:\\n      A SQL expression that will be used as the primary\\n      join of the child object against the parent object, or in a\\n      many-to-many relationship the join of the parent object to the\\n      association table. By default, this value is computed based on the\\n      foreign key relationships of the parent and child tables (or\\n      association table).\\n\\n      :paramref:`_orm.relationship.primaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param remote_side:\\n      Used for self-referential relationships, indicates the column or\\n      list of columns that form the \"remote side\" of the relationship.\\n\\n      :paramref:`_orm.relationship.remote_side` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential` - in-depth explanation of how\\n        :paramref:`_orm.relationship.remote_side`\\n        is used to configure self-referential relationships.\\n\\n        :func:`.remote` - an annotation function that accomplishes the\\n        same purpose as :paramref:`_orm.relationship.remote_side`,\\n        typically\\n        when a custom :paramref:`_orm.relationship.primaryjoin` condition\\n        is used.\\n\\n    :param query_class:\\n      A :class:`_query.Query`\\n      subclass that will be used internally by the\\n      ``AppenderQuery`` returned by a \"dynamic\" relationship, that\\n      is, a relationship that specifies ``lazy=\"dynamic\"`` or was\\n      otherwise constructed using the :func:`_orm.dynamic_loader`\\n      function.\\n\\n      .. seealso::\\n\\n        :ref:`dynamic_relationship` - Introduction to \"dynamic\"\\n        relationship loaders.\\n\\n    :param secondaryjoin:\\n      A SQL expression that will be used as the join of\\n      an association table to the child object. By default, this value is\\n      computed based on the foreign key relationships of the association\\n      and child tables.\\n\\n      :paramref:`_orm.relationship.secondaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param single_parent:\\n      When True, installs a validator which will prevent objects\\n      from being associated with more than one parent at a time.\\n      This is used for many-to-one or many-to-many relationships that\\n      should be treated either as one-to-one or one-to-many.  Its usage\\n      is optional, except for :func:`_orm.relationship` constructs which\\n      are many-to-one or many-to-many and also\\n      specify the ``delete-orphan`` cascade option.  The\\n      :func:`_orm.relationship` construct itself will raise an error\\n      instructing when this option is required.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - includes detail on when the\\n        :paramref:`_orm.relationship.single_parent`\\n        flag may be appropriate.\\n\\n    :param uselist:\\n      A boolean that indicates if this property should be loaded as a\\n      list or a scalar. In most cases, this value is determined\\n      automatically by :func:`_orm.relationship` at mapper configuration\\n      time.  When using explicit :class:`_orm.Mapped` annotations,\\n      :paramref:`_orm.relationship.uselist` may be derived from the\\n      whether or not the annotation within :class:`_orm.Mapped` contains\\n      a collection class.\\n      Otherwise, :paramref:`_orm.relationship.uselist` may be derived from\\n      the type and direction\\n      of the relationship - one to many forms a list, many to one\\n      forms a scalar, many to many is a list. If a scalar is desired\\n      where normally a list would be present, such as a bi-directional\\n      one-to-one relationship, use an appropriate :class:`_orm.Mapped`\\n      annotation or set :paramref:`_orm.relationship.uselist` to False.\\n\\n      The :paramref:`_orm.relationship.uselist`\\n      flag is also available on an\\n      existing :func:`_orm.relationship`\\n      construct as a read-only attribute,\\n      which can be used to determine if this :func:`_orm.relationship`\\n      deals\\n      with collections or scalar attributes::\\n\\n          >>> User.addresses.property.uselist\\n          True\\n\\n      .. seealso::\\n\\n          :ref:`relationships_one_to_one` - Introduction to the \"one to\\n          one\" relationship pattern, which is typically when an alternate\\n          setting for :paramref:`_orm.relationship.uselist` is involved.\\n\\n    :param viewonly=False:\\n      When set to ``True``, the relationship is used only for loading\\n      objects, and not for any persistence operation.  A\\n      :func:`_orm.relationship` which specifies\\n      :paramref:`_orm.relationship.viewonly` can work\\n      with a wider range of SQL operations within the\\n      :paramref:`_orm.relationship.primaryjoin` condition, including\\n      operations that feature the use of a variety of comparison operators\\n      as well as SQL functions such as :func:`_expression.cast`.  The\\n      :paramref:`_orm.relationship.viewonly`\\n      flag is also of general use when defining any kind of\\n      :func:`_orm.relationship` that doesn\\'t represent\\n      the full set of related objects, to prevent modifications of the\\n      collection from resulting in persistence operations.\\n\\n      When using the :paramref:`_orm.relationship.viewonly` flag in\\n      conjunction with backrefs, the originating relationship for a\\n      particular state change will not produce state changes within the\\n      viewonly relationship.   This is the behavior implied by\\n      :paramref:`_orm.relationship.sync_backref` being set to False.\\n\\n      .. versionchanged:: 1.3.17 - the\\n         :paramref:`_orm.relationship.sync_backref` flag is set to False\\n             when using viewonly in conjunction with backrefs.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.sync_backref`\\n\\n    :param sync_backref:\\n      A boolean that enables the events used to synchronize the in-Python\\n      attributes when this relationship is target of either\\n      :paramref:`_orm.relationship.backref` or\\n      :paramref:`_orm.relationship.back_populates`.\\n\\n      Defaults to ``None``, which indicates that an automatic value should\\n      be selected based on the value of the\\n      :paramref:`_orm.relationship.viewonly` flag.  When left at its\\n      default, changes in state will be back-populated only if neither\\n      sides of a relationship is viewonly.\\n\\n      .. versionadded:: 1.3.17\\n\\n      .. versionchanged:: 1.4 - A relationship that specifies\\n         :paramref:`_orm.relationship.viewonly` automatically implies\\n         that :paramref:`_orm.relationship.sync_backref` is ``False``.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.viewonly`\\n\\n    :param omit_join:\\n      Allows manual control over the \"selectin\" automatic join\\n      optimization.  Set to ``False`` to disable the \"omit join\" feature\\n      added in SQLAlchemy 1.3; or leave as ``None`` to leave automatic\\n      optimization in place.\\n\\n      .. note:: This flag may only be set to ``False``.   It is not\\n         necessary to set it to ``True`` as the \"omit_join\" optimization is\\n         automatically detected; if it is not detected, then the\\n         optimization is not supported.\\n\\n         .. versionchanged:: 1.3.11  setting ``omit_join`` to True will now\\n            emit a warning as this was not the intended use of this flag.\\n\\n      .. versionadded:: 1.3\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n\\n    '\n    return Relationship(argument, secondary=secondary, uselist=uselist, collection_class=collection_class, primaryjoin=primaryjoin, secondaryjoin=secondaryjoin, back_populates=back_populates, order_by=order_by, backref=backref, overlaps=overlaps, post_update=post_update, cascade=cascade, viewonly=viewonly, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), lazy=lazy, passive_deletes=passive_deletes, passive_updates=passive_updates, active_history=active_history, enable_typechecks=enable_typechecks, foreign_keys=foreign_keys, remote_side=remote_side, join_depth=join_depth, comparator_factory=comparator_factory, single_parent=single_parent, innerjoin=innerjoin, distinct_target_key=distinct_target_key, load_on_pending=load_on_pending, query_class=query_class, info=info, omit_join=omit_join, sync_backref=sync_backref, **kw)",
            "def relationship(argument: Optional[_RelationshipArgumentType[Any]]=None, secondary: Optional[_RelationshipSecondaryArgument]=None, *, uselist: Optional[bool]=None, collection_class: Optional[Union[Type[Collection[Any]], Callable[[], Collection[Any]]]]=None, primaryjoin: Optional[_RelationshipJoinConditionArgument]=None, secondaryjoin: Optional[_RelationshipJoinConditionArgument]=None, back_populates: Optional[str]=None, order_by: _ORMOrderByArgument=False, backref: Optional[ORMBackrefArgument]=None, overlaps: Optional[str]=None, post_update: bool=False, cascade: str='save-update, merge', viewonly: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, lazy: _LazyLoadArgumentType='select', passive_deletes: Union[Literal['all'], bool]=False, passive_updates: bool=True, active_history: bool=False, enable_typechecks: bool=True, foreign_keys: Optional[_ORMColCollectionArgument]=None, remote_side: Optional[_ORMColCollectionArgument]=None, join_depth: Optional[int]=None, comparator_factory: Optional[Type[RelationshipProperty.Comparator[Any]]]=None, single_parent: bool=False, innerjoin: bool=False, distinct_target_key: Optional[bool]=None, load_on_pending: bool=False, query_class: Optional[Type[Query[Any]]]=None, info: Optional[_InfoType]=None, omit_join: Literal[None, False]=None, sync_backref: Optional[bool]=None, **kw: Any) -> Relationship[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Provide a relationship between two mapped classes.\\n\\n    This corresponds to a parent-child or associative table relationship.\\n    The constructed class is an instance of :class:`.Relationship`.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - tutorial introduction\\n        to :func:`_orm.relationship` in the :ref:`unified_tutorial`\\n\\n        :ref:`relationship_config_toplevel` - narrative documentation\\n\\n    :param argument:\\n      This parameter refers to the class that is to be related.   It\\n      accepts several forms, including a direct reference to the target\\n      class itself, the :class:`_orm.Mapper` instance for the target class,\\n      a Python callable / lambda that will return a reference to the\\n      class or :class:`_orm.Mapper` when called, and finally a string\\n      name for the class, which will be resolved from the\\n      :class:`_orm.registry` in use in order to locate the class, e.g.::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related = relationship(\"RelatedClass\")\\n\\n      The :paramref:`_orm.relationship.argument` may also be omitted from the\\n      :func:`_orm.relationship` construct entirely, and instead placed inside\\n      a :class:`_orm.Mapped` annotation on the left side, which should\\n      include a Python collection type if the relationship is expected\\n      to be a collection, such as::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_items: Mapped[List[\"RelatedItem\"]] = relationship()\\n\\n      Or for a many-to-one or one-to-one relationship::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_item: Mapped[\"RelatedItem\"] = relationship()\\n\\n      .. seealso::\\n\\n        :ref:`orm_declarative_properties` - further detail\\n        on relationship configuration when using Declarative.\\n\\n    :param secondary:\\n      For a many-to-many relationship, specifies the intermediary\\n      table, and is typically an instance of :class:`_schema.Table`.\\n      In less common circumstances, the argument may also be specified\\n      as an :class:`_expression.Alias` construct, or even a\\n      :class:`_expression.Join` construct.\\n\\n      :paramref:`_orm.relationship.secondary` may\\n      also be passed as a callable function which is evaluated at\\n      mapper initialization time.  When using Declarative, it may also\\n      be a string argument noting the name of a :class:`_schema.Table`\\n      that is\\n      present in the :class:`_schema.MetaData`\\n      collection associated with the\\n      parent-mapped :class:`_schema.Table`.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      The :paramref:`_orm.relationship.secondary` keyword argument is\\n      typically applied in the case where the intermediary\\n      :class:`_schema.Table`\\n      is not otherwise expressed in any direct class mapping. If the\\n      \"secondary\" table is also explicitly mapped elsewhere (e.g. as in\\n      :ref:`association_pattern`), one should consider applying the\\n      :paramref:`_orm.relationship.viewonly` flag so that this\\n      :func:`_orm.relationship`\\n      is not used for persistence operations which\\n      may conflict with those of the association object pattern.\\n\\n      .. seealso::\\n\\n          :ref:`relationships_many_to_many` - Reference example of \"many\\n          to many\".\\n\\n          :ref:`self_referential_many_to_many` - Specifics on using\\n          many-to-many in a self-referential case.\\n\\n          :ref:`declarative_many_to_many` - Additional options when using\\n          Declarative.\\n\\n          :ref:`association_pattern` - an alternative to\\n          :paramref:`_orm.relationship.secondary`\\n          when composing association\\n          table relationships, allowing additional attributes to be\\n          specified on the association table.\\n\\n          :ref:`composite_secondary_join` - a lesser-used pattern which\\n          in some cases can enable complex :func:`_orm.relationship` SQL\\n          conditions to be used.\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      many-to-one reference should be loaded when replaced, if\\n      not already loaded. Normally, history tracking logic for\\n      simple many-to-ones only needs to be aware of the \"new\"\\n      value in order to perform a flush. This flag is available\\n      for applications that make use of\\n      :func:`.attributes.get_history` which also need to know\\n      the \"previous\" value of the attribute.\\n\\n    :param backref:\\n      A reference to a string relationship name, or a :func:`_orm.backref`\\n      construct, which will be used to automatically generate a new\\n      :func:`_orm.relationship` on the related class, which then refers to this\\n      one using a bi-directional :paramref:`_orm.relationship.back_populates`\\n      configuration.\\n\\n      In modern Python, explicit use of :func:`_orm.relationship`\\n      with :paramref:`_orm.relationship.back_populates` should be preferred,\\n      as it is more robust in terms of mapper configuration as well as\\n      more conceptually straightforward.  It also integrates with\\n      new :pep:`484` typing features introduced in SQLAlchemy 2.0 which\\n      is not possible with dynamically generated attributes.\\n\\n      .. seealso::\\n\\n        :ref:`relationships_backref` - notes on using\\n        :paramref:`_orm.relationship.backref`\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors using :paramref:`_orm.relationship.back_populates`\\n\\n        :func:`.backref` - allows control over :func:`_orm.relationship`\\n        configuration when using :paramref:`_orm.relationship.backref`.\\n\\n\\n    :param back_populates:\\n      Indicates the name of a :func:`_orm.relationship` on the related\\n      class that will be synchronized with this one.   It is usually\\n      expected that the :func:`_orm.relationship` on the related class\\n      also refer to this one.  This allows objects on both sides of\\n      each :func:`_orm.relationship` to synchronize in-Python state\\n      changes and also provides directives to the :term:`unit of work`\\n      flush process how changes along these relationships should\\n      be persisted.\\n\\n      .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors.\\n\\n        :ref:`relationship_patterns` - includes many examples of\\n        :paramref:`_orm.relationship.back_populates`.\\n\\n        :paramref:`_orm.relationship.backref` - legacy form which allows\\n        more succinct configuration, but does not support explicit typing\\n\\n    :param overlaps:\\n       A string name or comma-delimited set of names of other relationships\\n       on either this mapper, a descendant mapper, or a target mapper with\\n       which this relationship may write to the same foreign keys upon\\n       persistence.   The only effect this has is to eliminate the\\n       warning that this relationship will conflict with another upon\\n       persistence.   This is used for such relationships that are truly\\n       capable of conflicting with each other on write, but the application\\n       will ensure that no such conflicts occur.\\n\\n       .. versionadded:: 1.4\\n\\n       .. seealso::\\n\\n            :ref:`error_qzyx` - usage example\\n\\n    :param cascade:\\n      A comma-separated list of cascade rules which determines how\\n      Session operations should be \"cascaded\" from parent to child.\\n      This defaults to ``False``, which means the default cascade\\n      should be used - this default cascade is ``\"save-update, merge\"``.\\n\\n      The available cascades are ``save-update``, ``merge``,\\n      ``expunge``, ``delete``, ``delete-orphan``, and ``refresh-expire``.\\n      An additional option, ``all`` indicates shorthand for\\n      ``\"save-update, merge, refresh-expire,\\n      expunge, delete\"``, and is often used as in ``\"all, delete-orphan\"``\\n      to indicate that related objects should follow along with the\\n      parent object in all cases, and be deleted when de-associated.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - Full detail on each of the available\\n        cascade options.\\n\\n    :param cascade_backrefs=False:\\n      Legacy; this flag is always False.\\n\\n      .. versionchanged:: 2.0 \"cascade_backrefs\" functionality has been\\n         removed.\\n\\n    :param collection_class:\\n      A class or callable that returns a new list-holding object. will\\n      be used in place of a plain list for storing elements.\\n\\n      .. seealso::\\n\\n        :ref:`custom_collections` - Introductory documentation and\\n        examples.\\n\\n    :param comparator_factory:\\n      A class which extends :class:`.Relationship.Comparator`\\n      which provides custom SQL clause generation for comparison\\n      operations.\\n\\n      .. seealso::\\n\\n        :class:`.PropComparator` - some detail on redefining comparators\\n        at this level.\\n\\n        :ref:`custom_comparators` - Brief intro to this feature.\\n\\n\\n    :param distinct_target_key=None:\\n      Indicate if a \"subquery\" eager load should apply the DISTINCT\\n      keyword to the innermost SELECT statement.  When left as ``None``,\\n      the DISTINCT keyword will be applied in those cases when the target\\n      columns do not comprise the full primary key of the target table.\\n      When set to ``True``, the DISTINCT keyword is applied to the\\n      innermost SELECT unconditionally.\\n\\n      It may be desirable to set this flag to False when the DISTINCT is\\n      reducing performance of the innermost subquery beyond that of what\\n      duplicate innermost rows may be causing.\\n\\n      .. seealso::\\n\\n        :ref:`loading_toplevel` - includes an introduction to subquery\\n        eager loading.\\n\\n    :param doc:\\n      Docstring which will be applied to the resulting descriptor.\\n\\n    :param foreign_keys:\\n\\n      A list of columns which are to be used as \"foreign key\"\\n      columns, or columns which refer to the value in a remote\\n      column, within the context of this :func:`_orm.relationship`\\n      object\\'s :paramref:`_orm.relationship.primaryjoin` condition.\\n      That is, if the :paramref:`_orm.relationship.primaryjoin`\\n      condition of this :func:`_orm.relationship` is ``a.id ==\\n      b.a_id``, and the values in ``b.a_id`` are required to be\\n      present in ``a.id``, then the \"foreign key\" column of this\\n      :func:`_orm.relationship` is ``b.a_id``.\\n\\n      In normal cases, the :paramref:`_orm.relationship.foreign_keys`\\n      parameter is **not required.** :func:`_orm.relationship` will\\n      automatically determine which columns in the\\n      :paramref:`_orm.relationship.primaryjoin` condition are to be\\n      considered \"foreign key\" columns based on those\\n      :class:`_schema.Column` objects that specify\\n      :class:`_schema.ForeignKey`,\\n      or are otherwise listed as referencing columns in a\\n      :class:`_schema.ForeignKeyConstraint` construct.\\n      :paramref:`_orm.relationship.foreign_keys` is only needed when:\\n\\n        1. There is more than one way to construct a join from the local\\n           table to the remote table, as there are multiple foreign key\\n           references present.  Setting ``foreign_keys`` will limit the\\n           :func:`_orm.relationship`\\n           to consider just those columns specified\\n           here as \"foreign\".\\n\\n        2. The :class:`_schema.Table` being mapped does not actually have\\n           :class:`_schema.ForeignKey` or\\n           :class:`_schema.ForeignKeyConstraint`\\n           constructs present, often because the table\\n           was reflected from a database that does not support foreign key\\n           reflection (MySQL MyISAM).\\n\\n        3. The :paramref:`_orm.relationship.primaryjoin`\\n           argument is used to\\n           construct a non-standard join condition, which makes use of\\n           columns or expressions that do not normally refer to their\\n           \"parent\" column, such as a join condition expressed by a\\n           complex comparison using a SQL function.\\n\\n      The :func:`_orm.relationship` construct will raise informative\\n      error messages that suggest the use of the\\n      :paramref:`_orm.relationship.foreign_keys` parameter when\\n      presented with an ambiguous condition.   In typical cases,\\n      if :func:`_orm.relationship` doesn\\'t raise any exceptions, the\\n      :paramref:`_orm.relationship.foreign_keys` parameter is usually\\n      not needed.\\n\\n      :paramref:`_orm.relationship.foreign_keys` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`relationship_foreign_keys`\\n\\n        :ref:`relationship_custom_foreign`\\n\\n        :func:`.foreign` - allows direct annotation of the \"foreign\"\\n        columns within a :paramref:`_orm.relationship.primaryjoin`\\n        condition.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param innerjoin=False:\\n      When ``True``, joined eager loads will use an inner join to join\\n      against related tables instead of an outer join.  The purpose\\n      of this option is generally one of performance, as inner joins\\n      generally perform better than outer joins.\\n\\n      This flag can be set to ``True`` when the relationship references an\\n      object via many-to-one using local foreign keys that are not\\n      nullable, or when the reference is one-to-one or a collection that\\n      is guaranteed to have one or at least one entry.\\n\\n      The option supports the same \"nested\" and \"unnested\" options as\\n      that of :paramref:`_orm.joinedload.innerjoin`.  See that flag\\n      for details on nested / unnested behaviors.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.joinedload.innerjoin` - the option as specified by\\n        loader option, including detail on nesting behavior.\\n\\n        :ref:`what_kind_of_loading` - Discussion of some details of\\n        various loader options.\\n\\n\\n    :param join_depth:\\n      When non-``None``, an integer value indicating how many levels\\n      deep \"eager\" loaders should join on a self-referring or cyclical\\n      relationship.  The number counts how many times the same Mapper\\n      shall be present in the loading condition along a particular join\\n      branch.  When left at its default of ``None``, eager loaders\\n      will stop chaining when they encounter a the same target mapper\\n      which is already higher up in the chain.  This option applies\\n      both to joined- and subquery- eager loaders.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential_eager_loading` - Introductory documentation\\n        and examples.\\n\\n    :param lazy=\\'select\\': specifies\\n      How the related items should be loaded.  Default value is\\n      ``select``.  Values include:\\n\\n      * ``select`` - items should be loaded lazily when the property is\\n        first accessed, using a separate SELECT statement, or identity map\\n        fetch for simple many-to-one references.\\n\\n      * ``immediate`` - items should be loaded as the parents are loaded,\\n        using a separate SELECT statement, or identity map fetch for\\n        simple many-to-one references.\\n\\n      * ``joined`` - items should be loaded \"eagerly\" in the same query as\\n        that of the parent, using a JOIN or LEFT OUTER JOIN.  Whether\\n        the join is \"outer\" or not is determined by the\\n        :paramref:`_orm.relationship.innerjoin` parameter.\\n\\n      * ``subquery`` - items should be loaded \"eagerly\" as the parents are\\n        loaded, using one additional SQL statement, which issues a JOIN to\\n        a subquery of the original statement, for each collection\\n        requested.\\n\\n      * ``selectin`` - items should be loaded \"eagerly\" as the parents\\n        are loaded, using one or more additional SQL statements, which\\n        issues a JOIN to the immediate parent object, specifying primary\\n        key identifiers using an IN clause.\\n\\n      * ``noload`` - no loading should occur at any time.  The related\\n        collection will remain empty.   The ``noload`` strategy is not\\n        recommended for general use.  For a general use \"never load\"\\n        approach, see :ref:`write_only_relationship`\\n\\n      * ``raise`` - lazy loading is disallowed; accessing\\n        the attribute, if its value were not already loaded via eager\\n        loading, will raise an :exc:`~sqlalchemy.exc.InvalidRequestError`.\\n        This strategy can be used when objects are to be detached from\\n        their attached :class:`.Session` after they are loaded.\\n\\n      * ``raise_on_sql`` - lazy loading that emits SQL is disallowed;\\n        accessing the attribute, if its value were not already loaded via\\n        eager loading, will raise an\\n        :exc:`~sqlalchemy.exc.InvalidRequestError`, **if the lazy load\\n        needs to emit SQL**.  If the lazy load can pull the related value\\n        from the identity map or determine that it should be None, the\\n        value is loaded.  This strategy can be used when objects will\\n        remain associated with the attached :class:`.Session`, however\\n        additional SELECT statements should be blocked.\\n\\n      * ``write_only`` - the attribute will be configured with a special\\n        \"virtual collection\" that may receive\\n        :meth:`_orm.WriteOnlyCollection.add` and\\n        :meth:`_orm.WriteOnlyCollection.remove` commands to add or remove\\n        individual objects, but will not under any circumstances load or\\n        iterate the full set of objects from the database directly. Instead,\\n        methods such as :meth:`_orm.WriteOnlyCollection.select`,\\n        :meth:`_orm.WriteOnlyCollection.insert`,\\n        :meth:`_orm.WriteOnlyCollection.update` and\\n        :meth:`_orm.WriteOnlyCollection.delete` are provided which generate SQL\\n        constructs that may be used to load and modify rows in bulk. Used for\\n        large collections that are never appropriate to load at once into\\n        memory.\\n\\n        The ``write_only`` loader style is configured automatically when\\n        the :class:`_orm.WriteOnlyMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`write_only_relationship` for examples.\\n\\n        .. versionadded:: 2.0\\n\\n        .. seealso::\\n\\n            :ref:`write_only_relationship` - in the :ref:`queryguide_toplevel`\\n\\n      * ``dynamic`` - the attribute will return a pre-configured\\n        :class:`_query.Query` object for all read\\n        operations, onto which further filtering operations can be\\n        applied before iterating the results.\\n\\n        The ``dynamic`` loader style is configured automatically when\\n        the :class:`_orm.DynamicMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`dynamic_relationship` for examples.\\n\\n        .. legacy::  The \"dynamic\" lazy loader strategy is the legacy form of\\n           what is now the \"write_only\" strategy described in the section\\n           :ref:`write_only_relationship`.\\n\\n        .. seealso::\\n\\n            :ref:`dynamic_relationship` - in the :ref:`queryguide_toplevel`\\n\\n            :ref:`write_only_relationship` - more generally useful approach\\n            for large collections that should not fully load into memory\\n\\n      * True - a synonym for \\'select\\'\\n\\n      * False - a synonym for \\'joined\\'\\n\\n      * None - a synonym for \\'noload\\'\\n\\n      .. seealso::\\n\\n        :ref:`orm_queryguide_relationship_loaders` - Full documentation on\\n        relationship loader configuration in the :ref:`queryguide_toplevel`.\\n\\n\\n    :param load_on_pending=False:\\n      Indicates loading behavior for transient or pending parent objects.\\n\\n      When set to ``True``, causes the lazy-loader to\\n      issue a query for a parent object that is not persistent, meaning it\\n      has never been flushed.  This may take effect for a pending object\\n      when autoflush is disabled, or for a transient object that has been\\n      \"attached\" to a :class:`.Session` but is not part of its pending\\n      collection.\\n\\n      The :paramref:`_orm.relationship.load_on_pending`\\n      flag does not improve\\n      behavior when the ORM is used normally - object references should be\\n      constructed at the object level, not at the foreign key level, so\\n      that they are present in an ordinary way before a flush proceeds.\\n      This flag is not not intended for general use.\\n\\n      .. seealso::\\n\\n          :meth:`.Session.enable_relationship_loading` - this method\\n          establishes \"load on pending\" behavior for the whole object, and\\n          also allows loading on objects that remain transient or\\n          detached.\\n\\n    :param order_by:\\n      Indicates the ordering that should be applied when loading these\\n      items.  :paramref:`_orm.relationship.order_by`\\n      is expected to refer to\\n      one of the :class:`_schema.Column`\\n      objects to which the target class is\\n      mapped, or the attribute itself bound to the target class which\\n      refers to the column.\\n\\n      :paramref:`_orm.relationship.order_by`\\n      may also be passed as a callable\\n      function which is evaluated at mapper initialization time, and may\\n      be passed as a Python-evaluable string when using Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n    :param passive_deletes=False:\\n       Indicates loading behavior during delete operations.\\n\\n       A value of True indicates that unloaded child items should not\\n       be loaded during a delete operation on the parent.  Normally,\\n       when a parent item is deleted, all child items are loaded so\\n       that they can either be marked as deleted, or have their\\n       foreign key to the parent set to NULL.  Marking this flag as\\n       True usually implies an ON DELETE <CASCADE|SET NULL> rule is in\\n       place which will handle updating/deleting child rows on the\\n       database side.\\n\\n       Additionally, setting the flag to the string value \\'all\\' will\\n       disable the \"nulling out\" of the child foreign keys, when the parent\\n       object is deleted and there is no delete or delete-orphan cascade\\n       enabled.  This is typically used when a triggering or error raise\\n       scenario is in place on the database side.  Note that the foreign\\n       key attributes on in-session child objects will not be changed after\\n       a flush occurs so this is a very special use-case setting.\\n       Additionally, the \"nulling out\" will still occur if the child\\n       object is de-associated with the parent.\\n\\n       .. seealso::\\n\\n            :ref:`passive_deletes` - Introductory documentation\\n            and examples.\\n\\n    :param passive_updates=True:\\n      Indicates the persistence behavior to take when a referenced\\n      primary key value changes in place, indicating that the referencing\\n      foreign key columns will also need their value changed.\\n\\n      When True, it is assumed that ``ON UPDATE CASCADE`` is configured on\\n      the foreign key in the database, and that the database will\\n      handle propagation of an UPDATE from a source column to\\n      dependent rows.  When False, the SQLAlchemy\\n      :func:`_orm.relationship`\\n      construct will attempt to emit its own UPDATE statements to\\n      modify related targets.  However note that SQLAlchemy **cannot**\\n      emit an UPDATE for more than one level of cascade.  Also,\\n      setting this flag to False is not compatible in the case where\\n      the database is in fact enforcing referential integrity, unless\\n      those constraints are explicitly \"deferred\", if the target backend\\n      supports it.\\n\\n      It is highly advised that an application which is employing\\n      mutable primary keys keeps ``passive_updates`` set to True,\\n      and instead uses the referential integrity features of the database\\n      itself in order to handle the change efficiently and fully.\\n\\n      .. seealso::\\n\\n          :ref:`passive_updates` - Introductory documentation and\\n          examples.\\n\\n          :paramref:`.mapper.passive_updates` - a similar flag which\\n          takes effect for joined-table inheritance mappings.\\n\\n    :param post_update:\\n      This indicates that the relationship should be handled by a\\n      second UPDATE statement after an INSERT or before a\\n      DELETE. This flag is used to handle saving bi-directional\\n      dependencies between two individual rows (i.e. each row\\n      references the other), where it would otherwise be impossible to\\n      INSERT or DELETE both rows fully since one row exists before the\\n      other. Use this flag when a particular mapping arrangement will\\n      incur two rows that are dependent on each other, such as a table\\n      that has a one-to-many relationship to a set of child rows, and\\n      also has a column that references a single child row within that\\n      list (i.e. both tables contain a foreign key to each other). If\\n      a flush operation returns an error that a \"cyclical\\n      dependency\" was detected, this is a cue that you might want to\\n      use :paramref:`_orm.relationship.post_update` to \"break\" the cycle.\\n\\n      .. seealso::\\n\\n          :ref:`post_update` - Introductory documentation and examples.\\n\\n    :param primaryjoin:\\n      A SQL expression that will be used as the primary\\n      join of the child object against the parent object, or in a\\n      many-to-many relationship the join of the parent object to the\\n      association table. By default, this value is computed based on the\\n      foreign key relationships of the parent and child tables (or\\n      association table).\\n\\n      :paramref:`_orm.relationship.primaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param remote_side:\\n      Used for self-referential relationships, indicates the column or\\n      list of columns that form the \"remote side\" of the relationship.\\n\\n      :paramref:`_orm.relationship.remote_side` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential` - in-depth explanation of how\\n        :paramref:`_orm.relationship.remote_side`\\n        is used to configure self-referential relationships.\\n\\n        :func:`.remote` - an annotation function that accomplishes the\\n        same purpose as :paramref:`_orm.relationship.remote_side`,\\n        typically\\n        when a custom :paramref:`_orm.relationship.primaryjoin` condition\\n        is used.\\n\\n    :param query_class:\\n      A :class:`_query.Query`\\n      subclass that will be used internally by the\\n      ``AppenderQuery`` returned by a \"dynamic\" relationship, that\\n      is, a relationship that specifies ``lazy=\"dynamic\"`` or was\\n      otherwise constructed using the :func:`_orm.dynamic_loader`\\n      function.\\n\\n      .. seealso::\\n\\n        :ref:`dynamic_relationship` - Introduction to \"dynamic\"\\n        relationship loaders.\\n\\n    :param secondaryjoin:\\n      A SQL expression that will be used as the join of\\n      an association table to the child object. By default, this value is\\n      computed based on the foreign key relationships of the association\\n      and child tables.\\n\\n      :paramref:`_orm.relationship.secondaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param single_parent:\\n      When True, installs a validator which will prevent objects\\n      from being associated with more than one parent at a time.\\n      This is used for many-to-one or many-to-many relationships that\\n      should be treated either as one-to-one or one-to-many.  Its usage\\n      is optional, except for :func:`_orm.relationship` constructs which\\n      are many-to-one or many-to-many and also\\n      specify the ``delete-orphan`` cascade option.  The\\n      :func:`_orm.relationship` construct itself will raise an error\\n      instructing when this option is required.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - includes detail on when the\\n        :paramref:`_orm.relationship.single_parent`\\n        flag may be appropriate.\\n\\n    :param uselist:\\n      A boolean that indicates if this property should be loaded as a\\n      list or a scalar. In most cases, this value is determined\\n      automatically by :func:`_orm.relationship` at mapper configuration\\n      time.  When using explicit :class:`_orm.Mapped` annotations,\\n      :paramref:`_orm.relationship.uselist` may be derived from the\\n      whether or not the annotation within :class:`_orm.Mapped` contains\\n      a collection class.\\n      Otherwise, :paramref:`_orm.relationship.uselist` may be derived from\\n      the type and direction\\n      of the relationship - one to many forms a list, many to one\\n      forms a scalar, many to many is a list. If a scalar is desired\\n      where normally a list would be present, such as a bi-directional\\n      one-to-one relationship, use an appropriate :class:`_orm.Mapped`\\n      annotation or set :paramref:`_orm.relationship.uselist` to False.\\n\\n      The :paramref:`_orm.relationship.uselist`\\n      flag is also available on an\\n      existing :func:`_orm.relationship`\\n      construct as a read-only attribute,\\n      which can be used to determine if this :func:`_orm.relationship`\\n      deals\\n      with collections or scalar attributes::\\n\\n          >>> User.addresses.property.uselist\\n          True\\n\\n      .. seealso::\\n\\n          :ref:`relationships_one_to_one` - Introduction to the \"one to\\n          one\" relationship pattern, which is typically when an alternate\\n          setting for :paramref:`_orm.relationship.uselist` is involved.\\n\\n    :param viewonly=False:\\n      When set to ``True``, the relationship is used only for loading\\n      objects, and not for any persistence operation.  A\\n      :func:`_orm.relationship` which specifies\\n      :paramref:`_orm.relationship.viewonly` can work\\n      with a wider range of SQL operations within the\\n      :paramref:`_orm.relationship.primaryjoin` condition, including\\n      operations that feature the use of a variety of comparison operators\\n      as well as SQL functions such as :func:`_expression.cast`.  The\\n      :paramref:`_orm.relationship.viewonly`\\n      flag is also of general use when defining any kind of\\n      :func:`_orm.relationship` that doesn\\'t represent\\n      the full set of related objects, to prevent modifications of the\\n      collection from resulting in persistence operations.\\n\\n      When using the :paramref:`_orm.relationship.viewonly` flag in\\n      conjunction with backrefs, the originating relationship for a\\n      particular state change will not produce state changes within the\\n      viewonly relationship.   This is the behavior implied by\\n      :paramref:`_orm.relationship.sync_backref` being set to False.\\n\\n      .. versionchanged:: 1.3.17 - the\\n         :paramref:`_orm.relationship.sync_backref` flag is set to False\\n             when using viewonly in conjunction with backrefs.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.sync_backref`\\n\\n    :param sync_backref:\\n      A boolean that enables the events used to synchronize the in-Python\\n      attributes when this relationship is target of either\\n      :paramref:`_orm.relationship.backref` or\\n      :paramref:`_orm.relationship.back_populates`.\\n\\n      Defaults to ``None``, which indicates that an automatic value should\\n      be selected based on the value of the\\n      :paramref:`_orm.relationship.viewonly` flag.  When left at its\\n      default, changes in state will be back-populated only if neither\\n      sides of a relationship is viewonly.\\n\\n      .. versionadded:: 1.3.17\\n\\n      .. versionchanged:: 1.4 - A relationship that specifies\\n         :paramref:`_orm.relationship.viewonly` automatically implies\\n         that :paramref:`_orm.relationship.sync_backref` is ``False``.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.viewonly`\\n\\n    :param omit_join:\\n      Allows manual control over the \"selectin\" automatic join\\n      optimization.  Set to ``False`` to disable the \"omit join\" feature\\n      added in SQLAlchemy 1.3; or leave as ``None`` to leave automatic\\n      optimization in place.\\n\\n      .. note:: This flag may only be set to ``False``.   It is not\\n         necessary to set it to ``True`` as the \"omit_join\" optimization is\\n         automatically detected; if it is not detected, then the\\n         optimization is not supported.\\n\\n         .. versionchanged:: 1.3.11  setting ``omit_join`` to True will now\\n            emit a warning as this was not the intended use of this flag.\\n\\n      .. versionadded:: 1.3\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n\\n    '\n    return Relationship(argument, secondary=secondary, uselist=uselist, collection_class=collection_class, primaryjoin=primaryjoin, secondaryjoin=secondaryjoin, back_populates=back_populates, order_by=order_by, backref=backref, overlaps=overlaps, post_update=post_update, cascade=cascade, viewonly=viewonly, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), lazy=lazy, passive_deletes=passive_deletes, passive_updates=passive_updates, active_history=active_history, enable_typechecks=enable_typechecks, foreign_keys=foreign_keys, remote_side=remote_side, join_depth=join_depth, comparator_factory=comparator_factory, single_parent=single_parent, innerjoin=innerjoin, distinct_target_key=distinct_target_key, load_on_pending=load_on_pending, query_class=query_class, info=info, omit_join=omit_join, sync_backref=sync_backref, **kw)",
            "def relationship(argument: Optional[_RelationshipArgumentType[Any]]=None, secondary: Optional[_RelationshipSecondaryArgument]=None, *, uselist: Optional[bool]=None, collection_class: Optional[Union[Type[Collection[Any]], Callable[[], Collection[Any]]]]=None, primaryjoin: Optional[_RelationshipJoinConditionArgument]=None, secondaryjoin: Optional[_RelationshipJoinConditionArgument]=None, back_populates: Optional[str]=None, order_by: _ORMOrderByArgument=False, backref: Optional[ORMBackrefArgument]=None, overlaps: Optional[str]=None, post_update: bool=False, cascade: str='save-update, merge', viewonly: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, lazy: _LazyLoadArgumentType='select', passive_deletes: Union[Literal['all'], bool]=False, passive_updates: bool=True, active_history: bool=False, enable_typechecks: bool=True, foreign_keys: Optional[_ORMColCollectionArgument]=None, remote_side: Optional[_ORMColCollectionArgument]=None, join_depth: Optional[int]=None, comparator_factory: Optional[Type[RelationshipProperty.Comparator[Any]]]=None, single_parent: bool=False, innerjoin: bool=False, distinct_target_key: Optional[bool]=None, load_on_pending: bool=False, query_class: Optional[Type[Query[Any]]]=None, info: Optional[_InfoType]=None, omit_join: Literal[None, False]=None, sync_backref: Optional[bool]=None, **kw: Any) -> Relationship[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Provide a relationship between two mapped classes.\\n\\n    This corresponds to a parent-child or associative table relationship.\\n    The constructed class is an instance of :class:`.Relationship`.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - tutorial introduction\\n        to :func:`_orm.relationship` in the :ref:`unified_tutorial`\\n\\n        :ref:`relationship_config_toplevel` - narrative documentation\\n\\n    :param argument:\\n      This parameter refers to the class that is to be related.   It\\n      accepts several forms, including a direct reference to the target\\n      class itself, the :class:`_orm.Mapper` instance for the target class,\\n      a Python callable / lambda that will return a reference to the\\n      class or :class:`_orm.Mapper` when called, and finally a string\\n      name for the class, which will be resolved from the\\n      :class:`_orm.registry` in use in order to locate the class, e.g.::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related = relationship(\"RelatedClass\")\\n\\n      The :paramref:`_orm.relationship.argument` may also be omitted from the\\n      :func:`_orm.relationship` construct entirely, and instead placed inside\\n      a :class:`_orm.Mapped` annotation on the left side, which should\\n      include a Python collection type if the relationship is expected\\n      to be a collection, such as::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_items: Mapped[List[\"RelatedItem\"]] = relationship()\\n\\n      Or for a many-to-one or one-to-one relationship::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_item: Mapped[\"RelatedItem\"] = relationship()\\n\\n      .. seealso::\\n\\n        :ref:`orm_declarative_properties` - further detail\\n        on relationship configuration when using Declarative.\\n\\n    :param secondary:\\n      For a many-to-many relationship, specifies the intermediary\\n      table, and is typically an instance of :class:`_schema.Table`.\\n      In less common circumstances, the argument may also be specified\\n      as an :class:`_expression.Alias` construct, or even a\\n      :class:`_expression.Join` construct.\\n\\n      :paramref:`_orm.relationship.secondary` may\\n      also be passed as a callable function which is evaluated at\\n      mapper initialization time.  When using Declarative, it may also\\n      be a string argument noting the name of a :class:`_schema.Table`\\n      that is\\n      present in the :class:`_schema.MetaData`\\n      collection associated with the\\n      parent-mapped :class:`_schema.Table`.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      The :paramref:`_orm.relationship.secondary` keyword argument is\\n      typically applied in the case where the intermediary\\n      :class:`_schema.Table`\\n      is not otherwise expressed in any direct class mapping. If the\\n      \"secondary\" table is also explicitly mapped elsewhere (e.g. as in\\n      :ref:`association_pattern`), one should consider applying the\\n      :paramref:`_orm.relationship.viewonly` flag so that this\\n      :func:`_orm.relationship`\\n      is not used for persistence operations which\\n      may conflict with those of the association object pattern.\\n\\n      .. seealso::\\n\\n          :ref:`relationships_many_to_many` - Reference example of \"many\\n          to many\".\\n\\n          :ref:`self_referential_many_to_many` - Specifics on using\\n          many-to-many in a self-referential case.\\n\\n          :ref:`declarative_many_to_many` - Additional options when using\\n          Declarative.\\n\\n          :ref:`association_pattern` - an alternative to\\n          :paramref:`_orm.relationship.secondary`\\n          when composing association\\n          table relationships, allowing additional attributes to be\\n          specified on the association table.\\n\\n          :ref:`composite_secondary_join` - a lesser-used pattern which\\n          in some cases can enable complex :func:`_orm.relationship` SQL\\n          conditions to be used.\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      many-to-one reference should be loaded when replaced, if\\n      not already loaded. Normally, history tracking logic for\\n      simple many-to-ones only needs to be aware of the \"new\"\\n      value in order to perform a flush. This flag is available\\n      for applications that make use of\\n      :func:`.attributes.get_history` which also need to know\\n      the \"previous\" value of the attribute.\\n\\n    :param backref:\\n      A reference to a string relationship name, or a :func:`_orm.backref`\\n      construct, which will be used to automatically generate a new\\n      :func:`_orm.relationship` on the related class, which then refers to this\\n      one using a bi-directional :paramref:`_orm.relationship.back_populates`\\n      configuration.\\n\\n      In modern Python, explicit use of :func:`_orm.relationship`\\n      with :paramref:`_orm.relationship.back_populates` should be preferred,\\n      as it is more robust in terms of mapper configuration as well as\\n      more conceptually straightforward.  It also integrates with\\n      new :pep:`484` typing features introduced in SQLAlchemy 2.0 which\\n      is not possible with dynamically generated attributes.\\n\\n      .. seealso::\\n\\n        :ref:`relationships_backref` - notes on using\\n        :paramref:`_orm.relationship.backref`\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors using :paramref:`_orm.relationship.back_populates`\\n\\n        :func:`.backref` - allows control over :func:`_orm.relationship`\\n        configuration when using :paramref:`_orm.relationship.backref`.\\n\\n\\n    :param back_populates:\\n      Indicates the name of a :func:`_orm.relationship` on the related\\n      class that will be synchronized with this one.   It is usually\\n      expected that the :func:`_orm.relationship` on the related class\\n      also refer to this one.  This allows objects on both sides of\\n      each :func:`_orm.relationship` to synchronize in-Python state\\n      changes and also provides directives to the :term:`unit of work`\\n      flush process how changes along these relationships should\\n      be persisted.\\n\\n      .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors.\\n\\n        :ref:`relationship_patterns` - includes many examples of\\n        :paramref:`_orm.relationship.back_populates`.\\n\\n        :paramref:`_orm.relationship.backref` - legacy form which allows\\n        more succinct configuration, but does not support explicit typing\\n\\n    :param overlaps:\\n       A string name or comma-delimited set of names of other relationships\\n       on either this mapper, a descendant mapper, or a target mapper with\\n       which this relationship may write to the same foreign keys upon\\n       persistence.   The only effect this has is to eliminate the\\n       warning that this relationship will conflict with another upon\\n       persistence.   This is used for such relationships that are truly\\n       capable of conflicting with each other on write, but the application\\n       will ensure that no such conflicts occur.\\n\\n       .. versionadded:: 1.4\\n\\n       .. seealso::\\n\\n            :ref:`error_qzyx` - usage example\\n\\n    :param cascade:\\n      A comma-separated list of cascade rules which determines how\\n      Session operations should be \"cascaded\" from parent to child.\\n      This defaults to ``False``, which means the default cascade\\n      should be used - this default cascade is ``\"save-update, merge\"``.\\n\\n      The available cascades are ``save-update``, ``merge``,\\n      ``expunge``, ``delete``, ``delete-orphan``, and ``refresh-expire``.\\n      An additional option, ``all`` indicates shorthand for\\n      ``\"save-update, merge, refresh-expire,\\n      expunge, delete\"``, and is often used as in ``\"all, delete-orphan\"``\\n      to indicate that related objects should follow along with the\\n      parent object in all cases, and be deleted when de-associated.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - Full detail on each of the available\\n        cascade options.\\n\\n    :param cascade_backrefs=False:\\n      Legacy; this flag is always False.\\n\\n      .. versionchanged:: 2.0 \"cascade_backrefs\" functionality has been\\n         removed.\\n\\n    :param collection_class:\\n      A class or callable that returns a new list-holding object. will\\n      be used in place of a plain list for storing elements.\\n\\n      .. seealso::\\n\\n        :ref:`custom_collections` - Introductory documentation and\\n        examples.\\n\\n    :param comparator_factory:\\n      A class which extends :class:`.Relationship.Comparator`\\n      which provides custom SQL clause generation for comparison\\n      operations.\\n\\n      .. seealso::\\n\\n        :class:`.PropComparator` - some detail on redefining comparators\\n        at this level.\\n\\n        :ref:`custom_comparators` - Brief intro to this feature.\\n\\n\\n    :param distinct_target_key=None:\\n      Indicate if a \"subquery\" eager load should apply the DISTINCT\\n      keyword to the innermost SELECT statement.  When left as ``None``,\\n      the DISTINCT keyword will be applied in those cases when the target\\n      columns do not comprise the full primary key of the target table.\\n      When set to ``True``, the DISTINCT keyword is applied to the\\n      innermost SELECT unconditionally.\\n\\n      It may be desirable to set this flag to False when the DISTINCT is\\n      reducing performance of the innermost subquery beyond that of what\\n      duplicate innermost rows may be causing.\\n\\n      .. seealso::\\n\\n        :ref:`loading_toplevel` - includes an introduction to subquery\\n        eager loading.\\n\\n    :param doc:\\n      Docstring which will be applied to the resulting descriptor.\\n\\n    :param foreign_keys:\\n\\n      A list of columns which are to be used as \"foreign key\"\\n      columns, or columns which refer to the value in a remote\\n      column, within the context of this :func:`_orm.relationship`\\n      object\\'s :paramref:`_orm.relationship.primaryjoin` condition.\\n      That is, if the :paramref:`_orm.relationship.primaryjoin`\\n      condition of this :func:`_orm.relationship` is ``a.id ==\\n      b.a_id``, and the values in ``b.a_id`` are required to be\\n      present in ``a.id``, then the \"foreign key\" column of this\\n      :func:`_orm.relationship` is ``b.a_id``.\\n\\n      In normal cases, the :paramref:`_orm.relationship.foreign_keys`\\n      parameter is **not required.** :func:`_orm.relationship` will\\n      automatically determine which columns in the\\n      :paramref:`_orm.relationship.primaryjoin` condition are to be\\n      considered \"foreign key\" columns based on those\\n      :class:`_schema.Column` objects that specify\\n      :class:`_schema.ForeignKey`,\\n      or are otherwise listed as referencing columns in a\\n      :class:`_schema.ForeignKeyConstraint` construct.\\n      :paramref:`_orm.relationship.foreign_keys` is only needed when:\\n\\n        1. There is more than one way to construct a join from the local\\n           table to the remote table, as there are multiple foreign key\\n           references present.  Setting ``foreign_keys`` will limit the\\n           :func:`_orm.relationship`\\n           to consider just those columns specified\\n           here as \"foreign\".\\n\\n        2. The :class:`_schema.Table` being mapped does not actually have\\n           :class:`_schema.ForeignKey` or\\n           :class:`_schema.ForeignKeyConstraint`\\n           constructs present, often because the table\\n           was reflected from a database that does not support foreign key\\n           reflection (MySQL MyISAM).\\n\\n        3. The :paramref:`_orm.relationship.primaryjoin`\\n           argument is used to\\n           construct a non-standard join condition, which makes use of\\n           columns or expressions that do not normally refer to their\\n           \"parent\" column, such as a join condition expressed by a\\n           complex comparison using a SQL function.\\n\\n      The :func:`_orm.relationship` construct will raise informative\\n      error messages that suggest the use of the\\n      :paramref:`_orm.relationship.foreign_keys` parameter when\\n      presented with an ambiguous condition.   In typical cases,\\n      if :func:`_orm.relationship` doesn\\'t raise any exceptions, the\\n      :paramref:`_orm.relationship.foreign_keys` parameter is usually\\n      not needed.\\n\\n      :paramref:`_orm.relationship.foreign_keys` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`relationship_foreign_keys`\\n\\n        :ref:`relationship_custom_foreign`\\n\\n        :func:`.foreign` - allows direct annotation of the \"foreign\"\\n        columns within a :paramref:`_orm.relationship.primaryjoin`\\n        condition.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param innerjoin=False:\\n      When ``True``, joined eager loads will use an inner join to join\\n      against related tables instead of an outer join.  The purpose\\n      of this option is generally one of performance, as inner joins\\n      generally perform better than outer joins.\\n\\n      This flag can be set to ``True`` when the relationship references an\\n      object via many-to-one using local foreign keys that are not\\n      nullable, or when the reference is one-to-one or a collection that\\n      is guaranteed to have one or at least one entry.\\n\\n      The option supports the same \"nested\" and \"unnested\" options as\\n      that of :paramref:`_orm.joinedload.innerjoin`.  See that flag\\n      for details on nested / unnested behaviors.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.joinedload.innerjoin` - the option as specified by\\n        loader option, including detail on nesting behavior.\\n\\n        :ref:`what_kind_of_loading` - Discussion of some details of\\n        various loader options.\\n\\n\\n    :param join_depth:\\n      When non-``None``, an integer value indicating how many levels\\n      deep \"eager\" loaders should join on a self-referring or cyclical\\n      relationship.  The number counts how many times the same Mapper\\n      shall be present in the loading condition along a particular join\\n      branch.  When left at its default of ``None``, eager loaders\\n      will stop chaining when they encounter a the same target mapper\\n      which is already higher up in the chain.  This option applies\\n      both to joined- and subquery- eager loaders.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential_eager_loading` - Introductory documentation\\n        and examples.\\n\\n    :param lazy=\\'select\\': specifies\\n      How the related items should be loaded.  Default value is\\n      ``select``.  Values include:\\n\\n      * ``select`` - items should be loaded lazily when the property is\\n        first accessed, using a separate SELECT statement, or identity map\\n        fetch for simple many-to-one references.\\n\\n      * ``immediate`` - items should be loaded as the parents are loaded,\\n        using a separate SELECT statement, or identity map fetch for\\n        simple many-to-one references.\\n\\n      * ``joined`` - items should be loaded \"eagerly\" in the same query as\\n        that of the parent, using a JOIN or LEFT OUTER JOIN.  Whether\\n        the join is \"outer\" or not is determined by the\\n        :paramref:`_orm.relationship.innerjoin` parameter.\\n\\n      * ``subquery`` - items should be loaded \"eagerly\" as the parents are\\n        loaded, using one additional SQL statement, which issues a JOIN to\\n        a subquery of the original statement, for each collection\\n        requested.\\n\\n      * ``selectin`` - items should be loaded \"eagerly\" as the parents\\n        are loaded, using one or more additional SQL statements, which\\n        issues a JOIN to the immediate parent object, specifying primary\\n        key identifiers using an IN clause.\\n\\n      * ``noload`` - no loading should occur at any time.  The related\\n        collection will remain empty.   The ``noload`` strategy is not\\n        recommended for general use.  For a general use \"never load\"\\n        approach, see :ref:`write_only_relationship`\\n\\n      * ``raise`` - lazy loading is disallowed; accessing\\n        the attribute, if its value were not already loaded via eager\\n        loading, will raise an :exc:`~sqlalchemy.exc.InvalidRequestError`.\\n        This strategy can be used when objects are to be detached from\\n        their attached :class:`.Session` after they are loaded.\\n\\n      * ``raise_on_sql`` - lazy loading that emits SQL is disallowed;\\n        accessing the attribute, if its value were not already loaded via\\n        eager loading, will raise an\\n        :exc:`~sqlalchemy.exc.InvalidRequestError`, **if the lazy load\\n        needs to emit SQL**.  If the lazy load can pull the related value\\n        from the identity map or determine that it should be None, the\\n        value is loaded.  This strategy can be used when objects will\\n        remain associated with the attached :class:`.Session`, however\\n        additional SELECT statements should be blocked.\\n\\n      * ``write_only`` - the attribute will be configured with a special\\n        \"virtual collection\" that may receive\\n        :meth:`_orm.WriteOnlyCollection.add` and\\n        :meth:`_orm.WriteOnlyCollection.remove` commands to add or remove\\n        individual objects, but will not under any circumstances load or\\n        iterate the full set of objects from the database directly. Instead,\\n        methods such as :meth:`_orm.WriteOnlyCollection.select`,\\n        :meth:`_orm.WriteOnlyCollection.insert`,\\n        :meth:`_orm.WriteOnlyCollection.update` and\\n        :meth:`_orm.WriteOnlyCollection.delete` are provided which generate SQL\\n        constructs that may be used to load and modify rows in bulk. Used for\\n        large collections that are never appropriate to load at once into\\n        memory.\\n\\n        The ``write_only`` loader style is configured automatically when\\n        the :class:`_orm.WriteOnlyMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`write_only_relationship` for examples.\\n\\n        .. versionadded:: 2.0\\n\\n        .. seealso::\\n\\n            :ref:`write_only_relationship` - in the :ref:`queryguide_toplevel`\\n\\n      * ``dynamic`` - the attribute will return a pre-configured\\n        :class:`_query.Query` object for all read\\n        operations, onto which further filtering operations can be\\n        applied before iterating the results.\\n\\n        The ``dynamic`` loader style is configured automatically when\\n        the :class:`_orm.DynamicMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`dynamic_relationship` for examples.\\n\\n        .. legacy::  The \"dynamic\" lazy loader strategy is the legacy form of\\n           what is now the \"write_only\" strategy described in the section\\n           :ref:`write_only_relationship`.\\n\\n        .. seealso::\\n\\n            :ref:`dynamic_relationship` - in the :ref:`queryguide_toplevel`\\n\\n            :ref:`write_only_relationship` - more generally useful approach\\n            for large collections that should not fully load into memory\\n\\n      * True - a synonym for \\'select\\'\\n\\n      * False - a synonym for \\'joined\\'\\n\\n      * None - a synonym for \\'noload\\'\\n\\n      .. seealso::\\n\\n        :ref:`orm_queryguide_relationship_loaders` - Full documentation on\\n        relationship loader configuration in the :ref:`queryguide_toplevel`.\\n\\n\\n    :param load_on_pending=False:\\n      Indicates loading behavior for transient or pending parent objects.\\n\\n      When set to ``True``, causes the lazy-loader to\\n      issue a query for a parent object that is not persistent, meaning it\\n      has never been flushed.  This may take effect for a pending object\\n      when autoflush is disabled, or for a transient object that has been\\n      \"attached\" to a :class:`.Session` but is not part of its pending\\n      collection.\\n\\n      The :paramref:`_orm.relationship.load_on_pending`\\n      flag does not improve\\n      behavior when the ORM is used normally - object references should be\\n      constructed at the object level, not at the foreign key level, so\\n      that they are present in an ordinary way before a flush proceeds.\\n      This flag is not not intended for general use.\\n\\n      .. seealso::\\n\\n          :meth:`.Session.enable_relationship_loading` - this method\\n          establishes \"load on pending\" behavior for the whole object, and\\n          also allows loading on objects that remain transient or\\n          detached.\\n\\n    :param order_by:\\n      Indicates the ordering that should be applied when loading these\\n      items.  :paramref:`_orm.relationship.order_by`\\n      is expected to refer to\\n      one of the :class:`_schema.Column`\\n      objects to which the target class is\\n      mapped, or the attribute itself bound to the target class which\\n      refers to the column.\\n\\n      :paramref:`_orm.relationship.order_by`\\n      may also be passed as a callable\\n      function which is evaluated at mapper initialization time, and may\\n      be passed as a Python-evaluable string when using Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n    :param passive_deletes=False:\\n       Indicates loading behavior during delete operations.\\n\\n       A value of True indicates that unloaded child items should not\\n       be loaded during a delete operation on the parent.  Normally,\\n       when a parent item is deleted, all child items are loaded so\\n       that they can either be marked as deleted, or have their\\n       foreign key to the parent set to NULL.  Marking this flag as\\n       True usually implies an ON DELETE <CASCADE|SET NULL> rule is in\\n       place which will handle updating/deleting child rows on the\\n       database side.\\n\\n       Additionally, setting the flag to the string value \\'all\\' will\\n       disable the \"nulling out\" of the child foreign keys, when the parent\\n       object is deleted and there is no delete or delete-orphan cascade\\n       enabled.  This is typically used when a triggering or error raise\\n       scenario is in place on the database side.  Note that the foreign\\n       key attributes on in-session child objects will not be changed after\\n       a flush occurs so this is a very special use-case setting.\\n       Additionally, the \"nulling out\" will still occur if the child\\n       object is de-associated with the parent.\\n\\n       .. seealso::\\n\\n            :ref:`passive_deletes` - Introductory documentation\\n            and examples.\\n\\n    :param passive_updates=True:\\n      Indicates the persistence behavior to take when a referenced\\n      primary key value changes in place, indicating that the referencing\\n      foreign key columns will also need their value changed.\\n\\n      When True, it is assumed that ``ON UPDATE CASCADE`` is configured on\\n      the foreign key in the database, and that the database will\\n      handle propagation of an UPDATE from a source column to\\n      dependent rows.  When False, the SQLAlchemy\\n      :func:`_orm.relationship`\\n      construct will attempt to emit its own UPDATE statements to\\n      modify related targets.  However note that SQLAlchemy **cannot**\\n      emit an UPDATE for more than one level of cascade.  Also,\\n      setting this flag to False is not compatible in the case where\\n      the database is in fact enforcing referential integrity, unless\\n      those constraints are explicitly \"deferred\", if the target backend\\n      supports it.\\n\\n      It is highly advised that an application which is employing\\n      mutable primary keys keeps ``passive_updates`` set to True,\\n      and instead uses the referential integrity features of the database\\n      itself in order to handle the change efficiently and fully.\\n\\n      .. seealso::\\n\\n          :ref:`passive_updates` - Introductory documentation and\\n          examples.\\n\\n          :paramref:`.mapper.passive_updates` - a similar flag which\\n          takes effect for joined-table inheritance mappings.\\n\\n    :param post_update:\\n      This indicates that the relationship should be handled by a\\n      second UPDATE statement after an INSERT or before a\\n      DELETE. This flag is used to handle saving bi-directional\\n      dependencies between two individual rows (i.e. each row\\n      references the other), where it would otherwise be impossible to\\n      INSERT or DELETE both rows fully since one row exists before the\\n      other. Use this flag when a particular mapping arrangement will\\n      incur two rows that are dependent on each other, such as a table\\n      that has a one-to-many relationship to a set of child rows, and\\n      also has a column that references a single child row within that\\n      list (i.e. both tables contain a foreign key to each other). If\\n      a flush operation returns an error that a \"cyclical\\n      dependency\" was detected, this is a cue that you might want to\\n      use :paramref:`_orm.relationship.post_update` to \"break\" the cycle.\\n\\n      .. seealso::\\n\\n          :ref:`post_update` - Introductory documentation and examples.\\n\\n    :param primaryjoin:\\n      A SQL expression that will be used as the primary\\n      join of the child object against the parent object, or in a\\n      many-to-many relationship the join of the parent object to the\\n      association table. By default, this value is computed based on the\\n      foreign key relationships of the parent and child tables (or\\n      association table).\\n\\n      :paramref:`_orm.relationship.primaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param remote_side:\\n      Used for self-referential relationships, indicates the column or\\n      list of columns that form the \"remote side\" of the relationship.\\n\\n      :paramref:`_orm.relationship.remote_side` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential` - in-depth explanation of how\\n        :paramref:`_orm.relationship.remote_side`\\n        is used to configure self-referential relationships.\\n\\n        :func:`.remote` - an annotation function that accomplishes the\\n        same purpose as :paramref:`_orm.relationship.remote_side`,\\n        typically\\n        when a custom :paramref:`_orm.relationship.primaryjoin` condition\\n        is used.\\n\\n    :param query_class:\\n      A :class:`_query.Query`\\n      subclass that will be used internally by the\\n      ``AppenderQuery`` returned by a \"dynamic\" relationship, that\\n      is, a relationship that specifies ``lazy=\"dynamic\"`` or was\\n      otherwise constructed using the :func:`_orm.dynamic_loader`\\n      function.\\n\\n      .. seealso::\\n\\n        :ref:`dynamic_relationship` - Introduction to \"dynamic\"\\n        relationship loaders.\\n\\n    :param secondaryjoin:\\n      A SQL expression that will be used as the join of\\n      an association table to the child object. By default, this value is\\n      computed based on the foreign key relationships of the association\\n      and child tables.\\n\\n      :paramref:`_orm.relationship.secondaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param single_parent:\\n      When True, installs a validator which will prevent objects\\n      from being associated with more than one parent at a time.\\n      This is used for many-to-one or many-to-many relationships that\\n      should be treated either as one-to-one or one-to-many.  Its usage\\n      is optional, except for :func:`_orm.relationship` constructs which\\n      are many-to-one or many-to-many and also\\n      specify the ``delete-orphan`` cascade option.  The\\n      :func:`_orm.relationship` construct itself will raise an error\\n      instructing when this option is required.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - includes detail on when the\\n        :paramref:`_orm.relationship.single_parent`\\n        flag may be appropriate.\\n\\n    :param uselist:\\n      A boolean that indicates if this property should be loaded as a\\n      list or a scalar. In most cases, this value is determined\\n      automatically by :func:`_orm.relationship` at mapper configuration\\n      time.  When using explicit :class:`_orm.Mapped` annotations,\\n      :paramref:`_orm.relationship.uselist` may be derived from the\\n      whether or not the annotation within :class:`_orm.Mapped` contains\\n      a collection class.\\n      Otherwise, :paramref:`_orm.relationship.uselist` may be derived from\\n      the type and direction\\n      of the relationship - one to many forms a list, many to one\\n      forms a scalar, many to many is a list. If a scalar is desired\\n      where normally a list would be present, such as a bi-directional\\n      one-to-one relationship, use an appropriate :class:`_orm.Mapped`\\n      annotation or set :paramref:`_orm.relationship.uselist` to False.\\n\\n      The :paramref:`_orm.relationship.uselist`\\n      flag is also available on an\\n      existing :func:`_orm.relationship`\\n      construct as a read-only attribute,\\n      which can be used to determine if this :func:`_orm.relationship`\\n      deals\\n      with collections or scalar attributes::\\n\\n          >>> User.addresses.property.uselist\\n          True\\n\\n      .. seealso::\\n\\n          :ref:`relationships_one_to_one` - Introduction to the \"one to\\n          one\" relationship pattern, which is typically when an alternate\\n          setting for :paramref:`_orm.relationship.uselist` is involved.\\n\\n    :param viewonly=False:\\n      When set to ``True``, the relationship is used only for loading\\n      objects, and not for any persistence operation.  A\\n      :func:`_orm.relationship` which specifies\\n      :paramref:`_orm.relationship.viewonly` can work\\n      with a wider range of SQL operations within the\\n      :paramref:`_orm.relationship.primaryjoin` condition, including\\n      operations that feature the use of a variety of comparison operators\\n      as well as SQL functions such as :func:`_expression.cast`.  The\\n      :paramref:`_orm.relationship.viewonly`\\n      flag is also of general use when defining any kind of\\n      :func:`_orm.relationship` that doesn\\'t represent\\n      the full set of related objects, to prevent modifications of the\\n      collection from resulting in persistence operations.\\n\\n      When using the :paramref:`_orm.relationship.viewonly` flag in\\n      conjunction with backrefs, the originating relationship for a\\n      particular state change will not produce state changes within the\\n      viewonly relationship.   This is the behavior implied by\\n      :paramref:`_orm.relationship.sync_backref` being set to False.\\n\\n      .. versionchanged:: 1.3.17 - the\\n         :paramref:`_orm.relationship.sync_backref` flag is set to False\\n             when using viewonly in conjunction with backrefs.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.sync_backref`\\n\\n    :param sync_backref:\\n      A boolean that enables the events used to synchronize the in-Python\\n      attributes when this relationship is target of either\\n      :paramref:`_orm.relationship.backref` or\\n      :paramref:`_orm.relationship.back_populates`.\\n\\n      Defaults to ``None``, which indicates that an automatic value should\\n      be selected based on the value of the\\n      :paramref:`_orm.relationship.viewonly` flag.  When left at its\\n      default, changes in state will be back-populated only if neither\\n      sides of a relationship is viewonly.\\n\\n      .. versionadded:: 1.3.17\\n\\n      .. versionchanged:: 1.4 - A relationship that specifies\\n         :paramref:`_orm.relationship.viewonly` automatically implies\\n         that :paramref:`_orm.relationship.sync_backref` is ``False``.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.viewonly`\\n\\n    :param omit_join:\\n      Allows manual control over the \"selectin\" automatic join\\n      optimization.  Set to ``False`` to disable the \"omit join\" feature\\n      added in SQLAlchemy 1.3; or leave as ``None`` to leave automatic\\n      optimization in place.\\n\\n      .. note:: This flag may only be set to ``False``.   It is not\\n         necessary to set it to ``True`` as the \"omit_join\" optimization is\\n         automatically detected; if it is not detected, then the\\n         optimization is not supported.\\n\\n         .. versionchanged:: 1.3.11  setting ``omit_join`` to True will now\\n            emit a warning as this was not the intended use of this flag.\\n\\n      .. versionadded:: 1.3\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n\\n    '\n    return Relationship(argument, secondary=secondary, uselist=uselist, collection_class=collection_class, primaryjoin=primaryjoin, secondaryjoin=secondaryjoin, back_populates=back_populates, order_by=order_by, backref=backref, overlaps=overlaps, post_update=post_update, cascade=cascade, viewonly=viewonly, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), lazy=lazy, passive_deletes=passive_deletes, passive_updates=passive_updates, active_history=active_history, enable_typechecks=enable_typechecks, foreign_keys=foreign_keys, remote_side=remote_side, join_depth=join_depth, comparator_factory=comparator_factory, single_parent=single_parent, innerjoin=innerjoin, distinct_target_key=distinct_target_key, load_on_pending=load_on_pending, query_class=query_class, info=info, omit_join=omit_join, sync_backref=sync_backref, **kw)",
            "def relationship(argument: Optional[_RelationshipArgumentType[Any]]=None, secondary: Optional[_RelationshipSecondaryArgument]=None, *, uselist: Optional[bool]=None, collection_class: Optional[Union[Type[Collection[Any]], Callable[[], Collection[Any]]]]=None, primaryjoin: Optional[_RelationshipJoinConditionArgument]=None, secondaryjoin: Optional[_RelationshipJoinConditionArgument]=None, back_populates: Optional[str]=None, order_by: _ORMOrderByArgument=False, backref: Optional[ORMBackrefArgument]=None, overlaps: Optional[str]=None, post_update: bool=False, cascade: str='save-update, merge', viewonly: bool=False, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, lazy: _LazyLoadArgumentType='select', passive_deletes: Union[Literal['all'], bool]=False, passive_updates: bool=True, active_history: bool=False, enable_typechecks: bool=True, foreign_keys: Optional[_ORMColCollectionArgument]=None, remote_side: Optional[_ORMColCollectionArgument]=None, join_depth: Optional[int]=None, comparator_factory: Optional[Type[RelationshipProperty.Comparator[Any]]]=None, single_parent: bool=False, innerjoin: bool=False, distinct_target_key: Optional[bool]=None, load_on_pending: bool=False, query_class: Optional[Type[Query[Any]]]=None, info: Optional[_InfoType]=None, omit_join: Literal[None, False]=None, sync_backref: Optional[bool]=None, **kw: Any) -> Relationship[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Provide a relationship between two mapped classes.\\n\\n    This corresponds to a parent-child or associative table relationship.\\n    The constructed class is an instance of :class:`.Relationship`.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - tutorial introduction\\n        to :func:`_orm.relationship` in the :ref:`unified_tutorial`\\n\\n        :ref:`relationship_config_toplevel` - narrative documentation\\n\\n    :param argument:\\n      This parameter refers to the class that is to be related.   It\\n      accepts several forms, including a direct reference to the target\\n      class itself, the :class:`_orm.Mapper` instance for the target class,\\n      a Python callable / lambda that will return a reference to the\\n      class or :class:`_orm.Mapper` when called, and finally a string\\n      name for the class, which will be resolved from the\\n      :class:`_orm.registry` in use in order to locate the class, e.g.::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related = relationship(\"RelatedClass\")\\n\\n      The :paramref:`_orm.relationship.argument` may also be omitted from the\\n      :func:`_orm.relationship` construct entirely, and instead placed inside\\n      a :class:`_orm.Mapped` annotation on the left side, which should\\n      include a Python collection type if the relationship is expected\\n      to be a collection, such as::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_items: Mapped[List[\"RelatedItem\"]] = relationship()\\n\\n      Or for a many-to-one or one-to-one relationship::\\n\\n            class SomeClass(Base):\\n                # ...\\n\\n                related_item: Mapped[\"RelatedItem\"] = relationship()\\n\\n      .. seealso::\\n\\n        :ref:`orm_declarative_properties` - further detail\\n        on relationship configuration when using Declarative.\\n\\n    :param secondary:\\n      For a many-to-many relationship, specifies the intermediary\\n      table, and is typically an instance of :class:`_schema.Table`.\\n      In less common circumstances, the argument may also be specified\\n      as an :class:`_expression.Alias` construct, or even a\\n      :class:`_expression.Join` construct.\\n\\n      :paramref:`_orm.relationship.secondary` may\\n      also be passed as a callable function which is evaluated at\\n      mapper initialization time.  When using Declarative, it may also\\n      be a string argument noting the name of a :class:`_schema.Table`\\n      that is\\n      present in the :class:`_schema.MetaData`\\n      collection associated with the\\n      parent-mapped :class:`_schema.Table`.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      The :paramref:`_orm.relationship.secondary` keyword argument is\\n      typically applied in the case where the intermediary\\n      :class:`_schema.Table`\\n      is not otherwise expressed in any direct class mapping. If the\\n      \"secondary\" table is also explicitly mapped elsewhere (e.g. as in\\n      :ref:`association_pattern`), one should consider applying the\\n      :paramref:`_orm.relationship.viewonly` flag so that this\\n      :func:`_orm.relationship`\\n      is not used for persistence operations which\\n      may conflict with those of the association object pattern.\\n\\n      .. seealso::\\n\\n          :ref:`relationships_many_to_many` - Reference example of \"many\\n          to many\".\\n\\n          :ref:`self_referential_many_to_many` - Specifics on using\\n          many-to-many in a self-referential case.\\n\\n          :ref:`declarative_many_to_many` - Additional options when using\\n          Declarative.\\n\\n          :ref:`association_pattern` - an alternative to\\n          :paramref:`_orm.relationship.secondary`\\n          when composing association\\n          table relationships, allowing additional attributes to be\\n          specified on the association table.\\n\\n          :ref:`composite_secondary_join` - a lesser-used pattern which\\n          in some cases can enable complex :func:`_orm.relationship` SQL\\n          conditions to be used.\\n\\n    :param active_history=False:\\n      When ``True``, indicates that the \"previous\" value for a\\n      many-to-one reference should be loaded when replaced, if\\n      not already loaded. Normally, history tracking logic for\\n      simple many-to-ones only needs to be aware of the \"new\"\\n      value in order to perform a flush. This flag is available\\n      for applications that make use of\\n      :func:`.attributes.get_history` which also need to know\\n      the \"previous\" value of the attribute.\\n\\n    :param backref:\\n      A reference to a string relationship name, or a :func:`_orm.backref`\\n      construct, which will be used to automatically generate a new\\n      :func:`_orm.relationship` on the related class, which then refers to this\\n      one using a bi-directional :paramref:`_orm.relationship.back_populates`\\n      configuration.\\n\\n      In modern Python, explicit use of :func:`_orm.relationship`\\n      with :paramref:`_orm.relationship.back_populates` should be preferred,\\n      as it is more robust in terms of mapper configuration as well as\\n      more conceptually straightforward.  It also integrates with\\n      new :pep:`484` typing features introduced in SQLAlchemy 2.0 which\\n      is not possible with dynamically generated attributes.\\n\\n      .. seealso::\\n\\n        :ref:`relationships_backref` - notes on using\\n        :paramref:`_orm.relationship.backref`\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors using :paramref:`_orm.relationship.back_populates`\\n\\n        :func:`.backref` - allows control over :func:`_orm.relationship`\\n        configuration when using :paramref:`_orm.relationship.backref`.\\n\\n\\n    :param back_populates:\\n      Indicates the name of a :func:`_orm.relationship` on the related\\n      class that will be synchronized with this one.   It is usually\\n      expected that the :func:`_orm.relationship` on the related class\\n      also refer to this one.  This allows objects on both sides of\\n      each :func:`_orm.relationship` to synchronize in-Python state\\n      changes and also provides directives to the :term:`unit of work`\\n      flush process how changes along these relationships should\\n      be persisted.\\n\\n      .. seealso::\\n\\n        :ref:`tutorial_orm_related_objects` - in the :ref:`unified_tutorial`,\\n        presents an overview of bi-directional relationship configuration\\n        and behaviors.\\n\\n        :ref:`relationship_patterns` - includes many examples of\\n        :paramref:`_orm.relationship.back_populates`.\\n\\n        :paramref:`_orm.relationship.backref` - legacy form which allows\\n        more succinct configuration, but does not support explicit typing\\n\\n    :param overlaps:\\n       A string name or comma-delimited set of names of other relationships\\n       on either this mapper, a descendant mapper, or a target mapper with\\n       which this relationship may write to the same foreign keys upon\\n       persistence.   The only effect this has is to eliminate the\\n       warning that this relationship will conflict with another upon\\n       persistence.   This is used for such relationships that are truly\\n       capable of conflicting with each other on write, but the application\\n       will ensure that no such conflicts occur.\\n\\n       .. versionadded:: 1.4\\n\\n       .. seealso::\\n\\n            :ref:`error_qzyx` - usage example\\n\\n    :param cascade:\\n      A comma-separated list of cascade rules which determines how\\n      Session operations should be \"cascaded\" from parent to child.\\n      This defaults to ``False``, which means the default cascade\\n      should be used - this default cascade is ``\"save-update, merge\"``.\\n\\n      The available cascades are ``save-update``, ``merge``,\\n      ``expunge``, ``delete``, ``delete-orphan``, and ``refresh-expire``.\\n      An additional option, ``all`` indicates shorthand for\\n      ``\"save-update, merge, refresh-expire,\\n      expunge, delete\"``, and is often used as in ``\"all, delete-orphan\"``\\n      to indicate that related objects should follow along with the\\n      parent object in all cases, and be deleted when de-associated.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - Full detail on each of the available\\n        cascade options.\\n\\n    :param cascade_backrefs=False:\\n      Legacy; this flag is always False.\\n\\n      .. versionchanged:: 2.0 \"cascade_backrefs\" functionality has been\\n         removed.\\n\\n    :param collection_class:\\n      A class or callable that returns a new list-holding object. will\\n      be used in place of a plain list for storing elements.\\n\\n      .. seealso::\\n\\n        :ref:`custom_collections` - Introductory documentation and\\n        examples.\\n\\n    :param comparator_factory:\\n      A class which extends :class:`.Relationship.Comparator`\\n      which provides custom SQL clause generation for comparison\\n      operations.\\n\\n      .. seealso::\\n\\n        :class:`.PropComparator` - some detail on redefining comparators\\n        at this level.\\n\\n        :ref:`custom_comparators` - Brief intro to this feature.\\n\\n\\n    :param distinct_target_key=None:\\n      Indicate if a \"subquery\" eager load should apply the DISTINCT\\n      keyword to the innermost SELECT statement.  When left as ``None``,\\n      the DISTINCT keyword will be applied in those cases when the target\\n      columns do not comprise the full primary key of the target table.\\n      When set to ``True``, the DISTINCT keyword is applied to the\\n      innermost SELECT unconditionally.\\n\\n      It may be desirable to set this flag to False when the DISTINCT is\\n      reducing performance of the innermost subquery beyond that of what\\n      duplicate innermost rows may be causing.\\n\\n      .. seealso::\\n\\n        :ref:`loading_toplevel` - includes an introduction to subquery\\n        eager loading.\\n\\n    :param doc:\\n      Docstring which will be applied to the resulting descriptor.\\n\\n    :param foreign_keys:\\n\\n      A list of columns which are to be used as \"foreign key\"\\n      columns, or columns which refer to the value in a remote\\n      column, within the context of this :func:`_orm.relationship`\\n      object\\'s :paramref:`_orm.relationship.primaryjoin` condition.\\n      That is, if the :paramref:`_orm.relationship.primaryjoin`\\n      condition of this :func:`_orm.relationship` is ``a.id ==\\n      b.a_id``, and the values in ``b.a_id`` are required to be\\n      present in ``a.id``, then the \"foreign key\" column of this\\n      :func:`_orm.relationship` is ``b.a_id``.\\n\\n      In normal cases, the :paramref:`_orm.relationship.foreign_keys`\\n      parameter is **not required.** :func:`_orm.relationship` will\\n      automatically determine which columns in the\\n      :paramref:`_orm.relationship.primaryjoin` condition are to be\\n      considered \"foreign key\" columns based on those\\n      :class:`_schema.Column` objects that specify\\n      :class:`_schema.ForeignKey`,\\n      or are otherwise listed as referencing columns in a\\n      :class:`_schema.ForeignKeyConstraint` construct.\\n      :paramref:`_orm.relationship.foreign_keys` is only needed when:\\n\\n        1. There is more than one way to construct a join from the local\\n           table to the remote table, as there are multiple foreign key\\n           references present.  Setting ``foreign_keys`` will limit the\\n           :func:`_orm.relationship`\\n           to consider just those columns specified\\n           here as \"foreign\".\\n\\n        2. The :class:`_schema.Table` being mapped does not actually have\\n           :class:`_schema.ForeignKey` or\\n           :class:`_schema.ForeignKeyConstraint`\\n           constructs present, often because the table\\n           was reflected from a database that does not support foreign key\\n           reflection (MySQL MyISAM).\\n\\n        3. The :paramref:`_orm.relationship.primaryjoin`\\n           argument is used to\\n           construct a non-standard join condition, which makes use of\\n           columns or expressions that do not normally refer to their\\n           \"parent\" column, such as a join condition expressed by a\\n           complex comparison using a SQL function.\\n\\n      The :func:`_orm.relationship` construct will raise informative\\n      error messages that suggest the use of the\\n      :paramref:`_orm.relationship.foreign_keys` parameter when\\n      presented with an ambiguous condition.   In typical cases,\\n      if :func:`_orm.relationship` doesn\\'t raise any exceptions, the\\n      :paramref:`_orm.relationship.foreign_keys` parameter is usually\\n      not needed.\\n\\n      :paramref:`_orm.relationship.foreign_keys` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`relationship_foreign_keys`\\n\\n        :ref:`relationship_custom_foreign`\\n\\n        :func:`.foreign` - allows direct annotation of the \"foreign\"\\n        columns within a :paramref:`_orm.relationship.primaryjoin`\\n        condition.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.MapperProperty.info` attribute of this object.\\n\\n    :param innerjoin=False:\\n      When ``True``, joined eager loads will use an inner join to join\\n      against related tables instead of an outer join.  The purpose\\n      of this option is generally one of performance, as inner joins\\n      generally perform better than outer joins.\\n\\n      This flag can be set to ``True`` when the relationship references an\\n      object via many-to-one using local foreign keys that are not\\n      nullable, or when the reference is one-to-one or a collection that\\n      is guaranteed to have one or at least one entry.\\n\\n      The option supports the same \"nested\" and \"unnested\" options as\\n      that of :paramref:`_orm.joinedload.innerjoin`.  See that flag\\n      for details on nested / unnested behaviors.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.joinedload.innerjoin` - the option as specified by\\n        loader option, including detail on nesting behavior.\\n\\n        :ref:`what_kind_of_loading` - Discussion of some details of\\n        various loader options.\\n\\n\\n    :param join_depth:\\n      When non-``None``, an integer value indicating how many levels\\n      deep \"eager\" loaders should join on a self-referring or cyclical\\n      relationship.  The number counts how many times the same Mapper\\n      shall be present in the loading condition along a particular join\\n      branch.  When left at its default of ``None``, eager loaders\\n      will stop chaining when they encounter a the same target mapper\\n      which is already higher up in the chain.  This option applies\\n      both to joined- and subquery- eager loaders.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential_eager_loading` - Introductory documentation\\n        and examples.\\n\\n    :param lazy=\\'select\\': specifies\\n      How the related items should be loaded.  Default value is\\n      ``select``.  Values include:\\n\\n      * ``select`` - items should be loaded lazily when the property is\\n        first accessed, using a separate SELECT statement, or identity map\\n        fetch for simple many-to-one references.\\n\\n      * ``immediate`` - items should be loaded as the parents are loaded,\\n        using a separate SELECT statement, or identity map fetch for\\n        simple many-to-one references.\\n\\n      * ``joined`` - items should be loaded \"eagerly\" in the same query as\\n        that of the parent, using a JOIN or LEFT OUTER JOIN.  Whether\\n        the join is \"outer\" or not is determined by the\\n        :paramref:`_orm.relationship.innerjoin` parameter.\\n\\n      * ``subquery`` - items should be loaded \"eagerly\" as the parents are\\n        loaded, using one additional SQL statement, which issues a JOIN to\\n        a subquery of the original statement, for each collection\\n        requested.\\n\\n      * ``selectin`` - items should be loaded \"eagerly\" as the parents\\n        are loaded, using one or more additional SQL statements, which\\n        issues a JOIN to the immediate parent object, specifying primary\\n        key identifiers using an IN clause.\\n\\n      * ``noload`` - no loading should occur at any time.  The related\\n        collection will remain empty.   The ``noload`` strategy is not\\n        recommended for general use.  For a general use \"never load\"\\n        approach, see :ref:`write_only_relationship`\\n\\n      * ``raise`` - lazy loading is disallowed; accessing\\n        the attribute, if its value were not already loaded via eager\\n        loading, will raise an :exc:`~sqlalchemy.exc.InvalidRequestError`.\\n        This strategy can be used when objects are to be detached from\\n        their attached :class:`.Session` after they are loaded.\\n\\n      * ``raise_on_sql`` - lazy loading that emits SQL is disallowed;\\n        accessing the attribute, if its value were not already loaded via\\n        eager loading, will raise an\\n        :exc:`~sqlalchemy.exc.InvalidRequestError`, **if the lazy load\\n        needs to emit SQL**.  If the lazy load can pull the related value\\n        from the identity map or determine that it should be None, the\\n        value is loaded.  This strategy can be used when objects will\\n        remain associated with the attached :class:`.Session`, however\\n        additional SELECT statements should be blocked.\\n\\n      * ``write_only`` - the attribute will be configured with a special\\n        \"virtual collection\" that may receive\\n        :meth:`_orm.WriteOnlyCollection.add` and\\n        :meth:`_orm.WriteOnlyCollection.remove` commands to add or remove\\n        individual objects, but will not under any circumstances load or\\n        iterate the full set of objects from the database directly. Instead,\\n        methods such as :meth:`_orm.WriteOnlyCollection.select`,\\n        :meth:`_orm.WriteOnlyCollection.insert`,\\n        :meth:`_orm.WriteOnlyCollection.update` and\\n        :meth:`_orm.WriteOnlyCollection.delete` are provided which generate SQL\\n        constructs that may be used to load and modify rows in bulk. Used for\\n        large collections that are never appropriate to load at once into\\n        memory.\\n\\n        The ``write_only`` loader style is configured automatically when\\n        the :class:`_orm.WriteOnlyMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`write_only_relationship` for examples.\\n\\n        .. versionadded:: 2.0\\n\\n        .. seealso::\\n\\n            :ref:`write_only_relationship` - in the :ref:`queryguide_toplevel`\\n\\n      * ``dynamic`` - the attribute will return a pre-configured\\n        :class:`_query.Query` object for all read\\n        operations, onto which further filtering operations can be\\n        applied before iterating the results.\\n\\n        The ``dynamic`` loader style is configured automatically when\\n        the :class:`_orm.DynamicMapped` annotation is provided on the\\n        left hand side within a Declarative mapping.  See the section\\n        :ref:`dynamic_relationship` for examples.\\n\\n        .. legacy::  The \"dynamic\" lazy loader strategy is the legacy form of\\n           what is now the \"write_only\" strategy described in the section\\n           :ref:`write_only_relationship`.\\n\\n        .. seealso::\\n\\n            :ref:`dynamic_relationship` - in the :ref:`queryguide_toplevel`\\n\\n            :ref:`write_only_relationship` - more generally useful approach\\n            for large collections that should not fully load into memory\\n\\n      * True - a synonym for \\'select\\'\\n\\n      * False - a synonym for \\'joined\\'\\n\\n      * None - a synonym for \\'noload\\'\\n\\n      .. seealso::\\n\\n        :ref:`orm_queryguide_relationship_loaders` - Full documentation on\\n        relationship loader configuration in the :ref:`queryguide_toplevel`.\\n\\n\\n    :param load_on_pending=False:\\n      Indicates loading behavior for transient or pending parent objects.\\n\\n      When set to ``True``, causes the lazy-loader to\\n      issue a query for a parent object that is not persistent, meaning it\\n      has never been flushed.  This may take effect for a pending object\\n      when autoflush is disabled, or for a transient object that has been\\n      \"attached\" to a :class:`.Session` but is not part of its pending\\n      collection.\\n\\n      The :paramref:`_orm.relationship.load_on_pending`\\n      flag does not improve\\n      behavior when the ORM is used normally - object references should be\\n      constructed at the object level, not at the foreign key level, so\\n      that they are present in an ordinary way before a flush proceeds.\\n      This flag is not not intended for general use.\\n\\n      .. seealso::\\n\\n          :meth:`.Session.enable_relationship_loading` - this method\\n          establishes \"load on pending\" behavior for the whole object, and\\n          also allows loading on objects that remain transient or\\n          detached.\\n\\n    :param order_by:\\n      Indicates the ordering that should be applied when loading these\\n      items.  :paramref:`_orm.relationship.order_by`\\n      is expected to refer to\\n      one of the :class:`_schema.Column`\\n      objects to which the target class is\\n      mapped, or the attribute itself bound to the target class which\\n      refers to the column.\\n\\n      :paramref:`_orm.relationship.order_by`\\n      may also be passed as a callable\\n      function which is evaluated at mapper initialization time, and may\\n      be passed as a Python-evaluable string when using Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n    :param passive_deletes=False:\\n       Indicates loading behavior during delete operations.\\n\\n       A value of True indicates that unloaded child items should not\\n       be loaded during a delete operation on the parent.  Normally,\\n       when a parent item is deleted, all child items are loaded so\\n       that they can either be marked as deleted, or have their\\n       foreign key to the parent set to NULL.  Marking this flag as\\n       True usually implies an ON DELETE <CASCADE|SET NULL> rule is in\\n       place which will handle updating/deleting child rows on the\\n       database side.\\n\\n       Additionally, setting the flag to the string value \\'all\\' will\\n       disable the \"nulling out\" of the child foreign keys, when the parent\\n       object is deleted and there is no delete or delete-orphan cascade\\n       enabled.  This is typically used when a triggering or error raise\\n       scenario is in place on the database side.  Note that the foreign\\n       key attributes on in-session child objects will not be changed after\\n       a flush occurs so this is a very special use-case setting.\\n       Additionally, the \"nulling out\" will still occur if the child\\n       object is de-associated with the parent.\\n\\n       .. seealso::\\n\\n            :ref:`passive_deletes` - Introductory documentation\\n            and examples.\\n\\n    :param passive_updates=True:\\n      Indicates the persistence behavior to take when a referenced\\n      primary key value changes in place, indicating that the referencing\\n      foreign key columns will also need their value changed.\\n\\n      When True, it is assumed that ``ON UPDATE CASCADE`` is configured on\\n      the foreign key in the database, and that the database will\\n      handle propagation of an UPDATE from a source column to\\n      dependent rows.  When False, the SQLAlchemy\\n      :func:`_orm.relationship`\\n      construct will attempt to emit its own UPDATE statements to\\n      modify related targets.  However note that SQLAlchemy **cannot**\\n      emit an UPDATE for more than one level of cascade.  Also,\\n      setting this flag to False is not compatible in the case where\\n      the database is in fact enforcing referential integrity, unless\\n      those constraints are explicitly \"deferred\", if the target backend\\n      supports it.\\n\\n      It is highly advised that an application which is employing\\n      mutable primary keys keeps ``passive_updates`` set to True,\\n      and instead uses the referential integrity features of the database\\n      itself in order to handle the change efficiently and fully.\\n\\n      .. seealso::\\n\\n          :ref:`passive_updates` - Introductory documentation and\\n          examples.\\n\\n          :paramref:`.mapper.passive_updates` - a similar flag which\\n          takes effect for joined-table inheritance mappings.\\n\\n    :param post_update:\\n      This indicates that the relationship should be handled by a\\n      second UPDATE statement after an INSERT or before a\\n      DELETE. This flag is used to handle saving bi-directional\\n      dependencies between two individual rows (i.e. each row\\n      references the other), where it would otherwise be impossible to\\n      INSERT or DELETE both rows fully since one row exists before the\\n      other. Use this flag when a particular mapping arrangement will\\n      incur two rows that are dependent on each other, such as a table\\n      that has a one-to-many relationship to a set of child rows, and\\n      also has a column that references a single child row within that\\n      list (i.e. both tables contain a foreign key to each other). If\\n      a flush operation returns an error that a \"cyclical\\n      dependency\" was detected, this is a cue that you might want to\\n      use :paramref:`_orm.relationship.post_update` to \"break\" the cycle.\\n\\n      .. seealso::\\n\\n          :ref:`post_update` - Introductory documentation and examples.\\n\\n    :param primaryjoin:\\n      A SQL expression that will be used as the primary\\n      join of the child object against the parent object, or in a\\n      many-to-many relationship the join of the parent object to the\\n      association table. By default, this value is computed based on the\\n      foreign key relationships of the parent and child tables (or\\n      association table).\\n\\n      :paramref:`_orm.relationship.primaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param remote_side:\\n      Used for self-referential relationships, indicates the column or\\n      list of columns that form the \"remote side\" of the relationship.\\n\\n      :paramref:`_orm.relationship.remote_side` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n        :ref:`self_referential` - in-depth explanation of how\\n        :paramref:`_orm.relationship.remote_side`\\n        is used to configure self-referential relationships.\\n\\n        :func:`.remote` - an annotation function that accomplishes the\\n        same purpose as :paramref:`_orm.relationship.remote_side`,\\n        typically\\n        when a custom :paramref:`_orm.relationship.primaryjoin` condition\\n        is used.\\n\\n    :param query_class:\\n      A :class:`_query.Query`\\n      subclass that will be used internally by the\\n      ``AppenderQuery`` returned by a \"dynamic\" relationship, that\\n      is, a relationship that specifies ``lazy=\"dynamic\"`` or was\\n      otherwise constructed using the :func:`_orm.dynamic_loader`\\n      function.\\n\\n      .. seealso::\\n\\n        :ref:`dynamic_relationship` - Introduction to \"dynamic\"\\n        relationship loaders.\\n\\n    :param secondaryjoin:\\n      A SQL expression that will be used as the join of\\n      an association table to the child object. By default, this value is\\n      computed based on the foreign key relationships of the association\\n      and child tables.\\n\\n      :paramref:`_orm.relationship.secondaryjoin` may also be passed as a\\n      callable function which is evaluated at mapper initialization time,\\n      and may be passed as a Python-evaluable string when using\\n      Declarative.\\n\\n      .. warning:: When passed as a Python-evaluable string, the\\n         argument is interpreted using Python\\'s ``eval()`` function.\\n         **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.\\n         See :ref:`declarative_relationship_eval` for details on\\n         declarative evaluation of :func:`_orm.relationship` arguments.\\n\\n      .. seealso::\\n\\n          :ref:`relationship_primaryjoin`\\n\\n    :param single_parent:\\n      When True, installs a validator which will prevent objects\\n      from being associated with more than one parent at a time.\\n      This is used for many-to-one or many-to-many relationships that\\n      should be treated either as one-to-one or one-to-many.  Its usage\\n      is optional, except for :func:`_orm.relationship` constructs which\\n      are many-to-one or many-to-many and also\\n      specify the ``delete-orphan`` cascade option.  The\\n      :func:`_orm.relationship` construct itself will raise an error\\n      instructing when this option is required.\\n\\n      .. seealso::\\n\\n        :ref:`unitofwork_cascades` - includes detail on when the\\n        :paramref:`_orm.relationship.single_parent`\\n        flag may be appropriate.\\n\\n    :param uselist:\\n      A boolean that indicates if this property should be loaded as a\\n      list or a scalar. In most cases, this value is determined\\n      automatically by :func:`_orm.relationship` at mapper configuration\\n      time.  When using explicit :class:`_orm.Mapped` annotations,\\n      :paramref:`_orm.relationship.uselist` may be derived from the\\n      whether or not the annotation within :class:`_orm.Mapped` contains\\n      a collection class.\\n      Otherwise, :paramref:`_orm.relationship.uselist` may be derived from\\n      the type and direction\\n      of the relationship - one to many forms a list, many to one\\n      forms a scalar, many to many is a list. If a scalar is desired\\n      where normally a list would be present, such as a bi-directional\\n      one-to-one relationship, use an appropriate :class:`_orm.Mapped`\\n      annotation or set :paramref:`_orm.relationship.uselist` to False.\\n\\n      The :paramref:`_orm.relationship.uselist`\\n      flag is also available on an\\n      existing :func:`_orm.relationship`\\n      construct as a read-only attribute,\\n      which can be used to determine if this :func:`_orm.relationship`\\n      deals\\n      with collections or scalar attributes::\\n\\n          >>> User.addresses.property.uselist\\n          True\\n\\n      .. seealso::\\n\\n          :ref:`relationships_one_to_one` - Introduction to the \"one to\\n          one\" relationship pattern, which is typically when an alternate\\n          setting for :paramref:`_orm.relationship.uselist` is involved.\\n\\n    :param viewonly=False:\\n      When set to ``True``, the relationship is used only for loading\\n      objects, and not for any persistence operation.  A\\n      :func:`_orm.relationship` which specifies\\n      :paramref:`_orm.relationship.viewonly` can work\\n      with a wider range of SQL operations within the\\n      :paramref:`_orm.relationship.primaryjoin` condition, including\\n      operations that feature the use of a variety of comparison operators\\n      as well as SQL functions such as :func:`_expression.cast`.  The\\n      :paramref:`_orm.relationship.viewonly`\\n      flag is also of general use when defining any kind of\\n      :func:`_orm.relationship` that doesn\\'t represent\\n      the full set of related objects, to prevent modifications of the\\n      collection from resulting in persistence operations.\\n\\n      When using the :paramref:`_orm.relationship.viewonly` flag in\\n      conjunction with backrefs, the originating relationship for a\\n      particular state change will not produce state changes within the\\n      viewonly relationship.   This is the behavior implied by\\n      :paramref:`_orm.relationship.sync_backref` being set to False.\\n\\n      .. versionchanged:: 1.3.17 - the\\n         :paramref:`_orm.relationship.sync_backref` flag is set to False\\n             when using viewonly in conjunction with backrefs.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.sync_backref`\\n\\n    :param sync_backref:\\n      A boolean that enables the events used to synchronize the in-Python\\n      attributes when this relationship is target of either\\n      :paramref:`_orm.relationship.backref` or\\n      :paramref:`_orm.relationship.back_populates`.\\n\\n      Defaults to ``None``, which indicates that an automatic value should\\n      be selected based on the value of the\\n      :paramref:`_orm.relationship.viewonly` flag.  When left at its\\n      default, changes in state will be back-populated only if neither\\n      sides of a relationship is viewonly.\\n\\n      .. versionadded:: 1.3.17\\n\\n      .. versionchanged:: 1.4 - A relationship that specifies\\n         :paramref:`_orm.relationship.viewonly` automatically implies\\n         that :paramref:`_orm.relationship.sync_backref` is ``False``.\\n\\n      .. seealso::\\n\\n        :paramref:`_orm.relationship.viewonly`\\n\\n    :param omit_join:\\n      Allows manual control over the \"selectin\" automatic join\\n      optimization.  Set to ``False`` to disable the \"omit join\" feature\\n      added in SQLAlchemy 1.3; or leave as ``None`` to leave automatic\\n      optimization in place.\\n\\n      .. note:: This flag may only be set to ``False``.   It is not\\n         necessary to set it to ``True`` as the \"omit_join\" optimization is\\n         automatically detected; if it is not detected, then the\\n         optimization is not supported.\\n\\n         .. versionchanged:: 1.3.11  setting ``omit_join`` to True will now\\n            emit a warning as this was not the intended use of this flag.\\n\\n      .. versionadded:: 1.3\\n\\n    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,\\n     specifies if the mapped attribute should be part of the ``__repr__()``\\n     method as generated by the dataclass process.\\n    :param default_factory: Specific to\\n     :ref:`orm_declarative_native_dataclasses`,\\n     specifies a default-value generation function that will take place\\n     as part of the ``__init__()``\\n     method as generated by the dataclass process.\\n    :param compare: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be included in comparison operations when generating the\\n     ``__eq__()`` and ``__ne__()`` methods for the mapped class.\\n\\n     .. versionadded:: 2.0.0b4\\n\\n    :param kw_only: Specific to\\n     :ref:`orm_declarative_native_dataclasses`, indicates if this field\\n     should be marked as keyword-only when generating the ``__init__()``.\\n\\n\\n    '\n    return Relationship(argument, secondary=secondary, uselist=uselist, collection_class=collection_class, primaryjoin=primaryjoin, secondaryjoin=secondaryjoin, back_populates=back_populates, order_by=order_by, backref=backref, overlaps=overlaps, post_update=post_update, cascade=cascade, viewonly=viewonly, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), lazy=lazy, passive_deletes=passive_deletes, passive_updates=passive_updates, active_history=active_history, enable_typechecks=enable_typechecks, foreign_keys=foreign_keys, remote_side=remote_side, join_depth=join_depth, comparator_factory=comparator_factory, single_parent=single_parent, innerjoin=innerjoin, distinct_target_key=distinct_target_key, load_on_pending=load_on_pending, query_class=query_class, info=info, omit_join=omit_join, sync_backref=sync_backref, **kw)"
        ]
    },
    {
        "func_name": "synonym",
        "original": "def synonym(name: str, *, map_column: Optional[bool]=None, descriptor: Optional[Any]=None, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> Synonym[Any]:\n    \"\"\"Denote an attribute name as a synonym to a mapped property,\n    in that the attribute will mirror the value and expression behavior\n    of another attribute.\n\n    e.g.::\n\n        class MyClass(Base):\n            __tablename__ = 'my_table'\n\n            id = Column(Integer, primary_key=True)\n            job_status = Column(String(50))\n\n            status = synonym(\"job_status\")\n\n\n    :param name: the name of the existing mapped property.  This\n      can refer to the string name ORM-mapped attribute\n      configured on the class, including column-bound attributes\n      and relationships.\n\n    :param descriptor: a Python :term:`descriptor` that will be used\n      as a getter (and potentially a setter) when this attribute is\n      accessed at the instance level.\n\n    :param map_column: **For classical mappings and mappings against\n      an existing Table object only**.  if ``True``, the :func:`.synonym`\n      construct will locate the :class:`_schema.Column`\n      object upon the mapped\n      table that would normally be associated with the attribute name of\n      this synonym, and produce a new :class:`.ColumnProperty` that instead\n      maps this :class:`_schema.Column`\n      to the alternate name given as the \"name\"\n      argument of the synonym; in this way, the usual step of redefining\n      the mapping of the :class:`_schema.Column`\n      to be under a different name is\n      unnecessary. This is usually intended to be used when a\n      :class:`_schema.Column`\n      is to be replaced with an attribute that also uses a\n      descriptor, that is, in conjunction with the\n      :paramref:`.synonym.descriptor` parameter::\n\n        my_table = Table(\n            \"my_table\", metadata,\n            Column('id', Integer, primary_key=True),\n            Column('job_status', String(50))\n        )\n\n        class MyClass:\n            @property\n            def _job_status_descriptor(self):\n                return \"Status: %s\" % self._job_status\n\n\n        mapper(\n            MyClass, my_table, properties={\n                \"job_status\": synonym(\n                    \"_job_status\", map_column=True,\n                    descriptor=MyClass._job_status_descriptor)\n            }\n        )\n\n      Above, the attribute named ``_job_status`` is automatically\n      mapped to the ``job_status`` column::\n\n        >>> j1 = MyClass()\n        >>> j1._job_status = \"employed\"\n        >>> j1.job_status\n        Status: employed\n\n      When using Declarative, in order to provide a descriptor in\n      conjunction with a synonym, use the\n      :func:`sqlalchemy.ext.declarative.synonym_for` helper.  However,\n      note that the :ref:`hybrid properties <mapper_hybrids>` feature\n      should usually be preferred, particularly when redefining attribute\n      behavior.\n\n    :param info: Optional data dictionary which will be populated into the\n        :attr:`.InspectionAttr.info` attribute of this object.\n\n    :param comparator_factory: A subclass of :class:`.PropComparator`\n      that will provide custom comparison behavior at the SQL expression\n      level.\n\n      .. note::\n\n        For the use case of providing an attribute which redefines both\n        Python-level and SQL-expression level behavior of an attribute,\n        please refer to the Hybrid attribute introduced at\n        :ref:`mapper_hybrids` for a more effective technique.\n\n    .. seealso::\n\n        :ref:`synonyms` - Overview of synonyms\n\n        :func:`.synonym_for` - a helper oriented towards Declarative\n\n        :ref:`mapper_hybrids` - The Hybrid Attribute extension provides an\n        updated approach to augmenting attribute behavior more flexibly\n        than can be achieved with synonyms.\n\n    \"\"\"\n    return Synonym(name, map_column=map_column, descriptor=descriptor, comparator_factory=comparator_factory, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, info=info)",
        "mutated": [
            "def synonym(name: str, *, map_column: Optional[bool]=None, descriptor: Optional[Any]=None, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> Synonym[Any]:\n    if False:\n        i = 10\n    'Denote an attribute name as a synonym to a mapped property,\\n    in that the attribute will mirror the value and expression behavior\\n    of another attribute.\\n\\n    e.g.::\\n\\n        class MyClass(Base):\\n            __tablename__ = \\'my_table\\'\\n\\n            id = Column(Integer, primary_key=True)\\n            job_status = Column(String(50))\\n\\n            status = synonym(\"job_status\")\\n\\n\\n    :param name: the name of the existing mapped property.  This\\n      can refer to the string name ORM-mapped attribute\\n      configured on the class, including column-bound attributes\\n      and relationships.\\n\\n    :param descriptor: a Python :term:`descriptor` that will be used\\n      as a getter (and potentially a setter) when this attribute is\\n      accessed at the instance level.\\n\\n    :param map_column: **For classical mappings and mappings against\\n      an existing Table object only**.  if ``True``, the :func:`.synonym`\\n      construct will locate the :class:`_schema.Column`\\n      object upon the mapped\\n      table that would normally be associated with the attribute name of\\n      this synonym, and produce a new :class:`.ColumnProperty` that instead\\n      maps this :class:`_schema.Column`\\n      to the alternate name given as the \"name\"\\n      argument of the synonym; in this way, the usual step of redefining\\n      the mapping of the :class:`_schema.Column`\\n      to be under a different name is\\n      unnecessary. This is usually intended to be used when a\\n      :class:`_schema.Column`\\n      is to be replaced with an attribute that also uses a\\n      descriptor, that is, in conjunction with the\\n      :paramref:`.synonym.descriptor` parameter::\\n\\n        my_table = Table(\\n            \"my_table\", metadata,\\n            Column(\\'id\\', Integer, primary_key=True),\\n            Column(\\'job_status\\', String(50))\\n        )\\n\\n        class MyClass:\\n            @property\\n            def _job_status_descriptor(self):\\n                return \"Status: %s\" % self._job_status\\n\\n\\n        mapper(\\n            MyClass, my_table, properties={\\n                \"job_status\": synonym(\\n                    \"_job_status\", map_column=True,\\n                    descriptor=MyClass._job_status_descriptor)\\n            }\\n        )\\n\\n      Above, the attribute named ``_job_status`` is automatically\\n      mapped to the ``job_status`` column::\\n\\n        >>> j1 = MyClass()\\n        >>> j1._job_status = \"employed\"\\n        >>> j1.job_status\\n        Status: employed\\n\\n      When using Declarative, in order to provide a descriptor in\\n      conjunction with a synonym, use the\\n      :func:`sqlalchemy.ext.declarative.synonym_for` helper.  However,\\n      note that the :ref:`hybrid properties <mapper_hybrids>` feature\\n      should usually be preferred, particularly when redefining attribute\\n      behavior.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.InspectionAttr.info` attribute of this object.\\n\\n    :param comparator_factory: A subclass of :class:`.PropComparator`\\n      that will provide custom comparison behavior at the SQL expression\\n      level.\\n\\n      .. note::\\n\\n        For the use case of providing an attribute which redefines both\\n        Python-level and SQL-expression level behavior of an attribute,\\n        please refer to the Hybrid attribute introduced at\\n        :ref:`mapper_hybrids` for a more effective technique.\\n\\n    .. seealso::\\n\\n        :ref:`synonyms` - Overview of synonyms\\n\\n        :func:`.synonym_for` - a helper oriented towards Declarative\\n\\n        :ref:`mapper_hybrids` - The Hybrid Attribute extension provides an\\n        updated approach to augmenting attribute behavior more flexibly\\n        than can be achieved with synonyms.\\n\\n    '\n    return Synonym(name, map_column=map_column, descriptor=descriptor, comparator_factory=comparator_factory, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, info=info)",
            "def synonym(name: str, *, map_column: Optional[bool]=None, descriptor: Optional[Any]=None, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> Synonym[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Denote an attribute name as a synonym to a mapped property,\\n    in that the attribute will mirror the value and expression behavior\\n    of another attribute.\\n\\n    e.g.::\\n\\n        class MyClass(Base):\\n            __tablename__ = \\'my_table\\'\\n\\n            id = Column(Integer, primary_key=True)\\n            job_status = Column(String(50))\\n\\n            status = synonym(\"job_status\")\\n\\n\\n    :param name: the name of the existing mapped property.  This\\n      can refer to the string name ORM-mapped attribute\\n      configured on the class, including column-bound attributes\\n      and relationships.\\n\\n    :param descriptor: a Python :term:`descriptor` that will be used\\n      as a getter (and potentially a setter) when this attribute is\\n      accessed at the instance level.\\n\\n    :param map_column: **For classical mappings and mappings against\\n      an existing Table object only**.  if ``True``, the :func:`.synonym`\\n      construct will locate the :class:`_schema.Column`\\n      object upon the mapped\\n      table that would normally be associated with the attribute name of\\n      this synonym, and produce a new :class:`.ColumnProperty` that instead\\n      maps this :class:`_schema.Column`\\n      to the alternate name given as the \"name\"\\n      argument of the synonym; in this way, the usual step of redefining\\n      the mapping of the :class:`_schema.Column`\\n      to be under a different name is\\n      unnecessary. This is usually intended to be used when a\\n      :class:`_schema.Column`\\n      is to be replaced with an attribute that also uses a\\n      descriptor, that is, in conjunction with the\\n      :paramref:`.synonym.descriptor` parameter::\\n\\n        my_table = Table(\\n            \"my_table\", metadata,\\n            Column(\\'id\\', Integer, primary_key=True),\\n            Column(\\'job_status\\', String(50))\\n        )\\n\\n        class MyClass:\\n            @property\\n            def _job_status_descriptor(self):\\n                return \"Status: %s\" % self._job_status\\n\\n\\n        mapper(\\n            MyClass, my_table, properties={\\n                \"job_status\": synonym(\\n                    \"_job_status\", map_column=True,\\n                    descriptor=MyClass._job_status_descriptor)\\n            }\\n        )\\n\\n      Above, the attribute named ``_job_status`` is automatically\\n      mapped to the ``job_status`` column::\\n\\n        >>> j1 = MyClass()\\n        >>> j1._job_status = \"employed\"\\n        >>> j1.job_status\\n        Status: employed\\n\\n      When using Declarative, in order to provide a descriptor in\\n      conjunction with a synonym, use the\\n      :func:`sqlalchemy.ext.declarative.synonym_for` helper.  However,\\n      note that the :ref:`hybrid properties <mapper_hybrids>` feature\\n      should usually be preferred, particularly when redefining attribute\\n      behavior.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.InspectionAttr.info` attribute of this object.\\n\\n    :param comparator_factory: A subclass of :class:`.PropComparator`\\n      that will provide custom comparison behavior at the SQL expression\\n      level.\\n\\n      .. note::\\n\\n        For the use case of providing an attribute which redefines both\\n        Python-level and SQL-expression level behavior of an attribute,\\n        please refer to the Hybrid attribute introduced at\\n        :ref:`mapper_hybrids` for a more effective technique.\\n\\n    .. seealso::\\n\\n        :ref:`synonyms` - Overview of synonyms\\n\\n        :func:`.synonym_for` - a helper oriented towards Declarative\\n\\n        :ref:`mapper_hybrids` - The Hybrid Attribute extension provides an\\n        updated approach to augmenting attribute behavior more flexibly\\n        than can be achieved with synonyms.\\n\\n    '\n    return Synonym(name, map_column=map_column, descriptor=descriptor, comparator_factory=comparator_factory, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, info=info)",
            "def synonym(name: str, *, map_column: Optional[bool]=None, descriptor: Optional[Any]=None, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> Synonym[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Denote an attribute name as a synonym to a mapped property,\\n    in that the attribute will mirror the value and expression behavior\\n    of another attribute.\\n\\n    e.g.::\\n\\n        class MyClass(Base):\\n            __tablename__ = \\'my_table\\'\\n\\n            id = Column(Integer, primary_key=True)\\n            job_status = Column(String(50))\\n\\n            status = synonym(\"job_status\")\\n\\n\\n    :param name: the name of the existing mapped property.  This\\n      can refer to the string name ORM-mapped attribute\\n      configured on the class, including column-bound attributes\\n      and relationships.\\n\\n    :param descriptor: a Python :term:`descriptor` that will be used\\n      as a getter (and potentially a setter) when this attribute is\\n      accessed at the instance level.\\n\\n    :param map_column: **For classical mappings and mappings against\\n      an existing Table object only**.  if ``True``, the :func:`.synonym`\\n      construct will locate the :class:`_schema.Column`\\n      object upon the mapped\\n      table that would normally be associated with the attribute name of\\n      this synonym, and produce a new :class:`.ColumnProperty` that instead\\n      maps this :class:`_schema.Column`\\n      to the alternate name given as the \"name\"\\n      argument of the synonym; in this way, the usual step of redefining\\n      the mapping of the :class:`_schema.Column`\\n      to be under a different name is\\n      unnecessary. This is usually intended to be used when a\\n      :class:`_schema.Column`\\n      is to be replaced with an attribute that also uses a\\n      descriptor, that is, in conjunction with the\\n      :paramref:`.synonym.descriptor` parameter::\\n\\n        my_table = Table(\\n            \"my_table\", metadata,\\n            Column(\\'id\\', Integer, primary_key=True),\\n            Column(\\'job_status\\', String(50))\\n        )\\n\\n        class MyClass:\\n            @property\\n            def _job_status_descriptor(self):\\n                return \"Status: %s\" % self._job_status\\n\\n\\n        mapper(\\n            MyClass, my_table, properties={\\n                \"job_status\": synonym(\\n                    \"_job_status\", map_column=True,\\n                    descriptor=MyClass._job_status_descriptor)\\n            }\\n        )\\n\\n      Above, the attribute named ``_job_status`` is automatically\\n      mapped to the ``job_status`` column::\\n\\n        >>> j1 = MyClass()\\n        >>> j1._job_status = \"employed\"\\n        >>> j1.job_status\\n        Status: employed\\n\\n      When using Declarative, in order to provide a descriptor in\\n      conjunction with a synonym, use the\\n      :func:`sqlalchemy.ext.declarative.synonym_for` helper.  However,\\n      note that the :ref:`hybrid properties <mapper_hybrids>` feature\\n      should usually be preferred, particularly when redefining attribute\\n      behavior.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.InspectionAttr.info` attribute of this object.\\n\\n    :param comparator_factory: A subclass of :class:`.PropComparator`\\n      that will provide custom comparison behavior at the SQL expression\\n      level.\\n\\n      .. note::\\n\\n        For the use case of providing an attribute which redefines both\\n        Python-level and SQL-expression level behavior of an attribute,\\n        please refer to the Hybrid attribute introduced at\\n        :ref:`mapper_hybrids` for a more effective technique.\\n\\n    .. seealso::\\n\\n        :ref:`synonyms` - Overview of synonyms\\n\\n        :func:`.synonym_for` - a helper oriented towards Declarative\\n\\n        :ref:`mapper_hybrids` - The Hybrid Attribute extension provides an\\n        updated approach to augmenting attribute behavior more flexibly\\n        than can be achieved with synonyms.\\n\\n    '\n    return Synonym(name, map_column=map_column, descriptor=descriptor, comparator_factory=comparator_factory, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, info=info)",
            "def synonym(name: str, *, map_column: Optional[bool]=None, descriptor: Optional[Any]=None, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> Synonym[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Denote an attribute name as a synonym to a mapped property,\\n    in that the attribute will mirror the value and expression behavior\\n    of another attribute.\\n\\n    e.g.::\\n\\n        class MyClass(Base):\\n            __tablename__ = \\'my_table\\'\\n\\n            id = Column(Integer, primary_key=True)\\n            job_status = Column(String(50))\\n\\n            status = synonym(\"job_status\")\\n\\n\\n    :param name: the name of the existing mapped property.  This\\n      can refer to the string name ORM-mapped attribute\\n      configured on the class, including column-bound attributes\\n      and relationships.\\n\\n    :param descriptor: a Python :term:`descriptor` that will be used\\n      as a getter (and potentially a setter) when this attribute is\\n      accessed at the instance level.\\n\\n    :param map_column: **For classical mappings and mappings against\\n      an existing Table object only**.  if ``True``, the :func:`.synonym`\\n      construct will locate the :class:`_schema.Column`\\n      object upon the mapped\\n      table that would normally be associated with the attribute name of\\n      this synonym, and produce a new :class:`.ColumnProperty` that instead\\n      maps this :class:`_schema.Column`\\n      to the alternate name given as the \"name\"\\n      argument of the synonym; in this way, the usual step of redefining\\n      the mapping of the :class:`_schema.Column`\\n      to be under a different name is\\n      unnecessary. This is usually intended to be used when a\\n      :class:`_schema.Column`\\n      is to be replaced with an attribute that also uses a\\n      descriptor, that is, in conjunction with the\\n      :paramref:`.synonym.descriptor` parameter::\\n\\n        my_table = Table(\\n            \"my_table\", metadata,\\n            Column(\\'id\\', Integer, primary_key=True),\\n            Column(\\'job_status\\', String(50))\\n        )\\n\\n        class MyClass:\\n            @property\\n            def _job_status_descriptor(self):\\n                return \"Status: %s\" % self._job_status\\n\\n\\n        mapper(\\n            MyClass, my_table, properties={\\n                \"job_status\": synonym(\\n                    \"_job_status\", map_column=True,\\n                    descriptor=MyClass._job_status_descriptor)\\n            }\\n        )\\n\\n      Above, the attribute named ``_job_status`` is automatically\\n      mapped to the ``job_status`` column::\\n\\n        >>> j1 = MyClass()\\n        >>> j1._job_status = \"employed\"\\n        >>> j1.job_status\\n        Status: employed\\n\\n      When using Declarative, in order to provide a descriptor in\\n      conjunction with a synonym, use the\\n      :func:`sqlalchemy.ext.declarative.synonym_for` helper.  However,\\n      note that the :ref:`hybrid properties <mapper_hybrids>` feature\\n      should usually be preferred, particularly when redefining attribute\\n      behavior.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.InspectionAttr.info` attribute of this object.\\n\\n    :param comparator_factory: A subclass of :class:`.PropComparator`\\n      that will provide custom comparison behavior at the SQL expression\\n      level.\\n\\n      .. note::\\n\\n        For the use case of providing an attribute which redefines both\\n        Python-level and SQL-expression level behavior of an attribute,\\n        please refer to the Hybrid attribute introduced at\\n        :ref:`mapper_hybrids` for a more effective technique.\\n\\n    .. seealso::\\n\\n        :ref:`synonyms` - Overview of synonyms\\n\\n        :func:`.synonym_for` - a helper oriented towards Declarative\\n\\n        :ref:`mapper_hybrids` - The Hybrid Attribute extension provides an\\n        updated approach to augmenting attribute behavior more flexibly\\n        than can be achieved with synonyms.\\n\\n    '\n    return Synonym(name, map_column=map_column, descriptor=descriptor, comparator_factory=comparator_factory, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, info=info)",
            "def synonym(name: str, *, map_column: Optional[bool]=None, descriptor: Optional[Any]=None, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Union[_NoArg, _T]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> Synonym[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Denote an attribute name as a synonym to a mapped property,\\n    in that the attribute will mirror the value and expression behavior\\n    of another attribute.\\n\\n    e.g.::\\n\\n        class MyClass(Base):\\n            __tablename__ = \\'my_table\\'\\n\\n            id = Column(Integer, primary_key=True)\\n            job_status = Column(String(50))\\n\\n            status = synonym(\"job_status\")\\n\\n\\n    :param name: the name of the existing mapped property.  This\\n      can refer to the string name ORM-mapped attribute\\n      configured on the class, including column-bound attributes\\n      and relationships.\\n\\n    :param descriptor: a Python :term:`descriptor` that will be used\\n      as a getter (and potentially a setter) when this attribute is\\n      accessed at the instance level.\\n\\n    :param map_column: **For classical mappings and mappings against\\n      an existing Table object only**.  if ``True``, the :func:`.synonym`\\n      construct will locate the :class:`_schema.Column`\\n      object upon the mapped\\n      table that would normally be associated with the attribute name of\\n      this synonym, and produce a new :class:`.ColumnProperty` that instead\\n      maps this :class:`_schema.Column`\\n      to the alternate name given as the \"name\"\\n      argument of the synonym; in this way, the usual step of redefining\\n      the mapping of the :class:`_schema.Column`\\n      to be under a different name is\\n      unnecessary. This is usually intended to be used when a\\n      :class:`_schema.Column`\\n      is to be replaced with an attribute that also uses a\\n      descriptor, that is, in conjunction with the\\n      :paramref:`.synonym.descriptor` parameter::\\n\\n        my_table = Table(\\n            \"my_table\", metadata,\\n            Column(\\'id\\', Integer, primary_key=True),\\n            Column(\\'job_status\\', String(50))\\n        )\\n\\n        class MyClass:\\n            @property\\n            def _job_status_descriptor(self):\\n                return \"Status: %s\" % self._job_status\\n\\n\\n        mapper(\\n            MyClass, my_table, properties={\\n                \"job_status\": synonym(\\n                    \"_job_status\", map_column=True,\\n                    descriptor=MyClass._job_status_descriptor)\\n            }\\n        )\\n\\n      Above, the attribute named ``_job_status`` is automatically\\n      mapped to the ``job_status`` column::\\n\\n        >>> j1 = MyClass()\\n        >>> j1._job_status = \"employed\"\\n        >>> j1.job_status\\n        Status: employed\\n\\n      When using Declarative, in order to provide a descriptor in\\n      conjunction with a synonym, use the\\n      :func:`sqlalchemy.ext.declarative.synonym_for` helper.  However,\\n      note that the :ref:`hybrid properties <mapper_hybrids>` feature\\n      should usually be preferred, particularly when redefining attribute\\n      behavior.\\n\\n    :param info: Optional data dictionary which will be populated into the\\n        :attr:`.InspectionAttr.info` attribute of this object.\\n\\n    :param comparator_factory: A subclass of :class:`.PropComparator`\\n      that will provide custom comparison behavior at the SQL expression\\n      level.\\n\\n      .. note::\\n\\n        For the use case of providing an attribute which redefines both\\n        Python-level and SQL-expression level behavior of an attribute,\\n        please refer to the Hybrid attribute introduced at\\n        :ref:`mapper_hybrids` for a more effective technique.\\n\\n    .. seealso::\\n\\n        :ref:`synonyms` - Overview of synonyms\\n\\n        :func:`.synonym_for` - a helper oriented towards Declarative\\n\\n        :ref:`mapper_hybrids` - The Hybrid Attribute extension provides an\\n        updated approach to augmenting attribute behavior more flexibly\\n        than can be achieved with synonyms.\\n\\n    '\n    return Synonym(name, map_column=map_column, descriptor=descriptor, comparator_factory=comparator_factory, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), doc=doc, info=info)"
        ]
    },
    {
        "func_name": "create_session",
        "original": "def create_session(bind: Optional[_SessionBind]=None, **kwargs: Any) -> Session:\n    \"\"\"Create a new :class:`.Session`\n    with no automation enabled by default.\n\n    This function is used primarily for testing.   The usual\n    route to :class:`.Session` creation is via its constructor\n    or the :func:`.sessionmaker` function.\n\n    :param bind: optional, a single Connectable to use for all\n      database access in the created\n      :class:`~sqlalchemy.orm.session.Session`.\n\n    :param \\\\*\\\\*kwargs: optional, passed through to the\n      :class:`.Session` constructor.\n\n    :returns: an :class:`~sqlalchemy.orm.session.Session` instance\n\n    The defaults of create_session() are the opposite of that of\n    :func:`sessionmaker`; ``autoflush`` and ``expire_on_commit`` are\n    False.\n\n    Usage::\n\n      >>> from sqlalchemy.orm import create_session\n      >>> session = create_session()\n\n    It is recommended to use :func:`sessionmaker` instead of\n    create_session().\n\n    \"\"\"\n    kwargs.setdefault('autoflush', False)\n    kwargs.setdefault('expire_on_commit', False)\n    return Session(bind=bind, **kwargs)",
        "mutated": [
            "def create_session(bind: Optional[_SessionBind]=None, **kwargs: Any) -> Session:\n    if False:\n        i = 10\n    'Create a new :class:`.Session`\\n    with no automation enabled by default.\\n\\n    This function is used primarily for testing.   The usual\\n    route to :class:`.Session` creation is via its constructor\\n    or the :func:`.sessionmaker` function.\\n\\n    :param bind: optional, a single Connectable to use for all\\n      database access in the created\\n      :class:`~sqlalchemy.orm.session.Session`.\\n\\n    :param \\\\*\\\\*kwargs: optional, passed through to the\\n      :class:`.Session` constructor.\\n\\n    :returns: an :class:`~sqlalchemy.orm.session.Session` instance\\n\\n    The defaults of create_session() are the opposite of that of\\n    :func:`sessionmaker`; ``autoflush`` and ``expire_on_commit`` are\\n    False.\\n\\n    Usage::\\n\\n      >>> from sqlalchemy.orm import create_session\\n      >>> session = create_session()\\n\\n    It is recommended to use :func:`sessionmaker` instead of\\n    create_session().\\n\\n    '\n    kwargs.setdefault('autoflush', False)\n    kwargs.setdefault('expire_on_commit', False)\n    return Session(bind=bind, **kwargs)",
            "def create_session(bind: Optional[_SessionBind]=None, **kwargs: Any) -> Session:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create a new :class:`.Session`\\n    with no automation enabled by default.\\n\\n    This function is used primarily for testing.   The usual\\n    route to :class:`.Session` creation is via its constructor\\n    or the :func:`.sessionmaker` function.\\n\\n    :param bind: optional, a single Connectable to use for all\\n      database access in the created\\n      :class:`~sqlalchemy.orm.session.Session`.\\n\\n    :param \\\\*\\\\*kwargs: optional, passed through to the\\n      :class:`.Session` constructor.\\n\\n    :returns: an :class:`~sqlalchemy.orm.session.Session` instance\\n\\n    The defaults of create_session() are the opposite of that of\\n    :func:`sessionmaker`; ``autoflush`` and ``expire_on_commit`` are\\n    False.\\n\\n    Usage::\\n\\n      >>> from sqlalchemy.orm import create_session\\n      >>> session = create_session()\\n\\n    It is recommended to use :func:`sessionmaker` instead of\\n    create_session().\\n\\n    '\n    kwargs.setdefault('autoflush', False)\n    kwargs.setdefault('expire_on_commit', False)\n    return Session(bind=bind, **kwargs)",
            "def create_session(bind: Optional[_SessionBind]=None, **kwargs: Any) -> Session:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create a new :class:`.Session`\\n    with no automation enabled by default.\\n\\n    This function is used primarily for testing.   The usual\\n    route to :class:`.Session` creation is via its constructor\\n    or the :func:`.sessionmaker` function.\\n\\n    :param bind: optional, a single Connectable to use for all\\n      database access in the created\\n      :class:`~sqlalchemy.orm.session.Session`.\\n\\n    :param \\\\*\\\\*kwargs: optional, passed through to the\\n      :class:`.Session` constructor.\\n\\n    :returns: an :class:`~sqlalchemy.orm.session.Session` instance\\n\\n    The defaults of create_session() are the opposite of that of\\n    :func:`sessionmaker`; ``autoflush`` and ``expire_on_commit`` are\\n    False.\\n\\n    Usage::\\n\\n      >>> from sqlalchemy.orm import create_session\\n      >>> session = create_session()\\n\\n    It is recommended to use :func:`sessionmaker` instead of\\n    create_session().\\n\\n    '\n    kwargs.setdefault('autoflush', False)\n    kwargs.setdefault('expire_on_commit', False)\n    return Session(bind=bind, **kwargs)",
            "def create_session(bind: Optional[_SessionBind]=None, **kwargs: Any) -> Session:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create a new :class:`.Session`\\n    with no automation enabled by default.\\n\\n    This function is used primarily for testing.   The usual\\n    route to :class:`.Session` creation is via its constructor\\n    or the :func:`.sessionmaker` function.\\n\\n    :param bind: optional, a single Connectable to use for all\\n      database access in the created\\n      :class:`~sqlalchemy.orm.session.Session`.\\n\\n    :param \\\\*\\\\*kwargs: optional, passed through to the\\n      :class:`.Session` constructor.\\n\\n    :returns: an :class:`~sqlalchemy.orm.session.Session` instance\\n\\n    The defaults of create_session() are the opposite of that of\\n    :func:`sessionmaker`; ``autoflush`` and ``expire_on_commit`` are\\n    False.\\n\\n    Usage::\\n\\n      >>> from sqlalchemy.orm import create_session\\n      >>> session = create_session()\\n\\n    It is recommended to use :func:`sessionmaker` instead of\\n    create_session().\\n\\n    '\n    kwargs.setdefault('autoflush', False)\n    kwargs.setdefault('expire_on_commit', False)\n    return Session(bind=bind, **kwargs)",
            "def create_session(bind: Optional[_SessionBind]=None, **kwargs: Any) -> Session:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create a new :class:`.Session`\\n    with no automation enabled by default.\\n\\n    This function is used primarily for testing.   The usual\\n    route to :class:`.Session` creation is via its constructor\\n    or the :func:`.sessionmaker` function.\\n\\n    :param bind: optional, a single Connectable to use for all\\n      database access in the created\\n      :class:`~sqlalchemy.orm.session.Session`.\\n\\n    :param \\\\*\\\\*kwargs: optional, passed through to the\\n      :class:`.Session` constructor.\\n\\n    :returns: an :class:`~sqlalchemy.orm.session.Session` instance\\n\\n    The defaults of create_session() are the opposite of that of\\n    :func:`sessionmaker`; ``autoflush`` and ``expire_on_commit`` are\\n    False.\\n\\n    Usage::\\n\\n      >>> from sqlalchemy.orm import create_session\\n      >>> session = create_session()\\n\\n    It is recommended to use :func:`sessionmaker` instead of\\n    create_session().\\n\\n    '\n    kwargs.setdefault('autoflush', False)\n    kwargs.setdefault('expire_on_commit', False)\n    return Session(bind=bind, **kwargs)"
        ]
    },
    {
        "func_name": "_mapper_fn",
        "original": "def _mapper_fn(*arg: Any, **kw: Any) -> NoReturn:\n    \"\"\"Placeholder for the now-removed ``mapper()`` function.\n\n    Classical mappings should be performed using the\n    :meth:`_orm.registry.map_imperatively` method.\n\n    This symbol remains in SQLAlchemy 2.0 to suit the deprecated use case\n    of using the ``mapper()`` function as a target for ORM event listeners,\n    which failed to be marked as deprecated in the 1.4 series.\n\n    Global ORM mapper listeners should instead use the :class:`_orm.Mapper`\n    class as the target.\n\n    .. versionchanged:: 2.0  The ``mapper()`` function was removed; the\n       symbol remains temporarily as a placeholder for the event listening\n       use case.\n\n    \"\"\"\n    raise InvalidRequestError(\"The 'sqlalchemy.orm.mapper()' function is removed as of SQLAlchemy 2.0.  Use the 'sqlalchemy.orm.registry.map_imperatively()` method of the ``sqlalchemy.orm.registry`` class to perform classical mapping.\")",
        "mutated": [
            "def _mapper_fn(*arg: Any, **kw: Any) -> NoReturn:\n    if False:\n        i = 10\n    'Placeholder for the now-removed ``mapper()`` function.\\n\\n    Classical mappings should be performed using the\\n    :meth:`_orm.registry.map_imperatively` method.\\n\\n    This symbol remains in SQLAlchemy 2.0 to suit the deprecated use case\\n    of using the ``mapper()`` function as a target for ORM event listeners,\\n    which failed to be marked as deprecated in the 1.4 series.\\n\\n    Global ORM mapper listeners should instead use the :class:`_orm.Mapper`\\n    class as the target.\\n\\n    .. versionchanged:: 2.0  The ``mapper()`` function was removed; the\\n       symbol remains temporarily as a placeholder for the event listening\\n       use case.\\n\\n    '\n    raise InvalidRequestError(\"The 'sqlalchemy.orm.mapper()' function is removed as of SQLAlchemy 2.0.  Use the 'sqlalchemy.orm.registry.map_imperatively()` method of the ``sqlalchemy.orm.registry`` class to perform classical mapping.\")",
            "def _mapper_fn(*arg: Any, **kw: Any) -> NoReturn:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Placeholder for the now-removed ``mapper()`` function.\\n\\n    Classical mappings should be performed using the\\n    :meth:`_orm.registry.map_imperatively` method.\\n\\n    This symbol remains in SQLAlchemy 2.0 to suit the deprecated use case\\n    of using the ``mapper()`` function as a target for ORM event listeners,\\n    which failed to be marked as deprecated in the 1.4 series.\\n\\n    Global ORM mapper listeners should instead use the :class:`_orm.Mapper`\\n    class as the target.\\n\\n    .. versionchanged:: 2.0  The ``mapper()`` function was removed; the\\n       symbol remains temporarily as a placeholder for the event listening\\n       use case.\\n\\n    '\n    raise InvalidRequestError(\"The 'sqlalchemy.orm.mapper()' function is removed as of SQLAlchemy 2.0.  Use the 'sqlalchemy.orm.registry.map_imperatively()` method of the ``sqlalchemy.orm.registry`` class to perform classical mapping.\")",
            "def _mapper_fn(*arg: Any, **kw: Any) -> NoReturn:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Placeholder for the now-removed ``mapper()`` function.\\n\\n    Classical mappings should be performed using the\\n    :meth:`_orm.registry.map_imperatively` method.\\n\\n    This symbol remains in SQLAlchemy 2.0 to suit the deprecated use case\\n    of using the ``mapper()`` function as a target for ORM event listeners,\\n    which failed to be marked as deprecated in the 1.4 series.\\n\\n    Global ORM mapper listeners should instead use the :class:`_orm.Mapper`\\n    class as the target.\\n\\n    .. versionchanged:: 2.0  The ``mapper()`` function was removed; the\\n       symbol remains temporarily as a placeholder for the event listening\\n       use case.\\n\\n    '\n    raise InvalidRequestError(\"The 'sqlalchemy.orm.mapper()' function is removed as of SQLAlchemy 2.0.  Use the 'sqlalchemy.orm.registry.map_imperatively()` method of the ``sqlalchemy.orm.registry`` class to perform classical mapping.\")",
            "def _mapper_fn(*arg: Any, **kw: Any) -> NoReturn:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Placeholder for the now-removed ``mapper()`` function.\\n\\n    Classical mappings should be performed using the\\n    :meth:`_orm.registry.map_imperatively` method.\\n\\n    This symbol remains in SQLAlchemy 2.0 to suit the deprecated use case\\n    of using the ``mapper()`` function as a target for ORM event listeners,\\n    which failed to be marked as deprecated in the 1.4 series.\\n\\n    Global ORM mapper listeners should instead use the :class:`_orm.Mapper`\\n    class as the target.\\n\\n    .. versionchanged:: 2.0  The ``mapper()`` function was removed; the\\n       symbol remains temporarily as a placeholder for the event listening\\n       use case.\\n\\n    '\n    raise InvalidRequestError(\"The 'sqlalchemy.orm.mapper()' function is removed as of SQLAlchemy 2.0.  Use the 'sqlalchemy.orm.registry.map_imperatively()` method of the ``sqlalchemy.orm.registry`` class to perform classical mapping.\")",
            "def _mapper_fn(*arg: Any, **kw: Any) -> NoReturn:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Placeholder for the now-removed ``mapper()`` function.\\n\\n    Classical mappings should be performed using the\\n    :meth:`_orm.registry.map_imperatively` method.\\n\\n    This symbol remains in SQLAlchemy 2.0 to suit the deprecated use case\\n    of using the ``mapper()`` function as a target for ORM event listeners,\\n    which failed to be marked as deprecated in the 1.4 series.\\n\\n    Global ORM mapper listeners should instead use the :class:`_orm.Mapper`\\n    class as the target.\\n\\n    .. versionchanged:: 2.0  The ``mapper()`` function was removed; the\\n       symbol remains temporarily as a placeholder for the event listening\\n       use case.\\n\\n    '\n    raise InvalidRequestError(\"The 'sqlalchemy.orm.mapper()' function is removed as of SQLAlchemy 2.0.  Use the 'sqlalchemy.orm.registry.map_imperatively()` method of the ``sqlalchemy.orm.registry`` class to perform classical mapping.\")"
        ]
    },
    {
        "func_name": "dynamic_loader",
        "original": "def dynamic_loader(argument: Optional[_RelationshipArgumentType[Any]]=None, **kw: Any) -> RelationshipProperty[Any]:\n    \"\"\"Construct a dynamically-loading mapper property.\n\n    This is essentially the same as\n    using the ``lazy='dynamic'`` argument with :func:`relationship`::\n\n        dynamic_loader(SomeClass)\n\n        # is the same as\n\n        relationship(SomeClass, lazy=\"dynamic\")\n\n    See the section :ref:`dynamic_relationship` for more details\n    on dynamic loading.\n\n    \"\"\"\n    kw['lazy'] = 'dynamic'\n    return relationship(argument, **kw)",
        "mutated": [
            "def dynamic_loader(argument: Optional[_RelationshipArgumentType[Any]]=None, **kw: Any) -> RelationshipProperty[Any]:\n    if False:\n        i = 10\n    'Construct a dynamically-loading mapper property.\\n\\n    This is essentially the same as\\n    using the ``lazy=\\'dynamic\\'`` argument with :func:`relationship`::\\n\\n        dynamic_loader(SomeClass)\\n\\n        # is the same as\\n\\n        relationship(SomeClass, lazy=\"dynamic\")\\n\\n    See the section :ref:`dynamic_relationship` for more details\\n    on dynamic loading.\\n\\n    '\n    kw['lazy'] = 'dynamic'\n    return relationship(argument, **kw)",
            "def dynamic_loader(argument: Optional[_RelationshipArgumentType[Any]]=None, **kw: Any) -> RelationshipProperty[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Construct a dynamically-loading mapper property.\\n\\n    This is essentially the same as\\n    using the ``lazy=\\'dynamic\\'`` argument with :func:`relationship`::\\n\\n        dynamic_loader(SomeClass)\\n\\n        # is the same as\\n\\n        relationship(SomeClass, lazy=\"dynamic\")\\n\\n    See the section :ref:`dynamic_relationship` for more details\\n    on dynamic loading.\\n\\n    '\n    kw['lazy'] = 'dynamic'\n    return relationship(argument, **kw)",
            "def dynamic_loader(argument: Optional[_RelationshipArgumentType[Any]]=None, **kw: Any) -> RelationshipProperty[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Construct a dynamically-loading mapper property.\\n\\n    This is essentially the same as\\n    using the ``lazy=\\'dynamic\\'`` argument with :func:`relationship`::\\n\\n        dynamic_loader(SomeClass)\\n\\n        # is the same as\\n\\n        relationship(SomeClass, lazy=\"dynamic\")\\n\\n    See the section :ref:`dynamic_relationship` for more details\\n    on dynamic loading.\\n\\n    '\n    kw['lazy'] = 'dynamic'\n    return relationship(argument, **kw)",
            "def dynamic_loader(argument: Optional[_RelationshipArgumentType[Any]]=None, **kw: Any) -> RelationshipProperty[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Construct a dynamically-loading mapper property.\\n\\n    This is essentially the same as\\n    using the ``lazy=\\'dynamic\\'`` argument with :func:`relationship`::\\n\\n        dynamic_loader(SomeClass)\\n\\n        # is the same as\\n\\n        relationship(SomeClass, lazy=\"dynamic\")\\n\\n    See the section :ref:`dynamic_relationship` for more details\\n    on dynamic loading.\\n\\n    '\n    kw['lazy'] = 'dynamic'\n    return relationship(argument, **kw)",
            "def dynamic_loader(argument: Optional[_RelationshipArgumentType[Any]]=None, **kw: Any) -> RelationshipProperty[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Construct a dynamically-loading mapper property.\\n\\n    This is essentially the same as\\n    using the ``lazy=\\'dynamic\\'`` argument with :func:`relationship`::\\n\\n        dynamic_loader(SomeClass)\\n\\n        # is the same as\\n\\n        relationship(SomeClass, lazy=\"dynamic\")\\n\\n    See the section :ref:`dynamic_relationship` for more details\\n    on dynamic loading.\\n\\n    '\n    kw['lazy'] = 'dynamic'\n    return relationship(argument, **kw)"
        ]
    },
    {
        "func_name": "backref",
        "original": "def backref(name: str, **kwargs: Any) -> ORMBackrefArgument:\n    \"\"\"When using the :paramref:`_orm.relationship.backref` parameter,\n    provides specific parameters to be used when the new\n    :func:`_orm.relationship` is generated.\n\n    E.g.::\n\n        'items':relationship(\n            SomeItem, backref=backref('parent', lazy='subquery'))\n\n    The :paramref:`_orm.relationship.backref` parameter is generally\n    considered to be legacy; for modern applications, using\n    explicit :func:`_orm.relationship` constructs linked together using\n    the :paramref:`_orm.relationship.back_populates` parameter should be\n    preferred.\n\n    .. seealso::\n\n        :ref:`relationships_backref` - background on backrefs\n\n    \"\"\"\n    return (name, kwargs)",
        "mutated": [
            "def backref(name: str, **kwargs: Any) -> ORMBackrefArgument:\n    if False:\n        i = 10\n    \"When using the :paramref:`_orm.relationship.backref` parameter,\\n    provides specific parameters to be used when the new\\n    :func:`_orm.relationship` is generated.\\n\\n    E.g.::\\n\\n        'items':relationship(\\n            SomeItem, backref=backref('parent', lazy='subquery'))\\n\\n    The :paramref:`_orm.relationship.backref` parameter is generally\\n    considered to be legacy; for modern applications, using\\n    explicit :func:`_orm.relationship` constructs linked together using\\n    the :paramref:`_orm.relationship.back_populates` parameter should be\\n    preferred.\\n\\n    .. seealso::\\n\\n        :ref:`relationships_backref` - background on backrefs\\n\\n    \"\n    return (name, kwargs)",
            "def backref(name: str, **kwargs: Any) -> ORMBackrefArgument:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"When using the :paramref:`_orm.relationship.backref` parameter,\\n    provides specific parameters to be used when the new\\n    :func:`_orm.relationship` is generated.\\n\\n    E.g.::\\n\\n        'items':relationship(\\n            SomeItem, backref=backref('parent', lazy='subquery'))\\n\\n    The :paramref:`_orm.relationship.backref` parameter is generally\\n    considered to be legacy; for modern applications, using\\n    explicit :func:`_orm.relationship` constructs linked together using\\n    the :paramref:`_orm.relationship.back_populates` parameter should be\\n    preferred.\\n\\n    .. seealso::\\n\\n        :ref:`relationships_backref` - background on backrefs\\n\\n    \"\n    return (name, kwargs)",
            "def backref(name: str, **kwargs: Any) -> ORMBackrefArgument:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"When using the :paramref:`_orm.relationship.backref` parameter,\\n    provides specific parameters to be used when the new\\n    :func:`_orm.relationship` is generated.\\n\\n    E.g.::\\n\\n        'items':relationship(\\n            SomeItem, backref=backref('parent', lazy='subquery'))\\n\\n    The :paramref:`_orm.relationship.backref` parameter is generally\\n    considered to be legacy; for modern applications, using\\n    explicit :func:`_orm.relationship` constructs linked together using\\n    the :paramref:`_orm.relationship.back_populates` parameter should be\\n    preferred.\\n\\n    .. seealso::\\n\\n        :ref:`relationships_backref` - background on backrefs\\n\\n    \"\n    return (name, kwargs)",
            "def backref(name: str, **kwargs: Any) -> ORMBackrefArgument:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"When using the :paramref:`_orm.relationship.backref` parameter,\\n    provides specific parameters to be used when the new\\n    :func:`_orm.relationship` is generated.\\n\\n    E.g.::\\n\\n        'items':relationship(\\n            SomeItem, backref=backref('parent', lazy='subquery'))\\n\\n    The :paramref:`_orm.relationship.backref` parameter is generally\\n    considered to be legacy; for modern applications, using\\n    explicit :func:`_orm.relationship` constructs linked together using\\n    the :paramref:`_orm.relationship.back_populates` parameter should be\\n    preferred.\\n\\n    .. seealso::\\n\\n        :ref:`relationships_backref` - background on backrefs\\n\\n    \"\n    return (name, kwargs)",
            "def backref(name: str, **kwargs: Any) -> ORMBackrefArgument:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"When using the :paramref:`_orm.relationship.backref` parameter,\\n    provides specific parameters to be used when the new\\n    :func:`_orm.relationship` is generated.\\n\\n    E.g.::\\n\\n        'items':relationship(\\n            SomeItem, backref=backref('parent', lazy='subquery'))\\n\\n    The :paramref:`_orm.relationship.backref` parameter is generally\\n    considered to be legacy; for modern applications, using\\n    explicit :func:`_orm.relationship` constructs linked together using\\n    the :paramref:`_orm.relationship.back_populates` parameter should be\\n    preferred.\\n\\n    .. seealso::\\n\\n        :ref:`relationships_backref` - background on backrefs\\n\\n    \"\n    return (name, kwargs)"
        ]
    },
    {
        "func_name": "deferred",
        "original": "def deferred(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    \"\"\"Indicate a column-based mapped attribute that by default will\n    not load unless accessed.\n\n    When using :func:`_orm.mapped_column`, the same functionality as\n    that of :func:`_orm.deferred` construct is provided by using the\n    :paramref:`_orm.mapped_column.deferred` parameter.\n\n    :param \\\\*columns: columns to be mapped.  This is typically a single\n     :class:`_schema.Column` object,\n     however a collection is supported in order\n     to support multiple columns mapped under the same attribute.\n\n    :param raiseload: boolean, if True, indicates an exception should be raised\n     if the load operation is to take place.\n\n     .. versionadded:: 1.4\n\n\n    Additional arguments are the same as that of :func:`_orm.column_property`.\n\n    .. seealso::\n\n        :ref:`orm_queryguide_deferred_imperative`\n\n    \"\"\"\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=True, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc)",
        "mutated": [
            "def deferred(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n    'Indicate a column-based mapped attribute that by default will\\n    not load unless accessed.\\n\\n    When using :func:`_orm.mapped_column`, the same functionality as\\n    that of :func:`_orm.deferred` construct is provided by using the\\n    :paramref:`_orm.mapped_column.deferred` parameter.\\n\\n    :param \\\\*columns: columns to be mapped.  This is typically a single\\n     :class:`_schema.Column` object,\\n     however a collection is supported in order\\n     to support multiple columns mapped under the same attribute.\\n\\n    :param raiseload: boolean, if True, indicates an exception should be raised\\n     if the load operation is to take place.\\n\\n     .. versionadded:: 1.4\\n\\n\\n    Additional arguments are the same as that of :func:`_orm.column_property`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_imperative`\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=True, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc)",
            "def deferred(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Indicate a column-based mapped attribute that by default will\\n    not load unless accessed.\\n\\n    When using :func:`_orm.mapped_column`, the same functionality as\\n    that of :func:`_orm.deferred` construct is provided by using the\\n    :paramref:`_orm.mapped_column.deferred` parameter.\\n\\n    :param \\\\*columns: columns to be mapped.  This is typically a single\\n     :class:`_schema.Column` object,\\n     however a collection is supported in order\\n     to support multiple columns mapped under the same attribute.\\n\\n    :param raiseload: boolean, if True, indicates an exception should be raised\\n     if the load operation is to take place.\\n\\n     .. versionadded:: 1.4\\n\\n\\n    Additional arguments are the same as that of :func:`_orm.column_property`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_imperative`\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=True, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc)",
            "def deferred(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Indicate a column-based mapped attribute that by default will\\n    not load unless accessed.\\n\\n    When using :func:`_orm.mapped_column`, the same functionality as\\n    that of :func:`_orm.deferred` construct is provided by using the\\n    :paramref:`_orm.mapped_column.deferred` parameter.\\n\\n    :param \\\\*columns: columns to be mapped.  This is typically a single\\n     :class:`_schema.Column` object,\\n     however a collection is supported in order\\n     to support multiple columns mapped under the same attribute.\\n\\n    :param raiseload: boolean, if True, indicates an exception should be raised\\n     if the load operation is to take place.\\n\\n     .. versionadded:: 1.4\\n\\n\\n    Additional arguments are the same as that of :func:`_orm.column_property`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_imperative`\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=True, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc)",
            "def deferred(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Indicate a column-based mapped attribute that by default will\\n    not load unless accessed.\\n\\n    When using :func:`_orm.mapped_column`, the same functionality as\\n    that of :func:`_orm.deferred` construct is provided by using the\\n    :paramref:`_orm.mapped_column.deferred` parameter.\\n\\n    :param \\\\*columns: columns to be mapped.  This is typically a single\\n     :class:`_schema.Column` object,\\n     however a collection is supported in order\\n     to support multiple columns mapped under the same attribute.\\n\\n    :param raiseload: boolean, if True, indicates an exception should be raised\\n     if the load operation is to take place.\\n\\n     .. versionadded:: 1.4\\n\\n\\n    Additional arguments are the same as that of :func:`_orm.column_property`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_imperative`\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=True, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc)",
            "def deferred(column: _ORMColumnExprArgument[_T], *additional_columns: _ORMColumnExprArgument[Any], group: Optional[str]=None, raiseload: bool=False, comparator_factory: Optional[Type[PropComparator[_T]]]=None, init: Union[_NoArg, bool]=_NoArg.NO_ARG, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, default: Optional[Any]=_NoArg.NO_ARG, default_factory: Union[_NoArg, Callable[[], _T]]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, kw_only: Union[_NoArg, bool]=_NoArg.NO_ARG, active_history: bool=False, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Indicate a column-based mapped attribute that by default will\\n    not load unless accessed.\\n\\n    When using :func:`_orm.mapped_column`, the same functionality as\\n    that of :func:`_orm.deferred` construct is provided by using the\\n    :paramref:`_orm.mapped_column.deferred` parameter.\\n\\n    :param \\\\*columns: columns to be mapped.  This is typically a single\\n     :class:`_schema.Column` object,\\n     however a collection is supported in order\\n     to support multiple columns mapped under the same attribute.\\n\\n    :param raiseload: boolean, if True, indicates an exception should be raised\\n     if the load operation is to take place.\\n\\n     .. versionadded:: 1.4\\n\\n\\n    Additional arguments are the same as that of :func:`_orm.column_property`.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_deferred_imperative`\\n\\n    '\n    return MappedSQLExpression(column, *additional_columns, attribute_options=_AttributeOptions(init, repr, default, default_factory, compare, kw_only), group=group, deferred=True, raiseload=raiseload, comparator_factory=comparator_factory, active_history=active_history, expire_on_flush=expire_on_flush, info=info, doc=doc)"
        ]
    },
    {
        "func_name": "query_expression",
        "original": "def query_expression(default_expr: _ORMColumnExprArgument[_T]=sql.null(), *, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    \"\"\"Indicate an attribute that populates from a query-time SQL expression.\n\n    :param default_expr: Optional SQL expression object that will be used in\n        all cases if not assigned later with :func:`_orm.with_expression`.\n\n    .. versionadded:: 1.2\n\n    .. seealso::\n\n        :ref:`orm_queryguide_with_expression` - background and usage examples\n\n    \"\"\"\n    prop = MappedSQLExpression(default_expr, attribute_options=_AttributeOptions(False, repr, _NoArg.NO_ARG, _NoArg.NO_ARG, compare, _NoArg.NO_ARG), expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)\n    prop.strategy_key = (('query_expression', True),)\n    return prop",
        "mutated": [
            "def query_expression(default_expr: _ORMColumnExprArgument[_T]=sql.null(), *, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n    'Indicate an attribute that populates from a query-time SQL expression.\\n\\n    :param default_expr: Optional SQL expression object that will be used in\\n        all cases if not assigned later with :func:`_orm.with_expression`.\\n\\n    .. versionadded:: 1.2\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_with_expression` - background and usage examples\\n\\n    '\n    prop = MappedSQLExpression(default_expr, attribute_options=_AttributeOptions(False, repr, _NoArg.NO_ARG, _NoArg.NO_ARG, compare, _NoArg.NO_ARG), expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)\n    prop.strategy_key = (('query_expression', True),)\n    return prop",
            "def query_expression(default_expr: _ORMColumnExprArgument[_T]=sql.null(), *, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Indicate an attribute that populates from a query-time SQL expression.\\n\\n    :param default_expr: Optional SQL expression object that will be used in\\n        all cases if not assigned later with :func:`_orm.with_expression`.\\n\\n    .. versionadded:: 1.2\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_with_expression` - background and usage examples\\n\\n    '\n    prop = MappedSQLExpression(default_expr, attribute_options=_AttributeOptions(False, repr, _NoArg.NO_ARG, _NoArg.NO_ARG, compare, _NoArg.NO_ARG), expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)\n    prop.strategy_key = (('query_expression', True),)\n    return prop",
            "def query_expression(default_expr: _ORMColumnExprArgument[_T]=sql.null(), *, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Indicate an attribute that populates from a query-time SQL expression.\\n\\n    :param default_expr: Optional SQL expression object that will be used in\\n        all cases if not assigned later with :func:`_orm.with_expression`.\\n\\n    .. versionadded:: 1.2\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_with_expression` - background and usage examples\\n\\n    '\n    prop = MappedSQLExpression(default_expr, attribute_options=_AttributeOptions(False, repr, _NoArg.NO_ARG, _NoArg.NO_ARG, compare, _NoArg.NO_ARG), expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)\n    prop.strategy_key = (('query_expression', True),)\n    return prop",
            "def query_expression(default_expr: _ORMColumnExprArgument[_T]=sql.null(), *, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Indicate an attribute that populates from a query-time SQL expression.\\n\\n    :param default_expr: Optional SQL expression object that will be used in\\n        all cases if not assigned later with :func:`_orm.with_expression`.\\n\\n    .. versionadded:: 1.2\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_with_expression` - background and usage examples\\n\\n    '\n    prop = MappedSQLExpression(default_expr, attribute_options=_AttributeOptions(False, repr, _NoArg.NO_ARG, _NoArg.NO_ARG, compare, _NoArg.NO_ARG), expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)\n    prop.strategy_key = (('query_expression', True),)\n    return prop",
            "def query_expression(default_expr: _ORMColumnExprArgument[_T]=sql.null(), *, repr: Union[_NoArg, bool]=_NoArg.NO_ARG, compare: Union[_NoArg, bool]=_NoArg.NO_ARG, expire_on_flush: bool=True, info: Optional[_InfoType]=None, doc: Optional[str]=None) -> MappedSQLExpression[_T]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Indicate an attribute that populates from a query-time SQL expression.\\n\\n    :param default_expr: Optional SQL expression object that will be used in\\n        all cases if not assigned later with :func:`_orm.with_expression`.\\n\\n    .. versionadded:: 1.2\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_with_expression` - background and usage examples\\n\\n    '\n    prop = MappedSQLExpression(default_expr, attribute_options=_AttributeOptions(False, repr, _NoArg.NO_ARG, _NoArg.NO_ARG, compare, _NoArg.NO_ARG), expire_on_flush=expire_on_flush, info=info, doc=doc, _assume_readonly_dc_attributes=True)\n    prop.strategy_key = (('query_expression', True),)\n    return prop"
        ]
    },
    {
        "func_name": "clear_mappers",
        "original": "def clear_mappers() -> None:\n    \"\"\"Remove all mappers from all classes.\n\n    .. versionchanged:: 1.4  This function now locates all\n       :class:`_orm.registry` objects and calls upon the\n       :meth:`_orm.registry.dispose` method of each.\n\n    This function removes all instrumentation from classes and disposes\n    of their associated mappers.  Once called, the classes are unmapped\n    and can be later re-mapped with new mappers.\n\n    :func:`.clear_mappers` is *not* for normal use, as there is literally no\n    valid usage for it outside of very specific testing scenarios. Normally,\n    mappers are permanent structural components of user-defined classes, and\n    are never discarded independently of their class.  If a mapped class\n    itself is garbage collected, its mapper is automatically disposed of as\n    well. As such, :func:`.clear_mappers` is only for usage in test suites\n    that re-use the same classes with different mappings, which is itself an\n    extremely rare use case - the only such use case is in fact SQLAlchemy's\n    own test suite, and possibly the test suites of other ORM extension\n    libraries which intend to test various combinations of mapper construction\n    upon a fixed set of classes.\n\n    \"\"\"\n    mapperlib._dispose_registries(mapperlib._all_registries(), False)",
        "mutated": [
            "def clear_mappers() -> None:\n    if False:\n        i = 10\n    \"Remove all mappers from all classes.\\n\\n    .. versionchanged:: 1.4  This function now locates all\\n       :class:`_orm.registry` objects and calls upon the\\n       :meth:`_orm.registry.dispose` method of each.\\n\\n    This function removes all instrumentation from classes and disposes\\n    of their associated mappers.  Once called, the classes are unmapped\\n    and can be later re-mapped with new mappers.\\n\\n    :func:`.clear_mappers` is *not* for normal use, as there is literally no\\n    valid usage for it outside of very specific testing scenarios. Normally,\\n    mappers are permanent structural components of user-defined classes, and\\n    are never discarded independently of their class.  If a mapped class\\n    itself is garbage collected, its mapper is automatically disposed of as\\n    well. As such, :func:`.clear_mappers` is only for usage in test suites\\n    that re-use the same classes with different mappings, which is itself an\\n    extremely rare use case - the only such use case is in fact SQLAlchemy's\\n    own test suite, and possibly the test suites of other ORM extension\\n    libraries which intend to test various combinations of mapper construction\\n    upon a fixed set of classes.\\n\\n    \"\n    mapperlib._dispose_registries(mapperlib._all_registries(), False)",
            "def clear_mappers() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Remove all mappers from all classes.\\n\\n    .. versionchanged:: 1.4  This function now locates all\\n       :class:`_orm.registry` objects and calls upon the\\n       :meth:`_orm.registry.dispose` method of each.\\n\\n    This function removes all instrumentation from classes and disposes\\n    of their associated mappers.  Once called, the classes are unmapped\\n    and can be later re-mapped with new mappers.\\n\\n    :func:`.clear_mappers` is *not* for normal use, as there is literally no\\n    valid usage for it outside of very specific testing scenarios. Normally,\\n    mappers are permanent structural components of user-defined classes, and\\n    are never discarded independently of their class.  If a mapped class\\n    itself is garbage collected, its mapper is automatically disposed of as\\n    well. As such, :func:`.clear_mappers` is only for usage in test suites\\n    that re-use the same classes with different mappings, which is itself an\\n    extremely rare use case - the only such use case is in fact SQLAlchemy's\\n    own test suite, and possibly the test suites of other ORM extension\\n    libraries which intend to test various combinations of mapper construction\\n    upon a fixed set of classes.\\n\\n    \"\n    mapperlib._dispose_registries(mapperlib._all_registries(), False)",
            "def clear_mappers() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Remove all mappers from all classes.\\n\\n    .. versionchanged:: 1.4  This function now locates all\\n       :class:`_orm.registry` objects and calls upon the\\n       :meth:`_orm.registry.dispose` method of each.\\n\\n    This function removes all instrumentation from classes and disposes\\n    of their associated mappers.  Once called, the classes are unmapped\\n    and can be later re-mapped with new mappers.\\n\\n    :func:`.clear_mappers` is *not* for normal use, as there is literally no\\n    valid usage for it outside of very specific testing scenarios. Normally,\\n    mappers are permanent structural components of user-defined classes, and\\n    are never discarded independently of their class.  If a mapped class\\n    itself is garbage collected, its mapper is automatically disposed of as\\n    well. As such, :func:`.clear_mappers` is only for usage in test suites\\n    that re-use the same classes with different mappings, which is itself an\\n    extremely rare use case - the only such use case is in fact SQLAlchemy's\\n    own test suite, and possibly the test suites of other ORM extension\\n    libraries which intend to test various combinations of mapper construction\\n    upon a fixed set of classes.\\n\\n    \"\n    mapperlib._dispose_registries(mapperlib._all_registries(), False)",
            "def clear_mappers() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Remove all mappers from all classes.\\n\\n    .. versionchanged:: 1.4  This function now locates all\\n       :class:`_orm.registry` objects and calls upon the\\n       :meth:`_orm.registry.dispose` method of each.\\n\\n    This function removes all instrumentation from classes and disposes\\n    of their associated mappers.  Once called, the classes are unmapped\\n    and can be later re-mapped with new mappers.\\n\\n    :func:`.clear_mappers` is *not* for normal use, as there is literally no\\n    valid usage for it outside of very specific testing scenarios. Normally,\\n    mappers are permanent structural components of user-defined classes, and\\n    are never discarded independently of their class.  If a mapped class\\n    itself is garbage collected, its mapper is automatically disposed of as\\n    well. As such, :func:`.clear_mappers` is only for usage in test suites\\n    that re-use the same classes with different mappings, which is itself an\\n    extremely rare use case - the only such use case is in fact SQLAlchemy's\\n    own test suite, and possibly the test suites of other ORM extension\\n    libraries which intend to test various combinations of mapper construction\\n    upon a fixed set of classes.\\n\\n    \"\n    mapperlib._dispose_registries(mapperlib._all_registries(), False)",
            "def clear_mappers() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Remove all mappers from all classes.\\n\\n    .. versionchanged:: 1.4  This function now locates all\\n       :class:`_orm.registry` objects and calls upon the\\n       :meth:`_orm.registry.dispose` method of each.\\n\\n    This function removes all instrumentation from classes and disposes\\n    of their associated mappers.  Once called, the classes are unmapped\\n    and can be later re-mapped with new mappers.\\n\\n    :func:`.clear_mappers` is *not* for normal use, as there is literally no\\n    valid usage for it outside of very specific testing scenarios. Normally,\\n    mappers are permanent structural components of user-defined classes, and\\n    are never discarded independently of their class.  If a mapped class\\n    itself is garbage collected, its mapper is automatically disposed of as\\n    well. As such, :func:`.clear_mappers` is only for usage in test suites\\n    that re-use the same classes with different mappings, which is itself an\\n    extremely rare use case - the only such use case is in fact SQLAlchemy's\\n    own test suite, and possibly the test suites of other ORM extension\\n    libraries which intend to test various combinations of mapper construction\\n    upon a fixed set of classes.\\n\\n    \"\n    mapperlib._dispose_registries(mapperlib._all_registries(), False)"
        ]
    },
    {
        "func_name": "aliased",
        "original": "@overload\ndef aliased(element: Type[_O], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedType[_O]:\n    ...",
        "mutated": [
            "@overload\ndef aliased(element: Type[_O], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedType[_O]:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef aliased(element: Type[_O], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedType[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef aliased(element: Type[_O], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedType[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef aliased(element: Type[_O], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedType[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef aliased(element: Type[_O], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedType[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "aliased",
        "original": "@overload\ndef aliased(element: Union[AliasedClass[_O], Mapper[_O], AliasedInsp[_O]], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedClass[_O]:\n    ...",
        "mutated": [
            "@overload\ndef aliased(element: Union[AliasedClass[_O], Mapper[_O], AliasedInsp[_O]], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef aliased(element: Union[AliasedClass[_O], Mapper[_O], AliasedInsp[_O]], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef aliased(element: Union[AliasedClass[_O], Mapper[_O], AliasedInsp[_O]], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef aliased(element: Union[AliasedClass[_O], Mapper[_O], AliasedInsp[_O]], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef aliased(element: Union[AliasedClass[_O], Mapper[_O], AliasedInsp[_O]], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "aliased",
        "original": "@overload\ndef aliased(element: FromClause, alias: None=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> FromClause:\n    ...",
        "mutated": [
            "@overload\ndef aliased(element: FromClause, alias: None=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> FromClause:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef aliased(element: FromClause, alias: None=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> FromClause:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef aliased(element: FromClause, alias: None=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> FromClause:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef aliased(element: FromClause, alias: None=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> FromClause:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef aliased(element: FromClause, alias: None=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> FromClause:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "aliased",
        "original": "def aliased(element: Union[_EntityType[_O], FromClause], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> Union[AliasedClass[_O], FromClause, AliasedType[_O]]:\n    \"\"\"Produce an alias of the given element, usually an :class:`.AliasedClass`\n    instance.\n\n    E.g.::\n\n        my_alias = aliased(MyClass)\n\n        stmt = select(MyClass, my_alias).filter(MyClass.id > my_alias.id)\n        result = session.execute(stmt)\n\n    The :func:`.aliased` function is used to create an ad-hoc mapping of a\n    mapped class to a new selectable.  By default, a selectable is generated\n    from the normally mapped selectable (typically a :class:`_schema.Table`\n    ) using the\n    :meth:`_expression.FromClause.alias` method. However, :func:`.aliased`\n    can also be\n    used to link the class to a new :func:`_expression.select` statement.\n    Also, the :func:`.with_polymorphic` function is a variant of\n    :func:`.aliased` that is intended to specify a so-called \"polymorphic\n    selectable\", that corresponds to the union of several joined-inheritance\n    subclasses at once.\n\n    For convenience, the :func:`.aliased` function also accepts plain\n    :class:`_expression.FromClause` constructs, such as a\n    :class:`_schema.Table` or\n    :func:`_expression.select` construct.   In those cases, the\n    :meth:`_expression.FromClause.alias`\n    method is called on the object and the new\n    :class:`_expression.Alias` object returned.  The returned\n    :class:`_expression.Alias` is not\n    ORM-mapped in this case.\n\n    .. seealso::\n\n        :ref:`tutorial_orm_entity_aliases` - in the :ref:`unified_tutorial`\n\n        :ref:`orm_queryguide_orm_aliases` - in the :ref:`queryguide_toplevel`\n\n    :param element: element to be aliased.  Is normally a mapped class,\n     but for convenience can also be a :class:`_expression.FromClause`\n     element.\n\n    :param alias: Optional selectable unit to map the element to.  This is\n     usually used to link the object to a subquery, and should be an aliased\n     select construct as one would produce from the\n     :meth:`_query.Query.subquery` method or\n     the :meth:`_expression.Select.subquery` or\n     :meth:`_expression.Select.alias` methods of the :func:`_expression.select`\n     construct.\n\n    :param name: optional string name to use for the alias, if not specified\n     by the ``alias`` parameter.  The name, among other things, forms the\n     attribute name that will be accessible via tuples returned by a\n     :class:`_query.Query` object.  Not supported when creating aliases\n     of :class:`_sql.Join` objects.\n\n    :param flat: Boolean, will be passed through to the\n     :meth:`_expression.FromClause.alias` call so that aliases of\n     :class:`_expression.Join` objects will alias the individual tables\n     inside the join, rather than creating a subquery.  This is generally\n     supported by all modern databases with regards to right-nested joins\n     and generally produces more efficient queries.\n\n    :param adapt_on_names: if True, more liberal \"matching\" will be used when\n     mapping the mapped columns of the ORM entity to those of the\n     given selectable - a name-based match will be performed if the\n     given selectable doesn't otherwise have a column that corresponds\n     to one on the entity.  The use case for this is when associating\n     an entity with some derived selectable such as one that uses\n     aggregate functions::\n\n        class UnitPrice(Base):\n            __tablename__ = 'unit_price'\n            ...\n            unit_id = Column(Integer)\n            price = Column(Numeric)\n\n        aggregated_unit_price = Session.query(\n                                    func.sum(UnitPrice.price).label('price')\n                                ).group_by(UnitPrice.unit_id).subquery()\n\n        aggregated_unit_price = aliased(UnitPrice,\n                    alias=aggregated_unit_price, adapt_on_names=True)\n\n     Above, functions on ``aggregated_unit_price`` which refer to\n     ``.price`` will return the\n     ``func.sum(UnitPrice.price).label('price')`` column, as it is\n     matched on the name \"price\".  Ordinarily, the \"price\" function\n     wouldn't have any \"column correspondence\" to the actual\n     ``UnitPrice.price`` column as it is not a proxy of the original.\n\n    \"\"\"\n    return AliasedInsp._alias_factory(element, alias=alias, name=name, flat=flat, adapt_on_names=adapt_on_names)",
        "mutated": [
            "def aliased(element: Union[_EntityType[_O], FromClause], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> Union[AliasedClass[_O], FromClause, AliasedType[_O]]:\n    if False:\n        i = 10\n    'Produce an alias of the given element, usually an :class:`.AliasedClass`\\n    instance.\\n\\n    E.g.::\\n\\n        my_alias = aliased(MyClass)\\n\\n        stmt = select(MyClass, my_alias).filter(MyClass.id > my_alias.id)\\n        result = session.execute(stmt)\\n\\n    The :func:`.aliased` function is used to create an ad-hoc mapping of a\\n    mapped class to a new selectable.  By default, a selectable is generated\\n    from the normally mapped selectable (typically a :class:`_schema.Table`\\n    ) using the\\n    :meth:`_expression.FromClause.alias` method. However, :func:`.aliased`\\n    can also be\\n    used to link the class to a new :func:`_expression.select` statement.\\n    Also, the :func:`.with_polymorphic` function is a variant of\\n    :func:`.aliased` that is intended to specify a so-called \"polymorphic\\n    selectable\", that corresponds to the union of several joined-inheritance\\n    subclasses at once.\\n\\n    For convenience, the :func:`.aliased` function also accepts plain\\n    :class:`_expression.FromClause` constructs, such as a\\n    :class:`_schema.Table` or\\n    :func:`_expression.select` construct.   In those cases, the\\n    :meth:`_expression.FromClause.alias`\\n    method is called on the object and the new\\n    :class:`_expression.Alias` object returned.  The returned\\n    :class:`_expression.Alias` is not\\n    ORM-mapped in this case.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_entity_aliases` - in the :ref:`unified_tutorial`\\n\\n        :ref:`orm_queryguide_orm_aliases` - in the :ref:`queryguide_toplevel`\\n\\n    :param element: element to be aliased.  Is normally a mapped class,\\n     but for convenience can also be a :class:`_expression.FromClause`\\n     element.\\n\\n    :param alias: Optional selectable unit to map the element to.  This is\\n     usually used to link the object to a subquery, and should be an aliased\\n     select construct as one would produce from the\\n     :meth:`_query.Query.subquery` method or\\n     the :meth:`_expression.Select.subquery` or\\n     :meth:`_expression.Select.alias` methods of the :func:`_expression.select`\\n     construct.\\n\\n    :param name: optional string name to use for the alias, if not specified\\n     by the ``alias`` parameter.  The name, among other things, forms the\\n     attribute name that will be accessible via tuples returned by a\\n     :class:`_query.Query` object.  Not supported when creating aliases\\n     of :class:`_sql.Join` objects.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.\\n\\n    :param adapt_on_names: if True, more liberal \"matching\" will be used when\\n     mapping the mapped columns of the ORM entity to those of the\\n     given selectable - a name-based match will be performed if the\\n     given selectable doesn\\'t otherwise have a column that corresponds\\n     to one on the entity.  The use case for this is when associating\\n     an entity with some derived selectable such as one that uses\\n     aggregate functions::\\n\\n        class UnitPrice(Base):\\n            __tablename__ = \\'unit_price\\'\\n            ...\\n            unit_id = Column(Integer)\\n            price = Column(Numeric)\\n\\n        aggregated_unit_price = Session.query(\\n                                    func.sum(UnitPrice.price).label(\\'price\\')\\n                                ).group_by(UnitPrice.unit_id).subquery()\\n\\n        aggregated_unit_price = aliased(UnitPrice,\\n                    alias=aggregated_unit_price, adapt_on_names=True)\\n\\n     Above, functions on ``aggregated_unit_price`` which refer to\\n     ``.price`` will return the\\n     ``func.sum(UnitPrice.price).label(\\'price\\')`` column, as it is\\n     matched on the name \"price\".  Ordinarily, the \"price\" function\\n     wouldn\\'t have any \"column correspondence\" to the actual\\n     ``UnitPrice.price`` column as it is not a proxy of the original.\\n\\n    '\n    return AliasedInsp._alias_factory(element, alias=alias, name=name, flat=flat, adapt_on_names=adapt_on_names)",
            "def aliased(element: Union[_EntityType[_O], FromClause], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> Union[AliasedClass[_O], FromClause, AliasedType[_O]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Produce an alias of the given element, usually an :class:`.AliasedClass`\\n    instance.\\n\\n    E.g.::\\n\\n        my_alias = aliased(MyClass)\\n\\n        stmt = select(MyClass, my_alias).filter(MyClass.id > my_alias.id)\\n        result = session.execute(stmt)\\n\\n    The :func:`.aliased` function is used to create an ad-hoc mapping of a\\n    mapped class to a new selectable.  By default, a selectable is generated\\n    from the normally mapped selectable (typically a :class:`_schema.Table`\\n    ) using the\\n    :meth:`_expression.FromClause.alias` method. However, :func:`.aliased`\\n    can also be\\n    used to link the class to a new :func:`_expression.select` statement.\\n    Also, the :func:`.with_polymorphic` function is a variant of\\n    :func:`.aliased` that is intended to specify a so-called \"polymorphic\\n    selectable\", that corresponds to the union of several joined-inheritance\\n    subclasses at once.\\n\\n    For convenience, the :func:`.aliased` function also accepts plain\\n    :class:`_expression.FromClause` constructs, such as a\\n    :class:`_schema.Table` or\\n    :func:`_expression.select` construct.   In those cases, the\\n    :meth:`_expression.FromClause.alias`\\n    method is called on the object and the new\\n    :class:`_expression.Alias` object returned.  The returned\\n    :class:`_expression.Alias` is not\\n    ORM-mapped in this case.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_entity_aliases` - in the :ref:`unified_tutorial`\\n\\n        :ref:`orm_queryguide_orm_aliases` - in the :ref:`queryguide_toplevel`\\n\\n    :param element: element to be aliased.  Is normally a mapped class,\\n     but for convenience can also be a :class:`_expression.FromClause`\\n     element.\\n\\n    :param alias: Optional selectable unit to map the element to.  This is\\n     usually used to link the object to a subquery, and should be an aliased\\n     select construct as one would produce from the\\n     :meth:`_query.Query.subquery` method or\\n     the :meth:`_expression.Select.subquery` or\\n     :meth:`_expression.Select.alias` methods of the :func:`_expression.select`\\n     construct.\\n\\n    :param name: optional string name to use for the alias, if not specified\\n     by the ``alias`` parameter.  The name, among other things, forms the\\n     attribute name that will be accessible via tuples returned by a\\n     :class:`_query.Query` object.  Not supported when creating aliases\\n     of :class:`_sql.Join` objects.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.\\n\\n    :param adapt_on_names: if True, more liberal \"matching\" will be used when\\n     mapping the mapped columns of the ORM entity to those of the\\n     given selectable - a name-based match will be performed if the\\n     given selectable doesn\\'t otherwise have a column that corresponds\\n     to one on the entity.  The use case for this is when associating\\n     an entity with some derived selectable such as one that uses\\n     aggregate functions::\\n\\n        class UnitPrice(Base):\\n            __tablename__ = \\'unit_price\\'\\n            ...\\n            unit_id = Column(Integer)\\n            price = Column(Numeric)\\n\\n        aggregated_unit_price = Session.query(\\n                                    func.sum(UnitPrice.price).label(\\'price\\')\\n                                ).group_by(UnitPrice.unit_id).subquery()\\n\\n        aggregated_unit_price = aliased(UnitPrice,\\n                    alias=aggregated_unit_price, adapt_on_names=True)\\n\\n     Above, functions on ``aggregated_unit_price`` which refer to\\n     ``.price`` will return the\\n     ``func.sum(UnitPrice.price).label(\\'price\\')`` column, as it is\\n     matched on the name \"price\".  Ordinarily, the \"price\" function\\n     wouldn\\'t have any \"column correspondence\" to the actual\\n     ``UnitPrice.price`` column as it is not a proxy of the original.\\n\\n    '\n    return AliasedInsp._alias_factory(element, alias=alias, name=name, flat=flat, adapt_on_names=adapt_on_names)",
            "def aliased(element: Union[_EntityType[_O], FromClause], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> Union[AliasedClass[_O], FromClause, AliasedType[_O]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Produce an alias of the given element, usually an :class:`.AliasedClass`\\n    instance.\\n\\n    E.g.::\\n\\n        my_alias = aliased(MyClass)\\n\\n        stmt = select(MyClass, my_alias).filter(MyClass.id > my_alias.id)\\n        result = session.execute(stmt)\\n\\n    The :func:`.aliased` function is used to create an ad-hoc mapping of a\\n    mapped class to a new selectable.  By default, a selectable is generated\\n    from the normally mapped selectable (typically a :class:`_schema.Table`\\n    ) using the\\n    :meth:`_expression.FromClause.alias` method. However, :func:`.aliased`\\n    can also be\\n    used to link the class to a new :func:`_expression.select` statement.\\n    Also, the :func:`.with_polymorphic` function is a variant of\\n    :func:`.aliased` that is intended to specify a so-called \"polymorphic\\n    selectable\", that corresponds to the union of several joined-inheritance\\n    subclasses at once.\\n\\n    For convenience, the :func:`.aliased` function also accepts plain\\n    :class:`_expression.FromClause` constructs, such as a\\n    :class:`_schema.Table` or\\n    :func:`_expression.select` construct.   In those cases, the\\n    :meth:`_expression.FromClause.alias`\\n    method is called on the object and the new\\n    :class:`_expression.Alias` object returned.  The returned\\n    :class:`_expression.Alias` is not\\n    ORM-mapped in this case.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_entity_aliases` - in the :ref:`unified_tutorial`\\n\\n        :ref:`orm_queryguide_orm_aliases` - in the :ref:`queryguide_toplevel`\\n\\n    :param element: element to be aliased.  Is normally a mapped class,\\n     but for convenience can also be a :class:`_expression.FromClause`\\n     element.\\n\\n    :param alias: Optional selectable unit to map the element to.  This is\\n     usually used to link the object to a subquery, and should be an aliased\\n     select construct as one would produce from the\\n     :meth:`_query.Query.subquery` method or\\n     the :meth:`_expression.Select.subquery` or\\n     :meth:`_expression.Select.alias` methods of the :func:`_expression.select`\\n     construct.\\n\\n    :param name: optional string name to use for the alias, if not specified\\n     by the ``alias`` parameter.  The name, among other things, forms the\\n     attribute name that will be accessible via tuples returned by a\\n     :class:`_query.Query` object.  Not supported when creating aliases\\n     of :class:`_sql.Join` objects.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.\\n\\n    :param adapt_on_names: if True, more liberal \"matching\" will be used when\\n     mapping the mapped columns of the ORM entity to those of the\\n     given selectable - a name-based match will be performed if the\\n     given selectable doesn\\'t otherwise have a column that corresponds\\n     to one on the entity.  The use case for this is when associating\\n     an entity with some derived selectable such as one that uses\\n     aggregate functions::\\n\\n        class UnitPrice(Base):\\n            __tablename__ = \\'unit_price\\'\\n            ...\\n            unit_id = Column(Integer)\\n            price = Column(Numeric)\\n\\n        aggregated_unit_price = Session.query(\\n                                    func.sum(UnitPrice.price).label(\\'price\\')\\n                                ).group_by(UnitPrice.unit_id).subquery()\\n\\n        aggregated_unit_price = aliased(UnitPrice,\\n                    alias=aggregated_unit_price, adapt_on_names=True)\\n\\n     Above, functions on ``aggregated_unit_price`` which refer to\\n     ``.price`` will return the\\n     ``func.sum(UnitPrice.price).label(\\'price\\')`` column, as it is\\n     matched on the name \"price\".  Ordinarily, the \"price\" function\\n     wouldn\\'t have any \"column correspondence\" to the actual\\n     ``UnitPrice.price`` column as it is not a proxy of the original.\\n\\n    '\n    return AliasedInsp._alias_factory(element, alias=alias, name=name, flat=flat, adapt_on_names=adapt_on_names)",
            "def aliased(element: Union[_EntityType[_O], FromClause], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> Union[AliasedClass[_O], FromClause, AliasedType[_O]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Produce an alias of the given element, usually an :class:`.AliasedClass`\\n    instance.\\n\\n    E.g.::\\n\\n        my_alias = aliased(MyClass)\\n\\n        stmt = select(MyClass, my_alias).filter(MyClass.id > my_alias.id)\\n        result = session.execute(stmt)\\n\\n    The :func:`.aliased` function is used to create an ad-hoc mapping of a\\n    mapped class to a new selectable.  By default, a selectable is generated\\n    from the normally mapped selectable (typically a :class:`_schema.Table`\\n    ) using the\\n    :meth:`_expression.FromClause.alias` method. However, :func:`.aliased`\\n    can also be\\n    used to link the class to a new :func:`_expression.select` statement.\\n    Also, the :func:`.with_polymorphic` function is a variant of\\n    :func:`.aliased` that is intended to specify a so-called \"polymorphic\\n    selectable\", that corresponds to the union of several joined-inheritance\\n    subclasses at once.\\n\\n    For convenience, the :func:`.aliased` function also accepts plain\\n    :class:`_expression.FromClause` constructs, such as a\\n    :class:`_schema.Table` or\\n    :func:`_expression.select` construct.   In those cases, the\\n    :meth:`_expression.FromClause.alias`\\n    method is called on the object and the new\\n    :class:`_expression.Alias` object returned.  The returned\\n    :class:`_expression.Alias` is not\\n    ORM-mapped in this case.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_entity_aliases` - in the :ref:`unified_tutorial`\\n\\n        :ref:`orm_queryguide_orm_aliases` - in the :ref:`queryguide_toplevel`\\n\\n    :param element: element to be aliased.  Is normally a mapped class,\\n     but for convenience can also be a :class:`_expression.FromClause`\\n     element.\\n\\n    :param alias: Optional selectable unit to map the element to.  This is\\n     usually used to link the object to a subquery, and should be an aliased\\n     select construct as one would produce from the\\n     :meth:`_query.Query.subquery` method or\\n     the :meth:`_expression.Select.subquery` or\\n     :meth:`_expression.Select.alias` methods of the :func:`_expression.select`\\n     construct.\\n\\n    :param name: optional string name to use for the alias, if not specified\\n     by the ``alias`` parameter.  The name, among other things, forms the\\n     attribute name that will be accessible via tuples returned by a\\n     :class:`_query.Query` object.  Not supported when creating aliases\\n     of :class:`_sql.Join` objects.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.\\n\\n    :param adapt_on_names: if True, more liberal \"matching\" will be used when\\n     mapping the mapped columns of the ORM entity to those of the\\n     given selectable - a name-based match will be performed if the\\n     given selectable doesn\\'t otherwise have a column that corresponds\\n     to one on the entity.  The use case for this is when associating\\n     an entity with some derived selectable such as one that uses\\n     aggregate functions::\\n\\n        class UnitPrice(Base):\\n            __tablename__ = \\'unit_price\\'\\n            ...\\n            unit_id = Column(Integer)\\n            price = Column(Numeric)\\n\\n        aggregated_unit_price = Session.query(\\n                                    func.sum(UnitPrice.price).label(\\'price\\')\\n                                ).group_by(UnitPrice.unit_id).subquery()\\n\\n        aggregated_unit_price = aliased(UnitPrice,\\n                    alias=aggregated_unit_price, adapt_on_names=True)\\n\\n     Above, functions on ``aggregated_unit_price`` which refer to\\n     ``.price`` will return the\\n     ``func.sum(UnitPrice.price).label(\\'price\\')`` column, as it is\\n     matched on the name \"price\".  Ordinarily, the \"price\" function\\n     wouldn\\'t have any \"column correspondence\" to the actual\\n     ``UnitPrice.price`` column as it is not a proxy of the original.\\n\\n    '\n    return AliasedInsp._alias_factory(element, alias=alias, name=name, flat=flat, adapt_on_names=adapt_on_names)",
            "def aliased(element: Union[_EntityType[_O], FromClause], alias: Optional[FromClause]=None, name: Optional[str]=None, flat: bool=False, adapt_on_names: bool=False) -> Union[AliasedClass[_O], FromClause, AliasedType[_O]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Produce an alias of the given element, usually an :class:`.AliasedClass`\\n    instance.\\n\\n    E.g.::\\n\\n        my_alias = aliased(MyClass)\\n\\n        stmt = select(MyClass, my_alias).filter(MyClass.id > my_alias.id)\\n        result = session.execute(stmt)\\n\\n    The :func:`.aliased` function is used to create an ad-hoc mapping of a\\n    mapped class to a new selectable.  By default, a selectable is generated\\n    from the normally mapped selectable (typically a :class:`_schema.Table`\\n    ) using the\\n    :meth:`_expression.FromClause.alias` method. However, :func:`.aliased`\\n    can also be\\n    used to link the class to a new :func:`_expression.select` statement.\\n    Also, the :func:`.with_polymorphic` function is a variant of\\n    :func:`.aliased` that is intended to specify a so-called \"polymorphic\\n    selectable\", that corresponds to the union of several joined-inheritance\\n    subclasses at once.\\n\\n    For convenience, the :func:`.aliased` function also accepts plain\\n    :class:`_expression.FromClause` constructs, such as a\\n    :class:`_schema.Table` or\\n    :func:`_expression.select` construct.   In those cases, the\\n    :meth:`_expression.FromClause.alias`\\n    method is called on the object and the new\\n    :class:`_expression.Alias` object returned.  The returned\\n    :class:`_expression.Alias` is not\\n    ORM-mapped in this case.\\n\\n    .. seealso::\\n\\n        :ref:`tutorial_orm_entity_aliases` - in the :ref:`unified_tutorial`\\n\\n        :ref:`orm_queryguide_orm_aliases` - in the :ref:`queryguide_toplevel`\\n\\n    :param element: element to be aliased.  Is normally a mapped class,\\n     but for convenience can also be a :class:`_expression.FromClause`\\n     element.\\n\\n    :param alias: Optional selectable unit to map the element to.  This is\\n     usually used to link the object to a subquery, and should be an aliased\\n     select construct as one would produce from the\\n     :meth:`_query.Query.subquery` method or\\n     the :meth:`_expression.Select.subquery` or\\n     :meth:`_expression.Select.alias` methods of the :func:`_expression.select`\\n     construct.\\n\\n    :param name: optional string name to use for the alias, if not specified\\n     by the ``alias`` parameter.  The name, among other things, forms the\\n     attribute name that will be accessible via tuples returned by a\\n     :class:`_query.Query` object.  Not supported when creating aliases\\n     of :class:`_sql.Join` objects.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.\\n\\n    :param adapt_on_names: if True, more liberal \"matching\" will be used when\\n     mapping the mapped columns of the ORM entity to those of the\\n     given selectable - a name-based match will be performed if the\\n     given selectable doesn\\'t otherwise have a column that corresponds\\n     to one on the entity.  The use case for this is when associating\\n     an entity with some derived selectable such as one that uses\\n     aggregate functions::\\n\\n        class UnitPrice(Base):\\n            __tablename__ = \\'unit_price\\'\\n            ...\\n            unit_id = Column(Integer)\\n            price = Column(Numeric)\\n\\n        aggregated_unit_price = Session.query(\\n                                    func.sum(UnitPrice.price).label(\\'price\\')\\n                                ).group_by(UnitPrice.unit_id).subquery()\\n\\n        aggregated_unit_price = aliased(UnitPrice,\\n                    alias=aggregated_unit_price, adapt_on_names=True)\\n\\n     Above, functions on ``aggregated_unit_price`` which refer to\\n     ``.price`` will return the\\n     ``func.sum(UnitPrice.price).label(\\'price\\')`` column, as it is\\n     matched on the name \"price\".  Ordinarily, the \"price\" function\\n     wouldn\\'t have any \"column correspondence\" to the actual\\n     ``UnitPrice.price`` column as it is not a proxy of the original.\\n\\n    '\n    return AliasedInsp._alias_factory(element, alias=alias, name=name, flat=flat, adapt_on_names=adapt_on_names)"
        ]
    },
    {
        "func_name": "with_polymorphic",
        "original": "def with_polymorphic(base: Union[Type[_O], Mapper[_O]], classes: Union[Literal['*'], Iterable[Type[Any]]], selectable: Union[Literal[False, None], FromClause]=False, flat: bool=False, polymorphic_on: Optional[ColumnElement[Any]]=None, aliased: bool=False, innerjoin: bool=False, adapt_on_names: bool=False, _use_mapper_path: bool=False) -> AliasedClass[_O]:\n    \"\"\"Produce an :class:`.AliasedClass` construct which specifies\n    columns for descendant mappers of the given base.\n\n    Using this method will ensure that each descendant mapper's\n    tables are included in the FROM clause, and will allow filter()\n    criterion to be used against those tables.  The resulting\n    instances will also have those columns already loaded so that\n    no \"post fetch\" of those columns will be required.\n\n    .. seealso::\n\n        :ref:`with_polymorphic` - full discussion of\n        :func:`_orm.with_polymorphic`.\n\n    :param base: Base class to be aliased.\n\n    :param classes: a single class or mapper, or list of\n        class/mappers, which inherit from the base class.\n        Alternatively, it may also be the string ``'*'``, in which case\n        all descending mapped classes will be added to the FROM clause.\n\n    :param aliased: when True, the selectable will be aliased.   For a\n        JOIN, this means the JOIN will be SELECTed from inside of a subquery\n        unless the :paramref:`_orm.with_polymorphic.flat` flag is set to\n        True, which is recommended for simpler use cases.\n\n    :param flat: Boolean, will be passed through to the\n     :meth:`_expression.FromClause.alias` call so that aliases of\n     :class:`_expression.Join` objects will alias the individual tables\n     inside the join, rather than creating a subquery.  This is generally\n     supported by all modern databases with regards to right-nested joins\n     and generally produces more efficient queries.  Setting this flag is\n     recommended as long as the resulting SQL is functional.\n\n    :param selectable: a table or subquery that will\n        be used in place of the generated FROM clause. This argument is\n        required if any of the desired classes use concrete table\n        inheritance, since SQLAlchemy currently cannot generate UNIONs\n        among tables automatically. If used, the ``selectable`` argument\n        must represent the full set of tables and columns mapped by every\n        mapped class. Otherwise, the unaccounted mapped columns will\n        result in their table being appended directly to the FROM clause\n        which will usually lead to incorrect results.\n\n        When left at its default value of ``False``, the polymorphic\n        selectable assigned to the base mapper is used for selecting rows.\n        However, it may also be passed as ``None``, which will bypass the\n        configured polymorphic selectable and instead construct an ad-hoc\n        selectable for the target classes given; for joined table inheritance\n        this will be a join that includes all target mappers and their\n        subclasses.\n\n    :param polymorphic_on: a column to be used as the \"discriminator\"\n        column for the given selectable. If not given, the polymorphic_on\n        attribute of the base classes' mapper will be used, if any. This\n        is useful for mappings that don't have polymorphic loading\n        behavior by default.\n\n    :param innerjoin: if True, an INNER JOIN will be used.  This should\n       only be specified if querying for one specific subtype only\n\n    :param adapt_on_names: Passes through the\n      :paramref:`_orm.aliased.adapt_on_names`\n      parameter to the aliased object.  This may be useful in situations where\n      the given selectable is not directly related to the existing mapped\n      selectable.\n\n      .. versionadded:: 1.4.33\n\n    \"\"\"\n    return AliasedInsp._with_polymorphic_factory(base, classes, selectable=selectable, flat=flat, polymorphic_on=polymorphic_on, adapt_on_names=adapt_on_names, aliased=aliased, innerjoin=innerjoin, _use_mapper_path=_use_mapper_path)",
        "mutated": [
            "def with_polymorphic(base: Union[Type[_O], Mapper[_O]], classes: Union[Literal['*'], Iterable[Type[Any]]], selectable: Union[Literal[False, None], FromClause]=False, flat: bool=False, polymorphic_on: Optional[ColumnElement[Any]]=None, aliased: bool=False, innerjoin: bool=False, adapt_on_names: bool=False, _use_mapper_path: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n    'Produce an :class:`.AliasedClass` construct which specifies\\n    columns for descendant mappers of the given base.\\n\\n    Using this method will ensure that each descendant mapper\\'s\\n    tables are included in the FROM clause, and will allow filter()\\n    criterion to be used against those tables.  The resulting\\n    instances will also have those columns already loaded so that\\n    no \"post fetch\" of those columns will be required.\\n\\n    .. seealso::\\n\\n        :ref:`with_polymorphic` - full discussion of\\n        :func:`_orm.with_polymorphic`.\\n\\n    :param base: Base class to be aliased.\\n\\n    :param classes: a single class or mapper, or list of\\n        class/mappers, which inherit from the base class.\\n        Alternatively, it may also be the string ``\\'*\\'``, in which case\\n        all descending mapped classes will be added to the FROM clause.\\n\\n    :param aliased: when True, the selectable will be aliased.   For a\\n        JOIN, this means the JOIN will be SELECTed from inside of a subquery\\n        unless the :paramref:`_orm.with_polymorphic.flat` flag is set to\\n        True, which is recommended for simpler use cases.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.  Setting this flag is\\n     recommended as long as the resulting SQL is functional.\\n\\n    :param selectable: a table or subquery that will\\n        be used in place of the generated FROM clause. This argument is\\n        required if any of the desired classes use concrete table\\n        inheritance, since SQLAlchemy currently cannot generate UNIONs\\n        among tables automatically. If used, the ``selectable`` argument\\n        must represent the full set of tables and columns mapped by every\\n        mapped class. Otherwise, the unaccounted mapped columns will\\n        result in their table being appended directly to the FROM clause\\n        which will usually lead to incorrect results.\\n\\n        When left at its default value of ``False``, the polymorphic\\n        selectable assigned to the base mapper is used for selecting rows.\\n        However, it may also be passed as ``None``, which will bypass the\\n        configured polymorphic selectable and instead construct an ad-hoc\\n        selectable for the target classes given; for joined table inheritance\\n        this will be a join that includes all target mappers and their\\n        subclasses.\\n\\n    :param polymorphic_on: a column to be used as the \"discriminator\"\\n        column for the given selectable. If not given, the polymorphic_on\\n        attribute of the base classes\\' mapper will be used, if any. This\\n        is useful for mappings that don\\'t have polymorphic loading\\n        behavior by default.\\n\\n    :param innerjoin: if True, an INNER JOIN will be used.  This should\\n       only be specified if querying for one specific subtype only\\n\\n    :param adapt_on_names: Passes through the\\n      :paramref:`_orm.aliased.adapt_on_names`\\n      parameter to the aliased object.  This may be useful in situations where\\n      the given selectable is not directly related to the existing mapped\\n      selectable.\\n\\n      .. versionadded:: 1.4.33\\n\\n    '\n    return AliasedInsp._with_polymorphic_factory(base, classes, selectable=selectable, flat=flat, polymorphic_on=polymorphic_on, adapt_on_names=adapt_on_names, aliased=aliased, innerjoin=innerjoin, _use_mapper_path=_use_mapper_path)",
            "def with_polymorphic(base: Union[Type[_O], Mapper[_O]], classes: Union[Literal['*'], Iterable[Type[Any]]], selectable: Union[Literal[False, None], FromClause]=False, flat: bool=False, polymorphic_on: Optional[ColumnElement[Any]]=None, aliased: bool=False, innerjoin: bool=False, adapt_on_names: bool=False, _use_mapper_path: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Produce an :class:`.AliasedClass` construct which specifies\\n    columns for descendant mappers of the given base.\\n\\n    Using this method will ensure that each descendant mapper\\'s\\n    tables are included in the FROM clause, and will allow filter()\\n    criterion to be used against those tables.  The resulting\\n    instances will also have those columns already loaded so that\\n    no \"post fetch\" of those columns will be required.\\n\\n    .. seealso::\\n\\n        :ref:`with_polymorphic` - full discussion of\\n        :func:`_orm.with_polymorphic`.\\n\\n    :param base: Base class to be aliased.\\n\\n    :param classes: a single class or mapper, or list of\\n        class/mappers, which inherit from the base class.\\n        Alternatively, it may also be the string ``\\'*\\'``, in which case\\n        all descending mapped classes will be added to the FROM clause.\\n\\n    :param aliased: when True, the selectable will be aliased.   For a\\n        JOIN, this means the JOIN will be SELECTed from inside of a subquery\\n        unless the :paramref:`_orm.with_polymorphic.flat` flag is set to\\n        True, which is recommended for simpler use cases.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.  Setting this flag is\\n     recommended as long as the resulting SQL is functional.\\n\\n    :param selectable: a table or subquery that will\\n        be used in place of the generated FROM clause. This argument is\\n        required if any of the desired classes use concrete table\\n        inheritance, since SQLAlchemy currently cannot generate UNIONs\\n        among tables automatically. If used, the ``selectable`` argument\\n        must represent the full set of tables and columns mapped by every\\n        mapped class. Otherwise, the unaccounted mapped columns will\\n        result in their table being appended directly to the FROM clause\\n        which will usually lead to incorrect results.\\n\\n        When left at its default value of ``False``, the polymorphic\\n        selectable assigned to the base mapper is used for selecting rows.\\n        However, it may also be passed as ``None``, which will bypass the\\n        configured polymorphic selectable and instead construct an ad-hoc\\n        selectable for the target classes given; for joined table inheritance\\n        this will be a join that includes all target mappers and their\\n        subclasses.\\n\\n    :param polymorphic_on: a column to be used as the \"discriminator\"\\n        column for the given selectable. If not given, the polymorphic_on\\n        attribute of the base classes\\' mapper will be used, if any. This\\n        is useful for mappings that don\\'t have polymorphic loading\\n        behavior by default.\\n\\n    :param innerjoin: if True, an INNER JOIN will be used.  This should\\n       only be specified if querying for one specific subtype only\\n\\n    :param adapt_on_names: Passes through the\\n      :paramref:`_orm.aliased.adapt_on_names`\\n      parameter to the aliased object.  This may be useful in situations where\\n      the given selectable is not directly related to the existing mapped\\n      selectable.\\n\\n      .. versionadded:: 1.4.33\\n\\n    '\n    return AliasedInsp._with_polymorphic_factory(base, classes, selectable=selectable, flat=flat, polymorphic_on=polymorphic_on, adapt_on_names=adapt_on_names, aliased=aliased, innerjoin=innerjoin, _use_mapper_path=_use_mapper_path)",
            "def with_polymorphic(base: Union[Type[_O], Mapper[_O]], classes: Union[Literal['*'], Iterable[Type[Any]]], selectable: Union[Literal[False, None], FromClause]=False, flat: bool=False, polymorphic_on: Optional[ColumnElement[Any]]=None, aliased: bool=False, innerjoin: bool=False, adapt_on_names: bool=False, _use_mapper_path: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Produce an :class:`.AliasedClass` construct which specifies\\n    columns for descendant mappers of the given base.\\n\\n    Using this method will ensure that each descendant mapper\\'s\\n    tables are included in the FROM clause, and will allow filter()\\n    criterion to be used against those tables.  The resulting\\n    instances will also have those columns already loaded so that\\n    no \"post fetch\" of those columns will be required.\\n\\n    .. seealso::\\n\\n        :ref:`with_polymorphic` - full discussion of\\n        :func:`_orm.with_polymorphic`.\\n\\n    :param base: Base class to be aliased.\\n\\n    :param classes: a single class or mapper, or list of\\n        class/mappers, which inherit from the base class.\\n        Alternatively, it may also be the string ``\\'*\\'``, in which case\\n        all descending mapped classes will be added to the FROM clause.\\n\\n    :param aliased: when True, the selectable will be aliased.   For a\\n        JOIN, this means the JOIN will be SELECTed from inside of a subquery\\n        unless the :paramref:`_orm.with_polymorphic.flat` flag is set to\\n        True, which is recommended for simpler use cases.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.  Setting this flag is\\n     recommended as long as the resulting SQL is functional.\\n\\n    :param selectable: a table or subquery that will\\n        be used in place of the generated FROM clause. This argument is\\n        required if any of the desired classes use concrete table\\n        inheritance, since SQLAlchemy currently cannot generate UNIONs\\n        among tables automatically. If used, the ``selectable`` argument\\n        must represent the full set of tables and columns mapped by every\\n        mapped class. Otherwise, the unaccounted mapped columns will\\n        result in their table being appended directly to the FROM clause\\n        which will usually lead to incorrect results.\\n\\n        When left at its default value of ``False``, the polymorphic\\n        selectable assigned to the base mapper is used for selecting rows.\\n        However, it may also be passed as ``None``, which will bypass the\\n        configured polymorphic selectable and instead construct an ad-hoc\\n        selectable for the target classes given; for joined table inheritance\\n        this will be a join that includes all target mappers and their\\n        subclasses.\\n\\n    :param polymorphic_on: a column to be used as the \"discriminator\"\\n        column for the given selectable. If not given, the polymorphic_on\\n        attribute of the base classes\\' mapper will be used, if any. This\\n        is useful for mappings that don\\'t have polymorphic loading\\n        behavior by default.\\n\\n    :param innerjoin: if True, an INNER JOIN will be used.  This should\\n       only be specified if querying for one specific subtype only\\n\\n    :param adapt_on_names: Passes through the\\n      :paramref:`_orm.aliased.adapt_on_names`\\n      parameter to the aliased object.  This may be useful in situations where\\n      the given selectable is not directly related to the existing mapped\\n      selectable.\\n\\n      .. versionadded:: 1.4.33\\n\\n    '\n    return AliasedInsp._with_polymorphic_factory(base, classes, selectable=selectable, flat=flat, polymorphic_on=polymorphic_on, adapt_on_names=adapt_on_names, aliased=aliased, innerjoin=innerjoin, _use_mapper_path=_use_mapper_path)",
            "def with_polymorphic(base: Union[Type[_O], Mapper[_O]], classes: Union[Literal['*'], Iterable[Type[Any]]], selectable: Union[Literal[False, None], FromClause]=False, flat: bool=False, polymorphic_on: Optional[ColumnElement[Any]]=None, aliased: bool=False, innerjoin: bool=False, adapt_on_names: bool=False, _use_mapper_path: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Produce an :class:`.AliasedClass` construct which specifies\\n    columns for descendant mappers of the given base.\\n\\n    Using this method will ensure that each descendant mapper\\'s\\n    tables are included in the FROM clause, and will allow filter()\\n    criterion to be used against those tables.  The resulting\\n    instances will also have those columns already loaded so that\\n    no \"post fetch\" of those columns will be required.\\n\\n    .. seealso::\\n\\n        :ref:`with_polymorphic` - full discussion of\\n        :func:`_orm.with_polymorphic`.\\n\\n    :param base: Base class to be aliased.\\n\\n    :param classes: a single class or mapper, or list of\\n        class/mappers, which inherit from the base class.\\n        Alternatively, it may also be the string ``\\'*\\'``, in which case\\n        all descending mapped classes will be added to the FROM clause.\\n\\n    :param aliased: when True, the selectable will be aliased.   For a\\n        JOIN, this means the JOIN will be SELECTed from inside of a subquery\\n        unless the :paramref:`_orm.with_polymorphic.flat` flag is set to\\n        True, which is recommended for simpler use cases.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.  Setting this flag is\\n     recommended as long as the resulting SQL is functional.\\n\\n    :param selectable: a table or subquery that will\\n        be used in place of the generated FROM clause. This argument is\\n        required if any of the desired classes use concrete table\\n        inheritance, since SQLAlchemy currently cannot generate UNIONs\\n        among tables automatically. If used, the ``selectable`` argument\\n        must represent the full set of tables and columns mapped by every\\n        mapped class. Otherwise, the unaccounted mapped columns will\\n        result in their table being appended directly to the FROM clause\\n        which will usually lead to incorrect results.\\n\\n        When left at its default value of ``False``, the polymorphic\\n        selectable assigned to the base mapper is used for selecting rows.\\n        However, it may also be passed as ``None``, which will bypass the\\n        configured polymorphic selectable and instead construct an ad-hoc\\n        selectable for the target classes given; for joined table inheritance\\n        this will be a join that includes all target mappers and their\\n        subclasses.\\n\\n    :param polymorphic_on: a column to be used as the \"discriminator\"\\n        column for the given selectable. If not given, the polymorphic_on\\n        attribute of the base classes\\' mapper will be used, if any. This\\n        is useful for mappings that don\\'t have polymorphic loading\\n        behavior by default.\\n\\n    :param innerjoin: if True, an INNER JOIN will be used.  This should\\n       only be specified if querying for one specific subtype only\\n\\n    :param adapt_on_names: Passes through the\\n      :paramref:`_orm.aliased.adapt_on_names`\\n      parameter to the aliased object.  This may be useful in situations where\\n      the given selectable is not directly related to the existing mapped\\n      selectable.\\n\\n      .. versionadded:: 1.4.33\\n\\n    '\n    return AliasedInsp._with_polymorphic_factory(base, classes, selectable=selectable, flat=flat, polymorphic_on=polymorphic_on, adapt_on_names=adapt_on_names, aliased=aliased, innerjoin=innerjoin, _use_mapper_path=_use_mapper_path)",
            "def with_polymorphic(base: Union[Type[_O], Mapper[_O]], classes: Union[Literal['*'], Iterable[Type[Any]]], selectable: Union[Literal[False, None], FromClause]=False, flat: bool=False, polymorphic_on: Optional[ColumnElement[Any]]=None, aliased: bool=False, innerjoin: bool=False, adapt_on_names: bool=False, _use_mapper_path: bool=False) -> AliasedClass[_O]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Produce an :class:`.AliasedClass` construct which specifies\\n    columns for descendant mappers of the given base.\\n\\n    Using this method will ensure that each descendant mapper\\'s\\n    tables are included in the FROM clause, and will allow filter()\\n    criterion to be used against those tables.  The resulting\\n    instances will also have those columns already loaded so that\\n    no \"post fetch\" of those columns will be required.\\n\\n    .. seealso::\\n\\n        :ref:`with_polymorphic` - full discussion of\\n        :func:`_orm.with_polymorphic`.\\n\\n    :param base: Base class to be aliased.\\n\\n    :param classes: a single class or mapper, or list of\\n        class/mappers, which inherit from the base class.\\n        Alternatively, it may also be the string ``\\'*\\'``, in which case\\n        all descending mapped classes will be added to the FROM clause.\\n\\n    :param aliased: when True, the selectable will be aliased.   For a\\n        JOIN, this means the JOIN will be SELECTed from inside of a subquery\\n        unless the :paramref:`_orm.with_polymorphic.flat` flag is set to\\n        True, which is recommended for simpler use cases.\\n\\n    :param flat: Boolean, will be passed through to the\\n     :meth:`_expression.FromClause.alias` call so that aliases of\\n     :class:`_expression.Join` objects will alias the individual tables\\n     inside the join, rather than creating a subquery.  This is generally\\n     supported by all modern databases with regards to right-nested joins\\n     and generally produces more efficient queries.  Setting this flag is\\n     recommended as long as the resulting SQL is functional.\\n\\n    :param selectable: a table or subquery that will\\n        be used in place of the generated FROM clause. This argument is\\n        required if any of the desired classes use concrete table\\n        inheritance, since SQLAlchemy currently cannot generate UNIONs\\n        among tables automatically. If used, the ``selectable`` argument\\n        must represent the full set of tables and columns mapped by every\\n        mapped class. Otherwise, the unaccounted mapped columns will\\n        result in their table being appended directly to the FROM clause\\n        which will usually lead to incorrect results.\\n\\n        When left at its default value of ``False``, the polymorphic\\n        selectable assigned to the base mapper is used for selecting rows.\\n        However, it may also be passed as ``None``, which will bypass the\\n        configured polymorphic selectable and instead construct an ad-hoc\\n        selectable for the target classes given; for joined table inheritance\\n        this will be a join that includes all target mappers and their\\n        subclasses.\\n\\n    :param polymorphic_on: a column to be used as the \"discriminator\"\\n        column for the given selectable. If not given, the polymorphic_on\\n        attribute of the base classes\\' mapper will be used, if any. This\\n        is useful for mappings that don\\'t have polymorphic loading\\n        behavior by default.\\n\\n    :param innerjoin: if True, an INNER JOIN will be used.  This should\\n       only be specified if querying for one specific subtype only\\n\\n    :param adapt_on_names: Passes through the\\n      :paramref:`_orm.aliased.adapt_on_names`\\n      parameter to the aliased object.  This may be useful in situations where\\n      the given selectable is not directly related to the existing mapped\\n      selectable.\\n\\n      .. versionadded:: 1.4.33\\n\\n    '\n    return AliasedInsp._with_polymorphic_factory(base, classes, selectable=selectable, flat=flat, polymorphic_on=polymorphic_on, adapt_on_names=adapt_on_names, aliased=aliased, innerjoin=innerjoin, _use_mapper_path=_use_mapper_path)"
        ]
    },
    {
        "func_name": "join",
        "original": "def join(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, isouter: bool=False, full: bool=False) -> _ORMJoin:\n    \"\"\"Produce an inner join between left and right clauses.\n\n    :func:`_orm.join` is an extension to the core join interface\n    provided by :func:`_expression.join()`, where the\n    left and right selectable may be not only core selectable\n    objects such as :class:`_schema.Table`, but also mapped classes or\n    :class:`.AliasedClass` instances.   The \"on\" clause can\n    be a SQL expression or an ORM mapped attribute\n    referencing a configured :func:`_orm.relationship`.\n\n    :func:`_orm.join` is not commonly needed in modern usage,\n    as its functionality is encapsulated within that of the\n    :meth:`_sql.Select.join` and :meth:`_query.Query.join`\n    methods. which feature a\n    significant amount of automation beyond :func:`_orm.join`\n    by itself.  Explicit use of :func:`_orm.join`\n    with ORM-enabled SELECT statements involves use of the\n    :meth:`_sql.Select.select_from` method, as in::\n\n        from sqlalchemy.orm import join\n        stmt = select(User).\\\\\n            select_from(join(User, Address, User.addresses)).\\\\\n            filter(Address.email_address=='foo@bar.com')\n\n    In modern SQLAlchemy the above join can be written more\n    succinctly as::\n\n        stmt = select(User).\\\\\n                join(User.addresses).\\\\\n                filter(Address.email_address=='foo@bar.com')\n\n    .. warning:: using :func:`_orm.join` directly may not work properly\n       with modern ORM options such as :func:`_orm.with_loader_criteria`.\n       It is strongly recommended to use the idiomatic join patterns\n       provided by methods such as :meth:`.Select.join` and\n       :meth:`.Select.join_from` when creating ORM joins.\n\n    .. seealso::\n\n        :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` for\n        background on idiomatic ORM join patterns\n\n    \"\"\"\n    return _ORMJoin(left, right, onclause, isouter, full)",
        "mutated": [
            "def join(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, isouter: bool=False, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n    'Produce an inner join between left and right clauses.\\n\\n    :func:`_orm.join` is an extension to the core join interface\\n    provided by :func:`_expression.join()`, where the\\n    left and right selectable may be not only core selectable\\n    objects such as :class:`_schema.Table`, but also mapped classes or\\n    :class:`.AliasedClass` instances.   The \"on\" clause can\\n    be a SQL expression or an ORM mapped attribute\\n    referencing a configured :func:`_orm.relationship`.\\n\\n    :func:`_orm.join` is not commonly needed in modern usage,\\n    as its functionality is encapsulated within that of the\\n    :meth:`_sql.Select.join` and :meth:`_query.Query.join`\\n    methods. which feature a\\n    significant amount of automation beyond :func:`_orm.join`\\n    by itself.  Explicit use of :func:`_orm.join`\\n    with ORM-enabled SELECT statements involves use of the\\n    :meth:`_sql.Select.select_from` method, as in::\\n\\n        from sqlalchemy.orm import join\\n        stmt = select(User).\\\\\\n            select_from(join(User, Address, User.addresses)).\\\\\\n            filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    In modern SQLAlchemy the above join can be written more\\n    succinctly as::\\n\\n        stmt = select(User).\\\\\\n                join(User.addresses).\\\\\\n                filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    .. warning:: using :func:`_orm.join` directly may not work properly\\n       with modern ORM options such as :func:`_orm.with_loader_criteria`.\\n       It is strongly recommended to use the idiomatic join patterns\\n       provided by methods such as :meth:`.Select.join` and\\n       :meth:`.Select.join_from` when creating ORM joins.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` for\\n        background on idiomatic ORM join patterns\\n\\n    '\n    return _ORMJoin(left, right, onclause, isouter, full)",
            "def join(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, isouter: bool=False, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Produce an inner join between left and right clauses.\\n\\n    :func:`_orm.join` is an extension to the core join interface\\n    provided by :func:`_expression.join()`, where the\\n    left and right selectable may be not only core selectable\\n    objects such as :class:`_schema.Table`, but also mapped classes or\\n    :class:`.AliasedClass` instances.   The \"on\" clause can\\n    be a SQL expression or an ORM mapped attribute\\n    referencing a configured :func:`_orm.relationship`.\\n\\n    :func:`_orm.join` is not commonly needed in modern usage,\\n    as its functionality is encapsulated within that of the\\n    :meth:`_sql.Select.join` and :meth:`_query.Query.join`\\n    methods. which feature a\\n    significant amount of automation beyond :func:`_orm.join`\\n    by itself.  Explicit use of :func:`_orm.join`\\n    with ORM-enabled SELECT statements involves use of the\\n    :meth:`_sql.Select.select_from` method, as in::\\n\\n        from sqlalchemy.orm import join\\n        stmt = select(User).\\\\\\n            select_from(join(User, Address, User.addresses)).\\\\\\n            filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    In modern SQLAlchemy the above join can be written more\\n    succinctly as::\\n\\n        stmt = select(User).\\\\\\n                join(User.addresses).\\\\\\n                filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    .. warning:: using :func:`_orm.join` directly may not work properly\\n       with modern ORM options such as :func:`_orm.with_loader_criteria`.\\n       It is strongly recommended to use the idiomatic join patterns\\n       provided by methods such as :meth:`.Select.join` and\\n       :meth:`.Select.join_from` when creating ORM joins.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` for\\n        background on idiomatic ORM join patterns\\n\\n    '\n    return _ORMJoin(left, right, onclause, isouter, full)",
            "def join(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, isouter: bool=False, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Produce an inner join between left and right clauses.\\n\\n    :func:`_orm.join` is an extension to the core join interface\\n    provided by :func:`_expression.join()`, where the\\n    left and right selectable may be not only core selectable\\n    objects such as :class:`_schema.Table`, but also mapped classes or\\n    :class:`.AliasedClass` instances.   The \"on\" clause can\\n    be a SQL expression or an ORM mapped attribute\\n    referencing a configured :func:`_orm.relationship`.\\n\\n    :func:`_orm.join` is not commonly needed in modern usage,\\n    as its functionality is encapsulated within that of the\\n    :meth:`_sql.Select.join` and :meth:`_query.Query.join`\\n    methods. which feature a\\n    significant amount of automation beyond :func:`_orm.join`\\n    by itself.  Explicit use of :func:`_orm.join`\\n    with ORM-enabled SELECT statements involves use of the\\n    :meth:`_sql.Select.select_from` method, as in::\\n\\n        from sqlalchemy.orm import join\\n        stmt = select(User).\\\\\\n            select_from(join(User, Address, User.addresses)).\\\\\\n            filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    In modern SQLAlchemy the above join can be written more\\n    succinctly as::\\n\\n        stmt = select(User).\\\\\\n                join(User.addresses).\\\\\\n                filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    .. warning:: using :func:`_orm.join` directly may not work properly\\n       with modern ORM options such as :func:`_orm.with_loader_criteria`.\\n       It is strongly recommended to use the idiomatic join patterns\\n       provided by methods such as :meth:`.Select.join` and\\n       :meth:`.Select.join_from` when creating ORM joins.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` for\\n        background on idiomatic ORM join patterns\\n\\n    '\n    return _ORMJoin(left, right, onclause, isouter, full)",
            "def join(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, isouter: bool=False, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Produce an inner join between left and right clauses.\\n\\n    :func:`_orm.join` is an extension to the core join interface\\n    provided by :func:`_expression.join()`, where the\\n    left and right selectable may be not only core selectable\\n    objects such as :class:`_schema.Table`, but also mapped classes or\\n    :class:`.AliasedClass` instances.   The \"on\" clause can\\n    be a SQL expression or an ORM mapped attribute\\n    referencing a configured :func:`_orm.relationship`.\\n\\n    :func:`_orm.join` is not commonly needed in modern usage,\\n    as its functionality is encapsulated within that of the\\n    :meth:`_sql.Select.join` and :meth:`_query.Query.join`\\n    methods. which feature a\\n    significant amount of automation beyond :func:`_orm.join`\\n    by itself.  Explicit use of :func:`_orm.join`\\n    with ORM-enabled SELECT statements involves use of the\\n    :meth:`_sql.Select.select_from` method, as in::\\n\\n        from sqlalchemy.orm import join\\n        stmt = select(User).\\\\\\n            select_from(join(User, Address, User.addresses)).\\\\\\n            filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    In modern SQLAlchemy the above join can be written more\\n    succinctly as::\\n\\n        stmt = select(User).\\\\\\n                join(User.addresses).\\\\\\n                filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    .. warning:: using :func:`_orm.join` directly may not work properly\\n       with modern ORM options such as :func:`_orm.with_loader_criteria`.\\n       It is strongly recommended to use the idiomatic join patterns\\n       provided by methods such as :meth:`.Select.join` and\\n       :meth:`.Select.join_from` when creating ORM joins.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` for\\n        background on idiomatic ORM join patterns\\n\\n    '\n    return _ORMJoin(left, right, onclause, isouter, full)",
            "def join(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, isouter: bool=False, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Produce an inner join between left and right clauses.\\n\\n    :func:`_orm.join` is an extension to the core join interface\\n    provided by :func:`_expression.join()`, where the\\n    left and right selectable may be not only core selectable\\n    objects such as :class:`_schema.Table`, but also mapped classes or\\n    :class:`.AliasedClass` instances.   The \"on\" clause can\\n    be a SQL expression or an ORM mapped attribute\\n    referencing a configured :func:`_orm.relationship`.\\n\\n    :func:`_orm.join` is not commonly needed in modern usage,\\n    as its functionality is encapsulated within that of the\\n    :meth:`_sql.Select.join` and :meth:`_query.Query.join`\\n    methods. which feature a\\n    significant amount of automation beyond :func:`_orm.join`\\n    by itself.  Explicit use of :func:`_orm.join`\\n    with ORM-enabled SELECT statements involves use of the\\n    :meth:`_sql.Select.select_from` method, as in::\\n\\n        from sqlalchemy.orm import join\\n        stmt = select(User).\\\\\\n            select_from(join(User, Address, User.addresses)).\\\\\\n            filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    In modern SQLAlchemy the above join can be written more\\n    succinctly as::\\n\\n        stmt = select(User).\\\\\\n                join(User.addresses).\\\\\\n                filter(Address.email_address==\\'foo@bar.com\\')\\n\\n    .. warning:: using :func:`_orm.join` directly may not work properly\\n       with modern ORM options such as :func:`_orm.with_loader_criteria`.\\n       It is strongly recommended to use the idiomatic join patterns\\n       provided by methods such as :meth:`.Select.join` and\\n       :meth:`.Select.join_from` when creating ORM joins.\\n\\n    .. seealso::\\n\\n        :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` for\\n        background on idiomatic ORM join patterns\\n\\n    '\n    return _ORMJoin(left, right, onclause, isouter, full)"
        ]
    },
    {
        "func_name": "outerjoin",
        "original": "def outerjoin(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, full: bool=False) -> _ORMJoin:\n    \"\"\"Produce a left outer join between left and right clauses.\n\n    This is the \"outer join\" version of the :func:`_orm.join` function,\n    featuring the same behavior except that an OUTER JOIN is generated.\n    See that function's documentation for other usage details.\n\n    \"\"\"\n    return _ORMJoin(left, right, onclause, True, full)",
        "mutated": [
            "def outerjoin(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n    'Produce a left outer join between left and right clauses.\\n\\n    This is the \"outer join\" version of the :func:`_orm.join` function,\\n    featuring the same behavior except that an OUTER JOIN is generated.\\n    See that function\\'s documentation for other usage details.\\n\\n    '\n    return _ORMJoin(left, right, onclause, True, full)",
            "def outerjoin(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Produce a left outer join between left and right clauses.\\n\\n    This is the \"outer join\" version of the :func:`_orm.join` function,\\n    featuring the same behavior except that an OUTER JOIN is generated.\\n    See that function\\'s documentation for other usage details.\\n\\n    '\n    return _ORMJoin(left, right, onclause, True, full)",
            "def outerjoin(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Produce a left outer join between left and right clauses.\\n\\n    This is the \"outer join\" version of the :func:`_orm.join` function,\\n    featuring the same behavior except that an OUTER JOIN is generated.\\n    See that function\\'s documentation for other usage details.\\n\\n    '\n    return _ORMJoin(left, right, onclause, True, full)",
            "def outerjoin(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Produce a left outer join between left and right clauses.\\n\\n    This is the \"outer join\" version of the :func:`_orm.join` function,\\n    featuring the same behavior except that an OUTER JOIN is generated.\\n    See that function\\'s documentation for other usage details.\\n\\n    '\n    return _ORMJoin(left, right, onclause, True, full)",
            "def outerjoin(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument]=None, full: bool=False) -> _ORMJoin:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Produce a left outer join between left and right clauses.\\n\\n    This is the \"outer join\" version of the :func:`_orm.join` function,\\n    featuring the same behavior except that an OUTER JOIN is generated.\\n    See that function\\'s documentation for other usage details.\\n\\n    '\n    return _ORMJoin(left, right, onclause, True, full)"
        ]
    }
]