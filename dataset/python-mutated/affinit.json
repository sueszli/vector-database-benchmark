[
    {
        "func_name": "_get_gpu_affinity_table",
        "original": "def _get_gpu_affinity_table():\n    \"\"\"\n    Generate three dict objects, gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups.\n    gpu_cpu_affinity_map (dict): Key is GPU ID and value is cpu_affinity string.\n    cpu_socket_gpus_list (dict): Key is cpu_affinity string and value is  a list\n                                 collected all GPU IDs that affinity to this cpu socket.\n    cpu_core_groups (dict):      Key is cpu_affinity string and value is cpu core groups.\n                                 cpu core groups contains #GPUs groups, each group have,\n                                 nearly eaual amount of cpu cores.\n\n    Example:\n        $nvidia-smi topo -m\n            GPU0    GPU1    GPU2    GPU3    CPU Affinity    NUMA Affinity\n        GPU0     X     SYS     SYS     SYS      0-9,20-29           0\n        GPU1   SYS       X     SYS     SYS      0-9,20-29           0\n        GPU2   SYS      SYS      X     SYS      10-19,30-39         1\n        GPU3   SYS      SYS    SYS       X      10-19,30-39         1\n\n        gpu_cpu_affinity_map =\n            { 0: '0-9,20-29', # GPU0's cpu affninity is '0-9,20-29'\n              1: '0-9,20-29', # GPU1's cpu affninity is '0-9,20-29'\n              2: '10-19,30-39', # GPU2's cpu affninity is '10-19,30-39'\n              3: '10-19,30-39' } # GPU3's cpu affninity is '10-19,30-39'\n        cpu_socket_gpus_list =\n            { '0-9,20-29': [0, 1], # There are 2 GPUs, 0 and 1, belong to cpu affinity '0-9,20-29'.\n              '10-19,30-39': [2, 3] # There are 2 GPUs, 2 and 3, belong to cpu affinity '10-19,30-39'.\n            }\n        cpu_core_groups =\n            # There are 2 GPUs belong to cpu affinity '0-9,20-29', then\n            # cores [0, 1, ..., 8, 9] would be split to two groups every\n            # 2-th elements\n            # [0, 2, 4, 6, 8] and [1, 3, 5, 7, 9]\n            # The same for cores [20, 21, ..., 28, 29].\n            {'0-9,20-29': [\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\n                              ],\n            # The same as '0-9,20-29'\n            '10-19,30-39': [\n                            [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\n                            [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\n                           ]}\n\n    \"\"\"\n    lines = os.popen('nvidia-smi topo -m').readlines()\n    cpu_affinity_idx = -1\n    titles = lines[0].split('\\t')\n    for idx in range(len(titles)):\n        if 'CPU Affinity' in titles[idx]:\n            cpu_affinity_idx = idx\n    assert cpu_affinity_idx > 0, 'Can not obtain correct CPU affinity column index via nvidia-smi!'\n    gpu_cpu_affinity_map = dict()\n    cpu_socket_gpus_list = dict()\n    for idx in range(1, len(lines)):\n        line = lines[idx]\n        items = line.split('\\t')\n        if 'GPU' in items[0]:\n            gpu_id = int(items[0][3:])\n            affinity = items[cpu_affinity_idx]\n            gpu_cpu_affinity_map[gpu_id] = affinity\n            if affinity in cpu_socket_gpus_list:\n                cpu_socket_gpus_list[affinity].append(gpu_id)\n            else:\n                cpu_socket_gpus_list[affinity] = [gpu_id]\n    cpu_core_groups = _group_cpu_cores(cpu_socket_gpus_list)\n    return (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups)",
        "mutated": [
            "def _get_gpu_affinity_table():\n    if False:\n        i = 10\n    \"\\n    Generate three dict objects, gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups.\\n    gpu_cpu_affinity_map (dict): Key is GPU ID and value is cpu_affinity string.\\n    cpu_socket_gpus_list (dict): Key is cpu_affinity string and value is  a list\\n                                 collected all GPU IDs that affinity to this cpu socket.\\n    cpu_core_groups (dict):      Key is cpu_affinity string and value is cpu core groups.\\n                                 cpu core groups contains #GPUs groups, each group have,\\n                                 nearly eaual amount of cpu cores.\\n\\n    Example:\\n        $nvidia-smi topo -m\\n            GPU0    GPU1    GPU2    GPU3    CPU Affinity    NUMA Affinity\\n        GPU0     X     SYS     SYS     SYS      0-9,20-29           0\\n        GPU1   SYS       X     SYS     SYS      0-9,20-29           0\\n        GPU2   SYS      SYS      X     SYS      10-19,30-39         1\\n        GPU3   SYS      SYS    SYS       X      10-19,30-39         1\\n\\n        gpu_cpu_affinity_map =\\n            { 0: '0-9,20-29', # GPU0's cpu affninity is '0-9,20-29'\\n              1: '0-9,20-29', # GPU1's cpu affninity is '0-9,20-29'\\n              2: '10-19,30-39', # GPU2's cpu affninity is '10-19,30-39'\\n              3: '10-19,30-39' } # GPU3's cpu affninity is '10-19,30-39'\\n        cpu_socket_gpus_list =\\n            { '0-9,20-29': [0, 1], # There are 2 GPUs, 0 and 1, belong to cpu affinity '0-9,20-29'.\\n              '10-19,30-39': [2, 3] # There are 2 GPUs, 2 and 3, belong to cpu affinity '10-19,30-39'.\\n            }\\n        cpu_core_groups =\\n            # There are 2 GPUs belong to cpu affinity '0-9,20-29', then\\n            # cores [0, 1, ..., 8, 9] would be split to two groups every\\n            # 2-th elements\\n            # [0, 2, 4, 6, 8] and [1, 3, 5, 7, 9]\\n            # The same for cores [20, 21, ..., 28, 29].\\n            {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n            # The same as '0-9,20-29'\\n            '10-19,30-39': [\\n                            [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                            [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                           ]}\\n\\n    \"\n    lines = os.popen('nvidia-smi topo -m').readlines()\n    cpu_affinity_idx = -1\n    titles = lines[0].split('\\t')\n    for idx in range(len(titles)):\n        if 'CPU Affinity' in titles[idx]:\n            cpu_affinity_idx = idx\n    assert cpu_affinity_idx > 0, 'Can not obtain correct CPU affinity column index via nvidia-smi!'\n    gpu_cpu_affinity_map = dict()\n    cpu_socket_gpus_list = dict()\n    for idx in range(1, len(lines)):\n        line = lines[idx]\n        items = line.split('\\t')\n        if 'GPU' in items[0]:\n            gpu_id = int(items[0][3:])\n            affinity = items[cpu_affinity_idx]\n            gpu_cpu_affinity_map[gpu_id] = affinity\n            if affinity in cpu_socket_gpus_list:\n                cpu_socket_gpus_list[affinity].append(gpu_id)\n            else:\n                cpu_socket_gpus_list[affinity] = [gpu_id]\n    cpu_core_groups = _group_cpu_cores(cpu_socket_gpus_list)\n    return (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups)",
            "def _get_gpu_affinity_table():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Generate three dict objects, gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups.\\n    gpu_cpu_affinity_map (dict): Key is GPU ID and value is cpu_affinity string.\\n    cpu_socket_gpus_list (dict): Key is cpu_affinity string and value is  a list\\n                                 collected all GPU IDs that affinity to this cpu socket.\\n    cpu_core_groups (dict):      Key is cpu_affinity string and value is cpu core groups.\\n                                 cpu core groups contains #GPUs groups, each group have,\\n                                 nearly eaual amount of cpu cores.\\n\\n    Example:\\n        $nvidia-smi topo -m\\n            GPU0    GPU1    GPU2    GPU3    CPU Affinity    NUMA Affinity\\n        GPU0     X     SYS     SYS     SYS      0-9,20-29           0\\n        GPU1   SYS       X     SYS     SYS      0-9,20-29           0\\n        GPU2   SYS      SYS      X     SYS      10-19,30-39         1\\n        GPU3   SYS      SYS    SYS       X      10-19,30-39         1\\n\\n        gpu_cpu_affinity_map =\\n            { 0: '0-9,20-29', # GPU0's cpu affninity is '0-9,20-29'\\n              1: '0-9,20-29', # GPU1's cpu affninity is '0-9,20-29'\\n              2: '10-19,30-39', # GPU2's cpu affninity is '10-19,30-39'\\n              3: '10-19,30-39' } # GPU3's cpu affninity is '10-19,30-39'\\n        cpu_socket_gpus_list =\\n            { '0-9,20-29': [0, 1], # There are 2 GPUs, 0 and 1, belong to cpu affinity '0-9,20-29'.\\n              '10-19,30-39': [2, 3] # There are 2 GPUs, 2 and 3, belong to cpu affinity '10-19,30-39'.\\n            }\\n        cpu_core_groups =\\n            # There are 2 GPUs belong to cpu affinity '0-9,20-29', then\\n            # cores [0, 1, ..., 8, 9] would be split to two groups every\\n            # 2-th elements\\n            # [0, 2, 4, 6, 8] and [1, 3, 5, 7, 9]\\n            # The same for cores [20, 21, ..., 28, 29].\\n            {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n            # The same as '0-9,20-29'\\n            '10-19,30-39': [\\n                            [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                            [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                           ]}\\n\\n    \"\n    lines = os.popen('nvidia-smi topo -m').readlines()\n    cpu_affinity_idx = -1\n    titles = lines[0].split('\\t')\n    for idx in range(len(titles)):\n        if 'CPU Affinity' in titles[idx]:\n            cpu_affinity_idx = idx\n    assert cpu_affinity_idx > 0, 'Can not obtain correct CPU affinity column index via nvidia-smi!'\n    gpu_cpu_affinity_map = dict()\n    cpu_socket_gpus_list = dict()\n    for idx in range(1, len(lines)):\n        line = lines[idx]\n        items = line.split('\\t')\n        if 'GPU' in items[0]:\n            gpu_id = int(items[0][3:])\n            affinity = items[cpu_affinity_idx]\n            gpu_cpu_affinity_map[gpu_id] = affinity\n            if affinity in cpu_socket_gpus_list:\n                cpu_socket_gpus_list[affinity].append(gpu_id)\n            else:\n                cpu_socket_gpus_list[affinity] = [gpu_id]\n    cpu_core_groups = _group_cpu_cores(cpu_socket_gpus_list)\n    return (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups)",
            "def _get_gpu_affinity_table():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Generate three dict objects, gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups.\\n    gpu_cpu_affinity_map (dict): Key is GPU ID and value is cpu_affinity string.\\n    cpu_socket_gpus_list (dict): Key is cpu_affinity string and value is  a list\\n                                 collected all GPU IDs that affinity to this cpu socket.\\n    cpu_core_groups (dict):      Key is cpu_affinity string and value is cpu core groups.\\n                                 cpu core groups contains #GPUs groups, each group have,\\n                                 nearly eaual amount of cpu cores.\\n\\n    Example:\\n        $nvidia-smi topo -m\\n            GPU0    GPU1    GPU2    GPU3    CPU Affinity    NUMA Affinity\\n        GPU0     X     SYS     SYS     SYS      0-9,20-29           0\\n        GPU1   SYS       X     SYS     SYS      0-9,20-29           0\\n        GPU2   SYS      SYS      X     SYS      10-19,30-39         1\\n        GPU3   SYS      SYS    SYS       X      10-19,30-39         1\\n\\n        gpu_cpu_affinity_map =\\n            { 0: '0-9,20-29', # GPU0's cpu affninity is '0-9,20-29'\\n              1: '0-9,20-29', # GPU1's cpu affninity is '0-9,20-29'\\n              2: '10-19,30-39', # GPU2's cpu affninity is '10-19,30-39'\\n              3: '10-19,30-39' } # GPU3's cpu affninity is '10-19,30-39'\\n        cpu_socket_gpus_list =\\n            { '0-9,20-29': [0, 1], # There are 2 GPUs, 0 and 1, belong to cpu affinity '0-9,20-29'.\\n              '10-19,30-39': [2, 3] # There are 2 GPUs, 2 and 3, belong to cpu affinity '10-19,30-39'.\\n            }\\n        cpu_core_groups =\\n            # There are 2 GPUs belong to cpu affinity '0-9,20-29', then\\n            # cores [0, 1, ..., 8, 9] would be split to two groups every\\n            # 2-th elements\\n            # [0, 2, 4, 6, 8] and [1, 3, 5, 7, 9]\\n            # The same for cores [20, 21, ..., 28, 29].\\n            {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n            # The same as '0-9,20-29'\\n            '10-19,30-39': [\\n                            [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                            [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                           ]}\\n\\n    \"\n    lines = os.popen('nvidia-smi topo -m').readlines()\n    cpu_affinity_idx = -1\n    titles = lines[0].split('\\t')\n    for idx in range(len(titles)):\n        if 'CPU Affinity' in titles[idx]:\n            cpu_affinity_idx = idx\n    assert cpu_affinity_idx > 0, 'Can not obtain correct CPU affinity column index via nvidia-smi!'\n    gpu_cpu_affinity_map = dict()\n    cpu_socket_gpus_list = dict()\n    for idx in range(1, len(lines)):\n        line = lines[idx]\n        items = line.split('\\t')\n        if 'GPU' in items[0]:\n            gpu_id = int(items[0][3:])\n            affinity = items[cpu_affinity_idx]\n            gpu_cpu_affinity_map[gpu_id] = affinity\n            if affinity in cpu_socket_gpus_list:\n                cpu_socket_gpus_list[affinity].append(gpu_id)\n            else:\n                cpu_socket_gpus_list[affinity] = [gpu_id]\n    cpu_core_groups = _group_cpu_cores(cpu_socket_gpus_list)\n    return (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups)",
            "def _get_gpu_affinity_table():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Generate three dict objects, gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups.\\n    gpu_cpu_affinity_map (dict): Key is GPU ID and value is cpu_affinity string.\\n    cpu_socket_gpus_list (dict): Key is cpu_affinity string and value is  a list\\n                                 collected all GPU IDs that affinity to this cpu socket.\\n    cpu_core_groups (dict):      Key is cpu_affinity string and value is cpu core groups.\\n                                 cpu core groups contains #GPUs groups, each group have,\\n                                 nearly eaual amount of cpu cores.\\n\\n    Example:\\n        $nvidia-smi topo -m\\n            GPU0    GPU1    GPU2    GPU3    CPU Affinity    NUMA Affinity\\n        GPU0     X     SYS     SYS     SYS      0-9,20-29           0\\n        GPU1   SYS       X     SYS     SYS      0-9,20-29           0\\n        GPU2   SYS      SYS      X     SYS      10-19,30-39         1\\n        GPU3   SYS      SYS    SYS       X      10-19,30-39         1\\n\\n        gpu_cpu_affinity_map =\\n            { 0: '0-9,20-29', # GPU0's cpu affninity is '0-9,20-29'\\n              1: '0-9,20-29', # GPU1's cpu affninity is '0-9,20-29'\\n              2: '10-19,30-39', # GPU2's cpu affninity is '10-19,30-39'\\n              3: '10-19,30-39' } # GPU3's cpu affninity is '10-19,30-39'\\n        cpu_socket_gpus_list =\\n            { '0-9,20-29': [0, 1], # There are 2 GPUs, 0 and 1, belong to cpu affinity '0-9,20-29'.\\n              '10-19,30-39': [2, 3] # There are 2 GPUs, 2 and 3, belong to cpu affinity '10-19,30-39'.\\n            }\\n        cpu_core_groups =\\n            # There are 2 GPUs belong to cpu affinity '0-9,20-29', then\\n            # cores [0, 1, ..., 8, 9] would be split to two groups every\\n            # 2-th elements\\n            # [0, 2, 4, 6, 8] and [1, 3, 5, 7, 9]\\n            # The same for cores [20, 21, ..., 28, 29].\\n            {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n            # The same as '0-9,20-29'\\n            '10-19,30-39': [\\n                            [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                            [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                           ]}\\n\\n    \"\n    lines = os.popen('nvidia-smi topo -m').readlines()\n    cpu_affinity_idx = -1\n    titles = lines[0].split('\\t')\n    for idx in range(len(titles)):\n        if 'CPU Affinity' in titles[idx]:\n            cpu_affinity_idx = idx\n    assert cpu_affinity_idx > 0, 'Can not obtain correct CPU affinity column index via nvidia-smi!'\n    gpu_cpu_affinity_map = dict()\n    cpu_socket_gpus_list = dict()\n    for idx in range(1, len(lines)):\n        line = lines[idx]\n        items = line.split('\\t')\n        if 'GPU' in items[0]:\n            gpu_id = int(items[0][3:])\n            affinity = items[cpu_affinity_idx]\n            gpu_cpu_affinity_map[gpu_id] = affinity\n            if affinity in cpu_socket_gpus_list:\n                cpu_socket_gpus_list[affinity].append(gpu_id)\n            else:\n                cpu_socket_gpus_list[affinity] = [gpu_id]\n    cpu_core_groups = _group_cpu_cores(cpu_socket_gpus_list)\n    return (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups)",
            "def _get_gpu_affinity_table():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Generate three dict objects, gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups.\\n    gpu_cpu_affinity_map (dict): Key is GPU ID and value is cpu_affinity string.\\n    cpu_socket_gpus_list (dict): Key is cpu_affinity string and value is  a list\\n                                 collected all GPU IDs that affinity to this cpu socket.\\n    cpu_core_groups (dict):      Key is cpu_affinity string and value is cpu core groups.\\n                                 cpu core groups contains #GPUs groups, each group have,\\n                                 nearly eaual amount of cpu cores.\\n\\n    Example:\\n        $nvidia-smi topo -m\\n            GPU0    GPU1    GPU2    GPU3    CPU Affinity    NUMA Affinity\\n        GPU0     X     SYS     SYS     SYS      0-9,20-29           0\\n        GPU1   SYS       X     SYS     SYS      0-9,20-29           0\\n        GPU2   SYS      SYS      X     SYS      10-19,30-39         1\\n        GPU3   SYS      SYS    SYS       X      10-19,30-39         1\\n\\n        gpu_cpu_affinity_map =\\n            { 0: '0-9,20-29', # GPU0's cpu affninity is '0-9,20-29'\\n              1: '0-9,20-29', # GPU1's cpu affninity is '0-9,20-29'\\n              2: '10-19,30-39', # GPU2's cpu affninity is '10-19,30-39'\\n              3: '10-19,30-39' } # GPU3's cpu affninity is '10-19,30-39'\\n        cpu_socket_gpus_list =\\n            { '0-9,20-29': [0, 1], # There are 2 GPUs, 0 and 1, belong to cpu affinity '0-9,20-29'.\\n              '10-19,30-39': [2, 3] # There are 2 GPUs, 2 and 3, belong to cpu affinity '10-19,30-39'.\\n            }\\n        cpu_core_groups =\\n            # There are 2 GPUs belong to cpu affinity '0-9,20-29', then\\n            # cores [0, 1, ..., 8, 9] would be split to two groups every\\n            # 2-th elements\\n            # [0, 2, 4, 6, 8] and [1, 3, 5, 7, 9]\\n            # The same for cores [20, 21, ..., 28, 29].\\n            {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n            # The same as '0-9,20-29'\\n            '10-19,30-39': [\\n                            [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                            [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                           ]}\\n\\n    \"\n    lines = os.popen('nvidia-smi topo -m').readlines()\n    cpu_affinity_idx = -1\n    titles = lines[0].split('\\t')\n    for idx in range(len(titles)):\n        if 'CPU Affinity' in titles[idx]:\n            cpu_affinity_idx = idx\n    assert cpu_affinity_idx > 0, 'Can not obtain correct CPU affinity column index via nvidia-smi!'\n    gpu_cpu_affinity_map = dict()\n    cpu_socket_gpus_list = dict()\n    for idx in range(1, len(lines)):\n        line = lines[idx]\n        items = line.split('\\t')\n        if 'GPU' in items[0]:\n            gpu_id = int(items[0][3:])\n            affinity = items[cpu_affinity_idx]\n            gpu_cpu_affinity_map[gpu_id] = affinity\n            if affinity in cpu_socket_gpus_list:\n                cpu_socket_gpus_list[affinity].append(gpu_id)\n            else:\n                cpu_socket_gpus_list[affinity] = [gpu_id]\n    cpu_core_groups = _group_cpu_cores(cpu_socket_gpus_list)\n    return (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups)"
        ]
    },
    {
        "func_name": "_group_cpu_cores",
        "original": "def _group_cpu_cores(cpu_socket_gpus_list):\n    \"\"\"\n    Generate a dictionary that key is cpu_affinity string and value is cpu core groups.\n    cpu core groups contains #GPUs groups, each group have, nearly eaual amount of cpu cores.\n    The grouping way is collect cpu cores every #GPUs-th elements, due to index of hyperthreading.\n    For examle, 4 physical cores, 8 cores with hyperthreading. The CPU indices [0, 1, 2, 3] is\n    physical cores, and [4, 5, 6, 7] is hyperthreading. In this case, distributing physical cores\n    first, then hyperthreading would reach better performance.\n    Args:\n        cpu_socket_gpus_list (dict): a dict that map cpu_affinity_str to all GPUs that belong to it.\n    Return:\n        cpu_core_groups (dict): a dict that map cpu_affinity_str to cpu core groups.\n    Example:\n        cpu_socket_gpus_list = { '0-9,20-29': [0, 1], '10-19,30-39': [2, 3] },\n        which means there are 2 GPUs, 0 and 1, belong to '0-9,20-29' and\n        2 GPUs, 2 and 3, belong to '10-19,30-39'\n        therefore, cpu_core_groups =\n                {'0-9,20-29': [\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\n                              ],\n                 '10-19,30-39': [\n                                 [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\n                                 [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\n                                ]}\n\n    \"\"\"\n    cpu_core_groups = dict()\n    for cpu_socket in cpu_socket_gpus_list:\n        cpu_core_groups[cpu_socket] = list()\n        gpu_count = len(cpu_socket_gpus_list[cpu_socket])\n        cores = cpu_socket.split(',')\n        for core in cores:\n            core_indices = _get_core_indices(core)\n            core_group = list()\n            for i in range(gpu_count):\n                start = i % len(core_indices)\n                sub_core_set = core_indices[start::gpu_count]\n                core_group.append(sub_core_set)\n            cpu_core_groups[cpu_socket].append(core_group)\n    return cpu_core_groups",
        "mutated": [
            "def _group_cpu_cores(cpu_socket_gpus_list):\n    if False:\n        i = 10\n    \"\\n    Generate a dictionary that key is cpu_affinity string and value is cpu core groups.\\n    cpu core groups contains #GPUs groups, each group have, nearly eaual amount of cpu cores.\\n    The grouping way is collect cpu cores every #GPUs-th elements, due to index of hyperthreading.\\n    For examle, 4 physical cores, 8 cores with hyperthreading. The CPU indices [0, 1, 2, 3] is\\n    physical cores, and [4, 5, 6, 7] is hyperthreading. In this case, distributing physical cores\\n    first, then hyperthreading would reach better performance.\\n    Args:\\n        cpu_socket_gpus_list (dict): a dict that map cpu_affinity_str to all GPUs that belong to it.\\n    Return:\\n        cpu_core_groups (dict): a dict that map cpu_affinity_str to cpu core groups.\\n    Example:\\n        cpu_socket_gpus_list = { '0-9,20-29': [0, 1], '10-19,30-39': [2, 3] },\\n        which means there are 2 GPUs, 0 and 1, belong to '0-9,20-29' and\\n        2 GPUs, 2 and 3, belong to '10-19,30-39'\\n        therefore, cpu_core_groups =\\n                {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n                 '10-19,30-39': [\\n                                 [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                                 [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                                ]}\\n\\n    \"\n    cpu_core_groups = dict()\n    for cpu_socket in cpu_socket_gpus_list:\n        cpu_core_groups[cpu_socket] = list()\n        gpu_count = len(cpu_socket_gpus_list[cpu_socket])\n        cores = cpu_socket.split(',')\n        for core in cores:\n            core_indices = _get_core_indices(core)\n            core_group = list()\n            for i in range(gpu_count):\n                start = i % len(core_indices)\n                sub_core_set = core_indices[start::gpu_count]\n                core_group.append(sub_core_set)\n            cpu_core_groups[cpu_socket].append(core_group)\n    return cpu_core_groups",
            "def _group_cpu_cores(cpu_socket_gpus_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Generate a dictionary that key is cpu_affinity string and value is cpu core groups.\\n    cpu core groups contains #GPUs groups, each group have, nearly eaual amount of cpu cores.\\n    The grouping way is collect cpu cores every #GPUs-th elements, due to index of hyperthreading.\\n    For examle, 4 physical cores, 8 cores with hyperthreading. The CPU indices [0, 1, 2, 3] is\\n    physical cores, and [4, 5, 6, 7] is hyperthreading. In this case, distributing physical cores\\n    first, then hyperthreading would reach better performance.\\n    Args:\\n        cpu_socket_gpus_list (dict): a dict that map cpu_affinity_str to all GPUs that belong to it.\\n    Return:\\n        cpu_core_groups (dict): a dict that map cpu_affinity_str to cpu core groups.\\n    Example:\\n        cpu_socket_gpus_list = { '0-9,20-29': [0, 1], '10-19,30-39': [2, 3] },\\n        which means there are 2 GPUs, 0 and 1, belong to '0-9,20-29' and\\n        2 GPUs, 2 and 3, belong to '10-19,30-39'\\n        therefore, cpu_core_groups =\\n                {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n                 '10-19,30-39': [\\n                                 [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                                 [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                                ]}\\n\\n    \"\n    cpu_core_groups = dict()\n    for cpu_socket in cpu_socket_gpus_list:\n        cpu_core_groups[cpu_socket] = list()\n        gpu_count = len(cpu_socket_gpus_list[cpu_socket])\n        cores = cpu_socket.split(',')\n        for core in cores:\n            core_indices = _get_core_indices(core)\n            core_group = list()\n            for i in range(gpu_count):\n                start = i % len(core_indices)\n                sub_core_set = core_indices[start::gpu_count]\n                core_group.append(sub_core_set)\n            cpu_core_groups[cpu_socket].append(core_group)\n    return cpu_core_groups",
            "def _group_cpu_cores(cpu_socket_gpus_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Generate a dictionary that key is cpu_affinity string and value is cpu core groups.\\n    cpu core groups contains #GPUs groups, each group have, nearly eaual amount of cpu cores.\\n    The grouping way is collect cpu cores every #GPUs-th elements, due to index of hyperthreading.\\n    For examle, 4 physical cores, 8 cores with hyperthreading. The CPU indices [0, 1, 2, 3] is\\n    physical cores, and [4, 5, 6, 7] is hyperthreading. In this case, distributing physical cores\\n    first, then hyperthreading would reach better performance.\\n    Args:\\n        cpu_socket_gpus_list (dict): a dict that map cpu_affinity_str to all GPUs that belong to it.\\n    Return:\\n        cpu_core_groups (dict): a dict that map cpu_affinity_str to cpu core groups.\\n    Example:\\n        cpu_socket_gpus_list = { '0-9,20-29': [0, 1], '10-19,30-39': [2, 3] },\\n        which means there are 2 GPUs, 0 and 1, belong to '0-9,20-29' and\\n        2 GPUs, 2 and 3, belong to '10-19,30-39'\\n        therefore, cpu_core_groups =\\n                {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n                 '10-19,30-39': [\\n                                 [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                                 [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                                ]}\\n\\n    \"\n    cpu_core_groups = dict()\n    for cpu_socket in cpu_socket_gpus_list:\n        cpu_core_groups[cpu_socket] = list()\n        gpu_count = len(cpu_socket_gpus_list[cpu_socket])\n        cores = cpu_socket.split(',')\n        for core in cores:\n            core_indices = _get_core_indices(core)\n            core_group = list()\n            for i in range(gpu_count):\n                start = i % len(core_indices)\n                sub_core_set = core_indices[start::gpu_count]\n                core_group.append(sub_core_set)\n            cpu_core_groups[cpu_socket].append(core_group)\n    return cpu_core_groups",
            "def _group_cpu_cores(cpu_socket_gpus_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Generate a dictionary that key is cpu_affinity string and value is cpu core groups.\\n    cpu core groups contains #GPUs groups, each group have, nearly eaual amount of cpu cores.\\n    The grouping way is collect cpu cores every #GPUs-th elements, due to index of hyperthreading.\\n    For examle, 4 physical cores, 8 cores with hyperthreading. The CPU indices [0, 1, 2, 3] is\\n    physical cores, and [4, 5, 6, 7] is hyperthreading. In this case, distributing physical cores\\n    first, then hyperthreading would reach better performance.\\n    Args:\\n        cpu_socket_gpus_list (dict): a dict that map cpu_affinity_str to all GPUs that belong to it.\\n    Return:\\n        cpu_core_groups (dict): a dict that map cpu_affinity_str to cpu core groups.\\n    Example:\\n        cpu_socket_gpus_list = { '0-9,20-29': [0, 1], '10-19,30-39': [2, 3] },\\n        which means there are 2 GPUs, 0 and 1, belong to '0-9,20-29' and\\n        2 GPUs, 2 and 3, belong to '10-19,30-39'\\n        therefore, cpu_core_groups =\\n                {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n                 '10-19,30-39': [\\n                                 [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                                 [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                                ]}\\n\\n    \"\n    cpu_core_groups = dict()\n    for cpu_socket in cpu_socket_gpus_list:\n        cpu_core_groups[cpu_socket] = list()\n        gpu_count = len(cpu_socket_gpus_list[cpu_socket])\n        cores = cpu_socket.split(',')\n        for core in cores:\n            core_indices = _get_core_indices(core)\n            core_group = list()\n            for i in range(gpu_count):\n                start = i % len(core_indices)\n                sub_core_set = core_indices[start::gpu_count]\n                core_group.append(sub_core_set)\n            cpu_core_groups[cpu_socket].append(core_group)\n    return cpu_core_groups",
            "def _group_cpu_cores(cpu_socket_gpus_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Generate a dictionary that key is cpu_affinity string and value is cpu core groups.\\n    cpu core groups contains #GPUs groups, each group have, nearly eaual amount of cpu cores.\\n    The grouping way is collect cpu cores every #GPUs-th elements, due to index of hyperthreading.\\n    For examle, 4 physical cores, 8 cores with hyperthreading. The CPU indices [0, 1, 2, 3] is\\n    physical cores, and [4, 5, 6, 7] is hyperthreading. In this case, distributing physical cores\\n    first, then hyperthreading would reach better performance.\\n    Args:\\n        cpu_socket_gpus_list (dict): a dict that map cpu_affinity_str to all GPUs that belong to it.\\n    Return:\\n        cpu_core_groups (dict): a dict that map cpu_affinity_str to cpu core groups.\\n    Example:\\n        cpu_socket_gpus_list = { '0-9,20-29': [0, 1], '10-19,30-39': [2, 3] },\\n        which means there are 2 GPUs, 0 and 1, belong to '0-9,20-29' and\\n        2 GPUs, 2 and 3, belong to '10-19,30-39'\\n        therefore, cpu_core_groups =\\n                {'0-9,20-29': [\\n                               [[0, 2, 4, 6, 8], [1, 3, 5, 7, 9]],\\n                               [[20, 22, 24, 26, 28], [21, 23, 25, 27, 29]]\\n                              ],\\n                 '10-19,30-39': [\\n                                 [[10, 12, 14, 16, 18], [11, 13, 15, 17, 19]],\\n                                 [[30, 32, 34, 36, 38], [31, 33, 35, 37, 39]]\\n                                ]}\\n\\n    \"\n    cpu_core_groups = dict()\n    for cpu_socket in cpu_socket_gpus_list:\n        cpu_core_groups[cpu_socket] = list()\n        gpu_count = len(cpu_socket_gpus_list[cpu_socket])\n        cores = cpu_socket.split(',')\n        for core in cores:\n            core_indices = _get_core_indices(core)\n            core_group = list()\n            for i in range(gpu_count):\n                start = i % len(core_indices)\n                sub_core_set = core_indices[start::gpu_count]\n                core_group.append(sub_core_set)\n            cpu_core_groups[cpu_socket].append(core_group)\n    return cpu_core_groups"
        ]
    },
    {
        "func_name": "_get_core_indices",
        "original": "def _get_core_indices(cores_str):\n    \"\"\"\n    Generate a dictionary of cpu core indices.\n    Args:\n        cores_str (str): a string with format \"start_idx-end_idx\".\n    Return:\n        cpu_core_indices (list): a list collected all indices in [start_idx, end_idx].\n    Example:\n        cores_str = '0-20'\n        cpu_core_indices = [0, 1, 2, ..., 18, 19, 20]\n    \"\"\"\n    (start, end) = cores_str.split('-')\n    return [*range(int(start), int(end) + 1)]",
        "mutated": [
            "def _get_core_indices(cores_str):\n    if False:\n        i = 10\n    '\\n    Generate a dictionary of cpu core indices.\\n    Args:\\n        cores_str (str): a string with format \"start_idx-end_idx\".\\n    Return:\\n        cpu_core_indices (list): a list collected all indices in [start_idx, end_idx].\\n    Example:\\n        cores_str = \\'0-20\\'\\n        cpu_core_indices = [0, 1, 2, ..., 18, 19, 20]\\n    '\n    (start, end) = cores_str.split('-')\n    return [*range(int(start), int(end) + 1)]",
            "def _get_core_indices(cores_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate a dictionary of cpu core indices.\\n    Args:\\n        cores_str (str): a string with format \"start_idx-end_idx\".\\n    Return:\\n        cpu_core_indices (list): a list collected all indices in [start_idx, end_idx].\\n    Example:\\n        cores_str = \\'0-20\\'\\n        cpu_core_indices = [0, 1, 2, ..., 18, 19, 20]\\n    '\n    (start, end) = cores_str.split('-')\n    return [*range(int(start), int(end) + 1)]",
            "def _get_core_indices(cores_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate a dictionary of cpu core indices.\\n    Args:\\n        cores_str (str): a string with format \"start_idx-end_idx\".\\n    Return:\\n        cpu_core_indices (list): a list collected all indices in [start_idx, end_idx].\\n    Example:\\n        cores_str = \\'0-20\\'\\n        cpu_core_indices = [0, 1, 2, ..., 18, 19, 20]\\n    '\n    (start, end) = cores_str.split('-')\n    return [*range(int(start), int(end) + 1)]",
            "def _get_core_indices(cores_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate a dictionary of cpu core indices.\\n    Args:\\n        cores_str (str): a string with format \"start_idx-end_idx\".\\n    Return:\\n        cpu_core_indices (list): a list collected all indices in [start_idx, end_idx].\\n    Example:\\n        cores_str = \\'0-20\\'\\n        cpu_core_indices = [0, 1, 2, ..., 18, 19, 20]\\n    '\n    (start, end) = cores_str.split('-')\n    return [*range(int(start), int(end) + 1)]",
            "def _get_core_indices(cores_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate a dictionary of cpu core indices.\\n    Args:\\n        cores_str (str): a string with format \"start_idx-end_idx\".\\n    Return:\\n        cpu_core_indices (list): a list collected all indices in [start_idx, end_idx].\\n    Example:\\n        cores_str = \\'0-20\\'\\n        cpu_core_indices = [0, 1, 2, ..., 18, 19, 20]\\n    '\n    (start, end) = cores_str.split('-')\n    return [*range(int(start), int(end) + 1)]"
        ]
    },
    {
        "func_name": "set_cpu_affinity",
        "original": "def set_cpu_affinity():\n    \"\"\"\n    Setup CPU affinity.\n    Each GPU would be bound to a specific set of CPU cores for optimal and stable performance.\n    This function would obtain GPU-CPU affinity via \"nvidia-smi topo -m\", then equally distribute\n    CPU cores to each GPU.\n    \"\"\"\n    (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups) = _get_gpu_affinity_table()\n    node_num = paddle.distributed.fleet.node_num()\n    gpu_per_node = paddle.distributed.get_world_size() // node_num\n    local_rank = paddle.distributed.get_rank() % gpu_per_node\n    affinity_mask = list()\n    cpu_affinity_key = gpu_cpu_affinity_map[local_rank]\n    cpu_core_idx = cpu_socket_gpus_list[cpu_affinity_key].index(local_rank)\n    for cpu_core_group in cpu_core_groups[cpu_affinity_key]:\n        affinity_mask.extend(cpu_core_group[cpu_core_idx])\n    pid = os.getpid()\n    os.sched_setaffinity(pid, affinity_mask)\n    logging.info('Set CPU affinity of rank-%d (Process %d) to %s.', local_rank, pid, str(os.sched_getaffinity(pid)))",
        "mutated": [
            "def set_cpu_affinity():\n    if False:\n        i = 10\n    '\\n    Setup CPU affinity.\\n    Each GPU would be bound to a specific set of CPU cores for optimal and stable performance.\\n    This function would obtain GPU-CPU affinity via \"nvidia-smi topo -m\", then equally distribute\\n    CPU cores to each GPU.\\n    '\n    (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups) = _get_gpu_affinity_table()\n    node_num = paddle.distributed.fleet.node_num()\n    gpu_per_node = paddle.distributed.get_world_size() // node_num\n    local_rank = paddle.distributed.get_rank() % gpu_per_node\n    affinity_mask = list()\n    cpu_affinity_key = gpu_cpu_affinity_map[local_rank]\n    cpu_core_idx = cpu_socket_gpus_list[cpu_affinity_key].index(local_rank)\n    for cpu_core_group in cpu_core_groups[cpu_affinity_key]:\n        affinity_mask.extend(cpu_core_group[cpu_core_idx])\n    pid = os.getpid()\n    os.sched_setaffinity(pid, affinity_mask)\n    logging.info('Set CPU affinity of rank-%d (Process %d) to %s.', local_rank, pid, str(os.sched_getaffinity(pid)))",
            "def set_cpu_affinity():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Setup CPU affinity.\\n    Each GPU would be bound to a specific set of CPU cores for optimal and stable performance.\\n    This function would obtain GPU-CPU affinity via \"nvidia-smi topo -m\", then equally distribute\\n    CPU cores to each GPU.\\n    '\n    (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups) = _get_gpu_affinity_table()\n    node_num = paddle.distributed.fleet.node_num()\n    gpu_per_node = paddle.distributed.get_world_size() // node_num\n    local_rank = paddle.distributed.get_rank() % gpu_per_node\n    affinity_mask = list()\n    cpu_affinity_key = gpu_cpu_affinity_map[local_rank]\n    cpu_core_idx = cpu_socket_gpus_list[cpu_affinity_key].index(local_rank)\n    for cpu_core_group in cpu_core_groups[cpu_affinity_key]:\n        affinity_mask.extend(cpu_core_group[cpu_core_idx])\n    pid = os.getpid()\n    os.sched_setaffinity(pid, affinity_mask)\n    logging.info('Set CPU affinity of rank-%d (Process %d) to %s.', local_rank, pid, str(os.sched_getaffinity(pid)))",
            "def set_cpu_affinity():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Setup CPU affinity.\\n    Each GPU would be bound to a specific set of CPU cores for optimal and stable performance.\\n    This function would obtain GPU-CPU affinity via \"nvidia-smi topo -m\", then equally distribute\\n    CPU cores to each GPU.\\n    '\n    (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups) = _get_gpu_affinity_table()\n    node_num = paddle.distributed.fleet.node_num()\n    gpu_per_node = paddle.distributed.get_world_size() // node_num\n    local_rank = paddle.distributed.get_rank() % gpu_per_node\n    affinity_mask = list()\n    cpu_affinity_key = gpu_cpu_affinity_map[local_rank]\n    cpu_core_idx = cpu_socket_gpus_list[cpu_affinity_key].index(local_rank)\n    for cpu_core_group in cpu_core_groups[cpu_affinity_key]:\n        affinity_mask.extend(cpu_core_group[cpu_core_idx])\n    pid = os.getpid()\n    os.sched_setaffinity(pid, affinity_mask)\n    logging.info('Set CPU affinity of rank-%d (Process %d) to %s.', local_rank, pid, str(os.sched_getaffinity(pid)))",
            "def set_cpu_affinity():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Setup CPU affinity.\\n    Each GPU would be bound to a specific set of CPU cores for optimal and stable performance.\\n    This function would obtain GPU-CPU affinity via \"nvidia-smi topo -m\", then equally distribute\\n    CPU cores to each GPU.\\n    '\n    (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups) = _get_gpu_affinity_table()\n    node_num = paddle.distributed.fleet.node_num()\n    gpu_per_node = paddle.distributed.get_world_size() // node_num\n    local_rank = paddle.distributed.get_rank() % gpu_per_node\n    affinity_mask = list()\n    cpu_affinity_key = gpu_cpu_affinity_map[local_rank]\n    cpu_core_idx = cpu_socket_gpus_list[cpu_affinity_key].index(local_rank)\n    for cpu_core_group in cpu_core_groups[cpu_affinity_key]:\n        affinity_mask.extend(cpu_core_group[cpu_core_idx])\n    pid = os.getpid()\n    os.sched_setaffinity(pid, affinity_mask)\n    logging.info('Set CPU affinity of rank-%d (Process %d) to %s.', local_rank, pid, str(os.sched_getaffinity(pid)))",
            "def set_cpu_affinity():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Setup CPU affinity.\\n    Each GPU would be bound to a specific set of CPU cores for optimal and stable performance.\\n    This function would obtain GPU-CPU affinity via \"nvidia-smi topo -m\", then equally distribute\\n    CPU cores to each GPU.\\n    '\n    (gpu_cpu_affinity_map, cpu_socket_gpus_list, cpu_core_groups) = _get_gpu_affinity_table()\n    node_num = paddle.distributed.fleet.node_num()\n    gpu_per_node = paddle.distributed.get_world_size() // node_num\n    local_rank = paddle.distributed.get_rank() % gpu_per_node\n    affinity_mask = list()\n    cpu_affinity_key = gpu_cpu_affinity_map[local_rank]\n    cpu_core_idx = cpu_socket_gpus_list[cpu_affinity_key].index(local_rank)\n    for cpu_core_group in cpu_core_groups[cpu_affinity_key]:\n        affinity_mask.extend(cpu_core_group[cpu_core_idx])\n    pid = os.getpid()\n    os.sched_setaffinity(pid, affinity_mask)\n    logging.info('Set CPU affinity of rank-%d (Process %d) to %s.', local_rank, pid, str(os.sched_getaffinity(pid)))"
        ]
    }
]