[
    {
        "func_name": "_optimized_historical_forecasts_last_points_only",
        "original": "def _optimized_historical_forecasts_last_points_only(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    \"\"\"\n    Optimized historical forecasts for RegressionModel with last_points_only = True\n\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\n    \"\"\"\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        if model.output_chunk_length != forecast_horizon and (not model.multi_models):\n            unit = freq if series_.has_datetime_index else 1\n            shift = model.output_chunk_length - forecast_horizon\n            hist_fct_tgt_start -= shift * unit\n            hist_fct_pc_start -= shift * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n            hist_fct_fc_start -= shift * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n            hist_fct_tgt_end -= shift * unit\n            hist_fct_pc_end -= shift * unit if hist_fct_pc_end is not None else hist_fct_pc_end\n            hist_fct_fc_end -= shift * unit if hist_fct_fc_end is not None else hist_fct_fc_end\n        (X, times) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][::stride, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        forecast = forecast.reshape(X.shape[0], -1, num_samples)\n        if model.multi_models:\n            forecast = forecast[:, (forecast_horizon - 1) * len(forecast_components):forecast_horizon * len(forecast_components), :]\n        forecasts_list.append(TimeSeries.from_times_and_values(times=times[0] if stride == 1 and model.output_chunk_length == 1 else generate_index(start=hist_fct_start + (forecast_horizon - 1) * freq, length=forecast.shape[0], freq=freq * stride, name=series_.time_index.name), values=forecast, columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
        "mutated": [
            "def _optimized_historical_forecasts_last_points_only(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = True\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        if model.output_chunk_length != forecast_horizon and (not model.multi_models):\n            unit = freq if series_.has_datetime_index else 1\n            shift = model.output_chunk_length - forecast_horizon\n            hist_fct_tgt_start -= shift * unit\n            hist_fct_pc_start -= shift * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n            hist_fct_fc_start -= shift * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n            hist_fct_tgt_end -= shift * unit\n            hist_fct_pc_end -= shift * unit if hist_fct_pc_end is not None else hist_fct_pc_end\n            hist_fct_fc_end -= shift * unit if hist_fct_fc_end is not None else hist_fct_fc_end\n        (X, times) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][::stride, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        forecast = forecast.reshape(X.shape[0], -1, num_samples)\n        if model.multi_models:\n            forecast = forecast[:, (forecast_horizon - 1) * len(forecast_components):forecast_horizon * len(forecast_components), :]\n        forecasts_list.append(TimeSeries.from_times_and_values(times=times[0] if stride == 1 and model.output_chunk_length == 1 else generate_index(start=hist_fct_start + (forecast_horizon - 1) * freq, length=forecast.shape[0], freq=freq * stride, name=series_.time_index.name), values=forecast, columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts_last_points_only(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = True\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        if model.output_chunk_length != forecast_horizon and (not model.multi_models):\n            unit = freq if series_.has_datetime_index else 1\n            shift = model.output_chunk_length - forecast_horizon\n            hist_fct_tgt_start -= shift * unit\n            hist_fct_pc_start -= shift * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n            hist_fct_fc_start -= shift * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n            hist_fct_tgt_end -= shift * unit\n            hist_fct_pc_end -= shift * unit if hist_fct_pc_end is not None else hist_fct_pc_end\n            hist_fct_fc_end -= shift * unit if hist_fct_fc_end is not None else hist_fct_fc_end\n        (X, times) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][::stride, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        forecast = forecast.reshape(X.shape[0], -1, num_samples)\n        if model.multi_models:\n            forecast = forecast[:, (forecast_horizon - 1) * len(forecast_components):forecast_horizon * len(forecast_components), :]\n        forecasts_list.append(TimeSeries.from_times_and_values(times=times[0] if stride == 1 and model.output_chunk_length == 1 else generate_index(start=hist_fct_start + (forecast_horizon - 1) * freq, length=forecast.shape[0], freq=freq * stride, name=series_.time_index.name), values=forecast, columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts_last_points_only(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = True\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        if model.output_chunk_length != forecast_horizon and (not model.multi_models):\n            unit = freq if series_.has_datetime_index else 1\n            shift = model.output_chunk_length - forecast_horizon\n            hist_fct_tgt_start -= shift * unit\n            hist_fct_pc_start -= shift * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n            hist_fct_fc_start -= shift * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n            hist_fct_tgt_end -= shift * unit\n            hist_fct_pc_end -= shift * unit if hist_fct_pc_end is not None else hist_fct_pc_end\n            hist_fct_fc_end -= shift * unit if hist_fct_fc_end is not None else hist_fct_fc_end\n        (X, times) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][::stride, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        forecast = forecast.reshape(X.shape[0], -1, num_samples)\n        if model.multi_models:\n            forecast = forecast[:, (forecast_horizon - 1) * len(forecast_components):forecast_horizon * len(forecast_components), :]\n        forecasts_list.append(TimeSeries.from_times_and_values(times=times[0] if stride == 1 and model.output_chunk_length == 1 else generate_index(start=hist_fct_start + (forecast_horizon - 1) * freq, length=forecast.shape[0], freq=freq * stride, name=series_.time_index.name), values=forecast, columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts_last_points_only(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = True\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        if model.output_chunk_length != forecast_horizon and (not model.multi_models):\n            unit = freq if series_.has_datetime_index else 1\n            shift = model.output_chunk_length - forecast_horizon\n            hist_fct_tgt_start -= shift * unit\n            hist_fct_pc_start -= shift * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n            hist_fct_fc_start -= shift * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n            hist_fct_tgt_end -= shift * unit\n            hist_fct_pc_end -= shift * unit if hist_fct_pc_end is not None else hist_fct_pc_end\n            hist_fct_fc_end -= shift * unit if hist_fct_fc_end is not None else hist_fct_fc_end\n        (X, times) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][::stride, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        forecast = forecast.reshape(X.shape[0], -1, num_samples)\n        if model.multi_models:\n            forecast = forecast[:, (forecast_horizon - 1) * len(forecast_components):forecast_horizon * len(forecast_components), :]\n        forecasts_list.append(TimeSeries.from_times_and_values(times=times[0] if stride == 1 and model.output_chunk_length == 1 else generate_index(start=hist_fct_start + (forecast_horizon - 1) * freq, length=forecast.shape[0], freq=freq * stride, name=series_.time_index.name), values=forecast, columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts_last_points_only(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = True\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        if model.output_chunk_length != forecast_horizon and (not model.multi_models):\n            unit = freq if series_.has_datetime_index else 1\n            shift = model.output_chunk_length - forecast_horizon\n            hist_fct_tgt_start -= shift * unit\n            hist_fct_pc_start -= shift * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n            hist_fct_fc_start -= shift * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n            hist_fct_tgt_end -= shift * unit\n            hist_fct_pc_end -= shift * unit if hist_fct_pc_end is not None else hist_fct_pc_end\n            hist_fct_fc_end -= shift * unit if hist_fct_fc_end is not None else hist_fct_fc_end\n        (X, times) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][::stride, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        forecast = forecast.reshape(X.shape[0], -1, num_samples)\n        if model.multi_models:\n            forecast = forecast[:, (forecast_horizon - 1) * len(forecast_components):forecast_horizon * len(forecast_components), :]\n        forecasts_list.append(TimeSeries.from_times_and_values(times=times[0] if stride == 1 and model.output_chunk_length == 1 else generate_index(start=hist_fct_start + (forecast_horizon - 1) * freq, length=forecast.shape[0], freq=freq * stride, name=series_.time_index.name), values=forecast, columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n    return forecasts_list if len(series) > 1 else forecasts_list[0]"
        ]
    },
    {
        "func_name": "_optimized_historical_forecasts_all_points",
        "original": "def _optimized_historical_forecasts_all_points(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    \"\"\"\n    Optimized historical forecasts for RegressionModel with last_points_only = False.\n\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\n    \"\"\"\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        shift_start = 0\n        if model.output_chunk_length > 1:\n            unit = freq if series_.has_datetime_index else 1\n            if not model.multi_models:\n                shift_start = model.output_chunk_length - 1\n                hist_fct_tgt_start -= shift_start * unit\n                hist_fct_pc_start -= shift_start * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n                hist_fct_fc_start -= shift_start * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n        (X, _) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][:, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        if model.multi_models:\n            forecast = forecast.reshape(X.shape[0], model.output_chunk_length, len(forecast_components), num_samples)\n            forecast = forecast[::stride, :forecast_horizon]\n        else:\n            forecast = forecast.reshape(X.shape[0], -1, num_samples)\n            forecast = sliding_window_view(forecast, (forecast_horizon, len(forecast_components), num_samples))\n            if forecast_horizon != model.output_chunk_length:\n                forecast = forecast[:-shift_start + forecast_horizon - 1:stride, 0, 0, :forecast_horizon, :, :]\n            else:\n                forecast = forecast[::stride, 0, 0, :, :, :]\n        new_times = generate_index(start=hist_fct_start, length=forecast_horizon * stride * forecast.shape[0], freq=freq, name=series_.time_index.name)\n        forecasts_ = []\n        for (idx_ftc, step_fct) in enumerate(range(0, forecast.shape[0] * stride, stride)):\n            forecasts_.append(TimeSeries.from_times_and_values(times=new_times[step_fct:step_fct + forecast_horizon], values=forecast[idx_ftc], columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n        forecasts_list.append(forecasts_)\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
        "mutated": [
            "def _optimized_historical_forecasts_all_points(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = False.\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        shift_start = 0\n        if model.output_chunk_length > 1:\n            unit = freq if series_.has_datetime_index else 1\n            if not model.multi_models:\n                shift_start = model.output_chunk_length - 1\n                hist_fct_tgt_start -= shift_start * unit\n                hist_fct_pc_start -= shift_start * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n                hist_fct_fc_start -= shift_start * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n        (X, _) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][:, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        if model.multi_models:\n            forecast = forecast.reshape(X.shape[0], model.output_chunk_length, len(forecast_components), num_samples)\n            forecast = forecast[::stride, :forecast_horizon]\n        else:\n            forecast = forecast.reshape(X.shape[0], -1, num_samples)\n            forecast = sliding_window_view(forecast, (forecast_horizon, len(forecast_components), num_samples))\n            if forecast_horizon != model.output_chunk_length:\n                forecast = forecast[:-shift_start + forecast_horizon - 1:stride, 0, 0, :forecast_horizon, :, :]\n            else:\n                forecast = forecast[::stride, 0, 0, :, :, :]\n        new_times = generate_index(start=hist_fct_start, length=forecast_horizon * stride * forecast.shape[0], freq=freq, name=series_.time_index.name)\n        forecasts_ = []\n        for (idx_ftc, step_fct) in enumerate(range(0, forecast.shape[0] * stride, stride)):\n            forecasts_.append(TimeSeries.from_times_and_values(times=new_times[step_fct:step_fct + forecast_horizon], values=forecast[idx_ftc], columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n        forecasts_list.append(forecasts_)\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts_all_points(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = False.\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        shift_start = 0\n        if model.output_chunk_length > 1:\n            unit = freq if series_.has_datetime_index else 1\n            if not model.multi_models:\n                shift_start = model.output_chunk_length - 1\n                hist_fct_tgt_start -= shift_start * unit\n                hist_fct_pc_start -= shift_start * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n                hist_fct_fc_start -= shift_start * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n        (X, _) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][:, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        if model.multi_models:\n            forecast = forecast.reshape(X.shape[0], model.output_chunk_length, len(forecast_components), num_samples)\n            forecast = forecast[::stride, :forecast_horizon]\n        else:\n            forecast = forecast.reshape(X.shape[0], -1, num_samples)\n            forecast = sliding_window_view(forecast, (forecast_horizon, len(forecast_components), num_samples))\n            if forecast_horizon != model.output_chunk_length:\n                forecast = forecast[:-shift_start + forecast_horizon - 1:stride, 0, 0, :forecast_horizon, :, :]\n            else:\n                forecast = forecast[::stride, 0, 0, :, :, :]\n        new_times = generate_index(start=hist_fct_start, length=forecast_horizon * stride * forecast.shape[0], freq=freq, name=series_.time_index.name)\n        forecasts_ = []\n        for (idx_ftc, step_fct) in enumerate(range(0, forecast.shape[0] * stride, stride)):\n            forecasts_.append(TimeSeries.from_times_and_values(times=new_times[step_fct:step_fct + forecast_horizon], values=forecast[idx_ftc], columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n        forecasts_list.append(forecasts_)\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts_all_points(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = False.\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        shift_start = 0\n        if model.output_chunk_length > 1:\n            unit = freq if series_.has_datetime_index else 1\n            if not model.multi_models:\n                shift_start = model.output_chunk_length - 1\n                hist_fct_tgt_start -= shift_start * unit\n                hist_fct_pc_start -= shift_start * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n                hist_fct_fc_start -= shift_start * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n        (X, _) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][:, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        if model.multi_models:\n            forecast = forecast.reshape(X.shape[0], model.output_chunk_length, len(forecast_components), num_samples)\n            forecast = forecast[::stride, :forecast_horizon]\n        else:\n            forecast = forecast.reshape(X.shape[0], -1, num_samples)\n            forecast = sliding_window_view(forecast, (forecast_horizon, len(forecast_components), num_samples))\n            if forecast_horizon != model.output_chunk_length:\n                forecast = forecast[:-shift_start + forecast_horizon - 1:stride, 0, 0, :forecast_horizon, :, :]\n            else:\n                forecast = forecast[::stride, 0, 0, :, :, :]\n        new_times = generate_index(start=hist_fct_start, length=forecast_horizon * stride * forecast.shape[0], freq=freq, name=series_.time_index.name)\n        forecasts_ = []\n        for (idx_ftc, step_fct) in enumerate(range(0, forecast.shape[0] * stride, stride)):\n            forecasts_.append(TimeSeries.from_times_and_values(times=new_times[step_fct:step_fct + forecast_horizon], values=forecast[idx_ftc], columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n        forecasts_list.append(forecasts_)\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts_all_points(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = False.\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        shift_start = 0\n        if model.output_chunk_length > 1:\n            unit = freq if series_.has_datetime_index else 1\n            if not model.multi_models:\n                shift_start = model.output_chunk_length - 1\n                hist_fct_tgt_start -= shift_start * unit\n                hist_fct_pc_start -= shift_start * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n                hist_fct_fc_start -= shift_start * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n        (X, _) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][:, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        if model.multi_models:\n            forecast = forecast.reshape(X.shape[0], model.output_chunk_length, len(forecast_components), num_samples)\n            forecast = forecast[::stride, :forecast_horizon]\n        else:\n            forecast = forecast.reshape(X.shape[0], -1, num_samples)\n            forecast = sliding_window_view(forecast, (forecast_horizon, len(forecast_components), num_samples))\n            if forecast_horizon != model.output_chunk_length:\n                forecast = forecast[:-shift_start + forecast_horizon - 1:stride, 0, 0, :forecast_horizon, :, :]\n            else:\n                forecast = forecast[::stride, 0, 0, :, :, :]\n        new_times = generate_index(start=hist_fct_start, length=forecast_horizon * stride * forecast.shape[0], freq=freq, name=series_.time_index.name)\n        forecasts_ = []\n        for (idx_ftc, step_fct) in enumerate(range(0, forecast.shape[0] * stride, stride)):\n            forecasts_.append(TimeSeries.from_times_and_values(times=new_times[step_fct:step_fct + forecast_horizon], values=forecast[idx_ftc], columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n        forecasts_list.append(forecasts_)\n    return forecasts_list if len(series) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts_all_points(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, show_warnings: bool=True, predict_likelihood_parameters: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Optimized historical forecasts for RegressionModel with last_points_only = False.\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    forecasts_list = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        freq = series_.freq\n        forecast_components = model._likelihood_components_names(series_) if predict_likelihood_parameters else series_.columns\n        (hist_fct_start, hist_fct_end, hist_fct_tgt_start, hist_fct_tgt_end, hist_fct_pc_start, hist_fct_pc_end, hist_fct_fc_start, hist_fct_fc_end) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=freq, show_warnings=show_warnings)\n        shift_start = 0\n        if model.output_chunk_length > 1:\n            unit = freq if series_.has_datetime_index else 1\n            if not model.multi_models:\n                shift_start = model.output_chunk_length - 1\n                hist_fct_tgt_start -= shift_start * unit\n                hist_fct_pc_start -= shift_start * unit if hist_fct_pc_start is not None else hist_fct_pc_start\n                hist_fct_fc_start -= shift_start * unit if hist_fct_fc_start is not None else hist_fct_fc_start\n        (X, _) = create_lagged_prediction_data(target_series=None if model._get_lags('target') is None else series_[hist_fct_tgt_start:hist_fct_tgt_end], past_covariates=None if past_covariates_ is None else past_covariates_[hist_fct_pc_start:hist_fct_pc_end], future_covariates=None if future_covariates_ is None else future_covariates_[hist_fct_fc_start:hist_fct_fc_end], lags=model._get_lags('target'), lags_past_covariates=model._get_lags('past'), lags_future_covariates=model._get_lags('future'), uses_static_covariates=model.uses_static_covariates, last_static_covariates_shape=model._static_covariates_shape, max_samples_per_ts=None, check_inputs=True, use_moving_windows=True, concatenate=False)\n        X = X[0][:, :, 0]\n        forecast = model._predict_and_sample(x=np.repeat(X, num_samples, axis=0), num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n        if model.multi_models:\n            forecast = forecast.reshape(X.shape[0], model.output_chunk_length, len(forecast_components), num_samples)\n            forecast = forecast[::stride, :forecast_horizon]\n        else:\n            forecast = forecast.reshape(X.shape[0], -1, num_samples)\n            forecast = sliding_window_view(forecast, (forecast_horizon, len(forecast_components), num_samples))\n            if forecast_horizon != model.output_chunk_length:\n                forecast = forecast[:-shift_start + forecast_horizon - 1:stride, 0, 0, :forecast_horizon, :, :]\n            else:\n                forecast = forecast[::stride, 0, 0, :, :, :]\n        new_times = generate_index(start=hist_fct_start, length=forecast_horizon * stride * forecast.shape[0], freq=freq, name=series_.time_index.name)\n        forecasts_ = []\n        for (idx_ftc, step_fct) in enumerate(range(0, forecast.shape[0] * stride, stride)):\n            forecasts_.append(TimeSeries.from_times_and_values(times=new_times[step_fct:step_fct + forecast_horizon], values=forecast[idx_ftc], columns=forecast_components, static_covariates=series_.static_covariates, hierarchy=series_.hierarchy))\n        forecasts_list.append(forecasts_)\n    return forecasts_list if len(series) > 1 else forecasts_list[0]"
        ]
    }
]