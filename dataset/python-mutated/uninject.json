[
    {
        "func_name": "get_include_app_paths",
        "original": "def get_include_app_paths(package_name: str, venv: Venv, local_bin_dir: Path) -> Set[Path]:\n    bin_dir_app_paths = _get_package_bin_dir_app_paths(venv, venv.package_metadata[package_name], local_bin_dir)\n    need_to_remove = set()\n    for bin_dir_app_path in bin_dir_app_paths:\n        if bin_dir_app_path.name in venv.package_metadata[package_name].apps:\n            need_to_remove.add(bin_dir_app_path)\n    return need_to_remove",
        "mutated": [
            "def get_include_app_paths(package_name: str, venv: Venv, local_bin_dir: Path) -> Set[Path]:\n    if False:\n        i = 10\n    bin_dir_app_paths = _get_package_bin_dir_app_paths(venv, venv.package_metadata[package_name], local_bin_dir)\n    need_to_remove = set()\n    for bin_dir_app_path in bin_dir_app_paths:\n        if bin_dir_app_path.name in venv.package_metadata[package_name].apps:\n            need_to_remove.add(bin_dir_app_path)\n    return need_to_remove",
            "def get_include_app_paths(package_name: str, venv: Venv, local_bin_dir: Path) -> Set[Path]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    bin_dir_app_paths = _get_package_bin_dir_app_paths(venv, venv.package_metadata[package_name], local_bin_dir)\n    need_to_remove = set()\n    for bin_dir_app_path in bin_dir_app_paths:\n        if bin_dir_app_path.name in venv.package_metadata[package_name].apps:\n            need_to_remove.add(bin_dir_app_path)\n    return need_to_remove",
            "def get_include_app_paths(package_name: str, venv: Venv, local_bin_dir: Path) -> Set[Path]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    bin_dir_app_paths = _get_package_bin_dir_app_paths(venv, venv.package_metadata[package_name], local_bin_dir)\n    need_to_remove = set()\n    for bin_dir_app_path in bin_dir_app_paths:\n        if bin_dir_app_path.name in venv.package_metadata[package_name].apps:\n            need_to_remove.add(bin_dir_app_path)\n    return need_to_remove",
            "def get_include_app_paths(package_name: str, venv: Venv, local_bin_dir: Path) -> Set[Path]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    bin_dir_app_paths = _get_package_bin_dir_app_paths(venv, venv.package_metadata[package_name], local_bin_dir)\n    need_to_remove = set()\n    for bin_dir_app_path in bin_dir_app_paths:\n        if bin_dir_app_path.name in venv.package_metadata[package_name].apps:\n            need_to_remove.add(bin_dir_app_path)\n    return need_to_remove",
            "def get_include_app_paths(package_name: str, venv: Venv, local_bin_dir: Path) -> Set[Path]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    bin_dir_app_paths = _get_package_bin_dir_app_paths(venv, venv.package_metadata[package_name], local_bin_dir)\n    need_to_remove = set()\n    for bin_dir_app_path in bin_dir_app_paths:\n        if bin_dir_app_path.name in venv.package_metadata[package_name].apps:\n            need_to_remove.add(bin_dir_app_path)\n    return need_to_remove"
        ]
    },
    {
        "func_name": "uninject_dep",
        "original": "def uninject_dep(venv: Venv, package_name: str, *, local_bin_dir: Path, leave_deps: bool=False) -> bool:\n    package_name = canonicalize_name(package_name)\n    if package_name == venv.pipx_metadata.main_package.package:\n        logger.warning(pipx_wrap(f'\\n            {package_name} is the main package of {venv.root.name}\\n            venv. Use `pipx uninstall {venv.root.name}` to uninstall instead of uninject.\\n            ', subsequent_indent=' ' * 4))\n        return False\n    if package_name not in venv.pipx_metadata.injected_packages:\n        logger.warning(f'{package_name} is not in the {venv.root.name} venv. Skipping.')\n        return False\n    need_app_uninstall = venv.package_metadata[package_name].include_apps\n    new_app_paths = get_include_app_paths(package_name, venv, local_bin_dir)\n    if not leave_deps:\n        orig_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'Original not required packages: {orig_not_required_packages}')\n    venv.uninstall_package(package=package_name, was_injected=True)\n    if not leave_deps:\n        new_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'New not required packages: {new_not_required_packages}')\n        deps_of_uninstalled = new_not_required_packages - orig_not_required_packages\n        if len(deps_of_uninstalled) == 0:\n            pass\n        else:\n            logger.info(f'Dependencies of uninstalled package: {deps_of_uninstalled}')\n        for dep_package_name in deps_of_uninstalled:\n            venv.uninstall_package(package=dep_package_name, was_injected=False)\n        deps_string = ' and its dependencies'\n    else:\n        deps_string = ''\n    if need_app_uninstall:\n        for app_path in new_app_paths:\n            try:\n                os.unlink(app_path)\n            except FileNotFoundError:\n                logger.info(f\"tried to remove but couldn't find {app_path}\")\n            else:\n                logger.info(f'removed file {app_path}')\n    print(f'Uninjected package {bold(package_name)}{deps_string} from venv {bold(venv.root.name)} {stars}')\n    return True",
        "mutated": [
            "def uninject_dep(venv: Venv, package_name: str, *, local_bin_dir: Path, leave_deps: bool=False) -> bool:\n    if False:\n        i = 10\n    package_name = canonicalize_name(package_name)\n    if package_name == venv.pipx_metadata.main_package.package:\n        logger.warning(pipx_wrap(f'\\n            {package_name} is the main package of {venv.root.name}\\n            venv. Use `pipx uninstall {venv.root.name}` to uninstall instead of uninject.\\n            ', subsequent_indent=' ' * 4))\n        return False\n    if package_name not in venv.pipx_metadata.injected_packages:\n        logger.warning(f'{package_name} is not in the {venv.root.name} venv. Skipping.')\n        return False\n    need_app_uninstall = venv.package_metadata[package_name].include_apps\n    new_app_paths = get_include_app_paths(package_name, venv, local_bin_dir)\n    if not leave_deps:\n        orig_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'Original not required packages: {orig_not_required_packages}')\n    venv.uninstall_package(package=package_name, was_injected=True)\n    if not leave_deps:\n        new_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'New not required packages: {new_not_required_packages}')\n        deps_of_uninstalled = new_not_required_packages - orig_not_required_packages\n        if len(deps_of_uninstalled) == 0:\n            pass\n        else:\n            logger.info(f'Dependencies of uninstalled package: {deps_of_uninstalled}')\n        for dep_package_name in deps_of_uninstalled:\n            venv.uninstall_package(package=dep_package_name, was_injected=False)\n        deps_string = ' and its dependencies'\n    else:\n        deps_string = ''\n    if need_app_uninstall:\n        for app_path in new_app_paths:\n            try:\n                os.unlink(app_path)\n            except FileNotFoundError:\n                logger.info(f\"tried to remove but couldn't find {app_path}\")\n            else:\n                logger.info(f'removed file {app_path}')\n    print(f'Uninjected package {bold(package_name)}{deps_string} from venv {bold(venv.root.name)} {stars}')\n    return True",
            "def uninject_dep(venv: Venv, package_name: str, *, local_bin_dir: Path, leave_deps: bool=False) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    package_name = canonicalize_name(package_name)\n    if package_name == venv.pipx_metadata.main_package.package:\n        logger.warning(pipx_wrap(f'\\n            {package_name} is the main package of {venv.root.name}\\n            venv. Use `pipx uninstall {venv.root.name}` to uninstall instead of uninject.\\n            ', subsequent_indent=' ' * 4))\n        return False\n    if package_name not in venv.pipx_metadata.injected_packages:\n        logger.warning(f'{package_name} is not in the {venv.root.name} venv. Skipping.')\n        return False\n    need_app_uninstall = venv.package_metadata[package_name].include_apps\n    new_app_paths = get_include_app_paths(package_name, venv, local_bin_dir)\n    if not leave_deps:\n        orig_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'Original not required packages: {orig_not_required_packages}')\n    venv.uninstall_package(package=package_name, was_injected=True)\n    if not leave_deps:\n        new_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'New not required packages: {new_not_required_packages}')\n        deps_of_uninstalled = new_not_required_packages - orig_not_required_packages\n        if len(deps_of_uninstalled) == 0:\n            pass\n        else:\n            logger.info(f'Dependencies of uninstalled package: {deps_of_uninstalled}')\n        for dep_package_name in deps_of_uninstalled:\n            venv.uninstall_package(package=dep_package_name, was_injected=False)\n        deps_string = ' and its dependencies'\n    else:\n        deps_string = ''\n    if need_app_uninstall:\n        for app_path in new_app_paths:\n            try:\n                os.unlink(app_path)\n            except FileNotFoundError:\n                logger.info(f\"tried to remove but couldn't find {app_path}\")\n            else:\n                logger.info(f'removed file {app_path}')\n    print(f'Uninjected package {bold(package_name)}{deps_string} from venv {bold(venv.root.name)} {stars}')\n    return True",
            "def uninject_dep(venv: Venv, package_name: str, *, local_bin_dir: Path, leave_deps: bool=False) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    package_name = canonicalize_name(package_name)\n    if package_name == venv.pipx_metadata.main_package.package:\n        logger.warning(pipx_wrap(f'\\n            {package_name} is the main package of {venv.root.name}\\n            venv. Use `pipx uninstall {venv.root.name}` to uninstall instead of uninject.\\n            ', subsequent_indent=' ' * 4))\n        return False\n    if package_name not in venv.pipx_metadata.injected_packages:\n        logger.warning(f'{package_name} is not in the {venv.root.name} venv. Skipping.')\n        return False\n    need_app_uninstall = venv.package_metadata[package_name].include_apps\n    new_app_paths = get_include_app_paths(package_name, venv, local_bin_dir)\n    if not leave_deps:\n        orig_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'Original not required packages: {orig_not_required_packages}')\n    venv.uninstall_package(package=package_name, was_injected=True)\n    if not leave_deps:\n        new_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'New not required packages: {new_not_required_packages}')\n        deps_of_uninstalled = new_not_required_packages - orig_not_required_packages\n        if len(deps_of_uninstalled) == 0:\n            pass\n        else:\n            logger.info(f'Dependencies of uninstalled package: {deps_of_uninstalled}')\n        for dep_package_name in deps_of_uninstalled:\n            venv.uninstall_package(package=dep_package_name, was_injected=False)\n        deps_string = ' and its dependencies'\n    else:\n        deps_string = ''\n    if need_app_uninstall:\n        for app_path in new_app_paths:\n            try:\n                os.unlink(app_path)\n            except FileNotFoundError:\n                logger.info(f\"tried to remove but couldn't find {app_path}\")\n            else:\n                logger.info(f'removed file {app_path}')\n    print(f'Uninjected package {bold(package_name)}{deps_string} from venv {bold(venv.root.name)} {stars}')\n    return True",
            "def uninject_dep(venv: Venv, package_name: str, *, local_bin_dir: Path, leave_deps: bool=False) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    package_name = canonicalize_name(package_name)\n    if package_name == venv.pipx_metadata.main_package.package:\n        logger.warning(pipx_wrap(f'\\n            {package_name} is the main package of {venv.root.name}\\n            venv. Use `pipx uninstall {venv.root.name}` to uninstall instead of uninject.\\n            ', subsequent_indent=' ' * 4))\n        return False\n    if package_name not in venv.pipx_metadata.injected_packages:\n        logger.warning(f'{package_name} is not in the {venv.root.name} venv. Skipping.')\n        return False\n    need_app_uninstall = venv.package_metadata[package_name].include_apps\n    new_app_paths = get_include_app_paths(package_name, venv, local_bin_dir)\n    if not leave_deps:\n        orig_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'Original not required packages: {orig_not_required_packages}')\n    venv.uninstall_package(package=package_name, was_injected=True)\n    if not leave_deps:\n        new_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'New not required packages: {new_not_required_packages}')\n        deps_of_uninstalled = new_not_required_packages - orig_not_required_packages\n        if len(deps_of_uninstalled) == 0:\n            pass\n        else:\n            logger.info(f'Dependencies of uninstalled package: {deps_of_uninstalled}')\n        for dep_package_name in deps_of_uninstalled:\n            venv.uninstall_package(package=dep_package_name, was_injected=False)\n        deps_string = ' and its dependencies'\n    else:\n        deps_string = ''\n    if need_app_uninstall:\n        for app_path in new_app_paths:\n            try:\n                os.unlink(app_path)\n            except FileNotFoundError:\n                logger.info(f\"tried to remove but couldn't find {app_path}\")\n            else:\n                logger.info(f'removed file {app_path}')\n    print(f'Uninjected package {bold(package_name)}{deps_string} from venv {bold(venv.root.name)} {stars}')\n    return True",
            "def uninject_dep(venv: Venv, package_name: str, *, local_bin_dir: Path, leave_deps: bool=False) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    package_name = canonicalize_name(package_name)\n    if package_name == venv.pipx_metadata.main_package.package:\n        logger.warning(pipx_wrap(f'\\n            {package_name} is the main package of {venv.root.name}\\n            venv. Use `pipx uninstall {venv.root.name}` to uninstall instead of uninject.\\n            ', subsequent_indent=' ' * 4))\n        return False\n    if package_name not in venv.pipx_metadata.injected_packages:\n        logger.warning(f'{package_name} is not in the {venv.root.name} venv. Skipping.')\n        return False\n    need_app_uninstall = venv.package_metadata[package_name].include_apps\n    new_app_paths = get_include_app_paths(package_name, venv, local_bin_dir)\n    if not leave_deps:\n        orig_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'Original not required packages: {orig_not_required_packages}')\n    venv.uninstall_package(package=package_name, was_injected=True)\n    if not leave_deps:\n        new_not_required_packages = venv.list_installed_packages(not_required=True)\n        logger.info(f'New not required packages: {new_not_required_packages}')\n        deps_of_uninstalled = new_not_required_packages - orig_not_required_packages\n        if len(deps_of_uninstalled) == 0:\n            pass\n        else:\n            logger.info(f'Dependencies of uninstalled package: {deps_of_uninstalled}')\n        for dep_package_name in deps_of_uninstalled:\n            venv.uninstall_package(package=dep_package_name, was_injected=False)\n        deps_string = ' and its dependencies'\n    else:\n        deps_string = ''\n    if need_app_uninstall:\n        for app_path in new_app_paths:\n            try:\n                os.unlink(app_path)\n            except FileNotFoundError:\n                logger.info(f\"tried to remove but couldn't find {app_path}\")\n            else:\n                logger.info(f'removed file {app_path}')\n    print(f'Uninjected package {bold(package_name)}{deps_string} from venv {bold(venv.root.name)} {stars}')\n    return True"
        ]
    },
    {
        "func_name": "uninject",
        "original": "def uninject(venv_dir: Path, dependencies: List[str], *, local_bin_dir: Path, leave_deps: bool, verbose: bool) -> ExitCode:\n    \"\"\"Returns pipx exit code\"\"\"\n    if not venv_dir.exists() or not next(venv_dir.iterdir()):\n        raise PipxError(f'Virtual environment {venv_dir.name} does not exist.')\n    venv = Venv(venv_dir, verbose=verbose)\n    if not venv.package_metadata:\n        raise PipxError(f\"\\n            Can't uninject from Virtual Environment {venv_dir.name!r}.\\n            {venv_dir.name!r} has missing internal pipx metadata.\\n            It was likely installed using a pipx version before 0.15.0.0.\\n            Please uninstall and install {venv_dir.name!r} manually to fix.\\n            \")\n    all_success = True\n    for dep in dependencies:\n        all_success &= uninject_dep(venv, dep, local_bin_dir=local_bin_dir, leave_deps=leave_deps)\n    if all_success:\n        return EXIT_CODE_OK\n    else:\n        return EXIT_CODE_UNINJECT_ERROR",
        "mutated": [
            "def uninject(venv_dir: Path, dependencies: List[str], *, local_bin_dir: Path, leave_deps: bool, verbose: bool) -> ExitCode:\n    if False:\n        i = 10\n    'Returns pipx exit code'\n    if not venv_dir.exists() or not next(venv_dir.iterdir()):\n        raise PipxError(f'Virtual environment {venv_dir.name} does not exist.')\n    venv = Venv(venv_dir, verbose=verbose)\n    if not venv.package_metadata:\n        raise PipxError(f\"\\n            Can't uninject from Virtual Environment {venv_dir.name!r}.\\n            {venv_dir.name!r} has missing internal pipx metadata.\\n            It was likely installed using a pipx version before 0.15.0.0.\\n            Please uninstall and install {venv_dir.name!r} manually to fix.\\n            \")\n    all_success = True\n    for dep in dependencies:\n        all_success &= uninject_dep(venv, dep, local_bin_dir=local_bin_dir, leave_deps=leave_deps)\n    if all_success:\n        return EXIT_CODE_OK\n    else:\n        return EXIT_CODE_UNINJECT_ERROR",
            "def uninject(venv_dir: Path, dependencies: List[str], *, local_bin_dir: Path, leave_deps: bool, verbose: bool) -> ExitCode:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns pipx exit code'\n    if not venv_dir.exists() or not next(venv_dir.iterdir()):\n        raise PipxError(f'Virtual environment {venv_dir.name} does not exist.')\n    venv = Venv(venv_dir, verbose=verbose)\n    if not venv.package_metadata:\n        raise PipxError(f\"\\n            Can't uninject from Virtual Environment {venv_dir.name!r}.\\n            {venv_dir.name!r} has missing internal pipx metadata.\\n            It was likely installed using a pipx version before 0.15.0.0.\\n            Please uninstall and install {venv_dir.name!r} manually to fix.\\n            \")\n    all_success = True\n    for dep in dependencies:\n        all_success &= uninject_dep(venv, dep, local_bin_dir=local_bin_dir, leave_deps=leave_deps)\n    if all_success:\n        return EXIT_CODE_OK\n    else:\n        return EXIT_CODE_UNINJECT_ERROR",
            "def uninject(venv_dir: Path, dependencies: List[str], *, local_bin_dir: Path, leave_deps: bool, verbose: bool) -> ExitCode:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns pipx exit code'\n    if not venv_dir.exists() or not next(venv_dir.iterdir()):\n        raise PipxError(f'Virtual environment {venv_dir.name} does not exist.')\n    venv = Venv(venv_dir, verbose=verbose)\n    if not venv.package_metadata:\n        raise PipxError(f\"\\n            Can't uninject from Virtual Environment {venv_dir.name!r}.\\n            {venv_dir.name!r} has missing internal pipx metadata.\\n            It was likely installed using a pipx version before 0.15.0.0.\\n            Please uninstall and install {venv_dir.name!r} manually to fix.\\n            \")\n    all_success = True\n    for dep in dependencies:\n        all_success &= uninject_dep(venv, dep, local_bin_dir=local_bin_dir, leave_deps=leave_deps)\n    if all_success:\n        return EXIT_CODE_OK\n    else:\n        return EXIT_CODE_UNINJECT_ERROR",
            "def uninject(venv_dir: Path, dependencies: List[str], *, local_bin_dir: Path, leave_deps: bool, verbose: bool) -> ExitCode:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns pipx exit code'\n    if not venv_dir.exists() or not next(venv_dir.iterdir()):\n        raise PipxError(f'Virtual environment {venv_dir.name} does not exist.')\n    venv = Venv(venv_dir, verbose=verbose)\n    if not venv.package_metadata:\n        raise PipxError(f\"\\n            Can't uninject from Virtual Environment {venv_dir.name!r}.\\n            {venv_dir.name!r} has missing internal pipx metadata.\\n            It was likely installed using a pipx version before 0.15.0.0.\\n            Please uninstall and install {venv_dir.name!r} manually to fix.\\n            \")\n    all_success = True\n    for dep in dependencies:\n        all_success &= uninject_dep(venv, dep, local_bin_dir=local_bin_dir, leave_deps=leave_deps)\n    if all_success:\n        return EXIT_CODE_OK\n    else:\n        return EXIT_CODE_UNINJECT_ERROR",
            "def uninject(venv_dir: Path, dependencies: List[str], *, local_bin_dir: Path, leave_deps: bool, verbose: bool) -> ExitCode:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns pipx exit code'\n    if not venv_dir.exists() or not next(venv_dir.iterdir()):\n        raise PipxError(f'Virtual environment {venv_dir.name} does not exist.')\n    venv = Venv(venv_dir, verbose=verbose)\n    if not venv.package_metadata:\n        raise PipxError(f\"\\n            Can't uninject from Virtual Environment {venv_dir.name!r}.\\n            {venv_dir.name!r} has missing internal pipx metadata.\\n            It was likely installed using a pipx version before 0.15.0.0.\\n            Please uninstall and install {venv_dir.name!r} manually to fix.\\n            \")\n    all_success = True\n    for dep in dependencies:\n        all_success &= uninject_dep(venv, dep, local_bin_dir=local_bin_dir, leave_deps=leave_deps)\n    if all_success:\n        return EXIT_CODE_OK\n    else:\n        return EXIT_CODE_UNINJECT_ERROR"
        ]
    }
]