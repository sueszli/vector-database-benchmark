import glob
import os
import sys
import warnings
from numba import config as numba_config
CC_60_PTX_FILE = os.path.join(os.path.dirname(__file__), '../core/udf/shim_60.ptx')

def _get_best_ptx_file(archs, max_compute_capability):
    if False:
        return 10
    '\n    Determine of the available PTX files which one is\n    the most recent up to and including the device compute capability.\n    '
    filtered_archs = [x for x in archs if x[0] <= max_compute_capability]
    if filtered_archs:
        return max(filtered_archs, key=lambda x: x[0])
    else:
        return None

def _get_ptx_file(path, prefix):
    if False:
        for i in range(10):
            print('nop')
    if 'RAPIDS_NO_INITIALIZE' in os.environ:
        cc = int(os.environ.get('STRINGS_UDF_CC', '60'))
    else:
        from numba import cuda
        dev = cuda.get_current_device()
        cc = int(''.join((str(x) for x in dev.compute_capability)))
    files = glob.glob(os.path.join(path, f'{prefix}*.ptx'))
    if len(files) == 0:
        raise RuntimeError(f'Missing PTX files for cc={cc}')
    regular_sms = []
    for f in files:
        file_name = os.path.basename(f)
        sm_number = file_name.rstrip('.ptx').lstrip(prefix)
        if sm_number.endswith('a'):
            processed_sm_number = int(sm_number.rstrip('a'))
            if processed_sm_number == cc:
                return f
        else:
            regular_sms.append((int(sm_number), f))
    regular_result = None
    if regular_sms:
        regular_result = _get_best_ptx_file(regular_sms, cc)
    if regular_result is None:
        raise RuntimeError(f'This cuDF installation is missing the necessary PTX files that are <={cc}.')
    else:
        return regular_result[1]

def _patch_numba_mvc():
    if False:
        return 10
    numba_config.CUDA_ENABLE_MINOR_VERSION_COMPATIBILITY = 1
    if 'numba.cuda' in sys.modules:
        import numba.cuda
        from cubinlinker import CubinLinker, CubinLinkerError
        from ptxcompiler import compile_ptx
        numba.cuda.cudadrv.driver.compile_ptx = compile_ptx
        numba.cuda.cudadrv.driver.CubinLinker = CubinLinker
        numba.cuda.cudadrv.driver.CubinLinkerError = CubinLinkerError

def _setup_numba():
    if False:
        i = 10
        return i + 15
    '\n    Configure the numba linker for use with cuDF. This consists of\n    potentially putting numba into enhanced compatibility mode\n    based on the user driver and runtime versions as well as the\n    version of the CUDA Toolkit used to build the PTX files shipped\n    with the user cuDF package.\n    '
    try:
        from ptxcompiler.patch import NO_DRIVER, safe_get_versions
    except ModuleNotFoundError:
        from cudf.utils._ptxcompiler import NO_DRIVER, safe_get_versions
    versions = safe_get_versions()
    if versions != NO_DRIVER:
        (driver_version, runtime_version) = versions
        if driver_version >= (12, 0) and runtime_version > driver_version:
            warnings.warn(f'Using CUDA toolkit version {runtime_version} with CUDA driver version {driver_version} requires minor version compatibility, which is not yet supported for CUDA driver versions 12.0 and above. It is likely that many cuDF operations will not work in this state. Please install CUDA toolkit version {driver_version} to continue using cuDF.')
        else:
            ptx_toolkit_version = _get_cuda_version_from_ptx_file(CC_60_PTX_FILE)
            if driver_version < ptx_toolkit_version or driver_version < runtime_version:
                _patch_numba_mvc()

def _get_cuda_version_from_ptx_file(path):
    if False:
        print('Hello World!')
    '\n    https://docs.nvidia.com/cuda/parallel-thread-execution/\n    Each PTX module must begin with a .version\n    directive specifying the PTX language version\n\n    example header:\n    //\n    // Generated by NVIDIA NVVM Compiler\n    //\n    // Compiler Build ID: CL-31057947\n    // Cuda compilation tools, release 11.6, V11.6.124\n    // Based on NVVM 7.0.1\n    //\n\n    .version 7.6\n    .target sm_52\n    .address_size 64\n\n    '
    with open(path) as ptx_file:
        for line in ptx_file:
            if line.startswith('.version'):
                ver_line = line
                break
        else:
            raise ValueError('Could not read CUDA version from ptx file.')
    version = ver_line.strip('\n').split(' ')[1]
    ver_map = {'7.5': (11, 5), '7.6': (11, 6), '7.7': (11, 7), '7.8': (11, 8), '8.0': (12, 0), '8.1': (12, 1)}
    cuda_ver = ver_map.get(version)
    if cuda_ver is None:
        raise ValueError(f'Could not map PTX version {version} to a CUDA version')
    return cuda_ver

class _CUDFNumbaConfig:

    def __enter__(self):
        if False:
            print('Hello World!')
        self.enter_val = numba_config.CUDA_LOW_OCCUPANCY_WARNINGS
        numba_config.CUDA_LOW_OCCUPANCY_WARNINGS = 0

    def __exit__(self, exc_type, exc_value, traceback):
        if False:
            while True:
                i = 10
        numba_config.CUDA_LOW_OCCUPANCY_WARNINGS = self.enter_val