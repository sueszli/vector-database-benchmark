[
    {
        "func_name": "__init__",
        "original": "def __init__(self, *args, **kwargs):\n    super(OrderedListDict, self).__init__(*args, **kwargs)\n    self.default_factory = list",
        "mutated": [
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n    super(OrderedListDict, self).__init__(*args, **kwargs)\n    self.default_factory = list",
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(OrderedListDict, self).__init__(*args, **kwargs)\n    self.default_factory = list",
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(OrderedListDict, self).__init__(*args, **kwargs)\n    self.default_factory = list",
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(OrderedListDict, self).__init__(*args, **kwargs)\n    self.default_factory = list",
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(OrderedListDict, self).__init__(*args, **kwargs)\n    self.default_factory = list"
        ]
    },
    {
        "func_name": "__missing__",
        "original": "def __missing__(self, key):\n    self[key] = Value = self.default_factory()\n    return Value",
        "mutated": [
            "def __missing__(self, key):\n    if False:\n        i = 10\n    self[key] = Value = self.default_factory()\n    return Value",
            "def __missing__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self[key] = Value = self.default_factory()\n    return Value",
            "def __missing__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self[key] = Value = self.default_factory()\n    return Value",
            "def __missing__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self[key] = Value = self.default_factory()\n    return Value",
            "def __missing__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self[key] = Value = self.default_factory()\n    return Value"
        ]
    },
    {
        "func_name": "GetPackageList",
        "original": "def GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain):\n    PkgSet = set()\n    if Platform.Packages:\n        PkgSet.update(Platform.Packages)\n    for ModuleFile in Platform.Modules:\n        Data = BuildDatabase[ModuleFile, Arch, Target, Toolchain]\n        PkgSet.update(Data.Packages)\n        for Lib in GetLiabraryInstances(Data, Platform, BuildDatabase, Arch, Target, Toolchain):\n            PkgSet.update(Lib.Packages)\n    return list(PkgSet)",
        "mutated": [
            "def GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n    PkgSet = set()\n    if Platform.Packages:\n        PkgSet.update(Platform.Packages)\n    for ModuleFile in Platform.Modules:\n        Data = BuildDatabase[ModuleFile, Arch, Target, Toolchain]\n        PkgSet.update(Data.Packages)\n        for Lib in GetLiabraryInstances(Data, Platform, BuildDatabase, Arch, Target, Toolchain):\n            PkgSet.update(Lib.Packages)\n    return list(PkgSet)",
            "def GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    PkgSet = set()\n    if Platform.Packages:\n        PkgSet.update(Platform.Packages)\n    for ModuleFile in Platform.Modules:\n        Data = BuildDatabase[ModuleFile, Arch, Target, Toolchain]\n        PkgSet.update(Data.Packages)\n        for Lib in GetLiabraryInstances(Data, Platform, BuildDatabase, Arch, Target, Toolchain):\n            PkgSet.update(Lib.Packages)\n    return list(PkgSet)",
            "def GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    PkgSet = set()\n    if Platform.Packages:\n        PkgSet.update(Platform.Packages)\n    for ModuleFile in Platform.Modules:\n        Data = BuildDatabase[ModuleFile, Arch, Target, Toolchain]\n        PkgSet.update(Data.Packages)\n        for Lib in GetLiabraryInstances(Data, Platform, BuildDatabase, Arch, Target, Toolchain):\n            PkgSet.update(Lib.Packages)\n    return list(PkgSet)",
            "def GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    PkgSet = set()\n    if Platform.Packages:\n        PkgSet.update(Platform.Packages)\n    for ModuleFile in Platform.Modules:\n        Data = BuildDatabase[ModuleFile, Arch, Target, Toolchain]\n        PkgSet.update(Data.Packages)\n        for Lib in GetLiabraryInstances(Data, Platform, BuildDatabase, Arch, Target, Toolchain):\n            PkgSet.update(Lib.Packages)\n    return list(PkgSet)",
            "def GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    PkgSet = set()\n    if Platform.Packages:\n        PkgSet.update(Platform.Packages)\n    for ModuleFile in Platform.Modules:\n        Data = BuildDatabase[ModuleFile, Arch, Target, Toolchain]\n        PkgSet.update(Data.Packages)\n        for Lib in GetLiabraryInstances(Data, Platform, BuildDatabase, Arch, Target, Toolchain):\n            PkgSet.update(Lib.Packages)\n    return list(PkgSet)"
        ]
    },
    {
        "func_name": "GetDeclaredPcd",
        "original": "def GetDeclaredPcd(Platform, BuildDatabase, Arch, Target, Toolchain, additionalPkgs):\n    PkgList = GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain)\n    PkgList = set(PkgList)\n    PkgList |= additionalPkgs\n    DecPcds = {}\n    GuidDict = {}\n    for Pkg in PkgList:\n        Guids = Pkg.Guids\n        GuidDict.update(Guids)\n        for Pcd in Pkg.Pcds:\n            PcdCName = Pcd[0]\n            PcdTokenName = Pcd[1]\n            if GlobalData.MixedPcd:\n                for PcdItem in GlobalData.MixedPcd:\n                    if (PcdCName, PcdTokenName) in GlobalData.MixedPcd[PcdItem]:\n                        PcdCName = PcdItem[0]\n                        break\n            if (PcdCName, PcdTokenName) not in DecPcds:\n                DecPcds[PcdCName, PcdTokenName] = Pkg.Pcds[Pcd]\n    return (DecPcds, GuidDict)",
        "mutated": [
            "def GetDeclaredPcd(Platform, BuildDatabase, Arch, Target, Toolchain, additionalPkgs):\n    if False:\n        i = 10\n    PkgList = GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain)\n    PkgList = set(PkgList)\n    PkgList |= additionalPkgs\n    DecPcds = {}\n    GuidDict = {}\n    for Pkg in PkgList:\n        Guids = Pkg.Guids\n        GuidDict.update(Guids)\n        for Pcd in Pkg.Pcds:\n            PcdCName = Pcd[0]\n            PcdTokenName = Pcd[1]\n            if GlobalData.MixedPcd:\n                for PcdItem in GlobalData.MixedPcd:\n                    if (PcdCName, PcdTokenName) in GlobalData.MixedPcd[PcdItem]:\n                        PcdCName = PcdItem[0]\n                        break\n            if (PcdCName, PcdTokenName) not in DecPcds:\n                DecPcds[PcdCName, PcdTokenName] = Pkg.Pcds[Pcd]\n    return (DecPcds, GuidDict)",
            "def GetDeclaredPcd(Platform, BuildDatabase, Arch, Target, Toolchain, additionalPkgs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    PkgList = GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain)\n    PkgList = set(PkgList)\n    PkgList |= additionalPkgs\n    DecPcds = {}\n    GuidDict = {}\n    for Pkg in PkgList:\n        Guids = Pkg.Guids\n        GuidDict.update(Guids)\n        for Pcd in Pkg.Pcds:\n            PcdCName = Pcd[0]\n            PcdTokenName = Pcd[1]\n            if GlobalData.MixedPcd:\n                for PcdItem in GlobalData.MixedPcd:\n                    if (PcdCName, PcdTokenName) in GlobalData.MixedPcd[PcdItem]:\n                        PcdCName = PcdItem[0]\n                        break\n            if (PcdCName, PcdTokenName) not in DecPcds:\n                DecPcds[PcdCName, PcdTokenName] = Pkg.Pcds[Pcd]\n    return (DecPcds, GuidDict)",
            "def GetDeclaredPcd(Platform, BuildDatabase, Arch, Target, Toolchain, additionalPkgs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    PkgList = GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain)\n    PkgList = set(PkgList)\n    PkgList |= additionalPkgs\n    DecPcds = {}\n    GuidDict = {}\n    for Pkg in PkgList:\n        Guids = Pkg.Guids\n        GuidDict.update(Guids)\n        for Pcd in Pkg.Pcds:\n            PcdCName = Pcd[0]\n            PcdTokenName = Pcd[1]\n            if GlobalData.MixedPcd:\n                for PcdItem in GlobalData.MixedPcd:\n                    if (PcdCName, PcdTokenName) in GlobalData.MixedPcd[PcdItem]:\n                        PcdCName = PcdItem[0]\n                        break\n            if (PcdCName, PcdTokenName) not in DecPcds:\n                DecPcds[PcdCName, PcdTokenName] = Pkg.Pcds[Pcd]\n    return (DecPcds, GuidDict)",
            "def GetDeclaredPcd(Platform, BuildDatabase, Arch, Target, Toolchain, additionalPkgs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    PkgList = GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain)\n    PkgList = set(PkgList)\n    PkgList |= additionalPkgs\n    DecPcds = {}\n    GuidDict = {}\n    for Pkg in PkgList:\n        Guids = Pkg.Guids\n        GuidDict.update(Guids)\n        for Pcd in Pkg.Pcds:\n            PcdCName = Pcd[0]\n            PcdTokenName = Pcd[1]\n            if GlobalData.MixedPcd:\n                for PcdItem in GlobalData.MixedPcd:\n                    if (PcdCName, PcdTokenName) in GlobalData.MixedPcd[PcdItem]:\n                        PcdCName = PcdItem[0]\n                        break\n            if (PcdCName, PcdTokenName) not in DecPcds:\n                DecPcds[PcdCName, PcdTokenName] = Pkg.Pcds[Pcd]\n    return (DecPcds, GuidDict)",
            "def GetDeclaredPcd(Platform, BuildDatabase, Arch, Target, Toolchain, additionalPkgs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    PkgList = GetPackageList(Platform, BuildDatabase, Arch, Target, Toolchain)\n    PkgList = set(PkgList)\n    PkgList |= additionalPkgs\n    DecPcds = {}\n    GuidDict = {}\n    for Pkg in PkgList:\n        Guids = Pkg.Guids\n        GuidDict.update(Guids)\n        for Pcd in Pkg.Pcds:\n            PcdCName = Pcd[0]\n            PcdTokenName = Pcd[1]\n            if GlobalData.MixedPcd:\n                for PcdItem in GlobalData.MixedPcd:\n                    if (PcdCName, PcdTokenName) in GlobalData.MixedPcd[PcdItem]:\n                        PcdCName = PcdItem[0]\n                        break\n            if (PcdCName, PcdTokenName) not in DecPcds:\n                DecPcds[PcdCName, PcdTokenName] = Pkg.Pcds[Pcd]\n    return (DecPcds, GuidDict)"
        ]
    },
    {
        "func_name": "GetLiabraryInstances",
        "original": "def GetLiabraryInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain):\n    return GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, Platform.MetaFile, EdkLogger)",
        "mutated": [
            "def GetLiabraryInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n    return GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, Platform.MetaFile, EdkLogger)",
            "def GetLiabraryInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, Platform.MetaFile, EdkLogger)",
            "def GetLiabraryInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, Platform.MetaFile, EdkLogger)",
            "def GetLiabraryInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, Platform.MetaFile, EdkLogger)",
            "def GetLiabraryInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, Platform.MetaFile, EdkLogger)"
        ]
    },
    {
        "func_name": "GetModuleLibInstances",
        "original": "def GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, FileName='', EdkLogger=None):\n    if Module.LibInstances:\n        return Module.LibInstances\n    ModuleType = Module.ModuleType\n    if Module.ModuleType != SUP_MODULE_USER_DEFINED:\n        for LibraryClass in Platform.LibraryClasses.GetKeys():\n            if LibraryClass.startswith('NULL') and Platform.LibraryClasses[LibraryClass, Module.ModuleType]:\n                Module.LibraryClasses[LibraryClass] = Platform.LibraryClasses[LibraryClass, Module.ModuleType]\n    for LibraryClass in Platform.Modules[str(Module)].LibraryClasses:\n        if LibraryClass.startswith('NULL'):\n            Module.LibraryClasses[LibraryClass] = Platform.Modules[str(Module)].LibraryClasses[LibraryClass]\n    LibraryConsumerList = [Module]\n    Constructor = []\n    ConsumedByList = OrderedListDict()\n    LibraryInstance = OrderedDict()\n    if not Module.LibraryClass:\n        EdkLogger.verbose('')\n        EdkLogger.verbose('Library instances of module [%s] [%s]:' % (str(Module), Arch))\n    while len(LibraryConsumerList) > 0:\n        M = LibraryConsumerList.pop()\n        for LibraryClassName in M.LibraryClasses:\n            if LibraryClassName not in LibraryInstance:\n                LibraryPath = Platform.Modules[str(Module)].LibraryClasses.get(LibraryClassName, Platform.LibraryClasses[LibraryClassName, ModuleType])\n                if LibraryPath is None:\n                    LibraryPath = M.LibraryClasses.get(LibraryClassName)\n                    if LibraryPath is None:\n                        if not Module.LibraryClass:\n                            EdkLogger.error('build', RESOURCE_NOT_AVAILABLE, 'Instance of library class [%s] is not found' % LibraryClassName, File=FileName, ExtraData='in [%s] [%s]\\n\\tconsumed by module [%s]' % (str(M), Arch, str(Module)))\n                        else:\n                            return []\n                LibraryModule = BuildDatabase[LibraryPath, Arch, Target, Toolchain]\n                if LibraryClassName.startswith('NULL'):\n                    LibraryModule.LibraryClass.append(LibraryClassObject(LibraryClassName, [ModuleType]))\n                elif LibraryModule.LibraryClass is None or len(LibraryModule.LibraryClass) == 0 or (ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION and (ModuleType not in LibraryModule.LibraryClass[0].SupModList)):\n                    if not Module.LibraryClass:\n                        EdkLogger.error('build', OPTION_MISSING, 'Module type [%s] is not supported by library instance [%s]' % (ModuleType, LibraryPath), File=FileName, ExtraData='consumed by library instance [%s] which is consumed by module [%s]' % (str(M), str(Module)))\n                    else:\n                        return []\n                LibraryInstance[LibraryClassName] = LibraryModule\n                LibraryConsumerList.append(LibraryModule)\n                if not Module.LibraryClass:\n                    EdkLogger.verbose('\\t' + str(LibraryClassName) + ' : ' + str(LibraryModule))\n            else:\n                LibraryModule = LibraryInstance[LibraryClassName]\n            if LibraryModule is None:\n                continue\n            if LibraryModule.ConstructorList != [] and LibraryModule not in Constructor:\n                Constructor.append(LibraryModule)\n            if M != Module:\n                if M in ConsumedByList[LibraryModule]:\n                    continue\n                ConsumedByList[LibraryModule].append(M)\n    SortedLibraryList = []\n    LibraryList = []\n    Q = []\n    for LibraryClassName in LibraryInstance:\n        M = LibraryInstance[LibraryClassName]\n        LibraryList.append(M)\n        if not ConsumedByList[M]:\n            Q.append(M)\n    while True:\n        EdgeRemoved = True\n        while Q == [] and EdgeRemoved:\n            EdgeRemoved = False\n            for Item in LibraryList:\n                if Item not in Constructor:\n                    continue\n                for Node in ConsumedByList[Item]:\n                    if Node in Constructor:\n                        continue\n                    ConsumedByList[Item].remove(Node)\n                    EdgeRemoved = True\n                    if not ConsumedByList[Item]:\n                        Q.insert(0, Item)\n                        break\n                if Q != []:\n                    break\n        if Q == []:\n            break\n        Node = Q.pop()\n        SortedLibraryList.append(Node)\n        for Item in LibraryList:\n            if Node not in ConsumedByList[Item]:\n                continue\n            ConsumedByList[Item].remove(Node)\n            if ConsumedByList[Item]:\n                continue\n            Q.insert(0, Item)\n    for Item in LibraryList:\n        if ConsumedByList[Item] and Item in Constructor and (len(Constructor) > 1):\n            if not Module.LibraryClass:\n                ErrorMessage = '\\tconsumed by ' + '\\n\\tconsumed by '.join((str(L) for L in ConsumedByList[Item]))\n                EdkLogger.error('build', BUILD_ERROR, 'Library [%s] with constructors has a cycle' % str(Item), ExtraData=ErrorMessage, File=FileName)\n            else:\n                return []\n        if Item not in SortedLibraryList:\n            SortedLibraryList.append(Item)\n    SortedLibraryList.reverse()\n    Module.LibInstances = SortedLibraryList\n    SortedLibraryList = [lib.SetReferenceModule(Module) for lib in SortedLibraryList]\n    return SortedLibraryList",
        "mutated": [
            "def GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, FileName='', EdkLogger=None):\n    if False:\n        i = 10\n    if Module.LibInstances:\n        return Module.LibInstances\n    ModuleType = Module.ModuleType\n    if Module.ModuleType != SUP_MODULE_USER_DEFINED:\n        for LibraryClass in Platform.LibraryClasses.GetKeys():\n            if LibraryClass.startswith('NULL') and Platform.LibraryClasses[LibraryClass, Module.ModuleType]:\n                Module.LibraryClasses[LibraryClass] = Platform.LibraryClasses[LibraryClass, Module.ModuleType]\n    for LibraryClass in Platform.Modules[str(Module)].LibraryClasses:\n        if LibraryClass.startswith('NULL'):\n            Module.LibraryClasses[LibraryClass] = Platform.Modules[str(Module)].LibraryClasses[LibraryClass]\n    LibraryConsumerList = [Module]\n    Constructor = []\n    ConsumedByList = OrderedListDict()\n    LibraryInstance = OrderedDict()\n    if not Module.LibraryClass:\n        EdkLogger.verbose('')\n        EdkLogger.verbose('Library instances of module [%s] [%s]:' % (str(Module), Arch))\n    while len(LibraryConsumerList) > 0:\n        M = LibraryConsumerList.pop()\n        for LibraryClassName in M.LibraryClasses:\n            if LibraryClassName not in LibraryInstance:\n                LibraryPath = Platform.Modules[str(Module)].LibraryClasses.get(LibraryClassName, Platform.LibraryClasses[LibraryClassName, ModuleType])\n                if LibraryPath is None:\n                    LibraryPath = M.LibraryClasses.get(LibraryClassName)\n                    if LibraryPath is None:\n                        if not Module.LibraryClass:\n                            EdkLogger.error('build', RESOURCE_NOT_AVAILABLE, 'Instance of library class [%s] is not found' % LibraryClassName, File=FileName, ExtraData='in [%s] [%s]\\n\\tconsumed by module [%s]' % (str(M), Arch, str(Module)))\n                        else:\n                            return []\n                LibraryModule = BuildDatabase[LibraryPath, Arch, Target, Toolchain]\n                if LibraryClassName.startswith('NULL'):\n                    LibraryModule.LibraryClass.append(LibraryClassObject(LibraryClassName, [ModuleType]))\n                elif LibraryModule.LibraryClass is None or len(LibraryModule.LibraryClass) == 0 or (ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION and (ModuleType not in LibraryModule.LibraryClass[0].SupModList)):\n                    if not Module.LibraryClass:\n                        EdkLogger.error('build', OPTION_MISSING, 'Module type [%s] is not supported by library instance [%s]' % (ModuleType, LibraryPath), File=FileName, ExtraData='consumed by library instance [%s] which is consumed by module [%s]' % (str(M), str(Module)))\n                    else:\n                        return []\n                LibraryInstance[LibraryClassName] = LibraryModule\n                LibraryConsumerList.append(LibraryModule)\n                if not Module.LibraryClass:\n                    EdkLogger.verbose('\\t' + str(LibraryClassName) + ' : ' + str(LibraryModule))\n            else:\n                LibraryModule = LibraryInstance[LibraryClassName]\n            if LibraryModule is None:\n                continue\n            if LibraryModule.ConstructorList != [] and LibraryModule not in Constructor:\n                Constructor.append(LibraryModule)\n            if M != Module:\n                if M in ConsumedByList[LibraryModule]:\n                    continue\n                ConsumedByList[LibraryModule].append(M)\n    SortedLibraryList = []\n    LibraryList = []\n    Q = []\n    for LibraryClassName in LibraryInstance:\n        M = LibraryInstance[LibraryClassName]\n        LibraryList.append(M)\n        if not ConsumedByList[M]:\n            Q.append(M)\n    while True:\n        EdgeRemoved = True\n        while Q == [] and EdgeRemoved:\n            EdgeRemoved = False\n            for Item in LibraryList:\n                if Item not in Constructor:\n                    continue\n                for Node in ConsumedByList[Item]:\n                    if Node in Constructor:\n                        continue\n                    ConsumedByList[Item].remove(Node)\n                    EdgeRemoved = True\n                    if not ConsumedByList[Item]:\n                        Q.insert(0, Item)\n                        break\n                if Q != []:\n                    break\n        if Q == []:\n            break\n        Node = Q.pop()\n        SortedLibraryList.append(Node)\n        for Item in LibraryList:\n            if Node not in ConsumedByList[Item]:\n                continue\n            ConsumedByList[Item].remove(Node)\n            if ConsumedByList[Item]:\n                continue\n            Q.insert(0, Item)\n    for Item in LibraryList:\n        if ConsumedByList[Item] and Item in Constructor and (len(Constructor) > 1):\n            if not Module.LibraryClass:\n                ErrorMessage = '\\tconsumed by ' + '\\n\\tconsumed by '.join((str(L) for L in ConsumedByList[Item]))\n                EdkLogger.error('build', BUILD_ERROR, 'Library [%s] with constructors has a cycle' % str(Item), ExtraData=ErrorMessage, File=FileName)\n            else:\n                return []\n        if Item not in SortedLibraryList:\n            SortedLibraryList.append(Item)\n    SortedLibraryList.reverse()\n    Module.LibInstances = SortedLibraryList\n    SortedLibraryList = [lib.SetReferenceModule(Module) for lib in SortedLibraryList]\n    return SortedLibraryList",
            "def GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, FileName='', EdkLogger=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Module.LibInstances:\n        return Module.LibInstances\n    ModuleType = Module.ModuleType\n    if Module.ModuleType != SUP_MODULE_USER_DEFINED:\n        for LibraryClass in Platform.LibraryClasses.GetKeys():\n            if LibraryClass.startswith('NULL') and Platform.LibraryClasses[LibraryClass, Module.ModuleType]:\n                Module.LibraryClasses[LibraryClass] = Platform.LibraryClasses[LibraryClass, Module.ModuleType]\n    for LibraryClass in Platform.Modules[str(Module)].LibraryClasses:\n        if LibraryClass.startswith('NULL'):\n            Module.LibraryClasses[LibraryClass] = Platform.Modules[str(Module)].LibraryClasses[LibraryClass]\n    LibraryConsumerList = [Module]\n    Constructor = []\n    ConsumedByList = OrderedListDict()\n    LibraryInstance = OrderedDict()\n    if not Module.LibraryClass:\n        EdkLogger.verbose('')\n        EdkLogger.verbose('Library instances of module [%s] [%s]:' % (str(Module), Arch))\n    while len(LibraryConsumerList) > 0:\n        M = LibraryConsumerList.pop()\n        for LibraryClassName in M.LibraryClasses:\n            if LibraryClassName not in LibraryInstance:\n                LibraryPath = Platform.Modules[str(Module)].LibraryClasses.get(LibraryClassName, Platform.LibraryClasses[LibraryClassName, ModuleType])\n                if LibraryPath is None:\n                    LibraryPath = M.LibraryClasses.get(LibraryClassName)\n                    if LibraryPath is None:\n                        if not Module.LibraryClass:\n                            EdkLogger.error('build', RESOURCE_NOT_AVAILABLE, 'Instance of library class [%s] is not found' % LibraryClassName, File=FileName, ExtraData='in [%s] [%s]\\n\\tconsumed by module [%s]' % (str(M), Arch, str(Module)))\n                        else:\n                            return []\n                LibraryModule = BuildDatabase[LibraryPath, Arch, Target, Toolchain]\n                if LibraryClassName.startswith('NULL'):\n                    LibraryModule.LibraryClass.append(LibraryClassObject(LibraryClassName, [ModuleType]))\n                elif LibraryModule.LibraryClass is None or len(LibraryModule.LibraryClass) == 0 or (ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION and (ModuleType not in LibraryModule.LibraryClass[0].SupModList)):\n                    if not Module.LibraryClass:\n                        EdkLogger.error('build', OPTION_MISSING, 'Module type [%s] is not supported by library instance [%s]' % (ModuleType, LibraryPath), File=FileName, ExtraData='consumed by library instance [%s] which is consumed by module [%s]' % (str(M), str(Module)))\n                    else:\n                        return []\n                LibraryInstance[LibraryClassName] = LibraryModule\n                LibraryConsumerList.append(LibraryModule)\n                if not Module.LibraryClass:\n                    EdkLogger.verbose('\\t' + str(LibraryClassName) + ' : ' + str(LibraryModule))\n            else:\n                LibraryModule = LibraryInstance[LibraryClassName]\n            if LibraryModule is None:\n                continue\n            if LibraryModule.ConstructorList != [] and LibraryModule not in Constructor:\n                Constructor.append(LibraryModule)\n            if M != Module:\n                if M in ConsumedByList[LibraryModule]:\n                    continue\n                ConsumedByList[LibraryModule].append(M)\n    SortedLibraryList = []\n    LibraryList = []\n    Q = []\n    for LibraryClassName in LibraryInstance:\n        M = LibraryInstance[LibraryClassName]\n        LibraryList.append(M)\n        if not ConsumedByList[M]:\n            Q.append(M)\n    while True:\n        EdgeRemoved = True\n        while Q == [] and EdgeRemoved:\n            EdgeRemoved = False\n            for Item in LibraryList:\n                if Item not in Constructor:\n                    continue\n                for Node in ConsumedByList[Item]:\n                    if Node in Constructor:\n                        continue\n                    ConsumedByList[Item].remove(Node)\n                    EdgeRemoved = True\n                    if not ConsumedByList[Item]:\n                        Q.insert(0, Item)\n                        break\n                if Q != []:\n                    break\n        if Q == []:\n            break\n        Node = Q.pop()\n        SortedLibraryList.append(Node)\n        for Item in LibraryList:\n            if Node not in ConsumedByList[Item]:\n                continue\n            ConsumedByList[Item].remove(Node)\n            if ConsumedByList[Item]:\n                continue\n            Q.insert(0, Item)\n    for Item in LibraryList:\n        if ConsumedByList[Item] and Item in Constructor and (len(Constructor) > 1):\n            if not Module.LibraryClass:\n                ErrorMessage = '\\tconsumed by ' + '\\n\\tconsumed by '.join((str(L) for L in ConsumedByList[Item]))\n                EdkLogger.error('build', BUILD_ERROR, 'Library [%s] with constructors has a cycle' % str(Item), ExtraData=ErrorMessage, File=FileName)\n            else:\n                return []\n        if Item not in SortedLibraryList:\n            SortedLibraryList.append(Item)\n    SortedLibraryList.reverse()\n    Module.LibInstances = SortedLibraryList\n    SortedLibraryList = [lib.SetReferenceModule(Module) for lib in SortedLibraryList]\n    return SortedLibraryList",
            "def GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, FileName='', EdkLogger=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Module.LibInstances:\n        return Module.LibInstances\n    ModuleType = Module.ModuleType\n    if Module.ModuleType != SUP_MODULE_USER_DEFINED:\n        for LibraryClass in Platform.LibraryClasses.GetKeys():\n            if LibraryClass.startswith('NULL') and Platform.LibraryClasses[LibraryClass, Module.ModuleType]:\n                Module.LibraryClasses[LibraryClass] = Platform.LibraryClasses[LibraryClass, Module.ModuleType]\n    for LibraryClass in Platform.Modules[str(Module)].LibraryClasses:\n        if LibraryClass.startswith('NULL'):\n            Module.LibraryClasses[LibraryClass] = Platform.Modules[str(Module)].LibraryClasses[LibraryClass]\n    LibraryConsumerList = [Module]\n    Constructor = []\n    ConsumedByList = OrderedListDict()\n    LibraryInstance = OrderedDict()\n    if not Module.LibraryClass:\n        EdkLogger.verbose('')\n        EdkLogger.verbose('Library instances of module [%s] [%s]:' % (str(Module), Arch))\n    while len(LibraryConsumerList) > 0:\n        M = LibraryConsumerList.pop()\n        for LibraryClassName in M.LibraryClasses:\n            if LibraryClassName not in LibraryInstance:\n                LibraryPath = Platform.Modules[str(Module)].LibraryClasses.get(LibraryClassName, Platform.LibraryClasses[LibraryClassName, ModuleType])\n                if LibraryPath is None:\n                    LibraryPath = M.LibraryClasses.get(LibraryClassName)\n                    if LibraryPath is None:\n                        if not Module.LibraryClass:\n                            EdkLogger.error('build', RESOURCE_NOT_AVAILABLE, 'Instance of library class [%s] is not found' % LibraryClassName, File=FileName, ExtraData='in [%s] [%s]\\n\\tconsumed by module [%s]' % (str(M), Arch, str(Module)))\n                        else:\n                            return []\n                LibraryModule = BuildDatabase[LibraryPath, Arch, Target, Toolchain]\n                if LibraryClassName.startswith('NULL'):\n                    LibraryModule.LibraryClass.append(LibraryClassObject(LibraryClassName, [ModuleType]))\n                elif LibraryModule.LibraryClass is None or len(LibraryModule.LibraryClass) == 0 or (ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION and (ModuleType not in LibraryModule.LibraryClass[0].SupModList)):\n                    if not Module.LibraryClass:\n                        EdkLogger.error('build', OPTION_MISSING, 'Module type [%s] is not supported by library instance [%s]' % (ModuleType, LibraryPath), File=FileName, ExtraData='consumed by library instance [%s] which is consumed by module [%s]' % (str(M), str(Module)))\n                    else:\n                        return []\n                LibraryInstance[LibraryClassName] = LibraryModule\n                LibraryConsumerList.append(LibraryModule)\n                if not Module.LibraryClass:\n                    EdkLogger.verbose('\\t' + str(LibraryClassName) + ' : ' + str(LibraryModule))\n            else:\n                LibraryModule = LibraryInstance[LibraryClassName]\n            if LibraryModule is None:\n                continue\n            if LibraryModule.ConstructorList != [] and LibraryModule not in Constructor:\n                Constructor.append(LibraryModule)\n            if M != Module:\n                if M in ConsumedByList[LibraryModule]:\n                    continue\n                ConsumedByList[LibraryModule].append(M)\n    SortedLibraryList = []\n    LibraryList = []\n    Q = []\n    for LibraryClassName in LibraryInstance:\n        M = LibraryInstance[LibraryClassName]\n        LibraryList.append(M)\n        if not ConsumedByList[M]:\n            Q.append(M)\n    while True:\n        EdgeRemoved = True\n        while Q == [] and EdgeRemoved:\n            EdgeRemoved = False\n            for Item in LibraryList:\n                if Item not in Constructor:\n                    continue\n                for Node in ConsumedByList[Item]:\n                    if Node in Constructor:\n                        continue\n                    ConsumedByList[Item].remove(Node)\n                    EdgeRemoved = True\n                    if not ConsumedByList[Item]:\n                        Q.insert(0, Item)\n                        break\n                if Q != []:\n                    break\n        if Q == []:\n            break\n        Node = Q.pop()\n        SortedLibraryList.append(Node)\n        for Item in LibraryList:\n            if Node not in ConsumedByList[Item]:\n                continue\n            ConsumedByList[Item].remove(Node)\n            if ConsumedByList[Item]:\n                continue\n            Q.insert(0, Item)\n    for Item in LibraryList:\n        if ConsumedByList[Item] and Item in Constructor and (len(Constructor) > 1):\n            if not Module.LibraryClass:\n                ErrorMessage = '\\tconsumed by ' + '\\n\\tconsumed by '.join((str(L) for L in ConsumedByList[Item]))\n                EdkLogger.error('build', BUILD_ERROR, 'Library [%s] with constructors has a cycle' % str(Item), ExtraData=ErrorMessage, File=FileName)\n            else:\n                return []\n        if Item not in SortedLibraryList:\n            SortedLibraryList.append(Item)\n    SortedLibraryList.reverse()\n    Module.LibInstances = SortedLibraryList\n    SortedLibraryList = [lib.SetReferenceModule(Module) for lib in SortedLibraryList]\n    return SortedLibraryList",
            "def GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, FileName='', EdkLogger=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Module.LibInstances:\n        return Module.LibInstances\n    ModuleType = Module.ModuleType\n    if Module.ModuleType != SUP_MODULE_USER_DEFINED:\n        for LibraryClass in Platform.LibraryClasses.GetKeys():\n            if LibraryClass.startswith('NULL') and Platform.LibraryClasses[LibraryClass, Module.ModuleType]:\n                Module.LibraryClasses[LibraryClass] = Platform.LibraryClasses[LibraryClass, Module.ModuleType]\n    for LibraryClass in Platform.Modules[str(Module)].LibraryClasses:\n        if LibraryClass.startswith('NULL'):\n            Module.LibraryClasses[LibraryClass] = Platform.Modules[str(Module)].LibraryClasses[LibraryClass]\n    LibraryConsumerList = [Module]\n    Constructor = []\n    ConsumedByList = OrderedListDict()\n    LibraryInstance = OrderedDict()\n    if not Module.LibraryClass:\n        EdkLogger.verbose('')\n        EdkLogger.verbose('Library instances of module [%s] [%s]:' % (str(Module), Arch))\n    while len(LibraryConsumerList) > 0:\n        M = LibraryConsumerList.pop()\n        for LibraryClassName in M.LibraryClasses:\n            if LibraryClassName not in LibraryInstance:\n                LibraryPath = Platform.Modules[str(Module)].LibraryClasses.get(LibraryClassName, Platform.LibraryClasses[LibraryClassName, ModuleType])\n                if LibraryPath is None:\n                    LibraryPath = M.LibraryClasses.get(LibraryClassName)\n                    if LibraryPath is None:\n                        if not Module.LibraryClass:\n                            EdkLogger.error('build', RESOURCE_NOT_AVAILABLE, 'Instance of library class [%s] is not found' % LibraryClassName, File=FileName, ExtraData='in [%s] [%s]\\n\\tconsumed by module [%s]' % (str(M), Arch, str(Module)))\n                        else:\n                            return []\n                LibraryModule = BuildDatabase[LibraryPath, Arch, Target, Toolchain]\n                if LibraryClassName.startswith('NULL'):\n                    LibraryModule.LibraryClass.append(LibraryClassObject(LibraryClassName, [ModuleType]))\n                elif LibraryModule.LibraryClass is None or len(LibraryModule.LibraryClass) == 0 or (ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION and (ModuleType not in LibraryModule.LibraryClass[0].SupModList)):\n                    if not Module.LibraryClass:\n                        EdkLogger.error('build', OPTION_MISSING, 'Module type [%s] is not supported by library instance [%s]' % (ModuleType, LibraryPath), File=FileName, ExtraData='consumed by library instance [%s] which is consumed by module [%s]' % (str(M), str(Module)))\n                    else:\n                        return []\n                LibraryInstance[LibraryClassName] = LibraryModule\n                LibraryConsumerList.append(LibraryModule)\n                if not Module.LibraryClass:\n                    EdkLogger.verbose('\\t' + str(LibraryClassName) + ' : ' + str(LibraryModule))\n            else:\n                LibraryModule = LibraryInstance[LibraryClassName]\n            if LibraryModule is None:\n                continue\n            if LibraryModule.ConstructorList != [] and LibraryModule not in Constructor:\n                Constructor.append(LibraryModule)\n            if M != Module:\n                if M in ConsumedByList[LibraryModule]:\n                    continue\n                ConsumedByList[LibraryModule].append(M)\n    SortedLibraryList = []\n    LibraryList = []\n    Q = []\n    for LibraryClassName in LibraryInstance:\n        M = LibraryInstance[LibraryClassName]\n        LibraryList.append(M)\n        if not ConsumedByList[M]:\n            Q.append(M)\n    while True:\n        EdgeRemoved = True\n        while Q == [] and EdgeRemoved:\n            EdgeRemoved = False\n            for Item in LibraryList:\n                if Item not in Constructor:\n                    continue\n                for Node in ConsumedByList[Item]:\n                    if Node in Constructor:\n                        continue\n                    ConsumedByList[Item].remove(Node)\n                    EdgeRemoved = True\n                    if not ConsumedByList[Item]:\n                        Q.insert(0, Item)\n                        break\n                if Q != []:\n                    break\n        if Q == []:\n            break\n        Node = Q.pop()\n        SortedLibraryList.append(Node)\n        for Item in LibraryList:\n            if Node not in ConsumedByList[Item]:\n                continue\n            ConsumedByList[Item].remove(Node)\n            if ConsumedByList[Item]:\n                continue\n            Q.insert(0, Item)\n    for Item in LibraryList:\n        if ConsumedByList[Item] and Item in Constructor and (len(Constructor) > 1):\n            if not Module.LibraryClass:\n                ErrorMessage = '\\tconsumed by ' + '\\n\\tconsumed by '.join((str(L) for L in ConsumedByList[Item]))\n                EdkLogger.error('build', BUILD_ERROR, 'Library [%s] with constructors has a cycle' % str(Item), ExtraData=ErrorMessage, File=FileName)\n            else:\n                return []\n        if Item not in SortedLibraryList:\n            SortedLibraryList.append(Item)\n    SortedLibraryList.reverse()\n    Module.LibInstances = SortedLibraryList\n    SortedLibraryList = [lib.SetReferenceModule(Module) for lib in SortedLibraryList]\n    return SortedLibraryList",
            "def GetModuleLibInstances(Module, Platform, BuildDatabase, Arch, Target, Toolchain, FileName='', EdkLogger=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Module.LibInstances:\n        return Module.LibInstances\n    ModuleType = Module.ModuleType\n    if Module.ModuleType != SUP_MODULE_USER_DEFINED:\n        for LibraryClass in Platform.LibraryClasses.GetKeys():\n            if LibraryClass.startswith('NULL') and Platform.LibraryClasses[LibraryClass, Module.ModuleType]:\n                Module.LibraryClasses[LibraryClass] = Platform.LibraryClasses[LibraryClass, Module.ModuleType]\n    for LibraryClass in Platform.Modules[str(Module)].LibraryClasses:\n        if LibraryClass.startswith('NULL'):\n            Module.LibraryClasses[LibraryClass] = Platform.Modules[str(Module)].LibraryClasses[LibraryClass]\n    LibraryConsumerList = [Module]\n    Constructor = []\n    ConsumedByList = OrderedListDict()\n    LibraryInstance = OrderedDict()\n    if not Module.LibraryClass:\n        EdkLogger.verbose('')\n        EdkLogger.verbose('Library instances of module [%s] [%s]:' % (str(Module), Arch))\n    while len(LibraryConsumerList) > 0:\n        M = LibraryConsumerList.pop()\n        for LibraryClassName in M.LibraryClasses:\n            if LibraryClassName not in LibraryInstance:\n                LibraryPath = Platform.Modules[str(Module)].LibraryClasses.get(LibraryClassName, Platform.LibraryClasses[LibraryClassName, ModuleType])\n                if LibraryPath is None:\n                    LibraryPath = M.LibraryClasses.get(LibraryClassName)\n                    if LibraryPath is None:\n                        if not Module.LibraryClass:\n                            EdkLogger.error('build', RESOURCE_NOT_AVAILABLE, 'Instance of library class [%s] is not found' % LibraryClassName, File=FileName, ExtraData='in [%s] [%s]\\n\\tconsumed by module [%s]' % (str(M), Arch, str(Module)))\n                        else:\n                            return []\n                LibraryModule = BuildDatabase[LibraryPath, Arch, Target, Toolchain]\n                if LibraryClassName.startswith('NULL'):\n                    LibraryModule.LibraryClass.append(LibraryClassObject(LibraryClassName, [ModuleType]))\n                elif LibraryModule.LibraryClass is None or len(LibraryModule.LibraryClass) == 0 or (ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION and (ModuleType not in LibraryModule.LibraryClass[0].SupModList)):\n                    if not Module.LibraryClass:\n                        EdkLogger.error('build', OPTION_MISSING, 'Module type [%s] is not supported by library instance [%s]' % (ModuleType, LibraryPath), File=FileName, ExtraData='consumed by library instance [%s] which is consumed by module [%s]' % (str(M), str(Module)))\n                    else:\n                        return []\n                LibraryInstance[LibraryClassName] = LibraryModule\n                LibraryConsumerList.append(LibraryModule)\n                if not Module.LibraryClass:\n                    EdkLogger.verbose('\\t' + str(LibraryClassName) + ' : ' + str(LibraryModule))\n            else:\n                LibraryModule = LibraryInstance[LibraryClassName]\n            if LibraryModule is None:\n                continue\n            if LibraryModule.ConstructorList != [] and LibraryModule not in Constructor:\n                Constructor.append(LibraryModule)\n            if M != Module:\n                if M in ConsumedByList[LibraryModule]:\n                    continue\n                ConsumedByList[LibraryModule].append(M)\n    SortedLibraryList = []\n    LibraryList = []\n    Q = []\n    for LibraryClassName in LibraryInstance:\n        M = LibraryInstance[LibraryClassName]\n        LibraryList.append(M)\n        if not ConsumedByList[M]:\n            Q.append(M)\n    while True:\n        EdgeRemoved = True\n        while Q == [] and EdgeRemoved:\n            EdgeRemoved = False\n            for Item in LibraryList:\n                if Item not in Constructor:\n                    continue\n                for Node in ConsumedByList[Item]:\n                    if Node in Constructor:\n                        continue\n                    ConsumedByList[Item].remove(Node)\n                    EdgeRemoved = True\n                    if not ConsumedByList[Item]:\n                        Q.insert(0, Item)\n                        break\n                if Q != []:\n                    break\n        if Q == []:\n            break\n        Node = Q.pop()\n        SortedLibraryList.append(Node)\n        for Item in LibraryList:\n            if Node not in ConsumedByList[Item]:\n                continue\n            ConsumedByList[Item].remove(Node)\n            if ConsumedByList[Item]:\n                continue\n            Q.insert(0, Item)\n    for Item in LibraryList:\n        if ConsumedByList[Item] and Item in Constructor and (len(Constructor) > 1):\n            if not Module.LibraryClass:\n                ErrorMessage = '\\tconsumed by ' + '\\n\\tconsumed by '.join((str(L) for L in ConsumedByList[Item]))\n                EdkLogger.error('build', BUILD_ERROR, 'Library [%s] with constructors has a cycle' % str(Item), ExtraData=ErrorMessage, File=FileName)\n            else:\n                return []\n        if Item not in SortedLibraryList:\n            SortedLibraryList.append(Item)\n    SortedLibraryList.reverse()\n    Module.LibInstances = SortedLibraryList\n    SortedLibraryList = [lib.SetReferenceModule(Module) for lib in SortedLibraryList]\n    return SortedLibraryList"
        ]
    }
]