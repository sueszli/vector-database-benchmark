[
    {
        "func_name": "__init__",
        "original": "def __init__(self, settlement_date, maturity_date, coupon_spec, start_date=None, first_coupon_date=None, penultimate_coupon_date=None, holiday_calendar=None, dtype=None, name=None):\n    \"\"\"Initialize a batch of fixed coupon bonds.\n\n    Args:\n      settlement_date: A rank 1 `DateTensor` specifying the settlement date of\n        the bonds.\n      maturity_date: A rank 1 `DateTensor` specifying the maturity dates of the\n        bonds. The shape of the input should be the same as that of\n        `settlement_date`.\n      coupon_spec: A list of `FixedCouponSpecs` specifying the coupon payments.\n        The length of the list should be the same as the number of bonds\n        being created.\n      start_date: An optional `DateTensor` specifying the dates when the\n        interest starts to accrue for the coupons. The input can be used to\n        specify a forward start date for the coupons. The shape of the input\n        correspond to the numbercof instruments being created.\n        Default value: None in which case the coupons start to accrue from the\n        `settlement_date`.\n      first_coupon_date: An optional rank 1 `DateTensor` specifying the dates\n        when first coupon will be paid for bonds with irregular first coupon.\n      penultimate_coupon_date: An optional rank 1 `DateTensor` specifying the\n        dates when the penultimate coupon (or last regular coupon) will be paid\n        for bonds with irregular last coupon.\n      holiday_calendar: An instance of `dates.HolidayCalendar` to specify\n        weekends and holidays.\n        Default value: None in which case a holiday calendar would be created\n        with Saturday and Sunday being the holidays.\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\n        either supplied to the bond object or created by the bond object.\n        Default value: None which maps to the default dtype inferred by\n        TensorFlow.\n      name: Python str. The name to give to the ops created by this class.\n        Default value: `None` which maps to 'bond'.\n    \"\"\"\n    self._name = name or 'bond'\n    if holiday_calendar is None:\n        holiday_calendar = dates.create_holiday_calendar(weekend_mask=dates.WeekendMask.SATURDAY_SUNDAY)\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._maturity_date = dates.convert_to_date_tensor(maturity_date)\n        self._holiday_calendar = holiday_calendar\n        self._setup(coupon_spec, start_date, first_coupon_date, penultimate_coupon_date)",
        "mutated": [
            "def __init__(self, settlement_date, maturity_date, coupon_spec, start_date=None, first_coupon_date=None, penultimate_coupon_date=None, holiday_calendar=None, dtype=None, name=None):\n    if False:\n        i = 10\n    \"Initialize a batch of fixed coupon bonds.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the settlement date of\\n        the bonds.\\n      maturity_date: A rank 1 `DateTensor` specifying the maturity dates of the\\n        bonds. The shape of the input should be the same as that of\\n        `settlement_date`.\\n      coupon_spec: A list of `FixedCouponSpecs` specifying the coupon payments.\\n        The length of the list should be the same as the number of bonds\\n        being created.\\n      start_date: An optional `DateTensor` specifying the dates when the\\n        interest starts to accrue for the coupons. The input can be used to\\n        specify a forward start date for the coupons. The shape of the input\\n        correspond to the numbercof instruments being created.\\n        Default value: None in which case the coupons start to accrue from the\\n        `settlement_date`.\\n      first_coupon_date: An optional rank 1 `DateTensor` specifying the dates\\n        when first coupon will be paid for bonds with irregular first coupon.\\n      penultimate_coupon_date: An optional rank 1 `DateTensor` specifying the\\n        dates when the penultimate coupon (or last regular coupon) will be paid\\n        for bonds with irregular last coupon.\\n      holiday_calendar: An instance of `dates.HolidayCalendar` to specify\\n        weekends and holidays.\\n        Default value: None in which case a holiday calendar would be created\\n        with Saturday and Sunday being the holidays.\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the bond object or created by the bond object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'bond'.\\n    \"\n    self._name = name or 'bond'\n    if holiday_calendar is None:\n        holiday_calendar = dates.create_holiday_calendar(weekend_mask=dates.WeekendMask.SATURDAY_SUNDAY)\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._maturity_date = dates.convert_to_date_tensor(maturity_date)\n        self._holiday_calendar = holiday_calendar\n        self._setup(coupon_spec, start_date, first_coupon_date, penultimate_coupon_date)",
            "def __init__(self, settlement_date, maturity_date, coupon_spec, start_date=None, first_coupon_date=None, penultimate_coupon_date=None, holiday_calendar=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Initialize a batch of fixed coupon bonds.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the settlement date of\\n        the bonds.\\n      maturity_date: A rank 1 `DateTensor` specifying the maturity dates of the\\n        bonds. The shape of the input should be the same as that of\\n        `settlement_date`.\\n      coupon_spec: A list of `FixedCouponSpecs` specifying the coupon payments.\\n        The length of the list should be the same as the number of bonds\\n        being created.\\n      start_date: An optional `DateTensor` specifying the dates when the\\n        interest starts to accrue for the coupons. The input can be used to\\n        specify a forward start date for the coupons. The shape of the input\\n        correspond to the numbercof instruments being created.\\n        Default value: None in which case the coupons start to accrue from the\\n        `settlement_date`.\\n      first_coupon_date: An optional rank 1 `DateTensor` specifying the dates\\n        when first coupon will be paid for bonds with irregular first coupon.\\n      penultimate_coupon_date: An optional rank 1 `DateTensor` specifying the\\n        dates when the penultimate coupon (or last regular coupon) will be paid\\n        for bonds with irregular last coupon.\\n      holiday_calendar: An instance of `dates.HolidayCalendar` to specify\\n        weekends and holidays.\\n        Default value: None in which case a holiday calendar would be created\\n        with Saturday and Sunday being the holidays.\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the bond object or created by the bond object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'bond'.\\n    \"\n    self._name = name or 'bond'\n    if holiday_calendar is None:\n        holiday_calendar = dates.create_holiday_calendar(weekend_mask=dates.WeekendMask.SATURDAY_SUNDAY)\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._maturity_date = dates.convert_to_date_tensor(maturity_date)\n        self._holiday_calendar = holiday_calendar\n        self._setup(coupon_spec, start_date, first_coupon_date, penultimate_coupon_date)",
            "def __init__(self, settlement_date, maturity_date, coupon_spec, start_date=None, first_coupon_date=None, penultimate_coupon_date=None, holiday_calendar=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Initialize a batch of fixed coupon bonds.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the settlement date of\\n        the bonds.\\n      maturity_date: A rank 1 `DateTensor` specifying the maturity dates of the\\n        bonds. The shape of the input should be the same as that of\\n        `settlement_date`.\\n      coupon_spec: A list of `FixedCouponSpecs` specifying the coupon payments.\\n        The length of the list should be the same as the number of bonds\\n        being created.\\n      start_date: An optional `DateTensor` specifying the dates when the\\n        interest starts to accrue for the coupons. The input can be used to\\n        specify a forward start date for the coupons. The shape of the input\\n        correspond to the numbercof instruments being created.\\n        Default value: None in which case the coupons start to accrue from the\\n        `settlement_date`.\\n      first_coupon_date: An optional rank 1 `DateTensor` specifying the dates\\n        when first coupon will be paid for bonds with irregular first coupon.\\n      penultimate_coupon_date: An optional rank 1 `DateTensor` specifying the\\n        dates when the penultimate coupon (or last regular coupon) will be paid\\n        for bonds with irregular last coupon.\\n      holiday_calendar: An instance of `dates.HolidayCalendar` to specify\\n        weekends and holidays.\\n        Default value: None in which case a holiday calendar would be created\\n        with Saturday and Sunday being the holidays.\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the bond object or created by the bond object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'bond'.\\n    \"\n    self._name = name or 'bond'\n    if holiday_calendar is None:\n        holiday_calendar = dates.create_holiday_calendar(weekend_mask=dates.WeekendMask.SATURDAY_SUNDAY)\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._maturity_date = dates.convert_to_date_tensor(maturity_date)\n        self._holiday_calendar = holiday_calendar\n        self._setup(coupon_spec, start_date, first_coupon_date, penultimate_coupon_date)",
            "def __init__(self, settlement_date, maturity_date, coupon_spec, start_date=None, first_coupon_date=None, penultimate_coupon_date=None, holiday_calendar=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Initialize a batch of fixed coupon bonds.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the settlement date of\\n        the bonds.\\n      maturity_date: A rank 1 `DateTensor` specifying the maturity dates of the\\n        bonds. The shape of the input should be the same as that of\\n        `settlement_date`.\\n      coupon_spec: A list of `FixedCouponSpecs` specifying the coupon payments.\\n        The length of the list should be the same as the number of bonds\\n        being created.\\n      start_date: An optional `DateTensor` specifying the dates when the\\n        interest starts to accrue for the coupons. The input can be used to\\n        specify a forward start date for the coupons. The shape of the input\\n        correspond to the numbercof instruments being created.\\n        Default value: None in which case the coupons start to accrue from the\\n        `settlement_date`.\\n      first_coupon_date: An optional rank 1 `DateTensor` specifying the dates\\n        when first coupon will be paid for bonds with irregular first coupon.\\n      penultimate_coupon_date: An optional rank 1 `DateTensor` specifying the\\n        dates when the penultimate coupon (or last regular coupon) will be paid\\n        for bonds with irregular last coupon.\\n      holiday_calendar: An instance of `dates.HolidayCalendar` to specify\\n        weekends and holidays.\\n        Default value: None in which case a holiday calendar would be created\\n        with Saturday and Sunday being the holidays.\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the bond object or created by the bond object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'bond'.\\n    \"\n    self._name = name or 'bond'\n    if holiday_calendar is None:\n        holiday_calendar = dates.create_holiday_calendar(weekend_mask=dates.WeekendMask.SATURDAY_SUNDAY)\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._maturity_date = dates.convert_to_date_tensor(maturity_date)\n        self._holiday_calendar = holiday_calendar\n        self._setup(coupon_spec, start_date, first_coupon_date, penultimate_coupon_date)",
            "def __init__(self, settlement_date, maturity_date, coupon_spec, start_date=None, first_coupon_date=None, penultimate_coupon_date=None, holiday_calendar=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Initialize a batch of fixed coupon bonds.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the settlement date of\\n        the bonds.\\n      maturity_date: A rank 1 `DateTensor` specifying the maturity dates of the\\n        bonds. The shape of the input should be the same as that of\\n        `settlement_date`.\\n      coupon_spec: A list of `FixedCouponSpecs` specifying the coupon payments.\\n        The length of the list should be the same as the number of bonds\\n        being created.\\n      start_date: An optional `DateTensor` specifying the dates when the\\n        interest starts to accrue for the coupons. The input can be used to\\n        specify a forward start date for the coupons. The shape of the input\\n        correspond to the numbercof instruments being created.\\n        Default value: None in which case the coupons start to accrue from the\\n        `settlement_date`.\\n      first_coupon_date: An optional rank 1 `DateTensor` specifying the dates\\n        when first coupon will be paid for bonds with irregular first coupon.\\n      penultimate_coupon_date: An optional rank 1 `DateTensor` specifying the\\n        dates when the penultimate coupon (or last regular coupon) will be paid\\n        for bonds with irregular last coupon.\\n      holiday_calendar: An instance of `dates.HolidayCalendar` to specify\\n        weekends and holidays.\\n        Default value: None in which case a holiday calendar would be created\\n        with Saturday and Sunday being the holidays.\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the bond object or created by the bond object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'bond'.\\n    \"\n    self._name = name or 'bond'\n    if holiday_calendar is None:\n        holiday_calendar = dates.create_holiday_calendar(weekend_mask=dates.WeekendMask.SATURDAY_SUNDAY)\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._maturity_date = dates.convert_to_date_tensor(maturity_date)\n        self._holiday_calendar = holiday_calendar\n        self._setup(coupon_spec, start_date, first_coupon_date, penultimate_coupon_date)"
        ]
    },
    {
        "func_name": "price",
        "original": "def price(self, valuation_date, market, model=None, name=None):\n    \"\"\"Returns the dirty price of the bonds on the valuation date.\n\n    Args:\n      valuation_date: A scalar `DateTensor` specifying the date on which\n        valuation is being desired.\n      market: A namedtuple of type `InterestRateMarket` which contains the\n        necessary information for pricing the bonds.\n      model: Reserved for future use.\n      name: Python str. The name to give to the ops created by this function.\n        Default value: `None` which maps to 'price'.\n\n    Returns:\n      A Rank 1 `Tensor` of real dtype containing the dirty price of each bond\n      based on the input market data.\n    \"\"\"\n    name = name or self._name + '_price'\n    with tf.name_scope(name):\n        discount_curve = market.discount_curve\n        coupon_cf = self._cashflows.price(valuation_date, market, model)\n        principal_cf = self._notional * discount_curve.get_discount_factor(self._maturity_date)\n        return coupon_cf + principal_cf",
        "mutated": [
            "def price(self, valuation_date, market, model=None, name=None):\n    if False:\n        i = 10\n    \"Returns the dirty price of the bonds on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the bonds.\\n      model: Reserved for future use.\\n      name: Python str. The name to give to the ops created by this function.\\n        Default value: `None` which maps to 'price'.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real dtype containing the dirty price of each bond\\n      based on the input market data.\\n    \"\n    name = name or self._name + '_price'\n    with tf.name_scope(name):\n        discount_curve = market.discount_curve\n        coupon_cf = self._cashflows.price(valuation_date, market, model)\n        principal_cf = self._notional * discount_curve.get_discount_factor(self._maturity_date)\n        return coupon_cf + principal_cf",
            "def price(self, valuation_date, market, model=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Returns the dirty price of the bonds on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the bonds.\\n      model: Reserved for future use.\\n      name: Python str. The name to give to the ops created by this function.\\n        Default value: `None` which maps to 'price'.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real dtype containing the dirty price of each bond\\n      based on the input market data.\\n    \"\n    name = name or self._name + '_price'\n    with tf.name_scope(name):\n        discount_curve = market.discount_curve\n        coupon_cf = self._cashflows.price(valuation_date, market, model)\n        principal_cf = self._notional * discount_curve.get_discount_factor(self._maturity_date)\n        return coupon_cf + principal_cf",
            "def price(self, valuation_date, market, model=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Returns the dirty price of the bonds on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the bonds.\\n      model: Reserved for future use.\\n      name: Python str. The name to give to the ops created by this function.\\n        Default value: `None` which maps to 'price'.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real dtype containing the dirty price of each bond\\n      based on the input market data.\\n    \"\n    name = name or self._name + '_price'\n    with tf.name_scope(name):\n        discount_curve = market.discount_curve\n        coupon_cf = self._cashflows.price(valuation_date, market, model)\n        principal_cf = self._notional * discount_curve.get_discount_factor(self._maturity_date)\n        return coupon_cf + principal_cf",
            "def price(self, valuation_date, market, model=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Returns the dirty price of the bonds on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the bonds.\\n      model: Reserved for future use.\\n      name: Python str. The name to give to the ops created by this function.\\n        Default value: `None` which maps to 'price'.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real dtype containing the dirty price of each bond\\n      based on the input market data.\\n    \"\n    name = name or self._name + '_price'\n    with tf.name_scope(name):\n        discount_curve = market.discount_curve\n        coupon_cf = self._cashflows.price(valuation_date, market, model)\n        principal_cf = self._notional * discount_curve.get_discount_factor(self._maturity_date)\n        return coupon_cf + principal_cf",
            "def price(self, valuation_date, market, model=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Returns the dirty price of the bonds on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the bonds.\\n      model: Reserved for future use.\\n      name: Python str. The name to give to the ops created by this function.\\n        Default value: `None` which maps to 'price'.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real dtype containing the dirty price of each bond\\n      based on the input market data.\\n    \"\n    name = name or self._name + '_price'\n    with tf.name_scope(name):\n        discount_curve = market.discount_curve\n        coupon_cf = self._cashflows.price(valuation_date, market, model)\n        principal_cf = self._notional * discount_curve.get_discount_factor(self._maturity_date)\n        return coupon_cf + principal_cf"
        ]
    },
    {
        "func_name": "_setup",
        "original": "def _setup(self, coupon_spec, start_date, first_coupon_date, penultimate_coupon_date):\n    \"\"\"Setup bond cashflows.\"\"\"\n    if start_date is None:\n        self._cashflows = cs.FixedCashflowStream(self._settlement_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    else:\n        self._cashflows = cs.FixedCashflowStream(start_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    self._notional = tf.convert_to_tensor([x.notional for x in coupon_spec], dtype=self._dtype)",
        "mutated": [
            "def _setup(self, coupon_spec, start_date, first_coupon_date, penultimate_coupon_date):\n    if False:\n        i = 10\n    'Setup bond cashflows.'\n    if start_date is None:\n        self._cashflows = cs.FixedCashflowStream(self._settlement_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    else:\n        self._cashflows = cs.FixedCashflowStream(start_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    self._notional = tf.convert_to_tensor([x.notional for x in coupon_spec], dtype=self._dtype)",
            "def _setup(self, coupon_spec, start_date, first_coupon_date, penultimate_coupon_date):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Setup bond cashflows.'\n    if start_date is None:\n        self._cashflows = cs.FixedCashflowStream(self._settlement_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    else:\n        self._cashflows = cs.FixedCashflowStream(start_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    self._notional = tf.convert_to_tensor([x.notional for x in coupon_spec], dtype=self._dtype)",
            "def _setup(self, coupon_spec, start_date, first_coupon_date, penultimate_coupon_date):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Setup bond cashflows.'\n    if start_date is None:\n        self._cashflows = cs.FixedCashflowStream(self._settlement_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    else:\n        self._cashflows = cs.FixedCashflowStream(start_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    self._notional = tf.convert_to_tensor([x.notional for x in coupon_spec], dtype=self._dtype)",
            "def _setup(self, coupon_spec, start_date, first_coupon_date, penultimate_coupon_date):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Setup bond cashflows.'\n    if start_date is None:\n        self._cashflows = cs.FixedCashflowStream(self._settlement_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    else:\n        self._cashflows = cs.FixedCashflowStream(start_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    self._notional = tf.convert_to_tensor([x.notional for x in coupon_spec], dtype=self._dtype)",
            "def _setup(self, coupon_spec, start_date, first_coupon_date, penultimate_coupon_date):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Setup bond cashflows.'\n    if start_date is None:\n        self._cashflows = cs.FixedCashflowStream(self._settlement_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    else:\n        self._cashflows = cs.FixedCashflowStream(start_date, self._maturity_date, coupon_spec, first_coupon_date, penultimate_coupon_date, dtype=self._dtype)\n    self._notional = tf.convert_to_tensor([x.notional for x in coupon_spec], dtype=self._dtype)"
        ]
    }
]