[
    {
        "func_name": "voc_ap",
        "original": "def voc_ap(rec, prec, use_07_metric=False):\n    \"\"\" ap = voc_ap(rec, prec, [use_07_metric])\n    Compute VOC AP given precision and recall.\n    If use_07_metric is true, uses the\n    VOC 07 11 point method (default:False).\n    \"\"\"\n    if use_07_metric:\n        ap = 0.0\n        for t in np.arange(0.0, 1.1, 0.1):\n            if np.sum(rec >= t) == 0:\n                p = 0\n            else:\n                p = np.max(prec[rec >= t])\n            ap = ap + p / 11.0\n    else:\n        mrec = np.concatenate(([0.0], rec, [1.0]))\n        mpre = np.concatenate(([0.0], prec, [0.0]))\n        for i in range(mpre.size - 1, 0, -1):\n            mpre[i - 1] = np.maximum(mpre[i - 1], mpre[i])\n        i = np.where(mrec[1:] != mrec[:-1])[0]\n        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])\n    return ap",
        "mutated": [
            "def voc_ap(rec, prec, use_07_metric=False):\n    if False:\n        i = 10\n    ' ap = voc_ap(rec, prec, [use_07_metric])\\n    Compute VOC AP given precision and recall.\\n    If use_07_metric is true, uses the\\n    VOC 07 11 point method (default:False).\\n    '\n    if use_07_metric:\n        ap = 0.0\n        for t in np.arange(0.0, 1.1, 0.1):\n            if np.sum(rec >= t) == 0:\n                p = 0\n            else:\n                p = np.max(prec[rec >= t])\n            ap = ap + p / 11.0\n    else:\n        mrec = np.concatenate(([0.0], rec, [1.0]))\n        mpre = np.concatenate(([0.0], prec, [0.0]))\n        for i in range(mpre.size - 1, 0, -1):\n            mpre[i - 1] = np.maximum(mpre[i - 1], mpre[i])\n        i = np.where(mrec[1:] != mrec[:-1])[0]\n        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])\n    return ap",
            "def voc_ap(rec, prec, use_07_metric=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' ap = voc_ap(rec, prec, [use_07_metric])\\n    Compute VOC AP given precision and recall.\\n    If use_07_metric is true, uses the\\n    VOC 07 11 point method (default:False).\\n    '\n    if use_07_metric:\n        ap = 0.0\n        for t in np.arange(0.0, 1.1, 0.1):\n            if np.sum(rec >= t) == 0:\n                p = 0\n            else:\n                p = np.max(prec[rec >= t])\n            ap = ap + p / 11.0\n    else:\n        mrec = np.concatenate(([0.0], rec, [1.0]))\n        mpre = np.concatenate(([0.0], prec, [0.0]))\n        for i in range(mpre.size - 1, 0, -1):\n            mpre[i - 1] = np.maximum(mpre[i - 1], mpre[i])\n        i = np.where(mrec[1:] != mrec[:-1])[0]\n        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])\n    return ap",
            "def voc_ap(rec, prec, use_07_metric=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' ap = voc_ap(rec, prec, [use_07_metric])\\n    Compute VOC AP given precision and recall.\\n    If use_07_metric is true, uses the\\n    VOC 07 11 point method (default:False).\\n    '\n    if use_07_metric:\n        ap = 0.0\n        for t in np.arange(0.0, 1.1, 0.1):\n            if np.sum(rec >= t) == 0:\n                p = 0\n            else:\n                p = np.max(prec[rec >= t])\n            ap = ap + p / 11.0\n    else:\n        mrec = np.concatenate(([0.0], rec, [1.0]))\n        mpre = np.concatenate(([0.0], prec, [0.0]))\n        for i in range(mpre.size - 1, 0, -1):\n            mpre[i - 1] = np.maximum(mpre[i - 1], mpre[i])\n        i = np.where(mrec[1:] != mrec[:-1])[0]\n        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])\n    return ap",
            "def voc_ap(rec, prec, use_07_metric=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' ap = voc_ap(rec, prec, [use_07_metric])\\n    Compute VOC AP given precision and recall.\\n    If use_07_metric is true, uses the\\n    VOC 07 11 point method (default:False).\\n    '\n    if use_07_metric:\n        ap = 0.0\n        for t in np.arange(0.0, 1.1, 0.1):\n            if np.sum(rec >= t) == 0:\n                p = 0\n            else:\n                p = np.max(prec[rec >= t])\n            ap = ap + p / 11.0\n    else:\n        mrec = np.concatenate(([0.0], rec, [1.0]))\n        mpre = np.concatenate(([0.0], prec, [0.0]))\n        for i in range(mpre.size - 1, 0, -1):\n            mpre[i - 1] = np.maximum(mpre[i - 1], mpre[i])\n        i = np.where(mrec[1:] != mrec[:-1])[0]\n        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])\n    return ap",
            "def voc_ap(rec, prec, use_07_metric=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' ap = voc_ap(rec, prec, [use_07_metric])\\n    Compute VOC AP given precision and recall.\\n    If use_07_metric is true, uses the\\n    VOC 07 11 point method (default:False).\\n    '\n    if use_07_metric:\n        ap = 0.0\n        for t in np.arange(0.0, 1.1, 0.1):\n            if np.sum(rec >= t) == 0:\n                p = 0\n            else:\n                p = np.max(prec[rec >= t])\n            ap = ap + p / 11.0\n    else:\n        mrec = np.concatenate(([0.0], rec, [1.0]))\n        mpre = np.concatenate(([0.0], prec, [0.0]))\n        for i in range(mpre.size - 1, 0, -1):\n            mpre[i - 1] = np.maximum(mpre[i - 1], mpre[i])\n        i = np.where(mrec[1:] != mrec[:-1])[0]\n        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])\n    return ap"
        ]
    },
    {
        "func_name": "voc_eval",
        "original": "def voc_eval(all_boxes, all_gt_boxes, classes, ovthresh=0.5, use_07_metric=False):\n    num_classes = len(classes)\n    det_bbox = np.array([b[:5] for idx in all_boxes for b in idx])\n    det_cls_idx = np.array([b[-1] for idx in all_boxes for b in idx])\n    det_img_idx = np.array([img_idx for (img_idx, idx) in enumerate(all_boxes) for b in idx])\n    MAP = np.zeros((num_classes, 1))\n    det_bbox[:, :4] = np.round(det_bbox[:, :4], decimals=1)\n    det_bbox[:, -1] = np.round(det_bbox[:, -1], decimals=3)\n    for (cls_idx, cls) in enumerate(classes):\n        if cls == '__background__':\n            continue\n        npos = 0\n        for gt_boxes in all_gt_boxes:\n            npos = npos + len(np.where(np.logical_and(gt_boxes[:, GT_CLASS_INDEX] == cls_idx, gt_boxes[:, GT_DIFFICULT_INDEX] == 0))[0])\n        idx = np.where(det_cls_idx == cls_idx)[0]\n        cls_bb = det_bbox[idx]\n        cls_img_idx = det_img_idx[idx]\n        sorted_ind = np.argsort(-cls_bb[:, -1])\n        cls_bb = cls_bb[sorted_ind, :]\n        cls_img_idx = cls_img_idx[sorted_ind]\n        nd = len(sorted_ind)\n        tp = np.zeros(len(sorted_ind))\n        fp = np.zeros(len(sorted_ind))\n        for d in range(nd):\n            bb = cls_bb[d, :]\n            img_idx = cls_img_idx[d]\n            bbgt = all_gt_boxes[img_idx]\n            box_idx = np.where(bbgt[:, GT_CLASS_INDEX] == cls_idx)[0]\n            BBGT = bbgt[box_idx, :]\n            ovmax = -np.inf\n            if BBGT.size > 0:\n                ixmin = np.maximum(BBGT[:, 0], bb[0])\n                iymin = np.maximum(BBGT[:, 1], bb[1])\n                ixmax = np.minimum(BBGT[:, 2], bb[2])\n                iymax = np.minimum(BBGT[:, 3], bb[3])\n                iw = np.maximum(ixmax - ixmin + 1.0, 0.0)\n                ih = np.maximum(iymax - iymin + 1.0, 0.0)\n                inters = iw * ih\n                uni = (bb[2] - bb[0] + 1.0) * (bb[3] - bb[1] + 1.0) + (BBGT[:, 2] - BBGT[:, 0] + 1.0) * (BBGT[:, 3] - BBGT[:, 1] + 1.0) - inters\n                overlaps = inters / uni\n                ovmax = np.max(overlaps)\n                jmax = np.argmax(overlaps)\n            if ovmax > ovthresh:\n                if not bbgt[box_idx[jmax], GT_DIFFICULT_INDEX]:\n                    if not bbgt[box_idx[jmax], GT_DETECTED_INDEX]:\n                        tp[d] = 1.0\n                        bbgt[box_idx[jmax], GT_DETECTED_INDEX] = True\n                    else:\n                        fp[d] = 1.0\n            else:\n                fp[d] = 1.0\n        fp = np.cumsum(fp)\n        tp = np.cumsum(tp)\n        rec = tp / float(npos)\n        prec = tp / (tp + fp + 1e-10)\n        ap = voc_ap(rec, prec, True)\n        MAP[cls_idx] = ap\n        print('AP for {} = {:.4f}'.format(cls, ap))\n    print('Mean AP = {:.4f}'.format(MAP[1:].mean()))\n    return MAP[1:]",
        "mutated": [
            "def voc_eval(all_boxes, all_gt_boxes, classes, ovthresh=0.5, use_07_metric=False):\n    if False:\n        i = 10\n    num_classes = len(classes)\n    det_bbox = np.array([b[:5] for idx in all_boxes for b in idx])\n    det_cls_idx = np.array([b[-1] for idx in all_boxes for b in idx])\n    det_img_idx = np.array([img_idx for (img_idx, idx) in enumerate(all_boxes) for b in idx])\n    MAP = np.zeros((num_classes, 1))\n    det_bbox[:, :4] = np.round(det_bbox[:, :4], decimals=1)\n    det_bbox[:, -1] = np.round(det_bbox[:, -1], decimals=3)\n    for (cls_idx, cls) in enumerate(classes):\n        if cls == '__background__':\n            continue\n        npos = 0\n        for gt_boxes in all_gt_boxes:\n            npos = npos + len(np.where(np.logical_and(gt_boxes[:, GT_CLASS_INDEX] == cls_idx, gt_boxes[:, GT_DIFFICULT_INDEX] == 0))[0])\n        idx = np.where(det_cls_idx == cls_idx)[0]\n        cls_bb = det_bbox[idx]\n        cls_img_idx = det_img_idx[idx]\n        sorted_ind = np.argsort(-cls_bb[:, -1])\n        cls_bb = cls_bb[sorted_ind, :]\n        cls_img_idx = cls_img_idx[sorted_ind]\n        nd = len(sorted_ind)\n        tp = np.zeros(len(sorted_ind))\n        fp = np.zeros(len(sorted_ind))\n        for d in range(nd):\n            bb = cls_bb[d, :]\n            img_idx = cls_img_idx[d]\n            bbgt = all_gt_boxes[img_idx]\n            box_idx = np.where(bbgt[:, GT_CLASS_INDEX] == cls_idx)[0]\n            BBGT = bbgt[box_idx, :]\n            ovmax = -np.inf\n            if BBGT.size > 0:\n                ixmin = np.maximum(BBGT[:, 0], bb[0])\n                iymin = np.maximum(BBGT[:, 1], bb[1])\n                ixmax = np.minimum(BBGT[:, 2], bb[2])\n                iymax = np.minimum(BBGT[:, 3], bb[3])\n                iw = np.maximum(ixmax - ixmin + 1.0, 0.0)\n                ih = np.maximum(iymax - iymin + 1.0, 0.0)\n                inters = iw * ih\n                uni = (bb[2] - bb[0] + 1.0) * (bb[3] - bb[1] + 1.0) + (BBGT[:, 2] - BBGT[:, 0] + 1.0) * (BBGT[:, 3] - BBGT[:, 1] + 1.0) - inters\n                overlaps = inters / uni\n                ovmax = np.max(overlaps)\n                jmax = np.argmax(overlaps)\n            if ovmax > ovthresh:\n                if not bbgt[box_idx[jmax], GT_DIFFICULT_INDEX]:\n                    if not bbgt[box_idx[jmax], GT_DETECTED_INDEX]:\n                        tp[d] = 1.0\n                        bbgt[box_idx[jmax], GT_DETECTED_INDEX] = True\n                    else:\n                        fp[d] = 1.0\n            else:\n                fp[d] = 1.0\n        fp = np.cumsum(fp)\n        tp = np.cumsum(tp)\n        rec = tp / float(npos)\n        prec = tp / (tp + fp + 1e-10)\n        ap = voc_ap(rec, prec, True)\n        MAP[cls_idx] = ap\n        print('AP for {} = {:.4f}'.format(cls, ap))\n    print('Mean AP = {:.4f}'.format(MAP[1:].mean()))\n    return MAP[1:]",
            "def voc_eval(all_boxes, all_gt_boxes, classes, ovthresh=0.5, use_07_metric=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    num_classes = len(classes)\n    det_bbox = np.array([b[:5] for idx in all_boxes for b in idx])\n    det_cls_idx = np.array([b[-1] for idx in all_boxes for b in idx])\n    det_img_idx = np.array([img_idx for (img_idx, idx) in enumerate(all_boxes) for b in idx])\n    MAP = np.zeros((num_classes, 1))\n    det_bbox[:, :4] = np.round(det_bbox[:, :4], decimals=1)\n    det_bbox[:, -1] = np.round(det_bbox[:, -1], decimals=3)\n    for (cls_idx, cls) in enumerate(classes):\n        if cls == '__background__':\n            continue\n        npos = 0\n        for gt_boxes in all_gt_boxes:\n            npos = npos + len(np.where(np.logical_and(gt_boxes[:, GT_CLASS_INDEX] == cls_idx, gt_boxes[:, GT_DIFFICULT_INDEX] == 0))[0])\n        idx = np.where(det_cls_idx == cls_idx)[0]\n        cls_bb = det_bbox[idx]\n        cls_img_idx = det_img_idx[idx]\n        sorted_ind = np.argsort(-cls_bb[:, -1])\n        cls_bb = cls_bb[sorted_ind, :]\n        cls_img_idx = cls_img_idx[sorted_ind]\n        nd = len(sorted_ind)\n        tp = np.zeros(len(sorted_ind))\n        fp = np.zeros(len(sorted_ind))\n        for d in range(nd):\n            bb = cls_bb[d, :]\n            img_idx = cls_img_idx[d]\n            bbgt = all_gt_boxes[img_idx]\n            box_idx = np.where(bbgt[:, GT_CLASS_INDEX] == cls_idx)[0]\n            BBGT = bbgt[box_idx, :]\n            ovmax = -np.inf\n            if BBGT.size > 0:\n                ixmin = np.maximum(BBGT[:, 0], bb[0])\n                iymin = np.maximum(BBGT[:, 1], bb[1])\n                ixmax = np.minimum(BBGT[:, 2], bb[2])\n                iymax = np.minimum(BBGT[:, 3], bb[3])\n                iw = np.maximum(ixmax - ixmin + 1.0, 0.0)\n                ih = np.maximum(iymax - iymin + 1.0, 0.0)\n                inters = iw * ih\n                uni = (bb[2] - bb[0] + 1.0) * (bb[3] - bb[1] + 1.0) + (BBGT[:, 2] - BBGT[:, 0] + 1.0) * (BBGT[:, 3] - BBGT[:, 1] + 1.0) - inters\n                overlaps = inters / uni\n                ovmax = np.max(overlaps)\n                jmax = np.argmax(overlaps)\n            if ovmax > ovthresh:\n                if not bbgt[box_idx[jmax], GT_DIFFICULT_INDEX]:\n                    if not bbgt[box_idx[jmax], GT_DETECTED_INDEX]:\n                        tp[d] = 1.0\n                        bbgt[box_idx[jmax], GT_DETECTED_INDEX] = True\n                    else:\n                        fp[d] = 1.0\n            else:\n                fp[d] = 1.0\n        fp = np.cumsum(fp)\n        tp = np.cumsum(tp)\n        rec = tp / float(npos)\n        prec = tp / (tp + fp + 1e-10)\n        ap = voc_ap(rec, prec, True)\n        MAP[cls_idx] = ap\n        print('AP for {} = {:.4f}'.format(cls, ap))\n    print('Mean AP = {:.4f}'.format(MAP[1:].mean()))\n    return MAP[1:]",
            "def voc_eval(all_boxes, all_gt_boxes, classes, ovthresh=0.5, use_07_metric=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    num_classes = len(classes)\n    det_bbox = np.array([b[:5] for idx in all_boxes for b in idx])\n    det_cls_idx = np.array([b[-1] for idx in all_boxes for b in idx])\n    det_img_idx = np.array([img_idx for (img_idx, idx) in enumerate(all_boxes) for b in idx])\n    MAP = np.zeros((num_classes, 1))\n    det_bbox[:, :4] = np.round(det_bbox[:, :4], decimals=1)\n    det_bbox[:, -1] = np.round(det_bbox[:, -1], decimals=3)\n    for (cls_idx, cls) in enumerate(classes):\n        if cls == '__background__':\n            continue\n        npos = 0\n        for gt_boxes in all_gt_boxes:\n            npos = npos + len(np.where(np.logical_and(gt_boxes[:, GT_CLASS_INDEX] == cls_idx, gt_boxes[:, GT_DIFFICULT_INDEX] == 0))[0])\n        idx = np.where(det_cls_idx == cls_idx)[0]\n        cls_bb = det_bbox[idx]\n        cls_img_idx = det_img_idx[idx]\n        sorted_ind = np.argsort(-cls_bb[:, -1])\n        cls_bb = cls_bb[sorted_ind, :]\n        cls_img_idx = cls_img_idx[sorted_ind]\n        nd = len(sorted_ind)\n        tp = np.zeros(len(sorted_ind))\n        fp = np.zeros(len(sorted_ind))\n        for d in range(nd):\n            bb = cls_bb[d, :]\n            img_idx = cls_img_idx[d]\n            bbgt = all_gt_boxes[img_idx]\n            box_idx = np.where(bbgt[:, GT_CLASS_INDEX] == cls_idx)[0]\n            BBGT = bbgt[box_idx, :]\n            ovmax = -np.inf\n            if BBGT.size > 0:\n                ixmin = np.maximum(BBGT[:, 0], bb[0])\n                iymin = np.maximum(BBGT[:, 1], bb[1])\n                ixmax = np.minimum(BBGT[:, 2], bb[2])\n                iymax = np.minimum(BBGT[:, 3], bb[3])\n                iw = np.maximum(ixmax - ixmin + 1.0, 0.0)\n                ih = np.maximum(iymax - iymin + 1.0, 0.0)\n                inters = iw * ih\n                uni = (bb[2] - bb[0] + 1.0) * (bb[3] - bb[1] + 1.0) + (BBGT[:, 2] - BBGT[:, 0] + 1.0) * (BBGT[:, 3] - BBGT[:, 1] + 1.0) - inters\n                overlaps = inters / uni\n                ovmax = np.max(overlaps)\n                jmax = np.argmax(overlaps)\n            if ovmax > ovthresh:\n                if not bbgt[box_idx[jmax], GT_DIFFICULT_INDEX]:\n                    if not bbgt[box_idx[jmax], GT_DETECTED_INDEX]:\n                        tp[d] = 1.0\n                        bbgt[box_idx[jmax], GT_DETECTED_INDEX] = True\n                    else:\n                        fp[d] = 1.0\n            else:\n                fp[d] = 1.0\n        fp = np.cumsum(fp)\n        tp = np.cumsum(tp)\n        rec = tp / float(npos)\n        prec = tp / (tp + fp + 1e-10)\n        ap = voc_ap(rec, prec, True)\n        MAP[cls_idx] = ap\n        print('AP for {} = {:.4f}'.format(cls, ap))\n    print('Mean AP = {:.4f}'.format(MAP[1:].mean()))\n    return MAP[1:]",
            "def voc_eval(all_boxes, all_gt_boxes, classes, ovthresh=0.5, use_07_metric=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    num_classes = len(classes)\n    det_bbox = np.array([b[:5] for idx in all_boxes for b in idx])\n    det_cls_idx = np.array([b[-1] for idx in all_boxes for b in idx])\n    det_img_idx = np.array([img_idx for (img_idx, idx) in enumerate(all_boxes) for b in idx])\n    MAP = np.zeros((num_classes, 1))\n    det_bbox[:, :4] = np.round(det_bbox[:, :4], decimals=1)\n    det_bbox[:, -1] = np.round(det_bbox[:, -1], decimals=3)\n    for (cls_idx, cls) in enumerate(classes):\n        if cls == '__background__':\n            continue\n        npos = 0\n        for gt_boxes in all_gt_boxes:\n            npos = npos + len(np.where(np.logical_and(gt_boxes[:, GT_CLASS_INDEX] == cls_idx, gt_boxes[:, GT_DIFFICULT_INDEX] == 0))[0])\n        idx = np.where(det_cls_idx == cls_idx)[0]\n        cls_bb = det_bbox[idx]\n        cls_img_idx = det_img_idx[idx]\n        sorted_ind = np.argsort(-cls_bb[:, -1])\n        cls_bb = cls_bb[sorted_ind, :]\n        cls_img_idx = cls_img_idx[sorted_ind]\n        nd = len(sorted_ind)\n        tp = np.zeros(len(sorted_ind))\n        fp = np.zeros(len(sorted_ind))\n        for d in range(nd):\n            bb = cls_bb[d, :]\n            img_idx = cls_img_idx[d]\n            bbgt = all_gt_boxes[img_idx]\n            box_idx = np.where(bbgt[:, GT_CLASS_INDEX] == cls_idx)[0]\n            BBGT = bbgt[box_idx, :]\n            ovmax = -np.inf\n            if BBGT.size > 0:\n                ixmin = np.maximum(BBGT[:, 0], bb[0])\n                iymin = np.maximum(BBGT[:, 1], bb[1])\n                ixmax = np.minimum(BBGT[:, 2], bb[2])\n                iymax = np.minimum(BBGT[:, 3], bb[3])\n                iw = np.maximum(ixmax - ixmin + 1.0, 0.0)\n                ih = np.maximum(iymax - iymin + 1.0, 0.0)\n                inters = iw * ih\n                uni = (bb[2] - bb[0] + 1.0) * (bb[3] - bb[1] + 1.0) + (BBGT[:, 2] - BBGT[:, 0] + 1.0) * (BBGT[:, 3] - BBGT[:, 1] + 1.0) - inters\n                overlaps = inters / uni\n                ovmax = np.max(overlaps)\n                jmax = np.argmax(overlaps)\n            if ovmax > ovthresh:\n                if not bbgt[box_idx[jmax], GT_DIFFICULT_INDEX]:\n                    if not bbgt[box_idx[jmax], GT_DETECTED_INDEX]:\n                        tp[d] = 1.0\n                        bbgt[box_idx[jmax], GT_DETECTED_INDEX] = True\n                    else:\n                        fp[d] = 1.0\n            else:\n                fp[d] = 1.0\n        fp = np.cumsum(fp)\n        tp = np.cumsum(tp)\n        rec = tp / float(npos)\n        prec = tp / (tp + fp + 1e-10)\n        ap = voc_ap(rec, prec, True)\n        MAP[cls_idx] = ap\n        print('AP for {} = {:.4f}'.format(cls, ap))\n    print('Mean AP = {:.4f}'.format(MAP[1:].mean()))\n    return MAP[1:]",
            "def voc_eval(all_boxes, all_gt_boxes, classes, ovthresh=0.5, use_07_metric=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    num_classes = len(classes)\n    det_bbox = np.array([b[:5] for idx in all_boxes for b in idx])\n    det_cls_idx = np.array([b[-1] for idx in all_boxes for b in idx])\n    det_img_idx = np.array([img_idx for (img_idx, idx) in enumerate(all_boxes) for b in idx])\n    MAP = np.zeros((num_classes, 1))\n    det_bbox[:, :4] = np.round(det_bbox[:, :4], decimals=1)\n    det_bbox[:, -1] = np.round(det_bbox[:, -1], decimals=3)\n    for (cls_idx, cls) in enumerate(classes):\n        if cls == '__background__':\n            continue\n        npos = 0\n        for gt_boxes in all_gt_boxes:\n            npos = npos + len(np.where(np.logical_and(gt_boxes[:, GT_CLASS_INDEX] == cls_idx, gt_boxes[:, GT_DIFFICULT_INDEX] == 0))[0])\n        idx = np.where(det_cls_idx == cls_idx)[0]\n        cls_bb = det_bbox[idx]\n        cls_img_idx = det_img_idx[idx]\n        sorted_ind = np.argsort(-cls_bb[:, -1])\n        cls_bb = cls_bb[sorted_ind, :]\n        cls_img_idx = cls_img_idx[sorted_ind]\n        nd = len(sorted_ind)\n        tp = np.zeros(len(sorted_ind))\n        fp = np.zeros(len(sorted_ind))\n        for d in range(nd):\n            bb = cls_bb[d, :]\n            img_idx = cls_img_idx[d]\n            bbgt = all_gt_boxes[img_idx]\n            box_idx = np.where(bbgt[:, GT_CLASS_INDEX] == cls_idx)[0]\n            BBGT = bbgt[box_idx, :]\n            ovmax = -np.inf\n            if BBGT.size > 0:\n                ixmin = np.maximum(BBGT[:, 0], bb[0])\n                iymin = np.maximum(BBGT[:, 1], bb[1])\n                ixmax = np.minimum(BBGT[:, 2], bb[2])\n                iymax = np.minimum(BBGT[:, 3], bb[3])\n                iw = np.maximum(ixmax - ixmin + 1.0, 0.0)\n                ih = np.maximum(iymax - iymin + 1.0, 0.0)\n                inters = iw * ih\n                uni = (bb[2] - bb[0] + 1.0) * (bb[3] - bb[1] + 1.0) + (BBGT[:, 2] - BBGT[:, 0] + 1.0) * (BBGT[:, 3] - BBGT[:, 1] + 1.0) - inters\n                overlaps = inters / uni\n                ovmax = np.max(overlaps)\n                jmax = np.argmax(overlaps)\n            if ovmax > ovthresh:\n                if not bbgt[box_idx[jmax], GT_DIFFICULT_INDEX]:\n                    if not bbgt[box_idx[jmax], GT_DETECTED_INDEX]:\n                        tp[d] = 1.0\n                        bbgt[box_idx[jmax], GT_DETECTED_INDEX] = True\n                    else:\n                        fp[d] = 1.0\n            else:\n                fp[d] = 1.0\n        fp = np.cumsum(fp)\n        tp = np.cumsum(tp)\n        rec = tp / float(npos)\n        prec = tp / (tp + fp + 1e-10)\n        ap = voc_ap(rec, prec, True)\n        MAP[cls_idx] = ap\n        print('AP for {} = {:.4f}'.format(cls, ap))\n    print('Mean AP = {:.4f}'.format(MAP[1:].mean()))\n    return MAP[1:]"
        ]
    }
]