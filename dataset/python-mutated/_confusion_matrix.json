[
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_classes: int, normalize: bool=False, compute_on_call: bool=True):\n    \"\"\"Constructs a confusion matrix for a multiclass classification problems.\"\"\"\n    super().__init__(compute_on_call=compute_on_call)\n    self.num_classes = num_classes\n    self.normalize = normalize\n    self.conf = np.ndarray((num_classes, num_classes), dtype=np.int32)\n    self._ddp_backend = None\n    self.reset()",
        "mutated": [
            "def __init__(self, num_classes: int, normalize: bool=False, compute_on_call: bool=True):\n    if False:\n        i = 10\n    'Constructs a confusion matrix for a multiclass classification problems.'\n    super().__init__(compute_on_call=compute_on_call)\n    self.num_classes = num_classes\n    self.normalize = normalize\n    self.conf = np.ndarray((num_classes, num_classes), dtype=np.int32)\n    self._ddp_backend = None\n    self.reset()",
            "def __init__(self, num_classes: int, normalize: bool=False, compute_on_call: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Constructs a confusion matrix for a multiclass classification problems.'\n    super().__init__(compute_on_call=compute_on_call)\n    self.num_classes = num_classes\n    self.normalize = normalize\n    self.conf = np.ndarray((num_classes, num_classes), dtype=np.int32)\n    self._ddp_backend = None\n    self.reset()",
            "def __init__(self, num_classes: int, normalize: bool=False, compute_on_call: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Constructs a confusion matrix for a multiclass classification problems.'\n    super().__init__(compute_on_call=compute_on_call)\n    self.num_classes = num_classes\n    self.normalize = normalize\n    self.conf = np.ndarray((num_classes, num_classes), dtype=np.int32)\n    self._ddp_backend = None\n    self.reset()",
            "def __init__(self, num_classes: int, normalize: bool=False, compute_on_call: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Constructs a confusion matrix for a multiclass classification problems.'\n    super().__init__(compute_on_call=compute_on_call)\n    self.num_classes = num_classes\n    self.normalize = normalize\n    self.conf = np.ndarray((num_classes, num_classes), dtype=np.int32)\n    self._ddp_backend = None\n    self.reset()",
            "def __init__(self, num_classes: int, normalize: bool=False, compute_on_call: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Constructs a confusion matrix for a multiclass classification problems.'\n    super().__init__(compute_on_call=compute_on_call)\n    self.num_classes = num_classes\n    self.normalize = normalize\n    self.conf = np.ndarray((num_classes, num_classes), dtype=np.int32)\n    self._ddp_backend = None\n    self.reset()"
        ]
    },
    {
        "func_name": "reset",
        "original": "def reset(self) -> None:\n    \"\"\"Reset confusion matrix, filling it with zeros.\"\"\"\n    self.conf.fill(0)\n    self._ddp_backend = get_backend()",
        "mutated": [
            "def reset(self) -> None:\n    if False:\n        i = 10\n    'Reset confusion matrix, filling it with zeros.'\n    self.conf.fill(0)\n    self._ddp_backend = get_backend()",
            "def reset(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Reset confusion matrix, filling it with zeros.'\n    self.conf.fill(0)\n    self._ddp_backend = get_backend()",
            "def reset(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Reset confusion matrix, filling it with zeros.'\n    self.conf.fill(0)\n    self._ddp_backend = get_backend()",
            "def reset(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Reset confusion matrix, filling it with zeros.'\n    self.conf.fill(0)\n    self._ddp_backend = get_backend()",
            "def reset(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Reset confusion matrix, filling it with zeros.'\n    self.conf.fill(0)\n    self._ddp_backend = get_backend()"
        ]
    },
    {
        "func_name": "update",
        "original": "def update(self, predictions: torch.Tensor, targets: torch.Tensor) -> None:\n    \"\"\"Computes the confusion matrix of ``K x K`` size where ``K`` is no of classes.\n\n        Args:\n            predictions: Can be an N x K tensor of predicted scores\n                obtained from the model for N examples and K classes\n                or an N-tensor of integer values between 0 and K-1\n            targets: Can be a N-tensor of integer values assumed\n                to be integer values between 0 and K-1 or N x K tensor, where\n                targets are assumed to be provided as one-hot vectors\n        \"\"\"\n    predictions = predictions.cpu().numpy()\n    targets = targets.cpu().numpy()\n    assert predictions.shape[0] == targets.shape[0], 'number of targets and predicted outputs do not match'\n    if np.ndim(predictions) != 1:\n        assert predictions.shape[1] == self.num_classes, 'number of predictions does not match size of confusion matrix'\n        predictions = np.argmax(predictions, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 1 and k'\n    onehot_target = np.ndim(targets) != 1\n    if onehot_target:\n        assert targets.shape[1] == self.num_classes, 'Onehot target does not match size of confusion matrix'\n        assert (targets >= 0).all() and (targets <= 1).all(), 'in one-hot encoding, target values should be 0 or 1'\n        assert (targets.sum(1) == 1).all(), 'multilabel setting is not supported'\n        targets = np.argmax(targets, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 0 and k-1'\n    x = predictions + self.num_classes * targets\n    bincount_2d = np.bincount(x.astype(np.int32), minlength=self.num_classes ** 2)\n    assert bincount_2d.size == self.num_classes ** 2\n    conf = bincount_2d.reshape((self.num_classes, self.num_classes))\n    self.conf += conf",
        "mutated": [
            "def update(self, predictions: torch.Tensor, targets: torch.Tensor) -> None:\n    if False:\n        i = 10\n    'Computes the confusion matrix of ``K x K`` size where ``K`` is no of classes.\\n\\n        Args:\\n            predictions: Can be an N x K tensor of predicted scores\\n                obtained from the model for N examples and K classes\\n                or an N-tensor of integer values between 0 and K-1\\n            targets: Can be a N-tensor of integer values assumed\\n                to be integer values between 0 and K-1 or N x K tensor, where\\n                targets are assumed to be provided as one-hot vectors\\n        '\n    predictions = predictions.cpu().numpy()\n    targets = targets.cpu().numpy()\n    assert predictions.shape[0] == targets.shape[0], 'number of targets and predicted outputs do not match'\n    if np.ndim(predictions) != 1:\n        assert predictions.shape[1] == self.num_classes, 'number of predictions does not match size of confusion matrix'\n        predictions = np.argmax(predictions, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 1 and k'\n    onehot_target = np.ndim(targets) != 1\n    if onehot_target:\n        assert targets.shape[1] == self.num_classes, 'Onehot target does not match size of confusion matrix'\n        assert (targets >= 0).all() and (targets <= 1).all(), 'in one-hot encoding, target values should be 0 or 1'\n        assert (targets.sum(1) == 1).all(), 'multilabel setting is not supported'\n        targets = np.argmax(targets, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 0 and k-1'\n    x = predictions + self.num_classes * targets\n    bincount_2d = np.bincount(x.astype(np.int32), minlength=self.num_classes ** 2)\n    assert bincount_2d.size == self.num_classes ** 2\n    conf = bincount_2d.reshape((self.num_classes, self.num_classes))\n    self.conf += conf",
            "def update(self, predictions: torch.Tensor, targets: torch.Tensor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes the confusion matrix of ``K x K`` size where ``K`` is no of classes.\\n\\n        Args:\\n            predictions: Can be an N x K tensor of predicted scores\\n                obtained from the model for N examples and K classes\\n                or an N-tensor of integer values between 0 and K-1\\n            targets: Can be a N-tensor of integer values assumed\\n                to be integer values between 0 and K-1 or N x K tensor, where\\n                targets are assumed to be provided as one-hot vectors\\n        '\n    predictions = predictions.cpu().numpy()\n    targets = targets.cpu().numpy()\n    assert predictions.shape[0] == targets.shape[0], 'number of targets and predicted outputs do not match'\n    if np.ndim(predictions) != 1:\n        assert predictions.shape[1] == self.num_classes, 'number of predictions does not match size of confusion matrix'\n        predictions = np.argmax(predictions, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 1 and k'\n    onehot_target = np.ndim(targets) != 1\n    if onehot_target:\n        assert targets.shape[1] == self.num_classes, 'Onehot target does not match size of confusion matrix'\n        assert (targets >= 0).all() and (targets <= 1).all(), 'in one-hot encoding, target values should be 0 or 1'\n        assert (targets.sum(1) == 1).all(), 'multilabel setting is not supported'\n        targets = np.argmax(targets, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 0 and k-1'\n    x = predictions + self.num_classes * targets\n    bincount_2d = np.bincount(x.astype(np.int32), minlength=self.num_classes ** 2)\n    assert bincount_2d.size == self.num_classes ** 2\n    conf = bincount_2d.reshape((self.num_classes, self.num_classes))\n    self.conf += conf",
            "def update(self, predictions: torch.Tensor, targets: torch.Tensor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes the confusion matrix of ``K x K`` size where ``K`` is no of classes.\\n\\n        Args:\\n            predictions: Can be an N x K tensor of predicted scores\\n                obtained from the model for N examples and K classes\\n                or an N-tensor of integer values between 0 and K-1\\n            targets: Can be a N-tensor of integer values assumed\\n                to be integer values between 0 and K-1 or N x K tensor, where\\n                targets are assumed to be provided as one-hot vectors\\n        '\n    predictions = predictions.cpu().numpy()\n    targets = targets.cpu().numpy()\n    assert predictions.shape[0] == targets.shape[0], 'number of targets and predicted outputs do not match'\n    if np.ndim(predictions) != 1:\n        assert predictions.shape[1] == self.num_classes, 'number of predictions does not match size of confusion matrix'\n        predictions = np.argmax(predictions, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 1 and k'\n    onehot_target = np.ndim(targets) != 1\n    if onehot_target:\n        assert targets.shape[1] == self.num_classes, 'Onehot target does not match size of confusion matrix'\n        assert (targets >= 0).all() and (targets <= 1).all(), 'in one-hot encoding, target values should be 0 or 1'\n        assert (targets.sum(1) == 1).all(), 'multilabel setting is not supported'\n        targets = np.argmax(targets, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 0 and k-1'\n    x = predictions + self.num_classes * targets\n    bincount_2d = np.bincount(x.astype(np.int32), minlength=self.num_classes ** 2)\n    assert bincount_2d.size == self.num_classes ** 2\n    conf = bincount_2d.reshape((self.num_classes, self.num_classes))\n    self.conf += conf",
            "def update(self, predictions: torch.Tensor, targets: torch.Tensor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes the confusion matrix of ``K x K`` size where ``K`` is no of classes.\\n\\n        Args:\\n            predictions: Can be an N x K tensor of predicted scores\\n                obtained from the model for N examples and K classes\\n                or an N-tensor of integer values between 0 and K-1\\n            targets: Can be a N-tensor of integer values assumed\\n                to be integer values between 0 and K-1 or N x K tensor, where\\n                targets are assumed to be provided as one-hot vectors\\n        '\n    predictions = predictions.cpu().numpy()\n    targets = targets.cpu().numpy()\n    assert predictions.shape[0] == targets.shape[0], 'number of targets and predicted outputs do not match'\n    if np.ndim(predictions) != 1:\n        assert predictions.shape[1] == self.num_classes, 'number of predictions does not match size of confusion matrix'\n        predictions = np.argmax(predictions, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 1 and k'\n    onehot_target = np.ndim(targets) != 1\n    if onehot_target:\n        assert targets.shape[1] == self.num_classes, 'Onehot target does not match size of confusion matrix'\n        assert (targets >= 0).all() and (targets <= 1).all(), 'in one-hot encoding, target values should be 0 or 1'\n        assert (targets.sum(1) == 1).all(), 'multilabel setting is not supported'\n        targets = np.argmax(targets, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 0 and k-1'\n    x = predictions + self.num_classes * targets\n    bincount_2d = np.bincount(x.astype(np.int32), minlength=self.num_classes ** 2)\n    assert bincount_2d.size == self.num_classes ** 2\n    conf = bincount_2d.reshape((self.num_classes, self.num_classes))\n    self.conf += conf",
            "def update(self, predictions: torch.Tensor, targets: torch.Tensor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes the confusion matrix of ``K x K`` size where ``K`` is no of classes.\\n\\n        Args:\\n            predictions: Can be an N x K tensor of predicted scores\\n                obtained from the model for N examples and K classes\\n                or an N-tensor of integer values between 0 and K-1\\n            targets: Can be a N-tensor of integer values assumed\\n                to be integer values between 0 and K-1 or N x K tensor, where\\n                targets are assumed to be provided as one-hot vectors\\n        '\n    predictions = predictions.cpu().numpy()\n    targets = targets.cpu().numpy()\n    assert predictions.shape[0] == targets.shape[0], 'number of targets and predicted outputs do not match'\n    if np.ndim(predictions) != 1:\n        assert predictions.shape[1] == self.num_classes, 'number of predictions does not match size of confusion matrix'\n        predictions = np.argmax(predictions, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 1 and k'\n    onehot_target = np.ndim(targets) != 1\n    if onehot_target:\n        assert targets.shape[1] == self.num_classes, 'Onehot target does not match size of confusion matrix'\n        assert (targets >= 0).all() and (targets <= 1).all(), 'in one-hot encoding, target values should be 0 or 1'\n        assert (targets.sum(1) == 1).all(), 'multilabel setting is not supported'\n        targets = np.argmax(targets, 1)\n    else:\n        assert predictions.max() < self.num_classes and predictions.min() >= 0, 'predicted values are not between 0 and k-1'\n    x = predictions + self.num_classes * targets\n    bincount_2d = np.bincount(x.astype(np.int32), minlength=self.num_classes ** 2)\n    assert bincount_2d.size == self.num_classes ** 2\n    conf = bincount_2d.reshape((self.num_classes, self.num_classes))\n    self.conf += conf"
        ]
    },
    {
        "func_name": "compute",
        "original": "def compute(self) -> Any:\n    \"\"\"\n        Returns:\n            Confusion matrix of K rows and K columns, where rows corresponds\n            to ground-truth targets and columns corresponds to predicted\n            targets.\n        \"\"\"\n    if self._ddp_backend == 'xla':\n        device = get_device()\n        value = torch.tensor([self.conf], device=device)\n        self.conf = xm.all_gather(value).sum(0).cpu().detach().numpy()\n    elif self._ddp_backend == 'ddp':\n        value: List[np.ndarray] = all_gather(self.conf)\n        value: np.ndarray = np.sum(np.stack(value, axis=0), axis=0)\n        self.conf = value\n    if self.normalize:\n        conf = self.conf.astype(np.float32)\n        return conf / conf.sum(1).clip(min=1e-12)[:, None]\n    else:\n        return self.conf",
        "mutated": [
            "def compute(self) -> Any:\n    if False:\n        i = 10\n    '\\n        Returns:\\n            Confusion matrix of K rows and K columns, where rows corresponds\\n            to ground-truth targets and columns corresponds to predicted\\n            targets.\\n        '\n    if self._ddp_backend == 'xla':\n        device = get_device()\n        value = torch.tensor([self.conf], device=device)\n        self.conf = xm.all_gather(value).sum(0).cpu().detach().numpy()\n    elif self._ddp_backend == 'ddp':\n        value: List[np.ndarray] = all_gather(self.conf)\n        value: np.ndarray = np.sum(np.stack(value, axis=0), axis=0)\n        self.conf = value\n    if self.normalize:\n        conf = self.conf.astype(np.float32)\n        return conf / conf.sum(1).clip(min=1e-12)[:, None]\n    else:\n        return self.conf",
            "def compute(self) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns:\\n            Confusion matrix of K rows and K columns, where rows corresponds\\n            to ground-truth targets and columns corresponds to predicted\\n            targets.\\n        '\n    if self._ddp_backend == 'xla':\n        device = get_device()\n        value = torch.tensor([self.conf], device=device)\n        self.conf = xm.all_gather(value).sum(0).cpu().detach().numpy()\n    elif self._ddp_backend == 'ddp':\n        value: List[np.ndarray] = all_gather(self.conf)\n        value: np.ndarray = np.sum(np.stack(value, axis=0), axis=0)\n        self.conf = value\n    if self.normalize:\n        conf = self.conf.astype(np.float32)\n        return conf / conf.sum(1).clip(min=1e-12)[:, None]\n    else:\n        return self.conf",
            "def compute(self) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns:\\n            Confusion matrix of K rows and K columns, where rows corresponds\\n            to ground-truth targets and columns corresponds to predicted\\n            targets.\\n        '\n    if self._ddp_backend == 'xla':\n        device = get_device()\n        value = torch.tensor([self.conf], device=device)\n        self.conf = xm.all_gather(value).sum(0).cpu().detach().numpy()\n    elif self._ddp_backend == 'ddp':\n        value: List[np.ndarray] = all_gather(self.conf)\n        value: np.ndarray = np.sum(np.stack(value, axis=0), axis=0)\n        self.conf = value\n    if self.normalize:\n        conf = self.conf.astype(np.float32)\n        return conf / conf.sum(1).clip(min=1e-12)[:, None]\n    else:\n        return self.conf",
            "def compute(self) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns:\\n            Confusion matrix of K rows and K columns, where rows corresponds\\n            to ground-truth targets and columns corresponds to predicted\\n            targets.\\n        '\n    if self._ddp_backend == 'xla':\n        device = get_device()\n        value = torch.tensor([self.conf], device=device)\n        self.conf = xm.all_gather(value).sum(0).cpu().detach().numpy()\n    elif self._ddp_backend == 'ddp':\n        value: List[np.ndarray] = all_gather(self.conf)\n        value: np.ndarray = np.sum(np.stack(value, axis=0), axis=0)\n        self.conf = value\n    if self.normalize:\n        conf = self.conf.astype(np.float32)\n        return conf / conf.sum(1).clip(min=1e-12)[:, None]\n    else:\n        return self.conf",
            "def compute(self) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns:\\n            Confusion matrix of K rows and K columns, where rows corresponds\\n            to ground-truth targets and columns corresponds to predicted\\n            targets.\\n        '\n    if self._ddp_backend == 'xla':\n        device = get_device()\n        value = torch.tensor([self.conf], device=device)\n        self.conf = xm.all_gather(value).sum(0).cpu().detach().numpy()\n    elif self._ddp_backend == 'ddp':\n        value: List[np.ndarray] = all_gather(self.conf)\n        value: np.ndarray = np.sum(np.stack(value, axis=0), axis=0)\n        self.conf = value\n    if self.normalize:\n        conf = self.conf.astype(np.float32)\n        return conf / conf.sum(1).clip(min=1e-12)[:, None]\n    else:\n        return self.conf"
        ]
    }
]