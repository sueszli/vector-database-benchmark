[
    {
        "func_name": "_nested_open_implementation",
        "original": "def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n    if path in path_to_content:\n        return mock_open(read_data=path_to_content[path]).return_value\n    else:\n        raise FileNotFoundError(path)",
        "mutated": [
            "def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n    if False:\n        i = 10\n    if path in path_to_content:\n        return mock_open(read_data=path_to_content[path]).return_value\n    else:\n        raise FileNotFoundError(path)",
            "def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if path in path_to_content:\n        return mock_open(read_data=path_to_content[path]).return_value\n    else:\n        raise FileNotFoundError(path)",
            "def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if path in path_to_content:\n        return mock_open(read_data=path_to_content[path]).return_value\n    else:\n        raise FileNotFoundError(path)",
            "def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if path in path_to_content:\n        return mock_open(read_data=path_to_content[path]).return_value\n    else:\n        raise FileNotFoundError(path)",
            "def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if path in path_to_content:\n        return mock_open(read_data=path_to_content[path]).return_value\n    else:\n        raise FileNotFoundError(path)"
        ]
    },
    {
        "func_name": "_open_implementation",
        "original": "def _open_implementation(path_to_content: Dict[str, str]) -> Callable[[str, str], Any]:\n\n    def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n        if path in path_to_content:\n            return mock_open(read_data=path_to_content[path]).return_value\n        else:\n            raise FileNotFoundError(path)\n    return _nested_open_implementation",
        "mutated": [
            "def _open_implementation(path_to_content: Dict[str, str]) -> Callable[[str, str], Any]:\n    if False:\n        i = 10\n\n    def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n        if path in path_to_content:\n            return mock_open(read_data=path_to_content[path]).return_value\n        else:\n            raise FileNotFoundError(path)\n    return _nested_open_implementation",
            "def _open_implementation(path_to_content: Dict[str, str]) -> Callable[[str, str], Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n        if path in path_to_content:\n            return mock_open(read_data=path_to_content[path]).return_value\n        else:\n            raise FileNotFoundError(path)\n    return _nested_open_implementation",
            "def _open_implementation(path_to_content: Dict[str, str]) -> Callable[[str, str], Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n        if path in path_to_content:\n            return mock_open(read_data=path_to_content[path]).return_value\n        else:\n            raise FileNotFoundError(path)\n    return _nested_open_implementation",
            "def _open_implementation(path_to_content: Dict[str, str]) -> Callable[[str, str], Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n        if path in path_to_content:\n            return mock_open(read_data=path_to_content[path]).return_value\n        else:\n            raise FileNotFoundError(path)\n    return _nested_open_implementation",
            "def _open_implementation(path_to_content: Dict[str, str]) -> Callable[[str, str], Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def _nested_open_implementation(path: str, mode: str) -> IO[Any]:\n        if path in path_to_content:\n            return mock_open(read_data=path_to_content[path]).return_value\n        else:\n            raise FileNotFoundError(path)\n    return _nested_open_implementation"
        ]
    },
    {
        "func_name": "test_get_globals",
        "original": "@patch('os.path.exists', side_effect=lambda path: path in {'/root/a.py', '/root/a.pyi', '/root/b.py'} or '/stub_root' in path)\n@patch('os.path.abspath', side_effect=lambda path: path)\n@patch('os.getcwd', return_value='/root')\ndef test_get_globals(self, current_working_directory: unittest.mock._patch, absolute_path: unittest.mock._patch, exists: unittest.mock._patch) -> None:\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', return_value=['/root/a.py', '/root/b.py']):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py')], any_order=True)\n    directory_mapping = {'/root/**/*.py': ['/root/a.py', '/root/b.py'], '/stub_root/**/*.pyi': ['/stub_root/a.pyi', '/stub_root/b.pyi']}\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', side_effect=lambda root, recursive: directory_mapping[root]):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py'), call('/stub_root', '/stub_root/a.pyi'), call('/stub_root', '/stub_root/b.pyi')], any_order=True)",
        "mutated": [
            "@patch('os.path.exists', side_effect=lambda path: path in {'/root/a.py', '/root/a.pyi', '/root/b.py'} or '/stub_root' in path)\n@patch('os.path.abspath', side_effect=lambda path: path)\n@patch('os.getcwd', return_value='/root')\ndef test_get_globals(self, current_working_directory: unittest.mock._patch, absolute_path: unittest.mock._patch, exists: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', return_value=['/root/a.py', '/root/b.py']):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py')], any_order=True)\n    directory_mapping = {'/root/**/*.py': ['/root/a.py', '/root/b.py'], '/stub_root/**/*.pyi': ['/stub_root/a.pyi', '/stub_root/b.pyi']}\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', side_effect=lambda root, recursive: directory_mapping[root]):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py'), call('/stub_root', '/stub_root/a.pyi'), call('/stub_root', '/stub_root/b.pyi')], any_order=True)",
            "@patch('os.path.exists', side_effect=lambda path: path in {'/root/a.py', '/root/a.pyi', '/root/b.py'} or '/stub_root' in path)\n@patch('os.path.abspath', side_effect=lambda path: path)\n@patch('os.getcwd', return_value='/root')\ndef test_get_globals(self, current_working_directory: unittest.mock._patch, absolute_path: unittest.mock._patch, exists: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', return_value=['/root/a.py', '/root/b.py']):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py')], any_order=True)\n    directory_mapping = {'/root/**/*.py': ['/root/a.py', '/root/b.py'], '/stub_root/**/*.pyi': ['/stub_root/a.pyi', '/stub_root/b.pyi']}\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', side_effect=lambda root, recursive: directory_mapping[root]):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py'), call('/stub_root', '/stub_root/a.pyi'), call('/stub_root', '/stub_root/b.pyi')], any_order=True)",
            "@patch('os.path.exists', side_effect=lambda path: path in {'/root/a.py', '/root/a.pyi', '/root/b.py'} or '/stub_root' in path)\n@patch('os.path.abspath', side_effect=lambda path: path)\n@patch('os.getcwd', return_value='/root')\ndef test_get_globals(self, current_working_directory: unittest.mock._patch, absolute_path: unittest.mock._patch, exists: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', return_value=['/root/a.py', '/root/b.py']):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py')], any_order=True)\n    directory_mapping = {'/root/**/*.py': ['/root/a.py', '/root/b.py'], '/stub_root/**/*.pyi': ['/stub_root/a.pyi', '/stub_root/b.pyi']}\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', side_effect=lambda root, recursive: directory_mapping[root]):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py'), call('/stub_root', '/stub_root/a.pyi'), call('/stub_root', '/stub_root/b.pyi')], any_order=True)",
            "@patch('os.path.exists', side_effect=lambda path: path in {'/root/a.py', '/root/a.pyi', '/root/b.py'} or '/stub_root' in path)\n@patch('os.path.abspath', side_effect=lambda path: path)\n@patch('os.getcwd', return_value='/root')\ndef test_get_globals(self, current_working_directory: unittest.mock._patch, absolute_path: unittest.mock._patch, exists: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', return_value=['/root/a.py', '/root/b.py']):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py')], any_order=True)\n    directory_mapping = {'/root/**/*.py': ['/root/a.py', '/root/b.py'], '/stub_root/**/*.pyi': ['/stub_root/a.pyi', '/stub_root/b.pyi']}\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', side_effect=lambda root, recursive: directory_mapping[root]):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py'), call('/stub_root', '/stub_root/a.pyi'), call('/stub_root', '/stub_root/b.pyi')], any_order=True)",
            "@patch('os.path.exists', side_effect=lambda path: path in {'/root/a.py', '/root/a.pyi', '/root/b.py'} or '/stub_root' in path)\n@patch('os.path.abspath', side_effect=lambda path: path)\n@patch('os.getcwd', return_value='/root')\ndef test_get_globals(self, current_working_directory: unittest.mock._patch, absolute_path: unittest.mock._patch, exists: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', return_value=['/root/a.py', '/root/b.py']):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py')], any_order=True)\n    directory_mapping = {'/root/**/*.py': ['/root/a.py', '/root/b.py'], '/stub_root/**/*.pyi': ['/stub_root/a.pyi', '/stub_root/b.pyi']}\n    with patch(f'{get_globals_name}.GlobalModelGenerator._globals') as globals, patch('glob.glob', side_effect=lambda root, recursive: directory_mapping[root]):\n        GlobalModelGenerator(root='/root', stub_root='/stub_root').compute_models([])\n        globals.assert_has_calls([call('/root', '/root/a.pyi'), call('/root', '/root/b.py'), call('/stub_root', '/stub_root/a.pyi'), call('/stub_root', '/stub_root/b.pyi')], any_order=True)"
        ]
    },
    {
        "func_name": "assert_module_has_global_models",
        "original": "def assert_module_has_global_models(self, source: str, expected: Iterable[str], blacklist: Optional[Set[str]]=None) -> None:\n    blacklist = blacklist or set()\n    with patch('builtins.open') as open:\n        open.side_effect = _open_implementation({'/root/module.py': textwrap.dedent(source)})\n        generator = GlobalModelGenerator(root='/root', blacklisted_globals=blacklist)\n        self.assertSetEqual({str(model) for model in generator._globals('/root', '/root/module.py')}, set(expected))",
        "mutated": [
            "def assert_module_has_global_models(self, source: str, expected: Iterable[str], blacklist: Optional[Set[str]]=None) -> None:\n    if False:\n        i = 10\n    blacklist = blacklist or set()\n    with patch('builtins.open') as open:\n        open.side_effect = _open_implementation({'/root/module.py': textwrap.dedent(source)})\n        generator = GlobalModelGenerator(root='/root', blacklisted_globals=blacklist)\n        self.assertSetEqual({str(model) for model in generator._globals('/root', '/root/module.py')}, set(expected))",
            "def assert_module_has_global_models(self, source: str, expected: Iterable[str], blacklist: Optional[Set[str]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    blacklist = blacklist or set()\n    with patch('builtins.open') as open:\n        open.side_effect = _open_implementation({'/root/module.py': textwrap.dedent(source)})\n        generator = GlobalModelGenerator(root='/root', blacklisted_globals=blacklist)\n        self.assertSetEqual({str(model) for model in generator._globals('/root', '/root/module.py')}, set(expected))",
            "def assert_module_has_global_models(self, source: str, expected: Iterable[str], blacklist: Optional[Set[str]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    blacklist = blacklist or set()\n    with patch('builtins.open') as open:\n        open.side_effect = _open_implementation({'/root/module.py': textwrap.dedent(source)})\n        generator = GlobalModelGenerator(root='/root', blacklisted_globals=blacklist)\n        self.assertSetEqual({str(model) for model in generator._globals('/root', '/root/module.py')}, set(expected))",
            "def assert_module_has_global_models(self, source: str, expected: Iterable[str], blacklist: Optional[Set[str]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    blacklist = blacklist or set()\n    with patch('builtins.open') as open:\n        open.side_effect = _open_implementation({'/root/module.py': textwrap.dedent(source)})\n        generator = GlobalModelGenerator(root='/root', blacklisted_globals=blacklist)\n        self.assertSetEqual({str(model) for model in generator._globals('/root', '/root/module.py')}, set(expected))",
            "def assert_module_has_global_models(self, source: str, expected: Iterable[str], blacklist: Optional[Set[str]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    blacklist = blacklist or set()\n    with patch('builtins.open') as open:\n        open.side_effect = _open_implementation({'/root/module.py': textwrap.dedent(source)})\n        generator = GlobalModelGenerator(root='/root', blacklisted_globals=blacklist)\n        self.assertSetEqual({str(model) for model in generator._globals('/root', '/root/module.py')}, set(expected))"
        ]
    },
    {
        "func_name": "test_globals",
        "original": "@patch('builtins.open')\ndef test_globals(self, open: unittest.mock._patch) -> None:\n    self.assert_module_has_global_models('\\n            A = 1\\n            def function():\\n              B = 2\\n            if \"version\" is None:\\n              C = 2\\n            D, E = 1, 2\\n            __all__ = {}\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.E: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class Class:\\n              F: typing.ClassVar[int] = ...\\n              G: int = ...\\n              class Nested:\\n                H: typing.ClassVar[int] = ...\\n            ', {'module.Class.__class__.F: TaintSink[Global] = ...', 'module.Class.__class__.G: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            Z.X = 1\\n            A, B.C, D = 1, 2, 3\\n            [Y, Q.W] = [1, 2]\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.Y: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from collections import namedtuple\\n            x = collections.namedtuple()\\n            y = namedtuple()\\n            ', set())\n    self.assert_module_has_global_models('\\n            x = a\\n            y = b.c\\n            ', set())\n    self.assert_module_has_global_models('\\n            x[1] = 123\\n            y.field = 456\\n            ', set())\n    self.assert_module_has_global_models('\\n            x: int = 1\\n            y: str  # this is ignored, as it might not exist in the runtime\\n            z: Any = alias_that_we_skip\\n            ', {'module.x: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            A, B = 1\\n            class Class:\\n              C: typing.ClassVar[int] = ...\\n              D: int = ...\\n            ', expected={'module.B: TaintSink[Global] = ...', 'module.Class.__class__.D: TaintSink[Global] = ...'}, blacklist={'module.A', 'module.Class.__class__.C'})\n    self.assert_module_has_global_models('\\n            from dataclasses import dataclass\\n            @dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            import dataclasses\\n            @dataclasses.dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclasses.dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              D: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', {'module.MyClass.__class__.D: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def foo(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            class SubClass(MyClass):\\n              C: int = ...\\n            ', {'module.SubClass.__class__.C: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from typing import TypedDict\\n            class MyClass(TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            import typing\\n            class MyClass(typing.TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              x = lambda x: y\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @property\\n              def foo():\\n                return 0\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @util.some_property_module.cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_classproperty\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_class_property]]: ...'})",
        "mutated": [
            "@patch('builtins.open')\ndef test_globals(self, open: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n    self.assert_module_has_global_models('\\n            A = 1\\n            def function():\\n              B = 2\\n            if \"version\" is None:\\n              C = 2\\n            D, E = 1, 2\\n            __all__ = {}\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.E: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class Class:\\n              F: typing.ClassVar[int] = ...\\n              G: int = ...\\n              class Nested:\\n                H: typing.ClassVar[int] = ...\\n            ', {'module.Class.__class__.F: TaintSink[Global] = ...', 'module.Class.__class__.G: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            Z.X = 1\\n            A, B.C, D = 1, 2, 3\\n            [Y, Q.W] = [1, 2]\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.Y: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from collections import namedtuple\\n            x = collections.namedtuple()\\n            y = namedtuple()\\n            ', set())\n    self.assert_module_has_global_models('\\n            x = a\\n            y = b.c\\n            ', set())\n    self.assert_module_has_global_models('\\n            x[1] = 123\\n            y.field = 456\\n            ', set())\n    self.assert_module_has_global_models('\\n            x: int = 1\\n            y: str  # this is ignored, as it might not exist in the runtime\\n            z: Any = alias_that_we_skip\\n            ', {'module.x: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            A, B = 1\\n            class Class:\\n              C: typing.ClassVar[int] = ...\\n              D: int = ...\\n            ', expected={'module.B: TaintSink[Global] = ...', 'module.Class.__class__.D: TaintSink[Global] = ...'}, blacklist={'module.A', 'module.Class.__class__.C'})\n    self.assert_module_has_global_models('\\n            from dataclasses import dataclass\\n            @dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            import dataclasses\\n            @dataclasses.dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclasses.dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              D: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', {'module.MyClass.__class__.D: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def foo(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            class SubClass(MyClass):\\n              C: int = ...\\n            ', {'module.SubClass.__class__.C: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from typing import TypedDict\\n            class MyClass(TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            import typing\\n            class MyClass(typing.TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              x = lambda x: y\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @property\\n              def foo():\\n                return 0\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @util.some_property_module.cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_classproperty\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_class_property]]: ...'})",
            "@patch('builtins.open')\ndef test_globals(self, open: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.assert_module_has_global_models('\\n            A = 1\\n            def function():\\n              B = 2\\n            if \"version\" is None:\\n              C = 2\\n            D, E = 1, 2\\n            __all__ = {}\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.E: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class Class:\\n              F: typing.ClassVar[int] = ...\\n              G: int = ...\\n              class Nested:\\n                H: typing.ClassVar[int] = ...\\n            ', {'module.Class.__class__.F: TaintSink[Global] = ...', 'module.Class.__class__.G: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            Z.X = 1\\n            A, B.C, D = 1, 2, 3\\n            [Y, Q.W] = [1, 2]\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.Y: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from collections import namedtuple\\n            x = collections.namedtuple()\\n            y = namedtuple()\\n            ', set())\n    self.assert_module_has_global_models('\\n            x = a\\n            y = b.c\\n            ', set())\n    self.assert_module_has_global_models('\\n            x[1] = 123\\n            y.field = 456\\n            ', set())\n    self.assert_module_has_global_models('\\n            x: int = 1\\n            y: str  # this is ignored, as it might not exist in the runtime\\n            z: Any = alias_that_we_skip\\n            ', {'module.x: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            A, B = 1\\n            class Class:\\n              C: typing.ClassVar[int] = ...\\n              D: int = ...\\n            ', expected={'module.B: TaintSink[Global] = ...', 'module.Class.__class__.D: TaintSink[Global] = ...'}, blacklist={'module.A', 'module.Class.__class__.C'})\n    self.assert_module_has_global_models('\\n            from dataclasses import dataclass\\n            @dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            import dataclasses\\n            @dataclasses.dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclasses.dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              D: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', {'module.MyClass.__class__.D: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def foo(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            class SubClass(MyClass):\\n              C: int = ...\\n            ', {'module.SubClass.__class__.C: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from typing import TypedDict\\n            class MyClass(TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            import typing\\n            class MyClass(typing.TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              x = lambda x: y\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @property\\n              def foo():\\n                return 0\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @util.some_property_module.cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_classproperty\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_class_property]]: ...'})",
            "@patch('builtins.open')\ndef test_globals(self, open: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.assert_module_has_global_models('\\n            A = 1\\n            def function():\\n              B = 2\\n            if \"version\" is None:\\n              C = 2\\n            D, E = 1, 2\\n            __all__ = {}\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.E: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class Class:\\n              F: typing.ClassVar[int] = ...\\n              G: int = ...\\n              class Nested:\\n                H: typing.ClassVar[int] = ...\\n            ', {'module.Class.__class__.F: TaintSink[Global] = ...', 'module.Class.__class__.G: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            Z.X = 1\\n            A, B.C, D = 1, 2, 3\\n            [Y, Q.W] = [1, 2]\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.Y: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from collections import namedtuple\\n            x = collections.namedtuple()\\n            y = namedtuple()\\n            ', set())\n    self.assert_module_has_global_models('\\n            x = a\\n            y = b.c\\n            ', set())\n    self.assert_module_has_global_models('\\n            x[1] = 123\\n            y.field = 456\\n            ', set())\n    self.assert_module_has_global_models('\\n            x: int = 1\\n            y: str  # this is ignored, as it might not exist in the runtime\\n            z: Any = alias_that_we_skip\\n            ', {'module.x: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            A, B = 1\\n            class Class:\\n              C: typing.ClassVar[int] = ...\\n              D: int = ...\\n            ', expected={'module.B: TaintSink[Global] = ...', 'module.Class.__class__.D: TaintSink[Global] = ...'}, blacklist={'module.A', 'module.Class.__class__.C'})\n    self.assert_module_has_global_models('\\n            from dataclasses import dataclass\\n            @dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            import dataclasses\\n            @dataclasses.dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclasses.dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              D: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', {'module.MyClass.__class__.D: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def foo(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            class SubClass(MyClass):\\n              C: int = ...\\n            ', {'module.SubClass.__class__.C: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from typing import TypedDict\\n            class MyClass(TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            import typing\\n            class MyClass(typing.TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              x = lambda x: y\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @property\\n              def foo():\\n                return 0\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @util.some_property_module.cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_classproperty\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_class_property]]: ...'})",
            "@patch('builtins.open')\ndef test_globals(self, open: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.assert_module_has_global_models('\\n            A = 1\\n            def function():\\n              B = 2\\n            if \"version\" is None:\\n              C = 2\\n            D, E = 1, 2\\n            __all__ = {}\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.E: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class Class:\\n              F: typing.ClassVar[int] = ...\\n              G: int = ...\\n              class Nested:\\n                H: typing.ClassVar[int] = ...\\n            ', {'module.Class.__class__.F: TaintSink[Global] = ...', 'module.Class.__class__.G: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            Z.X = 1\\n            A, B.C, D = 1, 2, 3\\n            [Y, Q.W] = [1, 2]\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.Y: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from collections import namedtuple\\n            x = collections.namedtuple()\\n            y = namedtuple()\\n            ', set())\n    self.assert_module_has_global_models('\\n            x = a\\n            y = b.c\\n            ', set())\n    self.assert_module_has_global_models('\\n            x[1] = 123\\n            y.field = 456\\n            ', set())\n    self.assert_module_has_global_models('\\n            x: int = 1\\n            y: str  # this is ignored, as it might not exist in the runtime\\n            z: Any = alias_that_we_skip\\n            ', {'module.x: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            A, B = 1\\n            class Class:\\n              C: typing.ClassVar[int] = ...\\n              D: int = ...\\n            ', expected={'module.B: TaintSink[Global] = ...', 'module.Class.__class__.D: TaintSink[Global] = ...'}, blacklist={'module.A', 'module.Class.__class__.C'})\n    self.assert_module_has_global_models('\\n            from dataclasses import dataclass\\n            @dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            import dataclasses\\n            @dataclasses.dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclasses.dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              D: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', {'module.MyClass.__class__.D: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def foo(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            class SubClass(MyClass):\\n              C: int = ...\\n            ', {'module.SubClass.__class__.C: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from typing import TypedDict\\n            class MyClass(TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            import typing\\n            class MyClass(typing.TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              x = lambda x: y\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @property\\n              def foo():\\n                return 0\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @util.some_property_module.cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_classproperty\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_class_property]]: ...'})",
            "@patch('builtins.open')\ndef test_globals(self, open: unittest.mock._patch) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.assert_module_has_global_models('\\n            A = 1\\n            def function():\\n              B = 2\\n            if \"version\" is None:\\n              C = 2\\n            D, E = 1, 2\\n            __all__ = {}\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.E: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class Class:\\n              F: typing.ClassVar[int] = ...\\n              G: int = ...\\n              class Nested:\\n                H: typing.ClassVar[int] = ...\\n            ', {'module.Class.__class__.F: TaintSink[Global] = ...', 'module.Class.__class__.G: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            Z.X = 1\\n            A, B.C, D = 1, 2, 3\\n            [Y, Q.W] = [1, 2]\\n            ', {'module.A: TaintSink[Global] = ...', 'module.D: TaintSink[Global] = ...', 'module.Y: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from collections import namedtuple\\n            x = collections.namedtuple()\\n            y = namedtuple()\\n            ', set())\n    self.assert_module_has_global_models('\\n            x = a\\n            y = b.c\\n            ', set())\n    self.assert_module_has_global_models('\\n            x[1] = 123\\n            y.field = 456\\n            ', set())\n    self.assert_module_has_global_models('\\n            x: int = 1\\n            y: str  # this is ignored, as it might not exist in the runtime\\n            z: Any = alias_that_we_skip\\n            ', {'module.x: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            A, B = 1\\n            class Class:\\n              C: typing.ClassVar[int] = ...\\n              D: int = ...\\n            ', expected={'module.B: TaintSink[Global] = ...', 'module.Class.__class__.D: TaintSink[Global] = ...'}, blacklist={'module.A', 'module.Class.__class__.C'})\n    self.assert_module_has_global_models('\\n            from dataclasses import dataclass\\n            @dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            import dataclasses\\n            @dataclasses.dataclass\\n            class Class:\\n              C: int = ...\\n              D: int = ...\\n            @dataclasses.dataclass(frozen=True)\\n            class Frozen:\\n              C: int = ...\\n              D: int = ...\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              D: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', {'module.MyClass.__class__.D: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def __init__(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: ClassVar[int] = ...\\n              def foo(self):\\n                self.C = 1\\n            ', set())\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              C: int = ...\\n              def __init__(self):\\n                self.C = 1\\n            class SubClass(MyClass):\\n              C: int = ...\\n            ', {'module.SubClass.__class__.C: TaintSink[Global] = ...'})\n    self.assert_module_has_global_models('\\n            from typing import TypedDict\\n            class MyClass(TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            import typing\\n            class MyClass(typing.TypedDict):\\n              x: int = ...\\n              y: str = ...\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              x = lambda x: y\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @property\\n              def foo():\\n                return 0\\n            ', {})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @util.some_property_module.cached_property\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_property]]: ...'})\n    self.assert_module_has_global_models('\\n            class MyClass:\\n              @cached_classproperty\\n              def foo(self):\\n                return 0\\n            ', {'def module.MyClass.foo(self) -> TaintSink[Global, Via[cached_class_property]]: ...'})"
        ]
    }
]