[
    {
        "func_name": "generate_cluster_time_series",
        "original": "def generate_cluster_time_series(n_series, t_samples=100, k_corr_clusters=1, d_dist_clusters=1, rho_main=0.1, rho_corr=0.3, price_start=100.0, dists_clusters=('normal', 'normal', 'student-t', 'normal', 'student-t')):\n    \"\"\"\n    Generates a synthetic time series of correlation and distribution clusters.\n\n    It is reproduced with modifications from the following paper:\n    `Donnat, P., Marti, G. and Very, P., 2016. Toward a generic representation of random\n    variables for machine learning. Pattern Recognition Letters, 70, pp.24-31.\n    <https://www.sciencedirect.com/science/article/pii/S0167865515003906>`_\n\n    `www.datagrapple.com. (n.d.). DataGrapple - Tech: A GNPR tutorial: How to cluster random walks.\n    [online] Available at:  [Accessed 26 Aug. 2020].\n    <https://www.datagrapple.com/Tech/GNPR-tutorial-How-to-cluster-random-walks.html>`_\n\n    This method creates `n_series` time series of length `t_samples`. Each time series is divided\n    into `k_corr_clusters` correlation clusters. Each correlation cluster is subdivided into\n    `d_dist_clusters` distribution clusters.\n    A main distribution is sampled from a normal distribution with mean = 0 and stdev = 1, adjusted\n    by a `rho_main` factor. The correlation clusters are sampled from a given distribution, are generated\n    once, and adjusted by a `rho_corr` factor. The distribution clusters are sampled from other\n    given distributions, and adjusted by (1 - `rho_main` - `rho_corr`). They are sampled for each time series.\n    These three series are added together to form a time series of returns. The final time series\n    is the cumulative sum of the returns, with a start price given by `price_start`.\n\n    :param n_series: (int) Number of time series to generate.\n    :param t_samples: (int) Number of samples in each time series.\n    :param k_corr_clusters: (int) Number of correlation clusters in each time series.\n    :param d_dist_clusters: (int) Number of distribution clusters in each time series.\n    :param rho_main: (float): Strength of main time series distribution.\n    :param rho_corr: (float): Strength of correlation cluster distribution.\n    :param price_start: (float) Starting price of the time series.\n    :param dists_clusters: (list) List containing the names of the distributions to sample from.\n        The following numpy distributions are available: \"normal\" = normal(0, 1), \"normal_2\" = normal(0, 2),\n        \"student-t\" = standard_t(3)/sqrt(3), \"laplace\" = laplace(1/sqrt(2)). The first disitribution\n        is used to sample for the correlation clusters (k_corr_clusters), the remaining ones are used\n        to sample for the distribution clusters (d_dist_clusters).\n    :return: (pd.DataFrame) Generated time series. Has size (t_samples, n_series).\n    \"\"\"\n    pass",
        "mutated": [
            "def generate_cluster_time_series(n_series, t_samples=100, k_corr_clusters=1, d_dist_clusters=1, rho_main=0.1, rho_corr=0.3, price_start=100.0, dists_clusters=('normal', 'normal', 'student-t', 'normal', 'student-t')):\n    if False:\n        i = 10\n    '\\n    Generates a synthetic time series of correlation and distribution clusters.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Donnat, P., Marti, G. and Very, P., 2016. Toward a generic representation of random\\n    variables for machine learning. Pattern Recognition Letters, 70, pp.24-31.\\n    <https://www.sciencedirect.com/science/article/pii/S0167865515003906>`_\\n\\n    `www.datagrapple.com. (n.d.). DataGrapple - Tech: A GNPR tutorial: How to cluster random walks.\\n    [online] Available at:  [Accessed 26 Aug. 2020].\\n    <https://www.datagrapple.com/Tech/GNPR-tutorial-How-to-cluster-random-walks.html>`_\\n\\n    This method creates `n_series` time series of length `t_samples`. Each time series is divided\\n    into `k_corr_clusters` correlation clusters. Each correlation cluster is subdivided into\\n    `d_dist_clusters` distribution clusters.\\n    A main distribution is sampled from a normal distribution with mean = 0 and stdev = 1, adjusted\\n    by a `rho_main` factor. The correlation clusters are sampled from a given distribution, are generated\\n    once, and adjusted by a `rho_corr` factor. The distribution clusters are sampled from other\\n    given distributions, and adjusted by (1 - `rho_main` - `rho_corr`). They are sampled for each time series.\\n    These three series are added together to form a time series of returns. The final time series\\n    is the cumulative sum of the returns, with a start price given by `price_start`.\\n\\n    :param n_series: (int) Number of time series to generate.\\n    :param t_samples: (int) Number of samples in each time series.\\n    :param k_corr_clusters: (int) Number of correlation clusters in each time series.\\n    :param d_dist_clusters: (int) Number of distribution clusters in each time series.\\n    :param rho_main: (float): Strength of main time series distribution.\\n    :param rho_corr: (float): Strength of correlation cluster distribution.\\n    :param price_start: (float) Starting price of the time series.\\n    :param dists_clusters: (list) List containing the names of the distributions to sample from.\\n        The following numpy distributions are available: \"normal\" = normal(0, 1), \"normal_2\" = normal(0, 2),\\n        \"student-t\" = standard_t(3)/sqrt(3), \"laplace\" = laplace(1/sqrt(2)). The first disitribution\\n        is used to sample for the correlation clusters (k_corr_clusters), the remaining ones are used\\n        to sample for the distribution clusters (d_dist_clusters).\\n    :return: (pd.DataFrame) Generated time series. Has size (t_samples, n_series).\\n    '\n    pass",
            "def generate_cluster_time_series(n_series, t_samples=100, k_corr_clusters=1, d_dist_clusters=1, rho_main=0.1, rho_corr=0.3, price_start=100.0, dists_clusters=('normal', 'normal', 'student-t', 'normal', 'student-t')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generates a synthetic time series of correlation and distribution clusters.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Donnat, P., Marti, G. and Very, P., 2016. Toward a generic representation of random\\n    variables for machine learning. Pattern Recognition Letters, 70, pp.24-31.\\n    <https://www.sciencedirect.com/science/article/pii/S0167865515003906>`_\\n\\n    `www.datagrapple.com. (n.d.). DataGrapple - Tech: A GNPR tutorial: How to cluster random walks.\\n    [online] Available at:  [Accessed 26 Aug. 2020].\\n    <https://www.datagrapple.com/Tech/GNPR-tutorial-How-to-cluster-random-walks.html>`_\\n\\n    This method creates `n_series` time series of length `t_samples`. Each time series is divided\\n    into `k_corr_clusters` correlation clusters. Each correlation cluster is subdivided into\\n    `d_dist_clusters` distribution clusters.\\n    A main distribution is sampled from a normal distribution with mean = 0 and stdev = 1, adjusted\\n    by a `rho_main` factor. The correlation clusters are sampled from a given distribution, are generated\\n    once, and adjusted by a `rho_corr` factor. The distribution clusters are sampled from other\\n    given distributions, and adjusted by (1 - `rho_main` - `rho_corr`). They are sampled for each time series.\\n    These three series are added together to form a time series of returns. The final time series\\n    is the cumulative sum of the returns, with a start price given by `price_start`.\\n\\n    :param n_series: (int) Number of time series to generate.\\n    :param t_samples: (int) Number of samples in each time series.\\n    :param k_corr_clusters: (int) Number of correlation clusters in each time series.\\n    :param d_dist_clusters: (int) Number of distribution clusters in each time series.\\n    :param rho_main: (float): Strength of main time series distribution.\\n    :param rho_corr: (float): Strength of correlation cluster distribution.\\n    :param price_start: (float) Starting price of the time series.\\n    :param dists_clusters: (list) List containing the names of the distributions to sample from.\\n        The following numpy distributions are available: \"normal\" = normal(0, 1), \"normal_2\" = normal(0, 2),\\n        \"student-t\" = standard_t(3)/sqrt(3), \"laplace\" = laplace(1/sqrt(2)). The first disitribution\\n        is used to sample for the correlation clusters (k_corr_clusters), the remaining ones are used\\n        to sample for the distribution clusters (d_dist_clusters).\\n    :return: (pd.DataFrame) Generated time series. Has size (t_samples, n_series).\\n    '\n    pass",
            "def generate_cluster_time_series(n_series, t_samples=100, k_corr_clusters=1, d_dist_clusters=1, rho_main=0.1, rho_corr=0.3, price_start=100.0, dists_clusters=('normal', 'normal', 'student-t', 'normal', 'student-t')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generates a synthetic time series of correlation and distribution clusters.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Donnat, P., Marti, G. and Very, P., 2016. Toward a generic representation of random\\n    variables for machine learning. Pattern Recognition Letters, 70, pp.24-31.\\n    <https://www.sciencedirect.com/science/article/pii/S0167865515003906>`_\\n\\n    `www.datagrapple.com. (n.d.). DataGrapple - Tech: A GNPR tutorial: How to cluster random walks.\\n    [online] Available at:  [Accessed 26 Aug. 2020].\\n    <https://www.datagrapple.com/Tech/GNPR-tutorial-How-to-cluster-random-walks.html>`_\\n\\n    This method creates `n_series` time series of length `t_samples`. Each time series is divided\\n    into `k_corr_clusters` correlation clusters. Each correlation cluster is subdivided into\\n    `d_dist_clusters` distribution clusters.\\n    A main distribution is sampled from a normal distribution with mean = 0 and stdev = 1, adjusted\\n    by a `rho_main` factor. The correlation clusters are sampled from a given distribution, are generated\\n    once, and adjusted by a `rho_corr` factor. The distribution clusters are sampled from other\\n    given distributions, and adjusted by (1 - `rho_main` - `rho_corr`). They are sampled for each time series.\\n    These three series are added together to form a time series of returns. The final time series\\n    is the cumulative sum of the returns, with a start price given by `price_start`.\\n\\n    :param n_series: (int) Number of time series to generate.\\n    :param t_samples: (int) Number of samples in each time series.\\n    :param k_corr_clusters: (int) Number of correlation clusters in each time series.\\n    :param d_dist_clusters: (int) Number of distribution clusters in each time series.\\n    :param rho_main: (float): Strength of main time series distribution.\\n    :param rho_corr: (float): Strength of correlation cluster distribution.\\n    :param price_start: (float) Starting price of the time series.\\n    :param dists_clusters: (list) List containing the names of the distributions to sample from.\\n        The following numpy distributions are available: \"normal\" = normal(0, 1), \"normal_2\" = normal(0, 2),\\n        \"student-t\" = standard_t(3)/sqrt(3), \"laplace\" = laplace(1/sqrt(2)). The first disitribution\\n        is used to sample for the correlation clusters (k_corr_clusters), the remaining ones are used\\n        to sample for the distribution clusters (d_dist_clusters).\\n    :return: (pd.DataFrame) Generated time series. Has size (t_samples, n_series).\\n    '\n    pass",
            "def generate_cluster_time_series(n_series, t_samples=100, k_corr_clusters=1, d_dist_clusters=1, rho_main=0.1, rho_corr=0.3, price_start=100.0, dists_clusters=('normal', 'normal', 'student-t', 'normal', 'student-t')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generates a synthetic time series of correlation and distribution clusters.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Donnat, P., Marti, G. and Very, P., 2016. Toward a generic representation of random\\n    variables for machine learning. Pattern Recognition Letters, 70, pp.24-31.\\n    <https://www.sciencedirect.com/science/article/pii/S0167865515003906>`_\\n\\n    `www.datagrapple.com. (n.d.). DataGrapple - Tech: A GNPR tutorial: How to cluster random walks.\\n    [online] Available at:  [Accessed 26 Aug. 2020].\\n    <https://www.datagrapple.com/Tech/GNPR-tutorial-How-to-cluster-random-walks.html>`_\\n\\n    This method creates `n_series` time series of length `t_samples`. Each time series is divided\\n    into `k_corr_clusters` correlation clusters. Each correlation cluster is subdivided into\\n    `d_dist_clusters` distribution clusters.\\n    A main distribution is sampled from a normal distribution with mean = 0 and stdev = 1, adjusted\\n    by a `rho_main` factor. The correlation clusters are sampled from a given distribution, are generated\\n    once, and adjusted by a `rho_corr` factor. The distribution clusters are sampled from other\\n    given distributions, and adjusted by (1 - `rho_main` - `rho_corr`). They are sampled for each time series.\\n    These three series are added together to form a time series of returns. The final time series\\n    is the cumulative sum of the returns, with a start price given by `price_start`.\\n\\n    :param n_series: (int) Number of time series to generate.\\n    :param t_samples: (int) Number of samples in each time series.\\n    :param k_corr_clusters: (int) Number of correlation clusters in each time series.\\n    :param d_dist_clusters: (int) Number of distribution clusters in each time series.\\n    :param rho_main: (float): Strength of main time series distribution.\\n    :param rho_corr: (float): Strength of correlation cluster distribution.\\n    :param price_start: (float) Starting price of the time series.\\n    :param dists_clusters: (list) List containing the names of the distributions to sample from.\\n        The following numpy distributions are available: \"normal\" = normal(0, 1), \"normal_2\" = normal(0, 2),\\n        \"student-t\" = standard_t(3)/sqrt(3), \"laplace\" = laplace(1/sqrt(2)). The first disitribution\\n        is used to sample for the correlation clusters (k_corr_clusters), the remaining ones are used\\n        to sample for the distribution clusters (d_dist_clusters).\\n    :return: (pd.DataFrame) Generated time series. Has size (t_samples, n_series).\\n    '\n    pass",
            "def generate_cluster_time_series(n_series, t_samples=100, k_corr_clusters=1, d_dist_clusters=1, rho_main=0.1, rho_corr=0.3, price_start=100.0, dists_clusters=('normal', 'normal', 'student-t', 'normal', 'student-t')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generates a synthetic time series of correlation and distribution clusters.\\n\\n    It is reproduced with modifications from the following paper:\\n    `Donnat, P., Marti, G. and Very, P., 2016. Toward a generic representation of random\\n    variables for machine learning. Pattern Recognition Letters, 70, pp.24-31.\\n    <https://www.sciencedirect.com/science/article/pii/S0167865515003906>`_\\n\\n    `www.datagrapple.com. (n.d.). DataGrapple - Tech: A GNPR tutorial: How to cluster random walks.\\n    [online] Available at:  [Accessed 26 Aug. 2020].\\n    <https://www.datagrapple.com/Tech/GNPR-tutorial-How-to-cluster-random-walks.html>`_\\n\\n    This method creates `n_series` time series of length `t_samples`. Each time series is divided\\n    into `k_corr_clusters` correlation clusters. Each correlation cluster is subdivided into\\n    `d_dist_clusters` distribution clusters.\\n    A main distribution is sampled from a normal distribution with mean = 0 and stdev = 1, adjusted\\n    by a `rho_main` factor. The correlation clusters are sampled from a given distribution, are generated\\n    once, and adjusted by a `rho_corr` factor. The distribution clusters are sampled from other\\n    given distributions, and adjusted by (1 - `rho_main` - `rho_corr`). They are sampled for each time series.\\n    These three series are added together to form a time series of returns. The final time series\\n    is the cumulative sum of the returns, with a start price given by `price_start`.\\n\\n    :param n_series: (int) Number of time series to generate.\\n    :param t_samples: (int) Number of samples in each time series.\\n    :param k_corr_clusters: (int) Number of correlation clusters in each time series.\\n    :param d_dist_clusters: (int) Number of distribution clusters in each time series.\\n    :param rho_main: (float): Strength of main time series distribution.\\n    :param rho_corr: (float): Strength of correlation cluster distribution.\\n    :param price_start: (float) Starting price of the time series.\\n    :param dists_clusters: (list) List containing the names of the distributions to sample from.\\n        The following numpy distributions are available: \"normal\" = normal(0, 1), \"normal_2\" = normal(0, 2),\\n        \"student-t\" = standard_t(3)/sqrt(3), \"laplace\" = laplace(1/sqrt(2)). The first disitribution\\n        is used to sample for the correlation clusters (k_corr_clusters), the remaining ones are used\\n        to sample for the distribution clusters (d_dist_clusters).\\n    :return: (pd.DataFrame) Generated time series. Has size (t_samples, n_series).\\n    '\n    pass"
        ]
    }
]