[
    {
        "func_name": "ccl_3d",
        "original": "def ccl_3d(data_3d):\n    \"\"\" \n    3D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\n    Args:\n        [in]param data_3d: binary three-dimensional vector\n            type data_3d: jittor array\n\n    Returns:\n        [out]result : labeled three-dimensional vector\n\n    Example:\n    >>> import jittor as jt\n    >>> jt.flags.use_cuda = 1\n    >>> data_3d = jt.zeros((10, 11, 12), dtype=jt.uint32)\n    >>> data_3d[2:4, :, :] = 1\n    >>> data_3d[5:7, :, :] = 1\n    >>> result = ccl_3d(data_3d)\n    >>> print(result[:, 0, 0])\n    >>> print(\n        jt.unique(result, return_counts=True, return_inverse=True)[0],\n        jt.unique(result, return_counts=True, return_inverse=True)[2])\n    \"\"\"\n    data_3d = data_3d.astype(jt.uint32)\n    cX = data_3d.shape[0]\n    cY = data_3d.shape[1]\n    cZ = data_3d.shape[2]\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_3d_copy = data_3d.copy()\n    data_3d = data_3d.reshape(cX * cY * cZ)\n    result = jt.code(data_3d.shape, data_3d.dtype, [data_3d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            const unsigned char pzyx = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbour Connections\\n                            const bool nzm1yx   = (iz > 0) ? (pzyx == @g_image((iz-1)*pY +  iy   *pX + ix  )) : false;\\n                            const bool nzym1x   = (iy > 0) ? (pzyx == @g_image( iz   *pY + (iy-1)*pX + ix  )) : false;\\n                            const bool nzyxm1   = (ix > 0) ? (pzyx == @g_image( iz   *pY +  iy   *pX + ix-1)) : false;\\n\\n                            // Label\\n                            unsigned int label;\\n\\n                            // Initialise Label\\n                            label = (nzyxm1) ? (    iz*pY +     iy*pX + ix-1) : (iz*pY + iy*pX + ix);\\n                            label = (nzym1x) ? (    iz*pY + (iy-1)*pX +   ix) : label;\\n                            label = (nzm1yx) ? ((iz-1)*pY +     iy*pX +   ix) : label;\\n                            // Write to Global Memory\\n                            @g_labels(iz*pY + iy*pX + ix) = label;\\n                        }\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.z * blockDim.z) + threadIdx.z) * pY +\\n                                                ((blockIdx.y * blockDim.y) + threadIdx.y) * pX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY*cZ) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            // Get image and label values\\n                            const unsigned char pzyx  = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbouring indexes\\n                            const unsigned int xm1 = ix-1;\\n                            const unsigned int xp1 = ix+1;\\n                            const unsigned int ym1 = iy-1;\\n                            const unsigned int yp1 = iy+1;\\n                            const unsigned int zm1 = iz-1;\\n                            const unsigned int zp1 = iz+1;\\n\\n                            // Get neighbour labels\\n                            const unsigned int lzm1yx = (iz > 0)    ? @g_labels(zm1*pY +  iy*pX +  ix) : 0;\\n                            const unsigned int lzym1x = (iy > 0)    ? @g_labels( iz*pY + ym1*pX +  ix) : 0;\\n                            const unsigned int lzyxm1 = (ix > 0)    ? @g_labels( iz*pY +  iy*pX + xm1) : 0;\\n                            const unsigned int lzyx   =               @g_labels( iz*pY +  iy*pX +  ix);\\n                            const unsigned int lzyxp1 = (ix < cX-1) ? @g_labels( iz*pY +  iy*pX + xp1) : 0;\\n                            const unsigned int lzyp1x = (iy < cY-1) ? @g_labels( iz*pY + yp1*pX +  ix) : 0;\\n                            const unsigned int lzp1yx = (iz < cZ-1) ? @g_labels(zp1*pY +  iy*pX +  ix) : 0;\\n\\n                            const bool nzm1yx = (iz > 0)    ? (pzyx == @g_image(zm1*pY +  iy*pX +  ix)) : false;\\n                            const bool nzym1x = (iy > 0)    ? (pzyx == @g_image( iz*pY + ym1*pX +  ix)) : false;\\n                            const bool nzyxm1 = (ix > 0)    ? (pzyx == @g_image( iz*pY +  iy*pX + xm1)) : false;\\n                            const bool nzyxp1 = (ix < cX-1) ? (pzyx == @g_image( iz*pY +  iy*pX + xp1)) : false;\\n                            const bool nzyp1x = (iy < cY-1) ? (pzyx == @g_image( iz*pY + yp1*pX +  ix)) : false;\\n                            const bool nzp1yx = (iz < cZ-1) ? (pzyx == @g_image(zp1*pY +  iy*pX +  ix)) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lzyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nzm1yx) && (lzm1yx < label)) ? lzm1yx : label;\\n                            label = ((nzym1x) && (lzym1x < label)) ? lzym1x : label;\\n                            label = ((nzyxm1) && (lzyxm1 < label)) ? lzyxm1 : label;\\n                            label = ((nzyxp1) && (lzyxp1 < label)) ? lzyxp1 : label;\\n                            label = ((nzyp1x) && (lzyp1x < label)) ? lzyp1x : label;\\n                            label = ((nzp1yx) && (lzp1yx < label)) ? lzp1yx : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lzyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lzyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 4, 4);\\n                    const int cX= {cX};\\n                    const int cY= {cY};\\n                    const int cZ= {cZ};\\n                    const int pX= cX;\\n                    const int pY= cX*cY;' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y), ceil(cZ/(float)block.z));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< grid, block>>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    }\\n                    ')\n    result = result.reshape((cX, cY, cZ)) * data_3d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
        "mutated": [
            "def ccl_3d(data_3d):\n    if False:\n        i = 10\n    ' \\n    3D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_3d: binary three-dimensional vector\\n            type data_3d: jittor array\\n\\n    Returns:\\n        [out]result : labeled three-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> data_3d = jt.zeros((10, 11, 12), dtype=jt.uint32)\\n    >>> data_3d[2:4, :, :] = 1\\n    >>> data_3d[5:7, :, :] = 1\\n    >>> result = ccl_3d(data_3d)\\n    >>> print(result[:, 0, 0])\\n    >>> print(\\n        jt.unique(result, return_counts=True, return_inverse=True)[0],\\n        jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    '\n    data_3d = data_3d.astype(jt.uint32)\n    cX = data_3d.shape[0]\n    cY = data_3d.shape[1]\n    cZ = data_3d.shape[2]\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_3d_copy = data_3d.copy()\n    data_3d = data_3d.reshape(cX * cY * cZ)\n    result = jt.code(data_3d.shape, data_3d.dtype, [data_3d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            const unsigned char pzyx = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbour Connections\\n                            const bool nzm1yx   = (iz > 0) ? (pzyx == @g_image((iz-1)*pY +  iy   *pX + ix  )) : false;\\n                            const bool nzym1x   = (iy > 0) ? (pzyx == @g_image( iz   *pY + (iy-1)*pX + ix  )) : false;\\n                            const bool nzyxm1   = (ix > 0) ? (pzyx == @g_image( iz   *pY +  iy   *pX + ix-1)) : false;\\n\\n                            // Label\\n                            unsigned int label;\\n\\n                            // Initialise Label\\n                            label = (nzyxm1) ? (    iz*pY +     iy*pX + ix-1) : (iz*pY + iy*pX + ix);\\n                            label = (nzym1x) ? (    iz*pY + (iy-1)*pX +   ix) : label;\\n                            label = (nzm1yx) ? ((iz-1)*pY +     iy*pX +   ix) : label;\\n                            // Write to Global Memory\\n                            @g_labels(iz*pY + iy*pX + ix) = label;\\n                        }\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.z * blockDim.z) + threadIdx.z) * pY +\\n                                                ((blockIdx.y * blockDim.y) + threadIdx.y) * pX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY*cZ) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            // Get image and label values\\n                            const unsigned char pzyx  = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbouring indexes\\n                            const unsigned int xm1 = ix-1;\\n                            const unsigned int xp1 = ix+1;\\n                            const unsigned int ym1 = iy-1;\\n                            const unsigned int yp1 = iy+1;\\n                            const unsigned int zm1 = iz-1;\\n                            const unsigned int zp1 = iz+1;\\n\\n                            // Get neighbour labels\\n                            const unsigned int lzm1yx = (iz > 0)    ? @g_labels(zm1*pY +  iy*pX +  ix) : 0;\\n                            const unsigned int lzym1x = (iy > 0)    ? @g_labels( iz*pY + ym1*pX +  ix) : 0;\\n                            const unsigned int lzyxm1 = (ix > 0)    ? @g_labels( iz*pY +  iy*pX + xm1) : 0;\\n                            const unsigned int lzyx   =               @g_labels( iz*pY +  iy*pX +  ix);\\n                            const unsigned int lzyxp1 = (ix < cX-1) ? @g_labels( iz*pY +  iy*pX + xp1) : 0;\\n                            const unsigned int lzyp1x = (iy < cY-1) ? @g_labels( iz*pY + yp1*pX +  ix) : 0;\\n                            const unsigned int lzp1yx = (iz < cZ-1) ? @g_labels(zp1*pY +  iy*pX +  ix) : 0;\\n\\n                            const bool nzm1yx = (iz > 0)    ? (pzyx == @g_image(zm1*pY +  iy*pX +  ix)) : false;\\n                            const bool nzym1x = (iy > 0)    ? (pzyx == @g_image( iz*pY + ym1*pX +  ix)) : false;\\n                            const bool nzyxm1 = (ix > 0)    ? (pzyx == @g_image( iz*pY +  iy*pX + xm1)) : false;\\n                            const bool nzyxp1 = (ix < cX-1) ? (pzyx == @g_image( iz*pY +  iy*pX + xp1)) : false;\\n                            const bool nzyp1x = (iy < cY-1) ? (pzyx == @g_image( iz*pY + yp1*pX +  ix)) : false;\\n                            const bool nzp1yx = (iz < cZ-1) ? (pzyx == @g_image(zp1*pY +  iy*pX +  ix)) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lzyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nzm1yx) && (lzm1yx < label)) ? lzm1yx : label;\\n                            label = ((nzym1x) && (lzym1x < label)) ? lzym1x : label;\\n                            label = ((nzyxm1) && (lzyxm1 < label)) ? lzyxm1 : label;\\n                            label = ((nzyxp1) && (lzyxp1 < label)) ? lzyxp1 : label;\\n                            label = ((nzyp1x) && (lzyp1x < label)) ? lzyp1x : label;\\n                            label = ((nzp1yx) && (lzp1yx < label)) ? lzp1yx : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lzyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lzyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 4, 4);\\n                    const int cX= {cX};\\n                    const int cY= {cY};\\n                    const int cZ= {cZ};\\n                    const int pX= cX;\\n                    const int pY= cX*cY;' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y), ceil(cZ/(float)block.z));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< grid, block>>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    }\\n                    ')\n    result = result.reshape((cX, cY, cZ)) * data_3d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
            "def ccl_3d(data_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' \\n    3D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_3d: binary three-dimensional vector\\n            type data_3d: jittor array\\n\\n    Returns:\\n        [out]result : labeled three-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> data_3d = jt.zeros((10, 11, 12), dtype=jt.uint32)\\n    >>> data_3d[2:4, :, :] = 1\\n    >>> data_3d[5:7, :, :] = 1\\n    >>> result = ccl_3d(data_3d)\\n    >>> print(result[:, 0, 0])\\n    >>> print(\\n        jt.unique(result, return_counts=True, return_inverse=True)[0],\\n        jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    '\n    data_3d = data_3d.astype(jt.uint32)\n    cX = data_3d.shape[0]\n    cY = data_3d.shape[1]\n    cZ = data_3d.shape[2]\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_3d_copy = data_3d.copy()\n    data_3d = data_3d.reshape(cX * cY * cZ)\n    result = jt.code(data_3d.shape, data_3d.dtype, [data_3d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            const unsigned char pzyx = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbour Connections\\n                            const bool nzm1yx   = (iz > 0) ? (pzyx == @g_image((iz-1)*pY +  iy   *pX + ix  )) : false;\\n                            const bool nzym1x   = (iy > 0) ? (pzyx == @g_image( iz   *pY + (iy-1)*pX + ix  )) : false;\\n                            const bool nzyxm1   = (ix > 0) ? (pzyx == @g_image( iz   *pY +  iy   *pX + ix-1)) : false;\\n\\n                            // Label\\n                            unsigned int label;\\n\\n                            // Initialise Label\\n                            label = (nzyxm1) ? (    iz*pY +     iy*pX + ix-1) : (iz*pY + iy*pX + ix);\\n                            label = (nzym1x) ? (    iz*pY + (iy-1)*pX +   ix) : label;\\n                            label = (nzm1yx) ? ((iz-1)*pY +     iy*pX +   ix) : label;\\n                            // Write to Global Memory\\n                            @g_labels(iz*pY + iy*pX + ix) = label;\\n                        }\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.z * blockDim.z) + threadIdx.z) * pY +\\n                                                ((blockIdx.y * blockDim.y) + threadIdx.y) * pX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY*cZ) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            // Get image and label values\\n                            const unsigned char pzyx  = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbouring indexes\\n                            const unsigned int xm1 = ix-1;\\n                            const unsigned int xp1 = ix+1;\\n                            const unsigned int ym1 = iy-1;\\n                            const unsigned int yp1 = iy+1;\\n                            const unsigned int zm1 = iz-1;\\n                            const unsigned int zp1 = iz+1;\\n\\n                            // Get neighbour labels\\n                            const unsigned int lzm1yx = (iz > 0)    ? @g_labels(zm1*pY +  iy*pX +  ix) : 0;\\n                            const unsigned int lzym1x = (iy > 0)    ? @g_labels( iz*pY + ym1*pX +  ix) : 0;\\n                            const unsigned int lzyxm1 = (ix > 0)    ? @g_labels( iz*pY +  iy*pX + xm1) : 0;\\n                            const unsigned int lzyx   =               @g_labels( iz*pY +  iy*pX +  ix);\\n                            const unsigned int lzyxp1 = (ix < cX-1) ? @g_labels( iz*pY +  iy*pX + xp1) : 0;\\n                            const unsigned int lzyp1x = (iy < cY-1) ? @g_labels( iz*pY + yp1*pX +  ix) : 0;\\n                            const unsigned int lzp1yx = (iz < cZ-1) ? @g_labels(zp1*pY +  iy*pX +  ix) : 0;\\n\\n                            const bool nzm1yx = (iz > 0)    ? (pzyx == @g_image(zm1*pY +  iy*pX +  ix)) : false;\\n                            const bool nzym1x = (iy > 0)    ? (pzyx == @g_image( iz*pY + ym1*pX +  ix)) : false;\\n                            const bool nzyxm1 = (ix > 0)    ? (pzyx == @g_image( iz*pY +  iy*pX + xm1)) : false;\\n                            const bool nzyxp1 = (ix < cX-1) ? (pzyx == @g_image( iz*pY +  iy*pX + xp1)) : false;\\n                            const bool nzyp1x = (iy < cY-1) ? (pzyx == @g_image( iz*pY + yp1*pX +  ix)) : false;\\n                            const bool nzp1yx = (iz < cZ-1) ? (pzyx == @g_image(zp1*pY +  iy*pX +  ix)) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lzyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nzm1yx) && (lzm1yx < label)) ? lzm1yx : label;\\n                            label = ((nzym1x) && (lzym1x < label)) ? lzym1x : label;\\n                            label = ((nzyxm1) && (lzyxm1 < label)) ? lzyxm1 : label;\\n                            label = ((nzyxp1) && (lzyxp1 < label)) ? lzyxp1 : label;\\n                            label = ((nzyp1x) && (lzyp1x < label)) ? lzyp1x : label;\\n                            label = ((nzp1yx) && (lzp1yx < label)) ? lzp1yx : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lzyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lzyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 4, 4);\\n                    const int cX= {cX};\\n                    const int cY= {cY};\\n                    const int cZ= {cZ};\\n                    const int pX= cX;\\n                    const int pY= cX*cY;' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y), ceil(cZ/(float)block.z));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< grid, block>>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    }\\n                    ')\n    result = result.reshape((cX, cY, cZ)) * data_3d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
            "def ccl_3d(data_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' \\n    3D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_3d: binary three-dimensional vector\\n            type data_3d: jittor array\\n\\n    Returns:\\n        [out]result : labeled three-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> data_3d = jt.zeros((10, 11, 12), dtype=jt.uint32)\\n    >>> data_3d[2:4, :, :] = 1\\n    >>> data_3d[5:7, :, :] = 1\\n    >>> result = ccl_3d(data_3d)\\n    >>> print(result[:, 0, 0])\\n    >>> print(\\n        jt.unique(result, return_counts=True, return_inverse=True)[0],\\n        jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    '\n    data_3d = data_3d.astype(jt.uint32)\n    cX = data_3d.shape[0]\n    cY = data_3d.shape[1]\n    cZ = data_3d.shape[2]\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_3d_copy = data_3d.copy()\n    data_3d = data_3d.reshape(cX * cY * cZ)\n    result = jt.code(data_3d.shape, data_3d.dtype, [data_3d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            const unsigned char pzyx = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbour Connections\\n                            const bool nzm1yx   = (iz > 0) ? (pzyx == @g_image((iz-1)*pY +  iy   *pX + ix  )) : false;\\n                            const bool nzym1x   = (iy > 0) ? (pzyx == @g_image( iz   *pY + (iy-1)*pX + ix  )) : false;\\n                            const bool nzyxm1   = (ix > 0) ? (pzyx == @g_image( iz   *pY +  iy   *pX + ix-1)) : false;\\n\\n                            // Label\\n                            unsigned int label;\\n\\n                            // Initialise Label\\n                            label = (nzyxm1) ? (    iz*pY +     iy*pX + ix-1) : (iz*pY + iy*pX + ix);\\n                            label = (nzym1x) ? (    iz*pY + (iy-1)*pX +   ix) : label;\\n                            label = (nzm1yx) ? ((iz-1)*pY +     iy*pX +   ix) : label;\\n                            // Write to Global Memory\\n                            @g_labels(iz*pY + iy*pX + ix) = label;\\n                        }\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.z * blockDim.z) + threadIdx.z) * pY +\\n                                                ((blockIdx.y * blockDim.y) + threadIdx.y) * pX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY*cZ) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            // Get image and label values\\n                            const unsigned char pzyx  = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbouring indexes\\n                            const unsigned int xm1 = ix-1;\\n                            const unsigned int xp1 = ix+1;\\n                            const unsigned int ym1 = iy-1;\\n                            const unsigned int yp1 = iy+1;\\n                            const unsigned int zm1 = iz-1;\\n                            const unsigned int zp1 = iz+1;\\n\\n                            // Get neighbour labels\\n                            const unsigned int lzm1yx = (iz > 0)    ? @g_labels(zm1*pY +  iy*pX +  ix) : 0;\\n                            const unsigned int lzym1x = (iy > 0)    ? @g_labels( iz*pY + ym1*pX +  ix) : 0;\\n                            const unsigned int lzyxm1 = (ix > 0)    ? @g_labels( iz*pY +  iy*pX + xm1) : 0;\\n                            const unsigned int lzyx   =               @g_labels( iz*pY +  iy*pX +  ix);\\n                            const unsigned int lzyxp1 = (ix < cX-1) ? @g_labels( iz*pY +  iy*pX + xp1) : 0;\\n                            const unsigned int lzyp1x = (iy < cY-1) ? @g_labels( iz*pY + yp1*pX +  ix) : 0;\\n                            const unsigned int lzp1yx = (iz < cZ-1) ? @g_labels(zp1*pY +  iy*pX +  ix) : 0;\\n\\n                            const bool nzm1yx = (iz > 0)    ? (pzyx == @g_image(zm1*pY +  iy*pX +  ix)) : false;\\n                            const bool nzym1x = (iy > 0)    ? (pzyx == @g_image( iz*pY + ym1*pX +  ix)) : false;\\n                            const bool nzyxm1 = (ix > 0)    ? (pzyx == @g_image( iz*pY +  iy*pX + xm1)) : false;\\n                            const bool nzyxp1 = (ix < cX-1) ? (pzyx == @g_image( iz*pY +  iy*pX + xp1)) : false;\\n                            const bool nzyp1x = (iy < cY-1) ? (pzyx == @g_image( iz*pY + yp1*pX +  ix)) : false;\\n                            const bool nzp1yx = (iz < cZ-1) ? (pzyx == @g_image(zp1*pY +  iy*pX +  ix)) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lzyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nzm1yx) && (lzm1yx < label)) ? lzm1yx : label;\\n                            label = ((nzym1x) && (lzym1x < label)) ? lzym1x : label;\\n                            label = ((nzyxm1) && (lzyxm1 < label)) ? lzyxm1 : label;\\n                            label = ((nzyxp1) && (lzyxp1 < label)) ? lzyxp1 : label;\\n                            label = ((nzyp1x) && (lzyp1x < label)) ? lzyp1x : label;\\n                            label = ((nzp1yx) && (lzp1yx < label)) ? lzp1yx : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lzyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lzyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 4, 4);\\n                    const int cX= {cX};\\n                    const int cY= {cY};\\n                    const int cZ= {cZ};\\n                    const int pX= cX;\\n                    const int pY= cX*cY;' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y), ceil(cZ/(float)block.z));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< grid, block>>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    }\\n                    ')\n    result = result.reshape((cX, cY, cZ)) * data_3d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
            "def ccl_3d(data_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' \\n    3D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_3d: binary three-dimensional vector\\n            type data_3d: jittor array\\n\\n    Returns:\\n        [out]result : labeled three-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> data_3d = jt.zeros((10, 11, 12), dtype=jt.uint32)\\n    >>> data_3d[2:4, :, :] = 1\\n    >>> data_3d[5:7, :, :] = 1\\n    >>> result = ccl_3d(data_3d)\\n    >>> print(result[:, 0, 0])\\n    >>> print(\\n        jt.unique(result, return_counts=True, return_inverse=True)[0],\\n        jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    '\n    data_3d = data_3d.astype(jt.uint32)\n    cX = data_3d.shape[0]\n    cY = data_3d.shape[1]\n    cZ = data_3d.shape[2]\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_3d_copy = data_3d.copy()\n    data_3d = data_3d.reshape(cX * cY * cZ)\n    result = jt.code(data_3d.shape, data_3d.dtype, [data_3d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            const unsigned char pzyx = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbour Connections\\n                            const bool nzm1yx   = (iz > 0) ? (pzyx == @g_image((iz-1)*pY +  iy   *pX + ix  )) : false;\\n                            const bool nzym1x   = (iy > 0) ? (pzyx == @g_image( iz   *pY + (iy-1)*pX + ix  )) : false;\\n                            const bool nzyxm1   = (ix > 0) ? (pzyx == @g_image( iz   *pY +  iy   *pX + ix-1)) : false;\\n\\n                            // Label\\n                            unsigned int label;\\n\\n                            // Initialise Label\\n                            label = (nzyxm1) ? (    iz*pY +     iy*pX + ix-1) : (iz*pY + iy*pX + ix);\\n                            label = (nzym1x) ? (    iz*pY + (iy-1)*pX +   ix) : label;\\n                            label = (nzm1yx) ? ((iz-1)*pY +     iy*pX +   ix) : label;\\n                            // Write to Global Memory\\n                            @g_labels(iz*pY + iy*pX + ix) = label;\\n                        }\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.z * blockDim.z) + threadIdx.z) * pY +\\n                                                ((blockIdx.y * blockDim.y) + threadIdx.y) * pX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY*cZ) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            // Get image and label values\\n                            const unsigned char pzyx  = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbouring indexes\\n                            const unsigned int xm1 = ix-1;\\n                            const unsigned int xp1 = ix+1;\\n                            const unsigned int ym1 = iy-1;\\n                            const unsigned int yp1 = iy+1;\\n                            const unsigned int zm1 = iz-1;\\n                            const unsigned int zp1 = iz+1;\\n\\n                            // Get neighbour labels\\n                            const unsigned int lzm1yx = (iz > 0)    ? @g_labels(zm1*pY +  iy*pX +  ix) : 0;\\n                            const unsigned int lzym1x = (iy > 0)    ? @g_labels( iz*pY + ym1*pX +  ix) : 0;\\n                            const unsigned int lzyxm1 = (ix > 0)    ? @g_labels( iz*pY +  iy*pX + xm1) : 0;\\n                            const unsigned int lzyx   =               @g_labels( iz*pY +  iy*pX +  ix);\\n                            const unsigned int lzyxp1 = (ix < cX-1) ? @g_labels( iz*pY +  iy*pX + xp1) : 0;\\n                            const unsigned int lzyp1x = (iy < cY-1) ? @g_labels( iz*pY + yp1*pX +  ix) : 0;\\n                            const unsigned int lzp1yx = (iz < cZ-1) ? @g_labels(zp1*pY +  iy*pX +  ix) : 0;\\n\\n                            const bool nzm1yx = (iz > 0)    ? (pzyx == @g_image(zm1*pY +  iy*pX +  ix)) : false;\\n                            const bool nzym1x = (iy > 0)    ? (pzyx == @g_image( iz*pY + ym1*pX +  ix)) : false;\\n                            const bool nzyxm1 = (ix > 0)    ? (pzyx == @g_image( iz*pY +  iy*pX + xm1)) : false;\\n                            const bool nzyxp1 = (ix < cX-1) ? (pzyx == @g_image( iz*pY +  iy*pX + xp1)) : false;\\n                            const bool nzyp1x = (iy < cY-1) ? (pzyx == @g_image( iz*pY + yp1*pX +  ix)) : false;\\n                            const bool nzp1yx = (iz < cZ-1) ? (pzyx == @g_image(zp1*pY +  iy*pX +  ix)) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lzyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nzm1yx) && (lzm1yx < label)) ? lzm1yx : label;\\n                            label = ((nzym1x) && (lzym1x < label)) ? lzym1x : label;\\n                            label = ((nzyxm1) && (lzyxm1 < label)) ? lzyxm1 : label;\\n                            label = ((nzyxp1) && (lzyxp1 < label)) ? lzyxp1 : label;\\n                            label = ((nzyp1x) && (lzyp1x < label)) ? lzyp1x : label;\\n                            label = ((nzp1yx) && (lzp1yx < label)) ? lzp1yx : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lzyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lzyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 4, 4);\\n                    const int cX= {cX};\\n                    const int cY= {cY};\\n                    const int cZ= {cZ};\\n                    const int pX= cX;\\n                    const int pY= cX*cY;' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y), ceil(cZ/(float)block.z));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< grid, block>>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    }\\n                    ')\n    result = result.reshape((cX, cY, cZ)) * data_3d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
            "def ccl_3d(data_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' \\n    3D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_3d: binary three-dimensional vector\\n            type data_3d: jittor array\\n\\n    Returns:\\n        [out]result : labeled three-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> data_3d = jt.zeros((10, 11, 12), dtype=jt.uint32)\\n    >>> data_3d[2:4, :, :] = 1\\n    >>> data_3d[5:7, :, :] = 1\\n    >>> result = ccl_3d(data_3d)\\n    >>> print(result[:, 0, 0])\\n    >>> print(\\n        jt.unique(result, return_counts=True, return_inverse=True)[0],\\n        jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    '\n    data_3d = data_3d.astype(jt.uint32)\n    cX = data_3d.shape[0]\n    cY = data_3d.shape[1]\n    cZ = data_3d.shape[2]\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_3d_copy = data_3d.copy()\n    data_3d = data_3d.reshape(cX * cY * cZ)\n    result = jt.code(data_3d.shape, data_3d.dtype, [data_3d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            const unsigned char pzyx = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbour Connections\\n                            const bool nzm1yx   = (iz > 0) ? (pzyx == @g_image((iz-1)*pY +  iy   *pX + ix  )) : false;\\n                            const bool nzym1x   = (iy > 0) ? (pzyx == @g_image( iz   *pY + (iy-1)*pX + ix  )) : false;\\n                            const bool nzyxm1   = (ix > 0) ? (pzyx == @g_image( iz   *pY +  iy   *pX + ix-1)) : false;\\n\\n                            // Label\\n                            unsigned int label;\\n\\n                            // Initialise Label\\n                            label = (nzyxm1) ? (    iz*pY +     iy*pX + ix-1) : (iz*pY + iy*pX + ix);\\n                            label = (nzym1x) ? (    iz*pY + (iy-1)*pX +   ix) : label;\\n                            label = (nzm1yx) ? ((iz-1)*pY +     iy*pX +   ix) : label;\\n                            // Write to Global Memory\\n                            @g_labels(iz*pY + iy*pX + ix) = label;\\n                        }\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.z * blockDim.z) + threadIdx.z) * pY +\\n                                                ((blockIdx.y * blockDim.y) + threadIdx.y) * pX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY*cZ) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY, const int cZ, const int pX, const int pY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        const unsigned int iz = (blockIdx.z * blockDim.z) + threadIdx.z;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY) && (iz < cZ)) {\\n                            // Get image and label values\\n                            const unsigned char pzyx  = @g_image(iz*pY + iy*pX + ix);\\n                            \\n                            // Neighbouring indexes\\n                            const unsigned int xm1 = ix-1;\\n                            const unsigned int xp1 = ix+1;\\n                            const unsigned int ym1 = iy-1;\\n                            const unsigned int yp1 = iy+1;\\n                            const unsigned int zm1 = iz-1;\\n                            const unsigned int zp1 = iz+1;\\n\\n                            // Get neighbour labels\\n                            const unsigned int lzm1yx = (iz > 0)    ? @g_labels(zm1*pY +  iy*pX +  ix) : 0;\\n                            const unsigned int lzym1x = (iy > 0)    ? @g_labels( iz*pY + ym1*pX +  ix) : 0;\\n                            const unsigned int lzyxm1 = (ix > 0)    ? @g_labels( iz*pY +  iy*pX + xm1) : 0;\\n                            const unsigned int lzyx   =               @g_labels( iz*pY +  iy*pX +  ix);\\n                            const unsigned int lzyxp1 = (ix < cX-1) ? @g_labels( iz*pY +  iy*pX + xp1) : 0;\\n                            const unsigned int lzyp1x = (iy < cY-1) ? @g_labels( iz*pY + yp1*pX +  ix) : 0;\\n                            const unsigned int lzp1yx = (iz < cZ-1) ? @g_labels(zp1*pY +  iy*pX +  ix) : 0;\\n\\n                            const bool nzm1yx = (iz > 0)    ? (pzyx == @g_image(zm1*pY +  iy*pX +  ix)) : false;\\n                            const bool nzym1x = (iy > 0)    ? (pzyx == @g_image( iz*pY + ym1*pX +  ix)) : false;\\n                            const bool nzyxm1 = (ix > 0)    ? (pzyx == @g_image( iz*pY +  iy*pX + xm1)) : false;\\n                            const bool nzyxp1 = (ix < cX-1) ? (pzyx == @g_image( iz*pY +  iy*pX + xp1)) : false;\\n                            const bool nzyp1x = (iy < cY-1) ? (pzyx == @g_image( iz*pY + yp1*pX +  ix)) : false;\\n                            const bool nzp1yx = (iz < cZ-1) ? (pzyx == @g_image(zp1*pY +  iy*pX +  ix)) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lzyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nzm1yx) && (lzm1yx < label)) ? lzm1yx : label;\\n                            label = ((nzym1x) && (lzym1x < label)) ? lzym1x : label;\\n                            label = ((nzyxm1) && (lzyxm1 < label)) ? lzyxm1 : label;\\n                            label = ((nzyxp1) && (lzyxp1 < label)) ? lzyxp1 : label;\\n                            label = ((nzyp1x) && (lzyp1x < label)) ? lzyp1x : label;\\n                            label = ((nzp1yx) && (lzp1yx < label)) ? lzp1yx : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lzyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lzyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 4, 4);\\n                    const int cX= {cX};\\n                    const int cY= {cY};\\n                    const int cZ= {cZ};\\n                    const int pX= cX;\\n                    const int pY= cX*cY;' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y), ceil(cZ/(float)block.z));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY, cZ, pX, pY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< grid, block>>>(@ARGS, cX, cY, cZ, pX, pY);\\n                    }\\n                    ')\n    result = result.reshape((cX, cY, cZ)) * data_3d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result"
        ]
    }
]