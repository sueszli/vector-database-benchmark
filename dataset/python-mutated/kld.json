[
    {
        "func_name": "mutual_information",
        "original": "def mutual_information(data):\n    Q = vaex.utils.disjoined(data)\n    P = data\n    P = P / P.sum()\n    Q = Q / Q.sum()\n    mask = (P > 0) & (Q > 0)\n    information = np.sum(P[mask] * np.log(P[mask] / Q[mask]))\n    return information",
        "mutated": [
            "def mutual_information(data):\n    if False:\n        i = 10\n    Q = vaex.utils.disjoined(data)\n    P = data\n    P = P / P.sum()\n    Q = Q / Q.sum()\n    mask = (P > 0) & (Q > 0)\n    information = np.sum(P[mask] * np.log(P[mask] / Q[mask]))\n    return information",
            "def mutual_information(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Q = vaex.utils.disjoined(data)\n    P = data\n    P = P / P.sum()\n    Q = Q / Q.sum()\n    mask = (P > 0) & (Q > 0)\n    information = np.sum(P[mask] * np.log(P[mask] / Q[mask]))\n    return information",
            "def mutual_information(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Q = vaex.utils.disjoined(data)\n    P = data\n    P = P / P.sum()\n    Q = Q / Q.sum()\n    mask = (P > 0) & (Q > 0)\n    information = np.sum(P[mask] * np.log(P[mask] / Q[mask]))\n    return information",
            "def mutual_information(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Q = vaex.utils.disjoined(data)\n    P = data\n    P = P / P.sum()\n    Q = Q / Q.sum()\n    mask = (P > 0) & (Q > 0)\n    information = np.sum(P[mask] * np.log(P[mask] / Q[mask]))\n    return information",
            "def mutual_information(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Q = vaex.utils.disjoined(data)\n    P = data\n    P = P / P.sum()\n    Q = Q / Q.sum()\n    mask = (P > 0) & (Q > 0)\n    information = np.sum(P[mask] * np.log(P[mask] / Q[mask]))\n    return information"
        ]
    },
    {
        "func_name": "kl_divergence",
        "original": "def kl_divergence(P, Q, axis=None):\n    P = P / P.sum(axis=axis)\n    Q = Q / Q.sum(axis=axis)\n    information = np.sum(P * np.log(P / Q), axis=axis)\n    return information",
        "mutated": [
            "def kl_divergence(P, Q, axis=None):\n    if False:\n        i = 10\n    P = P / P.sum(axis=axis)\n    Q = Q / Q.sum(axis=axis)\n    information = np.sum(P * np.log(P / Q), axis=axis)\n    return information",
            "def kl_divergence(P, Q, axis=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    P = P / P.sum(axis=axis)\n    Q = Q / Q.sum(axis=axis)\n    information = np.sum(P * np.log(P / Q), axis=axis)\n    return information",
            "def kl_divergence(P, Q, axis=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    P = P / P.sum(axis=axis)\n    Q = Q / Q.sum(axis=axis)\n    information = np.sum(P * np.log(P / Q), axis=axis)\n    return information",
            "def kl_divergence(P, Q, axis=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    P = P / P.sum(axis=axis)\n    Q = Q / Q.sum(axis=axis)\n    information = np.sum(P * np.log(P / Q), axis=axis)\n    return information",
            "def kl_divergence(P, Q, axis=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    P = P / P.sum(axis=axis)\n    Q = Q / Q.sum(axis=axis)\n    information = np.sum(P * np.log(P / Q), axis=axis)\n    return information"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, dataset, pairs, gridsize=128):\n    self.dataset = dataset\n    self.pairs = pairs\n    self.dimension = len(self.pairs[0])\n    self.logger = logger.getLogger('kld')\n    self.gridsize = gridsize\n    logger.debug('dimension: %d, pairs: %s' % (self.dimension, self.pairs))",
        "mutated": [
            "def __init__(self, dataset, pairs, gridsize=128):\n    if False:\n        i = 10\n    self.dataset = dataset\n    self.pairs = pairs\n    self.dimension = len(self.pairs[0])\n    self.logger = logger.getLogger('kld')\n    self.gridsize = gridsize\n    logger.debug('dimension: %d, pairs: %s' % (self.dimension, self.pairs))",
            "def __init__(self, dataset, pairs, gridsize=128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.dataset = dataset\n    self.pairs = pairs\n    self.dimension = len(self.pairs[0])\n    self.logger = logger.getLogger('kld')\n    self.gridsize = gridsize\n    logger.debug('dimension: %d, pairs: %s' % (self.dimension, self.pairs))",
            "def __init__(self, dataset, pairs, gridsize=128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.dataset = dataset\n    self.pairs = pairs\n    self.dimension = len(self.pairs[0])\n    self.logger = logger.getLogger('kld')\n    self.gridsize = gridsize\n    logger.debug('dimension: %d, pairs: %s' % (self.dimension, self.pairs))",
            "def __init__(self, dataset, pairs, gridsize=128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.dataset = dataset\n    self.pairs = pairs\n    self.dimension = len(self.pairs[0])\n    self.logger = logger.getLogger('kld')\n    self.gridsize = gridsize\n    logger.debug('dimension: %d, pairs: %s' % (self.dimension, self.pairs))",
            "def __init__(self, dataset, pairs, gridsize=128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.dataset = dataset\n    self.pairs = pairs\n    self.dimension = len(self.pairs[0])\n    self.logger = logger.getLogger('kld')\n    self.gridsize = gridsize\n    logger.debug('dimension: %d, pairs: %s' % (self.dimension, self.pairs))"
        ]
    },
    {
        "func_name": "job",
        "original": "def job(pair):\n    pass",
        "mutated": [
            "def job(pair):\n    if False:\n        i = 10\n    pass",
            "def job(pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def job(pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def job(pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def job(pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "get_jobs",
        "original": "def get_jobs(self):\n\n    def job(pair):\n        pass",
        "mutated": [
            "def get_jobs(self):\n    if False:\n        i = 10\n\n    def job(pair):\n        pass",
            "def get_jobs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def job(pair):\n        pass",
            "def get_jobs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def job(pair):\n        pass",
            "def get_jobs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def job(pair):\n        pass",
            "def get_jobs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def job(pair):\n        pass"
        ]
    },
    {
        "func_name": "to_disjoined",
        "original": "def to_disjoined(counts):\n    shape = counts.shape\n    assert len(counts.shape) == 2\n    counts_0 = counts.sum(axis=1).reshape((shape[0], 1))\n    counts_1 = counts.sum(axis=0).reshape((1, shape[1]))\n    counts_disjoined = counts_0 * counts_1\n    return counts_disjoined",
        "mutated": [
            "def to_disjoined(counts):\n    if False:\n        i = 10\n    shape = counts.shape\n    assert len(counts.shape) == 2\n    counts_0 = counts.sum(axis=1).reshape((shape[0], 1))\n    counts_1 = counts.sum(axis=0).reshape((1, shape[1]))\n    counts_disjoined = counts_0 * counts_1\n    return counts_disjoined",
            "def to_disjoined(counts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    shape = counts.shape\n    assert len(counts.shape) == 2\n    counts_0 = counts.sum(axis=1).reshape((shape[0], 1))\n    counts_1 = counts.sum(axis=0).reshape((1, shape[1]))\n    counts_disjoined = counts_0 * counts_1\n    return counts_disjoined",
            "def to_disjoined(counts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    shape = counts.shape\n    assert len(counts.shape) == 2\n    counts_0 = counts.sum(axis=1).reshape((shape[0], 1))\n    counts_1 = counts.sum(axis=0).reshape((1, shape[1]))\n    counts_disjoined = counts_0 * counts_1\n    return counts_disjoined",
            "def to_disjoined(counts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    shape = counts.shape\n    assert len(counts.shape) == 2\n    counts_0 = counts.sum(axis=1).reshape((shape[0], 1))\n    counts_1 = counts.sum(axis=0).reshape((1, shape[1]))\n    counts_disjoined = counts_0 * counts_1\n    return counts_disjoined",
            "def to_disjoined(counts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    shape = counts.shape\n    assert len(counts.shape) == 2\n    counts_0 = counts.sum(axis=1).reshape((shape[0], 1))\n    counts_1 = counts.sum(axis=0).reshape((1, shape[1]))\n    counts_disjoined = counts_0 * counts_1\n    return counts_disjoined"
        ]
    },
    {
        "func_name": "kld_shuffled",
        "original": "def kld_shuffled(columns, Ngrid=128, datamins=None, datamaxes=None, offset=1):\n    if datamins is None:\n        datamins = np.array([np.nanmin(column) for column in columns])\n    if datamaxes is None:\n        datamaxes = np.array([np.nanmax(column) for column in columns])\n    dim = len(columns)\n    counts = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    counts_shuffled = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    D_kl = -1\n    if len(columns) == 2:\n        (x, y) = columns\n        print((x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset))\n        try:\n            vaex.histogram.hist2d_and_shuffled(x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset)\n        except:\n            args = [x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset]\n            sig = [numba.dispatcher.typeof_pyval(a) for a in args]\n            print(sig)\n            raise\n        print(('counts', sum(counts)))\n        deltax = [float(datamaxes[i] - datamins[i]) for i in range(dim)]\n        dx = np.array([deltax[d] / counts.shape[d] for d in range(dim)])\n        density = counts / np.sum(counts)\n        density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n        mask = (density_shuffled > 0) & (density > 0)\n        D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n    return D_kl",
        "mutated": [
            "def kld_shuffled(columns, Ngrid=128, datamins=None, datamaxes=None, offset=1):\n    if False:\n        i = 10\n    if datamins is None:\n        datamins = np.array([np.nanmin(column) for column in columns])\n    if datamaxes is None:\n        datamaxes = np.array([np.nanmax(column) for column in columns])\n    dim = len(columns)\n    counts = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    counts_shuffled = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    D_kl = -1\n    if len(columns) == 2:\n        (x, y) = columns\n        print((x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset))\n        try:\n            vaex.histogram.hist2d_and_shuffled(x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset)\n        except:\n            args = [x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset]\n            sig = [numba.dispatcher.typeof_pyval(a) for a in args]\n            print(sig)\n            raise\n        print(('counts', sum(counts)))\n        deltax = [float(datamaxes[i] - datamins[i]) for i in range(dim)]\n        dx = np.array([deltax[d] / counts.shape[d] for d in range(dim)])\n        density = counts / np.sum(counts)\n        density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n        mask = (density_shuffled > 0) & (density > 0)\n        D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n    return D_kl",
            "def kld_shuffled(columns, Ngrid=128, datamins=None, datamaxes=None, offset=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if datamins is None:\n        datamins = np.array([np.nanmin(column) for column in columns])\n    if datamaxes is None:\n        datamaxes = np.array([np.nanmax(column) for column in columns])\n    dim = len(columns)\n    counts = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    counts_shuffled = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    D_kl = -1\n    if len(columns) == 2:\n        (x, y) = columns\n        print((x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset))\n        try:\n            vaex.histogram.hist2d_and_shuffled(x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset)\n        except:\n            args = [x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset]\n            sig = [numba.dispatcher.typeof_pyval(a) for a in args]\n            print(sig)\n            raise\n        print(('counts', sum(counts)))\n        deltax = [float(datamaxes[i] - datamins[i]) for i in range(dim)]\n        dx = np.array([deltax[d] / counts.shape[d] for d in range(dim)])\n        density = counts / np.sum(counts)\n        density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n        mask = (density_shuffled > 0) & (density > 0)\n        D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n    return D_kl",
            "def kld_shuffled(columns, Ngrid=128, datamins=None, datamaxes=None, offset=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if datamins is None:\n        datamins = np.array([np.nanmin(column) for column in columns])\n    if datamaxes is None:\n        datamaxes = np.array([np.nanmax(column) for column in columns])\n    dim = len(columns)\n    counts = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    counts_shuffled = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    D_kl = -1\n    if len(columns) == 2:\n        (x, y) = columns\n        print((x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset))\n        try:\n            vaex.histogram.hist2d_and_shuffled(x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset)\n        except:\n            args = [x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset]\n            sig = [numba.dispatcher.typeof_pyval(a) for a in args]\n            print(sig)\n            raise\n        print(('counts', sum(counts)))\n        deltax = [float(datamaxes[i] - datamins[i]) for i in range(dim)]\n        dx = np.array([deltax[d] / counts.shape[d] for d in range(dim)])\n        density = counts / np.sum(counts)\n        density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n        mask = (density_shuffled > 0) & (density > 0)\n        D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n    return D_kl",
            "def kld_shuffled(columns, Ngrid=128, datamins=None, datamaxes=None, offset=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if datamins is None:\n        datamins = np.array([np.nanmin(column) for column in columns])\n    if datamaxes is None:\n        datamaxes = np.array([np.nanmax(column) for column in columns])\n    dim = len(columns)\n    counts = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    counts_shuffled = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    D_kl = -1\n    if len(columns) == 2:\n        (x, y) = columns\n        print((x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset))\n        try:\n            vaex.histogram.hist2d_and_shuffled(x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset)\n        except:\n            args = [x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset]\n            sig = [numba.dispatcher.typeof_pyval(a) for a in args]\n            print(sig)\n            raise\n        print(('counts', sum(counts)))\n        deltax = [float(datamaxes[i] - datamins[i]) for i in range(dim)]\n        dx = np.array([deltax[d] / counts.shape[d] for d in range(dim)])\n        density = counts / np.sum(counts)\n        density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n        mask = (density_shuffled > 0) & (density > 0)\n        D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n    return D_kl",
            "def kld_shuffled(columns, Ngrid=128, datamins=None, datamaxes=None, offset=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if datamins is None:\n        datamins = np.array([np.nanmin(column) for column in columns])\n    if datamaxes is None:\n        datamaxes = np.array([np.nanmax(column) for column in columns])\n    dim = len(columns)\n    counts = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    counts_shuffled = np.zeros((Ngrid,) * dim, dtype=np.float64)\n    D_kl = -1\n    if len(columns) == 2:\n        (x, y) = columns\n        print((x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset))\n        try:\n            vaex.histogram.hist2d_and_shuffled(x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset)\n        except:\n            args = [x, y, counts, counts_shuffled, datamins[0], datamaxes[0], datamins[1], datamaxes[1], offset]\n            sig = [numba.dispatcher.typeof_pyval(a) for a in args]\n            print(sig)\n            raise\n        print(('counts', sum(counts)))\n        deltax = [float(datamaxes[i] - datamins[i]) for i in range(dim)]\n        dx = np.array([deltax[d] / counts.shape[d] for d in range(dim)])\n        density = counts / np.sum(counts)\n        density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n        mask = (density_shuffled > 0) & (density > 0)\n        D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n    return D_kl"
        ]
    },
    {
        "func_name": "grid",
        "original": "def grid(info, *blocks, **kwargs):\n    index = kwargs['index']\n    if use_mask and dataset.mask is not None:\n        mask = dataset.mask[info.i1:info.i2]\n        blocks = [block[mask] for block in blocks]\n    else:\n        mask = None\n    ranges = []\n    minima = []\n    maxima = []\n    for dim in range(dimension):\n        ranges += list(range_map[pairs[index][dim]])\n        (mi, ma) = range_map[pairs[index][dim]]\n        minima.append(mi)\n        maxima.append(ma)\n    if len(blocks) == 2:\n        print(('mask', mask))\n        vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n    if len(blocks) == 3:\n        vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n    if len(blocks) > 3:\n        vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n    if feedback:\n        wrapper.N_done += len(blocks[0]) * dimension\n        if feedback:\n            cancel = feedback(wrapper.N_done * 100.0 / N_total)\n            if cancel:\n                raise Exception('cancelled')",
        "mutated": [
            "def grid(info, *blocks, **kwargs):\n    if False:\n        i = 10\n    index = kwargs['index']\n    if use_mask and dataset.mask is not None:\n        mask = dataset.mask[info.i1:info.i2]\n        blocks = [block[mask] for block in blocks]\n    else:\n        mask = None\n    ranges = []\n    minima = []\n    maxima = []\n    for dim in range(dimension):\n        ranges += list(range_map[pairs[index][dim]])\n        (mi, ma) = range_map[pairs[index][dim]]\n        minima.append(mi)\n        maxima.append(ma)\n    if len(blocks) == 2:\n        print(('mask', mask))\n        vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n    if len(blocks) == 3:\n        vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n    if len(blocks) > 3:\n        vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n    if feedback:\n        wrapper.N_done += len(blocks[0]) * dimension\n        if feedback:\n            cancel = feedback(wrapper.N_done * 100.0 / N_total)\n            if cancel:\n                raise Exception('cancelled')",
            "def grid(info, *blocks, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    index = kwargs['index']\n    if use_mask and dataset.mask is not None:\n        mask = dataset.mask[info.i1:info.i2]\n        blocks = [block[mask] for block in blocks]\n    else:\n        mask = None\n    ranges = []\n    minima = []\n    maxima = []\n    for dim in range(dimension):\n        ranges += list(range_map[pairs[index][dim]])\n        (mi, ma) = range_map[pairs[index][dim]]\n        minima.append(mi)\n        maxima.append(ma)\n    if len(blocks) == 2:\n        print(('mask', mask))\n        vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n    if len(blocks) == 3:\n        vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n    if len(blocks) > 3:\n        vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n    if feedback:\n        wrapper.N_done += len(blocks[0]) * dimension\n        if feedback:\n            cancel = feedback(wrapper.N_done * 100.0 / N_total)\n            if cancel:\n                raise Exception('cancelled')",
            "def grid(info, *blocks, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    index = kwargs['index']\n    if use_mask and dataset.mask is not None:\n        mask = dataset.mask[info.i1:info.i2]\n        blocks = [block[mask] for block in blocks]\n    else:\n        mask = None\n    ranges = []\n    minima = []\n    maxima = []\n    for dim in range(dimension):\n        ranges += list(range_map[pairs[index][dim]])\n        (mi, ma) = range_map[pairs[index][dim]]\n        minima.append(mi)\n        maxima.append(ma)\n    if len(blocks) == 2:\n        print(('mask', mask))\n        vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n    if len(blocks) == 3:\n        vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n    if len(blocks) > 3:\n        vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n    if feedback:\n        wrapper.N_done += len(blocks[0]) * dimension\n        if feedback:\n            cancel = feedback(wrapper.N_done * 100.0 / N_total)\n            if cancel:\n                raise Exception('cancelled')",
            "def grid(info, *blocks, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    index = kwargs['index']\n    if use_mask and dataset.mask is not None:\n        mask = dataset.mask[info.i1:info.i2]\n        blocks = [block[mask] for block in blocks]\n    else:\n        mask = None\n    ranges = []\n    minima = []\n    maxima = []\n    for dim in range(dimension):\n        ranges += list(range_map[pairs[index][dim]])\n        (mi, ma) = range_map[pairs[index][dim]]\n        minima.append(mi)\n        maxima.append(ma)\n    if len(blocks) == 2:\n        print(('mask', mask))\n        vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n    if len(blocks) == 3:\n        vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n    if len(blocks) > 3:\n        vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n    if feedback:\n        wrapper.N_done += len(blocks[0]) * dimension\n        if feedback:\n            cancel = feedback(wrapper.N_done * 100.0 / N_total)\n            if cancel:\n                raise Exception('cancelled')",
            "def grid(info, *blocks, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    index = kwargs['index']\n    if use_mask and dataset.mask is not None:\n        mask = dataset.mask[info.i1:info.i2]\n        blocks = [block[mask] for block in blocks]\n    else:\n        mask = None\n    ranges = []\n    minima = []\n    maxima = []\n    for dim in range(dimension):\n        ranges += list(range_map[pairs[index][dim]])\n        (mi, ma) = range_map[pairs[index][dim]]\n        minima.append(mi)\n        maxima.append(ma)\n    if len(blocks) == 2:\n        print(('mask', mask))\n        vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n    if len(blocks) == 3:\n        vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n    if len(blocks) > 3:\n        vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n    if feedback:\n        wrapper.N_done += len(blocks[0]) * dimension\n        if feedback:\n            cancel = feedback(wrapper.N_done * 100.0 / N_total)\n            if cancel:\n                raise Exception('cancelled')"
        ]
    },
    {
        "func_name": "kld_shuffled_grouped",
        "original": "def kld_shuffled_grouped(dataset, range_map, pairs, feedback=None, size_grid=32, use_mask=True, bytes_max=int(1024 ** 3 / 2)):\n    dimension = len(pairs[0])\n    bytes_per_grid = size_grid ** dimension * 8\n    grids_per_iteration = min(128, int(bytes_max / bytes_per_grid))\n    iterations = int(math.ceil(len(pairs) * 1.0 / grids_per_iteration))\n    jobsManager = vaex.dataset.JobsManager()\n    ranges = [None] * len(pairs)\n    D_kls = []\n\n    class Wrapper(object):\n        pass\n    wrapper = Wrapper()\n    wrapper.N_done = 0\n    counts = np.zeros((grids_per_iteration,) + (size_grid,) * dimension, dtype=np.float64)\n    N_total = len(pairs) * len(dataset) * dimension + len(pairs) * counts.size\n    logger.debug('{iterations} iterations with {grids_per_iteration} grids per iteration'.format(**locals()))\n    for part in range(iterations):\n        if part > 0:\n            counts.reshape(-1)[:] = 0\n        (i1, i2) = (part * grids_per_iteration, (part + 1) * grids_per_iteration)\n        if i2 > len(pairs):\n            i2 = len(pairs)\n        n_grids = i2 - i1\n        logger.debug('part {part} of {iterations}, from {i1} to {i2}'.format(**locals()))\n\n        def grid(info, *blocks, **kwargs):\n            index = kwargs['index']\n            if use_mask and dataset.mask is not None:\n                mask = dataset.mask[info.i1:info.i2]\n                blocks = [block[mask] for block in blocks]\n            else:\n                mask = None\n            ranges = []\n            minima = []\n            maxima = []\n            for dim in range(dimension):\n                ranges += list(range_map[pairs[index][dim]])\n                (mi, ma) = range_map[pairs[index][dim]]\n                minima.append(mi)\n                maxima.append(ma)\n            if len(blocks) == 2:\n                print(('mask', mask))\n                vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n            if len(blocks) == 3:\n                vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n            if len(blocks) > 3:\n                vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n            if feedback:\n                wrapper.N_done += len(blocks[0]) * dimension\n                if feedback:\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        raise Exception('cancelled')\n        for (index, pair) in zip(list(range(i1, i2)), pairs[i1:i2]):\n            logger.debug('add job %r %r' % (index, pair))\n            jobsManager.addJob(0, functools.partial(grid, index=index - i1), dataset, *pair)\n        jobsManager.execute()\n        with Timer('D_kl'):\n            for i in range(n_grids):\n                if 0:\n                    deltax = [float(range_map[pairs[i][d]][1] - range_map[pairs[i][d]][0]) for d in range(dimension)]\n                    dx = np.array([deltax[d] / counts[i].shape[d] for d in range(dimension)])\n                    density = counts[i] / np.sum(counts[i])\n                    counts_shuffled = to_disjoined(counts[i])\n                    density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n                    mask = (density_shuffled > 0) & (density > 0)\n                    print(('mask sum', np.sum(mask)))\n                    print(('mask sum', np.sum((counts_shuffled > 0) & (counts[i] > 0))))\n                    D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n                else:\n                    D_kl = mutual_information(counts[i])\n                D_kls.append(D_kl)\n                if feedback:\n                    wrapper.N_done += counts.size\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        return None\n    return D_kls",
        "mutated": [
            "def kld_shuffled_grouped(dataset, range_map, pairs, feedback=None, size_grid=32, use_mask=True, bytes_max=int(1024 ** 3 / 2)):\n    if False:\n        i = 10\n    dimension = len(pairs[0])\n    bytes_per_grid = size_grid ** dimension * 8\n    grids_per_iteration = min(128, int(bytes_max / bytes_per_grid))\n    iterations = int(math.ceil(len(pairs) * 1.0 / grids_per_iteration))\n    jobsManager = vaex.dataset.JobsManager()\n    ranges = [None] * len(pairs)\n    D_kls = []\n\n    class Wrapper(object):\n        pass\n    wrapper = Wrapper()\n    wrapper.N_done = 0\n    counts = np.zeros((grids_per_iteration,) + (size_grid,) * dimension, dtype=np.float64)\n    N_total = len(pairs) * len(dataset) * dimension + len(pairs) * counts.size\n    logger.debug('{iterations} iterations with {grids_per_iteration} grids per iteration'.format(**locals()))\n    for part in range(iterations):\n        if part > 0:\n            counts.reshape(-1)[:] = 0\n        (i1, i2) = (part * grids_per_iteration, (part + 1) * grids_per_iteration)\n        if i2 > len(pairs):\n            i2 = len(pairs)\n        n_grids = i2 - i1\n        logger.debug('part {part} of {iterations}, from {i1} to {i2}'.format(**locals()))\n\n        def grid(info, *blocks, **kwargs):\n            index = kwargs['index']\n            if use_mask and dataset.mask is not None:\n                mask = dataset.mask[info.i1:info.i2]\n                blocks = [block[mask] for block in blocks]\n            else:\n                mask = None\n            ranges = []\n            minima = []\n            maxima = []\n            for dim in range(dimension):\n                ranges += list(range_map[pairs[index][dim]])\n                (mi, ma) = range_map[pairs[index][dim]]\n                minima.append(mi)\n                maxima.append(ma)\n            if len(blocks) == 2:\n                print(('mask', mask))\n                vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n            if len(blocks) == 3:\n                vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n            if len(blocks) > 3:\n                vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n            if feedback:\n                wrapper.N_done += len(blocks[0]) * dimension\n                if feedback:\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        raise Exception('cancelled')\n        for (index, pair) in zip(list(range(i1, i2)), pairs[i1:i2]):\n            logger.debug('add job %r %r' % (index, pair))\n            jobsManager.addJob(0, functools.partial(grid, index=index - i1), dataset, *pair)\n        jobsManager.execute()\n        with Timer('D_kl'):\n            for i in range(n_grids):\n                if 0:\n                    deltax = [float(range_map[pairs[i][d]][1] - range_map[pairs[i][d]][0]) for d in range(dimension)]\n                    dx = np.array([deltax[d] / counts[i].shape[d] for d in range(dimension)])\n                    density = counts[i] / np.sum(counts[i])\n                    counts_shuffled = to_disjoined(counts[i])\n                    density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n                    mask = (density_shuffled > 0) & (density > 0)\n                    print(('mask sum', np.sum(mask)))\n                    print(('mask sum', np.sum((counts_shuffled > 0) & (counts[i] > 0))))\n                    D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n                else:\n                    D_kl = mutual_information(counts[i])\n                D_kls.append(D_kl)\n                if feedback:\n                    wrapper.N_done += counts.size\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        return None\n    return D_kls",
            "def kld_shuffled_grouped(dataset, range_map, pairs, feedback=None, size_grid=32, use_mask=True, bytes_max=int(1024 ** 3 / 2)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dimension = len(pairs[0])\n    bytes_per_grid = size_grid ** dimension * 8\n    grids_per_iteration = min(128, int(bytes_max / bytes_per_grid))\n    iterations = int(math.ceil(len(pairs) * 1.0 / grids_per_iteration))\n    jobsManager = vaex.dataset.JobsManager()\n    ranges = [None] * len(pairs)\n    D_kls = []\n\n    class Wrapper(object):\n        pass\n    wrapper = Wrapper()\n    wrapper.N_done = 0\n    counts = np.zeros((grids_per_iteration,) + (size_grid,) * dimension, dtype=np.float64)\n    N_total = len(pairs) * len(dataset) * dimension + len(pairs) * counts.size\n    logger.debug('{iterations} iterations with {grids_per_iteration} grids per iteration'.format(**locals()))\n    for part in range(iterations):\n        if part > 0:\n            counts.reshape(-1)[:] = 0\n        (i1, i2) = (part * grids_per_iteration, (part + 1) * grids_per_iteration)\n        if i2 > len(pairs):\n            i2 = len(pairs)\n        n_grids = i2 - i1\n        logger.debug('part {part} of {iterations}, from {i1} to {i2}'.format(**locals()))\n\n        def grid(info, *blocks, **kwargs):\n            index = kwargs['index']\n            if use_mask and dataset.mask is not None:\n                mask = dataset.mask[info.i1:info.i2]\n                blocks = [block[mask] for block in blocks]\n            else:\n                mask = None\n            ranges = []\n            minima = []\n            maxima = []\n            for dim in range(dimension):\n                ranges += list(range_map[pairs[index][dim]])\n                (mi, ma) = range_map[pairs[index][dim]]\n                minima.append(mi)\n                maxima.append(ma)\n            if len(blocks) == 2:\n                print(('mask', mask))\n                vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n            if len(blocks) == 3:\n                vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n            if len(blocks) > 3:\n                vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n            if feedback:\n                wrapper.N_done += len(blocks[0]) * dimension\n                if feedback:\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        raise Exception('cancelled')\n        for (index, pair) in zip(list(range(i1, i2)), pairs[i1:i2]):\n            logger.debug('add job %r %r' % (index, pair))\n            jobsManager.addJob(0, functools.partial(grid, index=index - i1), dataset, *pair)\n        jobsManager.execute()\n        with Timer('D_kl'):\n            for i in range(n_grids):\n                if 0:\n                    deltax = [float(range_map[pairs[i][d]][1] - range_map[pairs[i][d]][0]) for d in range(dimension)]\n                    dx = np.array([deltax[d] / counts[i].shape[d] for d in range(dimension)])\n                    density = counts[i] / np.sum(counts[i])\n                    counts_shuffled = to_disjoined(counts[i])\n                    density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n                    mask = (density_shuffled > 0) & (density > 0)\n                    print(('mask sum', np.sum(mask)))\n                    print(('mask sum', np.sum((counts_shuffled > 0) & (counts[i] > 0))))\n                    D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n                else:\n                    D_kl = mutual_information(counts[i])\n                D_kls.append(D_kl)\n                if feedback:\n                    wrapper.N_done += counts.size\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        return None\n    return D_kls",
            "def kld_shuffled_grouped(dataset, range_map, pairs, feedback=None, size_grid=32, use_mask=True, bytes_max=int(1024 ** 3 / 2)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dimension = len(pairs[0])\n    bytes_per_grid = size_grid ** dimension * 8\n    grids_per_iteration = min(128, int(bytes_max / bytes_per_grid))\n    iterations = int(math.ceil(len(pairs) * 1.0 / grids_per_iteration))\n    jobsManager = vaex.dataset.JobsManager()\n    ranges = [None] * len(pairs)\n    D_kls = []\n\n    class Wrapper(object):\n        pass\n    wrapper = Wrapper()\n    wrapper.N_done = 0\n    counts = np.zeros((grids_per_iteration,) + (size_grid,) * dimension, dtype=np.float64)\n    N_total = len(pairs) * len(dataset) * dimension + len(pairs) * counts.size\n    logger.debug('{iterations} iterations with {grids_per_iteration} grids per iteration'.format(**locals()))\n    for part in range(iterations):\n        if part > 0:\n            counts.reshape(-1)[:] = 0\n        (i1, i2) = (part * grids_per_iteration, (part + 1) * grids_per_iteration)\n        if i2 > len(pairs):\n            i2 = len(pairs)\n        n_grids = i2 - i1\n        logger.debug('part {part} of {iterations}, from {i1} to {i2}'.format(**locals()))\n\n        def grid(info, *blocks, **kwargs):\n            index = kwargs['index']\n            if use_mask and dataset.mask is not None:\n                mask = dataset.mask[info.i1:info.i2]\n                blocks = [block[mask] for block in blocks]\n            else:\n                mask = None\n            ranges = []\n            minima = []\n            maxima = []\n            for dim in range(dimension):\n                ranges += list(range_map[pairs[index][dim]])\n                (mi, ma) = range_map[pairs[index][dim]]\n                minima.append(mi)\n                maxima.append(ma)\n            if len(blocks) == 2:\n                print(('mask', mask))\n                vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n            if len(blocks) == 3:\n                vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n            if len(blocks) > 3:\n                vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n            if feedback:\n                wrapper.N_done += len(blocks[0]) * dimension\n                if feedback:\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        raise Exception('cancelled')\n        for (index, pair) in zip(list(range(i1, i2)), pairs[i1:i2]):\n            logger.debug('add job %r %r' % (index, pair))\n            jobsManager.addJob(0, functools.partial(grid, index=index - i1), dataset, *pair)\n        jobsManager.execute()\n        with Timer('D_kl'):\n            for i in range(n_grids):\n                if 0:\n                    deltax = [float(range_map[pairs[i][d]][1] - range_map[pairs[i][d]][0]) for d in range(dimension)]\n                    dx = np.array([deltax[d] / counts[i].shape[d] for d in range(dimension)])\n                    density = counts[i] / np.sum(counts[i])\n                    counts_shuffled = to_disjoined(counts[i])\n                    density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n                    mask = (density_shuffled > 0) & (density > 0)\n                    print(('mask sum', np.sum(mask)))\n                    print(('mask sum', np.sum((counts_shuffled > 0) & (counts[i] > 0))))\n                    D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n                else:\n                    D_kl = mutual_information(counts[i])\n                D_kls.append(D_kl)\n                if feedback:\n                    wrapper.N_done += counts.size\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        return None\n    return D_kls",
            "def kld_shuffled_grouped(dataset, range_map, pairs, feedback=None, size_grid=32, use_mask=True, bytes_max=int(1024 ** 3 / 2)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dimension = len(pairs[0])\n    bytes_per_grid = size_grid ** dimension * 8\n    grids_per_iteration = min(128, int(bytes_max / bytes_per_grid))\n    iterations = int(math.ceil(len(pairs) * 1.0 / grids_per_iteration))\n    jobsManager = vaex.dataset.JobsManager()\n    ranges = [None] * len(pairs)\n    D_kls = []\n\n    class Wrapper(object):\n        pass\n    wrapper = Wrapper()\n    wrapper.N_done = 0\n    counts = np.zeros((grids_per_iteration,) + (size_grid,) * dimension, dtype=np.float64)\n    N_total = len(pairs) * len(dataset) * dimension + len(pairs) * counts.size\n    logger.debug('{iterations} iterations with {grids_per_iteration} grids per iteration'.format(**locals()))\n    for part in range(iterations):\n        if part > 0:\n            counts.reshape(-1)[:] = 0\n        (i1, i2) = (part * grids_per_iteration, (part + 1) * grids_per_iteration)\n        if i2 > len(pairs):\n            i2 = len(pairs)\n        n_grids = i2 - i1\n        logger.debug('part {part} of {iterations}, from {i1} to {i2}'.format(**locals()))\n\n        def grid(info, *blocks, **kwargs):\n            index = kwargs['index']\n            if use_mask and dataset.mask is not None:\n                mask = dataset.mask[info.i1:info.i2]\n                blocks = [block[mask] for block in blocks]\n            else:\n                mask = None\n            ranges = []\n            minima = []\n            maxima = []\n            for dim in range(dimension):\n                ranges += list(range_map[pairs[index][dim]])\n                (mi, ma) = range_map[pairs[index][dim]]\n                minima.append(mi)\n                maxima.append(ma)\n            if len(blocks) == 2:\n                print(('mask', mask))\n                vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n            if len(blocks) == 3:\n                vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n            if len(blocks) > 3:\n                vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n            if feedback:\n                wrapper.N_done += len(blocks[0]) * dimension\n                if feedback:\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        raise Exception('cancelled')\n        for (index, pair) in zip(list(range(i1, i2)), pairs[i1:i2]):\n            logger.debug('add job %r %r' % (index, pair))\n            jobsManager.addJob(0, functools.partial(grid, index=index - i1), dataset, *pair)\n        jobsManager.execute()\n        with Timer('D_kl'):\n            for i in range(n_grids):\n                if 0:\n                    deltax = [float(range_map[pairs[i][d]][1] - range_map[pairs[i][d]][0]) for d in range(dimension)]\n                    dx = np.array([deltax[d] / counts[i].shape[d] for d in range(dimension)])\n                    density = counts[i] / np.sum(counts[i])\n                    counts_shuffled = to_disjoined(counts[i])\n                    density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n                    mask = (density_shuffled > 0) & (density > 0)\n                    print(('mask sum', np.sum(mask)))\n                    print(('mask sum', np.sum((counts_shuffled > 0) & (counts[i] > 0))))\n                    D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n                else:\n                    D_kl = mutual_information(counts[i])\n                D_kls.append(D_kl)\n                if feedback:\n                    wrapper.N_done += counts.size\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        return None\n    return D_kls",
            "def kld_shuffled_grouped(dataset, range_map, pairs, feedback=None, size_grid=32, use_mask=True, bytes_max=int(1024 ** 3 / 2)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dimension = len(pairs[0])\n    bytes_per_grid = size_grid ** dimension * 8\n    grids_per_iteration = min(128, int(bytes_max / bytes_per_grid))\n    iterations = int(math.ceil(len(pairs) * 1.0 / grids_per_iteration))\n    jobsManager = vaex.dataset.JobsManager()\n    ranges = [None] * len(pairs)\n    D_kls = []\n\n    class Wrapper(object):\n        pass\n    wrapper = Wrapper()\n    wrapper.N_done = 0\n    counts = np.zeros((grids_per_iteration,) + (size_grid,) * dimension, dtype=np.float64)\n    N_total = len(pairs) * len(dataset) * dimension + len(pairs) * counts.size\n    logger.debug('{iterations} iterations with {grids_per_iteration} grids per iteration'.format(**locals()))\n    for part in range(iterations):\n        if part > 0:\n            counts.reshape(-1)[:] = 0\n        (i1, i2) = (part * grids_per_iteration, (part + 1) * grids_per_iteration)\n        if i2 > len(pairs):\n            i2 = len(pairs)\n        n_grids = i2 - i1\n        logger.debug('part {part} of {iterations}, from {i1} to {i2}'.format(**locals()))\n\n        def grid(info, *blocks, **kwargs):\n            index = kwargs['index']\n            if use_mask and dataset.mask is not None:\n                mask = dataset.mask[info.i1:info.i2]\n                blocks = [block[mask] for block in blocks]\n            else:\n                mask = None\n            ranges = []\n            minima = []\n            maxima = []\n            for dim in range(dimension):\n                ranges += list(range_map[pairs[index][dim]])\n                (mi, ma) = range_map[pairs[index][dim]]\n                minima.append(mi)\n                maxima.append(ma)\n            if len(blocks) == 2:\n                print(('mask', mask))\n                vaex.vaexfast.histogram2d(blocks[0], blocks[1], None, counts[index], *ranges + [0, 0])\n            if len(blocks) == 3:\n                vaex.vaexfast.histogram3d(blocks[0], blocks[1], blocks[2], None, counts[index], *ranges + [0, 0, 0])\n            if len(blocks) > 3:\n                vaex.vaexfast.histogramNd(list(blocks), None, counts[index], minima, maxima)\n            if feedback:\n                wrapper.N_done += len(blocks[0]) * dimension\n                if feedback:\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        raise Exception('cancelled')\n        for (index, pair) in zip(list(range(i1, i2)), pairs[i1:i2]):\n            logger.debug('add job %r %r' % (index, pair))\n            jobsManager.addJob(0, functools.partial(grid, index=index - i1), dataset, *pair)\n        jobsManager.execute()\n        with Timer('D_kl'):\n            for i in range(n_grids):\n                if 0:\n                    deltax = [float(range_map[pairs[i][d]][1] - range_map[pairs[i][d]][0]) for d in range(dimension)]\n                    dx = np.array([deltax[d] / counts[i].shape[d] for d in range(dimension)])\n                    density = counts[i] / np.sum(counts[i])\n                    counts_shuffled = to_disjoined(counts[i])\n                    density_shuffled = counts_shuffled / np.sum(counts_shuffled)\n                    mask = (density_shuffled > 0) & (density > 0)\n                    print(('mask sum', np.sum(mask)))\n                    print(('mask sum', np.sum((counts_shuffled > 0) & (counts[i] > 0))))\n                    D_kl = np.sum(density[mask] * np.log(density[mask] / density_shuffled[mask]))\n                else:\n                    D_kl = mutual_information(counts[i])\n                D_kls.append(D_kl)\n                if feedback:\n                    wrapper.N_done += counts.size\n                    cancel = feedback(wrapper.N_done * 100.0 / N_total)\n                    if cancel:\n                        return None\n    return D_kls"
        ]
    }
]