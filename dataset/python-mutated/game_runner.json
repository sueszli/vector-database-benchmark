[
    {
        "func_name": "construct_game_queries",
        "original": "def construct_game_queries(base_profile, num_checkpts):\n    \"\"\"Constructs a list of checkpoint selection tuples to query value function.\n\n  Each query tuple (key, query) where key = (pi, pj) and query is\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\n  game of diplomacy to be played. It may be necessary to play several games with\n  the same players to form an accurate estimate of the value or payoff for each\n  player as checkpts contain stochastic policies.\n\n  Args:\n    base_profile: list of selected checkpts for each player, i.e.,\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\n    num_checkpts: list of ints, number of strats (or ckpts) per player\n  Returns:\n    Set of query tuples containing a selected checkpoint index for each player.\n  \"\"\"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            for aj in range(num_checkpts[pj]):\n                new_profile[pj] = aj\n                query = tuple(new_profile)\n                pair = (pi, pj)\n                new_queries.update([(pair, query)])\n    return new_queries",
        "mutated": [
            "def construct_game_queries(base_profile, num_checkpts):\n    if False:\n        i = 10\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi, pj) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            for aj in range(num_checkpts[pj]):\n                new_profile[pj] = aj\n                query = tuple(new_profile)\n                pair = (pi, pj)\n                new_queries.update([(pair, query)])\n    return new_queries",
            "def construct_game_queries(base_profile, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi, pj) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            for aj in range(num_checkpts[pj]):\n                new_profile[pj] = aj\n                query = tuple(new_profile)\n                pair = (pi, pj)\n                new_queries.update([(pair, query)])\n    return new_queries",
            "def construct_game_queries(base_profile, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi, pj) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            for aj in range(num_checkpts[pj]):\n                new_profile[pj] = aj\n                query = tuple(new_profile)\n                pair = (pi, pj)\n                new_queries.update([(pair, query)])\n    return new_queries",
            "def construct_game_queries(base_profile, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi, pj) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            for aj in range(num_checkpts[pj]):\n                new_profile[pj] = aj\n                query = tuple(new_profile)\n                pair = (pi, pj)\n                new_queries.update([(pair, query)])\n    return new_queries",
            "def construct_game_queries(base_profile, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi, pj) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            for aj in range(num_checkpts[pj]):\n                new_profile[pj] = aj\n                query = tuple(new_profile)\n                pair = (pi, pj)\n                new_queries.update([(pair, query)])\n    return new_queries"
        ]
    },
    {
        "func_name": "construct_game_queries_for_exp",
        "original": "def construct_game_queries_for_exp(base_profile, num_checkpts):\n    \"\"\"Constructs a list of checkpoint selection tuples to query value function.\n\n  Each query tuple (key, query) where key = (pi,) and query is\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\n  game of diplomacy to be played. It may be necessary to play several games with\n  the same players to form an accurate estimate of the value or payoff for each\n  player as checkpts contain stochastic policies.\n\n  Args:\n    base_profile: list of selected checkpts for each player, i.e.,\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\n    num_checkpts: list of ints, number of strats (or ckpts) per player\n  Returns:\n    Set of query tuples containing a selected checkpoint index for each player.\n  \"\"\"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for pi in range(num_players):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            query = tuple(new_profile)\n            new_queries.update([(pi, query)])\n    return new_queries",
        "mutated": [
            "def construct_game_queries_for_exp(base_profile, num_checkpts):\n    if False:\n        i = 10\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi,) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for pi in range(num_players):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            query = tuple(new_profile)\n            new_queries.update([(pi, query)])\n    return new_queries",
            "def construct_game_queries_for_exp(base_profile, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi,) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for pi in range(num_players):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            query = tuple(new_profile)\n            new_queries.update([(pi, query)])\n    return new_queries",
            "def construct_game_queries_for_exp(base_profile, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi,) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for pi in range(num_players):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            query = tuple(new_profile)\n            new_queries.update([(pi, query)])\n    return new_queries",
            "def construct_game_queries_for_exp(base_profile, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi,) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for pi in range(num_players):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            query = tuple(new_profile)\n            new_queries.update([(pi, query)])\n    return new_queries",
            "def construct_game_queries_for_exp(base_profile, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Constructs a list of checkpoint selection tuples to query value function.\\n\\n  Each query tuple (key, query) where key = (pi,) and query is\\n  (p1's selected checkpt, ..., p7's selected checkpt) fixes the players in the\\n  game of diplomacy to be played. It may be necessary to play several games with\\n  the same players to form an accurate estimate of the value or payoff for each\\n  player as checkpts contain stochastic policies.\\n\\n  Args:\\n    base_profile: list of selected checkpts for each player, i.e.,\\n      a sample from the player strategy profile ([x_i ~ p(x_i)])\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    Set of query tuples containing a selected checkpoint index for each player.\\n  \"\n    new_queries = set([])\n    num_players = len(base_profile)\n    for pi in range(num_players):\n        new_profile = list(base_profile)\n        for ai in range(num_checkpts[pi]):\n            new_profile[pi] = ai\n            query = tuple(new_profile)\n            new_queries.update([(pi, query)])\n    return new_queries"
        ]
    },
    {
        "func_name": "run_games_and_record_payoffs",
        "original": "def run_games_and_record_payoffs(game_queries, evaluate_game, ckpt_to_policy):\n    \"\"\"Simulate games according to game queries and return results.\n\n  Args:\n    game_queries: set of tuples containing indices specifying each players strat\n      key_query = (agent_tuple, profile_tuple) format\n    evaluate_game: callable function that takes a list of policies as argument\n    ckpt_to_policy: list of maps from strat (or checkpoint) to a policy, one\n      map for each player\n  Returns:\n    dictionary: key=key_query, value=np.array of payoffs (1 for each player)\n  \"\"\"\n    game_results = {}\n    for key_query in game_queries:\n        (_, query) = key_query\n        policies = [ckpt_to_policy[pi][ckpt_i] for (pi, ckpt_i) in enumerate(query)]\n        payoffs = evaluate_game(policies)\n        game_results.update({key_query: payoffs})\n    return game_results",
        "mutated": [
            "def run_games_and_record_payoffs(game_queries, evaluate_game, ckpt_to_policy):\n    if False:\n        i = 10\n    'Simulate games according to game queries and return results.\\n\\n  Args:\\n    game_queries: set of tuples containing indices specifying each players strat\\n      key_query = (agent_tuple, profile_tuple) format\\n    evaluate_game: callable function that takes a list of policies as argument\\n    ckpt_to_policy: list of maps from strat (or checkpoint) to a policy, one\\n      map for each player\\n  Returns:\\n    dictionary: key=key_query, value=np.array of payoffs (1 for each player)\\n  '\n    game_results = {}\n    for key_query in game_queries:\n        (_, query) = key_query\n        policies = [ckpt_to_policy[pi][ckpt_i] for (pi, ckpt_i) in enumerate(query)]\n        payoffs = evaluate_game(policies)\n        game_results.update({key_query: payoffs})\n    return game_results",
            "def run_games_and_record_payoffs(game_queries, evaluate_game, ckpt_to_policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Simulate games according to game queries and return results.\\n\\n  Args:\\n    game_queries: set of tuples containing indices specifying each players strat\\n      key_query = (agent_tuple, profile_tuple) format\\n    evaluate_game: callable function that takes a list of policies as argument\\n    ckpt_to_policy: list of maps from strat (or checkpoint) to a policy, one\\n      map for each player\\n  Returns:\\n    dictionary: key=key_query, value=np.array of payoffs (1 for each player)\\n  '\n    game_results = {}\n    for key_query in game_queries:\n        (_, query) = key_query\n        policies = [ckpt_to_policy[pi][ckpt_i] for (pi, ckpt_i) in enumerate(query)]\n        payoffs = evaluate_game(policies)\n        game_results.update({key_query: payoffs})\n    return game_results",
            "def run_games_and_record_payoffs(game_queries, evaluate_game, ckpt_to_policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Simulate games according to game queries and return results.\\n\\n  Args:\\n    game_queries: set of tuples containing indices specifying each players strat\\n      key_query = (agent_tuple, profile_tuple) format\\n    evaluate_game: callable function that takes a list of policies as argument\\n    ckpt_to_policy: list of maps from strat (or checkpoint) to a policy, one\\n      map for each player\\n  Returns:\\n    dictionary: key=key_query, value=np.array of payoffs (1 for each player)\\n  '\n    game_results = {}\n    for key_query in game_queries:\n        (_, query) = key_query\n        policies = [ckpt_to_policy[pi][ckpt_i] for (pi, ckpt_i) in enumerate(query)]\n        payoffs = evaluate_game(policies)\n        game_results.update({key_query: payoffs})\n    return game_results",
            "def run_games_and_record_payoffs(game_queries, evaluate_game, ckpt_to_policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Simulate games according to game queries and return results.\\n\\n  Args:\\n    game_queries: set of tuples containing indices specifying each players strat\\n      key_query = (agent_tuple, profile_tuple) format\\n    evaluate_game: callable function that takes a list of policies as argument\\n    ckpt_to_policy: list of maps from strat (or checkpoint) to a policy, one\\n      map for each player\\n  Returns:\\n    dictionary: key=key_query, value=np.array of payoffs (1 for each player)\\n  '\n    game_results = {}\n    for key_query in game_queries:\n        (_, query) = key_query\n        policies = [ckpt_to_policy[pi][ckpt_i] for (pi, ckpt_i) in enumerate(query)]\n        payoffs = evaluate_game(policies)\n        game_results.update({key_query: payoffs})\n    return game_results",
            "def run_games_and_record_payoffs(game_queries, evaluate_game, ckpt_to_policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Simulate games according to game queries and return results.\\n\\n  Args:\\n    game_queries: set of tuples containing indices specifying each players strat\\n      key_query = (agent_tuple, profile_tuple) format\\n    evaluate_game: callable function that takes a list of policies as argument\\n    ckpt_to_policy: list of maps from strat (or checkpoint) to a policy, one\\n      map for each player\\n  Returns:\\n    dictionary: key=key_query, value=np.array of payoffs (1 for each player)\\n  '\n    game_results = {}\n    for key_query in game_queries:\n        (_, query) = key_query\n        policies = [ckpt_to_policy[pi][ckpt_i] for (pi, ckpt_i) in enumerate(query)]\n        payoffs = evaluate_game(policies)\n        game_results.update({key_query: payoffs})\n    return game_results"
        ]
    },
    {
        "func_name": "form_payoff_matrices",
        "original": "def form_payoff_matrices(game_results, num_checkpts):\n    \"\"\"Packages dictionary of game results into a payoff tensor.\n\n  Args:\n    game_results: dictionary of payoffs for each game evaluated, keys are\n      (pair, profile) where pair is a tuple of the two agents played against\n      each other and profile indicates pure joint action played by all agents\n    num_checkpts: list of ints, number of strats (or ckpts) per player\n  Returns:\n    payoff_matrices: dict of np.arrays (2 x num_checkpts x num_checkpts) with\n      payoffs for two players. keys are pairs above with lowest index agent\n      first\n  \"\"\"\n    num_players = len(num_checkpts)\n    payoff_matrices = {}\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        key = (pi, pj)\n        payoff_matrices[key] = np.zeros((2, num_checkpts[pi], num_checkpts[pj]))\n    for (key_profile, payoffs) in game_results.items():\n        (key, profile) = key_profile\n        (i, j) = key\n        ai = profile[i]\n        aj = profile[j]\n        payoff_matrices[key][0, ai, aj] = payoffs[i]\n        payoff_matrices[key][1, ai, aj] = payoffs[j]\n    return payoff_matrices",
        "mutated": [
            "def form_payoff_matrices(game_results, num_checkpts):\n    if False:\n        i = 10\n    'Packages dictionary of game results into a payoff tensor.\\n\\n  Args:\\n    game_results: dictionary of payoffs for each game evaluated, keys are\\n      (pair, profile) where pair is a tuple of the two agents played against\\n      each other and profile indicates pure joint action played by all agents\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    payoff_matrices: dict of np.arrays (2 x num_checkpts x num_checkpts) with\\n      payoffs for two players. keys are pairs above with lowest index agent\\n      first\\n  '\n    num_players = len(num_checkpts)\n    payoff_matrices = {}\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        key = (pi, pj)\n        payoff_matrices[key] = np.zeros((2, num_checkpts[pi], num_checkpts[pj]))\n    for (key_profile, payoffs) in game_results.items():\n        (key, profile) = key_profile\n        (i, j) = key\n        ai = profile[i]\n        aj = profile[j]\n        payoff_matrices[key][0, ai, aj] = payoffs[i]\n        payoff_matrices[key][1, ai, aj] = payoffs[j]\n    return payoff_matrices",
            "def form_payoff_matrices(game_results, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Packages dictionary of game results into a payoff tensor.\\n\\n  Args:\\n    game_results: dictionary of payoffs for each game evaluated, keys are\\n      (pair, profile) where pair is a tuple of the two agents played against\\n      each other and profile indicates pure joint action played by all agents\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    payoff_matrices: dict of np.arrays (2 x num_checkpts x num_checkpts) with\\n      payoffs for two players. keys are pairs above with lowest index agent\\n      first\\n  '\n    num_players = len(num_checkpts)\n    payoff_matrices = {}\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        key = (pi, pj)\n        payoff_matrices[key] = np.zeros((2, num_checkpts[pi], num_checkpts[pj]))\n    for (key_profile, payoffs) in game_results.items():\n        (key, profile) = key_profile\n        (i, j) = key\n        ai = profile[i]\n        aj = profile[j]\n        payoff_matrices[key][0, ai, aj] = payoffs[i]\n        payoff_matrices[key][1, ai, aj] = payoffs[j]\n    return payoff_matrices",
            "def form_payoff_matrices(game_results, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Packages dictionary of game results into a payoff tensor.\\n\\n  Args:\\n    game_results: dictionary of payoffs for each game evaluated, keys are\\n      (pair, profile) where pair is a tuple of the two agents played against\\n      each other and profile indicates pure joint action played by all agents\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    payoff_matrices: dict of np.arrays (2 x num_checkpts x num_checkpts) with\\n      payoffs for two players. keys are pairs above with lowest index agent\\n      first\\n  '\n    num_players = len(num_checkpts)\n    payoff_matrices = {}\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        key = (pi, pj)\n        payoff_matrices[key] = np.zeros((2, num_checkpts[pi], num_checkpts[pj]))\n    for (key_profile, payoffs) in game_results.items():\n        (key, profile) = key_profile\n        (i, j) = key\n        ai = profile[i]\n        aj = profile[j]\n        payoff_matrices[key][0, ai, aj] = payoffs[i]\n        payoff_matrices[key][1, ai, aj] = payoffs[j]\n    return payoff_matrices",
            "def form_payoff_matrices(game_results, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Packages dictionary of game results into a payoff tensor.\\n\\n  Args:\\n    game_results: dictionary of payoffs for each game evaluated, keys are\\n      (pair, profile) where pair is a tuple of the two agents played against\\n      each other and profile indicates pure joint action played by all agents\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    payoff_matrices: dict of np.arrays (2 x num_checkpts x num_checkpts) with\\n      payoffs for two players. keys are pairs above with lowest index agent\\n      first\\n  '\n    num_players = len(num_checkpts)\n    payoff_matrices = {}\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        key = (pi, pj)\n        payoff_matrices[key] = np.zeros((2, num_checkpts[pi], num_checkpts[pj]))\n    for (key_profile, payoffs) in game_results.items():\n        (key, profile) = key_profile\n        (i, j) = key\n        ai = profile[i]\n        aj = profile[j]\n        payoff_matrices[key][0, ai, aj] = payoffs[i]\n        payoff_matrices[key][1, ai, aj] = payoffs[j]\n    return payoff_matrices",
            "def form_payoff_matrices(game_results, num_checkpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Packages dictionary of game results into a payoff tensor.\\n\\n  Args:\\n    game_results: dictionary of payoffs for each game evaluated, keys are\\n      (pair, profile) where pair is a tuple of the two agents played against\\n      each other and profile indicates pure joint action played by all agents\\n    num_checkpts: list of ints, number of strats (or ckpts) per player\\n  Returns:\\n    payoff_matrices: dict of np.arrays (2 x num_checkpts x num_checkpts) with\\n      payoffs for two players. keys are pairs above with lowest index agent\\n      first\\n  '\n    num_players = len(num_checkpts)\n    payoff_matrices = {}\n    for (pi, pj) in itertools.combinations(range(num_players), 2):\n        key = (pi, pj)\n        payoff_matrices[key] = np.zeros((2, num_checkpts[pi], num_checkpts[pj]))\n    for (key_profile, payoffs) in game_results.items():\n        (key, profile) = key_profile\n        (i, j) = key\n        ai = profile[i]\n        aj = profile[j]\n        payoff_matrices[key][0, ai, aj] = payoffs[i]\n        payoff_matrices[key][1, ai, aj] = payoffs[j]\n    return payoff_matrices"
        ]
    }
]