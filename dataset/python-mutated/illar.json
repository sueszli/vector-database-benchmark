[
    {
        "func_name": "show_top",
        "original": "def show_top(minion=None, saltenv='base'):\n    \"\"\"\n    Returns the compiled top data for pillar for a specific minion.  If no\n    minion is specified, we use the first minion we find.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_top\n    \"\"\"\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv)\n    (top, errors) = pillar.get_top()\n    if errors:\n        __jid_event__.fire_event({'data': errors, 'outputter': 'nested'}, 'progress')\n        return errors\n    return top",
        "mutated": [
            "def show_top(minion=None, saltenv='base'):\n    if False:\n        i = 10\n    '\\n    Returns the compiled top data for pillar for a specific minion.  If no\\n    minion is specified, we use the first minion we find.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_top\\n    '\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv)\n    (top, errors) = pillar.get_top()\n    if errors:\n        __jid_event__.fire_event({'data': errors, 'outputter': 'nested'}, 'progress')\n        return errors\n    return top",
            "def show_top(minion=None, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the compiled top data for pillar for a specific minion.  If no\\n    minion is specified, we use the first minion we find.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_top\\n    '\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv)\n    (top, errors) = pillar.get_top()\n    if errors:\n        __jid_event__.fire_event({'data': errors, 'outputter': 'nested'}, 'progress')\n        return errors\n    return top",
            "def show_top(minion=None, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the compiled top data for pillar for a specific minion.  If no\\n    minion is specified, we use the first minion we find.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_top\\n    '\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv)\n    (top, errors) = pillar.get_top()\n    if errors:\n        __jid_event__.fire_event({'data': errors, 'outputter': 'nested'}, 'progress')\n        return errors\n    return top",
            "def show_top(minion=None, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the compiled top data for pillar for a specific minion.  If no\\n    minion is specified, we use the first minion we find.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_top\\n    '\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv)\n    (top, errors) = pillar.get_top()\n    if errors:\n        __jid_event__.fire_event({'data': errors, 'outputter': 'nested'}, 'progress')\n        return errors\n    return top",
            "def show_top(minion=None, saltenv='base'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the compiled top data for pillar for a specific minion.  If no\\n    minion is specified, we use the first minion we find.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_top\\n    '\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv)\n    (top, errors) = pillar.get_top()\n    if errors:\n        __jid_event__.fire_event({'data': errors, 'outputter': 'nested'}, 'progress')\n        return errors\n    return top"
        ]
    },
    {
        "func_name": "show_pillar",
        "original": "def show_pillar(minion='*', **kwargs):\n    \"\"\"\n    Returns the compiled pillar either of a specific minion\n    or just the global available pillars. This function assumes\n    that no minion has the id ``*``.\n    Function also accepts pillarenv as attribute in order to limit to a specific pillar branch of git\n\n    CLI Example:\n\n    shows minion specific pillar:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'www.example.com'\n\n    shows global pillar:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar\n\n    shows global pillar for 'dev' pillar environment:\n    (note that not specifying pillarenv will merge all pillar environments\n    using the master config option pillar_source_merging_strategy.)\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'pillarenv=dev'\n\n    shows global pillar for 'dev' pillar environment and specific pillarenv = dev:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'saltenv=dev' 'pillarenv=dev'\n\n    API Example:\n\n    .. code-block:: python\n\n        import salt.config\n        import salt.runner\n        opts = salt.config.master_config('/etc/salt/master')\n        runner = salt.runner.RunnerClient(opts)\n        pillar = runner.cmd('pillar.show_pillar', [])\n        print(pillar)\n    \"\"\"\n    pillarenv = None\n    saltenv = 'base'\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    if grains is None:\n        grains = {'fqdn': minion}\n    for key in kwargs:\n        if key == 'saltenv':\n            saltenv = kwargs[key]\n        elif key == 'pillarenv':\n            pillarenv = kwargs[key]\n        else:\n            grains[key] = kwargs[key]\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n    compiled_pillar = pillar.compile_pillar()\n    return compiled_pillar",
        "mutated": [
            "def show_pillar(minion='*', **kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns the compiled pillar either of a specific minion\\n    or just the global available pillars. This function assumes\\n    that no minion has the id ``*``.\\n    Function also accepts pillarenv as attribute in order to limit to a specific pillar branch of git\\n\\n    CLI Example:\\n\\n    shows minion specific pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'www.example.com'\\n\\n    shows global pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar\\n\\n    shows global pillar for 'dev' pillar environment:\\n    (note that not specifying pillarenv will merge all pillar environments\\n    using the master config option pillar_source_merging_strategy.)\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'pillarenv=dev'\\n\\n    shows global pillar for 'dev' pillar environment and specific pillarenv = dev:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'saltenv=dev' 'pillarenv=dev'\\n\\n    API Example:\\n\\n    .. code-block:: python\\n\\n        import salt.config\\n        import salt.runner\\n        opts = salt.config.master_config('/etc/salt/master')\\n        runner = salt.runner.RunnerClient(opts)\\n        pillar = runner.cmd('pillar.show_pillar', [])\\n        print(pillar)\\n    \"\n    pillarenv = None\n    saltenv = 'base'\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    if grains is None:\n        grains = {'fqdn': minion}\n    for key in kwargs:\n        if key == 'saltenv':\n            saltenv = kwargs[key]\n        elif key == 'pillarenv':\n            pillarenv = kwargs[key]\n        else:\n            grains[key] = kwargs[key]\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n    compiled_pillar = pillar.compile_pillar()\n    return compiled_pillar",
            "def show_pillar(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns the compiled pillar either of a specific minion\\n    or just the global available pillars. This function assumes\\n    that no minion has the id ``*``.\\n    Function also accepts pillarenv as attribute in order to limit to a specific pillar branch of git\\n\\n    CLI Example:\\n\\n    shows minion specific pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'www.example.com'\\n\\n    shows global pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar\\n\\n    shows global pillar for 'dev' pillar environment:\\n    (note that not specifying pillarenv will merge all pillar environments\\n    using the master config option pillar_source_merging_strategy.)\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'pillarenv=dev'\\n\\n    shows global pillar for 'dev' pillar environment and specific pillarenv = dev:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'saltenv=dev' 'pillarenv=dev'\\n\\n    API Example:\\n\\n    .. code-block:: python\\n\\n        import salt.config\\n        import salt.runner\\n        opts = salt.config.master_config('/etc/salt/master')\\n        runner = salt.runner.RunnerClient(opts)\\n        pillar = runner.cmd('pillar.show_pillar', [])\\n        print(pillar)\\n    \"\n    pillarenv = None\n    saltenv = 'base'\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    if grains is None:\n        grains = {'fqdn': minion}\n    for key in kwargs:\n        if key == 'saltenv':\n            saltenv = kwargs[key]\n        elif key == 'pillarenv':\n            pillarenv = kwargs[key]\n        else:\n            grains[key] = kwargs[key]\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n    compiled_pillar = pillar.compile_pillar()\n    return compiled_pillar",
            "def show_pillar(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns the compiled pillar either of a specific minion\\n    or just the global available pillars. This function assumes\\n    that no minion has the id ``*``.\\n    Function also accepts pillarenv as attribute in order to limit to a specific pillar branch of git\\n\\n    CLI Example:\\n\\n    shows minion specific pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'www.example.com'\\n\\n    shows global pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar\\n\\n    shows global pillar for 'dev' pillar environment:\\n    (note that not specifying pillarenv will merge all pillar environments\\n    using the master config option pillar_source_merging_strategy.)\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'pillarenv=dev'\\n\\n    shows global pillar for 'dev' pillar environment and specific pillarenv = dev:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'saltenv=dev' 'pillarenv=dev'\\n\\n    API Example:\\n\\n    .. code-block:: python\\n\\n        import salt.config\\n        import salt.runner\\n        opts = salt.config.master_config('/etc/salt/master')\\n        runner = salt.runner.RunnerClient(opts)\\n        pillar = runner.cmd('pillar.show_pillar', [])\\n        print(pillar)\\n    \"\n    pillarenv = None\n    saltenv = 'base'\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    if grains is None:\n        grains = {'fqdn': minion}\n    for key in kwargs:\n        if key == 'saltenv':\n            saltenv = kwargs[key]\n        elif key == 'pillarenv':\n            pillarenv = kwargs[key]\n        else:\n            grains[key] = kwargs[key]\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n    compiled_pillar = pillar.compile_pillar()\n    return compiled_pillar",
            "def show_pillar(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns the compiled pillar either of a specific minion\\n    or just the global available pillars. This function assumes\\n    that no minion has the id ``*``.\\n    Function also accepts pillarenv as attribute in order to limit to a specific pillar branch of git\\n\\n    CLI Example:\\n\\n    shows minion specific pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'www.example.com'\\n\\n    shows global pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar\\n\\n    shows global pillar for 'dev' pillar environment:\\n    (note that not specifying pillarenv will merge all pillar environments\\n    using the master config option pillar_source_merging_strategy.)\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'pillarenv=dev'\\n\\n    shows global pillar for 'dev' pillar environment and specific pillarenv = dev:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'saltenv=dev' 'pillarenv=dev'\\n\\n    API Example:\\n\\n    .. code-block:: python\\n\\n        import salt.config\\n        import salt.runner\\n        opts = salt.config.master_config('/etc/salt/master')\\n        runner = salt.runner.RunnerClient(opts)\\n        pillar = runner.cmd('pillar.show_pillar', [])\\n        print(pillar)\\n    \"\n    pillarenv = None\n    saltenv = 'base'\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    if grains is None:\n        grains = {'fqdn': minion}\n    for key in kwargs:\n        if key == 'saltenv':\n            saltenv = kwargs[key]\n        elif key == 'pillarenv':\n            pillarenv = kwargs[key]\n        else:\n            grains[key] = kwargs[key]\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n    compiled_pillar = pillar.compile_pillar()\n    return compiled_pillar",
            "def show_pillar(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns the compiled pillar either of a specific minion\\n    or just the global available pillars. This function assumes\\n    that no minion has the id ``*``.\\n    Function also accepts pillarenv as attribute in order to limit to a specific pillar branch of git\\n\\n    CLI Example:\\n\\n    shows minion specific pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'www.example.com'\\n\\n    shows global pillar:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar\\n\\n    shows global pillar for 'dev' pillar environment:\\n    (note that not specifying pillarenv will merge all pillar environments\\n    using the master config option pillar_source_merging_strategy.)\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'pillarenv=dev'\\n\\n    shows global pillar for 'dev' pillar environment and specific pillarenv = dev:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar 'saltenv=dev' 'pillarenv=dev'\\n\\n    API Example:\\n\\n    .. code-block:: python\\n\\n        import salt.config\\n        import salt.runner\\n        opts = salt.config.master_config('/etc/salt/master')\\n        runner = salt.runner.RunnerClient(opts)\\n        pillar = runner.cmd('pillar.show_pillar', [])\\n        print(pillar)\\n    \"\n    pillarenv = None\n    saltenv = 'base'\n    (id_, grains, _) = salt.utils.minions.get_minion_data(minion, __opts__)\n    if grains is None:\n        grains = {'fqdn': minion}\n    for key in kwargs:\n        if key == 'saltenv':\n            saltenv = kwargs[key]\n        elif key == 'pillarenv':\n            pillarenv = kwargs[key]\n        else:\n            grains[key] = kwargs[key]\n    pillar = salt.pillar.Pillar(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n    compiled_pillar = pillar.compile_pillar()\n    return compiled_pillar"
        ]
    },
    {
        "func_name": "clear_pillar_cache",
        "original": "def clear_pillar_cache(minion='*', **kwargs):\n    \"\"\"\n    Clears the cached values when using pillar_cache\n\n    .. versionadded:: 3003\n\n    CLI Example:\n\n    Clears the pillar cache for a specific minion:\n\n    .. code-block:: bash\n\n        salt-run pillar.clear_pillar_cache 'minion'\n\n    \"\"\"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        pillar.clear_pillar()\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache.get(tgt).get(pillarenv)\n    return pillar_cache",
        "mutated": [
            "def clear_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n    \"\\n    Clears the cached values when using pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Clears the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.clear_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        pillar.clear_pillar()\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache.get(tgt).get(pillarenv)\n    return pillar_cache",
            "def clear_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Clears the cached values when using pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Clears the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.clear_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        pillar.clear_pillar()\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache.get(tgt).get(pillarenv)\n    return pillar_cache",
            "def clear_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Clears the cached values when using pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Clears the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.clear_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        pillar.clear_pillar()\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache.get(tgt).get(pillarenv)\n    return pillar_cache",
            "def clear_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Clears the cached values when using pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Clears the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.clear_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        pillar.clear_pillar()\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache.get(tgt).get(pillarenv)\n    return pillar_cache",
            "def clear_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Clears the cached values when using pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Clears the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.clear_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        pillar.clear_pillar()\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache.get(tgt).get(pillarenv)\n    return pillar_cache"
        ]
    },
    {
        "func_name": "show_pillar_cache",
        "original": "def show_pillar_cache(minion='*', **kwargs):\n    \"\"\"\n    Shows the cached values in pillar_cache\n\n    .. versionadded:: 3003\n\n    CLI Example:\n\n    Shows the pillar cache for a specific minion:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar_cache 'minion'\n\n    \"\"\"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache[tgt].get(pillarenv)\n    return pillar_cache",
        "mutated": [
            "def show_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n    \"\\n    Shows the cached values in pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Shows the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache[tgt].get(pillarenv)\n    return pillar_cache",
            "def show_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Shows the cached values in pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Shows the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache[tgt].get(pillarenv)\n    return pillar_cache",
            "def show_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Shows the cached values in pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Shows the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache[tgt].get(pillarenv)\n    return pillar_cache",
            "def show_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Shows the cached values in pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Shows the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache[tgt].get(pillarenv)\n    return pillar_cache",
            "def show_pillar_cache(minion='*', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Shows the cached values in pillar_cache\\n\\n    .. versionadded:: 3003\\n\\n    CLI Example:\\n\\n    Shows the pillar cache for a specific minion:\\n\\n    .. code-block:: bash\\n\\n        salt-run pillar.show_pillar_cache 'minion'\\n\\n    \"\n    if not __opts__.get('pillar_cache'):\n        log.info('The pillar_cache is set to False or not enabled.')\n        return False\n    ckminions = salt.utils.minions.CkMinions(__opts__)\n    ret = ckminions.check_minions(minion)\n    pillarenv = kwargs.pop('pillarenv', None)\n    saltenv = kwargs.pop('saltenv', 'base')\n    pillar_cache = {}\n    for tgt in ret.get('minions', []):\n        (id_, grains, _) = salt.utils.minions.get_minion_data(tgt, __opts__)\n        for key in kwargs:\n            grains[key] = kwargs[key]\n        if grains is None:\n            grains = {'fqdn': minion}\n        pillar = salt.pillar.PillarCache(__opts__, grains, id_, saltenv, pillarenv=pillarenv)\n        if __opts__.get('pillar_cache_backend') == 'memory':\n            _pillar_cache = pillar.cache\n        else:\n            _pillar_cache = pillar.cache._dict\n        if tgt in _pillar_cache and _pillar_cache[tgt]:\n            pillar_cache[tgt] = _pillar_cache[tgt].get(pillarenv)\n    return pillar_cache"
        ]
    }
]