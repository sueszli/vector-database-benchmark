[
    {
        "func_name": "_vectorize_zvalue",
        "original": "def _vectorize_zvalue(z, mode='max'):\n    alpha = 255 if mode == 'max' else 0\n    if z is None:\n        return z\n    elif np.isscalar(z):\n        return [z] * 3 + [alpha]\n    elif len(z) == 1:\n        return list(z) * 3 + [alpha]\n    elif len(z) == 3:\n        return list(z) + [alpha]\n    elif len(z) == 4:\n        return z\n    else:\n        raise ValueError('zmax can be a scalar, or an iterable of length 1, 3 or 4. A value of %s was passed for zmax.' % str(z))",
        "mutated": [
            "def _vectorize_zvalue(z, mode='max'):\n    if False:\n        i = 10\n    alpha = 255 if mode == 'max' else 0\n    if z is None:\n        return z\n    elif np.isscalar(z):\n        return [z] * 3 + [alpha]\n    elif len(z) == 1:\n        return list(z) * 3 + [alpha]\n    elif len(z) == 3:\n        return list(z) + [alpha]\n    elif len(z) == 4:\n        return z\n    else:\n        raise ValueError('zmax can be a scalar, or an iterable of length 1, 3 or 4. A value of %s was passed for zmax.' % str(z))",
            "def _vectorize_zvalue(z, mode='max'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    alpha = 255 if mode == 'max' else 0\n    if z is None:\n        return z\n    elif np.isscalar(z):\n        return [z] * 3 + [alpha]\n    elif len(z) == 1:\n        return list(z) * 3 + [alpha]\n    elif len(z) == 3:\n        return list(z) + [alpha]\n    elif len(z) == 4:\n        return z\n    else:\n        raise ValueError('zmax can be a scalar, or an iterable of length 1, 3 or 4. A value of %s was passed for zmax.' % str(z))",
            "def _vectorize_zvalue(z, mode='max'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    alpha = 255 if mode == 'max' else 0\n    if z is None:\n        return z\n    elif np.isscalar(z):\n        return [z] * 3 + [alpha]\n    elif len(z) == 1:\n        return list(z) * 3 + [alpha]\n    elif len(z) == 3:\n        return list(z) + [alpha]\n    elif len(z) == 4:\n        return z\n    else:\n        raise ValueError('zmax can be a scalar, or an iterable of length 1, 3 or 4. A value of %s was passed for zmax.' % str(z))",
            "def _vectorize_zvalue(z, mode='max'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    alpha = 255 if mode == 'max' else 0\n    if z is None:\n        return z\n    elif np.isscalar(z):\n        return [z] * 3 + [alpha]\n    elif len(z) == 1:\n        return list(z) * 3 + [alpha]\n    elif len(z) == 3:\n        return list(z) + [alpha]\n    elif len(z) == 4:\n        return z\n    else:\n        raise ValueError('zmax can be a scalar, or an iterable of length 1, 3 or 4. A value of %s was passed for zmax.' % str(z))",
            "def _vectorize_zvalue(z, mode='max'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    alpha = 255 if mode == 'max' else 0\n    if z is None:\n        return z\n    elif np.isscalar(z):\n        return [z] * 3 + [alpha]\n    elif len(z) == 1:\n        return list(z) * 3 + [alpha]\n    elif len(z) == 3:\n        return list(z) + [alpha]\n    elif len(z) == 4:\n        return z\n    else:\n        raise ValueError('zmax can be a scalar, or an iterable of length 1, 3 or 4. A value of %s was passed for zmax.' % str(z))"
        ]
    },
    {
        "func_name": "_infer_zmax_from_type",
        "original": "def _infer_zmax_from_type(img):\n    dt = img.dtype.type\n    rtol = 1.05\n    if dt in _integer_types:\n        return _integer_ranges[dt][1]\n    else:\n        im_max = img[np.isfinite(img)].max()\n        if im_max <= 1 * rtol:\n            return 1\n        elif im_max <= 255 * rtol:\n            return 255\n        elif im_max <= 65535 * rtol:\n            return 65535\n        else:\n            return 2 ** 32",
        "mutated": [
            "def _infer_zmax_from_type(img):\n    if False:\n        i = 10\n    dt = img.dtype.type\n    rtol = 1.05\n    if dt in _integer_types:\n        return _integer_ranges[dt][1]\n    else:\n        im_max = img[np.isfinite(img)].max()\n        if im_max <= 1 * rtol:\n            return 1\n        elif im_max <= 255 * rtol:\n            return 255\n        elif im_max <= 65535 * rtol:\n            return 65535\n        else:\n            return 2 ** 32",
            "def _infer_zmax_from_type(img):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dt = img.dtype.type\n    rtol = 1.05\n    if dt in _integer_types:\n        return _integer_ranges[dt][1]\n    else:\n        im_max = img[np.isfinite(img)].max()\n        if im_max <= 1 * rtol:\n            return 1\n        elif im_max <= 255 * rtol:\n            return 255\n        elif im_max <= 65535 * rtol:\n            return 65535\n        else:\n            return 2 ** 32",
            "def _infer_zmax_from_type(img):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dt = img.dtype.type\n    rtol = 1.05\n    if dt in _integer_types:\n        return _integer_ranges[dt][1]\n    else:\n        im_max = img[np.isfinite(img)].max()\n        if im_max <= 1 * rtol:\n            return 1\n        elif im_max <= 255 * rtol:\n            return 255\n        elif im_max <= 65535 * rtol:\n            return 65535\n        else:\n            return 2 ** 32",
            "def _infer_zmax_from_type(img):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dt = img.dtype.type\n    rtol = 1.05\n    if dt in _integer_types:\n        return _integer_ranges[dt][1]\n    else:\n        im_max = img[np.isfinite(img)].max()\n        if im_max <= 1 * rtol:\n            return 1\n        elif im_max <= 255 * rtol:\n            return 255\n        elif im_max <= 65535 * rtol:\n            return 65535\n        else:\n            return 2 ** 32",
            "def _infer_zmax_from_type(img):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dt = img.dtype.type\n    rtol = 1.05\n    if dt in _integer_types:\n        return _integer_ranges[dt][1]\n    else:\n        im_max = img[np.isfinite(img)].max()\n        if im_max <= 1 * rtol:\n            return 1\n        elif im_max <= 255 * rtol:\n            return 255\n        elif im_max <= 65535 * rtol:\n            return 65535\n        else:\n            return 2 ** 32"
        ]
    },
    {
        "func_name": "imshow",
        "original": "def imshow(img, zmin=None, zmax=None, origin=None, labels={}, x=None, y=None, animation_frame=None, facet_col=None, facet_col_wrap=None, facet_col_spacing=None, facet_row_spacing=None, color_continuous_scale=None, color_continuous_midpoint=None, range_color=None, title=None, template=None, width=None, height=None, aspect=None, contrast_rescaling=None, binary_string=None, binary_backend='auto', binary_compression_level=4, binary_format='png', text_auto=False) -> go.Figure:\n    \"\"\"\n    Display an image, i.e. data on a 2D regular raster.\n\n    Parameters\n    ----------\n\n    img: array-like image, or xarray\n        The image data. Supported array shapes are\n\n        - (M, N): an image with scalar data. The data is visualized\n          using a colormap.\n        - (M, N, 3): an image with RGB values.\n        - (M, N, 4): an image with RGBA values, i.e. including transparency.\n\n    zmin, zmax : scalar or iterable, optional\n        zmin and zmax define the scalar range that the colormap covers. By default,\n        zmin and zmax correspond to the min and max values of the datatype for integer\n        datatypes (ie [0-255] for uint8 images, [0, 65535] for uint16 images, etc.). For\n        a multichannel image of floats, the max of the image is computed and zmax is the\n        smallest power of 256 (1, 255, 65535) greater than this max value,\n        with a 5% tolerance. For a single-channel image, the max of the image is used.\n        Overridden by range_color.\n\n    origin : str, 'upper' or 'lower' (default 'upper')\n        position of the [0, 0] pixel of the image array, in the upper left or lower left\n        corner. The convention 'upper' is typically used for matrices and images.\n\n    labels : dict with str keys and str values (default `{}`)\n        Sets names used in the figure for axis titles (keys ``x`` and ``y``),\n        colorbar title and hoverlabel (key ``color``). The values should correspond\n        to the desired label to be displayed. If ``img`` is an xarray, dimension\n        names are used for axis titles, and long name for the colorbar title\n        (unless overridden in ``labels``). Possible keys are: x, y, and color.\n\n    x, y: list-like, optional\n        x and y are used to label the axes of single-channel heatmap visualizations and\n        their lengths must match the lengths of the second and first dimensions of the\n        img argument. They are auto-populated if the input is an xarray.\n\n    animation_frame: int or str, optional (default None)\n        axis number along which the image array is sliced to create an animation plot.\n        If `img` is an xarray, `animation_frame` can be the name of one the dimensions.\n\n    facet_col: int or str, optional (default None)\n        axis number along which the image array is sliced to create a facetted plot.\n        If `img` is an xarray, `facet_col` can be the name of one the dimensions.\n\n    facet_col_wrap: int\n        Maximum number of facet columns. Wraps the column variable at this width,\n        so that the column facets span multiple rows.\n        Ignored if `facet_col` is None.\n\n    facet_col_spacing: float between 0 and 1\n        Spacing between facet columns, in paper units. Default is 0.02.\n\n    facet_row_spacing: float between 0 and 1\n        Spacing between facet rows created when ``facet_col_wrap`` is used, in\n        paper units. Default is 0.0.7.\n\n    color_continuous_scale : str or list of str\n        colormap used to map scalar data to colors (for a 2D image). This parameter is\n        not used for RGB or RGBA images. If a string is provided, it should be the name\n        of a known color scale, and if a list is provided, it should be a list of CSS-\n        compatible colors.\n\n    color_continuous_midpoint : number\n        If set, computes the bounds of the continuous color scale to have the desired\n        midpoint. Overridden by range_color or zmin and zmax.\n\n    range_color : list of two numbers\n        If provided, overrides auto-scaling on the continuous color scale, including\n        overriding `color_continuous_midpoint`. Also overrides zmin and zmax. Used only\n        for single-channel images.\n\n    title : str\n        The figure title.\n\n    template : str or dict or plotly.graph_objects.layout.Template instance\n        The figure template name or definition.\n\n    width : number\n        The figure width in pixels.\n\n    height: number\n        The figure height in pixels.\n\n    aspect: 'equal', 'auto', or None\n      - 'equal': Ensures an aspect ratio of 1 or pixels (square pixels)\n      - 'auto': The axes is kept fixed and the aspect ratio of pixels is\n        adjusted so that the data fit in the axes. In general, this will\n        result in non-square pixels.\n      - if None, 'equal' is used for numpy arrays and 'auto' for xarrays\n        (which have typically heterogeneous coordinates)\n\n    contrast_rescaling: 'minmax', 'infer', or None\n        how to determine data values corresponding to the bounds of the color\n        range, when zmin or zmax are not passed. If `minmax`, the min and max\n        values of the image are used. If `infer`, a heuristic based on the image\n        data type is used.\n\n    binary_string: bool, default None\n        if True, the image data are first rescaled and encoded as uint8 and\n        then passed to plotly.js as a b64 PNG string. If False, data are passed\n        unchanged as a numerical array. Setting to True may lead to performance\n        gains, at the cost of a loss of precision depending on the original data\n        type. If None, use_binary_string is set to True for multichannel (eg) RGB\n        arrays, and to False for single-channel (2D) arrays. 2D arrays are\n        represented as grayscale and with no colorbar if use_binary_string is\n        True.\n\n    binary_backend: str, 'auto' (default), 'pil' or 'pypng'\n        Third-party package for the transformation of numpy arrays to\n        png b64 strings. If 'auto', Pillow is used if installed,  otherwise\n        pypng.\n\n    binary_compression_level: int, between 0 and 9 (default 4)\n        png compression level to be passed to the backend when transforming an\n        array to a png b64 string. Increasing `binary_compression` decreases the\n        size of the png string, but the compression step takes more time. For most\n        images it is not worth using levels greater than 5, but it's possible to\n        test `len(fig.data[0].source)` and to time the execution of `imshow` to\n        tune the level of compression. 0 means no compression (not recommended).\n\n    binary_format: str, 'png' (default) or 'jpg'\n        compression format used to generate b64 string. 'png' is recommended\n        since it uses lossless compression, but 'jpg' (lossy) compression can\n        result if smaller binary strings for natural images.\n\n    text_auto: bool or str (default `False`)\n        If `True` or a string, single-channel `img` values will be displayed as text.\n        A string like `'.2f'` will be interpreted as a `texttemplate` numeric formatting directive.\n\n    Returns\n    -------\n    fig : graph_objects.Figure containing the displayed image\n\n    See also\n    --------\n\n    plotly.graph_objects.Image : image trace\n    plotly.graph_objects.Heatmap : heatmap trace\n\n    Notes\n    -----\n\n    In order to update and customize the returned figure, use\n    `go.Figure.update_traces` or `go.Figure.update_layout`.\n\n    If an xarray is passed, dimensions names and coordinates are used for\n    axes labels and ticks.\n    \"\"\"\n    args = locals()\n    apply_default_cascade(args)\n    labels = labels.copy()\n    nslices_facet = 1\n    if facet_col is not None:\n        if isinstance(facet_col, str):\n            facet_col = img.dims.index(facet_col)\n        nslices_facet = img.shape[facet_col]\n        facet_slices = range(nslices_facet)\n        ncols = int(facet_col_wrap) if facet_col_wrap is not None else nslices_facet\n        nrows = nslices_facet // ncols + 1 if nslices_facet % ncols else nslices_facet // ncols\n    else:\n        nrows = 1\n        ncols = 1\n    if animation_frame is not None:\n        if isinstance(animation_frame, str):\n            animation_frame = img.dims.index(animation_frame)\n        nslices_animation = img.shape[animation_frame]\n        animation_slices = range(nslices_animation)\n    slice_dimensions = (facet_col is not None) + (animation_frame is not None)\n    facet_label = None\n    animation_label = None\n    img_is_xarray = False\n    if xarray_imported and isinstance(img, xarray.DataArray):\n        dims = list(img.dims)\n        img_is_xarray = True\n        pop_indexes = []\n        if facet_col is not None:\n            facet_slices = img.coords[img.dims[facet_col]].values\n            pop_indexes.append(facet_col)\n            facet_label = img.dims[facet_col]\n        if animation_frame is not None:\n            animation_slices = img.coords[img.dims[animation_frame]].values\n            pop_indexes.append(animation_frame)\n            animation_label = img.dims[animation_frame]\n        for index in sorted(pop_indexes, reverse=True):\n            _ = dims.pop(index)\n        (y_label, x_label) = (dims[0], dims[1])\n        for ax in [x_label, y_label]:\n            if np.issubdtype(img.coords[ax].dtype, np.datetime64):\n                img.coords[ax] = img.coords[ax].astype(str)\n        if x is None:\n            x = img.coords[x_label].values\n        if y is None:\n            y = img.coords[y_label].values\n        if aspect is None:\n            aspect = 'auto'\n        if labels.get('x', None) is None:\n            labels['x'] = x_label\n        if labels.get('y', None) is None:\n            labels['y'] = y_label\n        if labels.get('animation_frame', None) is None:\n            labels['animation_frame'] = animation_label\n        if labels.get('facet_col', None) is None:\n            labels['facet_col'] = facet_label\n        if labels.get('color', None) is None:\n            labels['color'] = xarray.plot.utils.label_from_attrs(img)\n            labels['color'] = labels['color'].replace('\\n', '<br>')\n    else:\n        if hasattr(img, 'columns') and hasattr(img.columns, '__len__'):\n            if x is None:\n                x = img.columns\n            if labels.get('x', None) is None and hasattr(img.columns, 'name'):\n                labels['x'] = img.columns.name or ''\n        if hasattr(img, 'index') and hasattr(img.index, '__len__'):\n            if y is None:\n                y = img.index\n            if labels.get('y', None) is None and hasattr(img.index, 'name'):\n                labels['y'] = img.index.name or ''\n        if labels.get('x', None) is None:\n            labels['x'] = ''\n        if labels.get('y', None) is None:\n            labels['y'] = ''\n        if labels.get('color', None) is None:\n            labels['color'] = ''\n        if aspect is None:\n            aspect = 'equal'\n    if isinstance(img, pd.DataFrame):\n        if binary_string:\n            raise ValueError('Binary strings cannot be used with pandas arrays')\n        is_dataframe = True\n    else:\n        is_dataframe = False\n    img = np.asanyarray(img)\n    if facet_col is not None:\n        img = np.moveaxis(img, facet_col, 0)\n        if animation_frame is not None and animation_frame < facet_col:\n            animation_frame += 1\n        facet_col = True\n    if animation_frame is not None:\n        img = np.moveaxis(img, animation_frame, 0)\n        animation_frame = True\n        args['animation_frame'] = 'animation_frame' if labels.get('animation_frame') is None else labels['animation_frame']\n    iterables = ()\n    if animation_frame is not None:\n        iterables += (range(nslices_animation),)\n    if facet_col is not None:\n        iterables += (range(nslices_facet),)\n    if binary_string is None:\n        binary_string = img.ndim >= 3 + slice_dimensions and (not is_dataframe)\n    if img.dtype == bool:\n        img = 255 * img.astype(np.uint8)\n    if range_color is not None:\n        zmin = range_color[0]\n        zmax = range_color[1]\n    if contrast_rescaling is None:\n        contrast_rescaling = 'minmax' if img.ndim == 2 + slice_dimensions else 'infer'\n    if contrast_rescaling == 'minmax':\n        if (zmin is not None or binary_string) and zmax is None:\n            zmax = img.max()\n        if (zmax is not None or binary_string) and zmin is None:\n            zmin = img.min()\n    else:\n        if zmax is None and img.dtype != np.uint8:\n            zmax = _infer_zmax_from_type(img)\n        if zmin is None and zmax is not None:\n            zmin = 0\n    if img.ndim == 2 + slice_dimensions and (not binary_string):\n        y_index = slice_dimensions\n        if y is not None and img.shape[y_index] != len(y):\n            raise ValueError('The length of the y vector must match the length of the first ' + 'dimension of the img matrix.')\n        x_index = slice_dimensions + 1\n        if x is not None and img.shape[x_index] != len(x):\n            raise ValueError('The length of the x vector must match the length of the second ' + 'dimension of the img matrix.')\n        texttemplate = None\n        if text_auto is True:\n            texttemplate = '%{z}'\n        elif text_auto is not False:\n            texttemplate = '%{z:' + text_auto + '}'\n        traces = [go.Heatmap(x=x, y=y, z=img[index_tup], coloraxis='coloraxis1', name=str(i), texttemplate=texttemplate) for (i, index_tup) in enumerate(itertools.product(*iterables))]\n        autorange = True if origin == 'lower' else 'reversed'\n        layout = dict(yaxis=dict(autorange=autorange))\n        if aspect == 'equal':\n            layout['xaxis'] = dict(scaleanchor='y', constrain='domain')\n            layout['yaxis']['constrain'] = 'domain'\n        colorscale_validator = ColorscaleValidator('colorscale', 'imshow')\n        layout['coloraxis1'] = dict(colorscale=colorscale_validator.validate_coerce(args['color_continuous_scale']), cmid=color_continuous_midpoint, cmin=zmin, cmax=zmax)\n        if labels['color']:\n            layout['coloraxis1']['colorbar'] = dict(title_text=labels['color'])\n    elif img.ndim >= 3 and (img.shape[-1] in [3, 4] or (slice_dimensions and binary_string)) or (img.ndim == 2 and binary_string):\n        rescale_image = True\n        if zmin is not None and zmax is not None:\n            (zmin, zmax) = (_vectorize_zvalue(zmin, mode='min'), _vectorize_zvalue(zmax, mode='max'))\n        (x0, y0, dx, dy) = (None,) * 4\n        error_msg_xarray = 'Non-numerical coordinates were passed with xarray `img`, but the Image trace cannot handle it. Please use `binary_string=False` for 2D data or pass instead the numpy array `img.values` to `px.imshow`.'\n        if x is not None:\n            x = np.asanyarray(x)\n            if np.issubdtype(x.dtype, np.number):\n                x0 = x[0]\n                dx = x[1] - x[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `x` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if y is not None:\n            y = np.asanyarray(y)\n            if np.issubdtype(y.dtype, np.number):\n                y0 = y[0]\n                dy = y[1] - y[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `y` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if binary_string:\n            if zmin is None and zmax is None:\n                img_rescaled = img\n                rescale_image = False\n            elif img.ndim == 2 + slice_dimensions:\n                img_rescaled = rescale_intensity(img, in_range=(zmin[0], zmax[0]), out_range=np.uint8)\n            else:\n                img_rescaled = np.stack([rescale_intensity(img[..., ch], in_range=(zmin[ch], zmax[ch]), out_range=np.uint8) for ch in range(img.shape[-1])], axis=-1)\n            img_str = [image_array_to_data_uri(img_rescaled[index_tup], backend=binary_backend, compression=binary_compression_level, ext=binary_format) for index_tup in itertools.product(*iterables)]\n            traces = [go.Image(source=img_str_slice, name=str(i), x0=x0, y0=y0, dx=dx, dy=dy) for (i, img_str_slice) in enumerate(img_str)]\n        else:\n            colormodel = 'rgb' if img.shape[-1] == 3 else 'rgba256'\n            traces = [go.Image(z=img[index_tup], zmin=zmin, zmax=zmax, colormodel=colormodel, x0=x0, y0=y0, dx=dx, dy=dy) for index_tup in itertools.product(*iterables)]\n        layout = {}\n        if origin == 'lower' or (dy is not None and dy < 0):\n            layout['yaxis'] = dict(autorange=True)\n        if dx is not None and dx < 0:\n            layout['xaxis'] = dict(autorange='reversed')\n    else:\n        raise ValueError('px.imshow only accepts 2D single-channel, RGB or RGBA images. An image of shape %s was provided. Alternatively, 3- or 4-D single or multichannel datasets can be visualized using the `facet_col` or/and `animation_frame` arguments.' % str(img.shape))\n    col_labels = []\n    if facet_col is not None:\n        slice_label = 'facet_col' if labels.get('facet_col') is None else labels['facet_col']\n        col_labels = [f'{slice_label}={i}' for i in facet_slices]\n    fig = init_figure(args, 'xy', [], nrows, ncols, col_labels, [])\n    for attr_name in ['height', 'width']:\n        if args[attr_name]:\n            layout[attr_name] = args[attr_name]\n    if args['title']:\n        layout['title_text'] = args['title']\n    elif args['template'].layout.margin.t is None:\n        layout['margin'] = {'t': 60}\n    frame_list = []\n    for (index, trace) in enumerate(traces):\n        if facet_col and index < nrows * ncols or index == 0:\n            fig.add_trace(trace, row=nrows - index // ncols, col=index % ncols + 1)\n    if animation_frame is not None:\n        for (i, index) in zip(range(nslices_animation), animation_slices):\n            frame_list.append(dict(data=traces[nslices_facet * i:nslices_facet * (i + 1)], layout=layout, name=str(index)))\n    if animation_frame:\n        fig.frames = frame_list\n    fig.update_layout(layout)\n    if binary_string and rescale_image and (not np.all(img == img_rescaled)):\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y')\n    else:\n        if trace['type'] == 'heatmap':\n            hover_name = '%{z}'\n        elif img.ndim == 2:\n            hover_name = '%{z[0]}'\n        elif img.ndim == 3 and img.shape[-1] == 3:\n            hover_name = '[%{z[0]}, %{z[1]}, %{z[2]}]'\n        else:\n            hover_name = '%{z}'\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<br>%s: %s<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y', labels['color'] or 'color', hover_name)\n    fig.update_traces(hovertemplate=hovertemplate)\n    if labels['x']:\n        fig.update_xaxes(title_text=labels['x'], row=1)\n    if labels['y']:\n        fig.update_yaxes(title_text=labels['y'], col=1)\n    configure_animation_controls(args, go.Image, fig)\n    fig.update_layout(template=args['template'], overwrite=True)\n    return fig",
        "mutated": [
            "def imshow(img, zmin=None, zmax=None, origin=None, labels={}, x=None, y=None, animation_frame=None, facet_col=None, facet_col_wrap=None, facet_col_spacing=None, facet_row_spacing=None, color_continuous_scale=None, color_continuous_midpoint=None, range_color=None, title=None, template=None, width=None, height=None, aspect=None, contrast_rescaling=None, binary_string=None, binary_backend='auto', binary_compression_level=4, binary_format='png', text_auto=False) -> go.Figure:\n    if False:\n        i = 10\n    \"\\n    Display an image, i.e. data on a 2D regular raster.\\n\\n    Parameters\\n    ----------\\n\\n    img: array-like image, or xarray\\n        The image data. Supported array shapes are\\n\\n        - (M, N): an image with scalar data. The data is visualized\\n          using a colormap.\\n        - (M, N, 3): an image with RGB values.\\n        - (M, N, 4): an image with RGBA values, i.e. including transparency.\\n\\n    zmin, zmax : scalar or iterable, optional\\n        zmin and zmax define the scalar range that the colormap covers. By default,\\n        zmin and zmax correspond to the min and max values of the datatype for integer\\n        datatypes (ie [0-255] for uint8 images, [0, 65535] for uint16 images, etc.). For\\n        a multichannel image of floats, the max of the image is computed and zmax is the\\n        smallest power of 256 (1, 255, 65535) greater than this max value,\\n        with a 5% tolerance. For a single-channel image, the max of the image is used.\\n        Overridden by range_color.\\n\\n    origin : str, 'upper' or 'lower' (default 'upper')\\n        position of the [0, 0] pixel of the image array, in the upper left or lower left\\n        corner. The convention 'upper' is typically used for matrices and images.\\n\\n    labels : dict with str keys and str values (default `{}`)\\n        Sets names used in the figure for axis titles (keys ``x`` and ``y``),\\n        colorbar title and hoverlabel (key ``color``). The values should correspond\\n        to the desired label to be displayed. If ``img`` is an xarray, dimension\\n        names are used for axis titles, and long name for the colorbar title\\n        (unless overridden in ``labels``). Possible keys are: x, y, and color.\\n\\n    x, y: list-like, optional\\n        x and y are used to label the axes of single-channel heatmap visualizations and\\n        their lengths must match the lengths of the second and first dimensions of the\\n        img argument. They are auto-populated if the input is an xarray.\\n\\n    animation_frame: int or str, optional (default None)\\n        axis number along which the image array is sliced to create an animation plot.\\n        If `img` is an xarray, `animation_frame` can be the name of one the dimensions.\\n\\n    facet_col: int or str, optional (default None)\\n        axis number along which the image array is sliced to create a facetted plot.\\n        If `img` is an xarray, `facet_col` can be the name of one the dimensions.\\n\\n    facet_col_wrap: int\\n        Maximum number of facet columns. Wraps the column variable at this width,\\n        so that the column facets span multiple rows.\\n        Ignored if `facet_col` is None.\\n\\n    facet_col_spacing: float between 0 and 1\\n        Spacing between facet columns, in paper units. Default is 0.02.\\n\\n    facet_row_spacing: float between 0 and 1\\n        Spacing between facet rows created when ``facet_col_wrap`` is used, in\\n        paper units. Default is 0.0.7.\\n\\n    color_continuous_scale : str or list of str\\n        colormap used to map scalar data to colors (for a 2D image). This parameter is\\n        not used for RGB or RGBA images. If a string is provided, it should be the name\\n        of a known color scale, and if a list is provided, it should be a list of CSS-\\n        compatible colors.\\n\\n    color_continuous_midpoint : number\\n        If set, computes the bounds of the continuous color scale to have the desired\\n        midpoint. Overridden by range_color or zmin and zmax.\\n\\n    range_color : list of two numbers\\n        If provided, overrides auto-scaling on the continuous color scale, including\\n        overriding `color_continuous_midpoint`. Also overrides zmin and zmax. Used only\\n        for single-channel images.\\n\\n    title : str\\n        The figure title.\\n\\n    template : str or dict or plotly.graph_objects.layout.Template instance\\n        The figure template name or definition.\\n\\n    width : number\\n        The figure width in pixels.\\n\\n    height: number\\n        The figure height in pixels.\\n\\n    aspect: 'equal', 'auto', or None\\n      - 'equal': Ensures an aspect ratio of 1 or pixels (square pixels)\\n      - 'auto': The axes is kept fixed and the aspect ratio of pixels is\\n        adjusted so that the data fit in the axes. In general, this will\\n        result in non-square pixels.\\n      - if None, 'equal' is used for numpy arrays and 'auto' for xarrays\\n        (which have typically heterogeneous coordinates)\\n\\n    contrast_rescaling: 'minmax', 'infer', or None\\n        how to determine data values corresponding to the bounds of the color\\n        range, when zmin or zmax are not passed. If `minmax`, the min and max\\n        values of the image are used. If `infer`, a heuristic based on the image\\n        data type is used.\\n\\n    binary_string: bool, default None\\n        if True, the image data are first rescaled and encoded as uint8 and\\n        then passed to plotly.js as a b64 PNG string. If False, data are passed\\n        unchanged as a numerical array. Setting to True may lead to performance\\n        gains, at the cost of a loss of precision depending on the original data\\n        type. If None, use_binary_string is set to True for multichannel (eg) RGB\\n        arrays, and to False for single-channel (2D) arrays. 2D arrays are\\n        represented as grayscale and with no colorbar if use_binary_string is\\n        True.\\n\\n    binary_backend: str, 'auto' (default), 'pil' or 'pypng'\\n        Third-party package for the transformation of numpy arrays to\\n        png b64 strings. If 'auto', Pillow is used if installed,  otherwise\\n        pypng.\\n\\n    binary_compression_level: int, between 0 and 9 (default 4)\\n        png compression level to be passed to the backend when transforming an\\n        array to a png b64 string. Increasing `binary_compression` decreases the\\n        size of the png string, but the compression step takes more time. For most\\n        images it is not worth using levels greater than 5, but it's possible to\\n        test `len(fig.data[0].source)` and to time the execution of `imshow` to\\n        tune the level of compression. 0 means no compression (not recommended).\\n\\n    binary_format: str, 'png' (default) or 'jpg'\\n        compression format used to generate b64 string. 'png' is recommended\\n        since it uses lossless compression, but 'jpg' (lossy) compression can\\n        result if smaller binary strings for natural images.\\n\\n    text_auto: bool or str (default `False`)\\n        If `True` or a string, single-channel `img` values will be displayed as text.\\n        A string like `'.2f'` will be interpreted as a `texttemplate` numeric formatting directive.\\n\\n    Returns\\n    -------\\n    fig : graph_objects.Figure containing the displayed image\\n\\n    See also\\n    --------\\n\\n    plotly.graph_objects.Image : image trace\\n    plotly.graph_objects.Heatmap : heatmap trace\\n\\n    Notes\\n    -----\\n\\n    In order to update and customize the returned figure, use\\n    `go.Figure.update_traces` or `go.Figure.update_layout`.\\n\\n    If an xarray is passed, dimensions names and coordinates are used for\\n    axes labels and ticks.\\n    \"\n    args = locals()\n    apply_default_cascade(args)\n    labels = labels.copy()\n    nslices_facet = 1\n    if facet_col is not None:\n        if isinstance(facet_col, str):\n            facet_col = img.dims.index(facet_col)\n        nslices_facet = img.shape[facet_col]\n        facet_slices = range(nslices_facet)\n        ncols = int(facet_col_wrap) if facet_col_wrap is not None else nslices_facet\n        nrows = nslices_facet // ncols + 1 if nslices_facet % ncols else nslices_facet // ncols\n    else:\n        nrows = 1\n        ncols = 1\n    if animation_frame is not None:\n        if isinstance(animation_frame, str):\n            animation_frame = img.dims.index(animation_frame)\n        nslices_animation = img.shape[animation_frame]\n        animation_slices = range(nslices_animation)\n    slice_dimensions = (facet_col is not None) + (animation_frame is not None)\n    facet_label = None\n    animation_label = None\n    img_is_xarray = False\n    if xarray_imported and isinstance(img, xarray.DataArray):\n        dims = list(img.dims)\n        img_is_xarray = True\n        pop_indexes = []\n        if facet_col is not None:\n            facet_slices = img.coords[img.dims[facet_col]].values\n            pop_indexes.append(facet_col)\n            facet_label = img.dims[facet_col]\n        if animation_frame is not None:\n            animation_slices = img.coords[img.dims[animation_frame]].values\n            pop_indexes.append(animation_frame)\n            animation_label = img.dims[animation_frame]\n        for index in sorted(pop_indexes, reverse=True):\n            _ = dims.pop(index)\n        (y_label, x_label) = (dims[0], dims[1])\n        for ax in [x_label, y_label]:\n            if np.issubdtype(img.coords[ax].dtype, np.datetime64):\n                img.coords[ax] = img.coords[ax].astype(str)\n        if x is None:\n            x = img.coords[x_label].values\n        if y is None:\n            y = img.coords[y_label].values\n        if aspect is None:\n            aspect = 'auto'\n        if labels.get('x', None) is None:\n            labels['x'] = x_label\n        if labels.get('y', None) is None:\n            labels['y'] = y_label\n        if labels.get('animation_frame', None) is None:\n            labels['animation_frame'] = animation_label\n        if labels.get('facet_col', None) is None:\n            labels['facet_col'] = facet_label\n        if labels.get('color', None) is None:\n            labels['color'] = xarray.plot.utils.label_from_attrs(img)\n            labels['color'] = labels['color'].replace('\\n', '<br>')\n    else:\n        if hasattr(img, 'columns') and hasattr(img.columns, '__len__'):\n            if x is None:\n                x = img.columns\n            if labels.get('x', None) is None and hasattr(img.columns, 'name'):\n                labels['x'] = img.columns.name or ''\n        if hasattr(img, 'index') and hasattr(img.index, '__len__'):\n            if y is None:\n                y = img.index\n            if labels.get('y', None) is None and hasattr(img.index, 'name'):\n                labels['y'] = img.index.name or ''\n        if labels.get('x', None) is None:\n            labels['x'] = ''\n        if labels.get('y', None) is None:\n            labels['y'] = ''\n        if labels.get('color', None) is None:\n            labels['color'] = ''\n        if aspect is None:\n            aspect = 'equal'\n    if isinstance(img, pd.DataFrame):\n        if binary_string:\n            raise ValueError('Binary strings cannot be used with pandas arrays')\n        is_dataframe = True\n    else:\n        is_dataframe = False\n    img = np.asanyarray(img)\n    if facet_col is not None:\n        img = np.moveaxis(img, facet_col, 0)\n        if animation_frame is not None and animation_frame < facet_col:\n            animation_frame += 1\n        facet_col = True\n    if animation_frame is not None:\n        img = np.moveaxis(img, animation_frame, 0)\n        animation_frame = True\n        args['animation_frame'] = 'animation_frame' if labels.get('animation_frame') is None else labels['animation_frame']\n    iterables = ()\n    if animation_frame is not None:\n        iterables += (range(nslices_animation),)\n    if facet_col is not None:\n        iterables += (range(nslices_facet),)\n    if binary_string is None:\n        binary_string = img.ndim >= 3 + slice_dimensions and (not is_dataframe)\n    if img.dtype == bool:\n        img = 255 * img.astype(np.uint8)\n    if range_color is not None:\n        zmin = range_color[0]\n        zmax = range_color[1]\n    if contrast_rescaling is None:\n        contrast_rescaling = 'minmax' if img.ndim == 2 + slice_dimensions else 'infer'\n    if contrast_rescaling == 'minmax':\n        if (zmin is not None or binary_string) and zmax is None:\n            zmax = img.max()\n        if (zmax is not None or binary_string) and zmin is None:\n            zmin = img.min()\n    else:\n        if zmax is None and img.dtype != np.uint8:\n            zmax = _infer_zmax_from_type(img)\n        if zmin is None and zmax is not None:\n            zmin = 0\n    if img.ndim == 2 + slice_dimensions and (not binary_string):\n        y_index = slice_dimensions\n        if y is not None and img.shape[y_index] != len(y):\n            raise ValueError('The length of the y vector must match the length of the first ' + 'dimension of the img matrix.')\n        x_index = slice_dimensions + 1\n        if x is not None and img.shape[x_index] != len(x):\n            raise ValueError('The length of the x vector must match the length of the second ' + 'dimension of the img matrix.')\n        texttemplate = None\n        if text_auto is True:\n            texttemplate = '%{z}'\n        elif text_auto is not False:\n            texttemplate = '%{z:' + text_auto + '}'\n        traces = [go.Heatmap(x=x, y=y, z=img[index_tup], coloraxis='coloraxis1', name=str(i), texttemplate=texttemplate) for (i, index_tup) in enumerate(itertools.product(*iterables))]\n        autorange = True if origin == 'lower' else 'reversed'\n        layout = dict(yaxis=dict(autorange=autorange))\n        if aspect == 'equal':\n            layout['xaxis'] = dict(scaleanchor='y', constrain='domain')\n            layout['yaxis']['constrain'] = 'domain'\n        colorscale_validator = ColorscaleValidator('colorscale', 'imshow')\n        layout['coloraxis1'] = dict(colorscale=colorscale_validator.validate_coerce(args['color_continuous_scale']), cmid=color_continuous_midpoint, cmin=zmin, cmax=zmax)\n        if labels['color']:\n            layout['coloraxis1']['colorbar'] = dict(title_text=labels['color'])\n    elif img.ndim >= 3 and (img.shape[-1] in [3, 4] or (slice_dimensions and binary_string)) or (img.ndim == 2 and binary_string):\n        rescale_image = True\n        if zmin is not None and zmax is not None:\n            (zmin, zmax) = (_vectorize_zvalue(zmin, mode='min'), _vectorize_zvalue(zmax, mode='max'))\n        (x0, y0, dx, dy) = (None,) * 4\n        error_msg_xarray = 'Non-numerical coordinates were passed with xarray `img`, but the Image trace cannot handle it. Please use `binary_string=False` for 2D data or pass instead the numpy array `img.values` to `px.imshow`.'\n        if x is not None:\n            x = np.asanyarray(x)\n            if np.issubdtype(x.dtype, np.number):\n                x0 = x[0]\n                dx = x[1] - x[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `x` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if y is not None:\n            y = np.asanyarray(y)\n            if np.issubdtype(y.dtype, np.number):\n                y0 = y[0]\n                dy = y[1] - y[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `y` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if binary_string:\n            if zmin is None and zmax is None:\n                img_rescaled = img\n                rescale_image = False\n            elif img.ndim == 2 + slice_dimensions:\n                img_rescaled = rescale_intensity(img, in_range=(zmin[0], zmax[0]), out_range=np.uint8)\n            else:\n                img_rescaled = np.stack([rescale_intensity(img[..., ch], in_range=(zmin[ch], zmax[ch]), out_range=np.uint8) for ch in range(img.shape[-1])], axis=-1)\n            img_str = [image_array_to_data_uri(img_rescaled[index_tup], backend=binary_backend, compression=binary_compression_level, ext=binary_format) for index_tup in itertools.product(*iterables)]\n            traces = [go.Image(source=img_str_slice, name=str(i), x0=x0, y0=y0, dx=dx, dy=dy) for (i, img_str_slice) in enumerate(img_str)]\n        else:\n            colormodel = 'rgb' if img.shape[-1] == 3 else 'rgba256'\n            traces = [go.Image(z=img[index_tup], zmin=zmin, zmax=zmax, colormodel=colormodel, x0=x0, y0=y0, dx=dx, dy=dy) for index_tup in itertools.product(*iterables)]\n        layout = {}\n        if origin == 'lower' or (dy is not None and dy < 0):\n            layout['yaxis'] = dict(autorange=True)\n        if dx is not None and dx < 0:\n            layout['xaxis'] = dict(autorange='reversed')\n    else:\n        raise ValueError('px.imshow only accepts 2D single-channel, RGB or RGBA images. An image of shape %s was provided. Alternatively, 3- or 4-D single or multichannel datasets can be visualized using the `facet_col` or/and `animation_frame` arguments.' % str(img.shape))\n    col_labels = []\n    if facet_col is not None:\n        slice_label = 'facet_col' if labels.get('facet_col') is None else labels['facet_col']\n        col_labels = [f'{slice_label}={i}' for i in facet_slices]\n    fig = init_figure(args, 'xy', [], nrows, ncols, col_labels, [])\n    for attr_name in ['height', 'width']:\n        if args[attr_name]:\n            layout[attr_name] = args[attr_name]\n    if args['title']:\n        layout['title_text'] = args['title']\n    elif args['template'].layout.margin.t is None:\n        layout['margin'] = {'t': 60}\n    frame_list = []\n    for (index, trace) in enumerate(traces):\n        if facet_col and index < nrows * ncols or index == 0:\n            fig.add_trace(trace, row=nrows - index // ncols, col=index % ncols + 1)\n    if animation_frame is not None:\n        for (i, index) in zip(range(nslices_animation), animation_slices):\n            frame_list.append(dict(data=traces[nslices_facet * i:nslices_facet * (i + 1)], layout=layout, name=str(index)))\n    if animation_frame:\n        fig.frames = frame_list\n    fig.update_layout(layout)\n    if binary_string and rescale_image and (not np.all(img == img_rescaled)):\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y')\n    else:\n        if trace['type'] == 'heatmap':\n            hover_name = '%{z}'\n        elif img.ndim == 2:\n            hover_name = '%{z[0]}'\n        elif img.ndim == 3 and img.shape[-1] == 3:\n            hover_name = '[%{z[0]}, %{z[1]}, %{z[2]}]'\n        else:\n            hover_name = '%{z}'\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<br>%s: %s<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y', labels['color'] or 'color', hover_name)\n    fig.update_traces(hovertemplate=hovertemplate)\n    if labels['x']:\n        fig.update_xaxes(title_text=labels['x'], row=1)\n    if labels['y']:\n        fig.update_yaxes(title_text=labels['y'], col=1)\n    configure_animation_controls(args, go.Image, fig)\n    fig.update_layout(template=args['template'], overwrite=True)\n    return fig",
            "def imshow(img, zmin=None, zmax=None, origin=None, labels={}, x=None, y=None, animation_frame=None, facet_col=None, facet_col_wrap=None, facet_col_spacing=None, facet_row_spacing=None, color_continuous_scale=None, color_continuous_midpoint=None, range_color=None, title=None, template=None, width=None, height=None, aspect=None, contrast_rescaling=None, binary_string=None, binary_backend='auto', binary_compression_level=4, binary_format='png', text_auto=False) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Display an image, i.e. data on a 2D regular raster.\\n\\n    Parameters\\n    ----------\\n\\n    img: array-like image, or xarray\\n        The image data. Supported array shapes are\\n\\n        - (M, N): an image with scalar data. The data is visualized\\n          using a colormap.\\n        - (M, N, 3): an image with RGB values.\\n        - (M, N, 4): an image with RGBA values, i.e. including transparency.\\n\\n    zmin, zmax : scalar or iterable, optional\\n        zmin and zmax define the scalar range that the colormap covers. By default,\\n        zmin and zmax correspond to the min and max values of the datatype for integer\\n        datatypes (ie [0-255] for uint8 images, [0, 65535] for uint16 images, etc.). For\\n        a multichannel image of floats, the max of the image is computed and zmax is the\\n        smallest power of 256 (1, 255, 65535) greater than this max value,\\n        with a 5% tolerance. For a single-channel image, the max of the image is used.\\n        Overridden by range_color.\\n\\n    origin : str, 'upper' or 'lower' (default 'upper')\\n        position of the [0, 0] pixel of the image array, in the upper left or lower left\\n        corner. The convention 'upper' is typically used for matrices and images.\\n\\n    labels : dict with str keys and str values (default `{}`)\\n        Sets names used in the figure for axis titles (keys ``x`` and ``y``),\\n        colorbar title and hoverlabel (key ``color``). The values should correspond\\n        to the desired label to be displayed. If ``img`` is an xarray, dimension\\n        names are used for axis titles, and long name for the colorbar title\\n        (unless overridden in ``labels``). Possible keys are: x, y, and color.\\n\\n    x, y: list-like, optional\\n        x and y are used to label the axes of single-channel heatmap visualizations and\\n        their lengths must match the lengths of the second and first dimensions of the\\n        img argument. They are auto-populated if the input is an xarray.\\n\\n    animation_frame: int or str, optional (default None)\\n        axis number along which the image array is sliced to create an animation plot.\\n        If `img` is an xarray, `animation_frame` can be the name of one the dimensions.\\n\\n    facet_col: int or str, optional (default None)\\n        axis number along which the image array is sliced to create a facetted plot.\\n        If `img` is an xarray, `facet_col` can be the name of one the dimensions.\\n\\n    facet_col_wrap: int\\n        Maximum number of facet columns. Wraps the column variable at this width,\\n        so that the column facets span multiple rows.\\n        Ignored if `facet_col` is None.\\n\\n    facet_col_spacing: float between 0 and 1\\n        Spacing between facet columns, in paper units. Default is 0.02.\\n\\n    facet_row_spacing: float between 0 and 1\\n        Spacing between facet rows created when ``facet_col_wrap`` is used, in\\n        paper units. Default is 0.0.7.\\n\\n    color_continuous_scale : str or list of str\\n        colormap used to map scalar data to colors (for a 2D image). This parameter is\\n        not used for RGB or RGBA images. If a string is provided, it should be the name\\n        of a known color scale, and if a list is provided, it should be a list of CSS-\\n        compatible colors.\\n\\n    color_continuous_midpoint : number\\n        If set, computes the bounds of the continuous color scale to have the desired\\n        midpoint. Overridden by range_color or zmin and zmax.\\n\\n    range_color : list of two numbers\\n        If provided, overrides auto-scaling on the continuous color scale, including\\n        overriding `color_continuous_midpoint`. Also overrides zmin and zmax. Used only\\n        for single-channel images.\\n\\n    title : str\\n        The figure title.\\n\\n    template : str or dict or plotly.graph_objects.layout.Template instance\\n        The figure template name or definition.\\n\\n    width : number\\n        The figure width in pixels.\\n\\n    height: number\\n        The figure height in pixels.\\n\\n    aspect: 'equal', 'auto', or None\\n      - 'equal': Ensures an aspect ratio of 1 or pixels (square pixels)\\n      - 'auto': The axes is kept fixed and the aspect ratio of pixels is\\n        adjusted so that the data fit in the axes. In general, this will\\n        result in non-square pixels.\\n      - if None, 'equal' is used for numpy arrays and 'auto' for xarrays\\n        (which have typically heterogeneous coordinates)\\n\\n    contrast_rescaling: 'minmax', 'infer', or None\\n        how to determine data values corresponding to the bounds of the color\\n        range, when zmin or zmax are not passed. If `minmax`, the min and max\\n        values of the image are used. If `infer`, a heuristic based on the image\\n        data type is used.\\n\\n    binary_string: bool, default None\\n        if True, the image data are first rescaled and encoded as uint8 and\\n        then passed to plotly.js as a b64 PNG string. If False, data are passed\\n        unchanged as a numerical array. Setting to True may lead to performance\\n        gains, at the cost of a loss of precision depending on the original data\\n        type. If None, use_binary_string is set to True for multichannel (eg) RGB\\n        arrays, and to False for single-channel (2D) arrays. 2D arrays are\\n        represented as grayscale and with no colorbar if use_binary_string is\\n        True.\\n\\n    binary_backend: str, 'auto' (default), 'pil' or 'pypng'\\n        Third-party package for the transformation of numpy arrays to\\n        png b64 strings. If 'auto', Pillow is used if installed,  otherwise\\n        pypng.\\n\\n    binary_compression_level: int, between 0 and 9 (default 4)\\n        png compression level to be passed to the backend when transforming an\\n        array to a png b64 string. Increasing `binary_compression` decreases the\\n        size of the png string, but the compression step takes more time. For most\\n        images it is not worth using levels greater than 5, but it's possible to\\n        test `len(fig.data[0].source)` and to time the execution of `imshow` to\\n        tune the level of compression. 0 means no compression (not recommended).\\n\\n    binary_format: str, 'png' (default) or 'jpg'\\n        compression format used to generate b64 string. 'png' is recommended\\n        since it uses lossless compression, but 'jpg' (lossy) compression can\\n        result if smaller binary strings for natural images.\\n\\n    text_auto: bool or str (default `False`)\\n        If `True` or a string, single-channel `img` values will be displayed as text.\\n        A string like `'.2f'` will be interpreted as a `texttemplate` numeric formatting directive.\\n\\n    Returns\\n    -------\\n    fig : graph_objects.Figure containing the displayed image\\n\\n    See also\\n    --------\\n\\n    plotly.graph_objects.Image : image trace\\n    plotly.graph_objects.Heatmap : heatmap trace\\n\\n    Notes\\n    -----\\n\\n    In order to update and customize the returned figure, use\\n    `go.Figure.update_traces` or `go.Figure.update_layout`.\\n\\n    If an xarray is passed, dimensions names and coordinates are used for\\n    axes labels and ticks.\\n    \"\n    args = locals()\n    apply_default_cascade(args)\n    labels = labels.copy()\n    nslices_facet = 1\n    if facet_col is not None:\n        if isinstance(facet_col, str):\n            facet_col = img.dims.index(facet_col)\n        nslices_facet = img.shape[facet_col]\n        facet_slices = range(nslices_facet)\n        ncols = int(facet_col_wrap) if facet_col_wrap is not None else nslices_facet\n        nrows = nslices_facet // ncols + 1 if nslices_facet % ncols else nslices_facet // ncols\n    else:\n        nrows = 1\n        ncols = 1\n    if animation_frame is not None:\n        if isinstance(animation_frame, str):\n            animation_frame = img.dims.index(animation_frame)\n        nslices_animation = img.shape[animation_frame]\n        animation_slices = range(nslices_animation)\n    slice_dimensions = (facet_col is not None) + (animation_frame is not None)\n    facet_label = None\n    animation_label = None\n    img_is_xarray = False\n    if xarray_imported and isinstance(img, xarray.DataArray):\n        dims = list(img.dims)\n        img_is_xarray = True\n        pop_indexes = []\n        if facet_col is not None:\n            facet_slices = img.coords[img.dims[facet_col]].values\n            pop_indexes.append(facet_col)\n            facet_label = img.dims[facet_col]\n        if animation_frame is not None:\n            animation_slices = img.coords[img.dims[animation_frame]].values\n            pop_indexes.append(animation_frame)\n            animation_label = img.dims[animation_frame]\n        for index in sorted(pop_indexes, reverse=True):\n            _ = dims.pop(index)\n        (y_label, x_label) = (dims[0], dims[1])\n        for ax in [x_label, y_label]:\n            if np.issubdtype(img.coords[ax].dtype, np.datetime64):\n                img.coords[ax] = img.coords[ax].astype(str)\n        if x is None:\n            x = img.coords[x_label].values\n        if y is None:\n            y = img.coords[y_label].values\n        if aspect is None:\n            aspect = 'auto'\n        if labels.get('x', None) is None:\n            labels['x'] = x_label\n        if labels.get('y', None) is None:\n            labels['y'] = y_label\n        if labels.get('animation_frame', None) is None:\n            labels['animation_frame'] = animation_label\n        if labels.get('facet_col', None) is None:\n            labels['facet_col'] = facet_label\n        if labels.get('color', None) is None:\n            labels['color'] = xarray.plot.utils.label_from_attrs(img)\n            labels['color'] = labels['color'].replace('\\n', '<br>')\n    else:\n        if hasattr(img, 'columns') and hasattr(img.columns, '__len__'):\n            if x is None:\n                x = img.columns\n            if labels.get('x', None) is None and hasattr(img.columns, 'name'):\n                labels['x'] = img.columns.name or ''\n        if hasattr(img, 'index') and hasattr(img.index, '__len__'):\n            if y is None:\n                y = img.index\n            if labels.get('y', None) is None and hasattr(img.index, 'name'):\n                labels['y'] = img.index.name or ''\n        if labels.get('x', None) is None:\n            labels['x'] = ''\n        if labels.get('y', None) is None:\n            labels['y'] = ''\n        if labels.get('color', None) is None:\n            labels['color'] = ''\n        if aspect is None:\n            aspect = 'equal'\n    if isinstance(img, pd.DataFrame):\n        if binary_string:\n            raise ValueError('Binary strings cannot be used with pandas arrays')\n        is_dataframe = True\n    else:\n        is_dataframe = False\n    img = np.asanyarray(img)\n    if facet_col is not None:\n        img = np.moveaxis(img, facet_col, 0)\n        if animation_frame is not None and animation_frame < facet_col:\n            animation_frame += 1\n        facet_col = True\n    if animation_frame is not None:\n        img = np.moveaxis(img, animation_frame, 0)\n        animation_frame = True\n        args['animation_frame'] = 'animation_frame' if labels.get('animation_frame') is None else labels['animation_frame']\n    iterables = ()\n    if animation_frame is not None:\n        iterables += (range(nslices_animation),)\n    if facet_col is not None:\n        iterables += (range(nslices_facet),)\n    if binary_string is None:\n        binary_string = img.ndim >= 3 + slice_dimensions and (not is_dataframe)\n    if img.dtype == bool:\n        img = 255 * img.astype(np.uint8)\n    if range_color is not None:\n        zmin = range_color[0]\n        zmax = range_color[1]\n    if contrast_rescaling is None:\n        contrast_rescaling = 'minmax' if img.ndim == 2 + slice_dimensions else 'infer'\n    if contrast_rescaling == 'minmax':\n        if (zmin is not None or binary_string) and zmax is None:\n            zmax = img.max()\n        if (zmax is not None or binary_string) and zmin is None:\n            zmin = img.min()\n    else:\n        if zmax is None and img.dtype != np.uint8:\n            zmax = _infer_zmax_from_type(img)\n        if zmin is None and zmax is not None:\n            zmin = 0\n    if img.ndim == 2 + slice_dimensions and (not binary_string):\n        y_index = slice_dimensions\n        if y is not None and img.shape[y_index] != len(y):\n            raise ValueError('The length of the y vector must match the length of the first ' + 'dimension of the img matrix.')\n        x_index = slice_dimensions + 1\n        if x is not None and img.shape[x_index] != len(x):\n            raise ValueError('The length of the x vector must match the length of the second ' + 'dimension of the img matrix.')\n        texttemplate = None\n        if text_auto is True:\n            texttemplate = '%{z}'\n        elif text_auto is not False:\n            texttemplate = '%{z:' + text_auto + '}'\n        traces = [go.Heatmap(x=x, y=y, z=img[index_tup], coloraxis='coloraxis1', name=str(i), texttemplate=texttemplate) for (i, index_tup) in enumerate(itertools.product(*iterables))]\n        autorange = True if origin == 'lower' else 'reversed'\n        layout = dict(yaxis=dict(autorange=autorange))\n        if aspect == 'equal':\n            layout['xaxis'] = dict(scaleanchor='y', constrain='domain')\n            layout['yaxis']['constrain'] = 'domain'\n        colorscale_validator = ColorscaleValidator('colorscale', 'imshow')\n        layout['coloraxis1'] = dict(colorscale=colorscale_validator.validate_coerce(args['color_continuous_scale']), cmid=color_continuous_midpoint, cmin=zmin, cmax=zmax)\n        if labels['color']:\n            layout['coloraxis1']['colorbar'] = dict(title_text=labels['color'])\n    elif img.ndim >= 3 and (img.shape[-1] in [3, 4] or (slice_dimensions and binary_string)) or (img.ndim == 2 and binary_string):\n        rescale_image = True\n        if zmin is not None and zmax is not None:\n            (zmin, zmax) = (_vectorize_zvalue(zmin, mode='min'), _vectorize_zvalue(zmax, mode='max'))\n        (x0, y0, dx, dy) = (None,) * 4\n        error_msg_xarray = 'Non-numerical coordinates were passed with xarray `img`, but the Image trace cannot handle it. Please use `binary_string=False` for 2D data or pass instead the numpy array `img.values` to `px.imshow`.'\n        if x is not None:\n            x = np.asanyarray(x)\n            if np.issubdtype(x.dtype, np.number):\n                x0 = x[0]\n                dx = x[1] - x[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `x` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if y is not None:\n            y = np.asanyarray(y)\n            if np.issubdtype(y.dtype, np.number):\n                y0 = y[0]\n                dy = y[1] - y[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `y` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if binary_string:\n            if zmin is None and zmax is None:\n                img_rescaled = img\n                rescale_image = False\n            elif img.ndim == 2 + slice_dimensions:\n                img_rescaled = rescale_intensity(img, in_range=(zmin[0], zmax[0]), out_range=np.uint8)\n            else:\n                img_rescaled = np.stack([rescale_intensity(img[..., ch], in_range=(zmin[ch], zmax[ch]), out_range=np.uint8) for ch in range(img.shape[-1])], axis=-1)\n            img_str = [image_array_to_data_uri(img_rescaled[index_tup], backend=binary_backend, compression=binary_compression_level, ext=binary_format) for index_tup in itertools.product(*iterables)]\n            traces = [go.Image(source=img_str_slice, name=str(i), x0=x0, y0=y0, dx=dx, dy=dy) for (i, img_str_slice) in enumerate(img_str)]\n        else:\n            colormodel = 'rgb' if img.shape[-1] == 3 else 'rgba256'\n            traces = [go.Image(z=img[index_tup], zmin=zmin, zmax=zmax, colormodel=colormodel, x0=x0, y0=y0, dx=dx, dy=dy) for index_tup in itertools.product(*iterables)]\n        layout = {}\n        if origin == 'lower' or (dy is not None and dy < 0):\n            layout['yaxis'] = dict(autorange=True)\n        if dx is not None and dx < 0:\n            layout['xaxis'] = dict(autorange='reversed')\n    else:\n        raise ValueError('px.imshow only accepts 2D single-channel, RGB or RGBA images. An image of shape %s was provided. Alternatively, 3- or 4-D single or multichannel datasets can be visualized using the `facet_col` or/and `animation_frame` arguments.' % str(img.shape))\n    col_labels = []\n    if facet_col is not None:\n        slice_label = 'facet_col' if labels.get('facet_col') is None else labels['facet_col']\n        col_labels = [f'{slice_label}={i}' for i in facet_slices]\n    fig = init_figure(args, 'xy', [], nrows, ncols, col_labels, [])\n    for attr_name in ['height', 'width']:\n        if args[attr_name]:\n            layout[attr_name] = args[attr_name]\n    if args['title']:\n        layout['title_text'] = args['title']\n    elif args['template'].layout.margin.t is None:\n        layout['margin'] = {'t': 60}\n    frame_list = []\n    for (index, trace) in enumerate(traces):\n        if facet_col and index < nrows * ncols or index == 0:\n            fig.add_trace(trace, row=nrows - index // ncols, col=index % ncols + 1)\n    if animation_frame is not None:\n        for (i, index) in zip(range(nslices_animation), animation_slices):\n            frame_list.append(dict(data=traces[nslices_facet * i:nslices_facet * (i + 1)], layout=layout, name=str(index)))\n    if animation_frame:\n        fig.frames = frame_list\n    fig.update_layout(layout)\n    if binary_string and rescale_image and (not np.all(img == img_rescaled)):\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y')\n    else:\n        if trace['type'] == 'heatmap':\n            hover_name = '%{z}'\n        elif img.ndim == 2:\n            hover_name = '%{z[0]}'\n        elif img.ndim == 3 and img.shape[-1] == 3:\n            hover_name = '[%{z[0]}, %{z[1]}, %{z[2]}]'\n        else:\n            hover_name = '%{z}'\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<br>%s: %s<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y', labels['color'] or 'color', hover_name)\n    fig.update_traces(hovertemplate=hovertemplate)\n    if labels['x']:\n        fig.update_xaxes(title_text=labels['x'], row=1)\n    if labels['y']:\n        fig.update_yaxes(title_text=labels['y'], col=1)\n    configure_animation_controls(args, go.Image, fig)\n    fig.update_layout(template=args['template'], overwrite=True)\n    return fig",
            "def imshow(img, zmin=None, zmax=None, origin=None, labels={}, x=None, y=None, animation_frame=None, facet_col=None, facet_col_wrap=None, facet_col_spacing=None, facet_row_spacing=None, color_continuous_scale=None, color_continuous_midpoint=None, range_color=None, title=None, template=None, width=None, height=None, aspect=None, contrast_rescaling=None, binary_string=None, binary_backend='auto', binary_compression_level=4, binary_format='png', text_auto=False) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Display an image, i.e. data on a 2D regular raster.\\n\\n    Parameters\\n    ----------\\n\\n    img: array-like image, or xarray\\n        The image data. Supported array shapes are\\n\\n        - (M, N): an image with scalar data. The data is visualized\\n          using a colormap.\\n        - (M, N, 3): an image with RGB values.\\n        - (M, N, 4): an image with RGBA values, i.e. including transparency.\\n\\n    zmin, zmax : scalar or iterable, optional\\n        zmin and zmax define the scalar range that the colormap covers. By default,\\n        zmin and zmax correspond to the min and max values of the datatype for integer\\n        datatypes (ie [0-255] for uint8 images, [0, 65535] for uint16 images, etc.). For\\n        a multichannel image of floats, the max of the image is computed and zmax is the\\n        smallest power of 256 (1, 255, 65535) greater than this max value,\\n        with a 5% tolerance. For a single-channel image, the max of the image is used.\\n        Overridden by range_color.\\n\\n    origin : str, 'upper' or 'lower' (default 'upper')\\n        position of the [0, 0] pixel of the image array, in the upper left or lower left\\n        corner. The convention 'upper' is typically used for matrices and images.\\n\\n    labels : dict with str keys and str values (default `{}`)\\n        Sets names used in the figure for axis titles (keys ``x`` and ``y``),\\n        colorbar title and hoverlabel (key ``color``). The values should correspond\\n        to the desired label to be displayed. If ``img`` is an xarray, dimension\\n        names are used for axis titles, and long name for the colorbar title\\n        (unless overridden in ``labels``). Possible keys are: x, y, and color.\\n\\n    x, y: list-like, optional\\n        x and y are used to label the axes of single-channel heatmap visualizations and\\n        their lengths must match the lengths of the second and first dimensions of the\\n        img argument. They are auto-populated if the input is an xarray.\\n\\n    animation_frame: int or str, optional (default None)\\n        axis number along which the image array is sliced to create an animation plot.\\n        If `img` is an xarray, `animation_frame` can be the name of one the dimensions.\\n\\n    facet_col: int or str, optional (default None)\\n        axis number along which the image array is sliced to create a facetted plot.\\n        If `img` is an xarray, `facet_col` can be the name of one the dimensions.\\n\\n    facet_col_wrap: int\\n        Maximum number of facet columns. Wraps the column variable at this width,\\n        so that the column facets span multiple rows.\\n        Ignored if `facet_col` is None.\\n\\n    facet_col_spacing: float between 0 and 1\\n        Spacing between facet columns, in paper units. Default is 0.02.\\n\\n    facet_row_spacing: float between 0 and 1\\n        Spacing between facet rows created when ``facet_col_wrap`` is used, in\\n        paper units. Default is 0.0.7.\\n\\n    color_continuous_scale : str or list of str\\n        colormap used to map scalar data to colors (for a 2D image). This parameter is\\n        not used for RGB or RGBA images. If a string is provided, it should be the name\\n        of a known color scale, and if a list is provided, it should be a list of CSS-\\n        compatible colors.\\n\\n    color_continuous_midpoint : number\\n        If set, computes the bounds of the continuous color scale to have the desired\\n        midpoint. Overridden by range_color or zmin and zmax.\\n\\n    range_color : list of two numbers\\n        If provided, overrides auto-scaling on the continuous color scale, including\\n        overriding `color_continuous_midpoint`. Also overrides zmin and zmax. Used only\\n        for single-channel images.\\n\\n    title : str\\n        The figure title.\\n\\n    template : str or dict or plotly.graph_objects.layout.Template instance\\n        The figure template name or definition.\\n\\n    width : number\\n        The figure width in pixels.\\n\\n    height: number\\n        The figure height in pixels.\\n\\n    aspect: 'equal', 'auto', or None\\n      - 'equal': Ensures an aspect ratio of 1 or pixels (square pixels)\\n      - 'auto': The axes is kept fixed and the aspect ratio of pixels is\\n        adjusted so that the data fit in the axes. In general, this will\\n        result in non-square pixels.\\n      - if None, 'equal' is used for numpy arrays and 'auto' for xarrays\\n        (which have typically heterogeneous coordinates)\\n\\n    contrast_rescaling: 'minmax', 'infer', or None\\n        how to determine data values corresponding to the bounds of the color\\n        range, when zmin or zmax are not passed. If `minmax`, the min and max\\n        values of the image are used. If `infer`, a heuristic based on the image\\n        data type is used.\\n\\n    binary_string: bool, default None\\n        if True, the image data are first rescaled and encoded as uint8 and\\n        then passed to plotly.js as a b64 PNG string. If False, data are passed\\n        unchanged as a numerical array. Setting to True may lead to performance\\n        gains, at the cost of a loss of precision depending on the original data\\n        type. If None, use_binary_string is set to True for multichannel (eg) RGB\\n        arrays, and to False for single-channel (2D) arrays. 2D arrays are\\n        represented as grayscale and with no colorbar if use_binary_string is\\n        True.\\n\\n    binary_backend: str, 'auto' (default), 'pil' or 'pypng'\\n        Third-party package for the transformation of numpy arrays to\\n        png b64 strings. If 'auto', Pillow is used if installed,  otherwise\\n        pypng.\\n\\n    binary_compression_level: int, between 0 and 9 (default 4)\\n        png compression level to be passed to the backend when transforming an\\n        array to a png b64 string. Increasing `binary_compression` decreases the\\n        size of the png string, but the compression step takes more time. For most\\n        images it is not worth using levels greater than 5, but it's possible to\\n        test `len(fig.data[0].source)` and to time the execution of `imshow` to\\n        tune the level of compression. 0 means no compression (not recommended).\\n\\n    binary_format: str, 'png' (default) or 'jpg'\\n        compression format used to generate b64 string. 'png' is recommended\\n        since it uses lossless compression, but 'jpg' (lossy) compression can\\n        result if smaller binary strings for natural images.\\n\\n    text_auto: bool or str (default `False`)\\n        If `True` or a string, single-channel `img` values will be displayed as text.\\n        A string like `'.2f'` will be interpreted as a `texttemplate` numeric formatting directive.\\n\\n    Returns\\n    -------\\n    fig : graph_objects.Figure containing the displayed image\\n\\n    See also\\n    --------\\n\\n    plotly.graph_objects.Image : image trace\\n    plotly.graph_objects.Heatmap : heatmap trace\\n\\n    Notes\\n    -----\\n\\n    In order to update and customize the returned figure, use\\n    `go.Figure.update_traces` or `go.Figure.update_layout`.\\n\\n    If an xarray is passed, dimensions names and coordinates are used for\\n    axes labels and ticks.\\n    \"\n    args = locals()\n    apply_default_cascade(args)\n    labels = labels.copy()\n    nslices_facet = 1\n    if facet_col is not None:\n        if isinstance(facet_col, str):\n            facet_col = img.dims.index(facet_col)\n        nslices_facet = img.shape[facet_col]\n        facet_slices = range(nslices_facet)\n        ncols = int(facet_col_wrap) if facet_col_wrap is not None else nslices_facet\n        nrows = nslices_facet // ncols + 1 if nslices_facet % ncols else nslices_facet // ncols\n    else:\n        nrows = 1\n        ncols = 1\n    if animation_frame is not None:\n        if isinstance(animation_frame, str):\n            animation_frame = img.dims.index(animation_frame)\n        nslices_animation = img.shape[animation_frame]\n        animation_slices = range(nslices_animation)\n    slice_dimensions = (facet_col is not None) + (animation_frame is not None)\n    facet_label = None\n    animation_label = None\n    img_is_xarray = False\n    if xarray_imported and isinstance(img, xarray.DataArray):\n        dims = list(img.dims)\n        img_is_xarray = True\n        pop_indexes = []\n        if facet_col is not None:\n            facet_slices = img.coords[img.dims[facet_col]].values\n            pop_indexes.append(facet_col)\n            facet_label = img.dims[facet_col]\n        if animation_frame is not None:\n            animation_slices = img.coords[img.dims[animation_frame]].values\n            pop_indexes.append(animation_frame)\n            animation_label = img.dims[animation_frame]\n        for index in sorted(pop_indexes, reverse=True):\n            _ = dims.pop(index)\n        (y_label, x_label) = (dims[0], dims[1])\n        for ax in [x_label, y_label]:\n            if np.issubdtype(img.coords[ax].dtype, np.datetime64):\n                img.coords[ax] = img.coords[ax].astype(str)\n        if x is None:\n            x = img.coords[x_label].values\n        if y is None:\n            y = img.coords[y_label].values\n        if aspect is None:\n            aspect = 'auto'\n        if labels.get('x', None) is None:\n            labels['x'] = x_label\n        if labels.get('y', None) is None:\n            labels['y'] = y_label\n        if labels.get('animation_frame', None) is None:\n            labels['animation_frame'] = animation_label\n        if labels.get('facet_col', None) is None:\n            labels['facet_col'] = facet_label\n        if labels.get('color', None) is None:\n            labels['color'] = xarray.plot.utils.label_from_attrs(img)\n            labels['color'] = labels['color'].replace('\\n', '<br>')\n    else:\n        if hasattr(img, 'columns') and hasattr(img.columns, '__len__'):\n            if x is None:\n                x = img.columns\n            if labels.get('x', None) is None and hasattr(img.columns, 'name'):\n                labels['x'] = img.columns.name or ''\n        if hasattr(img, 'index') and hasattr(img.index, '__len__'):\n            if y is None:\n                y = img.index\n            if labels.get('y', None) is None and hasattr(img.index, 'name'):\n                labels['y'] = img.index.name or ''\n        if labels.get('x', None) is None:\n            labels['x'] = ''\n        if labels.get('y', None) is None:\n            labels['y'] = ''\n        if labels.get('color', None) is None:\n            labels['color'] = ''\n        if aspect is None:\n            aspect = 'equal'\n    if isinstance(img, pd.DataFrame):\n        if binary_string:\n            raise ValueError('Binary strings cannot be used with pandas arrays')\n        is_dataframe = True\n    else:\n        is_dataframe = False\n    img = np.asanyarray(img)\n    if facet_col is not None:\n        img = np.moveaxis(img, facet_col, 0)\n        if animation_frame is not None and animation_frame < facet_col:\n            animation_frame += 1\n        facet_col = True\n    if animation_frame is not None:\n        img = np.moveaxis(img, animation_frame, 0)\n        animation_frame = True\n        args['animation_frame'] = 'animation_frame' if labels.get('animation_frame') is None else labels['animation_frame']\n    iterables = ()\n    if animation_frame is not None:\n        iterables += (range(nslices_animation),)\n    if facet_col is not None:\n        iterables += (range(nslices_facet),)\n    if binary_string is None:\n        binary_string = img.ndim >= 3 + slice_dimensions and (not is_dataframe)\n    if img.dtype == bool:\n        img = 255 * img.astype(np.uint8)\n    if range_color is not None:\n        zmin = range_color[0]\n        zmax = range_color[1]\n    if contrast_rescaling is None:\n        contrast_rescaling = 'minmax' if img.ndim == 2 + slice_dimensions else 'infer'\n    if contrast_rescaling == 'minmax':\n        if (zmin is not None or binary_string) and zmax is None:\n            zmax = img.max()\n        if (zmax is not None or binary_string) and zmin is None:\n            zmin = img.min()\n    else:\n        if zmax is None and img.dtype != np.uint8:\n            zmax = _infer_zmax_from_type(img)\n        if zmin is None and zmax is not None:\n            zmin = 0\n    if img.ndim == 2 + slice_dimensions and (not binary_string):\n        y_index = slice_dimensions\n        if y is not None and img.shape[y_index] != len(y):\n            raise ValueError('The length of the y vector must match the length of the first ' + 'dimension of the img matrix.')\n        x_index = slice_dimensions + 1\n        if x is not None and img.shape[x_index] != len(x):\n            raise ValueError('The length of the x vector must match the length of the second ' + 'dimension of the img matrix.')\n        texttemplate = None\n        if text_auto is True:\n            texttemplate = '%{z}'\n        elif text_auto is not False:\n            texttemplate = '%{z:' + text_auto + '}'\n        traces = [go.Heatmap(x=x, y=y, z=img[index_tup], coloraxis='coloraxis1', name=str(i), texttemplate=texttemplate) for (i, index_tup) in enumerate(itertools.product(*iterables))]\n        autorange = True if origin == 'lower' else 'reversed'\n        layout = dict(yaxis=dict(autorange=autorange))\n        if aspect == 'equal':\n            layout['xaxis'] = dict(scaleanchor='y', constrain='domain')\n            layout['yaxis']['constrain'] = 'domain'\n        colorscale_validator = ColorscaleValidator('colorscale', 'imshow')\n        layout['coloraxis1'] = dict(colorscale=colorscale_validator.validate_coerce(args['color_continuous_scale']), cmid=color_continuous_midpoint, cmin=zmin, cmax=zmax)\n        if labels['color']:\n            layout['coloraxis1']['colorbar'] = dict(title_text=labels['color'])\n    elif img.ndim >= 3 and (img.shape[-1] in [3, 4] or (slice_dimensions and binary_string)) or (img.ndim == 2 and binary_string):\n        rescale_image = True\n        if zmin is not None and zmax is not None:\n            (zmin, zmax) = (_vectorize_zvalue(zmin, mode='min'), _vectorize_zvalue(zmax, mode='max'))\n        (x0, y0, dx, dy) = (None,) * 4\n        error_msg_xarray = 'Non-numerical coordinates were passed with xarray `img`, but the Image trace cannot handle it. Please use `binary_string=False` for 2D data or pass instead the numpy array `img.values` to `px.imshow`.'\n        if x is not None:\n            x = np.asanyarray(x)\n            if np.issubdtype(x.dtype, np.number):\n                x0 = x[0]\n                dx = x[1] - x[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `x` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if y is not None:\n            y = np.asanyarray(y)\n            if np.issubdtype(y.dtype, np.number):\n                y0 = y[0]\n                dy = y[1] - y[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `y` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if binary_string:\n            if zmin is None and zmax is None:\n                img_rescaled = img\n                rescale_image = False\n            elif img.ndim == 2 + slice_dimensions:\n                img_rescaled = rescale_intensity(img, in_range=(zmin[0], zmax[0]), out_range=np.uint8)\n            else:\n                img_rescaled = np.stack([rescale_intensity(img[..., ch], in_range=(zmin[ch], zmax[ch]), out_range=np.uint8) for ch in range(img.shape[-1])], axis=-1)\n            img_str = [image_array_to_data_uri(img_rescaled[index_tup], backend=binary_backend, compression=binary_compression_level, ext=binary_format) for index_tup in itertools.product(*iterables)]\n            traces = [go.Image(source=img_str_slice, name=str(i), x0=x0, y0=y0, dx=dx, dy=dy) for (i, img_str_slice) in enumerate(img_str)]\n        else:\n            colormodel = 'rgb' if img.shape[-1] == 3 else 'rgba256'\n            traces = [go.Image(z=img[index_tup], zmin=zmin, zmax=zmax, colormodel=colormodel, x0=x0, y0=y0, dx=dx, dy=dy) for index_tup in itertools.product(*iterables)]\n        layout = {}\n        if origin == 'lower' or (dy is not None and dy < 0):\n            layout['yaxis'] = dict(autorange=True)\n        if dx is not None and dx < 0:\n            layout['xaxis'] = dict(autorange='reversed')\n    else:\n        raise ValueError('px.imshow only accepts 2D single-channel, RGB or RGBA images. An image of shape %s was provided. Alternatively, 3- or 4-D single or multichannel datasets can be visualized using the `facet_col` or/and `animation_frame` arguments.' % str(img.shape))\n    col_labels = []\n    if facet_col is not None:\n        slice_label = 'facet_col' if labels.get('facet_col') is None else labels['facet_col']\n        col_labels = [f'{slice_label}={i}' for i in facet_slices]\n    fig = init_figure(args, 'xy', [], nrows, ncols, col_labels, [])\n    for attr_name in ['height', 'width']:\n        if args[attr_name]:\n            layout[attr_name] = args[attr_name]\n    if args['title']:\n        layout['title_text'] = args['title']\n    elif args['template'].layout.margin.t is None:\n        layout['margin'] = {'t': 60}\n    frame_list = []\n    for (index, trace) in enumerate(traces):\n        if facet_col and index < nrows * ncols or index == 0:\n            fig.add_trace(trace, row=nrows - index // ncols, col=index % ncols + 1)\n    if animation_frame is not None:\n        for (i, index) in zip(range(nslices_animation), animation_slices):\n            frame_list.append(dict(data=traces[nslices_facet * i:nslices_facet * (i + 1)], layout=layout, name=str(index)))\n    if animation_frame:\n        fig.frames = frame_list\n    fig.update_layout(layout)\n    if binary_string and rescale_image and (not np.all(img == img_rescaled)):\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y')\n    else:\n        if trace['type'] == 'heatmap':\n            hover_name = '%{z}'\n        elif img.ndim == 2:\n            hover_name = '%{z[0]}'\n        elif img.ndim == 3 and img.shape[-1] == 3:\n            hover_name = '[%{z[0]}, %{z[1]}, %{z[2]}]'\n        else:\n            hover_name = '%{z}'\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<br>%s: %s<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y', labels['color'] or 'color', hover_name)\n    fig.update_traces(hovertemplate=hovertemplate)\n    if labels['x']:\n        fig.update_xaxes(title_text=labels['x'], row=1)\n    if labels['y']:\n        fig.update_yaxes(title_text=labels['y'], col=1)\n    configure_animation_controls(args, go.Image, fig)\n    fig.update_layout(template=args['template'], overwrite=True)\n    return fig",
            "def imshow(img, zmin=None, zmax=None, origin=None, labels={}, x=None, y=None, animation_frame=None, facet_col=None, facet_col_wrap=None, facet_col_spacing=None, facet_row_spacing=None, color_continuous_scale=None, color_continuous_midpoint=None, range_color=None, title=None, template=None, width=None, height=None, aspect=None, contrast_rescaling=None, binary_string=None, binary_backend='auto', binary_compression_level=4, binary_format='png', text_auto=False) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Display an image, i.e. data on a 2D regular raster.\\n\\n    Parameters\\n    ----------\\n\\n    img: array-like image, or xarray\\n        The image data. Supported array shapes are\\n\\n        - (M, N): an image with scalar data. The data is visualized\\n          using a colormap.\\n        - (M, N, 3): an image with RGB values.\\n        - (M, N, 4): an image with RGBA values, i.e. including transparency.\\n\\n    zmin, zmax : scalar or iterable, optional\\n        zmin and zmax define the scalar range that the colormap covers. By default,\\n        zmin and zmax correspond to the min and max values of the datatype for integer\\n        datatypes (ie [0-255] for uint8 images, [0, 65535] for uint16 images, etc.). For\\n        a multichannel image of floats, the max of the image is computed and zmax is the\\n        smallest power of 256 (1, 255, 65535) greater than this max value,\\n        with a 5% tolerance. For a single-channel image, the max of the image is used.\\n        Overridden by range_color.\\n\\n    origin : str, 'upper' or 'lower' (default 'upper')\\n        position of the [0, 0] pixel of the image array, in the upper left or lower left\\n        corner. The convention 'upper' is typically used for matrices and images.\\n\\n    labels : dict with str keys and str values (default `{}`)\\n        Sets names used in the figure for axis titles (keys ``x`` and ``y``),\\n        colorbar title and hoverlabel (key ``color``). The values should correspond\\n        to the desired label to be displayed. If ``img`` is an xarray, dimension\\n        names are used for axis titles, and long name for the colorbar title\\n        (unless overridden in ``labels``). Possible keys are: x, y, and color.\\n\\n    x, y: list-like, optional\\n        x and y are used to label the axes of single-channel heatmap visualizations and\\n        their lengths must match the lengths of the second and first dimensions of the\\n        img argument. They are auto-populated if the input is an xarray.\\n\\n    animation_frame: int or str, optional (default None)\\n        axis number along which the image array is sliced to create an animation plot.\\n        If `img` is an xarray, `animation_frame` can be the name of one the dimensions.\\n\\n    facet_col: int or str, optional (default None)\\n        axis number along which the image array is sliced to create a facetted plot.\\n        If `img` is an xarray, `facet_col` can be the name of one the dimensions.\\n\\n    facet_col_wrap: int\\n        Maximum number of facet columns. Wraps the column variable at this width,\\n        so that the column facets span multiple rows.\\n        Ignored if `facet_col` is None.\\n\\n    facet_col_spacing: float between 0 and 1\\n        Spacing between facet columns, in paper units. Default is 0.02.\\n\\n    facet_row_spacing: float between 0 and 1\\n        Spacing between facet rows created when ``facet_col_wrap`` is used, in\\n        paper units. Default is 0.0.7.\\n\\n    color_continuous_scale : str or list of str\\n        colormap used to map scalar data to colors (for a 2D image). This parameter is\\n        not used for RGB or RGBA images. If a string is provided, it should be the name\\n        of a known color scale, and if a list is provided, it should be a list of CSS-\\n        compatible colors.\\n\\n    color_continuous_midpoint : number\\n        If set, computes the bounds of the continuous color scale to have the desired\\n        midpoint. Overridden by range_color or zmin and zmax.\\n\\n    range_color : list of two numbers\\n        If provided, overrides auto-scaling on the continuous color scale, including\\n        overriding `color_continuous_midpoint`. Also overrides zmin and zmax. Used only\\n        for single-channel images.\\n\\n    title : str\\n        The figure title.\\n\\n    template : str or dict or plotly.graph_objects.layout.Template instance\\n        The figure template name or definition.\\n\\n    width : number\\n        The figure width in pixels.\\n\\n    height: number\\n        The figure height in pixels.\\n\\n    aspect: 'equal', 'auto', or None\\n      - 'equal': Ensures an aspect ratio of 1 or pixels (square pixels)\\n      - 'auto': The axes is kept fixed and the aspect ratio of pixels is\\n        adjusted so that the data fit in the axes. In general, this will\\n        result in non-square pixels.\\n      - if None, 'equal' is used for numpy arrays and 'auto' for xarrays\\n        (which have typically heterogeneous coordinates)\\n\\n    contrast_rescaling: 'minmax', 'infer', or None\\n        how to determine data values corresponding to the bounds of the color\\n        range, when zmin or zmax are not passed. If `minmax`, the min and max\\n        values of the image are used. If `infer`, a heuristic based on the image\\n        data type is used.\\n\\n    binary_string: bool, default None\\n        if True, the image data are first rescaled and encoded as uint8 and\\n        then passed to plotly.js as a b64 PNG string. If False, data are passed\\n        unchanged as a numerical array. Setting to True may lead to performance\\n        gains, at the cost of a loss of precision depending on the original data\\n        type. If None, use_binary_string is set to True for multichannel (eg) RGB\\n        arrays, and to False for single-channel (2D) arrays. 2D arrays are\\n        represented as grayscale and with no colorbar if use_binary_string is\\n        True.\\n\\n    binary_backend: str, 'auto' (default), 'pil' or 'pypng'\\n        Third-party package for the transformation of numpy arrays to\\n        png b64 strings. If 'auto', Pillow is used if installed,  otherwise\\n        pypng.\\n\\n    binary_compression_level: int, between 0 and 9 (default 4)\\n        png compression level to be passed to the backend when transforming an\\n        array to a png b64 string. Increasing `binary_compression` decreases the\\n        size of the png string, but the compression step takes more time. For most\\n        images it is not worth using levels greater than 5, but it's possible to\\n        test `len(fig.data[0].source)` and to time the execution of `imshow` to\\n        tune the level of compression. 0 means no compression (not recommended).\\n\\n    binary_format: str, 'png' (default) or 'jpg'\\n        compression format used to generate b64 string. 'png' is recommended\\n        since it uses lossless compression, but 'jpg' (lossy) compression can\\n        result if smaller binary strings for natural images.\\n\\n    text_auto: bool or str (default `False`)\\n        If `True` or a string, single-channel `img` values will be displayed as text.\\n        A string like `'.2f'` will be interpreted as a `texttemplate` numeric formatting directive.\\n\\n    Returns\\n    -------\\n    fig : graph_objects.Figure containing the displayed image\\n\\n    See also\\n    --------\\n\\n    plotly.graph_objects.Image : image trace\\n    plotly.graph_objects.Heatmap : heatmap trace\\n\\n    Notes\\n    -----\\n\\n    In order to update and customize the returned figure, use\\n    `go.Figure.update_traces` or `go.Figure.update_layout`.\\n\\n    If an xarray is passed, dimensions names and coordinates are used for\\n    axes labels and ticks.\\n    \"\n    args = locals()\n    apply_default_cascade(args)\n    labels = labels.copy()\n    nslices_facet = 1\n    if facet_col is not None:\n        if isinstance(facet_col, str):\n            facet_col = img.dims.index(facet_col)\n        nslices_facet = img.shape[facet_col]\n        facet_slices = range(nslices_facet)\n        ncols = int(facet_col_wrap) if facet_col_wrap is not None else nslices_facet\n        nrows = nslices_facet // ncols + 1 if nslices_facet % ncols else nslices_facet // ncols\n    else:\n        nrows = 1\n        ncols = 1\n    if animation_frame is not None:\n        if isinstance(animation_frame, str):\n            animation_frame = img.dims.index(animation_frame)\n        nslices_animation = img.shape[animation_frame]\n        animation_slices = range(nslices_animation)\n    slice_dimensions = (facet_col is not None) + (animation_frame is not None)\n    facet_label = None\n    animation_label = None\n    img_is_xarray = False\n    if xarray_imported and isinstance(img, xarray.DataArray):\n        dims = list(img.dims)\n        img_is_xarray = True\n        pop_indexes = []\n        if facet_col is not None:\n            facet_slices = img.coords[img.dims[facet_col]].values\n            pop_indexes.append(facet_col)\n            facet_label = img.dims[facet_col]\n        if animation_frame is not None:\n            animation_slices = img.coords[img.dims[animation_frame]].values\n            pop_indexes.append(animation_frame)\n            animation_label = img.dims[animation_frame]\n        for index in sorted(pop_indexes, reverse=True):\n            _ = dims.pop(index)\n        (y_label, x_label) = (dims[0], dims[1])\n        for ax in [x_label, y_label]:\n            if np.issubdtype(img.coords[ax].dtype, np.datetime64):\n                img.coords[ax] = img.coords[ax].astype(str)\n        if x is None:\n            x = img.coords[x_label].values\n        if y is None:\n            y = img.coords[y_label].values\n        if aspect is None:\n            aspect = 'auto'\n        if labels.get('x', None) is None:\n            labels['x'] = x_label\n        if labels.get('y', None) is None:\n            labels['y'] = y_label\n        if labels.get('animation_frame', None) is None:\n            labels['animation_frame'] = animation_label\n        if labels.get('facet_col', None) is None:\n            labels['facet_col'] = facet_label\n        if labels.get('color', None) is None:\n            labels['color'] = xarray.plot.utils.label_from_attrs(img)\n            labels['color'] = labels['color'].replace('\\n', '<br>')\n    else:\n        if hasattr(img, 'columns') and hasattr(img.columns, '__len__'):\n            if x is None:\n                x = img.columns\n            if labels.get('x', None) is None and hasattr(img.columns, 'name'):\n                labels['x'] = img.columns.name or ''\n        if hasattr(img, 'index') and hasattr(img.index, '__len__'):\n            if y is None:\n                y = img.index\n            if labels.get('y', None) is None and hasattr(img.index, 'name'):\n                labels['y'] = img.index.name or ''\n        if labels.get('x', None) is None:\n            labels['x'] = ''\n        if labels.get('y', None) is None:\n            labels['y'] = ''\n        if labels.get('color', None) is None:\n            labels['color'] = ''\n        if aspect is None:\n            aspect = 'equal'\n    if isinstance(img, pd.DataFrame):\n        if binary_string:\n            raise ValueError('Binary strings cannot be used with pandas arrays')\n        is_dataframe = True\n    else:\n        is_dataframe = False\n    img = np.asanyarray(img)\n    if facet_col is not None:\n        img = np.moveaxis(img, facet_col, 0)\n        if animation_frame is not None and animation_frame < facet_col:\n            animation_frame += 1\n        facet_col = True\n    if animation_frame is not None:\n        img = np.moveaxis(img, animation_frame, 0)\n        animation_frame = True\n        args['animation_frame'] = 'animation_frame' if labels.get('animation_frame') is None else labels['animation_frame']\n    iterables = ()\n    if animation_frame is not None:\n        iterables += (range(nslices_animation),)\n    if facet_col is not None:\n        iterables += (range(nslices_facet),)\n    if binary_string is None:\n        binary_string = img.ndim >= 3 + slice_dimensions and (not is_dataframe)\n    if img.dtype == bool:\n        img = 255 * img.astype(np.uint8)\n    if range_color is not None:\n        zmin = range_color[0]\n        zmax = range_color[1]\n    if contrast_rescaling is None:\n        contrast_rescaling = 'minmax' if img.ndim == 2 + slice_dimensions else 'infer'\n    if contrast_rescaling == 'minmax':\n        if (zmin is not None or binary_string) and zmax is None:\n            zmax = img.max()\n        if (zmax is not None or binary_string) and zmin is None:\n            zmin = img.min()\n    else:\n        if zmax is None and img.dtype != np.uint8:\n            zmax = _infer_zmax_from_type(img)\n        if zmin is None and zmax is not None:\n            zmin = 0\n    if img.ndim == 2 + slice_dimensions and (not binary_string):\n        y_index = slice_dimensions\n        if y is not None and img.shape[y_index] != len(y):\n            raise ValueError('The length of the y vector must match the length of the first ' + 'dimension of the img matrix.')\n        x_index = slice_dimensions + 1\n        if x is not None and img.shape[x_index] != len(x):\n            raise ValueError('The length of the x vector must match the length of the second ' + 'dimension of the img matrix.')\n        texttemplate = None\n        if text_auto is True:\n            texttemplate = '%{z}'\n        elif text_auto is not False:\n            texttemplate = '%{z:' + text_auto + '}'\n        traces = [go.Heatmap(x=x, y=y, z=img[index_tup], coloraxis='coloraxis1', name=str(i), texttemplate=texttemplate) for (i, index_tup) in enumerate(itertools.product(*iterables))]\n        autorange = True if origin == 'lower' else 'reversed'\n        layout = dict(yaxis=dict(autorange=autorange))\n        if aspect == 'equal':\n            layout['xaxis'] = dict(scaleanchor='y', constrain='domain')\n            layout['yaxis']['constrain'] = 'domain'\n        colorscale_validator = ColorscaleValidator('colorscale', 'imshow')\n        layout['coloraxis1'] = dict(colorscale=colorscale_validator.validate_coerce(args['color_continuous_scale']), cmid=color_continuous_midpoint, cmin=zmin, cmax=zmax)\n        if labels['color']:\n            layout['coloraxis1']['colorbar'] = dict(title_text=labels['color'])\n    elif img.ndim >= 3 and (img.shape[-1] in [3, 4] or (slice_dimensions and binary_string)) or (img.ndim == 2 and binary_string):\n        rescale_image = True\n        if zmin is not None and zmax is not None:\n            (zmin, zmax) = (_vectorize_zvalue(zmin, mode='min'), _vectorize_zvalue(zmax, mode='max'))\n        (x0, y0, dx, dy) = (None,) * 4\n        error_msg_xarray = 'Non-numerical coordinates were passed with xarray `img`, but the Image trace cannot handle it. Please use `binary_string=False` for 2D data or pass instead the numpy array `img.values` to `px.imshow`.'\n        if x is not None:\n            x = np.asanyarray(x)\n            if np.issubdtype(x.dtype, np.number):\n                x0 = x[0]\n                dx = x[1] - x[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `x` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if y is not None:\n            y = np.asanyarray(y)\n            if np.issubdtype(y.dtype, np.number):\n                y0 = y[0]\n                dy = y[1] - y[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `y` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if binary_string:\n            if zmin is None and zmax is None:\n                img_rescaled = img\n                rescale_image = False\n            elif img.ndim == 2 + slice_dimensions:\n                img_rescaled = rescale_intensity(img, in_range=(zmin[0], zmax[0]), out_range=np.uint8)\n            else:\n                img_rescaled = np.stack([rescale_intensity(img[..., ch], in_range=(zmin[ch], zmax[ch]), out_range=np.uint8) for ch in range(img.shape[-1])], axis=-1)\n            img_str = [image_array_to_data_uri(img_rescaled[index_tup], backend=binary_backend, compression=binary_compression_level, ext=binary_format) for index_tup in itertools.product(*iterables)]\n            traces = [go.Image(source=img_str_slice, name=str(i), x0=x0, y0=y0, dx=dx, dy=dy) for (i, img_str_slice) in enumerate(img_str)]\n        else:\n            colormodel = 'rgb' if img.shape[-1] == 3 else 'rgba256'\n            traces = [go.Image(z=img[index_tup], zmin=zmin, zmax=zmax, colormodel=colormodel, x0=x0, y0=y0, dx=dx, dy=dy) for index_tup in itertools.product(*iterables)]\n        layout = {}\n        if origin == 'lower' or (dy is not None and dy < 0):\n            layout['yaxis'] = dict(autorange=True)\n        if dx is not None and dx < 0:\n            layout['xaxis'] = dict(autorange='reversed')\n    else:\n        raise ValueError('px.imshow only accepts 2D single-channel, RGB or RGBA images. An image of shape %s was provided. Alternatively, 3- or 4-D single or multichannel datasets can be visualized using the `facet_col` or/and `animation_frame` arguments.' % str(img.shape))\n    col_labels = []\n    if facet_col is not None:\n        slice_label = 'facet_col' if labels.get('facet_col') is None else labels['facet_col']\n        col_labels = [f'{slice_label}={i}' for i in facet_slices]\n    fig = init_figure(args, 'xy', [], nrows, ncols, col_labels, [])\n    for attr_name in ['height', 'width']:\n        if args[attr_name]:\n            layout[attr_name] = args[attr_name]\n    if args['title']:\n        layout['title_text'] = args['title']\n    elif args['template'].layout.margin.t is None:\n        layout['margin'] = {'t': 60}\n    frame_list = []\n    for (index, trace) in enumerate(traces):\n        if facet_col and index < nrows * ncols or index == 0:\n            fig.add_trace(trace, row=nrows - index // ncols, col=index % ncols + 1)\n    if animation_frame is not None:\n        for (i, index) in zip(range(nslices_animation), animation_slices):\n            frame_list.append(dict(data=traces[nslices_facet * i:nslices_facet * (i + 1)], layout=layout, name=str(index)))\n    if animation_frame:\n        fig.frames = frame_list\n    fig.update_layout(layout)\n    if binary_string and rescale_image and (not np.all(img == img_rescaled)):\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y')\n    else:\n        if trace['type'] == 'heatmap':\n            hover_name = '%{z}'\n        elif img.ndim == 2:\n            hover_name = '%{z[0]}'\n        elif img.ndim == 3 and img.shape[-1] == 3:\n            hover_name = '[%{z[0]}, %{z[1]}, %{z[2]}]'\n        else:\n            hover_name = '%{z}'\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<br>%s: %s<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y', labels['color'] or 'color', hover_name)\n    fig.update_traces(hovertemplate=hovertemplate)\n    if labels['x']:\n        fig.update_xaxes(title_text=labels['x'], row=1)\n    if labels['y']:\n        fig.update_yaxes(title_text=labels['y'], col=1)\n    configure_animation_controls(args, go.Image, fig)\n    fig.update_layout(template=args['template'], overwrite=True)\n    return fig",
            "def imshow(img, zmin=None, zmax=None, origin=None, labels={}, x=None, y=None, animation_frame=None, facet_col=None, facet_col_wrap=None, facet_col_spacing=None, facet_row_spacing=None, color_continuous_scale=None, color_continuous_midpoint=None, range_color=None, title=None, template=None, width=None, height=None, aspect=None, contrast_rescaling=None, binary_string=None, binary_backend='auto', binary_compression_level=4, binary_format='png', text_auto=False) -> go.Figure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Display an image, i.e. data on a 2D regular raster.\\n\\n    Parameters\\n    ----------\\n\\n    img: array-like image, or xarray\\n        The image data. Supported array shapes are\\n\\n        - (M, N): an image with scalar data. The data is visualized\\n          using a colormap.\\n        - (M, N, 3): an image with RGB values.\\n        - (M, N, 4): an image with RGBA values, i.e. including transparency.\\n\\n    zmin, zmax : scalar or iterable, optional\\n        zmin and zmax define the scalar range that the colormap covers. By default,\\n        zmin and zmax correspond to the min and max values of the datatype for integer\\n        datatypes (ie [0-255] for uint8 images, [0, 65535] for uint16 images, etc.). For\\n        a multichannel image of floats, the max of the image is computed and zmax is the\\n        smallest power of 256 (1, 255, 65535) greater than this max value,\\n        with a 5% tolerance. For a single-channel image, the max of the image is used.\\n        Overridden by range_color.\\n\\n    origin : str, 'upper' or 'lower' (default 'upper')\\n        position of the [0, 0] pixel of the image array, in the upper left or lower left\\n        corner. The convention 'upper' is typically used for matrices and images.\\n\\n    labels : dict with str keys and str values (default `{}`)\\n        Sets names used in the figure for axis titles (keys ``x`` and ``y``),\\n        colorbar title and hoverlabel (key ``color``). The values should correspond\\n        to the desired label to be displayed. If ``img`` is an xarray, dimension\\n        names are used for axis titles, and long name for the colorbar title\\n        (unless overridden in ``labels``). Possible keys are: x, y, and color.\\n\\n    x, y: list-like, optional\\n        x and y are used to label the axes of single-channel heatmap visualizations and\\n        their lengths must match the lengths of the second and first dimensions of the\\n        img argument. They are auto-populated if the input is an xarray.\\n\\n    animation_frame: int or str, optional (default None)\\n        axis number along which the image array is sliced to create an animation plot.\\n        If `img` is an xarray, `animation_frame` can be the name of one the dimensions.\\n\\n    facet_col: int or str, optional (default None)\\n        axis number along which the image array is sliced to create a facetted plot.\\n        If `img` is an xarray, `facet_col` can be the name of one the dimensions.\\n\\n    facet_col_wrap: int\\n        Maximum number of facet columns. Wraps the column variable at this width,\\n        so that the column facets span multiple rows.\\n        Ignored if `facet_col` is None.\\n\\n    facet_col_spacing: float between 0 and 1\\n        Spacing between facet columns, in paper units. Default is 0.02.\\n\\n    facet_row_spacing: float between 0 and 1\\n        Spacing between facet rows created when ``facet_col_wrap`` is used, in\\n        paper units. Default is 0.0.7.\\n\\n    color_continuous_scale : str or list of str\\n        colormap used to map scalar data to colors (for a 2D image). This parameter is\\n        not used for RGB or RGBA images. If a string is provided, it should be the name\\n        of a known color scale, and if a list is provided, it should be a list of CSS-\\n        compatible colors.\\n\\n    color_continuous_midpoint : number\\n        If set, computes the bounds of the continuous color scale to have the desired\\n        midpoint. Overridden by range_color or zmin and zmax.\\n\\n    range_color : list of two numbers\\n        If provided, overrides auto-scaling on the continuous color scale, including\\n        overriding `color_continuous_midpoint`. Also overrides zmin and zmax. Used only\\n        for single-channel images.\\n\\n    title : str\\n        The figure title.\\n\\n    template : str or dict or plotly.graph_objects.layout.Template instance\\n        The figure template name or definition.\\n\\n    width : number\\n        The figure width in pixels.\\n\\n    height: number\\n        The figure height in pixels.\\n\\n    aspect: 'equal', 'auto', or None\\n      - 'equal': Ensures an aspect ratio of 1 or pixels (square pixels)\\n      - 'auto': The axes is kept fixed and the aspect ratio of pixels is\\n        adjusted so that the data fit in the axes. In general, this will\\n        result in non-square pixels.\\n      - if None, 'equal' is used for numpy arrays and 'auto' for xarrays\\n        (which have typically heterogeneous coordinates)\\n\\n    contrast_rescaling: 'minmax', 'infer', or None\\n        how to determine data values corresponding to the bounds of the color\\n        range, when zmin or zmax are not passed. If `minmax`, the min and max\\n        values of the image are used. If `infer`, a heuristic based on the image\\n        data type is used.\\n\\n    binary_string: bool, default None\\n        if True, the image data are first rescaled and encoded as uint8 and\\n        then passed to plotly.js as a b64 PNG string. If False, data are passed\\n        unchanged as a numerical array. Setting to True may lead to performance\\n        gains, at the cost of a loss of precision depending on the original data\\n        type. If None, use_binary_string is set to True for multichannel (eg) RGB\\n        arrays, and to False for single-channel (2D) arrays. 2D arrays are\\n        represented as grayscale and with no colorbar if use_binary_string is\\n        True.\\n\\n    binary_backend: str, 'auto' (default), 'pil' or 'pypng'\\n        Third-party package for the transformation of numpy arrays to\\n        png b64 strings. If 'auto', Pillow is used if installed,  otherwise\\n        pypng.\\n\\n    binary_compression_level: int, between 0 and 9 (default 4)\\n        png compression level to be passed to the backend when transforming an\\n        array to a png b64 string. Increasing `binary_compression` decreases the\\n        size of the png string, but the compression step takes more time. For most\\n        images it is not worth using levels greater than 5, but it's possible to\\n        test `len(fig.data[0].source)` and to time the execution of `imshow` to\\n        tune the level of compression. 0 means no compression (not recommended).\\n\\n    binary_format: str, 'png' (default) or 'jpg'\\n        compression format used to generate b64 string. 'png' is recommended\\n        since it uses lossless compression, but 'jpg' (lossy) compression can\\n        result if smaller binary strings for natural images.\\n\\n    text_auto: bool or str (default `False`)\\n        If `True` or a string, single-channel `img` values will be displayed as text.\\n        A string like `'.2f'` will be interpreted as a `texttemplate` numeric formatting directive.\\n\\n    Returns\\n    -------\\n    fig : graph_objects.Figure containing the displayed image\\n\\n    See also\\n    --------\\n\\n    plotly.graph_objects.Image : image trace\\n    plotly.graph_objects.Heatmap : heatmap trace\\n\\n    Notes\\n    -----\\n\\n    In order to update and customize the returned figure, use\\n    `go.Figure.update_traces` or `go.Figure.update_layout`.\\n\\n    If an xarray is passed, dimensions names and coordinates are used for\\n    axes labels and ticks.\\n    \"\n    args = locals()\n    apply_default_cascade(args)\n    labels = labels.copy()\n    nslices_facet = 1\n    if facet_col is not None:\n        if isinstance(facet_col, str):\n            facet_col = img.dims.index(facet_col)\n        nslices_facet = img.shape[facet_col]\n        facet_slices = range(nslices_facet)\n        ncols = int(facet_col_wrap) if facet_col_wrap is not None else nslices_facet\n        nrows = nslices_facet // ncols + 1 if nslices_facet % ncols else nslices_facet // ncols\n    else:\n        nrows = 1\n        ncols = 1\n    if animation_frame is not None:\n        if isinstance(animation_frame, str):\n            animation_frame = img.dims.index(animation_frame)\n        nslices_animation = img.shape[animation_frame]\n        animation_slices = range(nslices_animation)\n    slice_dimensions = (facet_col is not None) + (animation_frame is not None)\n    facet_label = None\n    animation_label = None\n    img_is_xarray = False\n    if xarray_imported and isinstance(img, xarray.DataArray):\n        dims = list(img.dims)\n        img_is_xarray = True\n        pop_indexes = []\n        if facet_col is not None:\n            facet_slices = img.coords[img.dims[facet_col]].values\n            pop_indexes.append(facet_col)\n            facet_label = img.dims[facet_col]\n        if animation_frame is not None:\n            animation_slices = img.coords[img.dims[animation_frame]].values\n            pop_indexes.append(animation_frame)\n            animation_label = img.dims[animation_frame]\n        for index in sorted(pop_indexes, reverse=True):\n            _ = dims.pop(index)\n        (y_label, x_label) = (dims[0], dims[1])\n        for ax in [x_label, y_label]:\n            if np.issubdtype(img.coords[ax].dtype, np.datetime64):\n                img.coords[ax] = img.coords[ax].astype(str)\n        if x is None:\n            x = img.coords[x_label].values\n        if y is None:\n            y = img.coords[y_label].values\n        if aspect is None:\n            aspect = 'auto'\n        if labels.get('x', None) is None:\n            labels['x'] = x_label\n        if labels.get('y', None) is None:\n            labels['y'] = y_label\n        if labels.get('animation_frame', None) is None:\n            labels['animation_frame'] = animation_label\n        if labels.get('facet_col', None) is None:\n            labels['facet_col'] = facet_label\n        if labels.get('color', None) is None:\n            labels['color'] = xarray.plot.utils.label_from_attrs(img)\n            labels['color'] = labels['color'].replace('\\n', '<br>')\n    else:\n        if hasattr(img, 'columns') and hasattr(img.columns, '__len__'):\n            if x is None:\n                x = img.columns\n            if labels.get('x', None) is None and hasattr(img.columns, 'name'):\n                labels['x'] = img.columns.name or ''\n        if hasattr(img, 'index') and hasattr(img.index, '__len__'):\n            if y is None:\n                y = img.index\n            if labels.get('y', None) is None and hasattr(img.index, 'name'):\n                labels['y'] = img.index.name or ''\n        if labels.get('x', None) is None:\n            labels['x'] = ''\n        if labels.get('y', None) is None:\n            labels['y'] = ''\n        if labels.get('color', None) is None:\n            labels['color'] = ''\n        if aspect is None:\n            aspect = 'equal'\n    if isinstance(img, pd.DataFrame):\n        if binary_string:\n            raise ValueError('Binary strings cannot be used with pandas arrays')\n        is_dataframe = True\n    else:\n        is_dataframe = False\n    img = np.asanyarray(img)\n    if facet_col is not None:\n        img = np.moveaxis(img, facet_col, 0)\n        if animation_frame is not None and animation_frame < facet_col:\n            animation_frame += 1\n        facet_col = True\n    if animation_frame is not None:\n        img = np.moveaxis(img, animation_frame, 0)\n        animation_frame = True\n        args['animation_frame'] = 'animation_frame' if labels.get('animation_frame') is None else labels['animation_frame']\n    iterables = ()\n    if animation_frame is not None:\n        iterables += (range(nslices_animation),)\n    if facet_col is not None:\n        iterables += (range(nslices_facet),)\n    if binary_string is None:\n        binary_string = img.ndim >= 3 + slice_dimensions and (not is_dataframe)\n    if img.dtype == bool:\n        img = 255 * img.astype(np.uint8)\n    if range_color is not None:\n        zmin = range_color[0]\n        zmax = range_color[1]\n    if contrast_rescaling is None:\n        contrast_rescaling = 'minmax' if img.ndim == 2 + slice_dimensions else 'infer'\n    if contrast_rescaling == 'minmax':\n        if (zmin is not None or binary_string) and zmax is None:\n            zmax = img.max()\n        if (zmax is not None or binary_string) and zmin is None:\n            zmin = img.min()\n    else:\n        if zmax is None and img.dtype != np.uint8:\n            zmax = _infer_zmax_from_type(img)\n        if zmin is None and zmax is not None:\n            zmin = 0\n    if img.ndim == 2 + slice_dimensions and (not binary_string):\n        y_index = slice_dimensions\n        if y is not None and img.shape[y_index] != len(y):\n            raise ValueError('The length of the y vector must match the length of the first ' + 'dimension of the img matrix.')\n        x_index = slice_dimensions + 1\n        if x is not None and img.shape[x_index] != len(x):\n            raise ValueError('The length of the x vector must match the length of the second ' + 'dimension of the img matrix.')\n        texttemplate = None\n        if text_auto is True:\n            texttemplate = '%{z}'\n        elif text_auto is not False:\n            texttemplate = '%{z:' + text_auto + '}'\n        traces = [go.Heatmap(x=x, y=y, z=img[index_tup], coloraxis='coloraxis1', name=str(i), texttemplate=texttemplate) for (i, index_tup) in enumerate(itertools.product(*iterables))]\n        autorange = True if origin == 'lower' else 'reversed'\n        layout = dict(yaxis=dict(autorange=autorange))\n        if aspect == 'equal':\n            layout['xaxis'] = dict(scaleanchor='y', constrain='domain')\n            layout['yaxis']['constrain'] = 'domain'\n        colorscale_validator = ColorscaleValidator('colorscale', 'imshow')\n        layout['coloraxis1'] = dict(colorscale=colorscale_validator.validate_coerce(args['color_continuous_scale']), cmid=color_continuous_midpoint, cmin=zmin, cmax=zmax)\n        if labels['color']:\n            layout['coloraxis1']['colorbar'] = dict(title_text=labels['color'])\n    elif img.ndim >= 3 and (img.shape[-1] in [3, 4] or (slice_dimensions and binary_string)) or (img.ndim == 2 and binary_string):\n        rescale_image = True\n        if zmin is not None and zmax is not None:\n            (zmin, zmax) = (_vectorize_zvalue(zmin, mode='min'), _vectorize_zvalue(zmax, mode='max'))\n        (x0, y0, dx, dy) = (None,) * 4\n        error_msg_xarray = 'Non-numerical coordinates were passed with xarray `img`, but the Image trace cannot handle it. Please use `binary_string=False` for 2D data or pass instead the numpy array `img.values` to `px.imshow`.'\n        if x is not None:\n            x = np.asanyarray(x)\n            if np.issubdtype(x.dtype, np.number):\n                x0 = x[0]\n                dx = x[1] - x[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `x` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if y is not None:\n            y = np.asanyarray(y)\n            if np.issubdtype(y.dtype, np.number):\n                y0 = y[0]\n                dy = y[1] - y[0]\n            else:\n                error_msg = error_msg_xarray if img_is_xarray else 'Only numerical values are accepted for the `y` parameter when an Image trace is used.'\n                raise ValueError(error_msg)\n        if binary_string:\n            if zmin is None and zmax is None:\n                img_rescaled = img\n                rescale_image = False\n            elif img.ndim == 2 + slice_dimensions:\n                img_rescaled = rescale_intensity(img, in_range=(zmin[0], zmax[0]), out_range=np.uint8)\n            else:\n                img_rescaled = np.stack([rescale_intensity(img[..., ch], in_range=(zmin[ch], zmax[ch]), out_range=np.uint8) for ch in range(img.shape[-1])], axis=-1)\n            img_str = [image_array_to_data_uri(img_rescaled[index_tup], backend=binary_backend, compression=binary_compression_level, ext=binary_format) for index_tup in itertools.product(*iterables)]\n            traces = [go.Image(source=img_str_slice, name=str(i), x0=x0, y0=y0, dx=dx, dy=dy) for (i, img_str_slice) in enumerate(img_str)]\n        else:\n            colormodel = 'rgb' if img.shape[-1] == 3 else 'rgba256'\n            traces = [go.Image(z=img[index_tup], zmin=zmin, zmax=zmax, colormodel=colormodel, x0=x0, y0=y0, dx=dx, dy=dy) for index_tup in itertools.product(*iterables)]\n        layout = {}\n        if origin == 'lower' or (dy is not None and dy < 0):\n            layout['yaxis'] = dict(autorange=True)\n        if dx is not None and dx < 0:\n            layout['xaxis'] = dict(autorange='reversed')\n    else:\n        raise ValueError('px.imshow only accepts 2D single-channel, RGB or RGBA images. An image of shape %s was provided. Alternatively, 3- or 4-D single or multichannel datasets can be visualized using the `facet_col` or/and `animation_frame` arguments.' % str(img.shape))\n    col_labels = []\n    if facet_col is not None:\n        slice_label = 'facet_col' if labels.get('facet_col') is None else labels['facet_col']\n        col_labels = [f'{slice_label}={i}' for i in facet_slices]\n    fig = init_figure(args, 'xy', [], nrows, ncols, col_labels, [])\n    for attr_name in ['height', 'width']:\n        if args[attr_name]:\n            layout[attr_name] = args[attr_name]\n    if args['title']:\n        layout['title_text'] = args['title']\n    elif args['template'].layout.margin.t is None:\n        layout['margin'] = {'t': 60}\n    frame_list = []\n    for (index, trace) in enumerate(traces):\n        if facet_col and index < nrows * ncols or index == 0:\n            fig.add_trace(trace, row=nrows - index // ncols, col=index % ncols + 1)\n    if animation_frame is not None:\n        for (i, index) in zip(range(nslices_animation), animation_slices):\n            frame_list.append(dict(data=traces[nslices_facet * i:nslices_facet * (i + 1)], layout=layout, name=str(index)))\n    if animation_frame:\n        fig.frames = frame_list\n    fig.update_layout(layout)\n    if binary_string and rescale_image and (not np.all(img == img_rescaled)):\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y')\n    else:\n        if trace['type'] == 'heatmap':\n            hover_name = '%{z}'\n        elif img.ndim == 2:\n            hover_name = '%{z[0]}'\n        elif img.ndim == 3 and img.shape[-1] == 3:\n            hover_name = '[%{z[0]}, %{z[1]}, %{z[2]}]'\n        else:\n            hover_name = '%{z}'\n        hovertemplate = '%s: %%{x}<br>%s: %%{y}<br>%s: %s<extra></extra>' % (labels['x'] or 'x', labels['y'] or 'y', labels['color'] or 'color', hover_name)\n    fig.update_traces(hovertemplate=hovertemplate)\n    if labels['x']:\n        fig.update_xaxes(title_text=labels['x'], row=1)\n    if labels['y']:\n        fig.update_yaxes(title_text=labels['y'], col=1)\n    configure_animation_controls(args, go.Image, fig)\n    fig.update_layout(template=args['template'], overwrite=True)\n    return fig"
        ]
    }
]