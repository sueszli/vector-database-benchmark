"""
    flyteidl/service/admin.proto

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: version not set
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""
import pprint
import re
import six
from flyteadmin.models.core_identity import CoreIdentity
from flyteadmin.models.core_o_auth2_token_request import CoreOAuth2TokenRequest
from flyteadmin.models.core_secret import CoreSecret

class CoreSecurityContext(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    '\n    Attributes:\n      swagger_types (dict): The key is attribute name\n                            and the value is attribute type.\n      attribute_map (dict): The key is attribute name\n                            and the value is json key in definition.\n    '
    swagger_types = {'run_as': 'CoreIdentity', 'secrets': 'list[CoreSecret]', 'tokens': 'list[CoreOAuth2TokenRequest]'}
    attribute_map = {'run_as': 'run_as', 'secrets': 'secrets', 'tokens': 'tokens'}

    def __init__(self, run_as=None, secrets=None, tokens=None):
        if False:
            i = 10
            return i + 15
        'CoreSecurityContext - a model defined in Swagger'
        self._run_as = None
        self._secrets = None
        self._tokens = None
        self.discriminator = None
        if run_as is not None:
            self.run_as = run_as
        if secrets is not None:
            self.secrets = secrets
        if tokens is not None:
            self.tokens = tokens

    @property
    def run_as(self):
        if False:
            while True:
                i = 10
        "Gets the run_as of this CoreSecurityContext.  # noqa: E501\n\n        run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the backend plugin to choose the appropriate identity for the execution engine the task will run on.  # noqa: E501\n\n        :return: The run_as of this CoreSecurityContext.  # noqa: E501\n        :rtype: CoreIdentity\n        "
        return self._run_as

    @run_as.setter
    def run_as(self, run_as):
        if False:
            print('Hello World!')
        "Sets the run_as of this CoreSecurityContext.\n\n        run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the backend plugin to choose the appropriate identity for the execution engine the task will run on.  # noqa: E501\n\n        :param run_as: The run_as of this CoreSecurityContext.  # noqa: E501\n        :type: CoreIdentity\n        "
        self._run_as = run_as

    @property
    def secrets(self):
        if False:
            return 10
        "Gets the secrets of this CoreSecurityContext.  # noqa: E501\n\n        secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.  # noqa: E501\n\n        :return: The secrets of this CoreSecurityContext.  # noqa: E501\n        :rtype: list[CoreSecret]\n        "
        return self._secrets

    @secrets.setter
    def secrets(self, secrets):
        if False:
            while True:
                i = 10
        "Sets the secrets of this CoreSecurityContext.\n\n        secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.  # noqa: E501\n\n        :param secrets: The secrets of this CoreSecurityContext.  # noqa: E501\n        :type: list[CoreSecret]\n        "
        self._secrets = secrets

    @property
    def tokens(self):
        if False:
            while True:
                i = 10
        "Gets the tokens of this CoreSecurityContext.  # noqa: E501\n\n        tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.  # noqa: E501\n\n        :return: The tokens of this CoreSecurityContext.  # noqa: E501\n        :rtype: list[CoreOAuth2TokenRequest]\n        "
        return self._tokens

    @tokens.setter
    def tokens(self, tokens):
        if False:
            return 10
        "Sets the tokens of this CoreSecurityContext.\n\n        tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.  # noqa: E501\n\n        :param tokens: The tokens of this CoreSecurityContext.  # noqa: E501\n        :type: list[CoreOAuth2TokenRequest]\n        "
        self._tokens = tokens

    def to_dict(self):
        if False:
            for i in range(10):
                print('nop')
        'Returns the model properties as a dict'
        result = {}
        for (attr, _) in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(lambda x: x.to_dict() if hasattr(x, 'to_dict') else x, value))
            elif hasattr(value, 'to_dict'):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(lambda item: (item[0], item[1].to_dict()) if hasattr(item[1], 'to_dict') else item, value.items()))
            else:
                result[attr] = value
        if issubclass(CoreSecurityContext, dict):
            for (key, value) in self.items():
                result[key] = value
        return result

    def to_str(self):
        if False:
            while True:
                i = 10
        'Returns the string representation of the model'
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        if False:
            i = 10
            return i + 15
        'For `print` and `pprint`'
        return self.to_str()

    def __eq__(self, other):
        if False:
            print('Hello World!')
        'Returns true if both objects are equal'
        if not isinstance(other, CoreSecurityContext):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        if False:
            return 10
        'Returns true if both objects are not equal'
        return not self == other