[
    {
        "func_name": "main",
        "original": "def main():\n    try:\n        src = sys.argv[1]\n    except:\n        src = 0\n    cap = video.create_capture(src)\n    classifier_fn = 'digits_svm.dat'\n    if not os.path.exists(classifier_fn):\n        print('\"%s\" not found, run digits.py first' % classifier_fn)\n        return\n    if True:\n        model = cv2.ml.SVM_load(classifier_fn)\n    else:\n        model = cv2.ml.SVM_create()\n        model.load_(classifier_fn)\n    while True:\n        (ret, frame) = cap.read()\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        bin = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 31, 10)\n        bin = cv2.medianBlur(bin, 3)\n        (_, contours, heirs) = cv2.findContours(bin.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)\n        try:\n            heirs = heirs[0]\n        except:\n            heirs = []\n        for (cnt, heir) in zip(contours, heirs):\n            (_, _, _, outer_i) = heir\n            if outer_i >= 0:\n                continue\n            (x, y, w, h) = cv2.boundingRect(cnt)\n            if not (16 <= h <= 64 and w <= 1.2 * h):\n                continue\n            pad = max(h - w, 0)\n            (x, w) = (x - pad / 2, w + pad)\n            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0))\n            bin_roi = bin[y:, x:][:h, :w]\n            gray_roi = gray[y:, x:][:h, :w]\n            m = bin_roi != 0\n            if not 0.1 < m.mean() < 0.4:\n                continue\n            '\\n            v_in, v_out = gray_roi[m], gray_roi[~m]\\n            if v_out.std() > 10.0:\\n                continue\\n            s = \"%f, %f\" % (abs(v_in.mean() - v_out.mean()), v_out.std())\\n            cv2.putText(frame, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness = 1)\\n            '\n            s = 1.5 * float(h) / SZ\n            m = cv2.moments(bin_roi)\n            c1 = np.float32([m['m10'], m['m01']]) / m['m00']\n            c0 = np.float32([SZ / 2, SZ / 2])\n            t = c1 - s * c0\n            A = np.zeros((2, 3), np.float32)\n            A[:, :2] = np.eye(2) * s\n            A[:, 2] = t\n            bin_norm = cv2.warpAffine(bin_roi, A, (SZ, SZ), flags=cv2.WARP_INVERSE_MAP | cv2.INTER_LINEAR)\n            bin_norm = deskew(bin_norm)\n            if x + w + SZ < frame.shape[1] and y + SZ < frame.shape[0]:\n                frame[y:, x + w:][:SZ, :SZ] = bin_norm[..., np.newaxis]\n            sample = preprocess_hog([bin_norm])\n            digit = model.predict(sample)[0]\n            cv2.putText(frame, '%d' % digit, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness=1)\n        cv2.imshow('frame', frame)\n        cv2.imshow('bin', bin)\n        ch = cv2.waitKey(1)\n        if ch == 27:\n            break",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    try:\n        src = sys.argv[1]\n    except:\n        src = 0\n    cap = video.create_capture(src)\n    classifier_fn = 'digits_svm.dat'\n    if not os.path.exists(classifier_fn):\n        print('\"%s\" not found, run digits.py first' % classifier_fn)\n        return\n    if True:\n        model = cv2.ml.SVM_load(classifier_fn)\n    else:\n        model = cv2.ml.SVM_create()\n        model.load_(classifier_fn)\n    while True:\n        (ret, frame) = cap.read()\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        bin = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 31, 10)\n        bin = cv2.medianBlur(bin, 3)\n        (_, contours, heirs) = cv2.findContours(bin.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)\n        try:\n            heirs = heirs[0]\n        except:\n            heirs = []\n        for (cnt, heir) in zip(contours, heirs):\n            (_, _, _, outer_i) = heir\n            if outer_i >= 0:\n                continue\n            (x, y, w, h) = cv2.boundingRect(cnt)\n            if not (16 <= h <= 64 and w <= 1.2 * h):\n                continue\n            pad = max(h - w, 0)\n            (x, w) = (x - pad / 2, w + pad)\n            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0))\n            bin_roi = bin[y:, x:][:h, :w]\n            gray_roi = gray[y:, x:][:h, :w]\n            m = bin_roi != 0\n            if not 0.1 < m.mean() < 0.4:\n                continue\n            '\\n            v_in, v_out = gray_roi[m], gray_roi[~m]\\n            if v_out.std() > 10.0:\\n                continue\\n            s = \"%f, %f\" % (abs(v_in.mean() - v_out.mean()), v_out.std())\\n            cv2.putText(frame, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness = 1)\\n            '\n            s = 1.5 * float(h) / SZ\n            m = cv2.moments(bin_roi)\n            c1 = np.float32([m['m10'], m['m01']]) / m['m00']\n            c0 = np.float32([SZ / 2, SZ / 2])\n            t = c1 - s * c0\n            A = np.zeros((2, 3), np.float32)\n            A[:, :2] = np.eye(2) * s\n            A[:, 2] = t\n            bin_norm = cv2.warpAffine(bin_roi, A, (SZ, SZ), flags=cv2.WARP_INVERSE_MAP | cv2.INTER_LINEAR)\n            bin_norm = deskew(bin_norm)\n            if x + w + SZ < frame.shape[1] and y + SZ < frame.shape[0]:\n                frame[y:, x + w:][:SZ, :SZ] = bin_norm[..., np.newaxis]\n            sample = preprocess_hog([bin_norm])\n            digit = model.predict(sample)[0]\n            cv2.putText(frame, '%d' % digit, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness=1)\n        cv2.imshow('frame', frame)\n        cv2.imshow('bin', bin)\n        ch = cv2.waitKey(1)\n        if ch == 27:\n            break",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        src = sys.argv[1]\n    except:\n        src = 0\n    cap = video.create_capture(src)\n    classifier_fn = 'digits_svm.dat'\n    if not os.path.exists(classifier_fn):\n        print('\"%s\" not found, run digits.py first' % classifier_fn)\n        return\n    if True:\n        model = cv2.ml.SVM_load(classifier_fn)\n    else:\n        model = cv2.ml.SVM_create()\n        model.load_(classifier_fn)\n    while True:\n        (ret, frame) = cap.read()\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        bin = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 31, 10)\n        bin = cv2.medianBlur(bin, 3)\n        (_, contours, heirs) = cv2.findContours(bin.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)\n        try:\n            heirs = heirs[0]\n        except:\n            heirs = []\n        for (cnt, heir) in zip(contours, heirs):\n            (_, _, _, outer_i) = heir\n            if outer_i >= 0:\n                continue\n            (x, y, w, h) = cv2.boundingRect(cnt)\n            if not (16 <= h <= 64 and w <= 1.2 * h):\n                continue\n            pad = max(h - w, 0)\n            (x, w) = (x - pad / 2, w + pad)\n            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0))\n            bin_roi = bin[y:, x:][:h, :w]\n            gray_roi = gray[y:, x:][:h, :w]\n            m = bin_roi != 0\n            if not 0.1 < m.mean() < 0.4:\n                continue\n            '\\n            v_in, v_out = gray_roi[m], gray_roi[~m]\\n            if v_out.std() > 10.0:\\n                continue\\n            s = \"%f, %f\" % (abs(v_in.mean() - v_out.mean()), v_out.std())\\n            cv2.putText(frame, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness = 1)\\n            '\n            s = 1.5 * float(h) / SZ\n            m = cv2.moments(bin_roi)\n            c1 = np.float32([m['m10'], m['m01']]) / m['m00']\n            c0 = np.float32([SZ / 2, SZ / 2])\n            t = c1 - s * c0\n            A = np.zeros((2, 3), np.float32)\n            A[:, :2] = np.eye(2) * s\n            A[:, 2] = t\n            bin_norm = cv2.warpAffine(bin_roi, A, (SZ, SZ), flags=cv2.WARP_INVERSE_MAP | cv2.INTER_LINEAR)\n            bin_norm = deskew(bin_norm)\n            if x + w + SZ < frame.shape[1] and y + SZ < frame.shape[0]:\n                frame[y:, x + w:][:SZ, :SZ] = bin_norm[..., np.newaxis]\n            sample = preprocess_hog([bin_norm])\n            digit = model.predict(sample)[0]\n            cv2.putText(frame, '%d' % digit, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness=1)\n        cv2.imshow('frame', frame)\n        cv2.imshow('bin', bin)\n        ch = cv2.waitKey(1)\n        if ch == 27:\n            break",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        src = sys.argv[1]\n    except:\n        src = 0\n    cap = video.create_capture(src)\n    classifier_fn = 'digits_svm.dat'\n    if not os.path.exists(classifier_fn):\n        print('\"%s\" not found, run digits.py first' % classifier_fn)\n        return\n    if True:\n        model = cv2.ml.SVM_load(classifier_fn)\n    else:\n        model = cv2.ml.SVM_create()\n        model.load_(classifier_fn)\n    while True:\n        (ret, frame) = cap.read()\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        bin = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 31, 10)\n        bin = cv2.medianBlur(bin, 3)\n        (_, contours, heirs) = cv2.findContours(bin.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)\n        try:\n            heirs = heirs[0]\n        except:\n            heirs = []\n        for (cnt, heir) in zip(contours, heirs):\n            (_, _, _, outer_i) = heir\n            if outer_i >= 0:\n                continue\n            (x, y, w, h) = cv2.boundingRect(cnt)\n            if not (16 <= h <= 64 and w <= 1.2 * h):\n                continue\n            pad = max(h - w, 0)\n            (x, w) = (x - pad / 2, w + pad)\n            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0))\n            bin_roi = bin[y:, x:][:h, :w]\n            gray_roi = gray[y:, x:][:h, :w]\n            m = bin_roi != 0\n            if not 0.1 < m.mean() < 0.4:\n                continue\n            '\\n            v_in, v_out = gray_roi[m], gray_roi[~m]\\n            if v_out.std() > 10.0:\\n                continue\\n            s = \"%f, %f\" % (abs(v_in.mean() - v_out.mean()), v_out.std())\\n            cv2.putText(frame, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness = 1)\\n            '\n            s = 1.5 * float(h) / SZ\n            m = cv2.moments(bin_roi)\n            c1 = np.float32([m['m10'], m['m01']]) / m['m00']\n            c0 = np.float32([SZ / 2, SZ / 2])\n            t = c1 - s * c0\n            A = np.zeros((2, 3), np.float32)\n            A[:, :2] = np.eye(2) * s\n            A[:, 2] = t\n            bin_norm = cv2.warpAffine(bin_roi, A, (SZ, SZ), flags=cv2.WARP_INVERSE_MAP | cv2.INTER_LINEAR)\n            bin_norm = deskew(bin_norm)\n            if x + w + SZ < frame.shape[1] and y + SZ < frame.shape[0]:\n                frame[y:, x + w:][:SZ, :SZ] = bin_norm[..., np.newaxis]\n            sample = preprocess_hog([bin_norm])\n            digit = model.predict(sample)[0]\n            cv2.putText(frame, '%d' % digit, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness=1)\n        cv2.imshow('frame', frame)\n        cv2.imshow('bin', bin)\n        ch = cv2.waitKey(1)\n        if ch == 27:\n            break",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        src = sys.argv[1]\n    except:\n        src = 0\n    cap = video.create_capture(src)\n    classifier_fn = 'digits_svm.dat'\n    if not os.path.exists(classifier_fn):\n        print('\"%s\" not found, run digits.py first' % classifier_fn)\n        return\n    if True:\n        model = cv2.ml.SVM_load(classifier_fn)\n    else:\n        model = cv2.ml.SVM_create()\n        model.load_(classifier_fn)\n    while True:\n        (ret, frame) = cap.read()\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        bin = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 31, 10)\n        bin = cv2.medianBlur(bin, 3)\n        (_, contours, heirs) = cv2.findContours(bin.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)\n        try:\n            heirs = heirs[0]\n        except:\n            heirs = []\n        for (cnt, heir) in zip(contours, heirs):\n            (_, _, _, outer_i) = heir\n            if outer_i >= 0:\n                continue\n            (x, y, w, h) = cv2.boundingRect(cnt)\n            if not (16 <= h <= 64 and w <= 1.2 * h):\n                continue\n            pad = max(h - w, 0)\n            (x, w) = (x - pad / 2, w + pad)\n            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0))\n            bin_roi = bin[y:, x:][:h, :w]\n            gray_roi = gray[y:, x:][:h, :w]\n            m = bin_roi != 0\n            if not 0.1 < m.mean() < 0.4:\n                continue\n            '\\n            v_in, v_out = gray_roi[m], gray_roi[~m]\\n            if v_out.std() > 10.0:\\n                continue\\n            s = \"%f, %f\" % (abs(v_in.mean() - v_out.mean()), v_out.std())\\n            cv2.putText(frame, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness = 1)\\n            '\n            s = 1.5 * float(h) / SZ\n            m = cv2.moments(bin_roi)\n            c1 = np.float32([m['m10'], m['m01']]) / m['m00']\n            c0 = np.float32([SZ / 2, SZ / 2])\n            t = c1 - s * c0\n            A = np.zeros((2, 3), np.float32)\n            A[:, :2] = np.eye(2) * s\n            A[:, 2] = t\n            bin_norm = cv2.warpAffine(bin_roi, A, (SZ, SZ), flags=cv2.WARP_INVERSE_MAP | cv2.INTER_LINEAR)\n            bin_norm = deskew(bin_norm)\n            if x + w + SZ < frame.shape[1] and y + SZ < frame.shape[0]:\n                frame[y:, x + w:][:SZ, :SZ] = bin_norm[..., np.newaxis]\n            sample = preprocess_hog([bin_norm])\n            digit = model.predict(sample)[0]\n            cv2.putText(frame, '%d' % digit, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness=1)\n        cv2.imshow('frame', frame)\n        cv2.imshow('bin', bin)\n        ch = cv2.waitKey(1)\n        if ch == 27:\n            break",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        src = sys.argv[1]\n    except:\n        src = 0\n    cap = video.create_capture(src)\n    classifier_fn = 'digits_svm.dat'\n    if not os.path.exists(classifier_fn):\n        print('\"%s\" not found, run digits.py first' % classifier_fn)\n        return\n    if True:\n        model = cv2.ml.SVM_load(classifier_fn)\n    else:\n        model = cv2.ml.SVM_create()\n        model.load_(classifier_fn)\n    while True:\n        (ret, frame) = cap.read()\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        bin = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 31, 10)\n        bin = cv2.medianBlur(bin, 3)\n        (_, contours, heirs) = cv2.findContours(bin.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)\n        try:\n            heirs = heirs[0]\n        except:\n            heirs = []\n        for (cnt, heir) in zip(contours, heirs):\n            (_, _, _, outer_i) = heir\n            if outer_i >= 0:\n                continue\n            (x, y, w, h) = cv2.boundingRect(cnt)\n            if not (16 <= h <= 64 and w <= 1.2 * h):\n                continue\n            pad = max(h - w, 0)\n            (x, w) = (x - pad / 2, w + pad)\n            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0))\n            bin_roi = bin[y:, x:][:h, :w]\n            gray_roi = gray[y:, x:][:h, :w]\n            m = bin_roi != 0\n            if not 0.1 < m.mean() < 0.4:\n                continue\n            '\\n            v_in, v_out = gray_roi[m], gray_roi[~m]\\n            if v_out.std() > 10.0:\\n                continue\\n            s = \"%f, %f\" % (abs(v_in.mean() - v_out.mean()), v_out.std())\\n            cv2.putText(frame, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness = 1)\\n            '\n            s = 1.5 * float(h) / SZ\n            m = cv2.moments(bin_roi)\n            c1 = np.float32([m['m10'], m['m01']]) / m['m00']\n            c0 = np.float32([SZ / 2, SZ / 2])\n            t = c1 - s * c0\n            A = np.zeros((2, 3), np.float32)\n            A[:, :2] = np.eye(2) * s\n            A[:, 2] = t\n            bin_norm = cv2.warpAffine(bin_roi, A, (SZ, SZ), flags=cv2.WARP_INVERSE_MAP | cv2.INTER_LINEAR)\n            bin_norm = deskew(bin_norm)\n            if x + w + SZ < frame.shape[1] and y + SZ < frame.shape[0]:\n                frame[y:, x + w:][:SZ, :SZ] = bin_norm[..., np.newaxis]\n            sample = preprocess_hog([bin_norm])\n            digit = model.predict(sample)[0]\n            cv2.putText(frame, '%d' % digit, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (200, 0, 0), thickness=1)\n        cv2.imshow('frame', frame)\n        cv2.imshow('bin', bin)\n        ch = cv2.waitKey(1)\n        if ch == 27:\n            break"
        ]
    }
]