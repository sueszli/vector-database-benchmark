import jittor as jt

def ccl_link(score_map, link_map, result_comp_area_thresh=6):
    if False:
        i = 10
        return i + 15
    '\n    Find components in score map and link them with link map, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm.\n    Args:\n        [in]param score_map: binary two-dimensional vector\n            type score_map: jittor array\n        [in]param link_map: two-dimensional vector with 8 channels\n            type link_map: jittor array\n        [in]param result_comp_area_thresh: threshold of component area\n            type result_comp_area_thresh: int\n    Returns:\n        [out]result: labeled two-dimensional vector\n    Example:\n    >>> import jittor as jt\n    >>> jt.flags.use_cuda = 1\n    >>> import cv2\n    >>> import numpy as np\n    >>> score_map = jt.Var(np.load("score_map.npy"))\n    >>> link_map = jt.Var(np.load("link_map.npy"))\n    >>> score_map = score_map >= 0.5\n    >>> link_map = link_map >= 0.8\n    >>> for i in range(8):\n    >>>     link_map[:, :, i] = link_map[:, :, i] & score_map\n    \n    >>> result = ccl_link(score_map, link_map)\n    >>> cv2.imwrite(\'pixellink.png\', result.numpy().astype(np.uint8) * 50)\n    '
    score_map = score_map.astype(jt.uint32)
    link_map = link_map.astype(jt.uint32)
    cY = score_map.shape[0]
    cX = score_map.shape[1]
    changed = jt.ones([1], dtype=jt.uint32)
    score_map = score_map.reshape(cX * cY)
    result = jt.code(score_map.shape, score_map.dtype, [score_map, link_map, changed], cuda_header='\n                    @alias(score_map, in0)\n                    @alias(link_map, in1)\n                    @alias(g_labels, out)\n                    ', cuda_src='\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY) {\n                        @PRECALC\n                        // Calculate index\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\n                        @g_labels(iy*cX + ix) = iy*cX + ix;\n                    }\n\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\n                        // Resolve Label\n                        unsigned int next = @g_labels(label);\n\n                        // Follow chain\n                        while(label != next) {\n                            // Move to next\n                            label = next;\n                            next = @g_labels(label);\n                        }\n\n                        // Return label\n                        return label;\n                    }\n\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY) {\n                        @PRECALC\n                        // Calculate index\n                        const unsigned int id = ((blockIdx.y * blockDim.y) + threadIdx.y) * cX +\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\n                        \n                        // Check Thread Range\n                        if(id < cX*cY) {\n                            // Resolve Label\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\n                        }\n                    }\n\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY) {\n                        @PRECALC\n                        // Calculate index\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\n\n                        // Check Thread Range\n                        if((ix < cX) && (iy < cY)) {\n                            // Get image and label values\n                            const unsigned char cyx   = @score_map( iy*cX + ix);\n                            \n                            // Get neighbour labels\n                            const unsigned int lym1x = (iy > 0)    ? @g_labels((iy-1)*cX +   ix) : 0;\n                            const unsigned int lyxm1 = (ix > 0)    ? @g_labels(iy    *cX + ix-1) : 0;\n                            const unsigned int lyx   =               @g_labels(iy    *cX +   ix);\n                            const unsigned int lyxp1 = (ix < cX-1) ? @g_labels(iy    *cX + ix+1) : 0;\n                            const unsigned int lyp1x = (iy < cY-1) ? @g_labels((iy+1)*cX +   ix) : 0;\n\n                            const unsigned int lym1xm1 = (iy > 0    && ix > 0   )    ? @g_labels((iy-1)*cX +   ix-1) : 0;\n                            const unsigned int lym1xp1 = (iy > 0    && ix < cX-1)    ? @g_labels((iy-1)*cX +   ix+1) : 0;\n                            const unsigned int lyp1xm1 = (iy < cY-1 && ix > 0   )    ? @g_labels((iy+1)*cX +   ix-1) : 0;\n                            const unsigned int lyp1xp1 = (iy < cY-1 && ix < cX-1)    ? @g_labels((iy+1)*cX +   ix+1) : 0;\n                            bool nym1x, nyxm1, nyxp1, nyp1x, nym1xm1, nym1xp1, nyp1xm1, nyp1xp1;\n                            if(cyx) {\n                                nym1x = (iy > 0)    ? ((cyx == (@score_map((iy-1)*cX +   ix))) && (@link_map(iy, ix, 6) || @link_map(iy-1,   ix, 7))) : false; // up\n                                nyxm1 = (ix > 0)    ? ((cyx == (@score_map(iy    *cX + ix-1))) && (@link_map(iy, ix, 0) || @link_map(iy-1, ix-1, 3))) : false; // left\n                                nyxp1 = (ix < cX-1) ? ((cyx == (@score_map(iy    *cX + ix+1))) && (@link_map(iy, ix, 3) || @link_map(iy,   ix+1, 0))) : false; // right\n                                nyp1x = (iy > cY-1) ? ((cyx == (@score_map((iy+1)*cX +   ix))) && (@link_map(iy, ix, 7) || @link_map(iy+1,   ix, 6))) : false; // down\n\n                                nym1xm1 = (iy > 0    && ix > 0   )    ? ((cyx == (@score_map((iy-1)*cX +   ix-1))) && (@link_map(iy, ix, 2) || @link_map(iy-1,  ix-1, 4))) : false; // up-left\n                                nym1xp1 = (iy > 0    && ix < cX-1)    ? ((cyx == (@score_map((iy-1)*cX +   ix+1))) && (@link_map(iy, ix, 5) || @link_map(iy-1,  ix+1, 1))) : false; // up-right\n                                nyp1xm1 = (iy < cY-1 && ix > 0   )    ? ((cyx == (@score_map((iy+1)*cX +   ix-1))) && (@link_map(iy, ix, 1) || @link_map(iy+1,  ix-1, 5))) : false; // down-left\n                                nyp1xp1 = (iy < cY-1 && ix < cX-1)    ? ((cyx == (@score_map((iy+1)*cX +   ix+1))) && (@link_map(iy, ix, 4) || @link_map(iy+1,  ix+1, 2))) : false; // down-right\n                            }\n                            else {\n                                nym1x = (iy > 0)    ? (cyx == (@score_map((iy-1)*cX +   ix))) : false; // up\n                                nyxm1 = (ix > 0)    ? (cyx == (@score_map(iy    *cX + ix-1))) : false; // left\n                                nyxp1 = (ix < cX-1) ? (cyx == (@score_map(iy    *cX + ix+1))) : false; // right\n                                nyp1x = (iy > cY-1) ? (cyx == (@score_map((iy+1)*cX +   ix))) : false; // down\n\n                                nym1xm1 = (iy > 0    && ix > 0   )    ? (cyx == (@score_map((iy-1)*cX +   ix-1))) : false; // up-left\n                                nym1xp1 = (iy > 0    && ix < cX-1)    ? (cyx == (@score_map((iy-1)*cX +   ix+1))) : false; // up-right\n                                nyp1xm1 = (iy < cY-1 && ix > 0   )    ? (cyx == (@score_map((iy+1)*cX +   ix-1))) : false; // down-left\n                                nyp1xp1 = (iy < cY-1 && ix < cX-1)    ? (cyx == (@score_map((iy+1)*cX +   ix+1))) : false; // down-right\n                            }\n\n                            // Lowest label\n                            unsigned int label = lyx;\n\n                            // Find lowest neighbouring label\n                            label = ((nym1x) && (lym1x < label)) ? lym1x : label;\n                            label = ((nyxm1) && (lyxm1 < label)) ? lyxm1 : label;\n                            label = ((nyxp1) && (lyxp1 < label)) ? lyxp1 : label;\n                            label = ((nyp1x) && (lyp1x < label)) ? lyp1x : label;\n\n                            label = ((nym1xm1) && (lym1xm1 < label)) ? lym1xm1 : label;\n                            label = ((nym1xp1) && (lym1xp1 < label)) ? lym1xp1 : label;\n                            label = ((nyp1xm1) && (lyp1xm1 < label)) ? lyp1xm1 : label;\n                            label = ((nyp1xp1) && (lyp1xp1 < label)) ? lyp1xp1 : label;\n\n                            // If labels are different, resolve them\n                            if(label < lyx) {\n                                // Update label\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\n                                @g_labels(lyx) = label;\n\n                                // Record the change\n                                @in2(0) = 1;\n                            }\n                        }\n                    }\n                    ' + f'\n                    dim3 block(32, 32);\n                    const int cX= {cX};\n                    const int cY= {cY};' + '\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y));\n                    dim3 resolve_block(32, 32);\n                    dim3 resolve_grid(ceil(cX/(float)resolve_block.x), ceil(cY/(float)resolve_block.y));\n                    \n                    // Initialise labels\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY);\n                    \n                    // Resolve the labels\n                    resolve_labels <<< resolve_grid, resolve_block >>>(@ARGS, cX, cY);\n\n                    // Changed Flag\n                    int32 changed = 1;\n                    \n                    // While labels have changed\n                    while(changed) {\n                        // Copy changed to device\n                        cudaMemsetAsync(in2_p, 0, 4);\n                        \n                        // Label image\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY);\n\n                        // Copy changed flag to host\n                        cudaMemcpy(&changed, in2_p, sizeof(int32), cudaMemcpyDeviceToHost);\n                        \n                        // Resolve the labels\n                        resolve_labels <<< resolve_grid, resolve_block >>>(@ARGS, cX, cY);\n                    }\n                    ')
    result = result.reshape((cY, cX))
    (value, _, cnt) = jt.unique(result, return_inverse=True, return_counts=True)
    value = (cnt > result_comp_area_thresh) * value
    value = value[value != 0]
    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)
    map_result[value] = jt.index(value.shape)[0] + 1
    result = map_result[result]
    return result