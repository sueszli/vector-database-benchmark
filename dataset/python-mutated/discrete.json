[
    {
        "func_name": "constant",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including constant() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(...).get_waveform().  Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. Use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef constant(duration: int, amp: complex, name: Optional[str]=None) -> Waveform:\n    \"\"\"Generates constant-sampled :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp``, samples from the function:\n\n    .. math::\n\n        f(x) = A\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Complex pulse amplitude.\n        name: Name of pulse.\n    \"\"\"\n    return _sampled_constant_pulse(duration, amp, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including constant() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(...).get_waveform().  Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. Use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef constant(duration: int, amp: complex, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n    'Generates constant-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, samples from the function:\\n\\n    .. math::\\n\\n        f(x) = A\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Complex pulse amplitude.\\n        name: Name of pulse.\\n    '\n    return _sampled_constant_pulse(duration, amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including constant() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(...).get_waveform().  Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. Use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef constant(duration: int, amp: complex, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates constant-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, samples from the function:\\n\\n    .. math::\\n\\n        f(x) = A\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Complex pulse amplitude.\\n        name: Name of pulse.\\n    '\n    return _sampled_constant_pulse(duration, amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including constant() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(...).get_waveform().  Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. Use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef constant(duration: int, amp: complex, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates constant-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, samples from the function:\\n\\n    .. math::\\n\\n        f(x) = A\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Complex pulse amplitude.\\n        name: Name of pulse.\\n    '\n    return _sampled_constant_pulse(duration, amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including constant() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(...).get_waveform().  Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. Use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef constant(duration: int, amp: complex, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates constant-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, samples from the function:\\n\\n    .. math::\\n\\n        f(x) = A\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Complex pulse amplitude.\\n        name: Name of pulse.\\n    '\n    return _sampled_constant_pulse(duration, amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including constant() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(...).get_waveform().  Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. Use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef constant(duration: int, amp: complex, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates constant-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, samples from the function:\\n\\n    .. math::\\n\\n        f(x) = A\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Complex pulse amplitude.\\n        name: Name of pulse.\\n    '\n    return _sampled_constant_pulse(duration, amp, name=name)"
        ]
    },
    {
        "func_name": "zero",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including zero() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(amp=0,...).get_waveform().', pending=False)\ndef zero(duration: int, name: Optional[str]=None) -> Waveform:\n    \"\"\"Generates zero-sampled :class:`~qiskit.pulse.library.Waveform`.\n\n    Samples from the function:\n\n    .. math::\n\n        f(x) = 0\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        name: Name of pulse.\n    \"\"\"\n    return _sampled_zero_pulse(duration, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including zero() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(amp=0,...).get_waveform().', pending=False)\ndef zero(duration: int, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n    'Generates zero-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    Samples from the function:\\n\\n    .. math::\\n\\n        f(x) = 0\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        name: Name of pulse.\\n    '\n    return _sampled_zero_pulse(duration, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including zero() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(amp=0,...).get_waveform().', pending=False)\ndef zero(duration: int, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates zero-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    Samples from the function:\\n\\n    .. math::\\n\\n        f(x) = 0\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        name: Name of pulse.\\n    '\n    return _sampled_zero_pulse(duration, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including zero() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(amp=0,...).get_waveform().', pending=False)\ndef zero(duration: int, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates zero-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    Samples from the function:\\n\\n    .. math::\\n\\n        f(x) = 0\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        name: Name of pulse.\\n    '\n    return _sampled_zero_pulse(duration, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including zero() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(amp=0,...).get_waveform().', pending=False)\ndef zero(duration: int, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates zero-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    Samples from the function:\\n\\n    .. math::\\n\\n        f(x) = 0\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        name: Name of pulse.\\n    '\n    return _sampled_zero_pulse(duration, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including zero() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Constant(amp=0,...).get_waveform().', pending=False)\ndef zero(duration: int, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates zero-sampled :class:`~qiskit.pulse.library.Waveform`.\\n\\n    Samples from the function:\\n\\n    .. math::\\n\\n        f(x) = 0\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        name: Name of pulse.\\n    '\n    return _sampled_zero_pulse(duration, name=name)"
        ]
    },
    {
        "func_name": "square",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Square(...).get_waveform(). Note that pulse.Square() does not support complex values for `amp`, and that the phase is defined differently. See documentation.', pending=False)\ndef square(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    \"\"\"Generates square wave :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\n    the continuous function:\n\n    .. math::\n\n        f(x) = A \\\\text{sign}\\\\left[ \\\\sin\\\\left(\\\\frac{2 \\\\pi x}{T} + 2\\\\phi\\\\right) \\\\right]\n\n    with the convention :math:`\\\\text{sign}(0) = 1`.\n\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\n        phase: Pulse phase.\n        name: Name of pulse.\n    \"\"\"\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_square_pulse(duration, amp, freq, phase=phase, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Square(...).get_waveform(). Note that pulse.Square() does not support complex values for `amp`, and that the phase is defined differently. See documentation.', pending=False)\ndef square(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n    'Generates square wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\text{sign}\\\\left[ \\\\sin\\\\left(\\\\frac{2 \\\\pi x}{T} + 2\\\\phi\\\\right) \\\\right]\\n\\n    with the convention :math:`\\\\text{sign}(0) = 1`.\\n\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_square_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Square(...).get_waveform(). Note that pulse.Square() does not support complex values for `amp`, and that the phase is defined differently. See documentation.', pending=False)\ndef square(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates square wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\text{sign}\\\\left[ \\\\sin\\\\left(\\\\frac{2 \\\\pi x}{T} + 2\\\\phi\\\\right) \\\\right]\\n\\n    with the convention :math:`\\\\text{sign}(0) = 1`.\\n\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_square_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Square(...).get_waveform(). Note that pulse.Square() does not support complex values for `amp`, and that the phase is defined differently. See documentation.', pending=False)\ndef square(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates square wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\text{sign}\\\\left[ \\\\sin\\\\left(\\\\frac{2 \\\\pi x}{T} + 2\\\\phi\\\\right) \\\\right]\\n\\n    with the convention :math:`\\\\text{sign}(0) = 1`.\\n\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_square_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Square(...).get_waveform(). Note that pulse.Square() does not support complex values for `amp`, and that the phase is defined differently. See documentation.', pending=False)\ndef square(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates square wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\text{sign}\\\\left[ \\\\sin\\\\left(\\\\frac{2 \\\\pi x}{T} + 2\\\\phi\\\\right) \\\\right]\\n\\n    with the convention :math:`\\\\text{sign}(0) = 1`.\\n\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_square_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Square(...).get_waveform(). Note that pulse.Square() does not support complex values for `amp`, and that the phase is defined differently. See documentation.', pending=False)\ndef square(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates square wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\text{sign}\\\\left[ \\\\sin\\\\left(\\\\frac{2 \\\\pi x}{T} + 2\\\\phi\\\\right) \\\\right]\\n\\n    with the convention :math:`\\\\text{sign}(0) = 1`.\\n\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_square_pulse(duration, amp, freq, phase=phase, name=name)"
        ]
    },
    {
        "func_name": "sawtooth",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sawtooth() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sawtooth(...).get_waveform(). Note that pulse.Sawtooth() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`). Also note that the phase is defined differently, such that 2*pi phase shifts by a full cycle.', pending=False)\ndef sawtooth(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    \"\"\"Generates sawtooth wave :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\n    the continuous function:\n\n    .. math::\n\n        f(x) = 2 A \\\\left( g(x) - \\\\left\\\\lfloor \\\\frac{1}{2} + g(x) \\\\right\\\\rfloor\\\\right)\n\n    where :math:`g(x) = x/T + \\\\phi/\\\\pi`.\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\n        phase: Pulse phase.\n        name: Name of pulse.\n\n    Example:\n        .. plot::\n           :include-source:\n\n           import matplotlib.pyplot as plt\n           from qiskit.pulse.library import sawtooth\n           import numpy as np\n\n           duration = 100\n           amp = 1\n           freq = 1 / duration\n           sawtooth_wave = np.real(sawtooth(duration, amp, freq).samples)\n           plt.plot(range(duration), sawtooth_wave)\n           plt.show()\n    \"\"\"\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_sawtooth_pulse(duration, amp, freq, phase=phase, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sawtooth() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sawtooth(...).get_waveform(). Note that pulse.Sawtooth() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`). Also note that the phase is defined differently, such that 2*pi phase shifts by a full cycle.', pending=False)\ndef sawtooth(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n    'Generates sawtooth wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = 2 A \\\\left( g(x) - \\\\left\\\\lfloor \\\\frac{1}{2} + g(x) \\\\right\\\\rfloor\\\\right)\\n\\n    where :math:`g(x) = x/T + \\\\phi/\\\\pi`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import sawtooth\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           sawtooth_wave = np.real(sawtooth(duration, amp, freq).samples)\\n           plt.plot(range(duration), sawtooth_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_sawtooth_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sawtooth() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sawtooth(...).get_waveform(). Note that pulse.Sawtooth() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`). Also note that the phase is defined differently, such that 2*pi phase shifts by a full cycle.', pending=False)\ndef sawtooth(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates sawtooth wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = 2 A \\\\left( g(x) - \\\\left\\\\lfloor \\\\frac{1}{2} + g(x) \\\\right\\\\rfloor\\\\right)\\n\\n    where :math:`g(x) = x/T + \\\\phi/\\\\pi`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import sawtooth\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           sawtooth_wave = np.real(sawtooth(duration, amp, freq).samples)\\n           plt.plot(range(duration), sawtooth_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_sawtooth_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sawtooth() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sawtooth(...).get_waveform(). Note that pulse.Sawtooth() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`). Also note that the phase is defined differently, such that 2*pi phase shifts by a full cycle.', pending=False)\ndef sawtooth(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates sawtooth wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = 2 A \\\\left( g(x) - \\\\left\\\\lfloor \\\\frac{1}{2} + g(x) \\\\right\\\\rfloor\\\\right)\\n\\n    where :math:`g(x) = x/T + \\\\phi/\\\\pi`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import sawtooth\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           sawtooth_wave = np.real(sawtooth(duration, amp, freq).samples)\\n           plt.plot(range(duration), sawtooth_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_sawtooth_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sawtooth() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sawtooth(...).get_waveform(). Note that pulse.Sawtooth() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`). Also note that the phase is defined differently, such that 2*pi phase shifts by a full cycle.', pending=False)\ndef sawtooth(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates sawtooth wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = 2 A \\\\left( g(x) - \\\\left\\\\lfloor \\\\frac{1}{2} + g(x) \\\\right\\\\rfloor\\\\right)\\n\\n    where :math:`g(x) = x/T + \\\\phi/\\\\pi`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import sawtooth\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           sawtooth_wave = np.real(sawtooth(duration, amp, freq).samples)\\n           plt.plot(range(duration), sawtooth_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_sawtooth_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sawtooth() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sawtooth(...).get_waveform(). Note that pulse.Sawtooth() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`). Also note that the phase is defined differently, such that 2*pi phase shifts by a full cycle.', pending=False)\ndef sawtooth(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates sawtooth wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = 2 A \\\\left( g(x) - \\\\left\\\\lfloor \\\\frac{1}{2} + g(x) \\\\right\\\\rfloor\\\\right)\\n\\n    where :math:`g(x) = x/T + \\\\phi/\\\\pi`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import sawtooth\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           sawtooth_wave = np.real(sawtooth(duration, amp, freq).samples)\\n           plt.plot(range(duration), sawtooth_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_sawtooth_pulse(duration, amp, freq, phase=phase, name=name)"
        ]
    },
    {
        "func_name": "triangle",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including triangle() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Triangle(...).get_waveform(). Note that pulse.Triangle() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef triangle(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    \"\"\"Generates triangle wave :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\n    the continuous function:\n\n    .. math::\n\n        f(x) = A \\\\left(-2\\\\left|\\\\text{sawtooth}(x, A, T, \\\\phi)\\\\right| + 1\\\\right)\n\n    This a non-sinusoidal wave with linear ramping.\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\n        phase: Pulse phase.\n        name: Name of pulse.\n\n    Example:\n        .. plot::\n           :include-source:\n\n           import matplotlib.pyplot as plt\n           from qiskit.pulse.library import triangle\n           import numpy as np\n\n           duration = 100\n           amp = 1\n           freq = 1 / duration\n           triangle_wave = np.real(triangle(duration, amp, freq).samples)\n           plt.plot(range(duration), triangle_wave)\n           plt.show()\n    \"\"\"\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_triangle_pulse(duration, amp, freq, phase=phase, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including triangle() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Triangle(...).get_waveform(). Note that pulse.Triangle() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef triangle(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n    'Generates triangle wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\left(-2\\\\left|\\\\text{sawtooth}(x, A, T, \\\\phi)\\\\right| + 1\\\\right)\\n\\n    This a non-sinusoidal wave with linear ramping.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import triangle\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           triangle_wave = np.real(triangle(duration, amp, freq).samples)\\n           plt.plot(range(duration), triangle_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_triangle_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including triangle() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Triangle(...).get_waveform(). Note that pulse.Triangle() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef triangle(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates triangle wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\left(-2\\\\left|\\\\text{sawtooth}(x, A, T, \\\\phi)\\\\right| + 1\\\\right)\\n\\n    This a non-sinusoidal wave with linear ramping.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import triangle\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           triangle_wave = np.real(triangle(duration, amp, freq).samples)\\n           plt.plot(range(duration), triangle_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_triangle_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including triangle() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Triangle(...).get_waveform(). Note that pulse.Triangle() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef triangle(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates triangle wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\left(-2\\\\left|\\\\text{sawtooth}(x, A, T, \\\\phi)\\\\right| + 1\\\\right)\\n\\n    This a non-sinusoidal wave with linear ramping.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import triangle\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           triangle_wave = np.real(triangle(duration, amp, freq).samples)\\n           plt.plot(range(duration), triangle_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_triangle_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including triangle() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Triangle(...).get_waveform(). Note that pulse.Triangle() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef triangle(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates triangle wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\left(-2\\\\left|\\\\text{sawtooth}(x, A, T, \\\\phi)\\\\right| + 1\\\\right)\\n\\n    This a non-sinusoidal wave with linear ramping.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import triangle\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           triangle_wave = np.real(triangle(duration, amp, freq).samples)\\n           plt.plot(range(duration), triangle_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_triangle_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including triangle() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Triangle(...).get_waveform(). Note that pulse.Triangle() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef triangle(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates triangle wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\left(-2\\\\left|\\\\text{sawtooth}(x, A, T, \\\\phi)\\\\right| + 1\\\\right)\\n\\n    This a non-sinusoidal wave with linear ramping.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\\n        freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n\\n    Example:\\n        .. plot::\\n           :include-source:\\n\\n           import matplotlib.pyplot as plt\\n           from qiskit.pulse.library import triangle\\n           import numpy as np\\n\\n           duration = 100\\n           amp = 1\\n           freq = 1 / duration\\n           triangle_wave = np.real(triangle(duration, amp, freq).samples)\\n           plt.plot(range(duration), triangle_wave)\\n           plt.show()\\n    '\n    if freq is None:\n        freq = 1.0 / duration\n    return _sampled_triangle_pulse(duration, amp, freq, phase=phase, name=name)"
        ]
    },
    {
        "func_name": "cos",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including cos() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Cos(...).get_waveform(). Note that pulse.Cos() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef cos(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    \"\"\"Generates cosine wave :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\n    the continuous function:\n\n    .. math::\n\n        f(x) = A \\\\cos(2 \\\\pi \\\\omega x + \\\\phi)\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude.\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\n        phase: Pulse phase.\n        name: Name of pulse.\n    \"\"\"\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_cos_pulse(duration, amp, freq, phase=phase, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including cos() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Cos(...).get_waveform(). Note that pulse.Cos() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef cos(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n    'Generates cosine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\cos(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_cos_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including cos() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Cos(...).get_waveform(). Note that pulse.Cos() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef cos(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates cosine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\cos(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_cos_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including cos() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Cos(...).get_waveform(). Note that pulse.Cos() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef cos(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates cosine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\cos(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_cos_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including cos() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Cos(...).get_waveform(). Note that pulse.Cos() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef cos(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates cosine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\cos(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_cos_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including cos() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Cos(...).get_waveform(). Note that pulse.Cos() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef cos(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates cosine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\cos(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_cos_pulse(duration, amp, freq, phase=phase, name=name)"
        ]
    },
    {
        "func_name": "sin",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sin() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sin(...).get_waveform(). Note that pulse.Sin() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sin(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    \"\"\"Generates sine wave :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\n    the continuous function:\n\n    .. math::\n\n        f(x) = A \\\\sin(2 \\\\pi \\\\omega x + \\\\phi)\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude.\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\n        phase: Pulse phase.\n        name: Name of pulse.\n    \"\"\"\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_sin_pulse(duration, amp, freq, phase=phase, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sin() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sin(...).get_waveform(). Note that pulse.Sin() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sin(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n    'Generates sine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\sin(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_sin_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sin() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sin(...).get_waveform(). Note that pulse.Sin() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sin(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates sine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\sin(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_sin_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sin() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sin(...).get_waveform(). Note that pulse.Sin() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sin(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates sine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\sin(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_sin_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sin() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sin(...).get_waveform(). Note that pulse.Sin() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sin(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates sine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\sin(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_sin_pulse(duration, amp, freq, phase=phase, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sin() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sin(...).get_waveform(). Note that pulse.Sin() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sin(duration: int, amp: complex, freq: float=None, phase: float=0, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates sine wave :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\omega=` ``freq``, and :math:`\\\\phi=` ``phase``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A \\\\sin(2 \\\\pi \\\\omega x + \\\\phi)\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\\n        phase: Pulse phase.\\n        name: Name of pulse.\\n    '\n    if freq is None:\n        freq = 1 / duration\n    return _sampled_sin_pulse(duration, amp, freq, phase=phase, name=name)"
        ]
    },
    {
        "func_name": "gaussian",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Gaussian(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian(duration: int, amp: complex, sigma: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    \"\"\"Generates unnormalized gaussian :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\n    to generate a discrete pulse sampled from the continuous function:\n\n    .. math::\n\n        f(x) = A\\\\exp\\\\left(\\\\left(\\\\frac{x - \\\\mu}{2\\\\sigma}\\\\right)^2 \\\\right),\n\n    with the center :math:`\\\\mu=` ``duration/2``.\n\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\n\n    .. math::\n\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\n\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\n\n    Integrated area under the full curve is ``amp * np.sqrt(2*np.pi*sigma**2)``\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude at ``duration/2``.\n        sigma: Width (standard deviation) of pulse.\n        name: Name of pulse.\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\n    \"\"\"\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_gaussian_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Gaussian(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian(duration: int, amp: complex, sigma: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n    'Generates unnormalized gaussian :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\exp\\\\left(\\\\left(\\\\frac{x - \\\\mu}{2\\\\sigma}\\\\right)^2 \\\\right),\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Integrated area under the full curve is ``amp * np.sqrt(2*np.pi*sigma**2)``\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_gaussian_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Gaussian(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian(duration: int, amp: complex, sigma: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates unnormalized gaussian :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\exp\\\\left(\\\\left(\\\\frac{x - \\\\mu}{2\\\\sigma}\\\\right)^2 \\\\right),\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Integrated area under the full curve is ``amp * np.sqrt(2*np.pi*sigma**2)``\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_gaussian_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Gaussian(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian(duration: int, amp: complex, sigma: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates unnormalized gaussian :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\exp\\\\left(\\\\left(\\\\frac{x - \\\\mu}{2\\\\sigma}\\\\right)^2 \\\\right),\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Integrated area under the full curve is ``amp * np.sqrt(2*np.pi*sigma**2)``\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_gaussian_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Gaussian(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian(duration: int, amp: complex, sigma: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates unnormalized gaussian :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\exp\\\\left(\\\\left(\\\\frac{x - \\\\mu}{2\\\\sigma}\\\\right)^2 \\\\right),\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Integrated area under the full curve is ``amp * np.sqrt(2*np.pi*sigma**2)``\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_gaussian_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Gaussian(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian(duration: int, amp: complex, sigma: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates unnormalized gaussian :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\exp\\\\left(\\\\left(\\\\frac{x - \\\\mu}{2\\\\sigma}\\\\right)^2 \\\\right),\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Integrated area under the full curve is ``amp * np.sqrt(2*np.pi*sigma**2)``\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_gaussian_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)"
        ]
    },
    {
        "func_name": "gaussian_deriv",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianDeriv(...).get_waveform(). Note that pulse.GaussianDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef gaussian_deriv(duration: int, amp: complex, sigma: float, name: Optional[str]=None) -> Waveform:\n    \"\"\"Generates unnormalized gaussian derivative :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma`` applies the `midpoint` sampling strategy\n    to generate a discrete pulse sampled from the continuous function:\n\n    .. math::\n\n        f(x) = -A\\\\frac{(x - \\\\mu)}{\\\\sigma^2}\\\\exp\n            \\\\left(-\\\\frac{1}{2}\\\\left(\\\\frac{x - \\\\mu}{\\\\sigma}\\\\right)^2 \\\\right)\n\n    i.e. the derivative of the Gaussian function, with center :math:`\\\\mu=` ``duration/2``.\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude of corresponding Gaussian at the pulse center (``duration/2``).\n        sigma: Width (standard deviation) of pulse.\n        name: Name of pulse.\n    \"\"\"\n    center = duration / 2\n    return _sampled_gaussian_deriv_pulse(duration, amp, center, sigma, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianDeriv(...).get_waveform(). Note that pulse.GaussianDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef gaussian_deriv(duration: int, amp: complex, sigma: float, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n    'Generates unnormalized gaussian derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma`` applies the `midpoint` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = -A\\\\frac{(x - \\\\mu)}{\\\\sigma^2}\\\\exp\\n            \\\\left(-\\\\frac{1}{2}\\\\left(\\\\frac{x - \\\\mu}{\\\\sigma}\\\\right)^2 \\\\right)\\n\\n    i.e. the derivative of the Gaussian function, with center :math:`\\\\mu=` ``duration/2``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude of corresponding Gaussian at the pulse center (``duration/2``).\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_gaussian_deriv_pulse(duration, amp, center, sigma, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianDeriv(...).get_waveform(). Note that pulse.GaussianDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef gaussian_deriv(duration: int, amp: complex, sigma: float, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates unnormalized gaussian derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma`` applies the `midpoint` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = -A\\\\frac{(x - \\\\mu)}{\\\\sigma^2}\\\\exp\\n            \\\\left(-\\\\frac{1}{2}\\\\left(\\\\frac{x - \\\\mu}{\\\\sigma}\\\\right)^2 \\\\right)\\n\\n    i.e. the derivative of the Gaussian function, with center :math:`\\\\mu=` ``duration/2``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude of corresponding Gaussian at the pulse center (``duration/2``).\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_gaussian_deriv_pulse(duration, amp, center, sigma, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianDeriv(...).get_waveform(). Note that pulse.GaussianDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef gaussian_deriv(duration: int, amp: complex, sigma: float, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates unnormalized gaussian derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma`` applies the `midpoint` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = -A\\\\frac{(x - \\\\mu)}{\\\\sigma^2}\\\\exp\\n            \\\\left(-\\\\frac{1}{2}\\\\left(\\\\frac{x - \\\\mu}{\\\\sigma}\\\\right)^2 \\\\right)\\n\\n    i.e. the derivative of the Gaussian function, with center :math:`\\\\mu=` ``duration/2``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude of corresponding Gaussian at the pulse center (``duration/2``).\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_gaussian_deriv_pulse(duration, amp, center, sigma, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianDeriv(...).get_waveform(). Note that pulse.GaussianDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef gaussian_deriv(duration: int, amp: complex, sigma: float, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates unnormalized gaussian derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma`` applies the `midpoint` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = -A\\\\frac{(x - \\\\mu)}{\\\\sigma^2}\\\\exp\\n            \\\\left(-\\\\frac{1}{2}\\\\left(\\\\frac{x - \\\\mu}{\\\\sigma}\\\\right)^2 \\\\right)\\n\\n    i.e. the derivative of the Gaussian function, with center :math:`\\\\mu=` ``duration/2``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude of corresponding Gaussian at the pulse center (``duration/2``).\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_gaussian_deriv_pulse(duration, amp, center, sigma, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianDeriv(...).get_waveform(). Note that pulse.GaussianDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef gaussian_deriv(duration: int, amp: complex, sigma: float, name: Optional[str]=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates unnormalized gaussian derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma`` applies the `midpoint` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = -A\\\\frac{(x - \\\\mu)}{\\\\sigma^2}\\\\exp\\n            \\\\left(-\\\\frac{1}{2}\\\\left(\\\\frac{x - \\\\mu}{\\\\sigma}\\\\right)^2 \\\\right)\\n\\n    i.e. the derivative of the Gaussian function, with center :math:`\\\\mu=` ``duration/2``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude of corresponding Gaussian at the pulse center (``duration/2``).\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_gaussian_deriv_pulse(duration, amp, center, sigma, name=name)"
        ]
    },
    {
        "func_name": "sech",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sech(...).get_waveform(). Note that pulse.Sech() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech(duration: int, amp: complex, sigma: float, name: str=None, zero_ends: bool=True) -> Waveform:\n    \"\"\"Generates unnormalized sech :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\n    to generate a discrete pulse sampled from the continuous function:\n\n    .. math::\n\n        f(x) = A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\n\n    with the center :math:`\\\\mu=` ``duration/2``.\n\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\n\n    .. math::\n\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\n\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude at `duration/2`.\n        sigma: Width (standard deviation) of pulse.\n        name: Name of pulse.\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\n    \"\"\"\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_sech_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sech(...).get_waveform(). Note that pulse.Sech() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech(duration: int, amp: complex, sigma: float, name: str=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n    'Generates unnormalized sech :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `duration/2`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_sech_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sech(...).get_waveform(). Note that pulse.Sech() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech(duration: int, amp: complex, sigma: float, name: str=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates unnormalized sech :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `duration/2`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_sech_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sech(...).get_waveform(). Note that pulse.Sech() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech(duration: int, amp: complex, sigma: float, name: str=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates unnormalized sech :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `duration/2`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_sech_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sech(...).get_waveform(). Note that pulse.Sech() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech(duration: int, amp: complex, sigma: float, name: str=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates unnormalized sech :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `duration/2`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_sech_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Sech(...).get_waveform(). Note that pulse.Sech() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech(duration: int, amp: complex, sigma: float, name: str=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates unnormalized sech :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp`` and :math:`\\\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\\n    to generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\n\\n    with the center :math:`\\\\mu=` ``duration/2``.\\n\\n    If ``zero_ends==True``, each output sample :math:`y` is modified according to:\\n\\n    .. math::\\n\\n        y \\\\mapsto A\\\\frac{y-y^*}{A-y^*},\\n\\n    where :math:`y^*` is the value of the endpoint samples. This sets the endpoints\\n    to :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\\n    :math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `duration/2`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_sech_pulse(duration, amp, center, sigma, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)"
        ]
    },
    {
        "func_name": "sech_deriv",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.SechDeriv(...).get_waveform(). Note that pulse.SechDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech_deriv(duration: int, amp: complex, sigma: float, name: str=None) -> Waveform:\n    \"\"\"Generates unnormalized sech derivative :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and center :math:`\\\\mu=` ``duration/2``,\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\n    the continuous function:\n\n    .. math::\n        f(x) = \\\\frac{d}{dx}\\\\left[A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\\\right],\n\n    i.e. the derivative of :math:`\\\\text{sech}`.\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude at `center`.\n        sigma: Width (standard deviation) of pulse.\n        name: Name of pulse.\n    \"\"\"\n    center = duration / 2\n    return _sampled_sech_deriv_pulse(duration, amp, center, sigma, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.SechDeriv(...).get_waveform(). Note that pulse.SechDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech_deriv(duration: int, amp: complex, sigma: float, name: str=None) -> Waveform:\n    if False:\n        i = 10\n    'Generates unnormalized sech derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and center :math:`\\\\mu=` ``duration/2``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n        f(x) = \\\\frac{d}{dx}\\\\left[A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\\\right],\\n\\n    i.e. the derivative of :math:`\\\\text{sech}`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `center`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_sech_deriv_pulse(duration, amp, center, sigma, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.SechDeriv(...).get_waveform(). Note that pulse.SechDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech_deriv(duration: int, amp: complex, sigma: float, name: str=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates unnormalized sech derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and center :math:`\\\\mu=` ``duration/2``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n        f(x) = \\\\frac{d}{dx}\\\\left[A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\\\right],\\n\\n    i.e. the derivative of :math:`\\\\text{sech}`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `center`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_sech_deriv_pulse(duration, amp, center, sigma, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.SechDeriv(...).get_waveform(). Note that pulse.SechDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech_deriv(duration: int, amp: complex, sigma: float, name: str=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates unnormalized sech derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and center :math:`\\\\mu=` ``duration/2``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n        f(x) = \\\\frac{d}{dx}\\\\left[A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\\\right],\\n\\n    i.e. the derivative of :math:`\\\\text{sech}`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `center`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_sech_deriv_pulse(duration, amp, center, sigma, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.SechDeriv(...).get_waveform(). Note that pulse.SechDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech_deriv(duration: int, amp: complex, sigma: float, name: str=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates unnormalized sech derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and center :math:`\\\\mu=` ``duration/2``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n        f(x) = \\\\frac{d}{dx}\\\\left[A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\\\right],\\n\\n    i.e. the derivative of :math:`\\\\text{sech}`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `center`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_sech_deriv_pulse(duration, amp, center, sigma, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including sech_deriv() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.SechDeriv(...).get_waveform(). Note that pulse.SechDeriv() does not support complex values for `amp`. Instead, use two float values for (`amp`, `angle`).', pending=False)\ndef sech_deriv(duration: int, amp: complex, sigma: float, name: str=None) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates unnormalized sech derivative :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and center :math:`\\\\mu=` ``duration/2``,\\n    applies the `midpoint` sampling strategy to generate a discrete pulse sampled from\\n    the continuous function:\\n\\n    .. math::\\n        f(x) = \\\\frac{d}{dx}\\\\left[A\\\\text{sech}\\\\left(\\\\frac{x-\\\\mu}{\\\\sigma} \\\\right)\\\\right],\\n\\n    i.e. the derivative of :math:`\\\\text{sech}`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at `center`.\\n        sigma: Width (standard deviation) of pulse.\\n        name: Name of pulse.\\n    '\n    center = duration / 2\n    return _sampled_sech_deriv_pulse(duration, amp, center, sigma, name=name)"
        ]
    },
    {
        "func_name": "gaussian_square",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianSquare(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian_square(duration: int, amp: complex, sigma: float, risefall: Optional[float]=None, width: Optional[float]=None, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    \"\"\"Generates gaussian square :class:`~qiskit.pulse.library.Waveform`.\n\n    For :math:`d=` ``duration``, :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``,\n    and :math:`r=` ``risefall``, applies the ``midpoint`` sampling strategy to\n    generate a discrete pulse sampled from the continuous function:\n\n    .. math::\n\n        f(x) = \\\\begin{cases}\n                    g(x - r) ) & x\\\\leq r \\\\\\\\\n                    A & r\\\\leq x\\\\leq d-r \\\\\\\\\n                    g(x - (d - r)) & d-r\\\\leq x\n                \\\\end{cases}\n\n    where :math:`g(x)` is the Gaussian function sampled from in :meth:`gaussian`\n    with :math:`A=` ``amp``, :math:`\\\\mu=1`, and :math:`\\\\sigma=` ``sigma``. I.e.\n    :math:`f(x)` represents a square pulse with smooth Gaussian edges.\n\n    If ``zero_ends == True``, the samples for the Gaussian ramps are remapped as in\n    :meth:`gaussian`.\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude.\n        sigma: Width (standard deviation) of Gaussian rise/fall portion of the pulse.\n        risefall: Number of samples over which pulse rise and fall happen. Width of\n            square portion of pulse will be ``duration-2*risefall``.\n        width: The duration of the embedded square pulse. Only one of ``width`` or ``risefall``\n               should be specified as the functional form requires\n               ``width = duration - 2 * risefall``.\n        name: Name of pulse.\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\n\n    Raises:\n        PulseError: If ``risefall`` and ``width`` arguments are inconsistent or not enough info.\n    \"\"\"\n    if risefall is None and width is None:\n        raise PulseError(\"gaussian_square missing required argument: 'width' or 'risefall'.\")\n    if risefall is not None:\n        if width is None:\n            width = duration - 2 * risefall\n        elif 2 * risefall + width != duration:\n            raise PulseError('Both width and risefall were specified, and they are inconsistent: 2 * risefall + width == {} != duration == {}.'.format(2 * risefall + width, duration))\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    return _sampled_gaussian_square_pulse(duration, amp, center, width, sigma, zeroed_width=zeroed_width, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianSquare(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian_square(duration: int, amp: complex, sigma: float, risefall: Optional[float]=None, width: Optional[float]=None, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n    'Generates gaussian square :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`d=` ``duration``, :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``,\\n    and :math:`r=` ``risefall``, applies the ``midpoint`` sampling strategy to\\n    generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = \\\\begin{cases}\\n                    g(x - r) ) & x\\\\leq r \\\\\\\\\\n                    A & r\\\\leq x\\\\leq d-r \\\\\\\\\\n                    g(x - (d - r)) & d-r\\\\leq x\\n                \\\\end{cases}\\n\\n    where :math:`g(x)` is the Gaussian function sampled from in :meth:`gaussian`\\n    with :math:`A=` ``amp``, :math:`\\\\mu=1`, and :math:`\\\\sigma=` ``sigma``. I.e.\\n    :math:`f(x)` represents a square pulse with smooth Gaussian edges.\\n\\n    If ``zero_ends == True``, the samples for the Gaussian ramps are remapped as in\\n    :meth:`gaussian`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        sigma: Width (standard deviation) of Gaussian rise/fall portion of the pulse.\\n        risefall: Number of samples over which pulse rise and fall happen. Width of\\n            square portion of pulse will be ``duration-2*risefall``.\\n        width: The duration of the embedded square pulse. Only one of ``width`` or ``risefall``\\n               should be specified as the functional form requires\\n               ``width = duration - 2 * risefall``.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n\\n    Raises:\\n        PulseError: If ``risefall`` and ``width`` arguments are inconsistent or not enough info.\\n    '\n    if risefall is None and width is None:\n        raise PulseError(\"gaussian_square missing required argument: 'width' or 'risefall'.\")\n    if risefall is not None:\n        if width is None:\n            width = duration - 2 * risefall\n        elif 2 * risefall + width != duration:\n            raise PulseError('Both width and risefall were specified, and they are inconsistent: 2 * risefall + width == {} != duration == {}.'.format(2 * risefall + width, duration))\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    return _sampled_gaussian_square_pulse(duration, amp, center, width, sigma, zeroed_width=zeroed_width, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianSquare(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian_square(duration: int, amp: complex, sigma: float, risefall: Optional[float]=None, width: Optional[float]=None, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates gaussian square :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`d=` ``duration``, :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``,\\n    and :math:`r=` ``risefall``, applies the ``midpoint`` sampling strategy to\\n    generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = \\\\begin{cases}\\n                    g(x - r) ) & x\\\\leq r \\\\\\\\\\n                    A & r\\\\leq x\\\\leq d-r \\\\\\\\\\n                    g(x - (d - r)) & d-r\\\\leq x\\n                \\\\end{cases}\\n\\n    where :math:`g(x)` is the Gaussian function sampled from in :meth:`gaussian`\\n    with :math:`A=` ``amp``, :math:`\\\\mu=1`, and :math:`\\\\sigma=` ``sigma``. I.e.\\n    :math:`f(x)` represents a square pulse with smooth Gaussian edges.\\n\\n    If ``zero_ends == True``, the samples for the Gaussian ramps are remapped as in\\n    :meth:`gaussian`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        sigma: Width (standard deviation) of Gaussian rise/fall portion of the pulse.\\n        risefall: Number of samples over which pulse rise and fall happen. Width of\\n            square portion of pulse will be ``duration-2*risefall``.\\n        width: The duration of the embedded square pulse. Only one of ``width`` or ``risefall``\\n               should be specified as the functional form requires\\n               ``width = duration - 2 * risefall``.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n\\n    Raises:\\n        PulseError: If ``risefall`` and ``width`` arguments are inconsistent or not enough info.\\n    '\n    if risefall is None and width is None:\n        raise PulseError(\"gaussian_square missing required argument: 'width' or 'risefall'.\")\n    if risefall is not None:\n        if width is None:\n            width = duration - 2 * risefall\n        elif 2 * risefall + width != duration:\n            raise PulseError('Both width and risefall were specified, and they are inconsistent: 2 * risefall + width == {} != duration == {}.'.format(2 * risefall + width, duration))\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    return _sampled_gaussian_square_pulse(duration, amp, center, width, sigma, zeroed_width=zeroed_width, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianSquare(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian_square(duration: int, amp: complex, sigma: float, risefall: Optional[float]=None, width: Optional[float]=None, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates gaussian square :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`d=` ``duration``, :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``,\\n    and :math:`r=` ``risefall``, applies the ``midpoint`` sampling strategy to\\n    generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = \\\\begin{cases}\\n                    g(x - r) ) & x\\\\leq r \\\\\\\\\\n                    A & r\\\\leq x\\\\leq d-r \\\\\\\\\\n                    g(x - (d - r)) & d-r\\\\leq x\\n                \\\\end{cases}\\n\\n    where :math:`g(x)` is the Gaussian function sampled from in :meth:`gaussian`\\n    with :math:`A=` ``amp``, :math:`\\\\mu=1`, and :math:`\\\\sigma=` ``sigma``. I.e.\\n    :math:`f(x)` represents a square pulse with smooth Gaussian edges.\\n\\n    If ``zero_ends == True``, the samples for the Gaussian ramps are remapped as in\\n    :meth:`gaussian`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        sigma: Width (standard deviation) of Gaussian rise/fall portion of the pulse.\\n        risefall: Number of samples over which pulse rise and fall happen. Width of\\n            square portion of pulse will be ``duration-2*risefall``.\\n        width: The duration of the embedded square pulse. Only one of ``width`` or ``risefall``\\n               should be specified as the functional form requires\\n               ``width = duration - 2 * risefall``.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n\\n    Raises:\\n        PulseError: If ``risefall`` and ``width`` arguments are inconsistent or not enough info.\\n    '\n    if risefall is None and width is None:\n        raise PulseError(\"gaussian_square missing required argument: 'width' or 'risefall'.\")\n    if risefall is not None:\n        if width is None:\n            width = duration - 2 * risefall\n        elif 2 * risefall + width != duration:\n            raise PulseError('Both width and risefall were specified, and they are inconsistent: 2 * risefall + width == {} != duration == {}.'.format(2 * risefall + width, duration))\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    return _sampled_gaussian_square_pulse(duration, amp, center, width, sigma, zeroed_width=zeroed_width, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianSquare(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian_square(duration: int, amp: complex, sigma: float, risefall: Optional[float]=None, width: Optional[float]=None, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates gaussian square :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`d=` ``duration``, :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``,\\n    and :math:`r=` ``risefall``, applies the ``midpoint`` sampling strategy to\\n    generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = \\\\begin{cases}\\n                    g(x - r) ) & x\\\\leq r \\\\\\\\\\n                    A & r\\\\leq x\\\\leq d-r \\\\\\\\\\n                    g(x - (d - r)) & d-r\\\\leq x\\n                \\\\end{cases}\\n\\n    where :math:`g(x)` is the Gaussian function sampled from in :meth:`gaussian`\\n    with :math:`A=` ``amp``, :math:`\\\\mu=1`, and :math:`\\\\sigma=` ``sigma``. I.e.\\n    :math:`f(x)` represents a square pulse with smooth Gaussian edges.\\n\\n    If ``zero_ends == True``, the samples for the Gaussian ramps are remapped as in\\n    :meth:`gaussian`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        sigma: Width (standard deviation) of Gaussian rise/fall portion of the pulse.\\n        risefall: Number of samples over which pulse rise and fall happen. Width of\\n            square portion of pulse will be ``duration-2*risefall``.\\n        width: The duration of the embedded square pulse. Only one of ``width`` or ``risefall``\\n               should be specified as the functional form requires\\n               ``width = duration - 2 * risefall``.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n\\n    Raises:\\n        PulseError: If ``risefall`` and ``width`` arguments are inconsistent or not enough info.\\n    '\n    if risefall is None and width is None:\n        raise PulseError(\"gaussian_square missing required argument: 'width' or 'risefall'.\")\n    if risefall is not None:\n        if width is None:\n            width = duration - 2 * risefall\n        elif 2 * risefall + width != duration:\n            raise PulseError('Both width and risefall were specified, and they are inconsistent: 2 * risefall + width == {} != duration == {}.'.format(2 * risefall + width, duration))\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    return _sampled_gaussian_square_pulse(duration, amp, center, width, sigma, zeroed_width=zeroed_width, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including gaussian_square() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.GaussianSquare(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef gaussian_square(duration: int, amp: complex, sigma: float, risefall: Optional[float]=None, width: Optional[float]=None, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates gaussian square :class:`~qiskit.pulse.library.Waveform`.\\n\\n    For :math:`d=` ``duration``, :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``,\\n    and :math:`r=` ``risefall``, applies the ``midpoint`` sampling strategy to\\n    generate a discrete pulse sampled from the continuous function:\\n\\n    .. math::\\n\\n        f(x) = \\\\begin{cases}\\n                    g(x - r) ) & x\\\\leq r \\\\\\\\\\n                    A & r\\\\leq x\\\\leq d-r \\\\\\\\\\n                    g(x - (d - r)) & d-r\\\\leq x\\n                \\\\end{cases}\\n\\n    where :math:`g(x)` is the Gaussian function sampled from in :meth:`gaussian`\\n    with :math:`A=` ``amp``, :math:`\\\\mu=1`, and :math:`\\\\sigma=` ``sigma``. I.e.\\n    :math:`f(x)` represents a square pulse with smooth Gaussian edges.\\n\\n    If ``zero_ends == True``, the samples for the Gaussian ramps are remapped as in\\n    :meth:`gaussian`.\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude.\\n        sigma: Width (standard deviation) of Gaussian rise/fall portion of the pulse.\\n        risefall: Number of samples over which pulse rise and fall happen. Width of\\n            square portion of pulse will be ``duration-2*risefall``.\\n        width: The duration of the embedded square pulse. Only one of ``width`` or ``risefall``\\n               should be specified as the functional form requires\\n               ``width = duration - 2 * risefall``.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n\\n    Raises:\\n        PulseError: If ``risefall`` and ``width`` arguments are inconsistent or not enough info.\\n    '\n    if risefall is None and width is None:\n        raise PulseError(\"gaussian_square missing required argument: 'width' or 'risefall'.\")\n    if risefall is not None:\n        if width is None:\n            width = duration - 2 * risefall\n        elif 2 * risefall + width != duration:\n            raise PulseError('Both width and risefall were specified, and they are inconsistent: 2 * risefall + width == {} != duration == {}.'.format(2 * risefall + width, duration))\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    return _sampled_gaussian_square_pulse(duration, amp, center, width, sigma, zeroed_width=zeroed_width, name=name)"
        ]
    },
    {
        "func_name": "drag",
        "original": "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including drag() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Drag(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef drag(duration: int, amp: complex, sigma: float, beta: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    \"\"\"Generates Y-only correction DRAG :class:`~qiskit.pulse.library.Waveform` for standard nonlinear\n    oscillator (SNO) [1].\n\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and :math:`\\\\beta=` ``beta``, applies the\n    ``midpoint`` sampling strategy to generate a discrete pulse sampled from the\n    continuous function:\n\n    .. math::\n\n        f(x) = g(x) + i \\\\beta h(x),\n\n    where :math:`g(x)` is the function sampled in :meth:`gaussian`, and :math:`h(x)`\n    is the function sampled in :meth:`gaussian_deriv`.\n\n    If ``zero_ends == True``, the samples from :math:`g(x)` are remapped as in :meth:`gaussian`.\n\n    References:\n        1. |citation1|_\n\n        .. _citation1: http://dx.doi.org/10.1103/PhysRevA.83.012308\n\n        .. |citation1| replace:: *Gambetta, J. M., Motzoi, F., Merkel, S. T. & Wilhelm, F. K.\n           \"Analytic control methods for high-fidelity unitary operations\n           in a weakly nonlinear oscillator.\" Phys. Rev. A 83, 012308 (2011).*\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude at center  ``duration/2``.\n        sigma: Width (standard deviation) of pulse.\n        beta: Y correction amplitude. For the SNO this is\n              :math:`\\\\beta=-\\\\frac{\\\\lambda_1^2}{4\\\\Delta_2}`. Where :math:`\\\\lambda_1` is the\n              relative coupling strength between the first excited and second excited states\n              and :math:`\\\\Delta_2` is the detuning between the respective excited states.\n        name: Name of pulse.\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\n    \"\"\"\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_drag_pulse(duration, amp, center, sigma, beta, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
        "mutated": [
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including drag() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Drag(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef drag(duration: int, amp: complex, sigma: float, beta: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n    'Generates Y-only correction DRAG :class:`~qiskit.pulse.library.Waveform` for standard nonlinear\\n    oscillator (SNO) [1].\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and :math:`\\\\beta=` ``beta``, applies the\\n    ``midpoint`` sampling strategy to generate a discrete pulse sampled from the\\n    continuous function:\\n\\n    .. math::\\n\\n        f(x) = g(x) + i \\\\beta h(x),\\n\\n    where :math:`g(x)` is the function sampled in :meth:`gaussian`, and :math:`h(x)`\\n    is the function sampled in :meth:`gaussian_deriv`.\\n\\n    If ``zero_ends == True``, the samples from :math:`g(x)` are remapped as in :meth:`gaussian`.\\n\\n    References:\\n        1. |citation1|_\\n\\n        .. _citation1: http://dx.doi.org/10.1103/PhysRevA.83.012308\\n\\n        .. |citation1| replace:: *Gambetta, J. M., Motzoi, F., Merkel, S. T. & Wilhelm, F. K.\\n           \"Analytic control methods for high-fidelity unitary operations\\n           in a weakly nonlinear oscillator.\" Phys. Rev. A 83, 012308 (2011).*\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at center  ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        beta: Y correction amplitude. For the SNO this is\\n              :math:`\\\\beta=-\\\\frac{\\\\lambda_1^2}{4\\\\Delta_2}`. Where :math:`\\\\lambda_1` is the\\n              relative coupling strength between the first excited and second excited states\\n              and :math:`\\\\Delta_2` is the detuning between the respective excited states.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_drag_pulse(duration, amp, center, sigma, beta, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including drag() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Drag(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef drag(duration: int, amp: complex, sigma: float, beta: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates Y-only correction DRAG :class:`~qiskit.pulse.library.Waveform` for standard nonlinear\\n    oscillator (SNO) [1].\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and :math:`\\\\beta=` ``beta``, applies the\\n    ``midpoint`` sampling strategy to generate a discrete pulse sampled from the\\n    continuous function:\\n\\n    .. math::\\n\\n        f(x) = g(x) + i \\\\beta h(x),\\n\\n    where :math:`g(x)` is the function sampled in :meth:`gaussian`, and :math:`h(x)`\\n    is the function sampled in :meth:`gaussian_deriv`.\\n\\n    If ``zero_ends == True``, the samples from :math:`g(x)` are remapped as in :meth:`gaussian`.\\n\\n    References:\\n        1. |citation1|_\\n\\n        .. _citation1: http://dx.doi.org/10.1103/PhysRevA.83.012308\\n\\n        .. |citation1| replace:: *Gambetta, J. M., Motzoi, F., Merkel, S. T. & Wilhelm, F. K.\\n           \"Analytic control methods for high-fidelity unitary operations\\n           in a weakly nonlinear oscillator.\" Phys. Rev. A 83, 012308 (2011).*\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at center  ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        beta: Y correction amplitude. For the SNO this is\\n              :math:`\\\\beta=-\\\\frac{\\\\lambda_1^2}{4\\\\Delta_2}`. Where :math:`\\\\lambda_1` is the\\n              relative coupling strength between the first excited and second excited states\\n              and :math:`\\\\Delta_2` is the detuning between the respective excited states.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_drag_pulse(duration, amp, center, sigma, beta, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including drag() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Drag(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef drag(duration: int, amp: complex, sigma: float, beta: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates Y-only correction DRAG :class:`~qiskit.pulse.library.Waveform` for standard nonlinear\\n    oscillator (SNO) [1].\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and :math:`\\\\beta=` ``beta``, applies the\\n    ``midpoint`` sampling strategy to generate a discrete pulse sampled from the\\n    continuous function:\\n\\n    .. math::\\n\\n        f(x) = g(x) + i \\\\beta h(x),\\n\\n    where :math:`g(x)` is the function sampled in :meth:`gaussian`, and :math:`h(x)`\\n    is the function sampled in :meth:`gaussian_deriv`.\\n\\n    If ``zero_ends == True``, the samples from :math:`g(x)` are remapped as in :meth:`gaussian`.\\n\\n    References:\\n        1. |citation1|_\\n\\n        .. _citation1: http://dx.doi.org/10.1103/PhysRevA.83.012308\\n\\n        .. |citation1| replace:: *Gambetta, J. M., Motzoi, F., Merkel, S. T. & Wilhelm, F. K.\\n           \"Analytic control methods for high-fidelity unitary operations\\n           in a weakly nonlinear oscillator.\" Phys. Rev. A 83, 012308 (2011).*\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at center  ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        beta: Y correction amplitude. For the SNO this is\\n              :math:`\\\\beta=-\\\\frac{\\\\lambda_1^2}{4\\\\Delta_2}`. Where :math:`\\\\lambda_1` is the\\n              relative coupling strength between the first excited and second excited states\\n              and :math:`\\\\Delta_2` is the detuning between the respective excited states.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_drag_pulse(duration, amp, center, sigma, beta, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including drag() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Drag(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef drag(duration: int, amp: complex, sigma: float, beta: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates Y-only correction DRAG :class:`~qiskit.pulse.library.Waveform` for standard nonlinear\\n    oscillator (SNO) [1].\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and :math:`\\\\beta=` ``beta``, applies the\\n    ``midpoint`` sampling strategy to generate a discrete pulse sampled from the\\n    continuous function:\\n\\n    .. math::\\n\\n        f(x) = g(x) + i \\\\beta h(x),\\n\\n    where :math:`g(x)` is the function sampled in :meth:`gaussian`, and :math:`h(x)`\\n    is the function sampled in :meth:`gaussian_deriv`.\\n\\n    If ``zero_ends == True``, the samples from :math:`g(x)` are remapped as in :meth:`gaussian`.\\n\\n    References:\\n        1. |citation1|_\\n\\n        .. _citation1: http://dx.doi.org/10.1103/PhysRevA.83.012308\\n\\n        .. |citation1| replace:: *Gambetta, J. M., Motzoi, F., Merkel, S. T. & Wilhelm, F. K.\\n           \"Analytic control methods for high-fidelity unitary operations\\n           in a weakly nonlinear oscillator.\" Phys. Rev. A 83, 012308 (2011).*\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at center  ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        beta: Y correction amplitude. For the SNO this is\\n              :math:`\\\\beta=-\\\\frac{\\\\lambda_1^2}{4\\\\Delta_2}`. Where :math:`\\\\lambda_1` is the\\n              relative coupling strength between the first excited and second excited states\\n              and :math:`\\\\Delta_2` is the detuning between the respective excited states.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_drag_pulse(duration, amp, center, sigma, beta, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)",
            "@deprecate_func(since='0.46.0', additional_msg='The discrete pulses library, including drag() is deprecated. Instead, use the SymbolicPulse library to create the waveform with pulse.Drag(...).get_waveform(). Note that complex value support for the `amp` parameter is deprecated in the SymbolicPulse library. It is therefore recommended to use two float values for (`amp`, `angle`) instead of complex `amp`', pending=False)\ndef drag(duration: int, amp: complex, sigma: float, beta: float, name: Optional[str]=None, zero_ends: bool=True) -> Waveform:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates Y-only correction DRAG :class:`~qiskit.pulse.library.Waveform` for standard nonlinear\\n    oscillator (SNO) [1].\\n\\n    For :math:`A=` ``amp``, :math:`\\\\sigma=` ``sigma``, and :math:`\\\\beta=` ``beta``, applies the\\n    ``midpoint`` sampling strategy to generate a discrete pulse sampled from the\\n    continuous function:\\n\\n    .. math::\\n\\n        f(x) = g(x) + i \\\\beta h(x),\\n\\n    where :math:`g(x)` is the function sampled in :meth:`gaussian`, and :math:`h(x)`\\n    is the function sampled in :meth:`gaussian_deriv`.\\n\\n    If ``zero_ends == True``, the samples from :math:`g(x)` are remapped as in :meth:`gaussian`.\\n\\n    References:\\n        1. |citation1|_\\n\\n        .. _citation1: http://dx.doi.org/10.1103/PhysRevA.83.012308\\n\\n        .. |citation1| replace:: *Gambetta, J. M., Motzoi, F., Merkel, S. T. & Wilhelm, F. K.\\n           \"Analytic control methods for high-fidelity unitary operations\\n           in a weakly nonlinear oscillator.\" Phys. Rev. A 83, 012308 (2011).*\\n\\n    Args:\\n        duration: Duration of pulse. Must be greater than zero.\\n        amp: Pulse amplitude at center  ``duration/2``.\\n        sigma: Width (standard deviation) of pulse.\\n        beta: Y correction amplitude. For the SNO this is\\n              :math:`\\\\beta=-\\\\frac{\\\\lambda_1^2}{4\\\\Delta_2}`. Where :math:`\\\\lambda_1` is the\\n              relative coupling strength between the first excited and second excited states\\n              and :math:`\\\\Delta_2` is the detuning between the respective excited states.\\n        name: Name of pulse.\\n        zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\\n    '\n    center = duration / 2\n    zeroed_width = duration + 2 if zero_ends else None\n    rescale_amp = bool(zero_ends)\n    return _sampled_drag_pulse(duration, amp, center, sigma, beta, zeroed_width=zeroed_width, rescale_amp=rescale_amp, name=name)"
        ]
    }
]