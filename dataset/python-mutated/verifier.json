[
    {
        "func_name": "constrain_to_known_func_ids",
        "original": "def constrain_to_known_func_ids(state):\n    world = state.platform\n    tx = world.human_transactions[-1]\n    md = state.manticore.get_metadata(tx.address)\n    N = 0\n    is_normal = False\n    func_id = tx.data[:4]\n    for func_hsh in md.function_selectors:\n        N += 1\n        is_normal = OR(func_hsh == func_id, is_normal)\n    is_fallback = NOT(is_normal)\n    is_known_func_id = is_normal\n    chosen_fallback_func_is = None\n    if state.can_be_true(is_fallback):\n        with state as temp_state:\n            temp_state.constraint(is_fallback)\n            chosen_fallback_func_id = bytes(state.solve_one(tx.data[:4]))\n            is_known_func_id = OR(is_known_func_id, chosen_fallback_func_id == func_id)\n            N += 1\n    state.constrain(is_known_func_id)\n    return N",
        "mutated": [
            "def constrain_to_known_func_ids(state):\n    if False:\n        i = 10\n    world = state.platform\n    tx = world.human_transactions[-1]\n    md = state.manticore.get_metadata(tx.address)\n    N = 0\n    is_normal = False\n    func_id = tx.data[:4]\n    for func_hsh in md.function_selectors:\n        N += 1\n        is_normal = OR(func_hsh == func_id, is_normal)\n    is_fallback = NOT(is_normal)\n    is_known_func_id = is_normal\n    chosen_fallback_func_is = None\n    if state.can_be_true(is_fallback):\n        with state as temp_state:\n            temp_state.constraint(is_fallback)\n            chosen_fallback_func_id = bytes(state.solve_one(tx.data[:4]))\n            is_known_func_id = OR(is_known_func_id, chosen_fallback_func_id == func_id)\n            N += 1\n    state.constrain(is_known_func_id)\n    return N",
            "def constrain_to_known_func_ids(state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    world = state.platform\n    tx = world.human_transactions[-1]\n    md = state.manticore.get_metadata(tx.address)\n    N = 0\n    is_normal = False\n    func_id = tx.data[:4]\n    for func_hsh in md.function_selectors:\n        N += 1\n        is_normal = OR(func_hsh == func_id, is_normal)\n    is_fallback = NOT(is_normal)\n    is_known_func_id = is_normal\n    chosen_fallback_func_is = None\n    if state.can_be_true(is_fallback):\n        with state as temp_state:\n            temp_state.constraint(is_fallback)\n            chosen_fallback_func_id = bytes(state.solve_one(tx.data[:4]))\n            is_known_func_id = OR(is_known_func_id, chosen_fallback_func_id == func_id)\n            N += 1\n    state.constrain(is_known_func_id)\n    return N",
            "def constrain_to_known_func_ids(state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    world = state.platform\n    tx = world.human_transactions[-1]\n    md = state.manticore.get_metadata(tx.address)\n    N = 0\n    is_normal = False\n    func_id = tx.data[:4]\n    for func_hsh in md.function_selectors:\n        N += 1\n        is_normal = OR(func_hsh == func_id, is_normal)\n    is_fallback = NOT(is_normal)\n    is_known_func_id = is_normal\n    chosen_fallback_func_is = None\n    if state.can_be_true(is_fallback):\n        with state as temp_state:\n            temp_state.constraint(is_fallback)\n            chosen_fallback_func_id = bytes(state.solve_one(tx.data[:4]))\n            is_known_func_id = OR(is_known_func_id, chosen_fallback_func_id == func_id)\n            N += 1\n    state.constrain(is_known_func_id)\n    return N",
            "def constrain_to_known_func_ids(state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    world = state.platform\n    tx = world.human_transactions[-1]\n    md = state.manticore.get_metadata(tx.address)\n    N = 0\n    is_normal = False\n    func_id = tx.data[:4]\n    for func_hsh in md.function_selectors:\n        N += 1\n        is_normal = OR(func_hsh == func_id, is_normal)\n    is_fallback = NOT(is_normal)\n    is_known_func_id = is_normal\n    chosen_fallback_func_is = None\n    if state.can_be_true(is_fallback):\n        with state as temp_state:\n            temp_state.constraint(is_fallback)\n            chosen_fallback_func_id = bytes(state.solve_one(tx.data[:4]))\n            is_known_func_id = OR(is_known_func_id, chosen_fallback_func_id == func_id)\n            N += 1\n    state.constrain(is_known_func_id)\n    return N",
            "def constrain_to_known_func_ids(state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    world = state.platform\n    tx = world.human_transactions[-1]\n    md = state.manticore.get_metadata(tx.address)\n    N = 0\n    is_normal = False\n    func_id = tx.data[:4]\n    for func_hsh in md.function_selectors:\n        N += 1\n        is_normal = OR(func_hsh == func_id, is_normal)\n    is_fallback = NOT(is_normal)\n    is_known_func_id = is_normal\n    chosen_fallback_func_is = None\n    if state.can_be_true(is_fallback):\n        with state as temp_state:\n            temp_state.constraint(is_fallback)\n            chosen_fallback_func_id = bytes(state.solve_one(tx.data[:4]))\n            is_known_func_id = OR(is_known_func_id, chosen_fallback_func_id == func_id)\n            N += 1\n    state.constrain(is_known_func_id)\n    return N"
        ]
    },
    {
        "func_name": "manticore_verifier",
        "original": "def manticore_verifier(source_code, contract_name, maxfail=None, maxt=3, maxcov=100, deployer=None, senders=None, psender=None, propre='crytic_.*', compile_args=None, outputspace_url=None, timeout=100):\n    \"\"\"Verify solidity properties\n    The results are dumped to stdout and to the workspace folder.\n\n        $manticore-verifier property.sol  --contract TestToken --smt.solver yices --maxt 4\n        # Owner account: 0xf3c67ffb8ab4cdd4d3243ad247d0641cd24af939\n        # Contract account: 0x6f4b51ac2eb017600e9263085cfa06f831132c72\n        # Sender_0 account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\n        # PSender account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\n        # Found 2 properties: crytic_test_must_revert, crytic_test_balance\n        # Exploration will stop when some of the following happens:\n        # * 4 human transaction sent\n        # * Code coverage is greater than 100% meassured on target contract\n        # * No more coverage was gained in the last transaction\n        # * At least 2 different properties where found to be breakable. (1 for fail fast)\n        # * 240 seconds pass\n        # Starting exploration...\n        Transactions done: 0. States: 1, RT Coverage: 0.0%, Failing properties: 0/2\n        Transactions done: 1. States: 2, RT Coverage: 55.43%, Failing properties: 0/2\n        Transactions done: 2. States: 8, RT Coverage: 80.48%, Failing properties: 1/2\n        Transactions done: 3. States: 30, RT Coverage: 80.48%, Failing properties: 1/2\n        No coverage progress. Stopping exploration.\n        Coverage obtained 80.48%. (RT + prop)\n        +-------------------------+------------+\n        |      Property Named     |   Status   |\n        +-------------------------+------------+\n        |   crytic_test_balance   | failed (0) |\n        | crytic_test_must_revert |   passed   |\n        +-------------------------+------------+\n        Checkout testcases here:./mcore_6jdil7nh\n\n    :param maxfail: stop after maxfail properties are failing. All if None\n    :param maxcov: Stop after maxcov % coverage is obtained in the main contract\n    :param maxt: Max transaction count to explore\n    :param deployer: (optional) address of account used to deploy the contract\n    :param senders: (optional) a list of calles addresses for the exploration\n    :param psender: (optional) address from where the property is tested\n    :param source_code: A filename or source code\n    :param contract_name: The target contract name defined in the source code\n    :param propre: A regular expression for selecting properties\n    :param outputspace_url: where to put the extended result\n    :param timeout: timeout in seconds\n    :return:\n    \"\"\"\n    MAXTX = maxt\n    MAXCOV = maxcov\n    MAXFAIL = maxfail\n    config.get_group('smt').timeout = 120\n    config.get_group('smt').memory = 16384\n    config.get_group('evm').ignore_balance = True\n    config.get_group('evm').oog = 'ignore'\n    print('# Welcome to manticore-verifier')\n    m = ManticoreEVM()\n    filter_out_human_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n    m.register_plugin(filter_out_human_constants)\n    filter_out_human_constants.disable()\n    filter_no_crytic = FilterFunctions(regexp=propre, include=False)\n    m.register_plugin(filter_no_crytic)\n    filter_no_crytic.disable()\n    filter_only_crytic = FilterFunctions(regexp=propre, depth='human', fallback=False, include=True)\n    m.register_plugin(filter_only_crytic)\n    filter_only_crytic.disable()\n    senders = (None,) if senders is None else senders\n    user_accounts = []\n    for (n, address_i) in enumerate(senders):\n        user_accounts.append(m.create_account(balance=10 ** 10, address=address_i, name=f'sender_{n}'))\n    owner_account = m.create_account(balance=10 ** 10, address=deployer, name='deployer')\n    contract_account = m.solidity_create_contract(source_code, owner=owner_account, contract_name=contract_name, compile_args=compile_args, name='contract_account')\n    checker_account = m.create_account(balance=10 ** 10, address=psender, name='psender')\n    print(f'# Owner account: 0x{int(owner_account):x}')\n    print(f'# Contract account: 0x{int(contract_account):x}')\n    for (n, user_account) in enumerate(user_accounts):\n        print(f'# Sender_{n} account: 0x{int(user_account):x}')\n    print(f'# PSender account: 0x{int(checker_account):x}')\n    properties = {}\n    md = m.get_metadata(contract_account)\n    for func_hsh in md.function_selectors:\n        func_name = md.get_abi(func_hsh)['name']\n        if re.match(propre, func_name):\n            properties[func_name] = []\n    print(f\"# Found {len(properties)} properties: {', '.join(properties.keys())}\")\n    if not properties:\n        print('I am sorry I had to run the init bytecode for this.\\nGood Bye.')\n        return\n    MAXFAIL = len(properties) if MAXFAIL is None else MAXFAIL\n    tx_num = 0\n    current_coverage = None\n    new_coverage = 0.0\n    print(f'# Exploration will stop when some of the following happens:\\n# * {MAXTX} human transaction sent\\n# * Code coverage is greater than {MAXCOV}% meassured on target contract\\n# * No more coverage was gained in the last transaction\\n# * At least {MAXFAIL} different properties where found to be breakable. (1 for fail fast)\\n# * {timeout} seconds pass')\n    print('# Starting exploration...')\n    print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {0.0}%, Failing properties: 0/{len(properties)}')\n    with m.kill_timeout(timeout=timeout):\n        while not m.is_killed():\n            broken_properties = sum((int(len(x) != 0) for x in properties.values()))\n            if broken_properties >= MAXFAIL:\n                print(f'Found {broken_properties}/{len(properties)} failing properties. Stopping exploration.')\n                break\n            if tx_num >= MAXTX:\n                print(f'Max number of transactions reached ({tx_num})')\n                break\n            tx_num += 1\n            new_coverage = m.global_coverage(contract_account)\n            if new_coverage >= MAXCOV:\n                print(f'Current coverage({new_coverage}%) is greater than max allowed ({MAXCOV}%). Stopping exploration.')\n                break\n            if current_coverage == new_coverage:\n                print(f'No coverage progress. Stopping exploration.')\n                break\n            current_coverage = new_coverage\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.enable()\n            filter_out_human_constants.enable()\n            filter_only_crytic.disable()\n            symbolic_data = m.make_symbolic_buffer(320)\n            symbolic_value = m.make_symbolic_value()\n            caller_account = m.make_symbolic_value(160)\n            args = tuple((caller_account == address_i for address_i in user_accounts))\n            m.constrain(OR(*args, False))\n            m.transaction(caller=caller_account, address=contract_account, value=symbolic_value, data=symbolic_data)\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            m.clear_terminated_states()\n            m.take_snapshot()\n            print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {m.global_coverage(contract_account):3.2f}%, Failing properties: {broken_properties}/{len(properties)}')\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.disable()\n            filter_out_human_constants.disable()\n            filter_only_crytic.enable()\n            symbolic_data = m.make_symbolic_buffer(4)\n            m.transaction(caller=checker_account, address=contract_account, value=0, data=symbolic_data)\n            for state in m.all_states:\n                world = state.platform\n                tx = world.human_transactions[-1]\n                md = m.get_metadata(tx.address)\n                \"\\n                A is _broken_ if:\\n                     * is normal property\\n                     * RETURN False\\n                   OR:\\n                     * property name ends with 'revert'\\n                     * does not REVERT\\n                Property is considered to _pass_ otherwise\\n                \"\n                N = constrain_to_known_func_ids(state)\n                for func_id in map(bytes, state.solve_n(tx.data[:4], nsolves=N)):\n                    func_name = md.get_abi(func_id)['name']\n                    if not func_name.endswith('revert'):\n                        if tx.return_value == 1:\n                            return_data = ABI.deserialize('bool', tx.return_data)\n                            testcase = m.generate_testcase(state, f'property {md.get_func_name(func_id)} is broken', only_if=AND(tx.data[:4] == func_id, return_data == 0))\n                            if testcase:\n                                properties[func_name].append(testcase.num)\n                    elif tx.result != 'REVERT':\n                        testcase = m.generate_testcase(state, f'Some property is broken did not reverted.(MUST REVERTED)', only_if=tx.data[:4] == func_id)\n                        if testcase:\n                            properties[func_name].append(testcase.num)\n            m.clear_terminated_states()\n            m.goto_snapshot()\n        else:\n            print('Cancelled or timeout.')\n    m.clear_terminated_states()\n    m.clear_ready_states()\n    m.clear_snapshot()\n    if m.is_killed():\n        print('Exploration ended by CTRL+C or timeout')\n    print(f'Coverage obtained {new_coverage:3.2f}%. (RT + prop)')\n    x = PrettyTable()\n    x.field_names = ['Property Named', 'Status']\n    for (name, testcases) in sorted(properties.items()):\n        result = 'passed'\n        if testcases:\n            result = f'failed ({testcases[0]})'\n        x.add_row((name, result))\n    print(x)\n    m.clear_ready_states()\n    workspace = os.path.abspath(m.workspace)[len(os.getcwd()) + 1:]\n    print(f'Checkout testcases here:./{workspace}')",
        "mutated": [
            "def manticore_verifier(source_code, contract_name, maxfail=None, maxt=3, maxcov=100, deployer=None, senders=None, psender=None, propre='crytic_.*', compile_args=None, outputspace_url=None, timeout=100):\n    if False:\n        i = 10\n    'Verify solidity properties\\n    The results are dumped to stdout and to the workspace folder.\\n\\n        $manticore-verifier property.sol  --contract TestToken --smt.solver yices --maxt 4\\n        # Owner account: 0xf3c67ffb8ab4cdd4d3243ad247d0641cd24af939\\n        # Contract account: 0x6f4b51ac2eb017600e9263085cfa06f831132c72\\n        # Sender_0 account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # PSender account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # Found 2 properties: crytic_test_must_revert, crytic_test_balance\\n        # Exploration will stop when some of the following happens:\\n        # * 4 human transaction sent\\n        # * Code coverage is greater than 100% meassured on target contract\\n        # * No more coverage was gained in the last transaction\\n        # * At least 2 different properties where found to be breakable. (1 for fail fast)\\n        # * 240 seconds pass\\n        # Starting exploration...\\n        Transactions done: 0. States: 1, RT Coverage: 0.0%, Failing properties: 0/2\\n        Transactions done: 1. States: 2, RT Coverage: 55.43%, Failing properties: 0/2\\n        Transactions done: 2. States: 8, RT Coverage: 80.48%, Failing properties: 1/2\\n        Transactions done: 3. States: 30, RT Coverage: 80.48%, Failing properties: 1/2\\n        No coverage progress. Stopping exploration.\\n        Coverage obtained 80.48%. (RT + prop)\\n        +-------------------------+------------+\\n        |      Property Named     |   Status   |\\n        +-------------------------+------------+\\n        |   crytic_test_balance   | failed (0) |\\n        | crytic_test_must_revert |   passed   |\\n        +-------------------------+------------+\\n        Checkout testcases here:./mcore_6jdil7nh\\n\\n    :param maxfail: stop after maxfail properties are failing. All if None\\n    :param maxcov: Stop after maxcov % coverage is obtained in the main contract\\n    :param maxt: Max transaction count to explore\\n    :param deployer: (optional) address of account used to deploy the contract\\n    :param senders: (optional) a list of calles addresses for the exploration\\n    :param psender: (optional) address from where the property is tested\\n    :param source_code: A filename or source code\\n    :param contract_name: The target contract name defined in the source code\\n    :param propre: A regular expression for selecting properties\\n    :param outputspace_url: where to put the extended result\\n    :param timeout: timeout in seconds\\n    :return:\\n    '\n    MAXTX = maxt\n    MAXCOV = maxcov\n    MAXFAIL = maxfail\n    config.get_group('smt').timeout = 120\n    config.get_group('smt').memory = 16384\n    config.get_group('evm').ignore_balance = True\n    config.get_group('evm').oog = 'ignore'\n    print('# Welcome to manticore-verifier')\n    m = ManticoreEVM()\n    filter_out_human_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n    m.register_plugin(filter_out_human_constants)\n    filter_out_human_constants.disable()\n    filter_no_crytic = FilterFunctions(regexp=propre, include=False)\n    m.register_plugin(filter_no_crytic)\n    filter_no_crytic.disable()\n    filter_only_crytic = FilterFunctions(regexp=propre, depth='human', fallback=False, include=True)\n    m.register_plugin(filter_only_crytic)\n    filter_only_crytic.disable()\n    senders = (None,) if senders is None else senders\n    user_accounts = []\n    for (n, address_i) in enumerate(senders):\n        user_accounts.append(m.create_account(balance=10 ** 10, address=address_i, name=f'sender_{n}'))\n    owner_account = m.create_account(balance=10 ** 10, address=deployer, name='deployer')\n    contract_account = m.solidity_create_contract(source_code, owner=owner_account, contract_name=contract_name, compile_args=compile_args, name='contract_account')\n    checker_account = m.create_account(balance=10 ** 10, address=psender, name='psender')\n    print(f'# Owner account: 0x{int(owner_account):x}')\n    print(f'# Contract account: 0x{int(contract_account):x}')\n    for (n, user_account) in enumerate(user_accounts):\n        print(f'# Sender_{n} account: 0x{int(user_account):x}')\n    print(f'# PSender account: 0x{int(checker_account):x}')\n    properties = {}\n    md = m.get_metadata(contract_account)\n    for func_hsh in md.function_selectors:\n        func_name = md.get_abi(func_hsh)['name']\n        if re.match(propre, func_name):\n            properties[func_name] = []\n    print(f\"# Found {len(properties)} properties: {', '.join(properties.keys())}\")\n    if not properties:\n        print('I am sorry I had to run the init bytecode for this.\\nGood Bye.')\n        return\n    MAXFAIL = len(properties) if MAXFAIL is None else MAXFAIL\n    tx_num = 0\n    current_coverage = None\n    new_coverage = 0.0\n    print(f'# Exploration will stop when some of the following happens:\\n# * {MAXTX} human transaction sent\\n# * Code coverage is greater than {MAXCOV}% meassured on target contract\\n# * No more coverage was gained in the last transaction\\n# * At least {MAXFAIL} different properties where found to be breakable. (1 for fail fast)\\n# * {timeout} seconds pass')\n    print('# Starting exploration...')\n    print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {0.0}%, Failing properties: 0/{len(properties)}')\n    with m.kill_timeout(timeout=timeout):\n        while not m.is_killed():\n            broken_properties = sum((int(len(x) != 0) for x in properties.values()))\n            if broken_properties >= MAXFAIL:\n                print(f'Found {broken_properties}/{len(properties)} failing properties. Stopping exploration.')\n                break\n            if tx_num >= MAXTX:\n                print(f'Max number of transactions reached ({tx_num})')\n                break\n            tx_num += 1\n            new_coverage = m.global_coverage(contract_account)\n            if new_coverage >= MAXCOV:\n                print(f'Current coverage({new_coverage}%) is greater than max allowed ({MAXCOV}%). Stopping exploration.')\n                break\n            if current_coverage == new_coverage:\n                print(f'No coverage progress. Stopping exploration.')\n                break\n            current_coverage = new_coverage\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.enable()\n            filter_out_human_constants.enable()\n            filter_only_crytic.disable()\n            symbolic_data = m.make_symbolic_buffer(320)\n            symbolic_value = m.make_symbolic_value()\n            caller_account = m.make_symbolic_value(160)\n            args = tuple((caller_account == address_i for address_i in user_accounts))\n            m.constrain(OR(*args, False))\n            m.transaction(caller=caller_account, address=contract_account, value=symbolic_value, data=symbolic_data)\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            m.clear_terminated_states()\n            m.take_snapshot()\n            print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {m.global_coverage(contract_account):3.2f}%, Failing properties: {broken_properties}/{len(properties)}')\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.disable()\n            filter_out_human_constants.disable()\n            filter_only_crytic.enable()\n            symbolic_data = m.make_symbolic_buffer(4)\n            m.transaction(caller=checker_account, address=contract_account, value=0, data=symbolic_data)\n            for state in m.all_states:\n                world = state.platform\n                tx = world.human_transactions[-1]\n                md = m.get_metadata(tx.address)\n                \"\\n                A is _broken_ if:\\n                     * is normal property\\n                     * RETURN False\\n                   OR:\\n                     * property name ends with 'revert'\\n                     * does not REVERT\\n                Property is considered to _pass_ otherwise\\n                \"\n                N = constrain_to_known_func_ids(state)\n                for func_id in map(bytes, state.solve_n(tx.data[:4], nsolves=N)):\n                    func_name = md.get_abi(func_id)['name']\n                    if not func_name.endswith('revert'):\n                        if tx.return_value == 1:\n                            return_data = ABI.deserialize('bool', tx.return_data)\n                            testcase = m.generate_testcase(state, f'property {md.get_func_name(func_id)} is broken', only_if=AND(tx.data[:4] == func_id, return_data == 0))\n                            if testcase:\n                                properties[func_name].append(testcase.num)\n                    elif tx.result != 'REVERT':\n                        testcase = m.generate_testcase(state, f'Some property is broken did not reverted.(MUST REVERTED)', only_if=tx.data[:4] == func_id)\n                        if testcase:\n                            properties[func_name].append(testcase.num)\n            m.clear_terminated_states()\n            m.goto_snapshot()\n        else:\n            print('Cancelled or timeout.')\n    m.clear_terminated_states()\n    m.clear_ready_states()\n    m.clear_snapshot()\n    if m.is_killed():\n        print('Exploration ended by CTRL+C or timeout')\n    print(f'Coverage obtained {new_coverage:3.2f}%. (RT + prop)')\n    x = PrettyTable()\n    x.field_names = ['Property Named', 'Status']\n    for (name, testcases) in sorted(properties.items()):\n        result = 'passed'\n        if testcases:\n            result = f'failed ({testcases[0]})'\n        x.add_row((name, result))\n    print(x)\n    m.clear_ready_states()\n    workspace = os.path.abspath(m.workspace)[len(os.getcwd()) + 1:]\n    print(f'Checkout testcases here:./{workspace}')",
            "def manticore_verifier(source_code, contract_name, maxfail=None, maxt=3, maxcov=100, deployer=None, senders=None, psender=None, propre='crytic_.*', compile_args=None, outputspace_url=None, timeout=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Verify solidity properties\\n    The results are dumped to stdout and to the workspace folder.\\n\\n        $manticore-verifier property.sol  --contract TestToken --smt.solver yices --maxt 4\\n        # Owner account: 0xf3c67ffb8ab4cdd4d3243ad247d0641cd24af939\\n        # Contract account: 0x6f4b51ac2eb017600e9263085cfa06f831132c72\\n        # Sender_0 account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # PSender account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # Found 2 properties: crytic_test_must_revert, crytic_test_balance\\n        # Exploration will stop when some of the following happens:\\n        # * 4 human transaction sent\\n        # * Code coverage is greater than 100% meassured on target contract\\n        # * No more coverage was gained in the last transaction\\n        # * At least 2 different properties where found to be breakable. (1 for fail fast)\\n        # * 240 seconds pass\\n        # Starting exploration...\\n        Transactions done: 0. States: 1, RT Coverage: 0.0%, Failing properties: 0/2\\n        Transactions done: 1. States: 2, RT Coverage: 55.43%, Failing properties: 0/2\\n        Transactions done: 2. States: 8, RT Coverage: 80.48%, Failing properties: 1/2\\n        Transactions done: 3. States: 30, RT Coverage: 80.48%, Failing properties: 1/2\\n        No coverage progress. Stopping exploration.\\n        Coverage obtained 80.48%. (RT + prop)\\n        +-------------------------+------------+\\n        |      Property Named     |   Status   |\\n        +-------------------------+------------+\\n        |   crytic_test_balance   | failed (0) |\\n        | crytic_test_must_revert |   passed   |\\n        +-------------------------+------------+\\n        Checkout testcases here:./mcore_6jdil7nh\\n\\n    :param maxfail: stop after maxfail properties are failing. All if None\\n    :param maxcov: Stop after maxcov % coverage is obtained in the main contract\\n    :param maxt: Max transaction count to explore\\n    :param deployer: (optional) address of account used to deploy the contract\\n    :param senders: (optional) a list of calles addresses for the exploration\\n    :param psender: (optional) address from where the property is tested\\n    :param source_code: A filename or source code\\n    :param contract_name: The target contract name defined in the source code\\n    :param propre: A regular expression for selecting properties\\n    :param outputspace_url: where to put the extended result\\n    :param timeout: timeout in seconds\\n    :return:\\n    '\n    MAXTX = maxt\n    MAXCOV = maxcov\n    MAXFAIL = maxfail\n    config.get_group('smt').timeout = 120\n    config.get_group('smt').memory = 16384\n    config.get_group('evm').ignore_balance = True\n    config.get_group('evm').oog = 'ignore'\n    print('# Welcome to manticore-verifier')\n    m = ManticoreEVM()\n    filter_out_human_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n    m.register_plugin(filter_out_human_constants)\n    filter_out_human_constants.disable()\n    filter_no_crytic = FilterFunctions(regexp=propre, include=False)\n    m.register_plugin(filter_no_crytic)\n    filter_no_crytic.disable()\n    filter_only_crytic = FilterFunctions(regexp=propre, depth='human', fallback=False, include=True)\n    m.register_plugin(filter_only_crytic)\n    filter_only_crytic.disable()\n    senders = (None,) if senders is None else senders\n    user_accounts = []\n    for (n, address_i) in enumerate(senders):\n        user_accounts.append(m.create_account(balance=10 ** 10, address=address_i, name=f'sender_{n}'))\n    owner_account = m.create_account(balance=10 ** 10, address=deployer, name='deployer')\n    contract_account = m.solidity_create_contract(source_code, owner=owner_account, contract_name=contract_name, compile_args=compile_args, name='contract_account')\n    checker_account = m.create_account(balance=10 ** 10, address=psender, name='psender')\n    print(f'# Owner account: 0x{int(owner_account):x}')\n    print(f'# Contract account: 0x{int(contract_account):x}')\n    for (n, user_account) in enumerate(user_accounts):\n        print(f'# Sender_{n} account: 0x{int(user_account):x}')\n    print(f'# PSender account: 0x{int(checker_account):x}')\n    properties = {}\n    md = m.get_metadata(contract_account)\n    for func_hsh in md.function_selectors:\n        func_name = md.get_abi(func_hsh)['name']\n        if re.match(propre, func_name):\n            properties[func_name] = []\n    print(f\"# Found {len(properties)} properties: {', '.join(properties.keys())}\")\n    if not properties:\n        print('I am sorry I had to run the init bytecode for this.\\nGood Bye.')\n        return\n    MAXFAIL = len(properties) if MAXFAIL is None else MAXFAIL\n    tx_num = 0\n    current_coverage = None\n    new_coverage = 0.0\n    print(f'# Exploration will stop when some of the following happens:\\n# * {MAXTX} human transaction sent\\n# * Code coverage is greater than {MAXCOV}% meassured on target contract\\n# * No more coverage was gained in the last transaction\\n# * At least {MAXFAIL} different properties where found to be breakable. (1 for fail fast)\\n# * {timeout} seconds pass')\n    print('# Starting exploration...')\n    print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {0.0}%, Failing properties: 0/{len(properties)}')\n    with m.kill_timeout(timeout=timeout):\n        while not m.is_killed():\n            broken_properties = sum((int(len(x) != 0) for x in properties.values()))\n            if broken_properties >= MAXFAIL:\n                print(f'Found {broken_properties}/{len(properties)} failing properties. Stopping exploration.')\n                break\n            if tx_num >= MAXTX:\n                print(f'Max number of transactions reached ({tx_num})')\n                break\n            tx_num += 1\n            new_coverage = m.global_coverage(contract_account)\n            if new_coverage >= MAXCOV:\n                print(f'Current coverage({new_coverage}%) is greater than max allowed ({MAXCOV}%). Stopping exploration.')\n                break\n            if current_coverage == new_coverage:\n                print(f'No coverage progress. Stopping exploration.')\n                break\n            current_coverage = new_coverage\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.enable()\n            filter_out_human_constants.enable()\n            filter_only_crytic.disable()\n            symbolic_data = m.make_symbolic_buffer(320)\n            symbolic_value = m.make_symbolic_value()\n            caller_account = m.make_symbolic_value(160)\n            args = tuple((caller_account == address_i for address_i in user_accounts))\n            m.constrain(OR(*args, False))\n            m.transaction(caller=caller_account, address=contract_account, value=symbolic_value, data=symbolic_data)\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            m.clear_terminated_states()\n            m.take_snapshot()\n            print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {m.global_coverage(contract_account):3.2f}%, Failing properties: {broken_properties}/{len(properties)}')\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.disable()\n            filter_out_human_constants.disable()\n            filter_only_crytic.enable()\n            symbolic_data = m.make_symbolic_buffer(4)\n            m.transaction(caller=checker_account, address=contract_account, value=0, data=symbolic_data)\n            for state in m.all_states:\n                world = state.platform\n                tx = world.human_transactions[-1]\n                md = m.get_metadata(tx.address)\n                \"\\n                A is _broken_ if:\\n                     * is normal property\\n                     * RETURN False\\n                   OR:\\n                     * property name ends with 'revert'\\n                     * does not REVERT\\n                Property is considered to _pass_ otherwise\\n                \"\n                N = constrain_to_known_func_ids(state)\n                for func_id in map(bytes, state.solve_n(tx.data[:4], nsolves=N)):\n                    func_name = md.get_abi(func_id)['name']\n                    if not func_name.endswith('revert'):\n                        if tx.return_value == 1:\n                            return_data = ABI.deserialize('bool', tx.return_data)\n                            testcase = m.generate_testcase(state, f'property {md.get_func_name(func_id)} is broken', only_if=AND(tx.data[:4] == func_id, return_data == 0))\n                            if testcase:\n                                properties[func_name].append(testcase.num)\n                    elif tx.result != 'REVERT':\n                        testcase = m.generate_testcase(state, f'Some property is broken did not reverted.(MUST REVERTED)', only_if=tx.data[:4] == func_id)\n                        if testcase:\n                            properties[func_name].append(testcase.num)\n            m.clear_terminated_states()\n            m.goto_snapshot()\n        else:\n            print('Cancelled or timeout.')\n    m.clear_terminated_states()\n    m.clear_ready_states()\n    m.clear_snapshot()\n    if m.is_killed():\n        print('Exploration ended by CTRL+C or timeout')\n    print(f'Coverage obtained {new_coverage:3.2f}%. (RT + prop)')\n    x = PrettyTable()\n    x.field_names = ['Property Named', 'Status']\n    for (name, testcases) in sorted(properties.items()):\n        result = 'passed'\n        if testcases:\n            result = f'failed ({testcases[0]})'\n        x.add_row((name, result))\n    print(x)\n    m.clear_ready_states()\n    workspace = os.path.abspath(m.workspace)[len(os.getcwd()) + 1:]\n    print(f'Checkout testcases here:./{workspace}')",
            "def manticore_verifier(source_code, contract_name, maxfail=None, maxt=3, maxcov=100, deployer=None, senders=None, psender=None, propre='crytic_.*', compile_args=None, outputspace_url=None, timeout=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Verify solidity properties\\n    The results are dumped to stdout and to the workspace folder.\\n\\n        $manticore-verifier property.sol  --contract TestToken --smt.solver yices --maxt 4\\n        # Owner account: 0xf3c67ffb8ab4cdd4d3243ad247d0641cd24af939\\n        # Contract account: 0x6f4b51ac2eb017600e9263085cfa06f831132c72\\n        # Sender_0 account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # PSender account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # Found 2 properties: crytic_test_must_revert, crytic_test_balance\\n        # Exploration will stop when some of the following happens:\\n        # * 4 human transaction sent\\n        # * Code coverage is greater than 100% meassured on target contract\\n        # * No more coverage was gained in the last transaction\\n        # * At least 2 different properties where found to be breakable. (1 for fail fast)\\n        # * 240 seconds pass\\n        # Starting exploration...\\n        Transactions done: 0. States: 1, RT Coverage: 0.0%, Failing properties: 0/2\\n        Transactions done: 1. States: 2, RT Coverage: 55.43%, Failing properties: 0/2\\n        Transactions done: 2. States: 8, RT Coverage: 80.48%, Failing properties: 1/2\\n        Transactions done: 3. States: 30, RT Coverage: 80.48%, Failing properties: 1/2\\n        No coverage progress. Stopping exploration.\\n        Coverage obtained 80.48%. (RT + prop)\\n        +-------------------------+------------+\\n        |      Property Named     |   Status   |\\n        +-------------------------+------------+\\n        |   crytic_test_balance   | failed (0) |\\n        | crytic_test_must_revert |   passed   |\\n        +-------------------------+------------+\\n        Checkout testcases here:./mcore_6jdil7nh\\n\\n    :param maxfail: stop after maxfail properties are failing. All if None\\n    :param maxcov: Stop after maxcov % coverage is obtained in the main contract\\n    :param maxt: Max transaction count to explore\\n    :param deployer: (optional) address of account used to deploy the contract\\n    :param senders: (optional) a list of calles addresses for the exploration\\n    :param psender: (optional) address from where the property is tested\\n    :param source_code: A filename or source code\\n    :param contract_name: The target contract name defined in the source code\\n    :param propre: A regular expression for selecting properties\\n    :param outputspace_url: where to put the extended result\\n    :param timeout: timeout in seconds\\n    :return:\\n    '\n    MAXTX = maxt\n    MAXCOV = maxcov\n    MAXFAIL = maxfail\n    config.get_group('smt').timeout = 120\n    config.get_group('smt').memory = 16384\n    config.get_group('evm').ignore_balance = True\n    config.get_group('evm').oog = 'ignore'\n    print('# Welcome to manticore-verifier')\n    m = ManticoreEVM()\n    filter_out_human_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n    m.register_plugin(filter_out_human_constants)\n    filter_out_human_constants.disable()\n    filter_no_crytic = FilterFunctions(regexp=propre, include=False)\n    m.register_plugin(filter_no_crytic)\n    filter_no_crytic.disable()\n    filter_only_crytic = FilterFunctions(regexp=propre, depth='human', fallback=False, include=True)\n    m.register_plugin(filter_only_crytic)\n    filter_only_crytic.disable()\n    senders = (None,) if senders is None else senders\n    user_accounts = []\n    for (n, address_i) in enumerate(senders):\n        user_accounts.append(m.create_account(balance=10 ** 10, address=address_i, name=f'sender_{n}'))\n    owner_account = m.create_account(balance=10 ** 10, address=deployer, name='deployer')\n    contract_account = m.solidity_create_contract(source_code, owner=owner_account, contract_name=contract_name, compile_args=compile_args, name='contract_account')\n    checker_account = m.create_account(balance=10 ** 10, address=psender, name='psender')\n    print(f'# Owner account: 0x{int(owner_account):x}')\n    print(f'# Contract account: 0x{int(contract_account):x}')\n    for (n, user_account) in enumerate(user_accounts):\n        print(f'# Sender_{n} account: 0x{int(user_account):x}')\n    print(f'# PSender account: 0x{int(checker_account):x}')\n    properties = {}\n    md = m.get_metadata(contract_account)\n    for func_hsh in md.function_selectors:\n        func_name = md.get_abi(func_hsh)['name']\n        if re.match(propre, func_name):\n            properties[func_name] = []\n    print(f\"# Found {len(properties)} properties: {', '.join(properties.keys())}\")\n    if not properties:\n        print('I am sorry I had to run the init bytecode for this.\\nGood Bye.')\n        return\n    MAXFAIL = len(properties) if MAXFAIL is None else MAXFAIL\n    tx_num = 0\n    current_coverage = None\n    new_coverage = 0.0\n    print(f'# Exploration will stop when some of the following happens:\\n# * {MAXTX} human transaction sent\\n# * Code coverage is greater than {MAXCOV}% meassured on target contract\\n# * No more coverage was gained in the last transaction\\n# * At least {MAXFAIL} different properties where found to be breakable. (1 for fail fast)\\n# * {timeout} seconds pass')\n    print('# Starting exploration...')\n    print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {0.0}%, Failing properties: 0/{len(properties)}')\n    with m.kill_timeout(timeout=timeout):\n        while not m.is_killed():\n            broken_properties = sum((int(len(x) != 0) for x in properties.values()))\n            if broken_properties >= MAXFAIL:\n                print(f'Found {broken_properties}/{len(properties)} failing properties. Stopping exploration.')\n                break\n            if tx_num >= MAXTX:\n                print(f'Max number of transactions reached ({tx_num})')\n                break\n            tx_num += 1\n            new_coverage = m.global_coverage(contract_account)\n            if new_coverage >= MAXCOV:\n                print(f'Current coverage({new_coverage}%) is greater than max allowed ({MAXCOV}%). Stopping exploration.')\n                break\n            if current_coverage == new_coverage:\n                print(f'No coverage progress. Stopping exploration.')\n                break\n            current_coverage = new_coverage\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.enable()\n            filter_out_human_constants.enable()\n            filter_only_crytic.disable()\n            symbolic_data = m.make_symbolic_buffer(320)\n            symbolic_value = m.make_symbolic_value()\n            caller_account = m.make_symbolic_value(160)\n            args = tuple((caller_account == address_i for address_i in user_accounts))\n            m.constrain(OR(*args, False))\n            m.transaction(caller=caller_account, address=contract_account, value=symbolic_value, data=symbolic_data)\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            m.clear_terminated_states()\n            m.take_snapshot()\n            print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {m.global_coverage(contract_account):3.2f}%, Failing properties: {broken_properties}/{len(properties)}')\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.disable()\n            filter_out_human_constants.disable()\n            filter_only_crytic.enable()\n            symbolic_data = m.make_symbolic_buffer(4)\n            m.transaction(caller=checker_account, address=contract_account, value=0, data=symbolic_data)\n            for state in m.all_states:\n                world = state.platform\n                tx = world.human_transactions[-1]\n                md = m.get_metadata(tx.address)\n                \"\\n                A is _broken_ if:\\n                     * is normal property\\n                     * RETURN False\\n                   OR:\\n                     * property name ends with 'revert'\\n                     * does not REVERT\\n                Property is considered to _pass_ otherwise\\n                \"\n                N = constrain_to_known_func_ids(state)\n                for func_id in map(bytes, state.solve_n(tx.data[:4], nsolves=N)):\n                    func_name = md.get_abi(func_id)['name']\n                    if not func_name.endswith('revert'):\n                        if tx.return_value == 1:\n                            return_data = ABI.deserialize('bool', tx.return_data)\n                            testcase = m.generate_testcase(state, f'property {md.get_func_name(func_id)} is broken', only_if=AND(tx.data[:4] == func_id, return_data == 0))\n                            if testcase:\n                                properties[func_name].append(testcase.num)\n                    elif tx.result != 'REVERT':\n                        testcase = m.generate_testcase(state, f'Some property is broken did not reverted.(MUST REVERTED)', only_if=tx.data[:4] == func_id)\n                        if testcase:\n                            properties[func_name].append(testcase.num)\n            m.clear_terminated_states()\n            m.goto_snapshot()\n        else:\n            print('Cancelled or timeout.')\n    m.clear_terminated_states()\n    m.clear_ready_states()\n    m.clear_snapshot()\n    if m.is_killed():\n        print('Exploration ended by CTRL+C or timeout')\n    print(f'Coverage obtained {new_coverage:3.2f}%. (RT + prop)')\n    x = PrettyTable()\n    x.field_names = ['Property Named', 'Status']\n    for (name, testcases) in sorted(properties.items()):\n        result = 'passed'\n        if testcases:\n            result = f'failed ({testcases[0]})'\n        x.add_row((name, result))\n    print(x)\n    m.clear_ready_states()\n    workspace = os.path.abspath(m.workspace)[len(os.getcwd()) + 1:]\n    print(f'Checkout testcases here:./{workspace}')",
            "def manticore_verifier(source_code, contract_name, maxfail=None, maxt=3, maxcov=100, deployer=None, senders=None, psender=None, propre='crytic_.*', compile_args=None, outputspace_url=None, timeout=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Verify solidity properties\\n    The results are dumped to stdout and to the workspace folder.\\n\\n        $manticore-verifier property.sol  --contract TestToken --smt.solver yices --maxt 4\\n        # Owner account: 0xf3c67ffb8ab4cdd4d3243ad247d0641cd24af939\\n        # Contract account: 0x6f4b51ac2eb017600e9263085cfa06f831132c72\\n        # Sender_0 account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # PSender account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # Found 2 properties: crytic_test_must_revert, crytic_test_balance\\n        # Exploration will stop when some of the following happens:\\n        # * 4 human transaction sent\\n        # * Code coverage is greater than 100% meassured on target contract\\n        # * No more coverage was gained in the last transaction\\n        # * At least 2 different properties where found to be breakable. (1 for fail fast)\\n        # * 240 seconds pass\\n        # Starting exploration...\\n        Transactions done: 0. States: 1, RT Coverage: 0.0%, Failing properties: 0/2\\n        Transactions done: 1. States: 2, RT Coverage: 55.43%, Failing properties: 0/2\\n        Transactions done: 2. States: 8, RT Coverage: 80.48%, Failing properties: 1/2\\n        Transactions done: 3. States: 30, RT Coverage: 80.48%, Failing properties: 1/2\\n        No coverage progress. Stopping exploration.\\n        Coverage obtained 80.48%. (RT + prop)\\n        +-------------------------+------------+\\n        |      Property Named     |   Status   |\\n        +-------------------------+------------+\\n        |   crytic_test_balance   | failed (0) |\\n        | crytic_test_must_revert |   passed   |\\n        +-------------------------+------------+\\n        Checkout testcases here:./mcore_6jdil7nh\\n\\n    :param maxfail: stop after maxfail properties are failing. All if None\\n    :param maxcov: Stop after maxcov % coverage is obtained in the main contract\\n    :param maxt: Max transaction count to explore\\n    :param deployer: (optional) address of account used to deploy the contract\\n    :param senders: (optional) a list of calles addresses for the exploration\\n    :param psender: (optional) address from where the property is tested\\n    :param source_code: A filename or source code\\n    :param contract_name: The target contract name defined in the source code\\n    :param propre: A regular expression for selecting properties\\n    :param outputspace_url: where to put the extended result\\n    :param timeout: timeout in seconds\\n    :return:\\n    '\n    MAXTX = maxt\n    MAXCOV = maxcov\n    MAXFAIL = maxfail\n    config.get_group('smt').timeout = 120\n    config.get_group('smt').memory = 16384\n    config.get_group('evm').ignore_balance = True\n    config.get_group('evm').oog = 'ignore'\n    print('# Welcome to manticore-verifier')\n    m = ManticoreEVM()\n    filter_out_human_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n    m.register_plugin(filter_out_human_constants)\n    filter_out_human_constants.disable()\n    filter_no_crytic = FilterFunctions(regexp=propre, include=False)\n    m.register_plugin(filter_no_crytic)\n    filter_no_crytic.disable()\n    filter_only_crytic = FilterFunctions(regexp=propre, depth='human', fallback=False, include=True)\n    m.register_plugin(filter_only_crytic)\n    filter_only_crytic.disable()\n    senders = (None,) if senders is None else senders\n    user_accounts = []\n    for (n, address_i) in enumerate(senders):\n        user_accounts.append(m.create_account(balance=10 ** 10, address=address_i, name=f'sender_{n}'))\n    owner_account = m.create_account(balance=10 ** 10, address=deployer, name='deployer')\n    contract_account = m.solidity_create_contract(source_code, owner=owner_account, contract_name=contract_name, compile_args=compile_args, name='contract_account')\n    checker_account = m.create_account(balance=10 ** 10, address=psender, name='psender')\n    print(f'# Owner account: 0x{int(owner_account):x}')\n    print(f'# Contract account: 0x{int(contract_account):x}')\n    for (n, user_account) in enumerate(user_accounts):\n        print(f'# Sender_{n} account: 0x{int(user_account):x}')\n    print(f'# PSender account: 0x{int(checker_account):x}')\n    properties = {}\n    md = m.get_metadata(contract_account)\n    for func_hsh in md.function_selectors:\n        func_name = md.get_abi(func_hsh)['name']\n        if re.match(propre, func_name):\n            properties[func_name] = []\n    print(f\"# Found {len(properties)} properties: {', '.join(properties.keys())}\")\n    if not properties:\n        print('I am sorry I had to run the init bytecode for this.\\nGood Bye.')\n        return\n    MAXFAIL = len(properties) if MAXFAIL is None else MAXFAIL\n    tx_num = 0\n    current_coverage = None\n    new_coverage = 0.0\n    print(f'# Exploration will stop when some of the following happens:\\n# * {MAXTX} human transaction sent\\n# * Code coverage is greater than {MAXCOV}% meassured on target contract\\n# * No more coverage was gained in the last transaction\\n# * At least {MAXFAIL} different properties where found to be breakable. (1 for fail fast)\\n# * {timeout} seconds pass')\n    print('# Starting exploration...')\n    print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {0.0}%, Failing properties: 0/{len(properties)}')\n    with m.kill_timeout(timeout=timeout):\n        while not m.is_killed():\n            broken_properties = sum((int(len(x) != 0) for x in properties.values()))\n            if broken_properties >= MAXFAIL:\n                print(f'Found {broken_properties}/{len(properties)} failing properties. Stopping exploration.')\n                break\n            if tx_num >= MAXTX:\n                print(f'Max number of transactions reached ({tx_num})')\n                break\n            tx_num += 1\n            new_coverage = m.global_coverage(contract_account)\n            if new_coverage >= MAXCOV:\n                print(f'Current coverage({new_coverage}%) is greater than max allowed ({MAXCOV}%). Stopping exploration.')\n                break\n            if current_coverage == new_coverage:\n                print(f'No coverage progress. Stopping exploration.')\n                break\n            current_coverage = new_coverage\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.enable()\n            filter_out_human_constants.enable()\n            filter_only_crytic.disable()\n            symbolic_data = m.make_symbolic_buffer(320)\n            symbolic_value = m.make_symbolic_value()\n            caller_account = m.make_symbolic_value(160)\n            args = tuple((caller_account == address_i for address_i in user_accounts))\n            m.constrain(OR(*args, False))\n            m.transaction(caller=caller_account, address=contract_account, value=symbolic_value, data=symbolic_data)\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            m.clear_terminated_states()\n            m.take_snapshot()\n            print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {m.global_coverage(contract_account):3.2f}%, Failing properties: {broken_properties}/{len(properties)}')\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.disable()\n            filter_out_human_constants.disable()\n            filter_only_crytic.enable()\n            symbolic_data = m.make_symbolic_buffer(4)\n            m.transaction(caller=checker_account, address=contract_account, value=0, data=symbolic_data)\n            for state in m.all_states:\n                world = state.platform\n                tx = world.human_transactions[-1]\n                md = m.get_metadata(tx.address)\n                \"\\n                A is _broken_ if:\\n                     * is normal property\\n                     * RETURN False\\n                   OR:\\n                     * property name ends with 'revert'\\n                     * does not REVERT\\n                Property is considered to _pass_ otherwise\\n                \"\n                N = constrain_to_known_func_ids(state)\n                for func_id in map(bytes, state.solve_n(tx.data[:4], nsolves=N)):\n                    func_name = md.get_abi(func_id)['name']\n                    if not func_name.endswith('revert'):\n                        if tx.return_value == 1:\n                            return_data = ABI.deserialize('bool', tx.return_data)\n                            testcase = m.generate_testcase(state, f'property {md.get_func_name(func_id)} is broken', only_if=AND(tx.data[:4] == func_id, return_data == 0))\n                            if testcase:\n                                properties[func_name].append(testcase.num)\n                    elif tx.result != 'REVERT':\n                        testcase = m.generate_testcase(state, f'Some property is broken did not reverted.(MUST REVERTED)', only_if=tx.data[:4] == func_id)\n                        if testcase:\n                            properties[func_name].append(testcase.num)\n            m.clear_terminated_states()\n            m.goto_snapshot()\n        else:\n            print('Cancelled or timeout.')\n    m.clear_terminated_states()\n    m.clear_ready_states()\n    m.clear_snapshot()\n    if m.is_killed():\n        print('Exploration ended by CTRL+C or timeout')\n    print(f'Coverage obtained {new_coverage:3.2f}%. (RT + prop)')\n    x = PrettyTable()\n    x.field_names = ['Property Named', 'Status']\n    for (name, testcases) in sorted(properties.items()):\n        result = 'passed'\n        if testcases:\n            result = f'failed ({testcases[0]})'\n        x.add_row((name, result))\n    print(x)\n    m.clear_ready_states()\n    workspace = os.path.abspath(m.workspace)[len(os.getcwd()) + 1:]\n    print(f'Checkout testcases here:./{workspace}')",
            "def manticore_verifier(source_code, contract_name, maxfail=None, maxt=3, maxcov=100, deployer=None, senders=None, psender=None, propre='crytic_.*', compile_args=None, outputspace_url=None, timeout=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Verify solidity properties\\n    The results are dumped to stdout and to the workspace folder.\\n\\n        $manticore-verifier property.sol  --contract TestToken --smt.solver yices --maxt 4\\n        # Owner account: 0xf3c67ffb8ab4cdd4d3243ad247d0641cd24af939\\n        # Contract account: 0x6f4b51ac2eb017600e9263085cfa06f831132c72\\n        # Sender_0 account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # PSender account: 0x97528a0c7c6592772231fd581e5b42125c1a2ff4\\n        # Found 2 properties: crytic_test_must_revert, crytic_test_balance\\n        # Exploration will stop when some of the following happens:\\n        # * 4 human transaction sent\\n        # * Code coverage is greater than 100% meassured on target contract\\n        # * No more coverage was gained in the last transaction\\n        # * At least 2 different properties where found to be breakable. (1 for fail fast)\\n        # * 240 seconds pass\\n        # Starting exploration...\\n        Transactions done: 0. States: 1, RT Coverage: 0.0%, Failing properties: 0/2\\n        Transactions done: 1. States: 2, RT Coverage: 55.43%, Failing properties: 0/2\\n        Transactions done: 2. States: 8, RT Coverage: 80.48%, Failing properties: 1/2\\n        Transactions done: 3. States: 30, RT Coverage: 80.48%, Failing properties: 1/2\\n        No coverage progress. Stopping exploration.\\n        Coverage obtained 80.48%. (RT + prop)\\n        +-------------------------+------------+\\n        |      Property Named     |   Status   |\\n        +-------------------------+------------+\\n        |   crytic_test_balance   | failed (0) |\\n        | crytic_test_must_revert |   passed   |\\n        +-------------------------+------------+\\n        Checkout testcases here:./mcore_6jdil7nh\\n\\n    :param maxfail: stop after maxfail properties are failing. All if None\\n    :param maxcov: Stop after maxcov % coverage is obtained in the main contract\\n    :param maxt: Max transaction count to explore\\n    :param deployer: (optional) address of account used to deploy the contract\\n    :param senders: (optional) a list of calles addresses for the exploration\\n    :param psender: (optional) address from where the property is tested\\n    :param source_code: A filename or source code\\n    :param contract_name: The target contract name defined in the source code\\n    :param propre: A regular expression for selecting properties\\n    :param outputspace_url: where to put the extended result\\n    :param timeout: timeout in seconds\\n    :return:\\n    '\n    MAXTX = maxt\n    MAXCOV = maxcov\n    MAXFAIL = maxfail\n    config.get_group('smt').timeout = 120\n    config.get_group('smt').memory = 16384\n    config.get_group('evm').ignore_balance = True\n    config.get_group('evm').oog = 'ignore'\n    print('# Welcome to manticore-verifier')\n    m = ManticoreEVM()\n    filter_out_human_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n    m.register_plugin(filter_out_human_constants)\n    filter_out_human_constants.disable()\n    filter_no_crytic = FilterFunctions(regexp=propre, include=False)\n    m.register_plugin(filter_no_crytic)\n    filter_no_crytic.disable()\n    filter_only_crytic = FilterFunctions(regexp=propre, depth='human', fallback=False, include=True)\n    m.register_plugin(filter_only_crytic)\n    filter_only_crytic.disable()\n    senders = (None,) if senders is None else senders\n    user_accounts = []\n    for (n, address_i) in enumerate(senders):\n        user_accounts.append(m.create_account(balance=10 ** 10, address=address_i, name=f'sender_{n}'))\n    owner_account = m.create_account(balance=10 ** 10, address=deployer, name='deployer')\n    contract_account = m.solidity_create_contract(source_code, owner=owner_account, contract_name=contract_name, compile_args=compile_args, name='contract_account')\n    checker_account = m.create_account(balance=10 ** 10, address=psender, name='psender')\n    print(f'# Owner account: 0x{int(owner_account):x}')\n    print(f'# Contract account: 0x{int(contract_account):x}')\n    for (n, user_account) in enumerate(user_accounts):\n        print(f'# Sender_{n} account: 0x{int(user_account):x}')\n    print(f'# PSender account: 0x{int(checker_account):x}')\n    properties = {}\n    md = m.get_metadata(contract_account)\n    for func_hsh in md.function_selectors:\n        func_name = md.get_abi(func_hsh)['name']\n        if re.match(propre, func_name):\n            properties[func_name] = []\n    print(f\"# Found {len(properties)} properties: {', '.join(properties.keys())}\")\n    if not properties:\n        print('I am sorry I had to run the init bytecode for this.\\nGood Bye.')\n        return\n    MAXFAIL = len(properties) if MAXFAIL is None else MAXFAIL\n    tx_num = 0\n    current_coverage = None\n    new_coverage = 0.0\n    print(f'# Exploration will stop when some of the following happens:\\n# * {MAXTX} human transaction sent\\n# * Code coverage is greater than {MAXCOV}% meassured on target contract\\n# * No more coverage was gained in the last transaction\\n# * At least {MAXFAIL} different properties where found to be breakable. (1 for fail fast)\\n# * {timeout} seconds pass')\n    print('# Starting exploration...')\n    print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {0.0}%, Failing properties: 0/{len(properties)}')\n    with m.kill_timeout(timeout=timeout):\n        while not m.is_killed():\n            broken_properties = sum((int(len(x) != 0) for x in properties.values()))\n            if broken_properties >= MAXFAIL:\n                print(f'Found {broken_properties}/{len(properties)} failing properties. Stopping exploration.')\n                break\n            if tx_num >= MAXTX:\n                print(f'Max number of transactions reached ({tx_num})')\n                break\n            tx_num += 1\n            new_coverage = m.global_coverage(contract_account)\n            if new_coverage >= MAXCOV:\n                print(f'Current coverage({new_coverage}%) is greater than max allowed ({MAXCOV}%). Stopping exploration.')\n                break\n            if current_coverage == new_coverage:\n                print(f'No coverage progress. Stopping exploration.')\n                break\n            current_coverage = new_coverage\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.enable()\n            filter_out_human_constants.enable()\n            filter_only_crytic.disable()\n            symbolic_data = m.make_symbolic_buffer(320)\n            symbolic_value = m.make_symbolic_value()\n            caller_account = m.make_symbolic_value(160)\n            args = tuple((caller_account == address_i for address_i in user_accounts))\n            m.constrain(OR(*args, False))\n            m.transaction(caller=caller_account, address=contract_account, value=symbolic_value, data=symbolic_data)\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            m.clear_terminated_states()\n            m.take_snapshot()\n            print(f'Transactions done: {tx_num}. States: {m.count_ready_states()}, RT Coverage: {m.global_coverage(contract_account):3.2f}%, Failing properties: {broken_properties}/{len(properties)}')\n            if m.is_killed():\n                print('Cancelled or timeout.')\n                break\n            filter_no_crytic.disable()\n            filter_out_human_constants.disable()\n            filter_only_crytic.enable()\n            symbolic_data = m.make_symbolic_buffer(4)\n            m.transaction(caller=checker_account, address=contract_account, value=0, data=symbolic_data)\n            for state in m.all_states:\n                world = state.platform\n                tx = world.human_transactions[-1]\n                md = m.get_metadata(tx.address)\n                \"\\n                A is _broken_ if:\\n                     * is normal property\\n                     * RETURN False\\n                   OR:\\n                     * property name ends with 'revert'\\n                     * does not REVERT\\n                Property is considered to _pass_ otherwise\\n                \"\n                N = constrain_to_known_func_ids(state)\n                for func_id in map(bytes, state.solve_n(tx.data[:4], nsolves=N)):\n                    func_name = md.get_abi(func_id)['name']\n                    if not func_name.endswith('revert'):\n                        if tx.return_value == 1:\n                            return_data = ABI.deserialize('bool', tx.return_data)\n                            testcase = m.generate_testcase(state, f'property {md.get_func_name(func_id)} is broken', only_if=AND(tx.data[:4] == func_id, return_data == 0))\n                            if testcase:\n                                properties[func_name].append(testcase.num)\n                    elif tx.result != 'REVERT':\n                        testcase = m.generate_testcase(state, f'Some property is broken did not reverted.(MUST REVERTED)', only_if=tx.data[:4] == func_id)\n                        if testcase:\n                            properties[func_name].append(testcase.num)\n            m.clear_terminated_states()\n            m.goto_snapshot()\n        else:\n            print('Cancelled or timeout.')\n    m.clear_terminated_states()\n    m.clear_ready_states()\n    m.clear_snapshot()\n    if m.is_killed():\n        print('Exploration ended by CTRL+C or timeout')\n    print(f'Coverage obtained {new_coverage:3.2f}%. (RT + prop)')\n    x = PrettyTable()\n    x.field_names = ['Property Named', 'Status']\n    for (name, testcases) in sorted(properties.items()):\n        result = 'passed'\n        if testcases:\n            result = f'failed ({testcases[0]})'\n        x.add_row((name, result))\n    print(x)\n    m.clear_ready_states()\n    workspace = os.path.abspath(m.workspace)[len(os.getcwd()) + 1:]\n    print(f'Checkout testcases here:./{workspace}')"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    from crytic_compile import is_supported, cryticparser\n    parser = argparse.ArgumentParser(description='Solidity property verifier', prog='manticore_verifier')\n    cryticparser.init(parser)\n    parser.add_argument('source_code', type=str, nargs='*', default=[], help='Contract source code')\n    parser.add_argument('-v', action='count', default=0, help='Specify verbosity level from -v to -vvvv')\n    parser.add_argument('--workspace', type=str, default=None, help='A folder name for temporaries and results.(default mcore_?????)')\n    current_version = pkg_resources.get_distribution('manticore').version\n    parser.add_argument('--version', action='version', version=f'Manticore {current_version}', help='Show program version information')\n    parser.add_argument('--propconfig', type=str, help='Solidity property accounts config file (.yml)')\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    eth_flags.add_argument('--contract_name', type=str, help='The target contract name defined in the source code')\n    eth_flags.add_argument('--maxfail', type=int, help='stop after maxfail properties are failing. All if None')\n    eth_flags.add_argument('--maxcov', type=int, default=100, help=' Stop after maxcov %% coverage is obtained in the main contract')\n    eth_flags.add_argument('--maxt', type=int, default=3, help='Max transaction count to explore')\n    eth_flags.add_argument('--deployer', type=str, help='(optional) address of account used to deploy the contract')\n    eth_flags.add_argument('--senders', type=str, help='(optional) a comma separated list of sender addresses. The properties are going to be tested sending transactions from these addresses.')\n    eth_flags.add_argument('--psender', type=str, help='(optional) address from where the property is tested')\n    eth_flags.add_argument('--propre', default='crytic_.*', type=str, help='A regular expression for selecting properties')\n    eth_flags.add_argument('--timeout', default=240, type=int, help='Exploration timeout in seconds')\n    eth_flags.add_argument('--outputspace_url', type=str, help='where to put the extended result')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    parsed = parser.parse_args(sys.argv[1:])\n    config.process_config_values(parser, parsed)\n    if not parsed.source_code:\n        print(parser.format_usage() + 'error: You need to provide a contract source code.')\n        sys.exit(1)\n    args = parsed\n    set_verbosity(args.v)\n    logger = logging.getLogger('manticore.main')\n    deployer = None\n    senders = None\n    psenders = None\n    if args.propconfig:\n        '\\n        deployer: \"0x41414141414141414141\"  #who deploys the contract\\n        sender: [\"0x51515151515151515151\", \"0x52525252525252525252\"] #who calls the transactions (potentially can be multiple users)\\n        psender: \"0x616161616161616161\" #who calls the property\\n        '\n        import yaml\n        with open(args.propconfig) as f:\n            c = yaml.safe_load(f)\n            deployer = c.get('deployer')\n            if deployer is not None:\n                deployer = int(deployer, 0)\n            senders = c.get('sender')\n            if senders is not None:\n                senders = [int(sender, 0) for sender in senders]\n            psender = c.get('psender')\n            if psender is not None:\n                psender = int(psender, 0)\n    deployer = None\n    if args.deployer is not None:\n        deployer = int(args.deployer, 0)\n    senders = None\n    if args.senders is not None:\n        senders = [int(sender, 0) for sender in args.senders.split(',')]\n    psender = None\n    if args.psender is not None:\n        psender = int(args.psender, 0)\n    source_code = args.source_code[0]\n    contract_name = args.contract_name\n    maxfail = args.maxfail\n    maxt = args.maxt\n    maxcov = args.maxcov\n    return manticore_verifier(source_code, contract_name, maxfail=maxfail, maxt=maxt, maxcov=100, senders=senders, deployer=deployer, psender=psender, timeout=args.timeout, propre=args.propre, compile_args=vars(parsed))",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    from crytic_compile import is_supported, cryticparser\n    parser = argparse.ArgumentParser(description='Solidity property verifier', prog='manticore_verifier')\n    cryticparser.init(parser)\n    parser.add_argument('source_code', type=str, nargs='*', default=[], help='Contract source code')\n    parser.add_argument('-v', action='count', default=0, help='Specify verbosity level from -v to -vvvv')\n    parser.add_argument('--workspace', type=str, default=None, help='A folder name for temporaries and results.(default mcore_?????)')\n    current_version = pkg_resources.get_distribution('manticore').version\n    parser.add_argument('--version', action='version', version=f'Manticore {current_version}', help='Show program version information')\n    parser.add_argument('--propconfig', type=str, help='Solidity property accounts config file (.yml)')\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    eth_flags.add_argument('--contract_name', type=str, help='The target contract name defined in the source code')\n    eth_flags.add_argument('--maxfail', type=int, help='stop after maxfail properties are failing. All if None')\n    eth_flags.add_argument('--maxcov', type=int, default=100, help=' Stop after maxcov %% coverage is obtained in the main contract')\n    eth_flags.add_argument('--maxt', type=int, default=3, help='Max transaction count to explore')\n    eth_flags.add_argument('--deployer', type=str, help='(optional) address of account used to deploy the contract')\n    eth_flags.add_argument('--senders', type=str, help='(optional) a comma separated list of sender addresses. The properties are going to be tested sending transactions from these addresses.')\n    eth_flags.add_argument('--psender', type=str, help='(optional) address from where the property is tested')\n    eth_flags.add_argument('--propre', default='crytic_.*', type=str, help='A regular expression for selecting properties')\n    eth_flags.add_argument('--timeout', default=240, type=int, help='Exploration timeout in seconds')\n    eth_flags.add_argument('--outputspace_url', type=str, help='where to put the extended result')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    parsed = parser.parse_args(sys.argv[1:])\n    config.process_config_values(parser, parsed)\n    if not parsed.source_code:\n        print(parser.format_usage() + 'error: You need to provide a contract source code.')\n        sys.exit(1)\n    args = parsed\n    set_verbosity(args.v)\n    logger = logging.getLogger('manticore.main')\n    deployer = None\n    senders = None\n    psenders = None\n    if args.propconfig:\n        '\\n        deployer: \"0x41414141414141414141\"  #who deploys the contract\\n        sender: [\"0x51515151515151515151\", \"0x52525252525252525252\"] #who calls the transactions (potentially can be multiple users)\\n        psender: \"0x616161616161616161\" #who calls the property\\n        '\n        import yaml\n        with open(args.propconfig) as f:\n            c = yaml.safe_load(f)\n            deployer = c.get('deployer')\n            if deployer is not None:\n                deployer = int(deployer, 0)\n            senders = c.get('sender')\n            if senders is not None:\n                senders = [int(sender, 0) for sender in senders]\n            psender = c.get('psender')\n            if psender is not None:\n                psender = int(psender, 0)\n    deployer = None\n    if args.deployer is not None:\n        deployer = int(args.deployer, 0)\n    senders = None\n    if args.senders is not None:\n        senders = [int(sender, 0) for sender in args.senders.split(',')]\n    psender = None\n    if args.psender is not None:\n        psender = int(args.psender, 0)\n    source_code = args.source_code[0]\n    contract_name = args.contract_name\n    maxfail = args.maxfail\n    maxt = args.maxt\n    maxcov = args.maxcov\n    return manticore_verifier(source_code, contract_name, maxfail=maxfail, maxt=maxt, maxcov=100, senders=senders, deployer=deployer, psender=psender, timeout=args.timeout, propre=args.propre, compile_args=vars(parsed))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from crytic_compile import is_supported, cryticparser\n    parser = argparse.ArgumentParser(description='Solidity property verifier', prog='manticore_verifier')\n    cryticparser.init(parser)\n    parser.add_argument('source_code', type=str, nargs='*', default=[], help='Contract source code')\n    parser.add_argument('-v', action='count', default=0, help='Specify verbosity level from -v to -vvvv')\n    parser.add_argument('--workspace', type=str, default=None, help='A folder name for temporaries and results.(default mcore_?????)')\n    current_version = pkg_resources.get_distribution('manticore').version\n    parser.add_argument('--version', action='version', version=f'Manticore {current_version}', help='Show program version information')\n    parser.add_argument('--propconfig', type=str, help='Solidity property accounts config file (.yml)')\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    eth_flags.add_argument('--contract_name', type=str, help='The target contract name defined in the source code')\n    eth_flags.add_argument('--maxfail', type=int, help='stop after maxfail properties are failing. All if None')\n    eth_flags.add_argument('--maxcov', type=int, default=100, help=' Stop after maxcov %% coverage is obtained in the main contract')\n    eth_flags.add_argument('--maxt', type=int, default=3, help='Max transaction count to explore')\n    eth_flags.add_argument('--deployer', type=str, help='(optional) address of account used to deploy the contract')\n    eth_flags.add_argument('--senders', type=str, help='(optional) a comma separated list of sender addresses. The properties are going to be tested sending transactions from these addresses.')\n    eth_flags.add_argument('--psender', type=str, help='(optional) address from where the property is tested')\n    eth_flags.add_argument('--propre', default='crytic_.*', type=str, help='A regular expression for selecting properties')\n    eth_flags.add_argument('--timeout', default=240, type=int, help='Exploration timeout in seconds')\n    eth_flags.add_argument('--outputspace_url', type=str, help='where to put the extended result')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    parsed = parser.parse_args(sys.argv[1:])\n    config.process_config_values(parser, parsed)\n    if not parsed.source_code:\n        print(parser.format_usage() + 'error: You need to provide a contract source code.')\n        sys.exit(1)\n    args = parsed\n    set_verbosity(args.v)\n    logger = logging.getLogger('manticore.main')\n    deployer = None\n    senders = None\n    psenders = None\n    if args.propconfig:\n        '\\n        deployer: \"0x41414141414141414141\"  #who deploys the contract\\n        sender: [\"0x51515151515151515151\", \"0x52525252525252525252\"] #who calls the transactions (potentially can be multiple users)\\n        psender: \"0x616161616161616161\" #who calls the property\\n        '\n        import yaml\n        with open(args.propconfig) as f:\n            c = yaml.safe_load(f)\n            deployer = c.get('deployer')\n            if deployer is not None:\n                deployer = int(deployer, 0)\n            senders = c.get('sender')\n            if senders is not None:\n                senders = [int(sender, 0) for sender in senders]\n            psender = c.get('psender')\n            if psender is not None:\n                psender = int(psender, 0)\n    deployer = None\n    if args.deployer is not None:\n        deployer = int(args.deployer, 0)\n    senders = None\n    if args.senders is not None:\n        senders = [int(sender, 0) for sender in args.senders.split(',')]\n    psender = None\n    if args.psender is not None:\n        psender = int(args.psender, 0)\n    source_code = args.source_code[0]\n    contract_name = args.contract_name\n    maxfail = args.maxfail\n    maxt = args.maxt\n    maxcov = args.maxcov\n    return manticore_verifier(source_code, contract_name, maxfail=maxfail, maxt=maxt, maxcov=100, senders=senders, deployer=deployer, psender=psender, timeout=args.timeout, propre=args.propre, compile_args=vars(parsed))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from crytic_compile import is_supported, cryticparser\n    parser = argparse.ArgumentParser(description='Solidity property verifier', prog='manticore_verifier')\n    cryticparser.init(parser)\n    parser.add_argument('source_code', type=str, nargs='*', default=[], help='Contract source code')\n    parser.add_argument('-v', action='count', default=0, help='Specify verbosity level from -v to -vvvv')\n    parser.add_argument('--workspace', type=str, default=None, help='A folder name for temporaries and results.(default mcore_?????)')\n    current_version = pkg_resources.get_distribution('manticore').version\n    parser.add_argument('--version', action='version', version=f'Manticore {current_version}', help='Show program version information')\n    parser.add_argument('--propconfig', type=str, help='Solidity property accounts config file (.yml)')\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    eth_flags.add_argument('--contract_name', type=str, help='The target contract name defined in the source code')\n    eth_flags.add_argument('--maxfail', type=int, help='stop after maxfail properties are failing. All if None')\n    eth_flags.add_argument('--maxcov', type=int, default=100, help=' Stop after maxcov %% coverage is obtained in the main contract')\n    eth_flags.add_argument('--maxt', type=int, default=3, help='Max transaction count to explore')\n    eth_flags.add_argument('--deployer', type=str, help='(optional) address of account used to deploy the contract')\n    eth_flags.add_argument('--senders', type=str, help='(optional) a comma separated list of sender addresses. The properties are going to be tested sending transactions from these addresses.')\n    eth_flags.add_argument('--psender', type=str, help='(optional) address from where the property is tested')\n    eth_flags.add_argument('--propre', default='crytic_.*', type=str, help='A regular expression for selecting properties')\n    eth_flags.add_argument('--timeout', default=240, type=int, help='Exploration timeout in seconds')\n    eth_flags.add_argument('--outputspace_url', type=str, help='where to put the extended result')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    parsed = parser.parse_args(sys.argv[1:])\n    config.process_config_values(parser, parsed)\n    if not parsed.source_code:\n        print(parser.format_usage() + 'error: You need to provide a contract source code.')\n        sys.exit(1)\n    args = parsed\n    set_verbosity(args.v)\n    logger = logging.getLogger('manticore.main')\n    deployer = None\n    senders = None\n    psenders = None\n    if args.propconfig:\n        '\\n        deployer: \"0x41414141414141414141\"  #who deploys the contract\\n        sender: [\"0x51515151515151515151\", \"0x52525252525252525252\"] #who calls the transactions (potentially can be multiple users)\\n        psender: \"0x616161616161616161\" #who calls the property\\n        '\n        import yaml\n        with open(args.propconfig) as f:\n            c = yaml.safe_load(f)\n            deployer = c.get('deployer')\n            if deployer is not None:\n                deployer = int(deployer, 0)\n            senders = c.get('sender')\n            if senders is not None:\n                senders = [int(sender, 0) for sender in senders]\n            psender = c.get('psender')\n            if psender is not None:\n                psender = int(psender, 0)\n    deployer = None\n    if args.deployer is not None:\n        deployer = int(args.deployer, 0)\n    senders = None\n    if args.senders is not None:\n        senders = [int(sender, 0) for sender in args.senders.split(',')]\n    psender = None\n    if args.psender is not None:\n        psender = int(args.psender, 0)\n    source_code = args.source_code[0]\n    contract_name = args.contract_name\n    maxfail = args.maxfail\n    maxt = args.maxt\n    maxcov = args.maxcov\n    return manticore_verifier(source_code, contract_name, maxfail=maxfail, maxt=maxt, maxcov=100, senders=senders, deployer=deployer, psender=psender, timeout=args.timeout, propre=args.propre, compile_args=vars(parsed))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from crytic_compile import is_supported, cryticparser\n    parser = argparse.ArgumentParser(description='Solidity property verifier', prog='manticore_verifier')\n    cryticparser.init(parser)\n    parser.add_argument('source_code', type=str, nargs='*', default=[], help='Contract source code')\n    parser.add_argument('-v', action='count', default=0, help='Specify verbosity level from -v to -vvvv')\n    parser.add_argument('--workspace', type=str, default=None, help='A folder name for temporaries and results.(default mcore_?????)')\n    current_version = pkg_resources.get_distribution('manticore').version\n    parser.add_argument('--version', action='version', version=f'Manticore {current_version}', help='Show program version information')\n    parser.add_argument('--propconfig', type=str, help='Solidity property accounts config file (.yml)')\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    eth_flags.add_argument('--contract_name', type=str, help='The target contract name defined in the source code')\n    eth_flags.add_argument('--maxfail', type=int, help='stop after maxfail properties are failing. All if None')\n    eth_flags.add_argument('--maxcov', type=int, default=100, help=' Stop after maxcov %% coverage is obtained in the main contract')\n    eth_flags.add_argument('--maxt', type=int, default=3, help='Max transaction count to explore')\n    eth_flags.add_argument('--deployer', type=str, help='(optional) address of account used to deploy the contract')\n    eth_flags.add_argument('--senders', type=str, help='(optional) a comma separated list of sender addresses. The properties are going to be tested sending transactions from these addresses.')\n    eth_flags.add_argument('--psender', type=str, help='(optional) address from where the property is tested')\n    eth_flags.add_argument('--propre', default='crytic_.*', type=str, help='A regular expression for selecting properties')\n    eth_flags.add_argument('--timeout', default=240, type=int, help='Exploration timeout in seconds')\n    eth_flags.add_argument('--outputspace_url', type=str, help='where to put the extended result')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    parsed = parser.parse_args(sys.argv[1:])\n    config.process_config_values(parser, parsed)\n    if not parsed.source_code:\n        print(parser.format_usage() + 'error: You need to provide a contract source code.')\n        sys.exit(1)\n    args = parsed\n    set_verbosity(args.v)\n    logger = logging.getLogger('manticore.main')\n    deployer = None\n    senders = None\n    psenders = None\n    if args.propconfig:\n        '\\n        deployer: \"0x41414141414141414141\"  #who deploys the contract\\n        sender: [\"0x51515151515151515151\", \"0x52525252525252525252\"] #who calls the transactions (potentially can be multiple users)\\n        psender: \"0x616161616161616161\" #who calls the property\\n        '\n        import yaml\n        with open(args.propconfig) as f:\n            c = yaml.safe_load(f)\n            deployer = c.get('deployer')\n            if deployer is not None:\n                deployer = int(deployer, 0)\n            senders = c.get('sender')\n            if senders is not None:\n                senders = [int(sender, 0) for sender in senders]\n            psender = c.get('psender')\n            if psender is not None:\n                psender = int(psender, 0)\n    deployer = None\n    if args.deployer is not None:\n        deployer = int(args.deployer, 0)\n    senders = None\n    if args.senders is not None:\n        senders = [int(sender, 0) for sender in args.senders.split(',')]\n    psender = None\n    if args.psender is not None:\n        psender = int(args.psender, 0)\n    source_code = args.source_code[0]\n    contract_name = args.contract_name\n    maxfail = args.maxfail\n    maxt = args.maxt\n    maxcov = args.maxcov\n    return manticore_verifier(source_code, contract_name, maxfail=maxfail, maxt=maxt, maxcov=100, senders=senders, deployer=deployer, psender=psender, timeout=args.timeout, propre=args.propre, compile_args=vars(parsed))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from crytic_compile import is_supported, cryticparser\n    parser = argparse.ArgumentParser(description='Solidity property verifier', prog='manticore_verifier')\n    cryticparser.init(parser)\n    parser.add_argument('source_code', type=str, nargs='*', default=[], help='Contract source code')\n    parser.add_argument('-v', action='count', default=0, help='Specify verbosity level from -v to -vvvv')\n    parser.add_argument('--workspace', type=str, default=None, help='A folder name for temporaries and results.(default mcore_?????)')\n    current_version = pkg_resources.get_distribution('manticore').version\n    parser.add_argument('--version', action='version', version=f'Manticore {current_version}', help='Show program version information')\n    parser.add_argument('--propconfig', type=str, help='Solidity property accounts config file (.yml)')\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    eth_flags.add_argument('--contract_name', type=str, help='The target contract name defined in the source code')\n    eth_flags.add_argument('--maxfail', type=int, help='stop after maxfail properties are failing. All if None')\n    eth_flags.add_argument('--maxcov', type=int, default=100, help=' Stop after maxcov %% coverage is obtained in the main contract')\n    eth_flags.add_argument('--maxt', type=int, default=3, help='Max transaction count to explore')\n    eth_flags.add_argument('--deployer', type=str, help='(optional) address of account used to deploy the contract')\n    eth_flags.add_argument('--senders', type=str, help='(optional) a comma separated list of sender addresses. The properties are going to be tested sending transactions from these addresses.')\n    eth_flags.add_argument('--psender', type=str, help='(optional) address from where the property is tested')\n    eth_flags.add_argument('--propre', default='crytic_.*', type=str, help='A regular expression for selecting properties')\n    eth_flags.add_argument('--timeout', default=240, type=int, help='Exploration timeout in seconds')\n    eth_flags.add_argument('--outputspace_url', type=str, help='where to put the extended result')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    parsed = parser.parse_args(sys.argv[1:])\n    config.process_config_values(parser, parsed)\n    if not parsed.source_code:\n        print(parser.format_usage() + 'error: You need to provide a contract source code.')\n        sys.exit(1)\n    args = parsed\n    set_verbosity(args.v)\n    logger = logging.getLogger('manticore.main')\n    deployer = None\n    senders = None\n    psenders = None\n    if args.propconfig:\n        '\\n        deployer: \"0x41414141414141414141\"  #who deploys the contract\\n        sender: [\"0x51515151515151515151\", \"0x52525252525252525252\"] #who calls the transactions (potentially can be multiple users)\\n        psender: \"0x616161616161616161\" #who calls the property\\n        '\n        import yaml\n        with open(args.propconfig) as f:\n            c = yaml.safe_load(f)\n            deployer = c.get('deployer')\n            if deployer is not None:\n                deployer = int(deployer, 0)\n            senders = c.get('sender')\n            if senders is not None:\n                senders = [int(sender, 0) for sender in senders]\n            psender = c.get('psender')\n            if psender is not None:\n                psender = int(psender, 0)\n    deployer = None\n    if args.deployer is not None:\n        deployer = int(args.deployer, 0)\n    senders = None\n    if args.senders is not None:\n        senders = [int(sender, 0) for sender in args.senders.split(',')]\n    psender = None\n    if args.psender is not None:\n        psender = int(args.psender, 0)\n    source_code = args.source_code[0]\n    contract_name = args.contract_name\n    maxfail = args.maxfail\n    maxt = args.maxt\n    maxcov = args.maxcov\n    return manticore_verifier(source_code, contract_name, maxfail=maxfail, maxt=maxt, maxcov=100, senders=senders, deployer=deployer, psender=psender, timeout=args.timeout, propre=args.propre, compile_args=vars(parsed))"
        ]
    }
]