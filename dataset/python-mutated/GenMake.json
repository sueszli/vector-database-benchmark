[
    {
        "func_name": "getMakefileName",
        "original": "def getMakefileName(self):\n    if not self._FileType:\n        return self._DEFAULT_FILE_NAME_\n    else:\n        return self._FILE_NAME_[self._FileType]",
        "mutated": [
            "def getMakefileName(self):\n    if False:\n        i = 10\n    if not self._FileType:\n        return self._DEFAULT_FILE_NAME_\n    else:\n        return self._FILE_NAME_[self._FileType]",
            "def getMakefileName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not self._FileType:\n        return self._DEFAULT_FILE_NAME_\n    else:\n        return self._FILE_NAME_[self._FileType]",
            "def getMakefileName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not self._FileType:\n        return self._DEFAULT_FILE_NAME_\n    else:\n        return self._FILE_NAME_[self._FileType]",
            "def getMakefileName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not self._FileType:\n        return self._DEFAULT_FILE_NAME_\n    else:\n        return self._FILE_NAME_[self._FileType]",
            "def getMakefileName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not self._FileType:\n        return self._DEFAULT_FILE_NAME_\n    else:\n        return self._FILE_NAME_[self._FileType]"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, AutoGenObject):\n    self._AutoGenObject = AutoGenObject\n    MakePath = AutoGenObject.BuildOption.get('MAKE', {}).get('PATH')\n    if not MakePath:\n        MakePath = AutoGenObject.ToolDefinition.get('MAKE', {}).get('PATH')\n    if 'nmake' in MakePath:\n        self._FileType = NMAKE_FILETYPE\n    else:\n        self._FileType = GMAKE_FILETYPE\n    if sys.platform == 'win32':\n        self._Platform = WIN32_PLATFORM\n    else:\n        self._Platform = POSIX_PLATFORM",
        "mutated": [
            "def __init__(self, AutoGenObject):\n    if False:\n        i = 10\n    self._AutoGenObject = AutoGenObject\n    MakePath = AutoGenObject.BuildOption.get('MAKE', {}).get('PATH')\n    if not MakePath:\n        MakePath = AutoGenObject.ToolDefinition.get('MAKE', {}).get('PATH')\n    if 'nmake' in MakePath:\n        self._FileType = NMAKE_FILETYPE\n    else:\n        self._FileType = GMAKE_FILETYPE\n    if sys.platform == 'win32':\n        self._Platform = WIN32_PLATFORM\n    else:\n        self._Platform = POSIX_PLATFORM",
            "def __init__(self, AutoGenObject):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._AutoGenObject = AutoGenObject\n    MakePath = AutoGenObject.BuildOption.get('MAKE', {}).get('PATH')\n    if not MakePath:\n        MakePath = AutoGenObject.ToolDefinition.get('MAKE', {}).get('PATH')\n    if 'nmake' in MakePath:\n        self._FileType = NMAKE_FILETYPE\n    else:\n        self._FileType = GMAKE_FILETYPE\n    if sys.platform == 'win32':\n        self._Platform = WIN32_PLATFORM\n    else:\n        self._Platform = POSIX_PLATFORM",
            "def __init__(self, AutoGenObject):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._AutoGenObject = AutoGenObject\n    MakePath = AutoGenObject.BuildOption.get('MAKE', {}).get('PATH')\n    if not MakePath:\n        MakePath = AutoGenObject.ToolDefinition.get('MAKE', {}).get('PATH')\n    if 'nmake' in MakePath:\n        self._FileType = NMAKE_FILETYPE\n    else:\n        self._FileType = GMAKE_FILETYPE\n    if sys.platform == 'win32':\n        self._Platform = WIN32_PLATFORM\n    else:\n        self._Platform = POSIX_PLATFORM",
            "def __init__(self, AutoGenObject):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._AutoGenObject = AutoGenObject\n    MakePath = AutoGenObject.BuildOption.get('MAKE', {}).get('PATH')\n    if not MakePath:\n        MakePath = AutoGenObject.ToolDefinition.get('MAKE', {}).get('PATH')\n    if 'nmake' in MakePath:\n        self._FileType = NMAKE_FILETYPE\n    else:\n        self._FileType = GMAKE_FILETYPE\n    if sys.platform == 'win32':\n        self._Platform = WIN32_PLATFORM\n    else:\n        self._Platform = POSIX_PLATFORM",
            "def __init__(self, AutoGenObject):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._AutoGenObject = AutoGenObject\n    MakePath = AutoGenObject.BuildOption.get('MAKE', {}).get('PATH')\n    if not MakePath:\n        MakePath = AutoGenObject.ToolDefinition.get('MAKE', {}).get('PATH')\n    if 'nmake' in MakePath:\n        self._FileType = NMAKE_FILETYPE\n    else:\n        self._FileType = GMAKE_FILETYPE\n    if sys.platform == 'win32':\n        self._Platform = WIN32_PLATFORM\n    else:\n        self._Platform = POSIX_PLATFORM"
        ]
    },
    {
        "func_name": "Generate",
        "original": "def Generate(self):\n    FileContent = self._TEMPLATE_.Replace(self._TemplateDict)\n    FileName = self.getMakefileName()\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target'), 'w+') as fd:\n            fd.write('')\n    return SaveFileOnChange(os.path.join(self._AutoGenObject.MakeFileDir, FileName), FileContent, False)",
        "mutated": [
            "def Generate(self):\n    if False:\n        i = 10\n    FileContent = self._TEMPLATE_.Replace(self._TemplateDict)\n    FileName = self.getMakefileName()\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target'), 'w+') as fd:\n            fd.write('')\n    return SaveFileOnChange(os.path.join(self._AutoGenObject.MakeFileDir, FileName), FileContent, False)",
            "def Generate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FileContent = self._TEMPLATE_.Replace(self._TemplateDict)\n    FileName = self.getMakefileName()\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target'), 'w+') as fd:\n            fd.write('')\n    return SaveFileOnChange(os.path.join(self._AutoGenObject.MakeFileDir, FileName), FileContent, False)",
            "def Generate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FileContent = self._TEMPLATE_.Replace(self._TemplateDict)\n    FileName = self.getMakefileName()\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target'), 'w+') as fd:\n            fd.write('')\n    return SaveFileOnChange(os.path.join(self._AutoGenObject.MakeFileDir, FileName), FileContent, False)",
            "def Generate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FileContent = self._TEMPLATE_.Replace(self._TemplateDict)\n    FileName = self.getMakefileName()\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target'), 'w+') as fd:\n            fd.write('')\n    return SaveFileOnChange(os.path.join(self._AutoGenObject.MakeFileDir, FileName), FileContent, False)",
            "def Generate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FileContent = self._TEMPLATE_.Replace(self._TemplateDict)\n    FileName = self.getMakefileName()\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps.txt'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'dependency'), 'w+') as fd:\n            fd.write('')\n    if not os.path.exists(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target')):\n        with open(os.path.join(self._AutoGenObject.MakeFileDir, 'deps_target'), 'w+') as fd:\n            fd.write('')\n    return SaveFileOnChange(os.path.join(self._AutoGenObject.MakeFileDir, FileName), FileContent, False)"
        ]
    },
    {
        "func_name": "GetCreateDirectoryCommand",
        "original": "def GetCreateDirectoryCommand(self, DirList):\n    return [self._MD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
        "mutated": [
            "def GetCreateDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n    return [self._MD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
            "def GetCreateDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [self._MD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
            "def GetCreateDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [self._MD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
            "def GetCreateDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [self._MD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
            "def GetCreateDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [self._MD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]"
        ]
    },
    {
        "func_name": "GetRemoveDirectoryCommand",
        "original": "def GetRemoveDirectoryCommand(self, DirList):\n    return [self._RD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
        "mutated": [
            "def GetRemoveDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n    return [self._RD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
            "def GetRemoveDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [self._RD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
            "def GetRemoveDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [self._RD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
            "def GetRemoveDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [self._RD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]",
            "def GetRemoveDirectoryCommand(self, DirList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [self._RD_TEMPLATE_[self._Platform] % {'dir': Dir} for Dir in DirList]"
        ]
    },
    {
        "func_name": "PlaceMacro",
        "original": "def PlaceMacro(self, Path, MacroDefinitions=None):\n    if Path.startswith('$('):\n        return Path\n    else:\n        if MacroDefinitions is None:\n            MacroDefinitions = {}\n        PathLength = len(Path)\n        for MacroName in MacroDefinitions:\n            MacroValue = MacroDefinitions[MacroName]\n            MacroValueLength = len(MacroValue)\n            if MacroValueLength == 0:\n                continue\n            if MacroValueLength <= PathLength and Path.startswith(MacroValue):\n                Path = '$(%s)%s' % (MacroName, Path[MacroValueLength:])\n                break\n        return Path",
        "mutated": [
            "def PlaceMacro(self, Path, MacroDefinitions=None):\n    if False:\n        i = 10\n    if Path.startswith('$('):\n        return Path\n    else:\n        if MacroDefinitions is None:\n            MacroDefinitions = {}\n        PathLength = len(Path)\n        for MacroName in MacroDefinitions:\n            MacroValue = MacroDefinitions[MacroName]\n            MacroValueLength = len(MacroValue)\n            if MacroValueLength == 0:\n                continue\n            if MacroValueLength <= PathLength and Path.startswith(MacroValue):\n                Path = '$(%s)%s' % (MacroName, Path[MacroValueLength:])\n                break\n        return Path",
            "def PlaceMacro(self, Path, MacroDefinitions=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Path.startswith('$('):\n        return Path\n    else:\n        if MacroDefinitions is None:\n            MacroDefinitions = {}\n        PathLength = len(Path)\n        for MacroName in MacroDefinitions:\n            MacroValue = MacroDefinitions[MacroName]\n            MacroValueLength = len(MacroValue)\n            if MacroValueLength == 0:\n                continue\n            if MacroValueLength <= PathLength and Path.startswith(MacroValue):\n                Path = '$(%s)%s' % (MacroName, Path[MacroValueLength:])\n                break\n        return Path",
            "def PlaceMacro(self, Path, MacroDefinitions=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Path.startswith('$('):\n        return Path\n    else:\n        if MacroDefinitions is None:\n            MacroDefinitions = {}\n        PathLength = len(Path)\n        for MacroName in MacroDefinitions:\n            MacroValue = MacroDefinitions[MacroName]\n            MacroValueLength = len(MacroValue)\n            if MacroValueLength == 0:\n                continue\n            if MacroValueLength <= PathLength and Path.startswith(MacroValue):\n                Path = '$(%s)%s' % (MacroName, Path[MacroValueLength:])\n                break\n        return Path",
            "def PlaceMacro(self, Path, MacroDefinitions=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Path.startswith('$('):\n        return Path\n    else:\n        if MacroDefinitions is None:\n            MacroDefinitions = {}\n        PathLength = len(Path)\n        for MacroName in MacroDefinitions:\n            MacroValue = MacroDefinitions[MacroName]\n            MacroValueLength = len(MacroValue)\n            if MacroValueLength == 0:\n                continue\n            if MacroValueLength <= PathLength and Path.startswith(MacroValue):\n                Path = '$(%s)%s' % (MacroName, Path[MacroValueLength:])\n                break\n        return Path",
            "def PlaceMacro(self, Path, MacroDefinitions=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Path.startswith('$('):\n        return Path\n    else:\n        if MacroDefinitions is None:\n            MacroDefinitions = {}\n        PathLength = len(Path)\n        for MacroName in MacroDefinitions:\n            MacroValue = MacroDefinitions[MacroName]\n            MacroValueLength = len(MacroValue)\n            if MacroValueLength == 0:\n                continue\n            if MacroValueLength <= PathLength and Path.startswith(MacroValue):\n                Path = '$(%s)%s' % (MacroName, Path[MacroValueLength:])\n                break\n        return Path"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, ModuleAutoGen):\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.ResultFileList = []\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.FileBuildTargetList = []\n    self.BuildTargetList = []\n    self.PendingBuildTargetList = []\n    self.CommonFileDependency = []\n    self.FileListMacros = {}\n    self.ListFileMacros = {}\n    self.ObjTargetDict = OrderedDict()\n    self.FileCache = {}\n    self.LibraryBuildCommandList = []\n    self.LibraryFileList = []\n    self.LibraryMakefileList = []\n    self.LibraryBuildDirectoryList = []\n    self.SystemLibraryList = []\n    self.Macros = OrderedDict()\n    self.Macros['OUTPUT_DIR'] = self._AutoGenObject.Macros['OUTPUT_DIR']\n    self.Macros['DEBUG_DIR'] = self._AutoGenObject.Macros['DEBUG_DIR']\n    self.Macros['MODULE_BUILD_DIR'] = self._AutoGenObject.Macros['MODULE_BUILD_DIR']\n    self.Macros['BIN_DIR'] = self._AutoGenObject.Macros['BIN_DIR']\n    self.Macros['BUILD_DIR'] = self._AutoGenObject.Macros['BUILD_DIR']\n    self.Macros['WORKSPACE'] = self._AutoGenObject.Macros['WORKSPACE']\n    self.Macros['FFS_OUTPUT_DIR'] = self._AutoGenObject.Macros['FFS_OUTPUT_DIR']\n    self.GenFfsList = ModuleAutoGen.GenFfsList\n    self.MacroList = ['FFS_OUTPUT_DIR', 'MODULE_GUID', 'OUTPUT_DIR']\n    self.FfsOutputFileList = []\n    self.DependencyHeaderFileSet = set()",
        "mutated": [
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.ResultFileList = []\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.FileBuildTargetList = []\n    self.BuildTargetList = []\n    self.PendingBuildTargetList = []\n    self.CommonFileDependency = []\n    self.FileListMacros = {}\n    self.ListFileMacros = {}\n    self.ObjTargetDict = OrderedDict()\n    self.FileCache = {}\n    self.LibraryBuildCommandList = []\n    self.LibraryFileList = []\n    self.LibraryMakefileList = []\n    self.LibraryBuildDirectoryList = []\n    self.SystemLibraryList = []\n    self.Macros = OrderedDict()\n    self.Macros['OUTPUT_DIR'] = self._AutoGenObject.Macros['OUTPUT_DIR']\n    self.Macros['DEBUG_DIR'] = self._AutoGenObject.Macros['DEBUG_DIR']\n    self.Macros['MODULE_BUILD_DIR'] = self._AutoGenObject.Macros['MODULE_BUILD_DIR']\n    self.Macros['BIN_DIR'] = self._AutoGenObject.Macros['BIN_DIR']\n    self.Macros['BUILD_DIR'] = self._AutoGenObject.Macros['BUILD_DIR']\n    self.Macros['WORKSPACE'] = self._AutoGenObject.Macros['WORKSPACE']\n    self.Macros['FFS_OUTPUT_DIR'] = self._AutoGenObject.Macros['FFS_OUTPUT_DIR']\n    self.GenFfsList = ModuleAutoGen.GenFfsList\n    self.MacroList = ['FFS_OUTPUT_DIR', 'MODULE_GUID', 'OUTPUT_DIR']\n    self.FfsOutputFileList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.ResultFileList = []\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.FileBuildTargetList = []\n    self.BuildTargetList = []\n    self.PendingBuildTargetList = []\n    self.CommonFileDependency = []\n    self.FileListMacros = {}\n    self.ListFileMacros = {}\n    self.ObjTargetDict = OrderedDict()\n    self.FileCache = {}\n    self.LibraryBuildCommandList = []\n    self.LibraryFileList = []\n    self.LibraryMakefileList = []\n    self.LibraryBuildDirectoryList = []\n    self.SystemLibraryList = []\n    self.Macros = OrderedDict()\n    self.Macros['OUTPUT_DIR'] = self._AutoGenObject.Macros['OUTPUT_DIR']\n    self.Macros['DEBUG_DIR'] = self._AutoGenObject.Macros['DEBUG_DIR']\n    self.Macros['MODULE_BUILD_DIR'] = self._AutoGenObject.Macros['MODULE_BUILD_DIR']\n    self.Macros['BIN_DIR'] = self._AutoGenObject.Macros['BIN_DIR']\n    self.Macros['BUILD_DIR'] = self._AutoGenObject.Macros['BUILD_DIR']\n    self.Macros['WORKSPACE'] = self._AutoGenObject.Macros['WORKSPACE']\n    self.Macros['FFS_OUTPUT_DIR'] = self._AutoGenObject.Macros['FFS_OUTPUT_DIR']\n    self.GenFfsList = ModuleAutoGen.GenFfsList\n    self.MacroList = ['FFS_OUTPUT_DIR', 'MODULE_GUID', 'OUTPUT_DIR']\n    self.FfsOutputFileList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.ResultFileList = []\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.FileBuildTargetList = []\n    self.BuildTargetList = []\n    self.PendingBuildTargetList = []\n    self.CommonFileDependency = []\n    self.FileListMacros = {}\n    self.ListFileMacros = {}\n    self.ObjTargetDict = OrderedDict()\n    self.FileCache = {}\n    self.LibraryBuildCommandList = []\n    self.LibraryFileList = []\n    self.LibraryMakefileList = []\n    self.LibraryBuildDirectoryList = []\n    self.SystemLibraryList = []\n    self.Macros = OrderedDict()\n    self.Macros['OUTPUT_DIR'] = self._AutoGenObject.Macros['OUTPUT_DIR']\n    self.Macros['DEBUG_DIR'] = self._AutoGenObject.Macros['DEBUG_DIR']\n    self.Macros['MODULE_BUILD_DIR'] = self._AutoGenObject.Macros['MODULE_BUILD_DIR']\n    self.Macros['BIN_DIR'] = self._AutoGenObject.Macros['BIN_DIR']\n    self.Macros['BUILD_DIR'] = self._AutoGenObject.Macros['BUILD_DIR']\n    self.Macros['WORKSPACE'] = self._AutoGenObject.Macros['WORKSPACE']\n    self.Macros['FFS_OUTPUT_DIR'] = self._AutoGenObject.Macros['FFS_OUTPUT_DIR']\n    self.GenFfsList = ModuleAutoGen.GenFfsList\n    self.MacroList = ['FFS_OUTPUT_DIR', 'MODULE_GUID', 'OUTPUT_DIR']\n    self.FfsOutputFileList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.ResultFileList = []\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.FileBuildTargetList = []\n    self.BuildTargetList = []\n    self.PendingBuildTargetList = []\n    self.CommonFileDependency = []\n    self.FileListMacros = {}\n    self.ListFileMacros = {}\n    self.ObjTargetDict = OrderedDict()\n    self.FileCache = {}\n    self.LibraryBuildCommandList = []\n    self.LibraryFileList = []\n    self.LibraryMakefileList = []\n    self.LibraryBuildDirectoryList = []\n    self.SystemLibraryList = []\n    self.Macros = OrderedDict()\n    self.Macros['OUTPUT_DIR'] = self._AutoGenObject.Macros['OUTPUT_DIR']\n    self.Macros['DEBUG_DIR'] = self._AutoGenObject.Macros['DEBUG_DIR']\n    self.Macros['MODULE_BUILD_DIR'] = self._AutoGenObject.Macros['MODULE_BUILD_DIR']\n    self.Macros['BIN_DIR'] = self._AutoGenObject.Macros['BIN_DIR']\n    self.Macros['BUILD_DIR'] = self._AutoGenObject.Macros['BUILD_DIR']\n    self.Macros['WORKSPACE'] = self._AutoGenObject.Macros['WORKSPACE']\n    self.Macros['FFS_OUTPUT_DIR'] = self._AutoGenObject.Macros['FFS_OUTPUT_DIR']\n    self.GenFfsList = ModuleAutoGen.GenFfsList\n    self.MacroList = ['FFS_OUTPUT_DIR', 'MODULE_GUID', 'OUTPUT_DIR']\n    self.FfsOutputFileList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.ResultFileList = []\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.FileBuildTargetList = []\n    self.BuildTargetList = []\n    self.PendingBuildTargetList = []\n    self.CommonFileDependency = []\n    self.FileListMacros = {}\n    self.ListFileMacros = {}\n    self.ObjTargetDict = OrderedDict()\n    self.FileCache = {}\n    self.LibraryBuildCommandList = []\n    self.LibraryFileList = []\n    self.LibraryMakefileList = []\n    self.LibraryBuildDirectoryList = []\n    self.SystemLibraryList = []\n    self.Macros = OrderedDict()\n    self.Macros['OUTPUT_DIR'] = self._AutoGenObject.Macros['OUTPUT_DIR']\n    self.Macros['DEBUG_DIR'] = self._AutoGenObject.Macros['DEBUG_DIR']\n    self.Macros['MODULE_BUILD_DIR'] = self._AutoGenObject.Macros['MODULE_BUILD_DIR']\n    self.Macros['BIN_DIR'] = self._AutoGenObject.Macros['BIN_DIR']\n    self.Macros['BUILD_DIR'] = self._AutoGenObject.Macros['BUILD_DIR']\n    self.Macros['WORKSPACE'] = self._AutoGenObject.Macros['WORKSPACE']\n    self.Macros['FFS_OUTPUT_DIR'] = self._AutoGenObject.Macros['FFS_OUTPUT_DIR']\n    self.GenFfsList = ModuleAutoGen.GenFfsList\n    self.MacroList = ['FFS_OUTPUT_DIR', 'MODULE_GUID', 'OUTPUT_DIR']\n    self.FfsOutputFileList = []\n    self.DependencyHeaderFileSet = set()"
        ]
    },
    {
        "func_name": "_TemplateDict",
        "original": "@property\ndef _TemplateDict(self):\n    MyAgo = self._AutoGenObject\n    Separator = self._SEP_[self._Platform]\n    if len(MyAgo.SourceFileList) == 0 and len(MyAgo.BinaryFileList) == 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'No files to be built in module [%s, %s, %s]' % (MyAgo.BuildTarget, MyAgo.ToolChain, MyAgo.Arch), ExtraData='[%s]' % str(MyAgo))\n    self.ProcessDependentLibrary()\n    if len(MyAgo.Module.ModuleEntryPointList) > 0:\n        ModuleEntryPoint = MyAgo.Module.ModuleEntryPointList[0]\n    else:\n        ModuleEntryPoint = '_ModuleEntryPoint'\n    ArchEntryPoint = ModuleEntryPoint\n    if MyAgo.Arch == 'EBC':\n        ImageEntryPoint = 'EfiStart'\n    else:\n        ImageEntryPoint = '_ModuleEntryPoint'\n    for (k, v) in MyAgo.Module.Defines.items():\n        if k not in MyAgo.Macros:\n            MyAgo.Macros[k] = v\n    if 'MODULE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['MODULE_ENTRY_POINT'] = ModuleEntryPoint\n    if 'ARCH_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['ARCH_ENTRY_POINT'] = ArchEntryPoint\n    if 'IMAGE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['IMAGE_ENTRY_POINT'] = ImageEntryPoint\n    PCI_COMPRESS_Flag = False\n    for (k, v) in MyAgo.Module.Defines.items():\n        if 'PCI_COMPRESS' == k and 'TRUE' == v:\n            PCI_COMPRESS_Flag = True\n    ToolsDef = []\n    IncPrefix = self._INC_FLAG_[MyAgo.ToolChainFamily]\n    for Tool in sorted(list(MyAgo.BuildOption)):\n        Appended = False\n        for Attr in sorted(list(MyAgo.BuildOption[Tool])):\n            Value = MyAgo.BuildOption[Tool][Attr]\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, Value))\n                Appended = True\n            else:\n                if Tool == 'MAKE':\n                    continue\n                if Attr == 'FLAGS':\n                    Value = RemoveDupOption(Value, IncPrefix, MyAgo.IncludePathList)\n                    if Tool == 'OPTROM' and PCI_COMPRESS_Flag:\n                        ValueList = Value.split()\n                        if ValueList:\n                            for (i, v) in enumerate(ValueList):\n                                if '-e' == v:\n                                    ValueList[i] = '-ec'\n                            Value = ' '.join(ValueList)\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, Value))\n                Appended = True\n        if Appended:\n            ToolsDef.append('')\n    RespDict = self.CommandExceedLimit()\n    RespFileList = os.path.join(MyAgo.OutputDir, 'respfilelist.txt')\n    if RespDict:\n        RespFileListContent = ''\n        for Resp in RespDict:\n            RespFile = os.path.join(MyAgo.OutputDir, str(Resp).lower() + '.txt')\n            StrList = RespDict[Resp].split(' ')\n            UnexpandMacro = []\n            NewStr = []\n            for Str in StrList:\n                if '$' in Str or '-MMD' in Str or '-MF' in Str:\n                    UnexpandMacro.append(Str)\n                else:\n                    NewStr.append(Str)\n            UnexpandMacroStr = ' '.join(UnexpandMacro)\n            NewRespStr = ' '.join(NewStr)\n            SaveFileOnChange(RespFile, NewRespStr, False)\n            ToolsDef.append('%s = %s' % (Resp, UnexpandMacroStr + ' @' + RespFile))\n            RespFileListContent += '@' + RespFile + TAB_LINE_BREAK\n            RespFileListContent += NewRespStr + TAB_LINE_BREAK\n        SaveFileOnChange(RespFileList, RespFileListContent, False)\n    elif os.path.exists(RespFileList):\n        os.remove(RespFileList)\n    self.ResultFileList = [str(T.Target) for T in MyAgo.CodaTargetList]\n    if len(self.ResultFileList) == 0 and len(MyAgo.SourceFileList) != 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Nothing to build', ExtraData='[%s]' % str(MyAgo))\n    self.ProcessBuildTargetList(MyAgo.OutputDir, ToolsDef)\n    self.ParserGenerateFfsCmd()\n    FileMacroList = []\n    for FileListMacro in self.FileListMacros:\n        FileMacro = self._FILE_MACRO_TEMPLATE.Replace({'macro_name': FileListMacro, 'source_file': self.FileListMacros[FileListMacro]})\n        FileMacroList.append(FileMacro)\n    FileMacro = ''\n    IncludePathList = []\n    for P in MyAgo.IncludePathList:\n        IncludePathList.append(IncPrefix + self.PlaceMacro(P, self.Macros))\n        if FileBuildRule.INC_LIST_MACRO in self.ListFileMacros:\n            self.ListFileMacros[FileBuildRule.INC_LIST_MACRO].append(IncPrefix + P)\n    FileMacro += self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'INC', 'source_file': IncludePathList})\n    FileMacroList.append(FileMacro)\n    IncludePathList = []\n    asmsource = [item for item in MyAgo.SourceFileList if item.File.upper().endswith(('.NASM', '.ASM', '.NASMB', 'S'))]\n    if asmsource:\n        for P in MyAgo.IncludePathList:\n            IncludePath = self._INC_FLAG_['NASM'] + self.PlaceMacro(P, self.Macros)\n            if IncludePath.endswith(os.sep):\n                IncludePath = IncludePath.rstrip(os.sep)\n            if P == MyAgo.IncludePathList[-1] and self._Platform == WIN32_PLATFORM and (self._FileType == NMAKE_FILETYPE):\n                IncludePath = ''.join([IncludePath, '^', os.sep])\n            else:\n                IncludePath = os.path.join(IncludePath, '')\n            IncludePathList.append(IncludePath)\n        FileMacroList.append(self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'NASM_INC', 'source_file': IncludePathList}))\n    for ListFileMacro in self.ListFileMacros:\n        ListFileName = os.path.join(MyAgo.OutputDir, '%s.lst' % ListFileMacro.lower()[:len(ListFileMacro) - 5])\n        FileMacroList.append('%s = %s' % (ListFileMacro, ListFileName))\n        SaveFileOnChange(ListFileName, '\\n'.join(self.ListFileMacros[ListFileMacro]), False)\n    for Type in self.ObjTargetDict:\n        NewLine = ' '.join(list(self.ObjTargetDict[Type]))\n        FileMacroList.append('OBJLIST_%s = %s' % (list(self.ObjTargetDict.keys()).index(Type), NewLine))\n    BcTargetList = []\n    MakefileName = self.getMakefileName()\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join(D, MakefileName)}\n        LibraryMakeCommandList.append(Command)\n    package_rel_dir = MyAgo.SourceDir\n    current_dir = self.Macros['WORKSPACE']\n    found = False\n    while not found and os.sep in package_rel_dir:\n        index = package_rel_dir.index(os.sep)\n        current_dir = mws.join(current_dir, package_rel_dir[:index])\n        if os.path.exists(current_dir):\n            for fl in os.listdir(current_dir):\n                if fl.endswith('.dec'):\n                    found = True\n                    break\n        package_rel_dir = package_rel_dir[index + 1:]\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'makefile_name': MakefileName, 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'ffs_output_directory': MyAgo.Macros['FFS_OUTPUT_DIR'], 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile.Name, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(self.Macros['WORKSPACE'], MyAgo.SourceDir), 'package_relative_directory': package_rel_dir, 'module_extra_defines': ['%s = %s' % (k, v) for (k, v) in MyAgo.Module.Defines.items()], 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'module_entry_point': ModuleEntryPoint, 'image_entry_point': ImageEntryPoint, 'arch_entry_point': ArchEntryPoint, 'remaining_build_target': self.ResultFileList, 'common_dependency_file': self.CommonFileDependency, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'clean_command': self.GetRemoveDirectoryCommand(['$(OUTPUT_DIR)']), 'cleanall_command': self.GetRemoveDirectoryCommand(['$(DEBUG_DIR)', '$(OUTPUT_DIR)']), 'dependent_library_build_directory': self.LibraryBuildDirectoryList, 'library_build_command': LibraryMakeCommandList, 'file_macro': FileMacroList, 'file_build_target': self.BuildTargetList, 'backward_compatible_target': BcTargetList, 'INCLUDETAG': '\\n'.join([self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'dependency'), self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'deps_target')])}\n    return MakefileTemplateDict",
        "mutated": [
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n    MyAgo = self._AutoGenObject\n    Separator = self._SEP_[self._Platform]\n    if len(MyAgo.SourceFileList) == 0 and len(MyAgo.BinaryFileList) == 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'No files to be built in module [%s, %s, %s]' % (MyAgo.BuildTarget, MyAgo.ToolChain, MyAgo.Arch), ExtraData='[%s]' % str(MyAgo))\n    self.ProcessDependentLibrary()\n    if len(MyAgo.Module.ModuleEntryPointList) > 0:\n        ModuleEntryPoint = MyAgo.Module.ModuleEntryPointList[0]\n    else:\n        ModuleEntryPoint = '_ModuleEntryPoint'\n    ArchEntryPoint = ModuleEntryPoint\n    if MyAgo.Arch == 'EBC':\n        ImageEntryPoint = 'EfiStart'\n    else:\n        ImageEntryPoint = '_ModuleEntryPoint'\n    for (k, v) in MyAgo.Module.Defines.items():\n        if k not in MyAgo.Macros:\n            MyAgo.Macros[k] = v\n    if 'MODULE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['MODULE_ENTRY_POINT'] = ModuleEntryPoint\n    if 'ARCH_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['ARCH_ENTRY_POINT'] = ArchEntryPoint\n    if 'IMAGE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['IMAGE_ENTRY_POINT'] = ImageEntryPoint\n    PCI_COMPRESS_Flag = False\n    for (k, v) in MyAgo.Module.Defines.items():\n        if 'PCI_COMPRESS' == k and 'TRUE' == v:\n            PCI_COMPRESS_Flag = True\n    ToolsDef = []\n    IncPrefix = self._INC_FLAG_[MyAgo.ToolChainFamily]\n    for Tool in sorted(list(MyAgo.BuildOption)):\n        Appended = False\n        for Attr in sorted(list(MyAgo.BuildOption[Tool])):\n            Value = MyAgo.BuildOption[Tool][Attr]\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, Value))\n                Appended = True\n            else:\n                if Tool == 'MAKE':\n                    continue\n                if Attr == 'FLAGS':\n                    Value = RemoveDupOption(Value, IncPrefix, MyAgo.IncludePathList)\n                    if Tool == 'OPTROM' and PCI_COMPRESS_Flag:\n                        ValueList = Value.split()\n                        if ValueList:\n                            for (i, v) in enumerate(ValueList):\n                                if '-e' == v:\n                                    ValueList[i] = '-ec'\n                            Value = ' '.join(ValueList)\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, Value))\n                Appended = True\n        if Appended:\n            ToolsDef.append('')\n    RespDict = self.CommandExceedLimit()\n    RespFileList = os.path.join(MyAgo.OutputDir, 'respfilelist.txt')\n    if RespDict:\n        RespFileListContent = ''\n        for Resp in RespDict:\n            RespFile = os.path.join(MyAgo.OutputDir, str(Resp).lower() + '.txt')\n            StrList = RespDict[Resp].split(' ')\n            UnexpandMacro = []\n            NewStr = []\n            for Str in StrList:\n                if '$' in Str or '-MMD' in Str or '-MF' in Str:\n                    UnexpandMacro.append(Str)\n                else:\n                    NewStr.append(Str)\n            UnexpandMacroStr = ' '.join(UnexpandMacro)\n            NewRespStr = ' '.join(NewStr)\n            SaveFileOnChange(RespFile, NewRespStr, False)\n            ToolsDef.append('%s = %s' % (Resp, UnexpandMacroStr + ' @' + RespFile))\n            RespFileListContent += '@' + RespFile + TAB_LINE_BREAK\n            RespFileListContent += NewRespStr + TAB_LINE_BREAK\n        SaveFileOnChange(RespFileList, RespFileListContent, False)\n    elif os.path.exists(RespFileList):\n        os.remove(RespFileList)\n    self.ResultFileList = [str(T.Target) for T in MyAgo.CodaTargetList]\n    if len(self.ResultFileList) == 0 and len(MyAgo.SourceFileList) != 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Nothing to build', ExtraData='[%s]' % str(MyAgo))\n    self.ProcessBuildTargetList(MyAgo.OutputDir, ToolsDef)\n    self.ParserGenerateFfsCmd()\n    FileMacroList = []\n    for FileListMacro in self.FileListMacros:\n        FileMacro = self._FILE_MACRO_TEMPLATE.Replace({'macro_name': FileListMacro, 'source_file': self.FileListMacros[FileListMacro]})\n        FileMacroList.append(FileMacro)\n    FileMacro = ''\n    IncludePathList = []\n    for P in MyAgo.IncludePathList:\n        IncludePathList.append(IncPrefix + self.PlaceMacro(P, self.Macros))\n        if FileBuildRule.INC_LIST_MACRO in self.ListFileMacros:\n            self.ListFileMacros[FileBuildRule.INC_LIST_MACRO].append(IncPrefix + P)\n    FileMacro += self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'INC', 'source_file': IncludePathList})\n    FileMacroList.append(FileMacro)\n    IncludePathList = []\n    asmsource = [item for item in MyAgo.SourceFileList if item.File.upper().endswith(('.NASM', '.ASM', '.NASMB', 'S'))]\n    if asmsource:\n        for P in MyAgo.IncludePathList:\n            IncludePath = self._INC_FLAG_['NASM'] + self.PlaceMacro(P, self.Macros)\n            if IncludePath.endswith(os.sep):\n                IncludePath = IncludePath.rstrip(os.sep)\n            if P == MyAgo.IncludePathList[-1] and self._Platform == WIN32_PLATFORM and (self._FileType == NMAKE_FILETYPE):\n                IncludePath = ''.join([IncludePath, '^', os.sep])\n            else:\n                IncludePath = os.path.join(IncludePath, '')\n            IncludePathList.append(IncludePath)\n        FileMacroList.append(self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'NASM_INC', 'source_file': IncludePathList}))\n    for ListFileMacro in self.ListFileMacros:\n        ListFileName = os.path.join(MyAgo.OutputDir, '%s.lst' % ListFileMacro.lower()[:len(ListFileMacro) - 5])\n        FileMacroList.append('%s = %s' % (ListFileMacro, ListFileName))\n        SaveFileOnChange(ListFileName, '\\n'.join(self.ListFileMacros[ListFileMacro]), False)\n    for Type in self.ObjTargetDict:\n        NewLine = ' '.join(list(self.ObjTargetDict[Type]))\n        FileMacroList.append('OBJLIST_%s = %s' % (list(self.ObjTargetDict.keys()).index(Type), NewLine))\n    BcTargetList = []\n    MakefileName = self.getMakefileName()\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join(D, MakefileName)}\n        LibraryMakeCommandList.append(Command)\n    package_rel_dir = MyAgo.SourceDir\n    current_dir = self.Macros['WORKSPACE']\n    found = False\n    while not found and os.sep in package_rel_dir:\n        index = package_rel_dir.index(os.sep)\n        current_dir = mws.join(current_dir, package_rel_dir[:index])\n        if os.path.exists(current_dir):\n            for fl in os.listdir(current_dir):\n                if fl.endswith('.dec'):\n                    found = True\n                    break\n        package_rel_dir = package_rel_dir[index + 1:]\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'makefile_name': MakefileName, 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'ffs_output_directory': MyAgo.Macros['FFS_OUTPUT_DIR'], 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile.Name, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(self.Macros['WORKSPACE'], MyAgo.SourceDir), 'package_relative_directory': package_rel_dir, 'module_extra_defines': ['%s = %s' % (k, v) for (k, v) in MyAgo.Module.Defines.items()], 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'module_entry_point': ModuleEntryPoint, 'image_entry_point': ImageEntryPoint, 'arch_entry_point': ArchEntryPoint, 'remaining_build_target': self.ResultFileList, 'common_dependency_file': self.CommonFileDependency, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'clean_command': self.GetRemoveDirectoryCommand(['$(OUTPUT_DIR)']), 'cleanall_command': self.GetRemoveDirectoryCommand(['$(DEBUG_DIR)', '$(OUTPUT_DIR)']), 'dependent_library_build_directory': self.LibraryBuildDirectoryList, 'library_build_command': LibraryMakeCommandList, 'file_macro': FileMacroList, 'file_build_target': self.BuildTargetList, 'backward_compatible_target': BcTargetList, 'INCLUDETAG': '\\n'.join([self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'dependency'), self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'deps_target')])}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    MyAgo = self._AutoGenObject\n    Separator = self._SEP_[self._Platform]\n    if len(MyAgo.SourceFileList) == 0 and len(MyAgo.BinaryFileList) == 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'No files to be built in module [%s, %s, %s]' % (MyAgo.BuildTarget, MyAgo.ToolChain, MyAgo.Arch), ExtraData='[%s]' % str(MyAgo))\n    self.ProcessDependentLibrary()\n    if len(MyAgo.Module.ModuleEntryPointList) > 0:\n        ModuleEntryPoint = MyAgo.Module.ModuleEntryPointList[0]\n    else:\n        ModuleEntryPoint = '_ModuleEntryPoint'\n    ArchEntryPoint = ModuleEntryPoint\n    if MyAgo.Arch == 'EBC':\n        ImageEntryPoint = 'EfiStart'\n    else:\n        ImageEntryPoint = '_ModuleEntryPoint'\n    for (k, v) in MyAgo.Module.Defines.items():\n        if k not in MyAgo.Macros:\n            MyAgo.Macros[k] = v\n    if 'MODULE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['MODULE_ENTRY_POINT'] = ModuleEntryPoint\n    if 'ARCH_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['ARCH_ENTRY_POINT'] = ArchEntryPoint\n    if 'IMAGE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['IMAGE_ENTRY_POINT'] = ImageEntryPoint\n    PCI_COMPRESS_Flag = False\n    for (k, v) in MyAgo.Module.Defines.items():\n        if 'PCI_COMPRESS' == k and 'TRUE' == v:\n            PCI_COMPRESS_Flag = True\n    ToolsDef = []\n    IncPrefix = self._INC_FLAG_[MyAgo.ToolChainFamily]\n    for Tool in sorted(list(MyAgo.BuildOption)):\n        Appended = False\n        for Attr in sorted(list(MyAgo.BuildOption[Tool])):\n            Value = MyAgo.BuildOption[Tool][Attr]\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, Value))\n                Appended = True\n            else:\n                if Tool == 'MAKE':\n                    continue\n                if Attr == 'FLAGS':\n                    Value = RemoveDupOption(Value, IncPrefix, MyAgo.IncludePathList)\n                    if Tool == 'OPTROM' and PCI_COMPRESS_Flag:\n                        ValueList = Value.split()\n                        if ValueList:\n                            for (i, v) in enumerate(ValueList):\n                                if '-e' == v:\n                                    ValueList[i] = '-ec'\n                            Value = ' '.join(ValueList)\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, Value))\n                Appended = True\n        if Appended:\n            ToolsDef.append('')\n    RespDict = self.CommandExceedLimit()\n    RespFileList = os.path.join(MyAgo.OutputDir, 'respfilelist.txt')\n    if RespDict:\n        RespFileListContent = ''\n        for Resp in RespDict:\n            RespFile = os.path.join(MyAgo.OutputDir, str(Resp).lower() + '.txt')\n            StrList = RespDict[Resp].split(' ')\n            UnexpandMacro = []\n            NewStr = []\n            for Str in StrList:\n                if '$' in Str or '-MMD' in Str or '-MF' in Str:\n                    UnexpandMacro.append(Str)\n                else:\n                    NewStr.append(Str)\n            UnexpandMacroStr = ' '.join(UnexpandMacro)\n            NewRespStr = ' '.join(NewStr)\n            SaveFileOnChange(RespFile, NewRespStr, False)\n            ToolsDef.append('%s = %s' % (Resp, UnexpandMacroStr + ' @' + RespFile))\n            RespFileListContent += '@' + RespFile + TAB_LINE_BREAK\n            RespFileListContent += NewRespStr + TAB_LINE_BREAK\n        SaveFileOnChange(RespFileList, RespFileListContent, False)\n    elif os.path.exists(RespFileList):\n        os.remove(RespFileList)\n    self.ResultFileList = [str(T.Target) for T in MyAgo.CodaTargetList]\n    if len(self.ResultFileList) == 0 and len(MyAgo.SourceFileList) != 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Nothing to build', ExtraData='[%s]' % str(MyAgo))\n    self.ProcessBuildTargetList(MyAgo.OutputDir, ToolsDef)\n    self.ParserGenerateFfsCmd()\n    FileMacroList = []\n    for FileListMacro in self.FileListMacros:\n        FileMacro = self._FILE_MACRO_TEMPLATE.Replace({'macro_name': FileListMacro, 'source_file': self.FileListMacros[FileListMacro]})\n        FileMacroList.append(FileMacro)\n    FileMacro = ''\n    IncludePathList = []\n    for P in MyAgo.IncludePathList:\n        IncludePathList.append(IncPrefix + self.PlaceMacro(P, self.Macros))\n        if FileBuildRule.INC_LIST_MACRO in self.ListFileMacros:\n            self.ListFileMacros[FileBuildRule.INC_LIST_MACRO].append(IncPrefix + P)\n    FileMacro += self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'INC', 'source_file': IncludePathList})\n    FileMacroList.append(FileMacro)\n    IncludePathList = []\n    asmsource = [item for item in MyAgo.SourceFileList if item.File.upper().endswith(('.NASM', '.ASM', '.NASMB', 'S'))]\n    if asmsource:\n        for P in MyAgo.IncludePathList:\n            IncludePath = self._INC_FLAG_['NASM'] + self.PlaceMacro(P, self.Macros)\n            if IncludePath.endswith(os.sep):\n                IncludePath = IncludePath.rstrip(os.sep)\n            if P == MyAgo.IncludePathList[-1] and self._Platform == WIN32_PLATFORM and (self._FileType == NMAKE_FILETYPE):\n                IncludePath = ''.join([IncludePath, '^', os.sep])\n            else:\n                IncludePath = os.path.join(IncludePath, '')\n            IncludePathList.append(IncludePath)\n        FileMacroList.append(self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'NASM_INC', 'source_file': IncludePathList}))\n    for ListFileMacro in self.ListFileMacros:\n        ListFileName = os.path.join(MyAgo.OutputDir, '%s.lst' % ListFileMacro.lower()[:len(ListFileMacro) - 5])\n        FileMacroList.append('%s = %s' % (ListFileMacro, ListFileName))\n        SaveFileOnChange(ListFileName, '\\n'.join(self.ListFileMacros[ListFileMacro]), False)\n    for Type in self.ObjTargetDict:\n        NewLine = ' '.join(list(self.ObjTargetDict[Type]))\n        FileMacroList.append('OBJLIST_%s = %s' % (list(self.ObjTargetDict.keys()).index(Type), NewLine))\n    BcTargetList = []\n    MakefileName = self.getMakefileName()\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join(D, MakefileName)}\n        LibraryMakeCommandList.append(Command)\n    package_rel_dir = MyAgo.SourceDir\n    current_dir = self.Macros['WORKSPACE']\n    found = False\n    while not found and os.sep in package_rel_dir:\n        index = package_rel_dir.index(os.sep)\n        current_dir = mws.join(current_dir, package_rel_dir[:index])\n        if os.path.exists(current_dir):\n            for fl in os.listdir(current_dir):\n                if fl.endswith('.dec'):\n                    found = True\n                    break\n        package_rel_dir = package_rel_dir[index + 1:]\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'makefile_name': MakefileName, 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'ffs_output_directory': MyAgo.Macros['FFS_OUTPUT_DIR'], 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile.Name, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(self.Macros['WORKSPACE'], MyAgo.SourceDir), 'package_relative_directory': package_rel_dir, 'module_extra_defines': ['%s = %s' % (k, v) for (k, v) in MyAgo.Module.Defines.items()], 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'module_entry_point': ModuleEntryPoint, 'image_entry_point': ImageEntryPoint, 'arch_entry_point': ArchEntryPoint, 'remaining_build_target': self.ResultFileList, 'common_dependency_file': self.CommonFileDependency, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'clean_command': self.GetRemoveDirectoryCommand(['$(OUTPUT_DIR)']), 'cleanall_command': self.GetRemoveDirectoryCommand(['$(DEBUG_DIR)', '$(OUTPUT_DIR)']), 'dependent_library_build_directory': self.LibraryBuildDirectoryList, 'library_build_command': LibraryMakeCommandList, 'file_macro': FileMacroList, 'file_build_target': self.BuildTargetList, 'backward_compatible_target': BcTargetList, 'INCLUDETAG': '\\n'.join([self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'dependency'), self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'deps_target')])}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    MyAgo = self._AutoGenObject\n    Separator = self._SEP_[self._Platform]\n    if len(MyAgo.SourceFileList) == 0 and len(MyAgo.BinaryFileList) == 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'No files to be built in module [%s, %s, %s]' % (MyAgo.BuildTarget, MyAgo.ToolChain, MyAgo.Arch), ExtraData='[%s]' % str(MyAgo))\n    self.ProcessDependentLibrary()\n    if len(MyAgo.Module.ModuleEntryPointList) > 0:\n        ModuleEntryPoint = MyAgo.Module.ModuleEntryPointList[0]\n    else:\n        ModuleEntryPoint = '_ModuleEntryPoint'\n    ArchEntryPoint = ModuleEntryPoint\n    if MyAgo.Arch == 'EBC':\n        ImageEntryPoint = 'EfiStart'\n    else:\n        ImageEntryPoint = '_ModuleEntryPoint'\n    for (k, v) in MyAgo.Module.Defines.items():\n        if k not in MyAgo.Macros:\n            MyAgo.Macros[k] = v\n    if 'MODULE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['MODULE_ENTRY_POINT'] = ModuleEntryPoint\n    if 'ARCH_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['ARCH_ENTRY_POINT'] = ArchEntryPoint\n    if 'IMAGE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['IMAGE_ENTRY_POINT'] = ImageEntryPoint\n    PCI_COMPRESS_Flag = False\n    for (k, v) in MyAgo.Module.Defines.items():\n        if 'PCI_COMPRESS' == k and 'TRUE' == v:\n            PCI_COMPRESS_Flag = True\n    ToolsDef = []\n    IncPrefix = self._INC_FLAG_[MyAgo.ToolChainFamily]\n    for Tool in sorted(list(MyAgo.BuildOption)):\n        Appended = False\n        for Attr in sorted(list(MyAgo.BuildOption[Tool])):\n            Value = MyAgo.BuildOption[Tool][Attr]\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, Value))\n                Appended = True\n            else:\n                if Tool == 'MAKE':\n                    continue\n                if Attr == 'FLAGS':\n                    Value = RemoveDupOption(Value, IncPrefix, MyAgo.IncludePathList)\n                    if Tool == 'OPTROM' and PCI_COMPRESS_Flag:\n                        ValueList = Value.split()\n                        if ValueList:\n                            for (i, v) in enumerate(ValueList):\n                                if '-e' == v:\n                                    ValueList[i] = '-ec'\n                            Value = ' '.join(ValueList)\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, Value))\n                Appended = True\n        if Appended:\n            ToolsDef.append('')\n    RespDict = self.CommandExceedLimit()\n    RespFileList = os.path.join(MyAgo.OutputDir, 'respfilelist.txt')\n    if RespDict:\n        RespFileListContent = ''\n        for Resp in RespDict:\n            RespFile = os.path.join(MyAgo.OutputDir, str(Resp).lower() + '.txt')\n            StrList = RespDict[Resp].split(' ')\n            UnexpandMacro = []\n            NewStr = []\n            for Str in StrList:\n                if '$' in Str or '-MMD' in Str or '-MF' in Str:\n                    UnexpandMacro.append(Str)\n                else:\n                    NewStr.append(Str)\n            UnexpandMacroStr = ' '.join(UnexpandMacro)\n            NewRespStr = ' '.join(NewStr)\n            SaveFileOnChange(RespFile, NewRespStr, False)\n            ToolsDef.append('%s = %s' % (Resp, UnexpandMacroStr + ' @' + RespFile))\n            RespFileListContent += '@' + RespFile + TAB_LINE_BREAK\n            RespFileListContent += NewRespStr + TAB_LINE_BREAK\n        SaveFileOnChange(RespFileList, RespFileListContent, False)\n    elif os.path.exists(RespFileList):\n        os.remove(RespFileList)\n    self.ResultFileList = [str(T.Target) for T in MyAgo.CodaTargetList]\n    if len(self.ResultFileList) == 0 and len(MyAgo.SourceFileList) != 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Nothing to build', ExtraData='[%s]' % str(MyAgo))\n    self.ProcessBuildTargetList(MyAgo.OutputDir, ToolsDef)\n    self.ParserGenerateFfsCmd()\n    FileMacroList = []\n    for FileListMacro in self.FileListMacros:\n        FileMacro = self._FILE_MACRO_TEMPLATE.Replace({'macro_name': FileListMacro, 'source_file': self.FileListMacros[FileListMacro]})\n        FileMacroList.append(FileMacro)\n    FileMacro = ''\n    IncludePathList = []\n    for P in MyAgo.IncludePathList:\n        IncludePathList.append(IncPrefix + self.PlaceMacro(P, self.Macros))\n        if FileBuildRule.INC_LIST_MACRO in self.ListFileMacros:\n            self.ListFileMacros[FileBuildRule.INC_LIST_MACRO].append(IncPrefix + P)\n    FileMacro += self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'INC', 'source_file': IncludePathList})\n    FileMacroList.append(FileMacro)\n    IncludePathList = []\n    asmsource = [item for item in MyAgo.SourceFileList if item.File.upper().endswith(('.NASM', '.ASM', '.NASMB', 'S'))]\n    if asmsource:\n        for P in MyAgo.IncludePathList:\n            IncludePath = self._INC_FLAG_['NASM'] + self.PlaceMacro(P, self.Macros)\n            if IncludePath.endswith(os.sep):\n                IncludePath = IncludePath.rstrip(os.sep)\n            if P == MyAgo.IncludePathList[-1] and self._Platform == WIN32_PLATFORM and (self._FileType == NMAKE_FILETYPE):\n                IncludePath = ''.join([IncludePath, '^', os.sep])\n            else:\n                IncludePath = os.path.join(IncludePath, '')\n            IncludePathList.append(IncludePath)\n        FileMacroList.append(self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'NASM_INC', 'source_file': IncludePathList}))\n    for ListFileMacro in self.ListFileMacros:\n        ListFileName = os.path.join(MyAgo.OutputDir, '%s.lst' % ListFileMacro.lower()[:len(ListFileMacro) - 5])\n        FileMacroList.append('%s = %s' % (ListFileMacro, ListFileName))\n        SaveFileOnChange(ListFileName, '\\n'.join(self.ListFileMacros[ListFileMacro]), False)\n    for Type in self.ObjTargetDict:\n        NewLine = ' '.join(list(self.ObjTargetDict[Type]))\n        FileMacroList.append('OBJLIST_%s = %s' % (list(self.ObjTargetDict.keys()).index(Type), NewLine))\n    BcTargetList = []\n    MakefileName = self.getMakefileName()\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join(D, MakefileName)}\n        LibraryMakeCommandList.append(Command)\n    package_rel_dir = MyAgo.SourceDir\n    current_dir = self.Macros['WORKSPACE']\n    found = False\n    while not found and os.sep in package_rel_dir:\n        index = package_rel_dir.index(os.sep)\n        current_dir = mws.join(current_dir, package_rel_dir[:index])\n        if os.path.exists(current_dir):\n            for fl in os.listdir(current_dir):\n                if fl.endswith('.dec'):\n                    found = True\n                    break\n        package_rel_dir = package_rel_dir[index + 1:]\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'makefile_name': MakefileName, 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'ffs_output_directory': MyAgo.Macros['FFS_OUTPUT_DIR'], 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile.Name, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(self.Macros['WORKSPACE'], MyAgo.SourceDir), 'package_relative_directory': package_rel_dir, 'module_extra_defines': ['%s = %s' % (k, v) for (k, v) in MyAgo.Module.Defines.items()], 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'module_entry_point': ModuleEntryPoint, 'image_entry_point': ImageEntryPoint, 'arch_entry_point': ArchEntryPoint, 'remaining_build_target': self.ResultFileList, 'common_dependency_file': self.CommonFileDependency, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'clean_command': self.GetRemoveDirectoryCommand(['$(OUTPUT_DIR)']), 'cleanall_command': self.GetRemoveDirectoryCommand(['$(DEBUG_DIR)', '$(OUTPUT_DIR)']), 'dependent_library_build_directory': self.LibraryBuildDirectoryList, 'library_build_command': LibraryMakeCommandList, 'file_macro': FileMacroList, 'file_build_target': self.BuildTargetList, 'backward_compatible_target': BcTargetList, 'INCLUDETAG': '\\n'.join([self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'dependency'), self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'deps_target')])}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    MyAgo = self._AutoGenObject\n    Separator = self._SEP_[self._Platform]\n    if len(MyAgo.SourceFileList) == 0 and len(MyAgo.BinaryFileList) == 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'No files to be built in module [%s, %s, %s]' % (MyAgo.BuildTarget, MyAgo.ToolChain, MyAgo.Arch), ExtraData='[%s]' % str(MyAgo))\n    self.ProcessDependentLibrary()\n    if len(MyAgo.Module.ModuleEntryPointList) > 0:\n        ModuleEntryPoint = MyAgo.Module.ModuleEntryPointList[0]\n    else:\n        ModuleEntryPoint = '_ModuleEntryPoint'\n    ArchEntryPoint = ModuleEntryPoint\n    if MyAgo.Arch == 'EBC':\n        ImageEntryPoint = 'EfiStart'\n    else:\n        ImageEntryPoint = '_ModuleEntryPoint'\n    for (k, v) in MyAgo.Module.Defines.items():\n        if k not in MyAgo.Macros:\n            MyAgo.Macros[k] = v\n    if 'MODULE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['MODULE_ENTRY_POINT'] = ModuleEntryPoint\n    if 'ARCH_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['ARCH_ENTRY_POINT'] = ArchEntryPoint\n    if 'IMAGE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['IMAGE_ENTRY_POINT'] = ImageEntryPoint\n    PCI_COMPRESS_Flag = False\n    for (k, v) in MyAgo.Module.Defines.items():\n        if 'PCI_COMPRESS' == k and 'TRUE' == v:\n            PCI_COMPRESS_Flag = True\n    ToolsDef = []\n    IncPrefix = self._INC_FLAG_[MyAgo.ToolChainFamily]\n    for Tool in sorted(list(MyAgo.BuildOption)):\n        Appended = False\n        for Attr in sorted(list(MyAgo.BuildOption[Tool])):\n            Value = MyAgo.BuildOption[Tool][Attr]\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, Value))\n                Appended = True\n            else:\n                if Tool == 'MAKE':\n                    continue\n                if Attr == 'FLAGS':\n                    Value = RemoveDupOption(Value, IncPrefix, MyAgo.IncludePathList)\n                    if Tool == 'OPTROM' and PCI_COMPRESS_Flag:\n                        ValueList = Value.split()\n                        if ValueList:\n                            for (i, v) in enumerate(ValueList):\n                                if '-e' == v:\n                                    ValueList[i] = '-ec'\n                            Value = ' '.join(ValueList)\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, Value))\n                Appended = True\n        if Appended:\n            ToolsDef.append('')\n    RespDict = self.CommandExceedLimit()\n    RespFileList = os.path.join(MyAgo.OutputDir, 'respfilelist.txt')\n    if RespDict:\n        RespFileListContent = ''\n        for Resp in RespDict:\n            RespFile = os.path.join(MyAgo.OutputDir, str(Resp).lower() + '.txt')\n            StrList = RespDict[Resp].split(' ')\n            UnexpandMacro = []\n            NewStr = []\n            for Str in StrList:\n                if '$' in Str or '-MMD' in Str or '-MF' in Str:\n                    UnexpandMacro.append(Str)\n                else:\n                    NewStr.append(Str)\n            UnexpandMacroStr = ' '.join(UnexpandMacro)\n            NewRespStr = ' '.join(NewStr)\n            SaveFileOnChange(RespFile, NewRespStr, False)\n            ToolsDef.append('%s = %s' % (Resp, UnexpandMacroStr + ' @' + RespFile))\n            RespFileListContent += '@' + RespFile + TAB_LINE_BREAK\n            RespFileListContent += NewRespStr + TAB_LINE_BREAK\n        SaveFileOnChange(RespFileList, RespFileListContent, False)\n    elif os.path.exists(RespFileList):\n        os.remove(RespFileList)\n    self.ResultFileList = [str(T.Target) for T in MyAgo.CodaTargetList]\n    if len(self.ResultFileList) == 0 and len(MyAgo.SourceFileList) != 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Nothing to build', ExtraData='[%s]' % str(MyAgo))\n    self.ProcessBuildTargetList(MyAgo.OutputDir, ToolsDef)\n    self.ParserGenerateFfsCmd()\n    FileMacroList = []\n    for FileListMacro in self.FileListMacros:\n        FileMacro = self._FILE_MACRO_TEMPLATE.Replace({'macro_name': FileListMacro, 'source_file': self.FileListMacros[FileListMacro]})\n        FileMacroList.append(FileMacro)\n    FileMacro = ''\n    IncludePathList = []\n    for P in MyAgo.IncludePathList:\n        IncludePathList.append(IncPrefix + self.PlaceMacro(P, self.Macros))\n        if FileBuildRule.INC_LIST_MACRO in self.ListFileMacros:\n            self.ListFileMacros[FileBuildRule.INC_LIST_MACRO].append(IncPrefix + P)\n    FileMacro += self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'INC', 'source_file': IncludePathList})\n    FileMacroList.append(FileMacro)\n    IncludePathList = []\n    asmsource = [item for item in MyAgo.SourceFileList if item.File.upper().endswith(('.NASM', '.ASM', '.NASMB', 'S'))]\n    if asmsource:\n        for P in MyAgo.IncludePathList:\n            IncludePath = self._INC_FLAG_['NASM'] + self.PlaceMacro(P, self.Macros)\n            if IncludePath.endswith(os.sep):\n                IncludePath = IncludePath.rstrip(os.sep)\n            if P == MyAgo.IncludePathList[-1] and self._Platform == WIN32_PLATFORM and (self._FileType == NMAKE_FILETYPE):\n                IncludePath = ''.join([IncludePath, '^', os.sep])\n            else:\n                IncludePath = os.path.join(IncludePath, '')\n            IncludePathList.append(IncludePath)\n        FileMacroList.append(self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'NASM_INC', 'source_file': IncludePathList}))\n    for ListFileMacro in self.ListFileMacros:\n        ListFileName = os.path.join(MyAgo.OutputDir, '%s.lst' % ListFileMacro.lower()[:len(ListFileMacro) - 5])\n        FileMacroList.append('%s = %s' % (ListFileMacro, ListFileName))\n        SaveFileOnChange(ListFileName, '\\n'.join(self.ListFileMacros[ListFileMacro]), False)\n    for Type in self.ObjTargetDict:\n        NewLine = ' '.join(list(self.ObjTargetDict[Type]))\n        FileMacroList.append('OBJLIST_%s = %s' % (list(self.ObjTargetDict.keys()).index(Type), NewLine))\n    BcTargetList = []\n    MakefileName = self.getMakefileName()\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join(D, MakefileName)}\n        LibraryMakeCommandList.append(Command)\n    package_rel_dir = MyAgo.SourceDir\n    current_dir = self.Macros['WORKSPACE']\n    found = False\n    while not found and os.sep in package_rel_dir:\n        index = package_rel_dir.index(os.sep)\n        current_dir = mws.join(current_dir, package_rel_dir[:index])\n        if os.path.exists(current_dir):\n            for fl in os.listdir(current_dir):\n                if fl.endswith('.dec'):\n                    found = True\n                    break\n        package_rel_dir = package_rel_dir[index + 1:]\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'makefile_name': MakefileName, 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'ffs_output_directory': MyAgo.Macros['FFS_OUTPUT_DIR'], 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile.Name, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(self.Macros['WORKSPACE'], MyAgo.SourceDir), 'package_relative_directory': package_rel_dir, 'module_extra_defines': ['%s = %s' % (k, v) for (k, v) in MyAgo.Module.Defines.items()], 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'module_entry_point': ModuleEntryPoint, 'image_entry_point': ImageEntryPoint, 'arch_entry_point': ArchEntryPoint, 'remaining_build_target': self.ResultFileList, 'common_dependency_file': self.CommonFileDependency, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'clean_command': self.GetRemoveDirectoryCommand(['$(OUTPUT_DIR)']), 'cleanall_command': self.GetRemoveDirectoryCommand(['$(DEBUG_DIR)', '$(OUTPUT_DIR)']), 'dependent_library_build_directory': self.LibraryBuildDirectoryList, 'library_build_command': LibraryMakeCommandList, 'file_macro': FileMacroList, 'file_build_target': self.BuildTargetList, 'backward_compatible_target': BcTargetList, 'INCLUDETAG': '\\n'.join([self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'dependency'), self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'deps_target')])}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    MyAgo = self._AutoGenObject\n    Separator = self._SEP_[self._Platform]\n    if len(MyAgo.SourceFileList) == 0 and len(MyAgo.BinaryFileList) == 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'No files to be built in module [%s, %s, %s]' % (MyAgo.BuildTarget, MyAgo.ToolChain, MyAgo.Arch), ExtraData='[%s]' % str(MyAgo))\n    self.ProcessDependentLibrary()\n    if len(MyAgo.Module.ModuleEntryPointList) > 0:\n        ModuleEntryPoint = MyAgo.Module.ModuleEntryPointList[0]\n    else:\n        ModuleEntryPoint = '_ModuleEntryPoint'\n    ArchEntryPoint = ModuleEntryPoint\n    if MyAgo.Arch == 'EBC':\n        ImageEntryPoint = 'EfiStart'\n    else:\n        ImageEntryPoint = '_ModuleEntryPoint'\n    for (k, v) in MyAgo.Module.Defines.items():\n        if k not in MyAgo.Macros:\n            MyAgo.Macros[k] = v\n    if 'MODULE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['MODULE_ENTRY_POINT'] = ModuleEntryPoint\n    if 'ARCH_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['ARCH_ENTRY_POINT'] = ArchEntryPoint\n    if 'IMAGE_ENTRY_POINT' not in MyAgo.Macros:\n        MyAgo.Macros['IMAGE_ENTRY_POINT'] = ImageEntryPoint\n    PCI_COMPRESS_Flag = False\n    for (k, v) in MyAgo.Module.Defines.items():\n        if 'PCI_COMPRESS' == k and 'TRUE' == v:\n            PCI_COMPRESS_Flag = True\n    ToolsDef = []\n    IncPrefix = self._INC_FLAG_[MyAgo.ToolChainFamily]\n    for Tool in sorted(list(MyAgo.BuildOption)):\n        Appended = False\n        for Attr in sorted(list(MyAgo.BuildOption[Tool])):\n            Value = MyAgo.BuildOption[Tool][Attr]\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, Value))\n                Appended = True\n            else:\n                if Tool == 'MAKE':\n                    continue\n                if Attr == 'FLAGS':\n                    Value = RemoveDupOption(Value, IncPrefix, MyAgo.IncludePathList)\n                    if Tool == 'OPTROM' and PCI_COMPRESS_Flag:\n                        ValueList = Value.split()\n                        if ValueList:\n                            for (i, v) in enumerate(ValueList):\n                                if '-e' == v:\n                                    ValueList[i] = '-ec'\n                            Value = ' '.join(ValueList)\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, Value))\n                Appended = True\n        if Appended:\n            ToolsDef.append('')\n    RespDict = self.CommandExceedLimit()\n    RespFileList = os.path.join(MyAgo.OutputDir, 'respfilelist.txt')\n    if RespDict:\n        RespFileListContent = ''\n        for Resp in RespDict:\n            RespFile = os.path.join(MyAgo.OutputDir, str(Resp).lower() + '.txt')\n            StrList = RespDict[Resp].split(' ')\n            UnexpandMacro = []\n            NewStr = []\n            for Str in StrList:\n                if '$' in Str or '-MMD' in Str or '-MF' in Str:\n                    UnexpandMacro.append(Str)\n                else:\n                    NewStr.append(Str)\n            UnexpandMacroStr = ' '.join(UnexpandMacro)\n            NewRespStr = ' '.join(NewStr)\n            SaveFileOnChange(RespFile, NewRespStr, False)\n            ToolsDef.append('%s = %s' % (Resp, UnexpandMacroStr + ' @' + RespFile))\n            RespFileListContent += '@' + RespFile + TAB_LINE_BREAK\n            RespFileListContent += NewRespStr + TAB_LINE_BREAK\n        SaveFileOnChange(RespFileList, RespFileListContent, False)\n    elif os.path.exists(RespFileList):\n        os.remove(RespFileList)\n    self.ResultFileList = [str(T.Target) for T in MyAgo.CodaTargetList]\n    if len(self.ResultFileList) == 0 and len(MyAgo.SourceFileList) != 0:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Nothing to build', ExtraData='[%s]' % str(MyAgo))\n    self.ProcessBuildTargetList(MyAgo.OutputDir, ToolsDef)\n    self.ParserGenerateFfsCmd()\n    FileMacroList = []\n    for FileListMacro in self.FileListMacros:\n        FileMacro = self._FILE_MACRO_TEMPLATE.Replace({'macro_name': FileListMacro, 'source_file': self.FileListMacros[FileListMacro]})\n        FileMacroList.append(FileMacro)\n    FileMacro = ''\n    IncludePathList = []\n    for P in MyAgo.IncludePathList:\n        IncludePathList.append(IncPrefix + self.PlaceMacro(P, self.Macros))\n        if FileBuildRule.INC_LIST_MACRO in self.ListFileMacros:\n            self.ListFileMacros[FileBuildRule.INC_LIST_MACRO].append(IncPrefix + P)\n    FileMacro += self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'INC', 'source_file': IncludePathList})\n    FileMacroList.append(FileMacro)\n    IncludePathList = []\n    asmsource = [item for item in MyAgo.SourceFileList if item.File.upper().endswith(('.NASM', '.ASM', '.NASMB', 'S'))]\n    if asmsource:\n        for P in MyAgo.IncludePathList:\n            IncludePath = self._INC_FLAG_['NASM'] + self.PlaceMacro(P, self.Macros)\n            if IncludePath.endswith(os.sep):\n                IncludePath = IncludePath.rstrip(os.sep)\n            if P == MyAgo.IncludePathList[-1] and self._Platform == WIN32_PLATFORM and (self._FileType == NMAKE_FILETYPE):\n                IncludePath = ''.join([IncludePath, '^', os.sep])\n            else:\n                IncludePath = os.path.join(IncludePath, '')\n            IncludePathList.append(IncludePath)\n        FileMacroList.append(self._FILE_MACRO_TEMPLATE.Replace({'macro_name': 'NASM_INC', 'source_file': IncludePathList}))\n    for ListFileMacro in self.ListFileMacros:\n        ListFileName = os.path.join(MyAgo.OutputDir, '%s.lst' % ListFileMacro.lower()[:len(ListFileMacro) - 5])\n        FileMacroList.append('%s = %s' % (ListFileMacro, ListFileName))\n        SaveFileOnChange(ListFileName, '\\n'.join(self.ListFileMacros[ListFileMacro]), False)\n    for Type in self.ObjTargetDict:\n        NewLine = ' '.join(list(self.ObjTargetDict[Type]))\n        FileMacroList.append('OBJLIST_%s = %s' % (list(self.ObjTargetDict.keys()).index(Type), NewLine))\n    BcTargetList = []\n    MakefileName = self.getMakefileName()\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join(D, MakefileName)}\n        LibraryMakeCommandList.append(Command)\n    package_rel_dir = MyAgo.SourceDir\n    current_dir = self.Macros['WORKSPACE']\n    found = False\n    while not found and os.sep in package_rel_dir:\n        index = package_rel_dir.index(os.sep)\n        current_dir = mws.join(current_dir, package_rel_dir[:index])\n        if os.path.exists(current_dir):\n            for fl in os.listdir(current_dir):\n                if fl.endswith('.dec'):\n                    found = True\n                    break\n        package_rel_dir = package_rel_dir[index + 1:]\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'makefile_name': MakefileName, 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'ffs_output_directory': MyAgo.Macros['FFS_OUTPUT_DIR'], 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile.Name, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(self.Macros['WORKSPACE'], MyAgo.SourceDir), 'package_relative_directory': package_rel_dir, 'module_extra_defines': ['%s = %s' % (k, v) for (k, v) in MyAgo.Module.Defines.items()], 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'module_entry_point': ModuleEntryPoint, 'image_entry_point': ImageEntryPoint, 'arch_entry_point': ArchEntryPoint, 'remaining_build_target': self.ResultFileList, 'common_dependency_file': self.CommonFileDependency, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'clean_command': self.GetRemoveDirectoryCommand(['$(OUTPUT_DIR)']), 'cleanall_command': self.GetRemoveDirectoryCommand(['$(DEBUG_DIR)', '$(OUTPUT_DIR)']), 'dependent_library_build_directory': self.LibraryBuildDirectoryList, 'library_build_command': LibraryMakeCommandList, 'file_macro': FileMacroList, 'file_build_target': self.BuildTargetList, 'backward_compatible_target': BcTargetList, 'INCLUDETAG': '\\n'.join([self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'dependency'), self._INCLUDE_CMD_[self._FileType] + ' ' + os.path.join('$(MODULE_BUILD_DIR)', 'deps_target')])}\n    return MakefileTemplateDict"
        ]
    },
    {
        "func_name": "ParserGenerateFfsCmd",
        "original": "def ParserGenerateFfsCmd(self):\n    OutputFile = ''\n    DepsFileList = []\n    for Cmd in self.GenFfsList:\n        if Cmd[2]:\n            for CopyCmd in Cmd[2]:\n                (Src, Dst) = CopyCmd\n                Src = self.ReplaceMacro(Src)\n                Dst = self.ReplaceMacro(Dst)\n                if Dst not in self.ResultFileList:\n                    self.ResultFileList.append(Dst)\n                if '%s :' % Dst not in self.BuildTargetList:\n                    self.BuildTargetList.append('%s : %s' % (Dst, Src))\n                    self.BuildTargetList.append('\\t' + self._CP_TEMPLATE_[self._Platform] % {'Src': Src, 'Dst': Dst})\n        FfsCmdList = Cmd[0]\n        for (index, Str) in enumerate(FfsCmdList):\n            if '-o' == Str:\n                OutputFile = FfsCmdList[index + 1]\n            if '-i' == Str or '-oi' == Str:\n                if DepsFileList == []:\n                    DepsFileList = [FfsCmdList[index + 1]]\n                else:\n                    DepsFileList.append(FfsCmdList[index + 1])\n        DepsFileString = ' '.join(DepsFileList).strip()\n        if DepsFileString == '':\n            continue\n        OutputFile = self.ReplaceMacro(OutputFile)\n        self.ResultFileList.append(OutputFile)\n        DepsFileString = self.ReplaceMacro(DepsFileString)\n        self.BuildTargetList.append('%s : %s' % (OutputFile, DepsFileString))\n        CmdString = ' '.join(FfsCmdList).strip()\n        CmdString = self.ReplaceMacro(CmdString)\n        self.BuildTargetList.append('\\t%s' % CmdString)\n        self.ParseSecCmd(DepsFileList, Cmd[1])\n        for (SecOutputFile, SecDepsFile, SecCmd) in self.FfsOutputFileList:\n            self.BuildTargetList.append('%s : %s' % (self.ReplaceMacro(SecOutputFile), self.ReplaceMacro(SecDepsFile)))\n            self.BuildTargetList.append('\\t%s' % self.ReplaceMacro(SecCmd))\n        self.FfsOutputFileList = []",
        "mutated": [
            "def ParserGenerateFfsCmd(self):\n    if False:\n        i = 10\n    OutputFile = ''\n    DepsFileList = []\n    for Cmd in self.GenFfsList:\n        if Cmd[2]:\n            for CopyCmd in Cmd[2]:\n                (Src, Dst) = CopyCmd\n                Src = self.ReplaceMacro(Src)\n                Dst = self.ReplaceMacro(Dst)\n                if Dst not in self.ResultFileList:\n                    self.ResultFileList.append(Dst)\n                if '%s :' % Dst not in self.BuildTargetList:\n                    self.BuildTargetList.append('%s : %s' % (Dst, Src))\n                    self.BuildTargetList.append('\\t' + self._CP_TEMPLATE_[self._Platform] % {'Src': Src, 'Dst': Dst})\n        FfsCmdList = Cmd[0]\n        for (index, Str) in enumerate(FfsCmdList):\n            if '-o' == Str:\n                OutputFile = FfsCmdList[index + 1]\n            if '-i' == Str or '-oi' == Str:\n                if DepsFileList == []:\n                    DepsFileList = [FfsCmdList[index + 1]]\n                else:\n                    DepsFileList.append(FfsCmdList[index + 1])\n        DepsFileString = ' '.join(DepsFileList).strip()\n        if DepsFileString == '':\n            continue\n        OutputFile = self.ReplaceMacro(OutputFile)\n        self.ResultFileList.append(OutputFile)\n        DepsFileString = self.ReplaceMacro(DepsFileString)\n        self.BuildTargetList.append('%s : %s' % (OutputFile, DepsFileString))\n        CmdString = ' '.join(FfsCmdList).strip()\n        CmdString = self.ReplaceMacro(CmdString)\n        self.BuildTargetList.append('\\t%s' % CmdString)\n        self.ParseSecCmd(DepsFileList, Cmd[1])\n        for (SecOutputFile, SecDepsFile, SecCmd) in self.FfsOutputFileList:\n            self.BuildTargetList.append('%s : %s' % (self.ReplaceMacro(SecOutputFile), self.ReplaceMacro(SecDepsFile)))\n            self.BuildTargetList.append('\\t%s' % self.ReplaceMacro(SecCmd))\n        self.FfsOutputFileList = []",
            "def ParserGenerateFfsCmd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    OutputFile = ''\n    DepsFileList = []\n    for Cmd in self.GenFfsList:\n        if Cmd[2]:\n            for CopyCmd in Cmd[2]:\n                (Src, Dst) = CopyCmd\n                Src = self.ReplaceMacro(Src)\n                Dst = self.ReplaceMacro(Dst)\n                if Dst not in self.ResultFileList:\n                    self.ResultFileList.append(Dst)\n                if '%s :' % Dst not in self.BuildTargetList:\n                    self.BuildTargetList.append('%s : %s' % (Dst, Src))\n                    self.BuildTargetList.append('\\t' + self._CP_TEMPLATE_[self._Platform] % {'Src': Src, 'Dst': Dst})\n        FfsCmdList = Cmd[0]\n        for (index, Str) in enumerate(FfsCmdList):\n            if '-o' == Str:\n                OutputFile = FfsCmdList[index + 1]\n            if '-i' == Str or '-oi' == Str:\n                if DepsFileList == []:\n                    DepsFileList = [FfsCmdList[index + 1]]\n                else:\n                    DepsFileList.append(FfsCmdList[index + 1])\n        DepsFileString = ' '.join(DepsFileList).strip()\n        if DepsFileString == '':\n            continue\n        OutputFile = self.ReplaceMacro(OutputFile)\n        self.ResultFileList.append(OutputFile)\n        DepsFileString = self.ReplaceMacro(DepsFileString)\n        self.BuildTargetList.append('%s : %s' % (OutputFile, DepsFileString))\n        CmdString = ' '.join(FfsCmdList).strip()\n        CmdString = self.ReplaceMacro(CmdString)\n        self.BuildTargetList.append('\\t%s' % CmdString)\n        self.ParseSecCmd(DepsFileList, Cmd[1])\n        for (SecOutputFile, SecDepsFile, SecCmd) in self.FfsOutputFileList:\n            self.BuildTargetList.append('%s : %s' % (self.ReplaceMacro(SecOutputFile), self.ReplaceMacro(SecDepsFile)))\n            self.BuildTargetList.append('\\t%s' % self.ReplaceMacro(SecCmd))\n        self.FfsOutputFileList = []",
            "def ParserGenerateFfsCmd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    OutputFile = ''\n    DepsFileList = []\n    for Cmd in self.GenFfsList:\n        if Cmd[2]:\n            for CopyCmd in Cmd[2]:\n                (Src, Dst) = CopyCmd\n                Src = self.ReplaceMacro(Src)\n                Dst = self.ReplaceMacro(Dst)\n                if Dst not in self.ResultFileList:\n                    self.ResultFileList.append(Dst)\n                if '%s :' % Dst not in self.BuildTargetList:\n                    self.BuildTargetList.append('%s : %s' % (Dst, Src))\n                    self.BuildTargetList.append('\\t' + self._CP_TEMPLATE_[self._Platform] % {'Src': Src, 'Dst': Dst})\n        FfsCmdList = Cmd[0]\n        for (index, Str) in enumerate(FfsCmdList):\n            if '-o' == Str:\n                OutputFile = FfsCmdList[index + 1]\n            if '-i' == Str or '-oi' == Str:\n                if DepsFileList == []:\n                    DepsFileList = [FfsCmdList[index + 1]]\n                else:\n                    DepsFileList.append(FfsCmdList[index + 1])\n        DepsFileString = ' '.join(DepsFileList).strip()\n        if DepsFileString == '':\n            continue\n        OutputFile = self.ReplaceMacro(OutputFile)\n        self.ResultFileList.append(OutputFile)\n        DepsFileString = self.ReplaceMacro(DepsFileString)\n        self.BuildTargetList.append('%s : %s' % (OutputFile, DepsFileString))\n        CmdString = ' '.join(FfsCmdList).strip()\n        CmdString = self.ReplaceMacro(CmdString)\n        self.BuildTargetList.append('\\t%s' % CmdString)\n        self.ParseSecCmd(DepsFileList, Cmd[1])\n        for (SecOutputFile, SecDepsFile, SecCmd) in self.FfsOutputFileList:\n            self.BuildTargetList.append('%s : %s' % (self.ReplaceMacro(SecOutputFile), self.ReplaceMacro(SecDepsFile)))\n            self.BuildTargetList.append('\\t%s' % self.ReplaceMacro(SecCmd))\n        self.FfsOutputFileList = []",
            "def ParserGenerateFfsCmd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    OutputFile = ''\n    DepsFileList = []\n    for Cmd in self.GenFfsList:\n        if Cmd[2]:\n            for CopyCmd in Cmd[2]:\n                (Src, Dst) = CopyCmd\n                Src = self.ReplaceMacro(Src)\n                Dst = self.ReplaceMacro(Dst)\n                if Dst not in self.ResultFileList:\n                    self.ResultFileList.append(Dst)\n                if '%s :' % Dst not in self.BuildTargetList:\n                    self.BuildTargetList.append('%s : %s' % (Dst, Src))\n                    self.BuildTargetList.append('\\t' + self._CP_TEMPLATE_[self._Platform] % {'Src': Src, 'Dst': Dst})\n        FfsCmdList = Cmd[0]\n        for (index, Str) in enumerate(FfsCmdList):\n            if '-o' == Str:\n                OutputFile = FfsCmdList[index + 1]\n            if '-i' == Str or '-oi' == Str:\n                if DepsFileList == []:\n                    DepsFileList = [FfsCmdList[index + 1]]\n                else:\n                    DepsFileList.append(FfsCmdList[index + 1])\n        DepsFileString = ' '.join(DepsFileList).strip()\n        if DepsFileString == '':\n            continue\n        OutputFile = self.ReplaceMacro(OutputFile)\n        self.ResultFileList.append(OutputFile)\n        DepsFileString = self.ReplaceMacro(DepsFileString)\n        self.BuildTargetList.append('%s : %s' % (OutputFile, DepsFileString))\n        CmdString = ' '.join(FfsCmdList).strip()\n        CmdString = self.ReplaceMacro(CmdString)\n        self.BuildTargetList.append('\\t%s' % CmdString)\n        self.ParseSecCmd(DepsFileList, Cmd[1])\n        for (SecOutputFile, SecDepsFile, SecCmd) in self.FfsOutputFileList:\n            self.BuildTargetList.append('%s : %s' % (self.ReplaceMacro(SecOutputFile), self.ReplaceMacro(SecDepsFile)))\n            self.BuildTargetList.append('\\t%s' % self.ReplaceMacro(SecCmd))\n        self.FfsOutputFileList = []",
            "def ParserGenerateFfsCmd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    OutputFile = ''\n    DepsFileList = []\n    for Cmd in self.GenFfsList:\n        if Cmd[2]:\n            for CopyCmd in Cmd[2]:\n                (Src, Dst) = CopyCmd\n                Src = self.ReplaceMacro(Src)\n                Dst = self.ReplaceMacro(Dst)\n                if Dst not in self.ResultFileList:\n                    self.ResultFileList.append(Dst)\n                if '%s :' % Dst not in self.BuildTargetList:\n                    self.BuildTargetList.append('%s : %s' % (Dst, Src))\n                    self.BuildTargetList.append('\\t' + self._CP_TEMPLATE_[self._Platform] % {'Src': Src, 'Dst': Dst})\n        FfsCmdList = Cmd[0]\n        for (index, Str) in enumerate(FfsCmdList):\n            if '-o' == Str:\n                OutputFile = FfsCmdList[index + 1]\n            if '-i' == Str or '-oi' == Str:\n                if DepsFileList == []:\n                    DepsFileList = [FfsCmdList[index + 1]]\n                else:\n                    DepsFileList.append(FfsCmdList[index + 1])\n        DepsFileString = ' '.join(DepsFileList).strip()\n        if DepsFileString == '':\n            continue\n        OutputFile = self.ReplaceMacro(OutputFile)\n        self.ResultFileList.append(OutputFile)\n        DepsFileString = self.ReplaceMacro(DepsFileString)\n        self.BuildTargetList.append('%s : %s' % (OutputFile, DepsFileString))\n        CmdString = ' '.join(FfsCmdList).strip()\n        CmdString = self.ReplaceMacro(CmdString)\n        self.BuildTargetList.append('\\t%s' % CmdString)\n        self.ParseSecCmd(DepsFileList, Cmd[1])\n        for (SecOutputFile, SecDepsFile, SecCmd) in self.FfsOutputFileList:\n            self.BuildTargetList.append('%s : %s' % (self.ReplaceMacro(SecOutputFile), self.ReplaceMacro(SecDepsFile)))\n            self.BuildTargetList.append('\\t%s' % self.ReplaceMacro(SecCmd))\n        self.FfsOutputFileList = []"
        ]
    },
    {
        "func_name": "ParseSecCmd",
        "original": "def ParseSecCmd(self, OutputFileList, CmdTuple):\n    for OutputFile in OutputFileList:\n        for SecCmdStr in CmdTuple:\n            SecDepsFileList = []\n            SecCmdList = SecCmdStr.split()\n            CmdName = SecCmdList[0]\n            for (index, CmdItem) in enumerate(SecCmdList):\n                if '-o' == CmdItem and OutputFile == SecCmdList[index + 1]:\n                    index = index + 1\n                    while index + 1 < len(SecCmdList):\n                        if not SecCmdList[index + 1].startswith('-'):\n                            SecDepsFileList.append(SecCmdList[index + 1])\n                        index = index + 1\n                    if CmdName == 'Trim':\n                        SecDepsFileList.append(os.path.join('$(DEBUG_DIR)', os.path.basename(OutputFile).replace('offset', 'efi')))\n                    if OutputFile.endswith('.ui') or OutputFile.endswith('.ver'):\n                        SecDepsFileList.append(os.path.join('$(MODULE_DIR)', '$(MODULE_FILE)'))\n                    self.FfsOutputFileList.append((OutputFile, ' '.join(SecDepsFileList), SecCmdStr))\n                    if len(SecDepsFileList) > 0:\n                        self.ParseSecCmd(SecDepsFileList, CmdTuple)\n                    break\n                else:\n                    continue",
        "mutated": [
            "def ParseSecCmd(self, OutputFileList, CmdTuple):\n    if False:\n        i = 10\n    for OutputFile in OutputFileList:\n        for SecCmdStr in CmdTuple:\n            SecDepsFileList = []\n            SecCmdList = SecCmdStr.split()\n            CmdName = SecCmdList[0]\n            for (index, CmdItem) in enumerate(SecCmdList):\n                if '-o' == CmdItem and OutputFile == SecCmdList[index + 1]:\n                    index = index + 1\n                    while index + 1 < len(SecCmdList):\n                        if not SecCmdList[index + 1].startswith('-'):\n                            SecDepsFileList.append(SecCmdList[index + 1])\n                        index = index + 1\n                    if CmdName == 'Trim':\n                        SecDepsFileList.append(os.path.join('$(DEBUG_DIR)', os.path.basename(OutputFile).replace('offset', 'efi')))\n                    if OutputFile.endswith('.ui') or OutputFile.endswith('.ver'):\n                        SecDepsFileList.append(os.path.join('$(MODULE_DIR)', '$(MODULE_FILE)'))\n                    self.FfsOutputFileList.append((OutputFile, ' '.join(SecDepsFileList), SecCmdStr))\n                    if len(SecDepsFileList) > 0:\n                        self.ParseSecCmd(SecDepsFileList, CmdTuple)\n                    break\n                else:\n                    continue",
            "def ParseSecCmd(self, OutputFileList, CmdTuple):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for OutputFile in OutputFileList:\n        for SecCmdStr in CmdTuple:\n            SecDepsFileList = []\n            SecCmdList = SecCmdStr.split()\n            CmdName = SecCmdList[0]\n            for (index, CmdItem) in enumerate(SecCmdList):\n                if '-o' == CmdItem and OutputFile == SecCmdList[index + 1]:\n                    index = index + 1\n                    while index + 1 < len(SecCmdList):\n                        if not SecCmdList[index + 1].startswith('-'):\n                            SecDepsFileList.append(SecCmdList[index + 1])\n                        index = index + 1\n                    if CmdName == 'Trim':\n                        SecDepsFileList.append(os.path.join('$(DEBUG_DIR)', os.path.basename(OutputFile).replace('offset', 'efi')))\n                    if OutputFile.endswith('.ui') or OutputFile.endswith('.ver'):\n                        SecDepsFileList.append(os.path.join('$(MODULE_DIR)', '$(MODULE_FILE)'))\n                    self.FfsOutputFileList.append((OutputFile, ' '.join(SecDepsFileList), SecCmdStr))\n                    if len(SecDepsFileList) > 0:\n                        self.ParseSecCmd(SecDepsFileList, CmdTuple)\n                    break\n                else:\n                    continue",
            "def ParseSecCmd(self, OutputFileList, CmdTuple):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for OutputFile in OutputFileList:\n        for SecCmdStr in CmdTuple:\n            SecDepsFileList = []\n            SecCmdList = SecCmdStr.split()\n            CmdName = SecCmdList[0]\n            for (index, CmdItem) in enumerate(SecCmdList):\n                if '-o' == CmdItem and OutputFile == SecCmdList[index + 1]:\n                    index = index + 1\n                    while index + 1 < len(SecCmdList):\n                        if not SecCmdList[index + 1].startswith('-'):\n                            SecDepsFileList.append(SecCmdList[index + 1])\n                        index = index + 1\n                    if CmdName == 'Trim':\n                        SecDepsFileList.append(os.path.join('$(DEBUG_DIR)', os.path.basename(OutputFile).replace('offset', 'efi')))\n                    if OutputFile.endswith('.ui') or OutputFile.endswith('.ver'):\n                        SecDepsFileList.append(os.path.join('$(MODULE_DIR)', '$(MODULE_FILE)'))\n                    self.FfsOutputFileList.append((OutputFile, ' '.join(SecDepsFileList), SecCmdStr))\n                    if len(SecDepsFileList) > 0:\n                        self.ParseSecCmd(SecDepsFileList, CmdTuple)\n                    break\n                else:\n                    continue",
            "def ParseSecCmd(self, OutputFileList, CmdTuple):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for OutputFile in OutputFileList:\n        for SecCmdStr in CmdTuple:\n            SecDepsFileList = []\n            SecCmdList = SecCmdStr.split()\n            CmdName = SecCmdList[0]\n            for (index, CmdItem) in enumerate(SecCmdList):\n                if '-o' == CmdItem and OutputFile == SecCmdList[index + 1]:\n                    index = index + 1\n                    while index + 1 < len(SecCmdList):\n                        if not SecCmdList[index + 1].startswith('-'):\n                            SecDepsFileList.append(SecCmdList[index + 1])\n                        index = index + 1\n                    if CmdName == 'Trim':\n                        SecDepsFileList.append(os.path.join('$(DEBUG_DIR)', os.path.basename(OutputFile).replace('offset', 'efi')))\n                    if OutputFile.endswith('.ui') or OutputFile.endswith('.ver'):\n                        SecDepsFileList.append(os.path.join('$(MODULE_DIR)', '$(MODULE_FILE)'))\n                    self.FfsOutputFileList.append((OutputFile, ' '.join(SecDepsFileList), SecCmdStr))\n                    if len(SecDepsFileList) > 0:\n                        self.ParseSecCmd(SecDepsFileList, CmdTuple)\n                    break\n                else:\n                    continue",
            "def ParseSecCmd(self, OutputFileList, CmdTuple):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for OutputFile in OutputFileList:\n        for SecCmdStr in CmdTuple:\n            SecDepsFileList = []\n            SecCmdList = SecCmdStr.split()\n            CmdName = SecCmdList[0]\n            for (index, CmdItem) in enumerate(SecCmdList):\n                if '-o' == CmdItem and OutputFile == SecCmdList[index + 1]:\n                    index = index + 1\n                    while index + 1 < len(SecCmdList):\n                        if not SecCmdList[index + 1].startswith('-'):\n                            SecDepsFileList.append(SecCmdList[index + 1])\n                        index = index + 1\n                    if CmdName == 'Trim':\n                        SecDepsFileList.append(os.path.join('$(DEBUG_DIR)', os.path.basename(OutputFile).replace('offset', 'efi')))\n                    if OutputFile.endswith('.ui') or OutputFile.endswith('.ver'):\n                        SecDepsFileList.append(os.path.join('$(MODULE_DIR)', '$(MODULE_FILE)'))\n                    self.FfsOutputFileList.append((OutputFile, ' '.join(SecDepsFileList), SecCmdStr))\n                    if len(SecDepsFileList) > 0:\n                        self.ParseSecCmd(SecDepsFileList, CmdTuple)\n                    break\n                else:\n                    continue"
        ]
    },
    {
        "func_name": "ReplaceMacro",
        "original": "def ReplaceMacro(self, str):\n    for Macro in self.MacroList:\n        if self._AutoGenObject.Macros[Macro] and os.path.normcase(self._AutoGenObject.Macros[Macro]) in os.path.normcase(str):\n            replace_dir = str[os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])):os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])) + len(self._AutoGenObject.Macros[Macro])]\n            str = str.replace(replace_dir, '$(' + Macro + ')')\n    return str",
        "mutated": [
            "def ReplaceMacro(self, str):\n    if False:\n        i = 10\n    for Macro in self.MacroList:\n        if self._AutoGenObject.Macros[Macro] and os.path.normcase(self._AutoGenObject.Macros[Macro]) in os.path.normcase(str):\n            replace_dir = str[os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])):os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])) + len(self._AutoGenObject.Macros[Macro])]\n            str = str.replace(replace_dir, '$(' + Macro + ')')\n    return str",
            "def ReplaceMacro(self, str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for Macro in self.MacroList:\n        if self._AutoGenObject.Macros[Macro] and os.path.normcase(self._AutoGenObject.Macros[Macro]) in os.path.normcase(str):\n            replace_dir = str[os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])):os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])) + len(self._AutoGenObject.Macros[Macro])]\n            str = str.replace(replace_dir, '$(' + Macro + ')')\n    return str",
            "def ReplaceMacro(self, str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for Macro in self.MacroList:\n        if self._AutoGenObject.Macros[Macro] and os.path.normcase(self._AutoGenObject.Macros[Macro]) in os.path.normcase(str):\n            replace_dir = str[os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])):os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])) + len(self._AutoGenObject.Macros[Macro])]\n            str = str.replace(replace_dir, '$(' + Macro + ')')\n    return str",
            "def ReplaceMacro(self, str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for Macro in self.MacroList:\n        if self._AutoGenObject.Macros[Macro] and os.path.normcase(self._AutoGenObject.Macros[Macro]) in os.path.normcase(str):\n            replace_dir = str[os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])):os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])) + len(self._AutoGenObject.Macros[Macro])]\n            str = str.replace(replace_dir, '$(' + Macro + ')')\n    return str",
            "def ReplaceMacro(self, str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for Macro in self.MacroList:\n        if self._AutoGenObject.Macros[Macro] and os.path.normcase(self._AutoGenObject.Macros[Macro]) in os.path.normcase(str):\n            replace_dir = str[os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])):os.path.normcase(str).index(os.path.normcase(self._AutoGenObject.Macros[Macro])) + len(self._AutoGenObject.Macros[Macro])]\n            str = str.replace(replace_dir, '$(' + Macro + ')')\n    return str"
        ]
    },
    {
        "func_name": "CommandExceedLimit",
        "original": "def CommandExceedLimit(self):\n    FlagDict = {'CC': {'Macro': '$(CC_FLAGS)', 'Value': False}, 'PP': {'Macro': '$(PP_FLAGS)', 'Value': False}, 'APP': {'Macro': '$(APP_FLAGS)', 'Value': False}, 'ASLPP': {'Macro': '$(ASLPP_FLAGS)', 'Value': False}, 'VFRPP': {'Macro': '$(VFRPP_FLAGS)', 'Value': False}, 'ASM': {'Macro': '$(ASM_FLAGS)', 'Value': False}, 'ASLCC': {'Macro': '$(ASLCC_FLAGS)', 'Value': False}}\n    RespDict = {}\n    FileTypeList = []\n    IncPrefix = self._INC_FLAG_[self._AutoGenObject.ToolChainFamily]\n    for File in self._AutoGenObject.SourceFileList:\n        for type in self._AutoGenObject.FileTypes:\n            if File in self._AutoGenObject.FileTypes[type]:\n                if type not in FileTypeList:\n                    FileTypeList.append(type)\n    if FileTypeList:\n        for type in FileTypeList:\n            BuildTargets = self._AutoGenObject.BuildRules[type].BuildTargets\n            for Target in BuildTargets:\n                CommandList = BuildTargets[Target].Commands\n                for SingleCommand in CommandList:\n                    Tool = ''\n                    SingleCommandLength = len(SingleCommand)\n                    SingleCommandList = SingleCommand.split()\n                    if len(SingleCommandList) > 0:\n                        for Flag in FlagDict:\n                            if '$(' + Flag + ')' in SingleCommandList[0]:\n                                Tool = Flag\n                                break\n                    if Tool:\n                        if 'PATH' not in self._AutoGenObject.BuildOption[Tool]:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"%s_PATH doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                        SingleCommandLength += len(self._AutoGenObject.BuildOption[Tool]['PATH'])\n                        for item in SingleCommandList[1:]:\n                            if FlagDict[Tool]['Macro'] in item:\n                                if 'FLAGS' not in self._AutoGenObject.BuildOption[Tool]:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"%s_FLAGS doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                                Str = self._AutoGenObject.BuildOption[Tool]['FLAGS']\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                            elif '$(INC)' in item:\n                                SingleCommandLength += self._AutoGenObject.IncludePathLength + len(IncPrefix) * len(self._AutoGenObject.IncludePathList)\n                            elif item.find('$(') != -1:\n                                Str = item\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                        if SingleCommandLength > GlobalData.gCommandMaxLength:\n                            FlagDict[Tool]['Value'] = True\n            for Flag in FlagDict:\n                if FlagDict[Flag]['Value']:\n                    Key = Flag + '_RESP'\n                    RespMacro = FlagDict[Flag]['Macro'].replace('FLAGS', 'RESP')\n                    Value = self._AutoGenObject.BuildOption[Flag]['FLAGS']\n                    for inc in self._AutoGenObject.IncludePathList:\n                        Value += ' ' + IncPrefix + inc\n                    for Option in self._AutoGenObject.BuildOption:\n                        for Attr in self._AutoGenObject.BuildOption[Option]:\n                            if Value.find(Option + '_' + Attr) != -1:\n                                Value = Value.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                    while Value.find('$(') != -1:\n                        for macro in self._AutoGenObject.Macros:\n                            MacroName = '$(' + macro + ')'\n                            if Value.find(MacroName) != -1:\n                                Value = Value.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                break\n                        else:\n                            break\n                    if self._AutoGenObject.ToolChainFamily == 'GCC':\n                        RespDict[Key] = Value.replace('\\\\', '/')\n                    else:\n                        RespDict[Key] = Value\n                    for Target in BuildTargets:\n                        for (i, SingleCommand) in enumerate(BuildTargets[Target].Commands):\n                            if FlagDict[Flag]['Macro'] in SingleCommand:\n                                BuildTargets[Target].Commands[i] = SingleCommand.replace('$(INC)', '').replace(FlagDict[Flag]['Macro'], RespMacro)\n    return RespDict",
        "mutated": [
            "def CommandExceedLimit(self):\n    if False:\n        i = 10\n    FlagDict = {'CC': {'Macro': '$(CC_FLAGS)', 'Value': False}, 'PP': {'Macro': '$(PP_FLAGS)', 'Value': False}, 'APP': {'Macro': '$(APP_FLAGS)', 'Value': False}, 'ASLPP': {'Macro': '$(ASLPP_FLAGS)', 'Value': False}, 'VFRPP': {'Macro': '$(VFRPP_FLAGS)', 'Value': False}, 'ASM': {'Macro': '$(ASM_FLAGS)', 'Value': False}, 'ASLCC': {'Macro': '$(ASLCC_FLAGS)', 'Value': False}}\n    RespDict = {}\n    FileTypeList = []\n    IncPrefix = self._INC_FLAG_[self._AutoGenObject.ToolChainFamily]\n    for File in self._AutoGenObject.SourceFileList:\n        for type in self._AutoGenObject.FileTypes:\n            if File in self._AutoGenObject.FileTypes[type]:\n                if type not in FileTypeList:\n                    FileTypeList.append(type)\n    if FileTypeList:\n        for type in FileTypeList:\n            BuildTargets = self._AutoGenObject.BuildRules[type].BuildTargets\n            for Target in BuildTargets:\n                CommandList = BuildTargets[Target].Commands\n                for SingleCommand in CommandList:\n                    Tool = ''\n                    SingleCommandLength = len(SingleCommand)\n                    SingleCommandList = SingleCommand.split()\n                    if len(SingleCommandList) > 0:\n                        for Flag in FlagDict:\n                            if '$(' + Flag + ')' in SingleCommandList[0]:\n                                Tool = Flag\n                                break\n                    if Tool:\n                        if 'PATH' not in self._AutoGenObject.BuildOption[Tool]:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"%s_PATH doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                        SingleCommandLength += len(self._AutoGenObject.BuildOption[Tool]['PATH'])\n                        for item in SingleCommandList[1:]:\n                            if FlagDict[Tool]['Macro'] in item:\n                                if 'FLAGS' not in self._AutoGenObject.BuildOption[Tool]:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"%s_FLAGS doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                                Str = self._AutoGenObject.BuildOption[Tool]['FLAGS']\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                            elif '$(INC)' in item:\n                                SingleCommandLength += self._AutoGenObject.IncludePathLength + len(IncPrefix) * len(self._AutoGenObject.IncludePathList)\n                            elif item.find('$(') != -1:\n                                Str = item\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                        if SingleCommandLength > GlobalData.gCommandMaxLength:\n                            FlagDict[Tool]['Value'] = True\n            for Flag in FlagDict:\n                if FlagDict[Flag]['Value']:\n                    Key = Flag + '_RESP'\n                    RespMacro = FlagDict[Flag]['Macro'].replace('FLAGS', 'RESP')\n                    Value = self._AutoGenObject.BuildOption[Flag]['FLAGS']\n                    for inc in self._AutoGenObject.IncludePathList:\n                        Value += ' ' + IncPrefix + inc\n                    for Option in self._AutoGenObject.BuildOption:\n                        for Attr in self._AutoGenObject.BuildOption[Option]:\n                            if Value.find(Option + '_' + Attr) != -1:\n                                Value = Value.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                    while Value.find('$(') != -1:\n                        for macro in self._AutoGenObject.Macros:\n                            MacroName = '$(' + macro + ')'\n                            if Value.find(MacroName) != -1:\n                                Value = Value.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                break\n                        else:\n                            break\n                    if self._AutoGenObject.ToolChainFamily == 'GCC':\n                        RespDict[Key] = Value.replace('\\\\', '/')\n                    else:\n                        RespDict[Key] = Value\n                    for Target in BuildTargets:\n                        for (i, SingleCommand) in enumerate(BuildTargets[Target].Commands):\n                            if FlagDict[Flag]['Macro'] in SingleCommand:\n                                BuildTargets[Target].Commands[i] = SingleCommand.replace('$(INC)', '').replace(FlagDict[Flag]['Macro'], RespMacro)\n    return RespDict",
            "def CommandExceedLimit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FlagDict = {'CC': {'Macro': '$(CC_FLAGS)', 'Value': False}, 'PP': {'Macro': '$(PP_FLAGS)', 'Value': False}, 'APP': {'Macro': '$(APP_FLAGS)', 'Value': False}, 'ASLPP': {'Macro': '$(ASLPP_FLAGS)', 'Value': False}, 'VFRPP': {'Macro': '$(VFRPP_FLAGS)', 'Value': False}, 'ASM': {'Macro': '$(ASM_FLAGS)', 'Value': False}, 'ASLCC': {'Macro': '$(ASLCC_FLAGS)', 'Value': False}}\n    RespDict = {}\n    FileTypeList = []\n    IncPrefix = self._INC_FLAG_[self._AutoGenObject.ToolChainFamily]\n    for File in self._AutoGenObject.SourceFileList:\n        for type in self._AutoGenObject.FileTypes:\n            if File in self._AutoGenObject.FileTypes[type]:\n                if type not in FileTypeList:\n                    FileTypeList.append(type)\n    if FileTypeList:\n        for type in FileTypeList:\n            BuildTargets = self._AutoGenObject.BuildRules[type].BuildTargets\n            for Target in BuildTargets:\n                CommandList = BuildTargets[Target].Commands\n                for SingleCommand in CommandList:\n                    Tool = ''\n                    SingleCommandLength = len(SingleCommand)\n                    SingleCommandList = SingleCommand.split()\n                    if len(SingleCommandList) > 0:\n                        for Flag in FlagDict:\n                            if '$(' + Flag + ')' in SingleCommandList[0]:\n                                Tool = Flag\n                                break\n                    if Tool:\n                        if 'PATH' not in self._AutoGenObject.BuildOption[Tool]:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"%s_PATH doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                        SingleCommandLength += len(self._AutoGenObject.BuildOption[Tool]['PATH'])\n                        for item in SingleCommandList[1:]:\n                            if FlagDict[Tool]['Macro'] in item:\n                                if 'FLAGS' not in self._AutoGenObject.BuildOption[Tool]:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"%s_FLAGS doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                                Str = self._AutoGenObject.BuildOption[Tool]['FLAGS']\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                            elif '$(INC)' in item:\n                                SingleCommandLength += self._AutoGenObject.IncludePathLength + len(IncPrefix) * len(self._AutoGenObject.IncludePathList)\n                            elif item.find('$(') != -1:\n                                Str = item\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                        if SingleCommandLength > GlobalData.gCommandMaxLength:\n                            FlagDict[Tool]['Value'] = True\n            for Flag in FlagDict:\n                if FlagDict[Flag]['Value']:\n                    Key = Flag + '_RESP'\n                    RespMacro = FlagDict[Flag]['Macro'].replace('FLAGS', 'RESP')\n                    Value = self._AutoGenObject.BuildOption[Flag]['FLAGS']\n                    for inc in self._AutoGenObject.IncludePathList:\n                        Value += ' ' + IncPrefix + inc\n                    for Option in self._AutoGenObject.BuildOption:\n                        for Attr in self._AutoGenObject.BuildOption[Option]:\n                            if Value.find(Option + '_' + Attr) != -1:\n                                Value = Value.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                    while Value.find('$(') != -1:\n                        for macro in self._AutoGenObject.Macros:\n                            MacroName = '$(' + macro + ')'\n                            if Value.find(MacroName) != -1:\n                                Value = Value.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                break\n                        else:\n                            break\n                    if self._AutoGenObject.ToolChainFamily == 'GCC':\n                        RespDict[Key] = Value.replace('\\\\', '/')\n                    else:\n                        RespDict[Key] = Value\n                    for Target in BuildTargets:\n                        for (i, SingleCommand) in enumerate(BuildTargets[Target].Commands):\n                            if FlagDict[Flag]['Macro'] in SingleCommand:\n                                BuildTargets[Target].Commands[i] = SingleCommand.replace('$(INC)', '').replace(FlagDict[Flag]['Macro'], RespMacro)\n    return RespDict",
            "def CommandExceedLimit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FlagDict = {'CC': {'Macro': '$(CC_FLAGS)', 'Value': False}, 'PP': {'Macro': '$(PP_FLAGS)', 'Value': False}, 'APP': {'Macro': '$(APP_FLAGS)', 'Value': False}, 'ASLPP': {'Macro': '$(ASLPP_FLAGS)', 'Value': False}, 'VFRPP': {'Macro': '$(VFRPP_FLAGS)', 'Value': False}, 'ASM': {'Macro': '$(ASM_FLAGS)', 'Value': False}, 'ASLCC': {'Macro': '$(ASLCC_FLAGS)', 'Value': False}}\n    RespDict = {}\n    FileTypeList = []\n    IncPrefix = self._INC_FLAG_[self._AutoGenObject.ToolChainFamily]\n    for File in self._AutoGenObject.SourceFileList:\n        for type in self._AutoGenObject.FileTypes:\n            if File in self._AutoGenObject.FileTypes[type]:\n                if type not in FileTypeList:\n                    FileTypeList.append(type)\n    if FileTypeList:\n        for type in FileTypeList:\n            BuildTargets = self._AutoGenObject.BuildRules[type].BuildTargets\n            for Target in BuildTargets:\n                CommandList = BuildTargets[Target].Commands\n                for SingleCommand in CommandList:\n                    Tool = ''\n                    SingleCommandLength = len(SingleCommand)\n                    SingleCommandList = SingleCommand.split()\n                    if len(SingleCommandList) > 0:\n                        for Flag in FlagDict:\n                            if '$(' + Flag + ')' in SingleCommandList[0]:\n                                Tool = Flag\n                                break\n                    if Tool:\n                        if 'PATH' not in self._AutoGenObject.BuildOption[Tool]:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"%s_PATH doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                        SingleCommandLength += len(self._AutoGenObject.BuildOption[Tool]['PATH'])\n                        for item in SingleCommandList[1:]:\n                            if FlagDict[Tool]['Macro'] in item:\n                                if 'FLAGS' not in self._AutoGenObject.BuildOption[Tool]:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"%s_FLAGS doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                                Str = self._AutoGenObject.BuildOption[Tool]['FLAGS']\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                            elif '$(INC)' in item:\n                                SingleCommandLength += self._AutoGenObject.IncludePathLength + len(IncPrefix) * len(self._AutoGenObject.IncludePathList)\n                            elif item.find('$(') != -1:\n                                Str = item\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                        if SingleCommandLength > GlobalData.gCommandMaxLength:\n                            FlagDict[Tool]['Value'] = True\n            for Flag in FlagDict:\n                if FlagDict[Flag]['Value']:\n                    Key = Flag + '_RESP'\n                    RespMacro = FlagDict[Flag]['Macro'].replace('FLAGS', 'RESP')\n                    Value = self._AutoGenObject.BuildOption[Flag]['FLAGS']\n                    for inc in self._AutoGenObject.IncludePathList:\n                        Value += ' ' + IncPrefix + inc\n                    for Option in self._AutoGenObject.BuildOption:\n                        for Attr in self._AutoGenObject.BuildOption[Option]:\n                            if Value.find(Option + '_' + Attr) != -1:\n                                Value = Value.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                    while Value.find('$(') != -1:\n                        for macro in self._AutoGenObject.Macros:\n                            MacroName = '$(' + macro + ')'\n                            if Value.find(MacroName) != -1:\n                                Value = Value.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                break\n                        else:\n                            break\n                    if self._AutoGenObject.ToolChainFamily == 'GCC':\n                        RespDict[Key] = Value.replace('\\\\', '/')\n                    else:\n                        RespDict[Key] = Value\n                    for Target in BuildTargets:\n                        for (i, SingleCommand) in enumerate(BuildTargets[Target].Commands):\n                            if FlagDict[Flag]['Macro'] in SingleCommand:\n                                BuildTargets[Target].Commands[i] = SingleCommand.replace('$(INC)', '').replace(FlagDict[Flag]['Macro'], RespMacro)\n    return RespDict",
            "def CommandExceedLimit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FlagDict = {'CC': {'Macro': '$(CC_FLAGS)', 'Value': False}, 'PP': {'Macro': '$(PP_FLAGS)', 'Value': False}, 'APP': {'Macro': '$(APP_FLAGS)', 'Value': False}, 'ASLPP': {'Macro': '$(ASLPP_FLAGS)', 'Value': False}, 'VFRPP': {'Macro': '$(VFRPP_FLAGS)', 'Value': False}, 'ASM': {'Macro': '$(ASM_FLAGS)', 'Value': False}, 'ASLCC': {'Macro': '$(ASLCC_FLAGS)', 'Value': False}}\n    RespDict = {}\n    FileTypeList = []\n    IncPrefix = self._INC_FLAG_[self._AutoGenObject.ToolChainFamily]\n    for File in self._AutoGenObject.SourceFileList:\n        for type in self._AutoGenObject.FileTypes:\n            if File in self._AutoGenObject.FileTypes[type]:\n                if type not in FileTypeList:\n                    FileTypeList.append(type)\n    if FileTypeList:\n        for type in FileTypeList:\n            BuildTargets = self._AutoGenObject.BuildRules[type].BuildTargets\n            for Target in BuildTargets:\n                CommandList = BuildTargets[Target].Commands\n                for SingleCommand in CommandList:\n                    Tool = ''\n                    SingleCommandLength = len(SingleCommand)\n                    SingleCommandList = SingleCommand.split()\n                    if len(SingleCommandList) > 0:\n                        for Flag in FlagDict:\n                            if '$(' + Flag + ')' in SingleCommandList[0]:\n                                Tool = Flag\n                                break\n                    if Tool:\n                        if 'PATH' not in self._AutoGenObject.BuildOption[Tool]:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"%s_PATH doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                        SingleCommandLength += len(self._AutoGenObject.BuildOption[Tool]['PATH'])\n                        for item in SingleCommandList[1:]:\n                            if FlagDict[Tool]['Macro'] in item:\n                                if 'FLAGS' not in self._AutoGenObject.BuildOption[Tool]:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"%s_FLAGS doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                                Str = self._AutoGenObject.BuildOption[Tool]['FLAGS']\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                            elif '$(INC)' in item:\n                                SingleCommandLength += self._AutoGenObject.IncludePathLength + len(IncPrefix) * len(self._AutoGenObject.IncludePathList)\n                            elif item.find('$(') != -1:\n                                Str = item\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                        if SingleCommandLength > GlobalData.gCommandMaxLength:\n                            FlagDict[Tool]['Value'] = True\n            for Flag in FlagDict:\n                if FlagDict[Flag]['Value']:\n                    Key = Flag + '_RESP'\n                    RespMacro = FlagDict[Flag]['Macro'].replace('FLAGS', 'RESP')\n                    Value = self._AutoGenObject.BuildOption[Flag]['FLAGS']\n                    for inc in self._AutoGenObject.IncludePathList:\n                        Value += ' ' + IncPrefix + inc\n                    for Option in self._AutoGenObject.BuildOption:\n                        for Attr in self._AutoGenObject.BuildOption[Option]:\n                            if Value.find(Option + '_' + Attr) != -1:\n                                Value = Value.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                    while Value.find('$(') != -1:\n                        for macro in self._AutoGenObject.Macros:\n                            MacroName = '$(' + macro + ')'\n                            if Value.find(MacroName) != -1:\n                                Value = Value.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                break\n                        else:\n                            break\n                    if self._AutoGenObject.ToolChainFamily == 'GCC':\n                        RespDict[Key] = Value.replace('\\\\', '/')\n                    else:\n                        RespDict[Key] = Value\n                    for Target in BuildTargets:\n                        for (i, SingleCommand) in enumerate(BuildTargets[Target].Commands):\n                            if FlagDict[Flag]['Macro'] in SingleCommand:\n                                BuildTargets[Target].Commands[i] = SingleCommand.replace('$(INC)', '').replace(FlagDict[Flag]['Macro'], RespMacro)\n    return RespDict",
            "def CommandExceedLimit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FlagDict = {'CC': {'Macro': '$(CC_FLAGS)', 'Value': False}, 'PP': {'Macro': '$(PP_FLAGS)', 'Value': False}, 'APP': {'Macro': '$(APP_FLAGS)', 'Value': False}, 'ASLPP': {'Macro': '$(ASLPP_FLAGS)', 'Value': False}, 'VFRPP': {'Macro': '$(VFRPP_FLAGS)', 'Value': False}, 'ASM': {'Macro': '$(ASM_FLAGS)', 'Value': False}, 'ASLCC': {'Macro': '$(ASLCC_FLAGS)', 'Value': False}}\n    RespDict = {}\n    FileTypeList = []\n    IncPrefix = self._INC_FLAG_[self._AutoGenObject.ToolChainFamily]\n    for File in self._AutoGenObject.SourceFileList:\n        for type in self._AutoGenObject.FileTypes:\n            if File in self._AutoGenObject.FileTypes[type]:\n                if type not in FileTypeList:\n                    FileTypeList.append(type)\n    if FileTypeList:\n        for type in FileTypeList:\n            BuildTargets = self._AutoGenObject.BuildRules[type].BuildTargets\n            for Target in BuildTargets:\n                CommandList = BuildTargets[Target].Commands\n                for SingleCommand in CommandList:\n                    Tool = ''\n                    SingleCommandLength = len(SingleCommand)\n                    SingleCommandList = SingleCommand.split()\n                    if len(SingleCommandList) > 0:\n                        for Flag in FlagDict:\n                            if '$(' + Flag + ')' in SingleCommandList[0]:\n                                Tool = Flag\n                                break\n                    if Tool:\n                        if 'PATH' not in self._AutoGenObject.BuildOption[Tool]:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"%s_PATH doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                        SingleCommandLength += len(self._AutoGenObject.BuildOption[Tool]['PATH'])\n                        for item in SingleCommandList[1:]:\n                            if FlagDict[Tool]['Macro'] in item:\n                                if 'FLAGS' not in self._AutoGenObject.BuildOption[Tool]:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"%s_FLAGS doesn't exist in %s ToolChain and %s Arch.\" % (Tool, self._AutoGenObject.ToolChain, self._AutoGenObject.Arch), ExtraData='[%s]' % str(self._AutoGenObject))\n                                Str = self._AutoGenObject.BuildOption[Tool]['FLAGS']\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                            elif '$(INC)' in item:\n                                SingleCommandLength += self._AutoGenObject.IncludePathLength + len(IncPrefix) * len(self._AutoGenObject.IncludePathList)\n                            elif item.find('$(') != -1:\n                                Str = item\n                                for Option in self._AutoGenObject.BuildOption:\n                                    for Attr in self._AutoGenObject.BuildOption[Option]:\n                                        if Str.find(Option + '_' + Attr) != -1:\n                                            Str = Str.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                                while Str.find('$(') != -1:\n                                    for macro in self._AutoGenObject.Macros:\n                                        MacroName = '$(' + macro + ')'\n                                        if Str.find(MacroName) != -1:\n                                            Str = Str.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                            break\n                                    else:\n                                        break\n                                SingleCommandLength += len(Str)\n                        if SingleCommandLength > GlobalData.gCommandMaxLength:\n                            FlagDict[Tool]['Value'] = True\n            for Flag in FlagDict:\n                if FlagDict[Flag]['Value']:\n                    Key = Flag + '_RESP'\n                    RespMacro = FlagDict[Flag]['Macro'].replace('FLAGS', 'RESP')\n                    Value = self._AutoGenObject.BuildOption[Flag]['FLAGS']\n                    for inc in self._AutoGenObject.IncludePathList:\n                        Value += ' ' + IncPrefix + inc\n                    for Option in self._AutoGenObject.BuildOption:\n                        for Attr in self._AutoGenObject.BuildOption[Option]:\n                            if Value.find(Option + '_' + Attr) != -1:\n                                Value = Value.replace('$(' + Option + '_' + Attr + ')', self._AutoGenObject.BuildOption[Option][Attr])\n                    while Value.find('$(') != -1:\n                        for macro in self._AutoGenObject.Macros:\n                            MacroName = '$(' + macro + ')'\n                            if Value.find(MacroName) != -1:\n                                Value = Value.replace(MacroName, self._AutoGenObject.Macros[macro])\n                                break\n                        else:\n                            break\n                    if self._AutoGenObject.ToolChainFamily == 'GCC':\n                        RespDict[Key] = Value.replace('\\\\', '/')\n                    else:\n                        RespDict[Key] = Value\n                    for Target in BuildTargets:\n                        for (i, SingleCommand) in enumerate(BuildTargets[Target].Commands):\n                            if FlagDict[Flag]['Macro'] in SingleCommand:\n                                BuildTargets[Target].Commands[i] = SingleCommand.replace('$(INC)', '').replace(FlagDict[Flag]['Macro'], RespMacro)\n    return RespDict"
        ]
    },
    {
        "func_name": "ProcessBuildTargetList",
        "original": "def ProcessBuildTargetList(self, RespFile, ToolsDef):\n    ForceIncludedFile = []\n    for File in self._AutoGenObject.AutoGenFileList:\n        if File.Ext == '.h':\n            ForceIncludedFile.append(File)\n    SourceFileList = []\n    OutPutFileList = []\n    for Target in self._AutoGenObject.IntroTargetList:\n        SourceFileList.extend(Target.Inputs)\n        OutPutFileList.extend(Target.Outputs)\n    if OutPutFileList:\n        for Item in OutPutFileList:\n            if Item in SourceFileList:\n                SourceFileList.remove(Item)\n    FileDependencyDict = {item: ForceIncludedFile for item in SourceFileList}\n    for Dependency in FileDependencyDict.values():\n        self.DependencyHeaderFileSet.update(set(Dependency))\n    parentMetaFileIncludes = set()\n    for aInclude in self._AutoGenObject.PackageIncludePathList:\n        aIncludeName = str(aInclude)\n        parentMetaFileIncludes.add(aIncludeName.lower())\n    headerFilesInMetaFileSet = set()\n    for aFile in self._AutoGenObject.SourceFileList:\n        aFileName = str(aFile)\n        if not aFileName.endswith('.h'):\n            continue\n        headerFilesInMetaFileSet.add(aFileName.lower())\n    localAutoGenFileSet = set()\n    for aFile in self._AutoGenObject.AutoGenFileList:\n        localAutoGenFileSet.add(str(aFile).lower())\n    headerFileDependencySet = set()\n    localSourceDir = str(self._AutoGenObject.SourceDir).lower()\n    for Dependency in FileDependencyDict.values():\n        for aFile in Dependency:\n            aFileName = str(aFile).lower()\n            if not aFileName.endswith('.h'):\n                continue\n            if aFileName in localAutoGenFileSet:\n                continue\n            if localSourceDir not in aFileName:\n                continue\n            pathNeeded = True\n            for aIncludePath in parentMetaFileIncludes:\n                if aIncludePath in aFileName:\n                    pathNeeded = False\n                    break\n            if not pathNeeded:\n                continue\n            headerFileDependencySet.add(aFileName)\n    for aFile in headerFileDependencySet:\n        if aFile in headerFilesInMetaFileSet:\n            continue\n        if GlobalData.gUseHashCache:\n            GlobalData.gModuleBuildTracking[self._AutoGenObject] = 'FAIL_METAFILE'\n        EdkLogger.warn('build', 'Module MetaFile [Sources] is missing local header!', ExtraData='Local Header: ' + aFile + ' not found in ' + self._AutoGenObject.MetaFile.Path)\n    for (File, Dependency) in FileDependencyDict.items():\n        if not Dependency:\n            continue\n        self._AutoGenObject.AutoGenDepSet |= set(Dependency)\n    CmdSumDict = {}\n    CmdTargetDict = {}\n    CmdCppDict = {}\n    DependencyDict = FileDependencyDict.copy()\n    if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and TAB_C_CODE_FILE in self._AutoGenObject.Targets:\n        for T in self._AutoGenObject.Targets[TAB_C_CODE_FILE]:\n            NewFile = self.PlaceMacro(str(T), self.Macros)\n            if not self.ObjTargetDict.get(T.Target.SubDir):\n                self.ObjTargetDict[T.Target.SubDir] = set()\n            self.ObjTargetDict[T.Target.SubDir].add(NewFile)\n    for Type in self._AutoGenObject.Targets:\n        resp_file_number = 0\n        for T in self._AutoGenObject.Targets[Type]:\n            if T.GenFileListMacro and T.FileListMacro not in self.FileListMacros:\n                self.FileListMacros[T.FileListMacro] = []\n            if T.GenListFile and T.ListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.ListFileMacro] = []\n            if T.GenIncListFile and T.IncListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.IncListFileMacro] = []\n            Deps = []\n            CCodeDeps = []\n            for Dep in T.Dependencies:\n                Deps.append(self.PlaceMacro(str(Dep), self.Macros))\n                if Dep != '$(MAKE_FILE)':\n                    CCodeDeps.append(self.PlaceMacro(str(Dep), self.Macros))\n            if len(T.Inputs) == 1 and T.Inputs[0] in FileDependencyDict:\n                for F in FileDependencyDict[T.Inputs[0]]:\n                    Deps.append(self.PlaceMacro(str(F), self.Macros))\n            for F in T.Inputs:\n                NewFile = self.PlaceMacro(str(F), self.Macros)\n                if T.GenListFile:\n                    self.ListFileMacros[T.ListFileMacro].append(str(F).replace('\\\\', '/'))\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                elif T.GenFileListMacro:\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                else:\n                    Deps.append(NewFile)\n            for key in self.FileListMacros:\n                self.FileListMacros[key].sort()\n            if T.GenFileListMacro:\n                Deps.append('$(%s)' % T.FileListMacro)\n                if Type in [TAB_OBJECT_FILE, TAB_STATIC_LIBRARY]:\n                    Deps.append('$(%s)' % T.ListFileMacro)\n            if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and Type == TAB_C_CODE_FILE:\n                (T, CmdTarget, CmdTargetDict, CmdCppDict) = self.ParserCCodeFile(T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number)\n                resp_file_number += 1\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': CCodeDeps}\n                CmdLine = self._BUILD_TARGET_TEMPLATE.Replace(TargetDict).rstrip().replace('\\t$(OBJLIST', '$(OBJLIST')\n                if T.Commands:\n                    CmdLine = '%s%s' % (CmdLine, TAB_LINE_BREAK)\n                if CCodeDeps or CmdLine:\n                    self.BuildTargetList.append(CmdLine)\n            else:\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': Deps}\n                self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(TargetDict))\n                for i in T.Outputs[1:]:\n                    AnnexeTargetDict = {'target': self.PlaceMacro(i.Path, self.Macros), 'cmd': '', 'deps': self.PlaceMacro(T.Target.Path, self.Macros)}\n                    self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(AnnexeTargetDict))",
        "mutated": [
            "def ProcessBuildTargetList(self, RespFile, ToolsDef):\n    if False:\n        i = 10\n    ForceIncludedFile = []\n    for File in self._AutoGenObject.AutoGenFileList:\n        if File.Ext == '.h':\n            ForceIncludedFile.append(File)\n    SourceFileList = []\n    OutPutFileList = []\n    for Target in self._AutoGenObject.IntroTargetList:\n        SourceFileList.extend(Target.Inputs)\n        OutPutFileList.extend(Target.Outputs)\n    if OutPutFileList:\n        for Item in OutPutFileList:\n            if Item in SourceFileList:\n                SourceFileList.remove(Item)\n    FileDependencyDict = {item: ForceIncludedFile for item in SourceFileList}\n    for Dependency in FileDependencyDict.values():\n        self.DependencyHeaderFileSet.update(set(Dependency))\n    parentMetaFileIncludes = set()\n    for aInclude in self._AutoGenObject.PackageIncludePathList:\n        aIncludeName = str(aInclude)\n        parentMetaFileIncludes.add(aIncludeName.lower())\n    headerFilesInMetaFileSet = set()\n    for aFile in self._AutoGenObject.SourceFileList:\n        aFileName = str(aFile)\n        if not aFileName.endswith('.h'):\n            continue\n        headerFilesInMetaFileSet.add(aFileName.lower())\n    localAutoGenFileSet = set()\n    for aFile in self._AutoGenObject.AutoGenFileList:\n        localAutoGenFileSet.add(str(aFile).lower())\n    headerFileDependencySet = set()\n    localSourceDir = str(self._AutoGenObject.SourceDir).lower()\n    for Dependency in FileDependencyDict.values():\n        for aFile in Dependency:\n            aFileName = str(aFile).lower()\n            if not aFileName.endswith('.h'):\n                continue\n            if aFileName in localAutoGenFileSet:\n                continue\n            if localSourceDir not in aFileName:\n                continue\n            pathNeeded = True\n            for aIncludePath in parentMetaFileIncludes:\n                if aIncludePath in aFileName:\n                    pathNeeded = False\n                    break\n            if not pathNeeded:\n                continue\n            headerFileDependencySet.add(aFileName)\n    for aFile in headerFileDependencySet:\n        if aFile in headerFilesInMetaFileSet:\n            continue\n        if GlobalData.gUseHashCache:\n            GlobalData.gModuleBuildTracking[self._AutoGenObject] = 'FAIL_METAFILE'\n        EdkLogger.warn('build', 'Module MetaFile [Sources] is missing local header!', ExtraData='Local Header: ' + aFile + ' not found in ' + self._AutoGenObject.MetaFile.Path)\n    for (File, Dependency) in FileDependencyDict.items():\n        if not Dependency:\n            continue\n        self._AutoGenObject.AutoGenDepSet |= set(Dependency)\n    CmdSumDict = {}\n    CmdTargetDict = {}\n    CmdCppDict = {}\n    DependencyDict = FileDependencyDict.copy()\n    if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and TAB_C_CODE_FILE in self._AutoGenObject.Targets:\n        for T in self._AutoGenObject.Targets[TAB_C_CODE_FILE]:\n            NewFile = self.PlaceMacro(str(T), self.Macros)\n            if not self.ObjTargetDict.get(T.Target.SubDir):\n                self.ObjTargetDict[T.Target.SubDir] = set()\n            self.ObjTargetDict[T.Target.SubDir].add(NewFile)\n    for Type in self._AutoGenObject.Targets:\n        resp_file_number = 0\n        for T in self._AutoGenObject.Targets[Type]:\n            if T.GenFileListMacro and T.FileListMacro not in self.FileListMacros:\n                self.FileListMacros[T.FileListMacro] = []\n            if T.GenListFile and T.ListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.ListFileMacro] = []\n            if T.GenIncListFile and T.IncListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.IncListFileMacro] = []\n            Deps = []\n            CCodeDeps = []\n            for Dep in T.Dependencies:\n                Deps.append(self.PlaceMacro(str(Dep), self.Macros))\n                if Dep != '$(MAKE_FILE)':\n                    CCodeDeps.append(self.PlaceMacro(str(Dep), self.Macros))\n            if len(T.Inputs) == 1 and T.Inputs[0] in FileDependencyDict:\n                for F in FileDependencyDict[T.Inputs[0]]:\n                    Deps.append(self.PlaceMacro(str(F), self.Macros))\n            for F in T.Inputs:\n                NewFile = self.PlaceMacro(str(F), self.Macros)\n                if T.GenListFile:\n                    self.ListFileMacros[T.ListFileMacro].append(str(F).replace('\\\\', '/'))\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                elif T.GenFileListMacro:\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                else:\n                    Deps.append(NewFile)\n            for key in self.FileListMacros:\n                self.FileListMacros[key].sort()\n            if T.GenFileListMacro:\n                Deps.append('$(%s)' % T.FileListMacro)\n                if Type in [TAB_OBJECT_FILE, TAB_STATIC_LIBRARY]:\n                    Deps.append('$(%s)' % T.ListFileMacro)\n            if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and Type == TAB_C_CODE_FILE:\n                (T, CmdTarget, CmdTargetDict, CmdCppDict) = self.ParserCCodeFile(T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number)\n                resp_file_number += 1\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': CCodeDeps}\n                CmdLine = self._BUILD_TARGET_TEMPLATE.Replace(TargetDict).rstrip().replace('\\t$(OBJLIST', '$(OBJLIST')\n                if T.Commands:\n                    CmdLine = '%s%s' % (CmdLine, TAB_LINE_BREAK)\n                if CCodeDeps or CmdLine:\n                    self.BuildTargetList.append(CmdLine)\n            else:\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': Deps}\n                self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(TargetDict))\n                for i in T.Outputs[1:]:\n                    AnnexeTargetDict = {'target': self.PlaceMacro(i.Path, self.Macros), 'cmd': '', 'deps': self.PlaceMacro(T.Target.Path, self.Macros)}\n                    self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(AnnexeTargetDict))",
            "def ProcessBuildTargetList(self, RespFile, ToolsDef):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ForceIncludedFile = []\n    for File in self._AutoGenObject.AutoGenFileList:\n        if File.Ext == '.h':\n            ForceIncludedFile.append(File)\n    SourceFileList = []\n    OutPutFileList = []\n    for Target in self._AutoGenObject.IntroTargetList:\n        SourceFileList.extend(Target.Inputs)\n        OutPutFileList.extend(Target.Outputs)\n    if OutPutFileList:\n        for Item in OutPutFileList:\n            if Item in SourceFileList:\n                SourceFileList.remove(Item)\n    FileDependencyDict = {item: ForceIncludedFile for item in SourceFileList}\n    for Dependency in FileDependencyDict.values():\n        self.DependencyHeaderFileSet.update(set(Dependency))\n    parentMetaFileIncludes = set()\n    for aInclude in self._AutoGenObject.PackageIncludePathList:\n        aIncludeName = str(aInclude)\n        parentMetaFileIncludes.add(aIncludeName.lower())\n    headerFilesInMetaFileSet = set()\n    for aFile in self._AutoGenObject.SourceFileList:\n        aFileName = str(aFile)\n        if not aFileName.endswith('.h'):\n            continue\n        headerFilesInMetaFileSet.add(aFileName.lower())\n    localAutoGenFileSet = set()\n    for aFile in self._AutoGenObject.AutoGenFileList:\n        localAutoGenFileSet.add(str(aFile).lower())\n    headerFileDependencySet = set()\n    localSourceDir = str(self._AutoGenObject.SourceDir).lower()\n    for Dependency in FileDependencyDict.values():\n        for aFile in Dependency:\n            aFileName = str(aFile).lower()\n            if not aFileName.endswith('.h'):\n                continue\n            if aFileName in localAutoGenFileSet:\n                continue\n            if localSourceDir not in aFileName:\n                continue\n            pathNeeded = True\n            for aIncludePath in parentMetaFileIncludes:\n                if aIncludePath in aFileName:\n                    pathNeeded = False\n                    break\n            if not pathNeeded:\n                continue\n            headerFileDependencySet.add(aFileName)\n    for aFile in headerFileDependencySet:\n        if aFile in headerFilesInMetaFileSet:\n            continue\n        if GlobalData.gUseHashCache:\n            GlobalData.gModuleBuildTracking[self._AutoGenObject] = 'FAIL_METAFILE'\n        EdkLogger.warn('build', 'Module MetaFile [Sources] is missing local header!', ExtraData='Local Header: ' + aFile + ' not found in ' + self._AutoGenObject.MetaFile.Path)\n    for (File, Dependency) in FileDependencyDict.items():\n        if not Dependency:\n            continue\n        self._AutoGenObject.AutoGenDepSet |= set(Dependency)\n    CmdSumDict = {}\n    CmdTargetDict = {}\n    CmdCppDict = {}\n    DependencyDict = FileDependencyDict.copy()\n    if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and TAB_C_CODE_FILE in self._AutoGenObject.Targets:\n        for T in self._AutoGenObject.Targets[TAB_C_CODE_FILE]:\n            NewFile = self.PlaceMacro(str(T), self.Macros)\n            if not self.ObjTargetDict.get(T.Target.SubDir):\n                self.ObjTargetDict[T.Target.SubDir] = set()\n            self.ObjTargetDict[T.Target.SubDir].add(NewFile)\n    for Type in self._AutoGenObject.Targets:\n        resp_file_number = 0\n        for T in self._AutoGenObject.Targets[Type]:\n            if T.GenFileListMacro and T.FileListMacro not in self.FileListMacros:\n                self.FileListMacros[T.FileListMacro] = []\n            if T.GenListFile and T.ListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.ListFileMacro] = []\n            if T.GenIncListFile and T.IncListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.IncListFileMacro] = []\n            Deps = []\n            CCodeDeps = []\n            for Dep in T.Dependencies:\n                Deps.append(self.PlaceMacro(str(Dep), self.Macros))\n                if Dep != '$(MAKE_FILE)':\n                    CCodeDeps.append(self.PlaceMacro(str(Dep), self.Macros))\n            if len(T.Inputs) == 1 and T.Inputs[0] in FileDependencyDict:\n                for F in FileDependencyDict[T.Inputs[0]]:\n                    Deps.append(self.PlaceMacro(str(F), self.Macros))\n            for F in T.Inputs:\n                NewFile = self.PlaceMacro(str(F), self.Macros)\n                if T.GenListFile:\n                    self.ListFileMacros[T.ListFileMacro].append(str(F).replace('\\\\', '/'))\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                elif T.GenFileListMacro:\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                else:\n                    Deps.append(NewFile)\n            for key in self.FileListMacros:\n                self.FileListMacros[key].sort()\n            if T.GenFileListMacro:\n                Deps.append('$(%s)' % T.FileListMacro)\n                if Type in [TAB_OBJECT_FILE, TAB_STATIC_LIBRARY]:\n                    Deps.append('$(%s)' % T.ListFileMacro)\n            if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and Type == TAB_C_CODE_FILE:\n                (T, CmdTarget, CmdTargetDict, CmdCppDict) = self.ParserCCodeFile(T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number)\n                resp_file_number += 1\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': CCodeDeps}\n                CmdLine = self._BUILD_TARGET_TEMPLATE.Replace(TargetDict).rstrip().replace('\\t$(OBJLIST', '$(OBJLIST')\n                if T.Commands:\n                    CmdLine = '%s%s' % (CmdLine, TAB_LINE_BREAK)\n                if CCodeDeps or CmdLine:\n                    self.BuildTargetList.append(CmdLine)\n            else:\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': Deps}\n                self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(TargetDict))\n                for i in T.Outputs[1:]:\n                    AnnexeTargetDict = {'target': self.PlaceMacro(i.Path, self.Macros), 'cmd': '', 'deps': self.PlaceMacro(T.Target.Path, self.Macros)}\n                    self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(AnnexeTargetDict))",
            "def ProcessBuildTargetList(self, RespFile, ToolsDef):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ForceIncludedFile = []\n    for File in self._AutoGenObject.AutoGenFileList:\n        if File.Ext == '.h':\n            ForceIncludedFile.append(File)\n    SourceFileList = []\n    OutPutFileList = []\n    for Target in self._AutoGenObject.IntroTargetList:\n        SourceFileList.extend(Target.Inputs)\n        OutPutFileList.extend(Target.Outputs)\n    if OutPutFileList:\n        for Item in OutPutFileList:\n            if Item in SourceFileList:\n                SourceFileList.remove(Item)\n    FileDependencyDict = {item: ForceIncludedFile for item in SourceFileList}\n    for Dependency in FileDependencyDict.values():\n        self.DependencyHeaderFileSet.update(set(Dependency))\n    parentMetaFileIncludes = set()\n    for aInclude in self._AutoGenObject.PackageIncludePathList:\n        aIncludeName = str(aInclude)\n        parentMetaFileIncludes.add(aIncludeName.lower())\n    headerFilesInMetaFileSet = set()\n    for aFile in self._AutoGenObject.SourceFileList:\n        aFileName = str(aFile)\n        if not aFileName.endswith('.h'):\n            continue\n        headerFilesInMetaFileSet.add(aFileName.lower())\n    localAutoGenFileSet = set()\n    for aFile in self._AutoGenObject.AutoGenFileList:\n        localAutoGenFileSet.add(str(aFile).lower())\n    headerFileDependencySet = set()\n    localSourceDir = str(self._AutoGenObject.SourceDir).lower()\n    for Dependency in FileDependencyDict.values():\n        for aFile in Dependency:\n            aFileName = str(aFile).lower()\n            if not aFileName.endswith('.h'):\n                continue\n            if aFileName in localAutoGenFileSet:\n                continue\n            if localSourceDir not in aFileName:\n                continue\n            pathNeeded = True\n            for aIncludePath in parentMetaFileIncludes:\n                if aIncludePath in aFileName:\n                    pathNeeded = False\n                    break\n            if not pathNeeded:\n                continue\n            headerFileDependencySet.add(aFileName)\n    for aFile in headerFileDependencySet:\n        if aFile in headerFilesInMetaFileSet:\n            continue\n        if GlobalData.gUseHashCache:\n            GlobalData.gModuleBuildTracking[self._AutoGenObject] = 'FAIL_METAFILE'\n        EdkLogger.warn('build', 'Module MetaFile [Sources] is missing local header!', ExtraData='Local Header: ' + aFile + ' not found in ' + self._AutoGenObject.MetaFile.Path)\n    for (File, Dependency) in FileDependencyDict.items():\n        if not Dependency:\n            continue\n        self._AutoGenObject.AutoGenDepSet |= set(Dependency)\n    CmdSumDict = {}\n    CmdTargetDict = {}\n    CmdCppDict = {}\n    DependencyDict = FileDependencyDict.copy()\n    if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and TAB_C_CODE_FILE in self._AutoGenObject.Targets:\n        for T in self._AutoGenObject.Targets[TAB_C_CODE_FILE]:\n            NewFile = self.PlaceMacro(str(T), self.Macros)\n            if not self.ObjTargetDict.get(T.Target.SubDir):\n                self.ObjTargetDict[T.Target.SubDir] = set()\n            self.ObjTargetDict[T.Target.SubDir].add(NewFile)\n    for Type in self._AutoGenObject.Targets:\n        resp_file_number = 0\n        for T in self._AutoGenObject.Targets[Type]:\n            if T.GenFileListMacro and T.FileListMacro not in self.FileListMacros:\n                self.FileListMacros[T.FileListMacro] = []\n            if T.GenListFile and T.ListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.ListFileMacro] = []\n            if T.GenIncListFile and T.IncListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.IncListFileMacro] = []\n            Deps = []\n            CCodeDeps = []\n            for Dep in T.Dependencies:\n                Deps.append(self.PlaceMacro(str(Dep), self.Macros))\n                if Dep != '$(MAKE_FILE)':\n                    CCodeDeps.append(self.PlaceMacro(str(Dep), self.Macros))\n            if len(T.Inputs) == 1 and T.Inputs[0] in FileDependencyDict:\n                for F in FileDependencyDict[T.Inputs[0]]:\n                    Deps.append(self.PlaceMacro(str(F), self.Macros))\n            for F in T.Inputs:\n                NewFile = self.PlaceMacro(str(F), self.Macros)\n                if T.GenListFile:\n                    self.ListFileMacros[T.ListFileMacro].append(str(F).replace('\\\\', '/'))\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                elif T.GenFileListMacro:\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                else:\n                    Deps.append(NewFile)\n            for key in self.FileListMacros:\n                self.FileListMacros[key].sort()\n            if T.GenFileListMacro:\n                Deps.append('$(%s)' % T.FileListMacro)\n                if Type in [TAB_OBJECT_FILE, TAB_STATIC_LIBRARY]:\n                    Deps.append('$(%s)' % T.ListFileMacro)\n            if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and Type == TAB_C_CODE_FILE:\n                (T, CmdTarget, CmdTargetDict, CmdCppDict) = self.ParserCCodeFile(T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number)\n                resp_file_number += 1\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': CCodeDeps}\n                CmdLine = self._BUILD_TARGET_TEMPLATE.Replace(TargetDict).rstrip().replace('\\t$(OBJLIST', '$(OBJLIST')\n                if T.Commands:\n                    CmdLine = '%s%s' % (CmdLine, TAB_LINE_BREAK)\n                if CCodeDeps or CmdLine:\n                    self.BuildTargetList.append(CmdLine)\n            else:\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': Deps}\n                self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(TargetDict))\n                for i in T.Outputs[1:]:\n                    AnnexeTargetDict = {'target': self.PlaceMacro(i.Path, self.Macros), 'cmd': '', 'deps': self.PlaceMacro(T.Target.Path, self.Macros)}\n                    self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(AnnexeTargetDict))",
            "def ProcessBuildTargetList(self, RespFile, ToolsDef):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ForceIncludedFile = []\n    for File in self._AutoGenObject.AutoGenFileList:\n        if File.Ext == '.h':\n            ForceIncludedFile.append(File)\n    SourceFileList = []\n    OutPutFileList = []\n    for Target in self._AutoGenObject.IntroTargetList:\n        SourceFileList.extend(Target.Inputs)\n        OutPutFileList.extend(Target.Outputs)\n    if OutPutFileList:\n        for Item in OutPutFileList:\n            if Item in SourceFileList:\n                SourceFileList.remove(Item)\n    FileDependencyDict = {item: ForceIncludedFile for item in SourceFileList}\n    for Dependency in FileDependencyDict.values():\n        self.DependencyHeaderFileSet.update(set(Dependency))\n    parentMetaFileIncludes = set()\n    for aInclude in self._AutoGenObject.PackageIncludePathList:\n        aIncludeName = str(aInclude)\n        parentMetaFileIncludes.add(aIncludeName.lower())\n    headerFilesInMetaFileSet = set()\n    for aFile in self._AutoGenObject.SourceFileList:\n        aFileName = str(aFile)\n        if not aFileName.endswith('.h'):\n            continue\n        headerFilesInMetaFileSet.add(aFileName.lower())\n    localAutoGenFileSet = set()\n    for aFile in self._AutoGenObject.AutoGenFileList:\n        localAutoGenFileSet.add(str(aFile).lower())\n    headerFileDependencySet = set()\n    localSourceDir = str(self._AutoGenObject.SourceDir).lower()\n    for Dependency in FileDependencyDict.values():\n        for aFile in Dependency:\n            aFileName = str(aFile).lower()\n            if not aFileName.endswith('.h'):\n                continue\n            if aFileName in localAutoGenFileSet:\n                continue\n            if localSourceDir not in aFileName:\n                continue\n            pathNeeded = True\n            for aIncludePath in parentMetaFileIncludes:\n                if aIncludePath in aFileName:\n                    pathNeeded = False\n                    break\n            if not pathNeeded:\n                continue\n            headerFileDependencySet.add(aFileName)\n    for aFile in headerFileDependencySet:\n        if aFile in headerFilesInMetaFileSet:\n            continue\n        if GlobalData.gUseHashCache:\n            GlobalData.gModuleBuildTracking[self._AutoGenObject] = 'FAIL_METAFILE'\n        EdkLogger.warn('build', 'Module MetaFile [Sources] is missing local header!', ExtraData='Local Header: ' + aFile + ' not found in ' + self._AutoGenObject.MetaFile.Path)\n    for (File, Dependency) in FileDependencyDict.items():\n        if not Dependency:\n            continue\n        self._AutoGenObject.AutoGenDepSet |= set(Dependency)\n    CmdSumDict = {}\n    CmdTargetDict = {}\n    CmdCppDict = {}\n    DependencyDict = FileDependencyDict.copy()\n    if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and TAB_C_CODE_FILE in self._AutoGenObject.Targets:\n        for T in self._AutoGenObject.Targets[TAB_C_CODE_FILE]:\n            NewFile = self.PlaceMacro(str(T), self.Macros)\n            if not self.ObjTargetDict.get(T.Target.SubDir):\n                self.ObjTargetDict[T.Target.SubDir] = set()\n            self.ObjTargetDict[T.Target.SubDir].add(NewFile)\n    for Type in self._AutoGenObject.Targets:\n        resp_file_number = 0\n        for T in self._AutoGenObject.Targets[Type]:\n            if T.GenFileListMacro and T.FileListMacro not in self.FileListMacros:\n                self.FileListMacros[T.FileListMacro] = []\n            if T.GenListFile and T.ListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.ListFileMacro] = []\n            if T.GenIncListFile and T.IncListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.IncListFileMacro] = []\n            Deps = []\n            CCodeDeps = []\n            for Dep in T.Dependencies:\n                Deps.append(self.PlaceMacro(str(Dep), self.Macros))\n                if Dep != '$(MAKE_FILE)':\n                    CCodeDeps.append(self.PlaceMacro(str(Dep), self.Macros))\n            if len(T.Inputs) == 1 and T.Inputs[0] in FileDependencyDict:\n                for F in FileDependencyDict[T.Inputs[0]]:\n                    Deps.append(self.PlaceMacro(str(F), self.Macros))\n            for F in T.Inputs:\n                NewFile = self.PlaceMacro(str(F), self.Macros)\n                if T.GenListFile:\n                    self.ListFileMacros[T.ListFileMacro].append(str(F).replace('\\\\', '/'))\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                elif T.GenFileListMacro:\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                else:\n                    Deps.append(NewFile)\n            for key in self.FileListMacros:\n                self.FileListMacros[key].sort()\n            if T.GenFileListMacro:\n                Deps.append('$(%s)' % T.FileListMacro)\n                if Type in [TAB_OBJECT_FILE, TAB_STATIC_LIBRARY]:\n                    Deps.append('$(%s)' % T.ListFileMacro)\n            if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and Type == TAB_C_CODE_FILE:\n                (T, CmdTarget, CmdTargetDict, CmdCppDict) = self.ParserCCodeFile(T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number)\n                resp_file_number += 1\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': CCodeDeps}\n                CmdLine = self._BUILD_TARGET_TEMPLATE.Replace(TargetDict).rstrip().replace('\\t$(OBJLIST', '$(OBJLIST')\n                if T.Commands:\n                    CmdLine = '%s%s' % (CmdLine, TAB_LINE_BREAK)\n                if CCodeDeps or CmdLine:\n                    self.BuildTargetList.append(CmdLine)\n            else:\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': Deps}\n                self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(TargetDict))\n                for i in T.Outputs[1:]:\n                    AnnexeTargetDict = {'target': self.PlaceMacro(i.Path, self.Macros), 'cmd': '', 'deps': self.PlaceMacro(T.Target.Path, self.Macros)}\n                    self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(AnnexeTargetDict))",
            "def ProcessBuildTargetList(self, RespFile, ToolsDef):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ForceIncludedFile = []\n    for File in self._AutoGenObject.AutoGenFileList:\n        if File.Ext == '.h':\n            ForceIncludedFile.append(File)\n    SourceFileList = []\n    OutPutFileList = []\n    for Target in self._AutoGenObject.IntroTargetList:\n        SourceFileList.extend(Target.Inputs)\n        OutPutFileList.extend(Target.Outputs)\n    if OutPutFileList:\n        for Item in OutPutFileList:\n            if Item in SourceFileList:\n                SourceFileList.remove(Item)\n    FileDependencyDict = {item: ForceIncludedFile for item in SourceFileList}\n    for Dependency in FileDependencyDict.values():\n        self.DependencyHeaderFileSet.update(set(Dependency))\n    parentMetaFileIncludes = set()\n    for aInclude in self._AutoGenObject.PackageIncludePathList:\n        aIncludeName = str(aInclude)\n        parentMetaFileIncludes.add(aIncludeName.lower())\n    headerFilesInMetaFileSet = set()\n    for aFile in self._AutoGenObject.SourceFileList:\n        aFileName = str(aFile)\n        if not aFileName.endswith('.h'):\n            continue\n        headerFilesInMetaFileSet.add(aFileName.lower())\n    localAutoGenFileSet = set()\n    for aFile in self._AutoGenObject.AutoGenFileList:\n        localAutoGenFileSet.add(str(aFile).lower())\n    headerFileDependencySet = set()\n    localSourceDir = str(self._AutoGenObject.SourceDir).lower()\n    for Dependency in FileDependencyDict.values():\n        for aFile in Dependency:\n            aFileName = str(aFile).lower()\n            if not aFileName.endswith('.h'):\n                continue\n            if aFileName in localAutoGenFileSet:\n                continue\n            if localSourceDir not in aFileName:\n                continue\n            pathNeeded = True\n            for aIncludePath in parentMetaFileIncludes:\n                if aIncludePath in aFileName:\n                    pathNeeded = False\n                    break\n            if not pathNeeded:\n                continue\n            headerFileDependencySet.add(aFileName)\n    for aFile in headerFileDependencySet:\n        if aFile in headerFilesInMetaFileSet:\n            continue\n        if GlobalData.gUseHashCache:\n            GlobalData.gModuleBuildTracking[self._AutoGenObject] = 'FAIL_METAFILE'\n        EdkLogger.warn('build', 'Module MetaFile [Sources] is missing local header!', ExtraData='Local Header: ' + aFile + ' not found in ' + self._AutoGenObject.MetaFile.Path)\n    for (File, Dependency) in FileDependencyDict.items():\n        if not Dependency:\n            continue\n        self._AutoGenObject.AutoGenDepSet |= set(Dependency)\n    CmdSumDict = {}\n    CmdTargetDict = {}\n    CmdCppDict = {}\n    DependencyDict = FileDependencyDict.copy()\n    if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and TAB_C_CODE_FILE in self._AutoGenObject.Targets:\n        for T in self._AutoGenObject.Targets[TAB_C_CODE_FILE]:\n            NewFile = self.PlaceMacro(str(T), self.Macros)\n            if not self.ObjTargetDict.get(T.Target.SubDir):\n                self.ObjTargetDict[T.Target.SubDir] = set()\n            self.ObjTargetDict[T.Target.SubDir].add(NewFile)\n    for Type in self._AutoGenObject.Targets:\n        resp_file_number = 0\n        for T in self._AutoGenObject.Targets[Type]:\n            if T.GenFileListMacro and T.FileListMacro not in self.FileListMacros:\n                self.FileListMacros[T.FileListMacro] = []\n            if T.GenListFile and T.ListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.ListFileMacro] = []\n            if T.GenIncListFile and T.IncListFileMacro not in self.ListFileMacros:\n                self.ListFileMacros[T.IncListFileMacro] = []\n            Deps = []\n            CCodeDeps = []\n            for Dep in T.Dependencies:\n                Deps.append(self.PlaceMacro(str(Dep), self.Macros))\n                if Dep != '$(MAKE_FILE)':\n                    CCodeDeps.append(self.PlaceMacro(str(Dep), self.Macros))\n            if len(T.Inputs) == 1 and T.Inputs[0] in FileDependencyDict:\n                for F in FileDependencyDict[T.Inputs[0]]:\n                    Deps.append(self.PlaceMacro(str(F), self.Macros))\n            for F in T.Inputs:\n                NewFile = self.PlaceMacro(str(F), self.Macros)\n                if T.GenListFile:\n                    self.ListFileMacros[T.ListFileMacro].append(str(F).replace('\\\\', '/'))\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                elif T.GenFileListMacro:\n                    self.FileListMacros[T.FileListMacro].append(NewFile)\n                else:\n                    Deps.append(NewFile)\n            for key in self.FileListMacros:\n                self.FileListMacros[key].sort()\n            if T.GenFileListMacro:\n                Deps.append('$(%s)' % T.FileListMacro)\n                if Type in [TAB_OBJECT_FILE, TAB_STATIC_LIBRARY]:\n                    Deps.append('$(%s)' % T.ListFileMacro)\n            if self._AutoGenObject.BuildRuleFamily == TAB_COMPILER_MSFT and Type == TAB_C_CODE_FILE:\n                (T, CmdTarget, CmdTargetDict, CmdCppDict) = self.ParserCCodeFile(T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number)\n                resp_file_number += 1\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': CCodeDeps}\n                CmdLine = self._BUILD_TARGET_TEMPLATE.Replace(TargetDict).rstrip().replace('\\t$(OBJLIST', '$(OBJLIST')\n                if T.Commands:\n                    CmdLine = '%s%s' % (CmdLine, TAB_LINE_BREAK)\n                if CCodeDeps or CmdLine:\n                    self.BuildTargetList.append(CmdLine)\n            else:\n                TargetDict = {'target': self.PlaceMacro(T.Target.Path, self.Macros), 'cmd': '\\n\\t'.join(T.Commands), 'deps': Deps}\n                self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(TargetDict))\n                for i in T.Outputs[1:]:\n                    AnnexeTargetDict = {'target': self.PlaceMacro(i.Path, self.Macros), 'cmd': '', 'deps': self.PlaceMacro(T.Target.Path, self.Macros)}\n                    self.BuildTargetList.append(self._BUILD_TARGET_TEMPLATE.Replace(AnnexeTargetDict))"
        ]
    },
    {
        "func_name": "ParserCCodeFile",
        "original": "def ParserCCodeFile(self, T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number):\n    SaveFilePath = os.path.join(RespFile, 'cc_resp_%s.txt' % resp_file_number)\n    if not CmdSumDict:\n        for item in self._AutoGenObject.Targets[Type]:\n            CmdSumDict[item.Target.SubDir] = item.Target.BaseName\n            for CppPath in item.Inputs:\n                Path = self.PlaceMacro(CppPath.Path, self.Macros)\n                if CmdCppDict.get(item.Target.SubDir):\n                    CmdCppDict[item.Target.SubDir].append(Path)\n                else:\n                    CmdCppDict[item.Target.SubDir] = ['$(MAKE_FILE)', Path]\n                if CppPath.Path in DependencyDict:\n                    for Temp in DependencyDict[CppPath.Path]:\n                        try:\n                            Path = self.PlaceMacro(Temp.Path, self.Macros)\n                        except:\n                            continue\n                        if Path not in self.CommonFileDependency + CmdCppDict[item.Target.SubDir]:\n                            CmdCppDict[item.Target.SubDir].append(Path)\n    if T.Commands:\n        CommandList = T.Commands[:]\n        for Item in CommandList[:]:\n            SingleCommandList = Item.split()\n            if len(SingleCommandList) > 0 and self.CheckCCCmd(SingleCommandList):\n                for Temp in SingleCommandList:\n                    if Temp.startswith('/Fo'):\n                        CmdSign = '%s%s' % (Temp.rsplit(TAB_SLASH, 1)[0], TAB_SLASH)\n                        break\n                else:\n                    continue\n                if CmdSign not in list(CmdTargetDict.keys()):\n                    cmd = Item.replace(Temp, CmdSign)\n                    if SingleCommandList[-1] in cmd:\n                        CmdTargetDict[CmdSign] = [cmd.replace(SingleCommandList[-1], '').rstrip(), SingleCommandList[-1]]\n                else:\n                    CmdTargetDict[CmdSign].append(SingleCommandList[-1])\n                Index = CommandList.index(Item)\n                CommandList.pop(Index)\n                BaseName = SingleCommandList[-1].rsplit('.', 1)[0]\n                if BaseName.endswith('%s%s' % (TAB_SLASH, CmdSumDict[CmdSign[3:].rsplit(TAB_SLASH, 1)[0]])):\n                    Cpplist = CmdCppDict[T.Target.SubDir]\n                    Cpplist.insert(0, '$(OBJLIST_%d): ' % list(self.ObjTargetDict.keys()).index(T.Target.SubDir))\n                    source_files = CmdTargetDict[CmdSign][1:]\n                    source_files.insert(0, ' ')\n                    if len(source_files) > 2:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    elif len(source_files) <= 2 and len(' '.join(CmdTargetDict[CmdSign][:2])) > GlobalData.gCommandMaxLength:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    else:\n                        T.Commands[Index] = '%s\\n\\t%s' % (' \\\\\\n\\t'.join(Cpplist), ' '.join(CmdTargetDict[CmdSign]))\n                else:\n                    T.Commands.pop(Index)\n    return (T, CmdSumDict, CmdTargetDict, CmdCppDict)",
        "mutated": [
            "def ParserCCodeFile(self, T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number):\n    if False:\n        i = 10\n    SaveFilePath = os.path.join(RespFile, 'cc_resp_%s.txt' % resp_file_number)\n    if not CmdSumDict:\n        for item in self._AutoGenObject.Targets[Type]:\n            CmdSumDict[item.Target.SubDir] = item.Target.BaseName\n            for CppPath in item.Inputs:\n                Path = self.PlaceMacro(CppPath.Path, self.Macros)\n                if CmdCppDict.get(item.Target.SubDir):\n                    CmdCppDict[item.Target.SubDir].append(Path)\n                else:\n                    CmdCppDict[item.Target.SubDir] = ['$(MAKE_FILE)', Path]\n                if CppPath.Path in DependencyDict:\n                    for Temp in DependencyDict[CppPath.Path]:\n                        try:\n                            Path = self.PlaceMacro(Temp.Path, self.Macros)\n                        except:\n                            continue\n                        if Path not in self.CommonFileDependency + CmdCppDict[item.Target.SubDir]:\n                            CmdCppDict[item.Target.SubDir].append(Path)\n    if T.Commands:\n        CommandList = T.Commands[:]\n        for Item in CommandList[:]:\n            SingleCommandList = Item.split()\n            if len(SingleCommandList) > 0 and self.CheckCCCmd(SingleCommandList):\n                for Temp in SingleCommandList:\n                    if Temp.startswith('/Fo'):\n                        CmdSign = '%s%s' % (Temp.rsplit(TAB_SLASH, 1)[0], TAB_SLASH)\n                        break\n                else:\n                    continue\n                if CmdSign not in list(CmdTargetDict.keys()):\n                    cmd = Item.replace(Temp, CmdSign)\n                    if SingleCommandList[-1] in cmd:\n                        CmdTargetDict[CmdSign] = [cmd.replace(SingleCommandList[-1], '').rstrip(), SingleCommandList[-1]]\n                else:\n                    CmdTargetDict[CmdSign].append(SingleCommandList[-1])\n                Index = CommandList.index(Item)\n                CommandList.pop(Index)\n                BaseName = SingleCommandList[-1].rsplit('.', 1)[0]\n                if BaseName.endswith('%s%s' % (TAB_SLASH, CmdSumDict[CmdSign[3:].rsplit(TAB_SLASH, 1)[0]])):\n                    Cpplist = CmdCppDict[T.Target.SubDir]\n                    Cpplist.insert(0, '$(OBJLIST_%d): ' % list(self.ObjTargetDict.keys()).index(T.Target.SubDir))\n                    source_files = CmdTargetDict[CmdSign][1:]\n                    source_files.insert(0, ' ')\n                    if len(source_files) > 2:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    elif len(source_files) <= 2 and len(' '.join(CmdTargetDict[CmdSign][:2])) > GlobalData.gCommandMaxLength:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    else:\n                        T.Commands[Index] = '%s\\n\\t%s' % (' \\\\\\n\\t'.join(Cpplist), ' '.join(CmdTargetDict[CmdSign]))\n                else:\n                    T.Commands.pop(Index)\n    return (T, CmdSumDict, CmdTargetDict, CmdCppDict)",
            "def ParserCCodeFile(self, T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    SaveFilePath = os.path.join(RespFile, 'cc_resp_%s.txt' % resp_file_number)\n    if not CmdSumDict:\n        for item in self._AutoGenObject.Targets[Type]:\n            CmdSumDict[item.Target.SubDir] = item.Target.BaseName\n            for CppPath in item.Inputs:\n                Path = self.PlaceMacro(CppPath.Path, self.Macros)\n                if CmdCppDict.get(item.Target.SubDir):\n                    CmdCppDict[item.Target.SubDir].append(Path)\n                else:\n                    CmdCppDict[item.Target.SubDir] = ['$(MAKE_FILE)', Path]\n                if CppPath.Path in DependencyDict:\n                    for Temp in DependencyDict[CppPath.Path]:\n                        try:\n                            Path = self.PlaceMacro(Temp.Path, self.Macros)\n                        except:\n                            continue\n                        if Path not in self.CommonFileDependency + CmdCppDict[item.Target.SubDir]:\n                            CmdCppDict[item.Target.SubDir].append(Path)\n    if T.Commands:\n        CommandList = T.Commands[:]\n        for Item in CommandList[:]:\n            SingleCommandList = Item.split()\n            if len(SingleCommandList) > 0 and self.CheckCCCmd(SingleCommandList):\n                for Temp in SingleCommandList:\n                    if Temp.startswith('/Fo'):\n                        CmdSign = '%s%s' % (Temp.rsplit(TAB_SLASH, 1)[0], TAB_SLASH)\n                        break\n                else:\n                    continue\n                if CmdSign not in list(CmdTargetDict.keys()):\n                    cmd = Item.replace(Temp, CmdSign)\n                    if SingleCommandList[-1] in cmd:\n                        CmdTargetDict[CmdSign] = [cmd.replace(SingleCommandList[-1], '').rstrip(), SingleCommandList[-1]]\n                else:\n                    CmdTargetDict[CmdSign].append(SingleCommandList[-1])\n                Index = CommandList.index(Item)\n                CommandList.pop(Index)\n                BaseName = SingleCommandList[-1].rsplit('.', 1)[0]\n                if BaseName.endswith('%s%s' % (TAB_SLASH, CmdSumDict[CmdSign[3:].rsplit(TAB_SLASH, 1)[0]])):\n                    Cpplist = CmdCppDict[T.Target.SubDir]\n                    Cpplist.insert(0, '$(OBJLIST_%d): ' % list(self.ObjTargetDict.keys()).index(T.Target.SubDir))\n                    source_files = CmdTargetDict[CmdSign][1:]\n                    source_files.insert(0, ' ')\n                    if len(source_files) > 2:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    elif len(source_files) <= 2 and len(' '.join(CmdTargetDict[CmdSign][:2])) > GlobalData.gCommandMaxLength:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    else:\n                        T.Commands[Index] = '%s\\n\\t%s' % (' \\\\\\n\\t'.join(Cpplist), ' '.join(CmdTargetDict[CmdSign]))\n                else:\n                    T.Commands.pop(Index)\n    return (T, CmdSumDict, CmdTargetDict, CmdCppDict)",
            "def ParserCCodeFile(self, T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    SaveFilePath = os.path.join(RespFile, 'cc_resp_%s.txt' % resp_file_number)\n    if not CmdSumDict:\n        for item in self._AutoGenObject.Targets[Type]:\n            CmdSumDict[item.Target.SubDir] = item.Target.BaseName\n            for CppPath in item.Inputs:\n                Path = self.PlaceMacro(CppPath.Path, self.Macros)\n                if CmdCppDict.get(item.Target.SubDir):\n                    CmdCppDict[item.Target.SubDir].append(Path)\n                else:\n                    CmdCppDict[item.Target.SubDir] = ['$(MAKE_FILE)', Path]\n                if CppPath.Path in DependencyDict:\n                    for Temp in DependencyDict[CppPath.Path]:\n                        try:\n                            Path = self.PlaceMacro(Temp.Path, self.Macros)\n                        except:\n                            continue\n                        if Path not in self.CommonFileDependency + CmdCppDict[item.Target.SubDir]:\n                            CmdCppDict[item.Target.SubDir].append(Path)\n    if T.Commands:\n        CommandList = T.Commands[:]\n        for Item in CommandList[:]:\n            SingleCommandList = Item.split()\n            if len(SingleCommandList) > 0 and self.CheckCCCmd(SingleCommandList):\n                for Temp in SingleCommandList:\n                    if Temp.startswith('/Fo'):\n                        CmdSign = '%s%s' % (Temp.rsplit(TAB_SLASH, 1)[0], TAB_SLASH)\n                        break\n                else:\n                    continue\n                if CmdSign not in list(CmdTargetDict.keys()):\n                    cmd = Item.replace(Temp, CmdSign)\n                    if SingleCommandList[-1] in cmd:\n                        CmdTargetDict[CmdSign] = [cmd.replace(SingleCommandList[-1], '').rstrip(), SingleCommandList[-1]]\n                else:\n                    CmdTargetDict[CmdSign].append(SingleCommandList[-1])\n                Index = CommandList.index(Item)\n                CommandList.pop(Index)\n                BaseName = SingleCommandList[-1].rsplit('.', 1)[0]\n                if BaseName.endswith('%s%s' % (TAB_SLASH, CmdSumDict[CmdSign[3:].rsplit(TAB_SLASH, 1)[0]])):\n                    Cpplist = CmdCppDict[T.Target.SubDir]\n                    Cpplist.insert(0, '$(OBJLIST_%d): ' % list(self.ObjTargetDict.keys()).index(T.Target.SubDir))\n                    source_files = CmdTargetDict[CmdSign][1:]\n                    source_files.insert(0, ' ')\n                    if len(source_files) > 2:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    elif len(source_files) <= 2 and len(' '.join(CmdTargetDict[CmdSign][:2])) > GlobalData.gCommandMaxLength:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    else:\n                        T.Commands[Index] = '%s\\n\\t%s' % (' \\\\\\n\\t'.join(Cpplist), ' '.join(CmdTargetDict[CmdSign]))\n                else:\n                    T.Commands.pop(Index)\n    return (T, CmdSumDict, CmdTargetDict, CmdCppDict)",
            "def ParserCCodeFile(self, T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    SaveFilePath = os.path.join(RespFile, 'cc_resp_%s.txt' % resp_file_number)\n    if not CmdSumDict:\n        for item in self._AutoGenObject.Targets[Type]:\n            CmdSumDict[item.Target.SubDir] = item.Target.BaseName\n            for CppPath in item.Inputs:\n                Path = self.PlaceMacro(CppPath.Path, self.Macros)\n                if CmdCppDict.get(item.Target.SubDir):\n                    CmdCppDict[item.Target.SubDir].append(Path)\n                else:\n                    CmdCppDict[item.Target.SubDir] = ['$(MAKE_FILE)', Path]\n                if CppPath.Path in DependencyDict:\n                    for Temp in DependencyDict[CppPath.Path]:\n                        try:\n                            Path = self.PlaceMacro(Temp.Path, self.Macros)\n                        except:\n                            continue\n                        if Path not in self.CommonFileDependency + CmdCppDict[item.Target.SubDir]:\n                            CmdCppDict[item.Target.SubDir].append(Path)\n    if T.Commands:\n        CommandList = T.Commands[:]\n        for Item in CommandList[:]:\n            SingleCommandList = Item.split()\n            if len(SingleCommandList) > 0 and self.CheckCCCmd(SingleCommandList):\n                for Temp in SingleCommandList:\n                    if Temp.startswith('/Fo'):\n                        CmdSign = '%s%s' % (Temp.rsplit(TAB_SLASH, 1)[0], TAB_SLASH)\n                        break\n                else:\n                    continue\n                if CmdSign not in list(CmdTargetDict.keys()):\n                    cmd = Item.replace(Temp, CmdSign)\n                    if SingleCommandList[-1] in cmd:\n                        CmdTargetDict[CmdSign] = [cmd.replace(SingleCommandList[-1], '').rstrip(), SingleCommandList[-1]]\n                else:\n                    CmdTargetDict[CmdSign].append(SingleCommandList[-1])\n                Index = CommandList.index(Item)\n                CommandList.pop(Index)\n                BaseName = SingleCommandList[-1].rsplit('.', 1)[0]\n                if BaseName.endswith('%s%s' % (TAB_SLASH, CmdSumDict[CmdSign[3:].rsplit(TAB_SLASH, 1)[0]])):\n                    Cpplist = CmdCppDict[T.Target.SubDir]\n                    Cpplist.insert(0, '$(OBJLIST_%d): ' % list(self.ObjTargetDict.keys()).index(T.Target.SubDir))\n                    source_files = CmdTargetDict[CmdSign][1:]\n                    source_files.insert(0, ' ')\n                    if len(source_files) > 2:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    elif len(source_files) <= 2 and len(' '.join(CmdTargetDict[CmdSign][:2])) > GlobalData.gCommandMaxLength:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    else:\n                        T.Commands[Index] = '%s\\n\\t%s' % (' \\\\\\n\\t'.join(Cpplist), ' '.join(CmdTargetDict[CmdSign]))\n                else:\n                    T.Commands.pop(Index)\n    return (T, CmdSumDict, CmdTargetDict, CmdCppDict)",
            "def ParserCCodeFile(self, T, Type, CmdSumDict, CmdTargetDict, CmdCppDict, DependencyDict, RespFile, ToolsDef, resp_file_number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    SaveFilePath = os.path.join(RespFile, 'cc_resp_%s.txt' % resp_file_number)\n    if not CmdSumDict:\n        for item in self._AutoGenObject.Targets[Type]:\n            CmdSumDict[item.Target.SubDir] = item.Target.BaseName\n            for CppPath in item.Inputs:\n                Path = self.PlaceMacro(CppPath.Path, self.Macros)\n                if CmdCppDict.get(item.Target.SubDir):\n                    CmdCppDict[item.Target.SubDir].append(Path)\n                else:\n                    CmdCppDict[item.Target.SubDir] = ['$(MAKE_FILE)', Path]\n                if CppPath.Path in DependencyDict:\n                    for Temp in DependencyDict[CppPath.Path]:\n                        try:\n                            Path = self.PlaceMacro(Temp.Path, self.Macros)\n                        except:\n                            continue\n                        if Path not in self.CommonFileDependency + CmdCppDict[item.Target.SubDir]:\n                            CmdCppDict[item.Target.SubDir].append(Path)\n    if T.Commands:\n        CommandList = T.Commands[:]\n        for Item in CommandList[:]:\n            SingleCommandList = Item.split()\n            if len(SingleCommandList) > 0 and self.CheckCCCmd(SingleCommandList):\n                for Temp in SingleCommandList:\n                    if Temp.startswith('/Fo'):\n                        CmdSign = '%s%s' % (Temp.rsplit(TAB_SLASH, 1)[0], TAB_SLASH)\n                        break\n                else:\n                    continue\n                if CmdSign not in list(CmdTargetDict.keys()):\n                    cmd = Item.replace(Temp, CmdSign)\n                    if SingleCommandList[-1] in cmd:\n                        CmdTargetDict[CmdSign] = [cmd.replace(SingleCommandList[-1], '').rstrip(), SingleCommandList[-1]]\n                else:\n                    CmdTargetDict[CmdSign].append(SingleCommandList[-1])\n                Index = CommandList.index(Item)\n                CommandList.pop(Index)\n                BaseName = SingleCommandList[-1].rsplit('.', 1)[0]\n                if BaseName.endswith('%s%s' % (TAB_SLASH, CmdSumDict[CmdSign[3:].rsplit(TAB_SLASH, 1)[0]])):\n                    Cpplist = CmdCppDict[T.Target.SubDir]\n                    Cpplist.insert(0, '$(OBJLIST_%d): ' % list(self.ObjTargetDict.keys()).index(T.Target.SubDir))\n                    source_files = CmdTargetDict[CmdSign][1:]\n                    source_files.insert(0, ' ')\n                    if len(source_files) > 2:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    elif len(source_files) <= 2 and len(' '.join(CmdTargetDict[CmdSign][:2])) > GlobalData.gCommandMaxLength:\n                        SaveFileOnChange(SaveFilePath, ' '.join(source_files), False)\n                        T.Commands[Index] = '%s\\n\\t%s $(cc_resp_%s)' % (' \\\\\\n\\t'.join(Cpplist), CmdTargetDict[CmdSign][0], resp_file_number)\n                        ToolsDef.append('cc_resp_%s = @%s' % (resp_file_number, SaveFilePath))\n                    else:\n                        T.Commands[Index] = '%s\\n\\t%s' % (' \\\\\\n\\t'.join(Cpplist), ' '.join(CmdTargetDict[CmdSign]))\n                else:\n                    T.Commands.pop(Index)\n    return (T, CmdSumDict, CmdTargetDict, CmdCppDict)"
        ]
    },
    {
        "func_name": "CheckCCCmd",
        "original": "def CheckCCCmd(self, CommandList):\n    for cmd in CommandList:\n        if '$(CC)' in cmd:\n            return True\n    return False",
        "mutated": [
            "def CheckCCCmd(self, CommandList):\n    if False:\n        i = 10\n    for cmd in CommandList:\n        if '$(CC)' in cmd:\n            return True\n    return False",
            "def CheckCCCmd(self, CommandList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for cmd in CommandList:\n        if '$(CC)' in cmd:\n            return True\n    return False",
            "def CheckCCCmd(self, CommandList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for cmd in CommandList:\n        if '$(CC)' in cmd:\n            return True\n    return False",
            "def CheckCCCmd(self, CommandList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for cmd in CommandList:\n        if '$(CC)' in cmd:\n            return True\n    return False",
            "def CheckCCCmd(self, CommandList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for cmd in CommandList:\n        if '$(CC)' in cmd:\n            return True\n    return False"
        ]
    },
    {
        "func_name": "ProcessDependentLibrary",
        "original": "def ProcessDependentLibrary(self):\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            self.LibraryBuildDirectoryList.append(self.PlaceMacro(LibraryAutoGen.BuildDir, self.Macros))",
        "mutated": [
            "def ProcessDependentLibrary(self):\n    if False:\n        i = 10\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            self.LibraryBuildDirectoryList.append(self.PlaceMacro(LibraryAutoGen.BuildDir, self.Macros))",
            "def ProcessDependentLibrary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            self.LibraryBuildDirectoryList.append(self.PlaceMacro(LibraryAutoGen.BuildDir, self.Macros))",
            "def ProcessDependentLibrary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            self.LibraryBuildDirectoryList.append(self.PlaceMacro(LibraryAutoGen.BuildDir, self.Macros))",
            "def ProcessDependentLibrary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            self.LibraryBuildDirectoryList.append(self.PlaceMacro(LibraryAutoGen.BuildDir, self.Macros))",
            "def ProcessDependentLibrary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            self.LibraryBuildDirectoryList.append(self.PlaceMacro(LibraryAutoGen.BuildDir, self.Macros))"
        ]
    },
    {
        "func_name": "GetFileDependency",
        "original": "def GetFileDependency(self, FileList, ForceInculeList, SearchPathList):\n    Dependency = {}\n    for F in FileList:\n        Dependency[F] = GetDependencyList(self._AutoGenObject, self.FileCache, F, ForceInculeList, SearchPathList)\n    return Dependency",
        "mutated": [
            "def GetFileDependency(self, FileList, ForceInculeList, SearchPathList):\n    if False:\n        i = 10\n    Dependency = {}\n    for F in FileList:\n        Dependency[F] = GetDependencyList(self._AutoGenObject, self.FileCache, F, ForceInculeList, SearchPathList)\n    return Dependency",
            "def GetFileDependency(self, FileList, ForceInculeList, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Dependency = {}\n    for F in FileList:\n        Dependency[F] = GetDependencyList(self._AutoGenObject, self.FileCache, F, ForceInculeList, SearchPathList)\n    return Dependency",
            "def GetFileDependency(self, FileList, ForceInculeList, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Dependency = {}\n    for F in FileList:\n        Dependency[F] = GetDependencyList(self._AutoGenObject, self.FileCache, F, ForceInculeList, SearchPathList)\n    return Dependency",
            "def GetFileDependency(self, FileList, ForceInculeList, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Dependency = {}\n    for F in FileList:\n        Dependency[F] = GetDependencyList(self._AutoGenObject, self.FileCache, F, ForceInculeList, SearchPathList)\n    return Dependency",
            "def GetFileDependency(self, FileList, ForceInculeList, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Dependency = {}\n    for F in FileList:\n        Dependency[F] = GetDependencyList(self._AutoGenObject, self.FileCache, F, ForceInculeList, SearchPathList)\n    return Dependency"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, ModuleAutoGen):\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.DependencyHeaderFileSet = set()",
        "mutated": [
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, ModuleAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    BuildFile.__init__(self, ModuleAutoGen)\n    self.PlatformInfo = self._AutoGenObject.PlatformInfo\n    self.IntermediateDirectoryList = ['$(DEBUG_DIR)', '$(OUTPUT_DIR)']\n    self.DependencyHeaderFileSet = set()"
        ]
    },
    {
        "func_name": "_TemplateDict",
        "original": "@property\ndef _TemplateDict(self):\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if self._FileType not in MyAgo.CustomMakefile:\n        EdkLogger.error('build', OPTION_NOT_SUPPORTED, 'No custom makefile for %s' % self._FileType, ExtraData='[%s]' % str(MyAgo))\n    MakefilePath = mws.join(MyAgo.WorkspaceDir, MyAgo.CustomMakefile[self._FileType])\n    try:\n        CustomMakefile = open(MakefilePath, 'r').read()\n    except:\n        EdkLogger.error('build', FILE_OPEN_FAILURE, File=str(MyAgo), ExtraData=MyAgo.CustomMakefile[self._FileType])\n    ToolsDef = []\n    for Tool in MyAgo.BuildOption:\n        if Tool == 'MAKE':\n            continue\n        for Attr in MyAgo.BuildOption[Tool]:\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, MyAgo.BuildOption[Tool][Attr]))\n            else:\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, MyAgo.BuildOption[Tool][Attr]))\n        ToolsDef.append('')\n    MakefileName = self.getMakefileName()\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(MyAgo.WorkspaceDir, MyAgo.SourceDir), 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'custom_makefile_content': CustomMakefile}\n    return MakefileTemplateDict",
        "mutated": [
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if self._FileType not in MyAgo.CustomMakefile:\n        EdkLogger.error('build', OPTION_NOT_SUPPORTED, 'No custom makefile for %s' % self._FileType, ExtraData='[%s]' % str(MyAgo))\n    MakefilePath = mws.join(MyAgo.WorkspaceDir, MyAgo.CustomMakefile[self._FileType])\n    try:\n        CustomMakefile = open(MakefilePath, 'r').read()\n    except:\n        EdkLogger.error('build', FILE_OPEN_FAILURE, File=str(MyAgo), ExtraData=MyAgo.CustomMakefile[self._FileType])\n    ToolsDef = []\n    for Tool in MyAgo.BuildOption:\n        if Tool == 'MAKE':\n            continue\n        for Attr in MyAgo.BuildOption[Tool]:\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, MyAgo.BuildOption[Tool][Attr]))\n            else:\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, MyAgo.BuildOption[Tool][Attr]))\n        ToolsDef.append('')\n    MakefileName = self.getMakefileName()\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(MyAgo.WorkspaceDir, MyAgo.SourceDir), 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'custom_makefile_content': CustomMakefile}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if self._FileType not in MyAgo.CustomMakefile:\n        EdkLogger.error('build', OPTION_NOT_SUPPORTED, 'No custom makefile for %s' % self._FileType, ExtraData='[%s]' % str(MyAgo))\n    MakefilePath = mws.join(MyAgo.WorkspaceDir, MyAgo.CustomMakefile[self._FileType])\n    try:\n        CustomMakefile = open(MakefilePath, 'r').read()\n    except:\n        EdkLogger.error('build', FILE_OPEN_FAILURE, File=str(MyAgo), ExtraData=MyAgo.CustomMakefile[self._FileType])\n    ToolsDef = []\n    for Tool in MyAgo.BuildOption:\n        if Tool == 'MAKE':\n            continue\n        for Attr in MyAgo.BuildOption[Tool]:\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, MyAgo.BuildOption[Tool][Attr]))\n            else:\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, MyAgo.BuildOption[Tool][Attr]))\n        ToolsDef.append('')\n    MakefileName = self.getMakefileName()\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(MyAgo.WorkspaceDir, MyAgo.SourceDir), 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'custom_makefile_content': CustomMakefile}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if self._FileType not in MyAgo.CustomMakefile:\n        EdkLogger.error('build', OPTION_NOT_SUPPORTED, 'No custom makefile for %s' % self._FileType, ExtraData='[%s]' % str(MyAgo))\n    MakefilePath = mws.join(MyAgo.WorkspaceDir, MyAgo.CustomMakefile[self._FileType])\n    try:\n        CustomMakefile = open(MakefilePath, 'r').read()\n    except:\n        EdkLogger.error('build', FILE_OPEN_FAILURE, File=str(MyAgo), ExtraData=MyAgo.CustomMakefile[self._FileType])\n    ToolsDef = []\n    for Tool in MyAgo.BuildOption:\n        if Tool == 'MAKE':\n            continue\n        for Attr in MyAgo.BuildOption[Tool]:\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, MyAgo.BuildOption[Tool][Attr]))\n            else:\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, MyAgo.BuildOption[Tool][Attr]))\n        ToolsDef.append('')\n    MakefileName = self.getMakefileName()\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(MyAgo.WorkspaceDir, MyAgo.SourceDir), 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'custom_makefile_content': CustomMakefile}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if self._FileType not in MyAgo.CustomMakefile:\n        EdkLogger.error('build', OPTION_NOT_SUPPORTED, 'No custom makefile for %s' % self._FileType, ExtraData='[%s]' % str(MyAgo))\n    MakefilePath = mws.join(MyAgo.WorkspaceDir, MyAgo.CustomMakefile[self._FileType])\n    try:\n        CustomMakefile = open(MakefilePath, 'r').read()\n    except:\n        EdkLogger.error('build', FILE_OPEN_FAILURE, File=str(MyAgo), ExtraData=MyAgo.CustomMakefile[self._FileType])\n    ToolsDef = []\n    for Tool in MyAgo.BuildOption:\n        if Tool == 'MAKE':\n            continue\n        for Attr in MyAgo.BuildOption[Tool]:\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, MyAgo.BuildOption[Tool][Attr]))\n            else:\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, MyAgo.BuildOption[Tool][Attr]))\n        ToolsDef.append('')\n    MakefileName = self.getMakefileName()\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(MyAgo.WorkspaceDir, MyAgo.SourceDir), 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'custom_makefile_content': CustomMakefile}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if self._FileType not in MyAgo.CustomMakefile:\n        EdkLogger.error('build', OPTION_NOT_SUPPORTED, 'No custom makefile for %s' % self._FileType, ExtraData='[%s]' % str(MyAgo))\n    MakefilePath = mws.join(MyAgo.WorkspaceDir, MyAgo.CustomMakefile[self._FileType])\n    try:\n        CustomMakefile = open(MakefilePath, 'r').read()\n    except:\n        EdkLogger.error('build', FILE_OPEN_FAILURE, File=str(MyAgo), ExtraData=MyAgo.CustomMakefile[self._FileType])\n    ToolsDef = []\n    for Tool in MyAgo.BuildOption:\n        if Tool == 'MAKE':\n            continue\n        for Attr in MyAgo.BuildOption[Tool]:\n            if Attr == 'FAMILY':\n                continue\n            elif Attr == 'PATH':\n                ToolsDef.append('%s = %s' % (Tool, MyAgo.BuildOption[Tool][Attr]))\n            else:\n                ToolsDef.append('%s_%s = %s' % (Tool, Attr, MyAgo.BuildOption[Tool][Attr]))\n        ToolsDef.append('')\n    MakefileName = self.getMakefileName()\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(MODULE_BUILD_DIR)', MakefileName), 'platform_name': self.PlatformInfo.Name, 'platform_guid': self.PlatformInfo.Guid, 'platform_version': self.PlatformInfo.Version, 'platform_relative_directory': self.PlatformInfo.SourceDir, 'platform_output_directory': self.PlatformInfo.OutputDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'module_name': MyAgo.Name, 'module_guid': MyAgo.Guid, 'module_name_guid': MyAgo.UniqueBaseName, 'module_version': MyAgo.Version, 'module_type': MyAgo.ModuleType, 'module_file': MyAgo.MetaFile, 'module_file_base_name': MyAgo.MetaFile.BaseName, 'module_relative_directory': MyAgo.SourceDir, 'module_dir': mws.join(MyAgo.WorkspaceDir, MyAgo.SourceDir), 'architecture': MyAgo.Arch, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'platform_build_directory': self.PlatformInfo.BuildDir, 'module_build_directory': MyAgo.BuildDir, 'module_output_directory': MyAgo.OutputDir, 'module_debug_directory': MyAgo.DebugDir, 'separator': Separator, 'module_tool_definitions': ToolsDef, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'custom_makefile_content': CustomMakefile}\n    return MakefileTemplateDict"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, PlatformAutoGen):\n    BuildFile.__init__(self, PlatformAutoGen)\n    self.ModuleBuildCommandList = []\n    self.ModuleMakefileList = []\n    self.IntermediateDirectoryList = []\n    self.ModuleBuildDirectoryList = []\n    self.LibraryBuildDirectoryList = []\n    self.LibraryMakeCommandList = []\n    self.DependencyHeaderFileSet = set()",
        "mutated": [
            "def __init__(self, PlatformAutoGen):\n    if False:\n        i = 10\n    BuildFile.__init__(self, PlatformAutoGen)\n    self.ModuleBuildCommandList = []\n    self.ModuleMakefileList = []\n    self.IntermediateDirectoryList = []\n    self.ModuleBuildDirectoryList = []\n    self.LibraryBuildDirectoryList = []\n    self.LibraryMakeCommandList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, PlatformAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    BuildFile.__init__(self, PlatformAutoGen)\n    self.ModuleBuildCommandList = []\n    self.ModuleMakefileList = []\n    self.IntermediateDirectoryList = []\n    self.ModuleBuildDirectoryList = []\n    self.LibraryBuildDirectoryList = []\n    self.LibraryMakeCommandList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, PlatformAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    BuildFile.__init__(self, PlatformAutoGen)\n    self.ModuleBuildCommandList = []\n    self.ModuleMakefileList = []\n    self.IntermediateDirectoryList = []\n    self.ModuleBuildDirectoryList = []\n    self.LibraryBuildDirectoryList = []\n    self.LibraryMakeCommandList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, PlatformAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    BuildFile.__init__(self, PlatformAutoGen)\n    self.ModuleBuildCommandList = []\n    self.ModuleMakefileList = []\n    self.IntermediateDirectoryList = []\n    self.ModuleBuildDirectoryList = []\n    self.LibraryBuildDirectoryList = []\n    self.LibraryMakeCommandList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, PlatformAutoGen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    BuildFile.__init__(self, PlatformAutoGen)\n    self.ModuleBuildCommandList = []\n    self.ModuleMakefileList = []\n    self.IntermediateDirectoryList = []\n    self.ModuleBuildDirectoryList = []\n    self.LibraryBuildDirectoryList = []\n    self.LibraryMakeCommandList = []\n    self.DependencyHeaderFileSet = set()"
        ]
    },
    {
        "func_name": "_TemplateDict",
        "original": "@property\ndef _TemplateDict(self):\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    self.IntermediateDirectoryList = ['$(BUILD_DIR)']\n    self.ModuleBuildDirectoryList = self.GetModuleBuildDirectoryList()\n    self.LibraryBuildDirectoryList = self.GetLibraryBuildDirectoryList()\n    MakefileName = self.getMakefileName()\n    LibraryMakefileList = []\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        LibraryMakefileList.append(Makefile)\n        LibraryMakeCommandList.append(Command)\n    self.LibraryMakeCommandList = LibraryMakeCommandList\n    ModuleMakefileList = []\n    ModuleMakeCommandList = []\n    for D in self.ModuleBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        ModuleMakefileList.append(Makefile)\n        ModuleMakeCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'makefile_name': MakefileName, 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_file': MyAgo.MetaFile, 'platform_relative_directory': MyAgo.SourceDir, 'platform_output_directory': MyAgo.OutputDir, 'platform_build_directory': MyAgo.BuildDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'build_architecture_list': MyAgo.Arch, 'architecture': MyAgo.Arch, 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'library_makefile_list': LibraryMakefileList, 'module_makefile_list': ModuleMakefileList, 'library_build_command': LibraryMakeCommandList, 'module_build_command': ModuleMakeCommandList}\n    return MakefileTemplateDict",
        "mutated": [
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    self.IntermediateDirectoryList = ['$(BUILD_DIR)']\n    self.ModuleBuildDirectoryList = self.GetModuleBuildDirectoryList()\n    self.LibraryBuildDirectoryList = self.GetLibraryBuildDirectoryList()\n    MakefileName = self.getMakefileName()\n    LibraryMakefileList = []\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        LibraryMakefileList.append(Makefile)\n        LibraryMakeCommandList.append(Command)\n    self.LibraryMakeCommandList = LibraryMakeCommandList\n    ModuleMakefileList = []\n    ModuleMakeCommandList = []\n    for D in self.ModuleBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        ModuleMakefileList.append(Makefile)\n        ModuleMakeCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'makefile_name': MakefileName, 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_file': MyAgo.MetaFile, 'platform_relative_directory': MyAgo.SourceDir, 'platform_output_directory': MyAgo.OutputDir, 'platform_build_directory': MyAgo.BuildDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'build_architecture_list': MyAgo.Arch, 'architecture': MyAgo.Arch, 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'library_makefile_list': LibraryMakefileList, 'module_makefile_list': ModuleMakefileList, 'library_build_command': LibraryMakeCommandList, 'module_build_command': ModuleMakeCommandList}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    self.IntermediateDirectoryList = ['$(BUILD_DIR)']\n    self.ModuleBuildDirectoryList = self.GetModuleBuildDirectoryList()\n    self.LibraryBuildDirectoryList = self.GetLibraryBuildDirectoryList()\n    MakefileName = self.getMakefileName()\n    LibraryMakefileList = []\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        LibraryMakefileList.append(Makefile)\n        LibraryMakeCommandList.append(Command)\n    self.LibraryMakeCommandList = LibraryMakeCommandList\n    ModuleMakefileList = []\n    ModuleMakeCommandList = []\n    for D in self.ModuleBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        ModuleMakefileList.append(Makefile)\n        ModuleMakeCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'makefile_name': MakefileName, 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_file': MyAgo.MetaFile, 'platform_relative_directory': MyAgo.SourceDir, 'platform_output_directory': MyAgo.OutputDir, 'platform_build_directory': MyAgo.BuildDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'build_architecture_list': MyAgo.Arch, 'architecture': MyAgo.Arch, 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'library_makefile_list': LibraryMakefileList, 'module_makefile_list': ModuleMakefileList, 'library_build_command': LibraryMakeCommandList, 'module_build_command': ModuleMakeCommandList}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    self.IntermediateDirectoryList = ['$(BUILD_DIR)']\n    self.ModuleBuildDirectoryList = self.GetModuleBuildDirectoryList()\n    self.LibraryBuildDirectoryList = self.GetLibraryBuildDirectoryList()\n    MakefileName = self.getMakefileName()\n    LibraryMakefileList = []\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        LibraryMakefileList.append(Makefile)\n        LibraryMakeCommandList.append(Command)\n    self.LibraryMakeCommandList = LibraryMakeCommandList\n    ModuleMakefileList = []\n    ModuleMakeCommandList = []\n    for D in self.ModuleBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        ModuleMakefileList.append(Makefile)\n        ModuleMakeCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'makefile_name': MakefileName, 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_file': MyAgo.MetaFile, 'platform_relative_directory': MyAgo.SourceDir, 'platform_output_directory': MyAgo.OutputDir, 'platform_build_directory': MyAgo.BuildDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'build_architecture_list': MyAgo.Arch, 'architecture': MyAgo.Arch, 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'library_makefile_list': LibraryMakefileList, 'module_makefile_list': ModuleMakefileList, 'library_build_command': LibraryMakeCommandList, 'module_build_command': ModuleMakeCommandList}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    self.IntermediateDirectoryList = ['$(BUILD_DIR)']\n    self.ModuleBuildDirectoryList = self.GetModuleBuildDirectoryList()\n    self.LibraryBuildDirectoryList = self.GetLibraryBuildDirectoryList()\n    MakefileName = self.getMakefileName()\n    LibraryMakefileList = []\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        LibraryMakefileList.append(Makefile)\n        LibraryMakeCommandList.append(Command)\n    self.LibraryMakeCommandList = LibraryMakeCommandList\n    ModuleMakefileList = []\n    ModuleMakeCommandList = []\n    for D in self.ModuleBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        ModuleMakefileList.append(Makefile)\n        ModuleMakeCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'makefile_name': MakefileName, 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_file': MyAgo.MetaFile, 'platform_relative_directory': MyAgo.SourceDir, 'platform_output_directory': MyAgo.OutputDir, 'platform_build_directory': MyAgo.BuildDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'build_architecture_list': MyAgo.Arch, 'architecture': MyAgo.Arch, 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'library_makefile_list': LibraryMakefileList, 'module_makefile_list': ModuleMakefileList, 'library_build_command': LibraryMakeCommandList, 'module_build_command': ModuleMakeCommandList}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    self.IntermediateDirectoryList = ['$(BUILD_DIR)']\n    self.ModuleBuildDirectoryList = self.GetModuleBuildDirectoryList()\n    self.LibraryBuildDirectoryList = self.GetLibraryBuildDirectoryList()\n    MakefileName = self.getMakefileName()\n    LibraryMakefileList = []\n    LibraryMakeCommandList = []\n    for D in self.LibraryBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        LibraryMakefileList.append(Makefile)\n        LibraryMakeCommandList.append(Command)\n    self.LibraryMakeCommandList = LibraryMakeCommandList\n    ModuleMakefileList = []\n    ModuleMakeCommandList = []\n    for D in self.ModuleBuildDirectoryList:\n        D = self.PlaceMacro(D, {'BUILD_DIR': MyAgo.BuildDir})\n        Makefile = os.path.join(D, MakefileName)\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': Makefile}\n        ModuleMakefileList.append(Makefile)\n        ModuleMakeCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'makefile_name': MakefileName, 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_file': MyAgo.MetaFile, 'platform_relative_directory': MyAgo.SourceDir, 'platform_output_directory': MyAgo.OutputDir, 'platform_build_directory': MyAgo.BuildDir, 'platform_dir': MyAgo.Macros['PLATFORM_DIR'], 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'build_architecture_list': MyAgo.Arch, 'architecture': MyAgo.Arch, 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'library_makefile_list': LibraryMakefileList, 'module_makefile_list': ModuleMakefileList, 'library_build_command': LibraryMakeCommandList, 'module_build_command': ModuleMakeCommandList}\n    return MakefileTemplateDict"
        ]
    },
    {
        "func_name": "GetModuleBuildDirectoryList",
        "original": "def GetModuleBuildDirectoryList(self):\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
        "mutated": [
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList"
        ]
    },
    {
        "func_name": "GetLibraryBuildDirectoryList",
        "original": "def GetLibraryBuildDirectoryList(self):\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
        "mutated": [
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, Workspace):\n    BuildFile.__init__(self, Workspace)\n    self.IntermediateDirectoryList = []\n    self.DependencyHeaderFileSet = set()",
        "mutated": [
            "def __init__(self, Workspace):\n    if False:\n        i = 10\n    BuildFile.__init__(self, Workspace)\n    self.IntermediateDirectoryList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, Workspace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    BuildFile.__init__(self, Workspace)\n    self.IntermediateDirectoryList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, Workspace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    BuildFile.__init__(self, Workspace)\n    self.IntermediateDirectoryList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, Workspace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    BuildFile.__init__(self, Workspace)\n    self.IntermediateDirectoryList = []\n    self.DependencyHeaderFileSet = set()",
            "def __init__(self, Workspace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    BuildFile.__init__(self, Workspace)\n    self.IntermediateDirectoryList = []\n    self.DependencyHeaderFileSet = set()"
        ]
    },
    {
        "func_name": "_TemplateDict",
        "original": "@property\ndef _TemplateDict(self):\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    for Arch in MyAgo.ArchList:\n        self.IntermediateDirectoryList.append(Separator.join(['$(BUILD_DIR)', Arch]))\n    self.IntermediateDirectoryList.append('$(FV_DIR)')\n    MacroList = []\n    if MyAgo.FdfFile is not None and MyAgo.FdfFile != '':\n        FdfFileList = [MyAgo.FdfFile]\n        MacroDict = {}\n        MacroDict.update(GlobalData.gGlobalDefines)\n        MacroDict.update(GlobalData.gCommandLineDefines)\n        for MacroName in MacroDict:\n            if MacroDict[MacroName] != '':\n                MacroList.append('\"%s=%s\"' % (MacroName, MacroDict[MacroName].replace('\\\\', '\\\\\\\\')))\n            else:\n                MacroList.append('\"%s\"' % MacroName)\n    else:\n        FdfFileList = []\n    ExtraOption = ''\n    LogLevel = EdkLogger.GetLevel()\n    if LogLevel == EdkLogger.VERBOSE:\n        ExtraOption += ' -v'\n    elif LogLevel <= EdkLogger.DEBUG_9:\n        ExtraOption += ' -d %d' % (LogLevel - 1)\n    elif LogLevel == EdkLogger.QUIET:\n        ExtraOption += ' -q'\n    if GlobalData.gCaseInsensitive:\n        ExtraOption += ' -c'\n    if not GlobalData.gEnableGenfdsMultiThread:\n        ExtraOption += ' --no-genfds-multi-thread'\n    if GlobalData.gIgnoreSource:\n        ExtraOption += ' --ignore-sources'\n    for pcd in GlobalData.BuildOptionPcd:\n        if pcd[2]:\n            pcdname = '.'.join(pcd[0:3])\n        else:\n            pcdname = '.'.join(pcd[0:2])\n        if pcd[3].startswith('{'):\n            ExtraOption += ' --pcd ' + pcdname + '=' + 'H' + '\"' + pcd[3] + '\"'\n        else:\n            ExtraOption += ' --pcd ' + pcdname + '=' + pcd[3]\n    MakefileName = self.getMakefileName()\n    SubBuildCommandList = []\n    for A in MyAgo.ArchList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join('$(BUILD_DIR)', A, MakefileName)}\n        SubBuildCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_build_directory': MyAgo.BuildDir, 'conf_directory': GlobalData.gConfDirectory, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'arch': list(MyAgo.ArchList), 'build_architecture_list': ','.join(MyAgo.ArchList), 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'sub_build_command': SubBuildCommandList, 'fdf_file': FdfFileList, 'active_platform': str(MyAgo), 'fd': MyAgo.FdTargetList, 'fv': MyAgo.FvTargetList, 'cap': MyAgo.CapTargetList, 'extra_options': ExtraOption, 'macro': MacroList}\n    return MakefileTemplateDict",
        "mutated": [
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    for Arch in MyAgo.ArchList:\n        self.IntermediateDirectoryList.append(Separator.join(['$(BUILD_DIR)', Arch]))\n    self.IntermediateDirectoryList.append('$(FV_DIR)')\n    MacroList = []\n    if MyAgo.FdfFile is not None and MyAgo.FdfFile != '':\n        FdfFileList = [MyAgo.FdfFile]\n        MacroDict = {}\n        MacroDict.update(GlobalData.gGlobalDefines)\n        MacroDict.update(GlobalData.gCommandLineDefines)\n        for MacroName in MacroDict:\n            if MacroDict[MacroName] != '':\n                MacroList.append('\"%s=%s\"' % (MacroName, MacroDict[MacroName].replace('\\\\', '\\\\\\\\')))\n            else:\n                MacroList.append('\"%s\"' % MacroName)\n    else:\n        FdfFileList = []\n    ExtraOption = ''\n    LogLevel = EdkLogger.GetLevel()\n    if LogLevel == EdkLogger.VERBOSE:\n        ExtraOption += ' -v'\n    elif LogLevel <= EdkLogger.DEBUG_9:\n        ExtraOption += ' -d %d' % (LogLevel - 1)\n    elif LogLevel == EdkLogger.QUIET:\n        ExtraOption += ' -q'\n    if GlobalData.gCaseInsensitive:\n        ExtraOption += ' -c'\n    if not GlobalData.gEnableGenfdsMultiThread:\n        ExtraOption += ' --no-genfds-multi-thread'\n    if GlobalData.gIgnoreSource:\n        ExtraOption += ' --ignore-sources'\n    for pcd in GlobalData.BuildOptionPcd:\n        if pcd[2]:\n            pcdname = '.'.join(pcd[0:3])\n        else:\n            pcdname = '.'.join(pcd[0:2])\n        if pcd[3].startswith('{'):\n            ExtraOption += ' --pcd ' + pcdname + '=' + 'H' + '\"' + pcd[3] + '\"'\n        else:\n            ExtraOption += ' --pcd ' + pcdname + '=' + pcd[3]\n    MakefileName = self.getMakefileName()\n    SubBuildCommandList = []\n    for A in MyAgo.ArchList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join('$(BUILD_DIR)', A, MakefileName)}\n        SubBuildCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_build_directory': MyAgo.BuildDir, 'conf_directory': GlobalData.gConfDirectory, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'arch': list(MyAgo.ArchList), 'build_architecture_list': ','.join(MyAgo.ArchList), 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'sub_build_command': SubBuildCommandList, 'fdf_file': FdfFileList, 'active_platform': str(MyAgo), 'fd': MyAgo.FdTargetList, 'fv': MyAgo.FvTargetList, 'cap': MyAgo.CapTargetList, 'extra_options': ExtraOption, 'macro': MacroList}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    for Arch in MyAgo.ArchList:\n        self.IntermediateDirectoryList.append(Separator.join(['$(BUILD_DIR)', Arch]))\n    self.IntermediateDirectoryList.append('$(FV_DIR)')\n    MacroList = []\n    if MyAgo.FdfFile is not None and MyAgo.FdfFile != '':\n        FdfFileList = [MyAgo.FdfFile]\n        MacroDict = {}\n        MacroDict.update(GlobalData.gGlobalDefines)\n        MacroDict.update(GlobalData.gCommandLineDefines)\n        for MacroName in MacroDict:\n            if MacroDict[MacroName] != '':\n                MacroList.append('\"%s=%s\"' % (MacroName, MacroDict[MacroName].replace('\\\\', '\\\\\\\\')))\n            else:\n                MacroList.append('\"%s\"' % MacroName)\n    else:\n        FdfFileList = []\n    ExtraOption = ''\n    LogLevel = EdkLogger.GetLevel()\n    if LogLevel == EdkLogger.VERBOSE:\n        ExtraOption += ' -v'\n    elif LogLevel <= EdkLogger.DEBUG_9:\n        ExtraOption += ' -d %d' % (LogLevel - 1)\n    elif LogLevel == EdkLogger.QUIET:\n        ExtraOption += ' -q'\n    if GlobalData.gCaseInsensitive:\n        ExtraOption += ' -c'\n    if not GlobalData.gEnableGenfdsMultiThread:\n        ExtraOption += ' --no-genfds-multi-thread'\n    if GlobalData.gIgnoreSource:\n        ExtraOption += ' --ignore-sources'\n    for pcd in GlobalData.BuildOptionPcd:\n        if pcd[2]:\n            pcdname = '.'.join(pcd[0:3])\n        else:\n            pcdname = '.'.join(pcd[0:2])\n        if pcd[3].startswith('{'):\n            ExtraOption += ' --pcd ' + pcdname + '=' + 'H' + '\"' + pcd[3] + '\"'\n        else:\n            ExtraOption += ' --pcd ' + pcdname + '=' + pcd[3]\n    MakefileName = self.getMakefileName()\n    SubBuildCommandList = []\n    for A in MyAgo.ArchList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join('$(BUILD_DIR)', A, MakefileName)}\n        SubBuildCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_build_directory': MyAgo.BuildDir, 'conf_directory': GlobalData.gConfDirectory, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'arch': list(MyAgo.ArchList), 'build_architecture_list': ','.join(MyAgo.ArchList), 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'sub_build_command': SubBuildCommandList, 'fdf_file': FdfFileList, 'active_platform': str(MyAgo), 'fd': MyAgo.FdTargetList, 'fv': MyAgo.FvTargetList, 'cap': MyAgo.CapTargetList, 'extra_options': ExtraOption, 'macro': MacroList}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    for Arch in MyAgo.ArchList:\n        self.IntermediateDirectoryList.append(Separator.join(['$(BUILD_DIR)', Arch]))\n    self.IntermediateDirectoryList.append('$(FV_DIR)')\n    MacroList = []\n    if MyAgo.FdfFile is not None and MyAgo.FdfFile != '':\n        FdfFileList = [MyAgo.FdfFile]\n        MacroDict = {}\n        MacroDict.update(GlobalData.gGlobalDefines)\n        MacroDict.update(GlobalData.gCommandLineDefines)\n        for MacroName in MacroDict:\n            if MacroDict[MacroName] != '':\n                MacroList.append('\"%s=%s\"' % (MacroName, MacroDict[MacroName].replace('\\\\', '\\\\\\\\')))\n            else:\n                MacroList.append('\"%s\"' % MacroName)\n    else:\n        FdfFileList = []\n    ExtraOption = ''\n    LogLevel = EdkLogger.GetLevel()\n    if LogLevel == EdkLogger.VERBOSE:\n        ExtraOption += ' -v'\n    elif LogLevel <= EdkLogger.DEBUG_9:\n        ExtraOption += ' -d %d' % (LogLevel - 1)\n    elif LogLevel == EdkLogger.QUIET:\n        ExtraOption += ' -q'\n    if GlobalData.gCaseInsensitive:\n        ExtraOption += ' -c'\n    if not GlobalData.gEnableGenfdsMultiThread:\n        ExtraOption += ' --no-genfds-multi-thread'\n    if GlobalData.gIgnoreSource:\n        ExtraOption += ' --ignore-sources'\n    for pcd in GlobalData.BuildOptionPcd:\n        if pcd[2]:\n            pcdname = '.'.join(pcd[0:3])\n        else:\n            pcdname = '.'.join(pcd[0:2])\n        if pcd[3].startswith('{'):\n            ExtraOption += ' --pcd ' + pcdname + '=' + 'H' + '\"' + pcd[3] + '\"'\n        else:\n            ExtraOption += ' --pcd ' + pcdname + '=' + pcd[3]\n    MakefileName = self.getMakefileName()\n    SubBuildCommandList = []\n    for A in MyAgo.ArchList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join('$(BUILD_DIR)', A, MakefileName)}\n        SubBuildCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_build_directory': MyAgo.BuildDir, 'conf_directory': GlobalData.gConfDirectory, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'arch': list(MyAgo.ArchList), 'build_architecture_list': ','.join(MyAgo.ArchList), 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'sub_build_command': SubBuildCommandList, 'fdf_file': FdfFileList, 'active_platform': str(MyAgo), 'fd': MyAgo.FdTargetList, 'fv': MyAgo.FvTargetList, 'cap': MyAgo.CapTargetList, 'extra_options': ExtraOption, 'macro': MacroList}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    for Arch in MyAgo.ArchList:\n        self.IntermediateDirectoryList.append(Separator.join(['$(BUILD_DIR)', Arch]))\n    self.IntermediateDirectoryList.append('$(FV_DIR)')\n    MacroList = []\n    if MyAgo.FdfFile is not None and MyAgo.FdfFile != '':\n        FdfFileList = [MyAgo.FdfFile]\n        MacroDict = {}\n        MacroDict.update(GlobalData.gGlobalDefines)\n        MacroDict.update(GlobalData.gCommandLineDefines)\n        for MacroName in MacroDict:\n            if MacroDict[MacroName] != '':\n                MacroList.append('\"%s=%s\"' % (MacroName, MacroDict[MacroName].replace('\\\\', '\\\\\\\\')))\n            else:\n                MacroList.append('\"%s\"' % MacroName)\n    else:\n        FdfFileList = []\n    ExtraOption = ''\n    LogLevel = EdkLogger.GetLevel()\n    if LogLevel == EdkLogger.VERBOSE:\n        ExtraOption += ' -v'\n    elif LogLevel <= EdkLogger.DEBUG_9:\n        ExtraOption += ' -d %d' % (LogLevel - 1)\n    elif LogLevel == EdkLogger.QUIET:\n        ExtraOption += ' -q'\n    if GlobalData.gCaseInsensitive:\n        ExtraOption += ' -c'\n    if not GlobalData.gEnableGenfdsMultiThread:\n        ExtraOption += ' --no-genfds-multi-thread'\n    if GlobalData.gIgnoreSource:\n        ExtraOption += ' --ignore-sources'\n    for pcd in GlobalData.BuildOptionPcd:\n        if pcd[2]:\n            pcdname = '.'.join(pcd[0:3])\n        else:\n            pcdname = '.'.join(pcd[0:2])\n        if pcd[3].startswith('{'):\n            ExtraOption += ' --pcd ' + pcdname + '=' + 'H' + '\"' + pcd[3] + '\"'\n        else:\n            ExtraOption += ' --pcd ' + pcdname + '=' + pcd[3]\n    MakefileName = self.getMakefileName()\n    SubBuildCommandList = []\n    for A in MyAgo.ArchList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join('$(BUILD_DIR)', A, MakefileName)}\n        SubBuildCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_build_directory': MyAgo.BuildDir, 'conf_directory': GlobalData.gConfDirectory, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'arch': list(MyAgo.ArchList), 'build_architecture_list': ','.join(MyAgo.ArchList), 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'sub_build_command': SubBuildCommandList, 'fdf_file': FdfFileList, 'active_platform': str(MyAgo), 'fd': MyAgo.FdTargetList, 'fv': MyAgo.FvTargetList, 'cap': MyAgo.CapTargetList, 'extra_options': ExtraOption, 'macro': MacroList}\n    return MakefileTemplateDict",
            "@property\ndef _TemplateDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Separator = self._SEP_[self._Platform]\n    MyAgo = self._AutoGenObject\n    if 'MAKE' not in MyAgo.ToolDefinition or 'PATH' not in MyAgo.ToolDefinition['MAKE']:\n        EdkLogger.error('build', OPTION_MISSING, 'No MAKE command defined. Please check your tools_def.txt!', ExtraData='[%s]' % str(MyAgo))\n    for Arch in MyAgo.ArchList:\n        self.IntermediateDirectoryList.append(Separator.join(['$(BUILD_DIR)', Arch]))\n    self.IntermediateDirectoryList.append('$(FV_DIR)')\n    MacroList = []\n    if MyAgo.FdfFile is not None and MyAgo.FdfFile != '':\n        FdfFileList = [MyAgo.FdfFile]\n        MacroDict = {}\n        MacroDict.update(GlobalData.gGlobalDefines)\n        MacroDict.update(GlobalData.gCommandLineDefines)\n        for MacroName in MacroDict:\n            if MacroDict[MacroName] != '':\n                MacroList.append('\"%s=%s\"' % (MacroName, MacroDict[MacroName].replace('\\\\', '\\\\\\\\')))\n            else:\n                MacroList.append('\"%s\"' % MacroName)\n    else:\n        FdfFileList = []\n    ExtraOption = ''\n    LogLevel = EdkLogger.GetLevel()\n    if LogLevel == EdkLogger.VERBOSE:\n        ExtraOption += ' -v'\n    elif LogLevel <= EdkLogger.DEBUG_9:\n        ExtraOption += ' -d %d' % (LogLevel - 1)\n    elif LogLevel == EdkLogger.QUIET:\n        ExtraOption += ' -q'\n    if GlobalData.gCaseInsensitive:\n        ExtraOption += ' -c'\n    if not GlobalData.gEnableGenfdsMultiThread:\n        ExtraOption += ' --no-genfds-multi-thread'\n    if GlobalData.gIgnoreSource:\n        ExtraOption += ' --ignore-sources'\n    for pcd in GlobalData.BuildOptionPcd:\n        if pcd[2]:\n            pcdname = '.'.join(pcd[0:3])\n        else:\n            pcdname = '.'.join(pcd[0:2])\n        if pcd[3].startswith('{'):\n            ExtraOption += ' --pcd ' + pcdname + '=' + 'H' + '\"' + pcd[3] + '\"'\n        else:\n            ExtraOption += ' --pcd ' + pcdname + '=' + pcd[3]\n    MakefileName = self.getMakefileName()\n    SubBuildCommandList = []\n    for A in MyAgo.ArchList:\n        Command = self._MAKE_TEMPLATE_[self._Platform] % {'file': os.path.join('$(BUILD_DIR)', A, MakefileName)}\n        SubBuildCommandList.append(Command)\n    MakefileTemplateDict = {'makefile_header': self._FILE_HEADER_[self._FileType], 'makefile_path': os.path.join('$(BUILD_DIR)', MakefileName), 'make_path': MyAgo.ToolDefinition['MAKE']['PATH'], 'platform_name': MyAgo.Name, 'platform_guid': MyAgo.Guid, 'platform_version': MyAgo.Version, 'platform_build_directory': MyAgo.BuildDir, 'conf_directory': GlobalData.gConfDirectory, 'toolchain_tag': MyAgo.ToolChain, 'build_target': MyAgo.BuildTarget, 'shell_command_code': list(self._SHELL_CMD_[self._Platform].keys()), 'shell_command': list(self._SHELL_CMD_[self._Platform].values()), 'arch': list(MyAgo.ArchList), 'build_architecture_list': ','.join(MyAgo.ArchList), 'separator': Separator, 'create_directory_command': self.GetCreateDirectoryCommand(self.IntermediateDirectoryList), 'cleanall_command': self.GetRemoveDirectoryCommand(self.IntermediateDirectoryList), 'sub_build_command': SubBuildCommandList, 'fdf_file': FdfFileList, 'active_platform': str(MyAgo), 'fd': MyAgo.FdTargetList, 'fv': MyAgo.FvTargetList, 'cap': MyAgo.CapTargetList, 'extra_options': ExtraOption, 'macro': MacroList}\n    return MakefileTemplateDict"
        ]
    },
    {
        "func_name": "GetModuleBuildDirectoryList",
        "original": "def GetModuleBuildDirectoryList(self):\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
        "mutated": [
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList",
            "def GetModuleBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DirList = []\n    for ModuleAutoGen in self._AutoGenObject.ModuleAutoGenList:\n        if not ModuleAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, ModuleAutoGen.BuildDir))\n    return DirList"
        ]
    },
    {
        "func_name": "GetLibraryBuildDirectoryList",
        "original": "def GetLibraryBuildDirectoryList(self):\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
        "mutated": [
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList",
            "def GetLibraryBuildDirectoryList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DirList = []\n    for LibraryAutoGen in self._AutoGenObject.LibraryAutoGenList:\n        if not LibraryAutoGen.IsBinaryModule:\n            DirList.append(os.path.join(self._AutoGenObject.BuildDir, LibraryAutoGen.BuildDir))\n    return DirList"
        ]
    },
    {
        "func_name": "GetDependencyList",
        "original": "def GetDependencyList(AutoGenObject, FileCache, File, ForceList, SearchPathList):\n    EdkLogger.debug(EdkLogger.DEBUG_1, 'Try to get dependency files for %s' % File)\n    FileStack = [File] + ForceList\n    DependencySet = set()\n    if AutoGenObject.Arch not in gDependencyDatabase:\n        gDependencyDatabase[AutoGenObject.Arch] = {}\n    DepDb = gDependencyDatabase[AutoGenObject.Arch]\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        if F in FileCache:\n            for CacheFile in FileCache[F]:\n                FullPathDependList.append(CacheFile)\n                if CacheFile not in DependencySet:\n                    FileStack.append(CacheFile)\n            DependencySet.update(FullPathDependList)\n            continue\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F.Path, 'rb')\n                FileContent = Fd.read()\n                Fd.close()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F.Path + '\\n\\t' + str(X))\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                HeaderList = gMacroPattern.findall(Inc)\n                if len(HeaderList) == 1 and len(HeaderList[0]) == 2:\n                    HeaderType = HeaderList[0][0]\n                    HeaderKey = HeaderList[0][1]\n                    if HeaderType in gIncludeMacroConversion:\n                        Inc = gIncludeMacroConversion[HeaderType] % {'HeaderKey': HeaderKey}\n                    else:\n                        FileCache[File] = []\n                        return []\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = F.Dir\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if FilePath in gIsFileMap:\n                    if not gIsFileMap[FilePath]:\n                        continue\n                elif not os.path.isfile(FilePath):\n                    gIsFileMap[FilePath] = False\n                    continue\n                else:\n                    gIsFileMap[FilePath] = True\n                FilePath = PathClass(FilePath)\n                FullPathDependList.append(FilePath)\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                break\n            else:\n                EdkLogger.debug(EdkLogger.DEBUG_9, '%s included by %s was not found in any given path:\\n\\t%s' % (Inc, F, '\\n\\t'.join(SearchPathList)))\n        FileCache[F] = FullPathDependList\n        DependencySet.update(FullPathDependList)\n    DependencySet.update(ForceList)\n    if File in DependencySet:\n        DependencySet.remove(File)\n    DependencyList = list(DependencySet)\n    return DependencyList",
        "mutated": [
            "def GetDependencyList(AutoGenObject, FileCache, File, ForceList, SearchPathList):\n    if False:\n        i = 10\n    EdkLogger.debug(EdkLogger.DEBUG_1, 'Try to get dependency files for %s' % File)\n    FileStack = [File] + ForceList\n    DependencySet = set()\n    if AutoGenObject.Arch not in gDependencyDatabase:\n        gDependencyDatabase[AutoGenObject.Arch] = {}\n    DepDb = gDependencyDatabase[AutoGenObject.Arch]\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        if F in FileCache:\n            for CacheFile in FileCache[F]:\n                FullPathDependList.append(CacheFile)\n                if CacheFile not in DependencySet:\n                    FileStack.append(CacheFile)\n            DependencySet.update(FullPathDependList)\n            continue\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F.Path, 'rb')\n                FileContent = Fd.read()\n                Fd.close()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F.Path + '\\n\\t' + str(X))\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                HeaderList = gMacroPattern.findall(Inc)\n                if len(HeaderList) == 1 and len(HeaderList[0]) == 2:\n                    HeaderType = HeaderList[0][0]\n                    HeaderKey = HeaderList[0][1]\n                    if HeaderType in gIncludeMacroConversion:\n                        Inc = gIncludeMacroConversion[HeaderType] % {'HeaderKey': HeaderKey}\n                    else:\n                        FileCache[File] = []\n                        return []\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = F.Dir\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if FilePath in gIsFileMap:\n                    if not gIsFileMap[FilePath]:\n                        continue\n                elif not os.path.isfile(FilePath):\n                    gIsFileMap[FilePath] = False\n                    continue\n                else:\n                    gIsFileMap[FilePath] = True\n                FilePath = PathClass(FilePath)\n                FullPathDependList.append(FilePath)\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                break\n            else:\n                EdkLogger.debug(EdkLogger.DEBUG_9, '%s included by %s was not found in any given path:\\n\\t%s' % (Inc, F, '\\n\\t'.join(SearchPathList)))\n        FileCache[F] = FullPathDependList\n        DependencySet.update(FullPathDependList)\n    DependencySet.update(ForceList)\n    if File in DependencySet:\n        DependencySet.remove(File)\n    DependencyList = list(DependencySet)\n    return DependencyList",
            "def GetDependencyList(AutoGenObject, FileCache, File, ForceList, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    EdkLogger.debug(EdkLogger.DEBUG_1, 'Try to get dependency files for %s' % File)\n    FileStack = [File] + ForceList\n    DependencySet = set()\n    if AutoGenObject.Arch not in gDependencyDatabase:\n        gDependencyDatabase[AutoGenObject.Arch] = {}\n    DepDb = gDependencyDatabase[AutoGenObject.Arch]\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        if F in FileCache:\n            for CacheFile in FileCache[F]:\n                FullPathDependList.append(CacheFile)\n                if CacheFile not in DependencySet:\n                    FileStack.append(CacheFile)\n            DependencySet.update(FullPathDependList)\n            continue\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F.Path, 'rb')\n                FileContent = Fd.read()\n                Fd.close()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F.Path + '\\n\\t' + str(X))\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                HeaderList = gMacroPattern.findall(Inc)\n                if len(HeaderList) == 1 and len(HeaderList[0]) == 2:\n                    HeaderType = HeaderList[0][0]\n                    HeaderKey = HeaderList[0][1]\n                    if HeaderType in gIncludeMacroConversion:\n                        Inc = gIncludeMacroConversion[HeaderType] % {'HeaderKey': HeaderKey}\n                    else:\n                        FileCache[File] = []\n                        return []\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = F.Dir\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if FilePath in gIsFileMap:\n                    if not gIsFileMap[FilePath]:\n                        continue\n                elif not os.path.isfile(FilePath):\n                    gIsFileMap[FilePath] = False\n                    continue\n                else:\n                    gIsFileMap[FilePath] = True\n                FilePath = PathClass(FilePath)\n                FullPathDependList.append(FilePath)\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                break\n            else:\n                EdkLogger.debug(EdkLogger.DEBUG_9, '%s included by %s was not found in any given path:\\n\\t%s' % (Inc, F, '\\n\\t'.join(SearchPathList)))\n        FileCache[F] = FullPathDependList\n        DependencySet.update(FullPathDependList)\n    DependencySet.update(ForceList)\n    if File in DependencySet:\n        DependencySet.remove(File)\n    DependencyList = list(DependencySet)\n    return DependencyList",
            "def GetDependencyList(AutoGenObject, FileCache, File, ForceList, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    EdkLogger.debug(EdkLogger.DEBUG_1, 'Try to get dependency files for %s' % File)\n    FileStack = [File] + ForceList\n    DependencySet = set()\n    if AutoGenObject.Arch not in gDependencyDatabase:\n        gDependencyDatabase[AutoGenObject.Arch] = {}\n    DepDb = gDependencyDatabase[AutoGenObject.Arch]\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        if F in FileCache:\n            for CacheFile in FileCache[F]:\n                FullPathDependList.append(CacheFile)\n                if CacheFile not in DependencySet:\n                    FileStack.append(CacheFile)\n            DependencySet.update(FullPathDependList)\n            continue\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F.Path, 'rb')\n                FileContent = Fd.read()\n                Fd.close()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F.Path + '\\n\\t' + str(X))\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                HeaderList = gMacroPattern.findall(Inc)\n                if len(HeaderList) == 1 and len(HeaderList[0]) == 2:\n                    HeaderType = HeaderList[0][0]\n                    HeaderKey = HeaderList[0][1]\n                    if HeaderType in gIncludeMacroConversion:\n                        Inc = gIncludeMacroConversion[HeaderType] % {'HeaderKey': HeaderKey}\n                    else:\n                        FileCache[File] = []\n                        return []\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = F.Dir\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if FilePath in gIsFileMap:\n                    if not gIsFileMap[FilePath]:\n                        continue\n                elif not os.path.isfile(FilePath):\n                    gIsFileMap[FilePath] = False\n                    continue\n                else:\n                    gIsFileMap[FilePath] = True\n                FilePath = PathClass(FilePath)\n                FullPathDependList.append(FilePath)\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                break\n            else:\n                EdkLogger.debug(EdkLogger.DEBUG_9, '%s included by %s was not found in any given path:\\n\\t%s' % (Inc, F, '\\n\\t'.join(SearchPathList)))\n        FileCache[F] = FullPathDependList\n        DependencySet.update(FullPathDependList)\n    DependencySet.update(ForceList)\n    if File in DependencySet:\n        DependencySet.remove(File)\n    DependencyList = list(DependencySet)\n    return DependencyList",
            "def GetDependencyList(AutoGenObject, FileCache, File, ForceList, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    EdkLogger.debug(EdkLogger.DEBUG_1, 'Try to get dependency files for %s' % File)\n    FileStack = [File] + ForceList\n    DependencySet = set()\n    if AutoGenObject.Arch not in gDependencyDatabase:\n        gDependencyDatabase[AutoGenObject.Arch] = {}\n    DepDb = gDependencyDatabase[AutoGenObject.Arch]\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        if F in FileCache:\n            for CacheFile in FileCache[F]:\n                FullPathDependList.append(CacheFile)\n                if CacheFile not in DependencySet:\n                    FileStack.append(CacheFile)\n            DependencySet.update(FullPathDependList)\n            continue\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F.Path, 'rb')\n                FileContent = Fd.read()\n                Fd.close()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F.Path + '\\n\\t' + str(X))\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                HeaderList = gMacroPattern.findall(Inc)\n                if len(HeaderList) == 1 and len(HeaderList[0]) == 2:\n                    HeaderType = HeaderList[0][0]\n                    HeaderKey = HeaderList[0][1]\n                    if HeaderType in gIncludeMacroConversion:\n                        Inc = gIncludeMacroConversion[HeaderType] % {'HeaderKey': HeaderKey}\n                    else:\n                        FileCache[File] = []\n                        return []\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = F.Dir\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if FilePath in gIsFileMap:\n                    if not gIsFileMap[FilePath]:\n                        continue\n                elif not os.path.isfile(FilePath):\n                    gIsFileMap[FilePath] = False\n                    continue\n                else:\n                    gIsFileMap[FilePath] = True\n                FilePath = PathClass(FilePath)\n                FullPathDependList.append(FilePath)\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                break\n            else:\n                EdkLogger.debug(EdkLogger.DEBUG_9, '%s included by %s was not found in any given path:\\n\\t%s' % (Inc, F, '\\n\\t'.join(SearchPathList)))\n        FileCache[F] = FullPathDependList\n        DependencySet.update(FullPathDependList)\n    DependencySet.update(ForceList)\n    if File in DependencySet:\n        DependencySet.remove(File)\n    DependencyList = list(DependencySet)\n    return DependencyList",
            "def GetDependencyList(AutoGenObject, FileCache, File, ForceList, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    EdkLogger.debug(EdkLogger.DEBUG_1, 'Try to get dependency files for %s' % File)\n    FileStack = [File] + ForceList\n    DependencySet = set()\n    if AutoGenObject.Arch not in gDependencyDatabase:\n        gDependencyDatabase[AutoGenObject.Arch] = {}\n    DepDb = gDependencyDatabase[AutoGenObject.Arch]\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        if F in FileCache:\n            for CacheFile in FileCache[F]:\n                FullPathDependList.append(CacheFile)\n                if CacheFile not in DependencySet:\n                    FileStack.append(CacheFile)\n            DependencySet.update(FullPathDependList)\n            continue\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F.Path, 'rb')\n                FileContent = Fd.read()\n                Fd.close()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F.Path + '\\n\\t' + str(X))\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                HeaderList = gMacroPattern.findall(Inc)\n                if len(HeaderList) == 1 and len(HeaderList[0]) == 2:\n                    HeaderType = HeaderList[0][0]\n                    HeaderKey = HeaderList[0][1]\n                    if HeaderType in gIncludeMacroConversion:\n                        Inc = gIncludeMacroConversion[HeaderType] % {'HeaderKey': HeaderKey}\n                    else:\n                        FileCache[File] = []\n                        return []\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = F.Dir\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if FilePath in gIsFileMap:\n                    if not gIsFileMap[FilePath]:\n                        continue\n                elif not os.path.isfile(FilePath):\n                    gIsFileMap[FilePath] = False\n                    continue\n                else:\n                    gIsFileMap[FilePath] = True\n                FilePath = PathClass(FilePath)\n                FullPathDependList.append(FilePath)\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                break\n            else:\n                EdkLogger.debug(EdkLogger.DEBUG_9, '%s included by %s was not found in any given path:\\n\\t%s' % (Inc, F, '\\n\\t'.join(SearchPathList)))\n        FileCache[F] = FullPathDependList\n        DependencySet.update(FullPathDependList)\n    DependencySet.update(ForceList)\n    if File in DependencySet:\n        DependencySet.remove(File)\n    DependencyList = list(DependencySet)\n    return DependencyList"
        ]
    }
]