[
    {
        "func_name": "_linsolve",
        "original": "def _linsolve(eqs, syms):\n    \"\"\"Solve a linear system of equations.\n\n    Examples\n    ========\n\n    Solve a linear system with a unique solution:\n\n    >>> from sympy import symbols, Eq\n    >>> from sympy.polys.matrices.linsolve import _linsolve\n    >>> x, y = symbols('x, y')\n    >>> eqs = [Eq(x + y, 1), Eq(x - y, 2)]\n    >>> _linsolve(eqs, [x, y])\n    {x: 3/2, y: -1/2}\n\n    In the case of underdetermined systems the solution will be expressed in\n    terms of the unknown symbols that are unconstrained:\n\n    >>> _linsolve([Eq(x + y, 0)], [x, y])\n    {x: -y, y: y}\n\n    \"\"\"\n    nsyms = len(syms)\n    (eqsdict, const) = _linear_eq_to_dict(eqs, syms)\n    Aaug = sympy_dict_to_dm(eqsdict, const, syms)\n    K = Aaug.domain\n    if K.is_RealField or K.is_ComplexField:\n        Aaug = Aaug.to_ddm().rref()[0].to_sdm()\n    (Arref, pivots, nzcols) = sdm_irref(Aaug)\n    if pivots and pivots[-1] == nsyms:\n        return None\n    P = sdm_particular_from_rref(Arref, nsyms + 1, pivots)\n    (V, nonpivots) = sdm_nullspace_from_rref(Arref, K.one, nsyms, pivots, nzcols)\n    sol = defaultdict(list)\n    for (i, v) in P.items():\n        sol[syms[i]].append(K.to_sympy(v))\n    for (npi, Vi) in zip(nonpivots, V):\n        sym = syms[npi]\n        for (i, v) in Vi.items():\n            sol[syms[i]].append(sym * K.to_sympy(v))\n    sol = {s: Add(*terms) for (s, terms) in sol.items()}\n    zero = S.Zero\n    for s in set(syms) - set(sol):\n        sol[s] = zero\n    return sol",
        "mutated": [
            "def _linsolve(eqs, syms):\n    if False:\n        i = 10\n    \"Solve a linear system of equations.\\n\\n    Examples\\n    ========\\n\\n    Solve a linear system with a unique solution:\\n\\n    >>> from sympy import symbols, Eq\\n    >>> from sympy.polys.matrices.linsolve import _linsolve\\n    >>> x, y = symbols('x, y')\\n    >>> eqs = [Eq(x + y, 1), Eq(x - y, 2)]\\n    >>> _linsolve(eqs, [x, y])\\n    {x: 3/2, y: -1/2}\\n\\n    In the case of underdetermined systems the solution will be expressed in\\n    terms of the unknown symbols that are unconstrained:\\n\\n    >>> _linsolve([Eq(x + y, 0)], [x, y])\\n    {x: -y, y: y}\\n\\n    \"\n    nsyms = len(syms)\n    (eqsdict, const) = _linear_eq_to_dict(eqs, syms)\n    Aaug = sympy_dict_to_dm(eqsdict, const, syms)\n    K = Aaug.domain\n    if K.is_RealField or K.is_ComplexField:\n        Aaug = Aaug.to_ddm().rref()[0].to_sdm()\n    (Arref, pivots, nzcols) = sdm_irref(Aaug)\n    if pivots and pivots[-1] == nsyms:\n        return None\n    P = sdm_particular_from_rref(Arref, nsyms + 1, pivots)\n    (V, nonpivots) = sdm_nullspace_from_rref(Arref, K.one, nsyms, pivots, nzcols)\n    sol = defaultdict(list)\n    for (i, v) in P.items():\n        sol[syms[i]].append(K.to_sympy(v))\n    for (npi, Vi) in zip(nonpivots, V):\n        sym = syms[npi]\n        for (i, v) in Vi.items():\n            sol[syms[i]].append(sym * K.to_sympy(v))\n    sol = {s: Add(*terms) for (s, terms) in sol.items()}\n    zero = S.Zero\n    for s in set(syms) - set(sol):\n        sol[s] = zero\n    return sol",
            "def _linsolve(eqs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Solve a linear system of equations.\\n\\n    Examples\\n    ========\\n\\n    Solve a linear system with a unique solution:\\n\\n    >>> from sympy import symbols, Eq\\n    >>> from sympy.polys.matrices.linsolve import _linsolve\\n    >>> x, y = symbols('x, y')\\n    >>> eqs = [Eq(x + y, 1), Eq(x - y, 2)]\\n    >>> _linsolve(eqs, [x, y])\\n    {x: 3/2, y: -1/2}\\n\\n    In the case of underdetermined systems the solution will be expressed in\\n    terms of the unknown symbols that are unconstrained:\\n\\n    >>> _linsolve([Eq(x + y, 0)], [x, y])\\n    {x: -y, y: y}\\n\\n    \"\n    nsyms = len(syms)\n    (eqsdict, const) = _linear_eq_to_dict(eqs, syms)\n    Aaug = sympy_dict_to_dm(eqsdict, const, syms)\n    K = Aaug.domain\n    if K.is_RealField or K.is_ComplexField:\n        Aaug = Aaug.to_ddm().rref()[0].to_sdm()\n    (Arref, pivots, nzcols) = sdm_irref(Aaug)\n    if pivots and pivots[-1] == nsyms:\n        return None\n    P = sdm_particular_from_rref(Arref, nsyms + 1, pivots)\n    (V, nonpivots) = sdm_nullspace_from_rref(Arref, K.one, nsyms, pivots, nzcols)\n    sol = defaultdict(list)\n    for (i, v) in P.items():\n        sol[syms[i]].append(K.to_sympy(v))\n    for (npi, Vi) in zip(nonpivots, V):\n        sym = syms[npi]\n        for (i, v) in Vi.items():\n            sol[syms[i]].append(sym * K.to_sympy(v))\n    sol = {s: Add(*terms) for (s, terms) in sol.items()}\n    zero = S.Zero\n    for s in set(syms) - set(sol):\n        sol[s] = zero\n    return sol",
            "def _linsolve(eqs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Solve a linear system of equations.\\n\\n    Examples\\n    ========\\n\\n    Solve a linear system with a unique solution:\\n\\n    >>> from sympy import symbols, Eq\\n    >>> from sympy.polys.matrices.linsolve import _linsolve\\n    >>> x, y = symbols('x, y')\\n    >>> eqs = [Eq(x + y, 1), Eq(x - y, 2)]\\n    >>> _linsolve(eqs, [x, y])\\n    {x: 3/2, y: -1/2}\\n\\n    In the case of underdetermined systems the solution will be expressed in\\n    terms of the unknown symbols that are unconstrained:\\n\\n    >>> _linsolve([Eq(x + y, 0)], [x, y])\\n    {x: -y, y: y}\\n\\n    \"\n    nsyms = len(syms)\n    (eqsdict, const) = _linear_eq_to_dict(eqs, syms)\n    Aaug = sympy_dict_to_dm(eqsdict, const, syms)\n    K = Aaug.domain\n    if K.is_RealField or K.is_ComplexField:\n        Aaug = Aaug.to_ddm().rref()[0].to_sdm()\n    (Arref, pivots, nzcols) = sdm_irref(Aaug)\n    if pivots and pivots[-1] == nsyms:\n        return None\n    P = sdm_particular_from_rref(Arref, nsyms + 1, pivots)\n    (V, nonpivots) = sdm_nullspace_from_rref(Arref, K.one, nsyms, pivots, nzcols)\n    sol = defaultdict(list)\n    for (i, v) in P.items():\n        sol[syms[i]].append(K.to_sympy(v))\n    for (npi, Vi) in zip(nonpivots, V):\n        sym = syms[npi]\n        for (i, v) in Vi.items():\n            sol[syms[i]].append(sym * K.to_sympy(v))\n    sol = {s: Add(*terms) for (s, terms) in sol.items()}\n    zero = S.Zero\n    for s in set(syms) - set(sol):\n        sol[s] = zero\n    return sol",
            "def _linsolve(eqs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Solve a linear system of equations.\\n\\n    Examples\\n    ========\\n\\n    Solve a linear system with a unique solution:\\n\\n    >>> from sympy import symbols, Eq\\n    >>> from sympy.polys.matrices.linsolve import _linsolve\\n    >>> x, y = symbols('x, y')\\n    >>> eqs = [Eq(x + y, 1), Eq(x - y, 2)]\\n    >>> _linsolve(eqs, [x, y])\\n    {x: 3/2, y: -1/2}\\n\\n    In the case of underdetermined systems the solution will be expressed in\\n    terms of the unknown symbols that are unconstrained:\\n\\n    >>> _linsolve([Eq(x + y, 0)], [x, y])\\n    {x: -y, y: y}\\n\\n    \"\n    nsyms = len(syms)\n    (eqsdict, const) = _linear_eq_to_dict(eqs, syms)\n    Aaug = sympy_dict_to_dm(eqsdict, const, syms)\n    K = Aaug.domain\n    if K.is_RealField or K.is_ComplexField:\n        Aaug = Aaug.to_ddm().rref()[0].to_sdm()\n    (Arref, pivots, nzcols) = sdm_irref(Aaug)\n    if pivots and pivots[-1] == nsyms:\n        return None\n    P = sdm_particular_from_rref(Arref, nsyms + 1, pivots)\n    (V, nonpivots) = sdm_nullspace_from_rref(Arref, K.one, nsyms, pivots, nzcols)\n    sol = defaultdict(list)\n    for (i, v) in P.items():\n        sol[syms[i]].append(K.to_sympy(v))\n    for (npi, Vi) in zip(nonpivots, V):\n        sym = syms[npi]\n        for (i, v) in Vi.items():\n            sol[syms[i]].append(sym * K.to_sympy(v))\n    sol = {s: Add(*terms) for (s, terms) in sol.items()}\n    zero = S.Zero\n    for s in set(syms) - set(sol):\n        sol[s] = zero\n    return sol",
            "def _linsolve(eqs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Solve a linear system of equations.\\n\\n    Examples\\n    ========\\n\\n    Solve a linear system with a unique solution:\\n\\n    >>> from sympy import symbols, Eq\\n    >>> from sympy.polys.matrices.linsolve import _linsolve\\n    >>> x, y = symbols('x, y')\\n    >>> eqs = [Eq(x + y, 1), Eq(x - y, 2)]\\n    >>> _linsolve(eqs, [x, y])\\n    {x: 3/2, y: -1/2}\\n\\n    In the case of underdetermined systems the solution will be expressed in\\n    terms of the unknown symbols that are unconstrained:\\n\\n    >>> _linsolve([Eq(x + y, 0)], [x, y])\\n    {x: -y, y: y}\\n\\n    \"\n    nsyms = len(syms)\n    (eqsdict, const) = _linear_eq_to_dict(eqs, syms)\n    Aaug = sympy_dict_to_dm(eqsdict, const, syms)\n    K = Aaug.domain\n    if K.is_RealField or K.is_ComplexField:\n        Aaug = Aaug.to_ddm().rref()[0].to_sdm()\n    (Arref, pivots, nzcols) = sdm_irref(Aaug)\n    if pivots and pivots[-1] == nsyms:\n        return None\n    P = sdm_particular_from_rref(Arref, nsyms + 1, pivots)\n    (V, nonpivots) = sdm_nullspace_from_rref(Arref, K.one, nsyms, pivots, nzcols)\n    sol = defaultdict(list)\n    for (i, v) in P.items():\n        sol[syms[i]].append(K.to_sympy(v))\n    for (npi, Vi) in zip(nonpivots, V):\n        sym = syms[npi]\n        for (i, v) in Vi.items():\n            sol[syms[i]].append(sym * K.to_sympy(v))\n    sol = {s: Add(*terms) for (s, terms) in sol.items()}\n    zero = S.Zero\n    for s in set(syms) - set(sol):\n        sol[s] = zero\n    return sol"
        ]
    },
    {
        "func_name": "sympy_dict_to_dm",
        "original": "def sympy_dict_to_dm(eqs_coeffs, eqs_rhs, syms):\n    \"\"\"Convert a system of dict equations to a sparse augmented matrix\"\"\"\n    elems = set(eqs_rhs).union(*(e.values() for e in eqs_coeffs))\n    (K, elems_K) = construct_domain(elems, field=True, extension=True)\n    elem_map = dict(zip(elems, elems_K))\n    neqs = len(eqs_coeffs)\n    nsyms = len(syms)\n    sym2index = dict(zip(syms, range(nsyms)))\n    eqsdict = []\n    for (eq, rhs) in zip(eqs_coeffs, eqs_rhs):\n        eqdict = {sym2index[s]: elem_map[c] for (s, c) in eq.items()}\n        if rhs:\n            eqdict[nsyms] = -elem_map[rhs]\n        if eqdict:\n            eqsdict.append(eqdict)\n    sdm_aug = SDM(enumerate(eqsdict), (neqs, nsyms + 1), K)\n    return sdm_aug",
        "mutated": [
            "def sympy_dict_to_dm(eqs_coeffs, eqs_rhs, syms):\n    if False:\n        i = 10\n    'Convert a system of dict equations to a sparse augmented matrix'\n    elems = set(eqs_rhs).union(*(e.values() for e in eqs_coeffs))\n    (K, elems_K) = construct_domain(elems, field=True, extension=True)\n    elem_map = dict(zip(elems, elems_K))\n    neqs = len(eqs_coeffs)\n    nsyms = len(syms)\n    sym2index = dict(zip(syms, range(nsyms)))\n    eqsdict = []\n    for (eq, rhs) in zip(eqs_coeffs, eqs_rhs):\n        eqdict = {sym2index[s]: elem_map[c] for (s, c) in eq.items()}\n        if rhs:\n            eqdict[nsyms] = -elem_map[rhs]\n        if eqdict:\n            eqsdict.append(eqdict)\n    sdm_aug = SDM(enumerate(eqsdict), (neqs, nsyms + 1), K)\n    return sdm_aug",
            "def sympy_dict_to_dm(eqs_coeffs, eqs_rhs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert a system of dict equations to a sparse augmented matrix'\n    elems = set(eqs_rhs).union(*(e.values() for e in eqs_coeffs))\n    (K, elems_K) = construct_domain(elems, field=True, extension=True)\n    elem_map = dict(zip(elems, elems_K))\n    neqs = len(eqs_coeffs)\n    nsyms = len(syms)\n    sym2index = dict(zip(syms, range(nsyms)))\n    eqsdict = []\n    for (eq, rhs) in zip(eqs_coeffs, eqs_rhs):\n        eqdict = {sym2index[s]: elem_map[c] for (s, c) in eq.items()}\n        if rhs:\n            eqdict[nsyms] = -elem_map[rhs]\n        if eqdict:\n            eqsdict.append(eqdict)\n    sdm_aug = SDM(enumerate(eqsdict), (neqs, nsyms + 1), K)\n    return sdm_aug",
            "def sympy_dict_to_dm(eqs_coeffs, eqs_rhs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert a system of dict equations to a sparse augmented matrix'\n    elems = set(eqs_rhs).union(*(e.values() for e in eqs_coeffs))\n    (K, elems_K) = construct_domain(elems, field=True, extension=True)\n    elem_map = dict(zip(elems, elems_K))\n    neqs = len(eqs_coeffs)\n    nsyms = len(syms)\n    sym2index = dict(zip(syms, range(nsyms)))\n    eqsdict = []\n    for (eq, rhs) in zip(eqs_coeffs, eqs_rhs):\n        eqdict = {sym2index[s]: elem_map[c] for (s, c) in eq.items()}\n        if rhs:\n            eqdict[nsyms] = -elem_map[rhs]\n        if eqdict:\n            eqsdict.append(eqdict)\n    sdm_aug = SDM(enumerate(eqsdict), (neqs, nsyms + 1), K)\n    return sdm_aug",
            "def sympy_dict_to_dm(eqs_coeffs, eqs_rhs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert a system of dict equations to a sparse augmented matrix'\n    elems = set(eqs_rhs).union(*(e.values() for e in eqs_coeffs))\n    (K, elems_K) = construct_domain(elems, field=True, extension=True)\n    elem_map = dict(zip(elems, elems_K))\n    neqs = len(eqs_coeffs)\n    nsyms = len(syms)\n    sym2index = dict(zip(syms, range(nsyms)))\n    eqsdict = []\n    for (eq, rhs) in zip(eqs_coeffs, eqs_rhs):\n        eqdict = {sym2index[s]: elem_map[c] for (s, c) in eq.items()}\n        if rhs:\n            eqdict[nsyms] = -elem_map[rhs]\n        if eqdict:\n            eqsdict.append(eqdict)\n    sdm_aug = SDM(enumerate(eqsdict), (neqs, nsyms + 1), K)\n    return sdm_aug",
            "def sympy_dict_to_dm(eqs_coeffs, eqs_rhs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert a system of dict equations to a sparse augmented matrix'\n    elems = set(eqs_rhs).union(*(e.values() for e in eqs_coeffs))\n    (K, elems_K) = construct_domain(elems, field=True, extension=True)\n    elem_map = dict(zip(elems, elems_K))\n    neqs = len(eqs_coeffs)\n    nsyms = len(syms)\n    sym2index = dict(zip(syms, range(nsyms)))\n    eqsdict = []\n    for (eq, rhs) in zip(eqs_coeffs, eqs_rhs):\n        eqdict = {sym2index[s]: elem_map[c] for (s, c) in eq.items()}\n        if rhs:\n            eqdict[nsyms] = -elem_map[rhs]\n        if eqdict:\n            eqsdict.append(eqdict)\n    sdm_aug = SDM(enumerate(eqsdict), (neqs, nsyms + 1), K)\n    return sdm_aug"
        ]
    },
    {
        "func_name": "_linear_eq_to_dict",
        "original": "def _linear_eq_to_dict(eqs, syms):\n    \"\"\"Convert a system Expr/Eq equations into dict form, returning\n    the coefficient dictionaries and a list of syms-independent terms\n    from each expression in ``eqs```.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.linsolve import _linear_eq_to_dict\n    >>> from sympy.abc import x\n    >>> _linear_eq_to_dict([2*x + 3], {x})\n    ([{x: 2}], [3])\n    \"\"\"\n    coeffs = []\n    ind = []\n    symset = set(syms)\n    for (i, e) in enumerate(eqs):\n        if e.is_Equality:\n            (coeff, terms) = _lin_eq2dict(e.lhs, symset)\n            (cR, tR) = _lin_eq2dict(e.rhs, symset)\n            coeff -= cR\n            for (k, v) in tR.items():\n                if k in terms:\n                    terms[k] -= v\n                else:\n                    terms[k] = -v\n            terms = {k: v for (k, v) in terms.items() if v}\n            (c, d) = (coeff, terms)\n        else:\n            (c, d) = _lin_eq2dict(e, symset)\n        coeffs.append(d)\n        ind.append(c)\n    return (coeffs, ind)",
        "mutated": [
            "def _linear_eq_to_dict(eqs, syms):\n    if False:\n        i = 10\n    'Convert a system Expr/Eq equations into dict form, returning\\n    the coefficient dictionaries and a list of syms-independent terms\\n    from each expression in ``eqs```.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _linear_eq_to_dict\\n    >>> from sympy.abc import x\\n    >>> _linear_eq_to_dict([2*x + 3], {x})\\n    ([{x: 2}], [3])\\n    '\n    coeffs = []\n    ind = []\n    symset = set(syms)\n    for (i, e) in enumerate(eqs):\n        if e.is_Equality:\n            (coeff, terms) = _lin_eq2dict(e.lhs, symset)\n            (cR, tR) = _lin_eq2dict(e.rhs, symset)\n            coeff -= cR\n            for (k, v) in tR.items():\n                if k in terms:\n                    terms[k] -= v\n                else:\n                    terms[k] = -v\n            terms = {k: v for (k, v) in terms.items() if v}\n            (c, d) = (coeff, terms)\n        else:\n            (c, d) = _lin_eq2dict(e, symset)\n        coeffs.append(d)\n        ind.append(c)\n    return (coeffs, ind)",
            "def _linear_eq_to_dict(eqs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert a system Expr/Eq equations into dict form, returning\\n    the coefficient dictionaries and a list of syms-independent terms\\n    from each expression in ``eqs```.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _linear_eq_to_dict\\n    >>> from sympy.abc import x\\n    >>> _linear_eq_to_dict([2*x + 3], {x})\\n    ([{x: 2}], [3])\\n    '\n    coeffs = []\n    ind = []\n    symset = set(syms)\n    for (i, e) in enumerate(eqs):\n        if e.is_Equality:\n            (coeff, terms) = _lin_eq2dict(e.lhs, symset)\n            (cR, tR) = _lin_eq2dict(e.rhs, symset)\n            coeff -= cR\n            for (k, v) in tR.items():\n                if k in terms:\n                    terms[k] -= v\n                else:\n                    terms[k] = -v\n            terms = {k: v for (k, v) in terms.items() if v}\n            (c, d) = (coeff, terms)\n        else:\n            (c, d) = _lin_eq2dict(e, symset)\n        coeffs.append(d)\n        ind.append(c)\n    return (coeffs, ind)",
            "def _linear_eq_to_dict(eqs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert a system Expr/Eq equations into dict form, returning\\n    the coefficient dictionaries and a list of syms-independent terms\\n    from each expression in ``eqs```.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _linear_eq_to_dict\\n    >>> from sympy.abc import x\\n    >>> _linear_eq_to_dict([2*x + 3], {x})\\n    ([{x: 2}], [3])\\n    '\n    coeffs = []\n    ind = []\n    symset = set(syms)\n    for (i, e) in enumerate(eqs):\n        if e.is_Equality:\n            (coeff, terms) = _lin_eq2dict(e.lhs, symset)\n            (cR, tR) = _lin_eq2dict(e.rhs, symset)\n            coeff -= cR\n            for (k, v) in tR.items():\n                if k in terms:\n                    terms[k] -= v\n                else:\n                    terms[k] = -v\n            terms = {k: v for (k, v) in terms.items() if v}\n            (c, d) = (coeff, terms)\n        else:\n            (c, d) = _lin_eq2dict(e, symset)\n        coeffs.append(d)\n        ind.append(c)\n    return (coeffs, ind)",
            "def _linear_eq_to_dict(eqs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert a system Expr/Eq equations into dict form, returning\\n    the coefficient dictionaries and a list of syms-independent terms\\n    from each expression in ``eqs```.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _linear_eq_to_dict\\n    >>> from sympy.abc import x\\n    >>> _linear_eq_to_dict([2*x + 3], {x})\\n    ([{x: 2}], [3])\\n    '\n    coeffs = []\n    ind = []\n    symset = set(syms)\n    for (i, e) in enumerate(eqs):\n        if e.is_Equality:\n            (coeff, terms) = _lin_eq2dict(e.lhs, symset)\n            (cR, tR) = _lin_eq2dict(e.rhs, symset)\n            coeff -= cR\n            for (k, v) in tR.items():\n                if k in terms:\n                    terms[k] -= v\n                else:\n                    terms[k] = -v\n            terms = {k: v for (k, v) in terms.items() if v}\n            (c, d) = (coeff, terms)\n        else:\n            (c, d) = _lin_eq2dict(e, symset)\n        coeffs.append(d)\n        ind.append(c)\n    return (coeffs, ind)",
            "def _linear_eq_to_dict(eqs, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert a system Expr/Eq equations into dict form, returning\\n    the coefficient dictionaries and a list of syms-independent terms\\n    from each expression in ``eqs```.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _linear_eq_to_dict\\n    >>> from sympy.abc import x\\n    >>> _linear_eq_to_dict([2*x + 3], {x})\\n    ([{x: 2}], [3])\\n    '\n    coeffs = []\n    ind = []\n    symset = set(syms)\n    for (i, e) in enumerate(eqs):\n        if e.is_Equality:\n            (coeff, terms) = _lin_eq2dict(e.lhs, symset)\n            (cR, tR) = _lin_eq2dict(e.rhs, symset)\n            coeff -= cR\n            for (k, v) in tR.items():\n                if k in terms:\n                    terms[k] -= v\n                else:\n                    terms[k] = -v\n            terms = {k: v for (k, v) in terms.items() if v}\n            (c, d) = (coeff, terms)\n        else:\n            (c, d) = _lin_eq2dict(e, symset)\n        coeffs.append(d)\n        ind.append(c)\n    return (coeffs, ind)"
        ]
    },
    {
        "func_name": "_lin_eq2dict",
        "original": "def _lin_eq2dict(a, symset):\n    \"\"\"return (c, d) where c is the sym-independent part of ``a`` and\n    ``d`` is an efficiently calculated dictionary mapping symbols to\n    their coefficients. A PolyNonlinearError is raised if non-linearity\n    is detected.\n\n    The values in the dictionary will be non-zero.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.linsolve import _lin_eq2dict\n    >>> from sympy.abc import x, y\n    >>> _lin_eq2dict(x + 2*y + 3, {x, y})\n    (3, {x: 1, y: 2})\n    \"\"\"\n    if a in symset:\n        return (S.Zero, {a: S.One})\n    elif a.is_Add:\n        terms_list = defaultdict(list)\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            coeff_list.append(ci)\n            for (mij, cij) in ti.items():\n                terms_list[mij].append(cij)\n        coeff = Add(*coeff_list)\n        terms = {sym: Add(*coeffs) for (sym, coeffs) in terms_list.items()}\n        return (coeff, terms)\n    elif a.is_Mul:\n        terms = terms_coeff = None\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            if not ti:\n                coeff_list.append(ci)\n            elif terms is None:\n                terms = ti\n                terms_coeff = ci\n            else:\n                raise PolyNonlinearError(filldedent('\\n                    nonlinear cross-term: %s' % a))\n        coeff = Mul._from_args(coeff_list)\n        if terms is None:\n            return (coeff, {})\n        else:\n            terms = {sym: coeff * c for (sym, c) in terms.items()}\n            return (coeff * terms_coeff, terms)\n    elif not a.has_xfree(symset):\n        return (a, {})\n    else:\n        raise PolyNonlinearError('nonlinear term: %s' % a)",
        "mutated": [
            "def _lin_eq2dict(a, symset):\n    if False:\n        i = 10\n    'return (c, d) where c is the sym-independent part of ``a`` and\\n    ``d`` is an efficiently calculated dictionary mapping symbols to\\n    their coefficients. A PolyNonlinearError is raised if non-linearity\\n    is detected.\\n\\n    The values in the dictionary will be non-zero.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _lin_eq2dict\\n    >>> from sympy.abc import x, y\\n    >>> _lin_eq2dict(x + 2*y + 3, {x, y})\\n    (3, {x: 1, y: 2})\\n    '\n    if a in symset:\n        return (S.Zero, {a: S.One})\n    elif a.is_Add:\n        terms_list = defaultdict(list)\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            coeff_list.append(ci)\n            for (mij, cij) in ti.items():\n                terms_list[mij].append(cij)\n        coeff = Add(*coeff_list)\n        terms = {sym: Add(*coeffs) for (sym, coeffs) in terms_list.items()}\n        return (coeff, terms)\n    elif a.is_Mul:\n        terms = terms_coeff = None\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            if not ti:\n                coeff_list.append(ci)\n            elif terms is None:\n                terms = ti\n                terms_coeff = ci\n            else:\n                raise PolyNonlinearError(filldedent('\\n                    nonlinear cross-term: %s' % a))\n        coeff = Mul._from_args(coeff_list)\n        if terms is None:\n            return (coeff, {})\n        else:\n            terms = {sym: coeff * c for (sym, c) in terms.items()}\n            return (coeff * terms_coeff, terms)\n    elif not a.has_xfree(symset):\n        return (a, {})\n    else:\n        raise PolyNonlinearError('nonlinear term: %s' % a)",
            "def _lin_eq2dict(a, symset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'return (c, d) where c is the sym-independent part of ``a`` and\\n    ``d`` is an efficiently calculated dictionary mapping symbols to\\n    their coefficients. A PolyNonlinearError is raised if non-linearity\\n    is detected.\\n\\n    The values in the dictionary will be non-zero.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _lin_eq2dict\\n    >>> from sympy.abc import x, y\\n    >>> _lin_eq2dict(x + 2*y + 3, {x, y})\\n    (3, {x: 1, y: 2})\\n    '\n    if a in symset:\n        return (S.Zero, {a: S.One})\n    elif a.is_Add:\n        terms_list = defaultdict(list)\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            coeff_list.append(ci)\n            for (mij, cij) in ti.items():\n                terms_list[mij].append(cij)\n        coeff = Add(*coeff_list)\n        terms = {sym: Add(*coeffs) for (sym, coeffs) in terms_list.items()}\n        return (coeff, terms)\n    elif a.is_Mul:\n        terms = terms_coeff = None\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            if not ti:\n                coeff_list.append(ci)\n            elif terms is None:\n                terms = ti\n                terms_coeff = ci\n            else:\n                raise PolyNonlinearError(filldedent('\\n                    nonlinear cross-term: %s' % a))\n        coeff = Mul._from_args(coeff_list)\n        if terms is None:\n            return (coeff, {})\n        else:\n            terms = {sym: coeff * c for (sym, c) in terms.items()}\n            return (coeff * terms_coeff, terms)\n    elif not a.has_xfree(symset):\n        return (a, {})\n    else:\n        raise PolyNonlinearError('nonlinear term: %s' % a)",
            "def _lin_eq2dict(a, symset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'return (c, d) where c is the sym-independent part of ``a`` and\\n    ``d`` is an efficiently calculated dictionary mapping symbols to\\n    their coefficients. A PolyNonlinearError is raised if non-linearity\\n    is detected.\\n\\n    The values in the dictionary will be non-zero.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _lin_eq2dict\\n    >>> from sympy.abc import x, y\\n    >>> _lin_eq2dict(x + 2*y + 3, {x, y})\\n    (3, {x: 1, y: 2})\\n    '\n    if a in symset:\n        return (S.Zero, {a: S.One})\n    elif a.is_Add:\n        terms_list = defaultdict(list)\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            coeff_list.append(ci)\n            for (mij, cij) in ti.items():\n                terms_list[mij].append(cij)\n        coeff = Add(*coeff_list)\n        terms = {sym: Add(*coeffs) for (sym, coeffs) in terms_list.items()}\n        return (coeff, terms)\n    elif a.is_Mul:\n        terms = terms_coeff = None\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            if not ti:\n                coeff_list.append(ci)\n            elif terms is None:\n                terms = ti\n                terms_coeff = ci\n            else:\n                raise PolyNonlinearError(filldedent('\\n                    nonlinear cross-term: %s' % a))\n        coeff = Mul._from_args(coeff_list)\n        if terms is None:\n            return (coeff, {})\n        else:\n            terms = {sym: coeff * c for (sym, c) in terms.items()}\n            return (coeff * terms_coeff, terms)\n    elif not a.has_xfree(symset):\n        return (a, {})\n    else:\n        raise PolyNonlinearError('nonlinear term: %s' % a)",
            "def _lin_eq2dict(a, symset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'return (c, d) where c is the sym-independent part of ``a`` and\\n    ``d`` is an efficiently calculated dictionary mapping symbols to\\n    their coefficients. A PolyNonlinearError is raised if non-linearity\\n    is detected.\\n\\n    The values in the dictionary will be non-zero.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _lin_eq2dict\\n    >>> from sympy.abc import x, y\\n    >>> _lin_eq2dict(x + 2*y + 3, {x, y})\\n    (3, {x: 1, y: 2})\\n    '\n    if a in symset:\n        return (S.Zero, {a: S.One})\n    elif a.is_Add:\n        terms_list = defaultdict(list)\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            coeff_list.append(ci)\n            for (mij, cij) in ti.items():\n                terms_list[mij].append(cij)\n        coeff = Add(*coeff_list)\n        terms = {sym: Add(*coeffs) for (sym, coeffs) in terms_list.items()}\n        return (coeff, terms)\n    elif a.is_Mul:\n        terms = terms_coeff = None\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            if not ti:\n                coeff_list.append(ci)\n            elif terms is None:\n                terms = ti\n                terms_coeff = ci\n            else:\n                raise PolyNonlinearError(filldedent('\\n                    nonlinear cross-term: %s' % a))\n        coeff = Mul._from_args(coeff_list)\n        if terms is None:\n            return (coeff, {})\n        else:\n            terms = {sym: coeff * c for (sym, c) in terms.items()}\n            return (coeff * terms_coeff, terms)\n    elif not a.has_xfree(symset):\n        return (a, {})\n    else:\n        raise PolyNonlinearError('nonlinear term: %s' % a)",
            "def _lin_eq2dict(a, symset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'return (c, d) where c is the sym-independent part of ``a`` and\\n    ``d`` is an efficiently calculated dictionary mapping symbols to\\n    their coefficients. A PolyNonlinearError is raised if non-linearity\\n    is detected.\\n\\n    The values in the dictionary will be non-zero.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.matrices.linsolve import _lin_eq2dict\\n    >>> from sympy.abc import x, y\\n    >>> _lin_eq2dict(x + 2*y + 3, {x, y})\\n    (3, {x: 1, y: 2})\\n    '\n    if a in symset:\n        return (S.Zero, {a: S.One})\n    elif a.is_Add:\n        terms_list = defaultdict(list)\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            coeff_list.append(ci)\n            for (mij, cij) in ti.items():\n                terms_list[mij].append(cij)\n        coeff = Add(*coeff_list)\n        terms = {sym: Add(*coeffs) for (sym, coeffs) in terms_list.items()}\n        return (coeff, terms)\n    elif a.is_Mul:\n        terms = terms_coeff = None\n        coeff_list = []\n        for ai in a.args:\n            (ci, ti) = _lin_eq2dict(ai, symset)\n            if not ti:\n                coeff_list.append(ci)\n            elif terms is None:\n                terms = ti\n                terms_coeff = ci\n            else:\n                raise PolyNonlinearError(filldedent('\\n                    nonlinear cross-term: %s' % a))\n        coeff = Mul._from_args(coeff_list)\n        if terms is None:\n            return (coeff, {})\n        else:\n            terms = {sym: coeff * c for (sym, c) in terms.items()}\n            return (coeff * terms_coeff, terms)\n    elif not a.has_xfree(symset):\n        return (a, {})\n    else:\n        raise PolyNonlinearError('nonlinear term: %s' % a)"
        ]
    }
]