[
    {
        "func_name": "test_implied_volatility_docstring_example",
        "original": "def test_implied_volatility_docstring_example(self):\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([120.0, 20.0]), strikes=np.array([106.0, 11.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [0.33284656705268817, 1.9828728139982792])",
        "mutated": [
            "def test_implied_volatility_docstring_example(self):\n    if False:\n        i = 10\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([120.0, 20.0]), strikes=np.array([106.0, 11.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [0.33284656705268817, 1.9828728139982792])",
            "def test_implied_volatility_docstring_example(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([120.0, 20.0]), strikes=np.array([106.0, 11.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [0.33284656705268817, 1.9828728139982792])",
            "def test_implied_volatility_docstring_example(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([120.0, 20.0]), strikes=np.array([106.0, 11.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [0.33284656705268817, 1.9828728139982792])",
            "def test_implied_volatility_docstring_example(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([120.0, 20.0]), strikes=np.array([106.0, 11.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [0.33284656705268817, 1.9828728139982792])",
            "def test_implied_volatility_docstring_example(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([120.0, 20.0]), strikes=np.array([106.0, 11.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [0.33284656705268817, 1.9828728139982792])"
        ]
    },
    {
        "func_name": "test_implied_volatility_parameter_broadcasting",
        "original": "def test_implied_volatility_parameter_broadcasting(self):\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(strikes=np.array([[105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0]]), expiries=np.array([[30.0 / 365.0], [60.0 / 365.0], [90.0 / 365.0]]), forwards=115.0, alpha=np.array([[1.0], [1.5], [2.0]]), beta=np.array([[0.25], [0.5], [0.75]]), rho=0.05, volvol=np.array([[2.0], [2.5], [3.0]]), dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [[0.07290126718857293, 0.048678694833488044, 0.02925354052258421, 0.048663433935318724, 0.06968554457600247], [0.19479147227269086, 0.1647194927224411, 0.15186141282688834, 0.16548343518393138, 0.19098676373872667], [0.7493941577599591, 0.7318045979333434, 0.7259931664225101, 0.7310817574988578, 0.7449168095317619]])",
        "mutated": [
            "def test_implied_volatility_parameter_broadcasting(self):\n    if False:\n        i = 10\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(strikes=np.array([[105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0]]), expiries=np.array([[30.0 / 365.0], [60.0 / 365.0], [90.0 / 365.0]]), forwards=115.0, alpha=np.array([[1.0], [1.5], [2.0]]), beta=np.array([[0.25], [0.5], [0.75]]), rho=0.05, volvol=np.array([[2.0], [2.5], [3.0]]), dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [[0.07290126718857293, 0.048678694833488044, 0.02925354052258421, 0.048663433935318724, 0.06968554457600247], [0.19479147227269086, 0.1647194927224411, 0.15186141282688834, 0.16548343518393138, 0.19098676373872667], [0.7493941577599591, 0.7318045979333434, 0.7259931664225101, 0.7310817574988578, 0.7449168095317619]])",
            "def test_implied_volatility_parameter_broadcasting(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(strikes=np.array([[105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0]]), expiries=np.array([[30.0 / 365.0], [60.0 / 365.0], [90.0 / 365.0]]), forwards=115.0, alpha=np.array([[1.0], [1.5], [2.0]]), beta=np.array([[0.25], [0.5], [0.75]]), rho=0.05, volvol=np.array([[2.0], [2.5], [3.0]]), dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [[0.07290126718857293, 0.048678694833488044, 0.02925354052258421, 0.048663433935318724, 0.06968554457600247], [0.19479147227269086, 0.1647194927224411, 0.15186141282688834, 0.16548343518393138, 0.19098676373872667], [0.7493941577599591, 0.7318045979333434, 0.7259931664225101, 0.7310817574988578, 0.7449168095317619]])",
            "def test_implied_volatility_parameter_broadcasting(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(strikes=np.array([[105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0]]), expiries=np.array([[30.0 / 365.0], [60.0 / 365.0], [90.0 / 365.0]]), forwards=115.0, alpha=np.array([[1.0], [1.5], [2.0]]), beta=np.array([[0.25], [0.5], [0.75]]), rho=0.05, volvol=np.array([[2.0], [2.5], [3.0]]), dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [[0.07290126718857293, 0.048678694833488044, 0.02925354052258421, 0.048663433935318724, 0.06968554457600247], [0.19479147227269086, 0.1647194927224411, 0.15186141282688834, 0.16548343518393138, 0.19098676373872667], [0.7493941577599591, 0.7318045979333434, 0.7259931664225101, 0.7310817574988578, 0.7449168095317619]])",
            "def test_implied_volatility_parameter_broadcasting(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(strikes=np.array([[105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0]]), expiries=np.array([[30.0 / 365.0], [60.0 / 365.0], [90.0 / 365.0]]), forwards=115.0, alpha=np.array([[1.0], [1.5], [2.0]]), beta=np.array([[0.25], [0.5], [0.75]]), rho=0.05, volvol=np.array([[2.0], [2.5], [3.0]]), dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [[0.07290126718857293, 0.048678694833488044, 0.02925354052258421, 0.048663433935318724, 0.06968554457600247], [0.19479147227269086, 0.1647194927224411, 0.15186141282688834, 0.16548343518393138, 0.19098676373872667], [0.7493941577599591, 0.7318045979333434, 0.7259931664225101, 0.7310817574988578, 0.7449168095317619]])",
            "def test_implied_volatility_parameter_broadcasting(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(strikes=np.array([[105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0], [105.0, 110.0, 115.0, 120.0, 125.0]]), expiries=np.array([[30.0 / 365.0], [60.0 / 365.0], [90.0 / 365.0]]), forwards=115.0, alpha=np.array([[1.0], [1.5], [2.0]]), beta=np.array([[0.25], [0.5], [0.75]]), rho=0.05, volvol=np.array([[2.0], [2.5], [3.0]]), dtype=tf.float64)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(equiv_vol, [[0.07290126718857293, 0.048678694833488044, 0.02925354052258421, 0.048663433935318724, 0.06968554457600247], [0.19479147227269086, 0.1647194927224411, 0.15186141282688834, 0.16548343518393138, 0.19098676373872667], [0.7493941577599591, 0.7318045979333434, 0.7259931664225101, 0.7310817574988578, 0.7449168095317619]])"
        ]
    },
    {
        "func_name": "test_implied_volatility_lognormal_correctness",
        "original": "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 0.1805437461785543}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.10940855660611389}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.5679836366288498}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 0.036000740359707344}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.1400903903272142}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.5, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.043211700217443874}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([0.14847284969337574, 0.46783426296790165])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_lognormal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=2e-05, rtol=0.0002)",
        "mutated": [
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 0.1805437461785543}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.10940855660611389}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.5679836366288498}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 0.036000740359707344}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.1400903903272142}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.5, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.043211700217443874}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([0.14847284969337574, 0.46783426296790165])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_lognormal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=2e-05, rtol=0.0002)",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 0.1805437461785543}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.10940855660611389}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.5679836366288498}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 0.036000740359707344}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.1400903903272142}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.5, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.043211700217443874}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([0.14847284969337574, 0.46783426296790165])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_lognormal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=2e-05, rtol=0.0002)",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 0.1805437461785543}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.10940855660611389}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.5679836366288498}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 0.036000740359707344}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.1400903903272142}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.5, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.043211700217443874}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([0.14847284969337574, 0.46783426296790165])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_lognormal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=2e-05, rtol=0.0002)",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 0.1805437461785543}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.10940855660611389}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.5679836366288498}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 0.036000740359707344}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.1400903903272142}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.5, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.043211700217443874}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([0.14847284969337574, 0.46783426296790165])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_lognormal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=2e-05, rtol=0.0002)",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 0.1805437461785543}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.10940855660611389}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 0.5679836366288498}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 0.036000740359707344}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.1400903903272142}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.5, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 0.043211700217443874}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([0.14847284969337574, 0.46783426296790165])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_lognormal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=2e-05, rtol=0.0002)"
        ]
    },
    {
        "func_name": "test_implied_volatility_normal_correctness",
        "original": "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.12, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 14.240742}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 13.098578}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 67.89029}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 4.309942}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 16.771861}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([1.557701, 6.032939])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_normal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype, volatility_type=NORMAL)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=0.005, rtol=0.001)",
        "mutated": [
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.12, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 14.240742}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 13.098578}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 67.89029}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 4.309942}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 16.771861}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([1.557701, 6.032939])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_normal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype, volatility_type=NORMAL)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=0.005, rtol=0.001)",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.12, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 14.240742}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 13.098578}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 67.89029}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 4.309942}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 16.771861}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([1.557701, 6.032939])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_normal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype, volatility_type=NORMAL)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=0.005, rtol=0.001)",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.12, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 14.240742}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 13.098578}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 67.89029}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 4.309942}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 16.771861}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([1.557701, 6.032939])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_normal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype, volatility_type=NORMAL)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=0.005, rtol=0.001)",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.12, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 14.240742}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 13.098578}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 67.89029}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 4.309942}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 16.771861}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([1.557701, 6.032939])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_normal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype, volatility_type=NORMAL)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=0.005, rtol=0.001)",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.12, 'volvol': 2.8, 'rho': -0.02, 'expected_vol': 14.240742}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 13.098578}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': 0.2, 'expected_vol': 67.89029}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 0.0, 'rho': 0.2, 'expected_vol': 4.309942}, {'strikes': 130.0, 'forwards': 110.0, 'expiries': 0.0, 'alpha': 0.31, 'beta': 0.55, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': 16.771861}, {'strikes': np.array([11.0, 15.0]), 'forwards': np.array([10.0, 11.0]), 'expiries': np.array([0.5, 2.0]), 'alpha': 0.31, 'beta': 0.28, 'volvol': 2.5, 'rho': 0.2, 'expected_vol': np.array([1.557701, 6.032939])}), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_normal_correctness(self, forwards, strikes, expiries, alpha, beta, rho, volvol, expected_vol, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, dtype=dtype, volatility_type=NORMAL)\n    equiv_vol = self.evaluate(equiv_vol)\n    self.assertAllClose(expected_vol, equiv_vol, atol=0.005, rtol=0.001)"
        ]
    },
    {
        "func_name": "test_implied_volatility_differentiable",
        "original": "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 0.0, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': np.array([[130.0, 140.0, 150.0], [130.0, 140.0, 150.0]]), 'forwards': 140.0, 'expiries': [[0.0], [1.0]], 'alpha': [[0.25], [0.5]], 'beta': [[0.33], [0.66]], 'volvol': [[1.0], [2.0]], 'rho': [[0.001], [-0.001]]}), vol_type=(NORMAL, LOGNORMAL), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_differentiable(self, strikes, forwards, expiries, alpha, beta, volvol, rho, vol_type, dtype):\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    alpha = tf.convert_to_tensor(alpha, dtype=dtype)\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([forwards, strikes, expiries, alpha, beta, rho, volvol])\n        equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, volatility_type=vol_type, dtype=dtype)\n        grad = tape.gradient(target=equiv_vol, sources=[forwards, strikes, expiries, alpha, beta, rho, volvol])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))",
        "mutated": [
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 0.0, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': np.array([[130.0, 140.0, 150.0], [130.0, 140.0, 150.0]]), 'forwards': 140.0, 'expiries': [[0.0], [1.0]], 'alpha': [[0.25], [0.5]], 'beta': [[0.33], [0.66]], 'volvol': [[1.0], [2.0]], 'rho': [[0.001], [-0.001]]}), vol_type=(NORMAL, LOGNORMAL), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_differentiable(self, strikes, forwards, expiries, alpha, beta, volvol, rho, vol_type, dtype):\n    if False:\n        i = 10\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    alpha = tf.convert_to_tensor(alpha, dtype=dtype)\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([forwards, strikes, expiries, alpha, beta, rho, volvol])\n        equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, volatility_type=vol_type, dtype=dtype)\n        grad = tape.gradient(target=equiv_vol, sources=[forwards, strikes, expiries, alpha, beta, rho, volvol])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 0.0, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': np.array([[130.0, 140.0, 150.0], [130.0, 140.0, 150.0]]), 'forwards': 140.0, 'expiries': [[0.0], [1.0]], 'alpha': [[0.25], [0.5]], 'beta': [[0.33], [0.66]], 'volvol': [[1.0], [2.0]], 'rho': [[0.001], [-0.001]]}), vol_type=(NORMAL, LOGNORMAL), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_differentiable(self, strikes, forwards, expiries, alpha, beta, volvol, rho, vol_type, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    alpha = tf.convert_to_tensor(alpha, dtype=dtype)\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([forwards, strikes, expiries, alpha, beta, rho, volvol])\n        equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, volatility_type=vol_type, dtype=dtype)\n        grad = tape.gradient(target=equiv_vol, sources=[forwards, strikes, expiries, alpha, beta, rho, volvol])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 0.0, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': np.array([[130.0, 140.0, 150.0], [130.0, 140.0, 150.0]]), 'forwards': 140.0, 'expiries': [[0.0], [1.0]], 'alpha': [[0.25], [0.5]], 'beta': [[0.33], [0.66]], 'volvol': [[1.0], [2.0]], 'rho': [[0.001], [-0.001]]}), vol_type=(NORMAL, LOGNORMAL), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_differentiable(self, strikes, forwards, expiries, alpha, beta, volvol, rho, vol_type, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    alpha = tf.convert_to_tensor(alpha, dtype=dtype)\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([forwards, strikes, expiries, alpha, beta, rho, volvol])\n        equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, volatility_type=vol_type, dtype=dtype)\n        grad = tape.gradient(target=equiv_vol, sources=[forwards, strikes, expiries, alpha, beta, rho, volvol])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 0.0, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': np.array([[130.0, 140.0, 150.0], [130.0, 140.0, 150.0]]), 'forwards': 140.0, 'expiries': [[0.0], [1.0]], 'alpha': [[0.25], [0.5]], 'beta': [[0.33], [0.66]], 'volvol': [[1.0], [2.0]], 'rho': [[0.001], [-0.001]]}), vol_type=(NORMAL, LOGNORMAL), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_differentiable(self, strikes, forwards, expiries, alpha, beta, volvol, rho, vol_type, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    alpha = tf.convert_to_tensor(alpha, dtype=dtype)\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([forwards, strikes, expiries, alpha, beta, rho, volvol])\n        equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, volatility_type=vol_type, dtype=dtype)\n        grad = tape.gradient(target=equiv_vol, sources=[forwards, strikes, expiries, alpha, beta, rho, volvol])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))",
            "@parameterized.product(({'strikes': 130.0, 'forwards': 110.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 1.0, 'volvol': 2.8, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 200.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 0.0, 'rho': -0.02}, {'strikes': 130.0, 'forwards': 130.0, 'expiries': 0.0 / 365.0, 'alpha': 0.31, 'beta': 0.5, 'volvol': 2.8, 'rho': -0.02}, {'strikes': np.array([[130.0, 140.0, 150.0], [130.0, 140.0, 150.0]]), 'forwards': 140.0, 'expiries': [[0.0], [1.0]], 'alpha': [[0.25], [0.5]], 'beta': [[0.33], [0.66]], 'volvol': [[1.0], [2.0]], 'rho': [[0.001], [-0.001]]}), vol_type=(NORMAL, LOGNORMAL), dtype=(tf.float32, tf.float64))\ndef test_implied_volatility_differentiable(self, strikes, forwards, expiries, alpha, beta, volvol, rho, vol_type, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    alpha = tf.convert_to_tensor(alpha, dtype=dtype)\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([forwards, strikes, expiries, alpha, beta, rho, volvol])\n        equiv_vol = tff.models.sabr.approximations.implied_volatility(forwards=forwards, strikes=strikes, expiries=expiries, alpha=alpha, beta=beta, rho=rho, volvol=volvol, volatility_type=vol_type, dtype=dtype)\n        grad = tape.gradient(target=equiv_vol, sources=[forwards, strikes, expiries, alpha, beta, rho, volvol])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))"
        ]
    },
    {
        "func_name": "test_implied_volatility_shifted_model_example",
        "original": "@parameterized.parameters([NORMAL, LOGNORMAL])\ndef test_implied_volatility_shifted_model_example(self, volatility_type):\n    shift = np.array([1.0, 2.0])\n    actual_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5, 0.0]), strikes=np.array([1.0, 2.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, shift=shift, dtype=tf.float64, volatility_type=volatility_type)\n    expected_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5 + shift[0], 0.0 + shift[1]]), strikes=np.array([1.0 + shift[0], 2.0 + shift[1]]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64, volatility_type=volatility_type)\n    (actual_vol, expected_vol) = self.evaluate([actual_vol, expected_vol])\n    self.assertAllClose(actual_vol, expected_vol)",
        "mutated": [
            "@parameterized.parameters([NORMAL, LOGNORMAL])\ndef test_implied_volatility_shifted_model_example(self, volatility_type):\n    if False:\n        i = 10\n    shift = np.array([1.0, 2.0])\n    actual_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5, 0.0]), strikes=np.array([1.0, 2.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, shift=shift, dtype=tf.float64, volatility_type=volatility_type)\n    expected_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5 + shift[0], 0.0 + shift[1]]), strikes=np.array([1.0 + shift[0], 2.0 + shift[1]]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64, volatility_type=volatility_type)\n    (actual_vol, expected_vol) = self.evaluate([actual_vol, expected_vol])\n    self.assertAllClose(actual_vol, expected_vol)",
            "@parameterized.parameters([NORMAL, LOGNORMAL])\ndef test_implied_volatility_shifted_model_example(self, volatility_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    shift = np.array([1.0, 2.0])\n    actual_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5, 0.0]), strikes=np.array([1.0, 2.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, shift=shift, dtype=tf.float64, volatility_type=volatility_type)\n    expected_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5 + shift[0], 0.0 + shift[1]]), strikes=np.array([1.0 + shift[0], 2.0 + shift[1]]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64, volatility_type=volatility_type)\n    (actual_vol, expected_vol) = self.evaluate([actual_vol, expected_vol])\n    self.assertAllClose(actual_vol, expected_vol)",
            "@parameterized.parameters([NORMAL, LOGNORMAL])\ndef test_implied_volatility_shifted_model_example(self, volatility_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    shift = np.array([1.0, 2.0])\n    actual_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5, 0.0]), strikes=np.array([1.0, 2.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, shift=shift, dtype=tf.float64, volatility_type=volatility_type)\n    expected_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5 + shift[0], 0.0 + shift[1]]), strikes=np.array([1.0 + shift[0], 2.0 + shift[1]]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64, volatility_type=volatility_type)\n    (actual_vol, expected_vol) = self.evaluate([actual_vol, expected_vol])\n    self.assertAllClose(actual_vol, expected_vol)",
            "@parameterized.parameters([NORMAL, LOGNORMAL])\ndef test_implied_volatility_shifted_model_example(self, volatility_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    shift = np.array([1.0, 2.0])\n    actual_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5, 0.0]), strikes=np.array([1.0, 2.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, shift=shift, dtype=tf.float64, volatility_type=volatility_type)\n    expected_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5 + shift[0], 0.0 + shift[1]]), strikes=np.array([1.0 + shift[0], 2.0 + shift[1]]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64, volatility_type=volatility_type)\n    (actual_vol, expected_vol) = self.evaluate([actual_vol, expected_vol])\n    self.assertAllClose(actual_vol, expected_vol)",
            "@parameterized.parameters([NORMAL, LOGNORMAL])\ndef test_implied_volatility_shifted_model_example(self, volatility_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    shift = np.array([1.0, 2.0])\n    actual_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5, 0.0]), strikes=np.array([1.0, 2.0]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, shift=shift, dtype=tf.float64, volatility_type=volatility_type)\n    expected_vol = tff.models.sabr.approximations.implied_volatility(forwards=np.array([-0.5 + shift[0], 0.0 + shift[1]]), strikes=np.array([1.0 + shift[0], 2.0 + shift[1]]), expiries=np.array([17.0 / 365.0, 400.0 / 365.0]), alpha=1.63, beta=0.6, rho=2e-05, volvol=3.3, dtype=tf.float64, volatility_type=volatility_type)\n    (actual_vol, expected_vol) = self.evaluate([actual_vol, expected_vol])\n    self.assertAllClose(actual_vol, expected_vol)"
        ]
    }
]