[
    {
        "func_name": "_tricode",
        "original": "def _tricode(G, v, u, w):\n    \"\"\"Returns the integer code of the given triad.\n\n    This is some fancy magic that comes from Batagelj and Mrvar's paper. It\n    treats each edge joining a pair of `v`, `u`, and `w` as a bit in\n    the binary representation of an integer.\n\n    \"\"\"\n    combos = ((v, u, 1), (u, v, 2), (v, w, 4), (w, v, 8), (u, w, 16), (w, u, 32))\n    return sum((x for (u, v, x) in combos if v in G[u]))",
        "mutated": [
            "def _tricode(G, v, u, w):\n    if False:\n        i = 10\n    \"Returns the integer code of the given triad.\\n\\n    This is some fancy magic that comes from Batagelj and Mrvar's paper. It\\n    treats each edge joining a pair of `v`, `u`, and `w` as a bit in\\n    the binary representation of an integer.\\n\\n    \"\n    combos = ((v, u, 1), (u, v, 2), (v, w, 4), (w, v, 8), (u, w, 16), (w, u, 32))\n    return sum((x for (u, v, x) in combos if v in G[u]))",
            "def _tricode(G, v, u, w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Returns the integer code of the given triad.\\n\\n    This is some fancy magic that comes from Batagelj and Mrvar's paper. It\\n    treats each edge joining a pair of `v`, `u`, and `w` as a bit in\\n    the binary representation of an integer.\\n\\n    \"\n    combos = ((v, u, 1), (u, v, 2), (v, w, 4), (w, v, 8), (u, w, 16), (w, u, 32))\n    return sum((x for (u, v, x) in combos if v in G[u]))",
            "def _tricode(G, v, u, w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Returns the integer code of the given triad.\\n\\n    This is some fancy magic that comes from Batagelj and Mrvar's paper. It\\n    treats each edge joining a pair of `v`, `u`, and `w` as a bit in\\n    the binary representation of an integer.\\n\\n    \"\n    combos = ((v, u, 1), (u, v, 2), (v, w, 4), (w, v, 8), (u, w, 16), (w, u, 32))\n    return sum((x for (u, v, x) in combos if v in G[u]))",
            "def _tricode(G, v, u, w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Returns the integer code of the given triad.\\n\\n    This is some fancy magic that comes from Batagelj and Mrvar's paper. It\\n    treats each edge joining a pair of `v`, `u`, and `w` as a bit in\\n    the binary representation of an integer.\\n\\n    \"\n    combos = ((v, u, 1), (u, v, 2), (v, w, 4), (w, v, 8), (u, w, 16), (w, u, 32))\n    return sum((x for (u, v, x) in combos if v in G[u]))",
            "def _tricode(G, v, u, w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Returns the integer code of the given triad.\\n\\n    This is some fancy magic that comes from Batagelj and Mrvar's paper. It\\n    treats each edge joining a pair of `v`, `u`, and `w` as a bit in\\n    the binary representation of an integer.\\n\\n    \"\n    combos = ((v, u, 1), (u, v, 2), (v, w, 4), (w, v, 8), (u, w, 16), (w, u, 32))\n    return sum((x for (u, v, x) in combos if v in G[u]))"
        ]
    },
    {
        "func_name": "triadic_census",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef triadic_census(G, nodelist=None):\n    \"\"\"Determines the triadic census of a directed graph.\n\n    The triadic census is a count of how many of the 16 possible types of\n    triads are present in a directed graph. If a list of nodes is passed, then\n    only those triads are taken into account which have elements of nodelist in them.\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph\n    nodelist : list\n        List of nodes for which you want to calculate triadic census\n\n    Returns\n    -------\n    census : dict\n       Dictionary with triad type as keys and number of occurrences as values.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\n    >>> triadic_census = nx.triadic_census(G)\n    >>> for key, value in triadic_census.items():\n    ...     print(f\"{key}: {value}\")\n    ...\n    003: 0\n    012: 0\n    102: 0\n    021D: 0\n    021U: 0\n    021C: 0\n    111D: 0\n    111U: 0\n    030T: 2\n    030C: 2\n    201: 0\n    120D: 0\n    120U: 0\n    120C: 0\n    210: 0\n    300: 0\n\n    Notes\n    -----\n    This algorithm has complexity $O(m)$ where $m$ is the number of edges in\n    the graph.\n\n    Raises\n    ------\n    ValueError\n        If `nodelist` contains duplicate nodes or nodes not in `G`.\n        If you want to ignore this you can preprocess with `set(nodelist) & G.nodes`\n\n    See also\n    --------\n    triad_graph\n\n    References\n    ----------\n    .. [1] Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\n        algorithm for large sparse networks with small maximum degree,\n        University of Ljubljana,\n        http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf\n\n    \"\"\"\n    nodeset = set(G.nbunch_iter(nodelist))\n    if nodelist is not None and len(nodelist) != len(nodeset):\n        raise ValueError('nodelist includes duplicate nodes or nodes not in G')\n    N = len(G)\n    Nnot = N - len(nodeset)\n    m = {n: i for (i, n) in enumerate(nodeset)}\n    if Nnot:\n        not_nodeset = G.nodes - nodeset\n        m.update(((n, i + N) for (i, n) in enumerate(not_nodeset)))\n    nbrs = {n: G.pred[n].keys() | G.succ[n].keys() for n in G}\n    dbl_nbrs = {n: G.pred[n].keys() & G.succ[n].keys() for n in G}\n    if Nnot:\n        sgl_nbrs = {n: G.pred[n].keys() ^ G.succ[n].keys() for n in not_nodeset}\n        sgl = sum((1 for n in not_nodeset for nbr in sgl_nbrs[n] if nbr not in nodeset))\n        sgl_edges_outside = sgl // 2\n        dbl = sum((1 for n in not_nodeset for nbr in dbl_nbrs[n] if nbr not in nodeset))\n        dbl_edges_outside = dbl // 2\n    census = {name: 0 for name in TRIAD_NAMES}\n    for v in nodeset:\n        vnbrs = nbrs[v]\n        dbl_vnbrs = dbl_nbrs[v]\n        if Nnot:\n            sgl_unbrs_bdy = sgl_unbrs_out = dbl_unbrs_bdy = dbl_unbrs_out = 0\n        for u in vnbrs:\n            if m[u] <= m[v]:\n                continue\n            unbrs = nbrs[u]\n            neighbors = (vnbrs | unbrs) - {u, v}\n            for w in neighbors:\n                if m[u] < m[w] or (m[v] < m[w] < m[u] and v not in nbrs[w]):\n                    code = _tricode(G, v, u, w)\n                    census[TRICODE_TO_NAME[code]] += 1\n            if u in dbl_vnbrs:\n                census['102'] += N - len(neighbors) - 2\n            else:\n                census['012'] += N - len(neighbors) - 2\n            if Nnot and u not in nodeset:\n                sgl_unbrs = sgl_nbrs[u]\n                sgl_unbrs_bdy += len(sgl_unbrs & vnbrs - nodeset)\n                sgl_unbrs_out += len(sgl_unbrs - vnbrs - nodeset)\n                dbl_unbrs = dbl_nbrs[u]\n                dbl_unbrs_bdy += len(dbl_unbrs & vnbrs - nodeset)\n                dbl_unbrs_out += len(dbl_unbrs - vnbrs - nodeset)\n        if Nnot:\n            census['012'] += sgl_edges_outside - (sgl_unbrs_out + sgl_unbrs_bdy // 2)\n            census['102'] += dbl_edges_outside - (dbl_unbrs_out + dbl_unbrs_bdy // 2)\n    total_triangles = N * (N - 1) * (N - 2) // 6\n    triangles_without_nodeset = Nnot * (Nnot - 1) * (Nnot - 2) // 6\n    total_census = total_triangles - triangles_without_nodeset\n    census['003'] = total_census - sum(census.values())\n    return census",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triadic_census(G, nodelist=None):\n    if False:\n        i = 10\n    'Determines the triadic census of a directed graph.\\n\\n    The triadic census is a count of how many of the 16 possible types of\\n    triads are present in a directed graph. If a list of nodes is passed, then\\n    only those triads are taken into account which have elements of nodelist in them.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    nodelist : list\\n        List of nodes for which you want to calculate triadic census\\n\\n    Returns\\n    -------\\n    census : dict\\n       Dictionary with triad type as keys and number of occurrences as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> triadic_census = nx.triadic_census(G)\\n    >>> for key, value in triadic_census.items():\\n    ...     print(f\"{key}: {value}\")\\n    ...\\n    003: 0\\n    012: 0\\n    102: 0\\n    021D: 0\\n    021U: 0\\n    021C: 0\\n    111D: 0\\n    111U: 0\\n    030T: 2\\n    030C: 2\\n    201: 0\\n    120D: 0\\n    120U: 0\\n    120C: 0\\n    210: 0\\n    300: 0\\n\\n    Notes\\n    -----\\n    This algorithm has complexity $O(m)$ where $m$ is the number of edges in\\n    the graph.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If `nodelist` contains duplicate nodes or nodes not in `G`.\\n        If you want to ignore this you can preprocess with `set(nodelist) & G.nodes`\\n\\n    See also\\n    --------\\n    triad_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\\n        algorithm for large sparse networks with small maximum degree,\\n        University of Ljubljana,\\n        http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf\\n\\n    '\n    nodeset = set(G.nbunch_iter(nodelist))\n    if nodelist is not None and len(nodelist) != len(nodeset):\n        raise ValueError('nodelist includes duplicate nodes or nodes not in G')\n    N = len(G)\n    Nnot = N - len(nodeset)\n    m = {n: i for (i, n) in enumerate(nodeset)}\n    if Nnot:\n        not_nodeset = G.nodes - nodeset\n        m.update(((n, i + N) for (i, n) in enumerate(not_nodeset)))\n    nbrs = {n: G.pred[n].keys() | G.succ[n].keys() for n in G}\n    dbl_nbrs = {n: G.pred[n].keys() & G.succ[n].keys() for n in G}\n    if Nnot:\n        sgl_nbrs = {n: G.pred[n].keys() ^ G.succ[n].keys() for n in not_nodeset}\n        sgl = sum((1 for n in not_nodeset for nbr in sgl_nbrs[n] if nbr not in nodeset))\n        sgl_edges_outside = sgl // 2\n        dbl = sum((1 for n in not_nodeset for nbr in dbl_nbrs[n] if nbr not in nodeset))\n        dbl_edges_outside = dbl // 2\n    census = {name: 0 for name in TRIAD_NAMES}\n    for v in nodeset:\n        vnbrs = nbrs[v]\n        dbl_vnbrs = dbl_nbrs[v]\n        if Nnot:\n            sgl_unbrs_bdy = sgl_unbrs_out = dbl_unbrs_bdy = dbl_unbrs_out = 0\n        for u in vnbrs:\n            if m[u] <= m[v]:\n                continue\n            unbrs = nbrs[u]\n            neighbors = (vnbrs | unbrs) - {u, v}\n            for w in neighbors:\n                if m[u] < m[w] or (m[v] < m[w] < m[u] and v not in nbrs[w]):\n                    code = _tricode(G, v, u, w)\n                    census[TRICODE_TO_NAME[code]] += 1\n            if u in dbl_vnbrs:\n                census['102'] += N - len(neighbors) - 2\n            else:\n                census['012'] += N - len(neighbors) - 2\n            if Nnot and u not in nodeset:\n                sgl_unbrs = sgl_nbrs[u]\n                sgl_unbrs_bdy += len(sgl_unbrs & vnbrs - nodeset)\n                sgl_unbrs_out += len(sgl_unbrs - vnbrs - nodeset)\n                dbl_unbrs = dbl_nbrs[u]\n                dbl_unbrs_bdy += len(dbl_unbrs & vnbrs - nodeset)\n                dbl_unbrs_out += len(dbl_unbrs - vnbrs - nodeset)\n        if Nnot:\n            census['012'] += sgl_edges_outside - (sgl_unbrs_out + sgl_unbrs_bdy // 2)\n            census['102'] += dbl_edges_outside - (dbl_unbrs_out + dbl_unbrs_bdy // 2)\n    total_triangles = N * (N - 1) * (N - 2) // 6\n    triangles_without_nodeset = Nnot * (Nnot - 1) * (Nnot - 2) // 6\n    total_census = total_triangles - triangles_without_nodeset\n    census['003'] = total_census - sum(census.values())\n    return census",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triadic_census(G, nodelist=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Determines the triadic census of a directed graph.\\n\\n    The triadic census is a count of how many of the 16 possible types of\\n    triads are present in a directed graph. If a list of nodes is passed, then\\n    only those triads are taken into account which have elements of nodelist in them.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    nodelist : list\\n        List of nodes for which you want to calculate triadic census\\n\\n    Returns\\n    -------\\n    census : dict\\n       Dictionary with triad type as keys and number of occurrences as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> triadic_census = nx.triadic_census(G)\\n    >>> for key, value in triadic_census.items():\\n    ...     print(f\"{key}: {value}\")\\n    ...\\n    003: 0\\n    012: 0\\n    102: 0\\n    021D: 0\\n    021U: 0\\n    021C: 0\\n    111D: 0\\n    111U: 0\\n    030T: 2\\n    030C: 2\\n    201: 0\\n    120D: 0\\n    120U: 0\\n    120C: 0\\n    210: 0\\n    300: 0\\n\\n    Notes\\n    -----\\n    This algorithm has complexity $O(m)$ where $m$ is the number of edges in\\n    the graph.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If `nodelist` contains duplicate nodes or nodes not in `G`.\\n        If you want to ignore this you can preprocess with `set(nodelist) & G.nodes`\\n\\n    See also\\n    --------\\n    triad_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\\n        algorithm for large sparse networks with small maximum degree,\\n        University of Ljubljana,\\n        http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf\\n\\n    '\n    nodeset = set(G.nbunch_iter(nodelist))\n    if nodelist is not None and len(nodelist) != len(nodeset):\n        raise ValueError('nodelist includes duplicate nodes or nodes not in G')\n    N = len(G)\n    Nnot = N - len(nodeset)\n    m = {n: i for (i, n) in enumerate(nodeset)}\n    if Nnot:\n        not_nodeset = G.nodes - nodeset\n        m.update(((n, i + N) for (i, n) in enumerate(not_nodeset)))\n    nbrs = {n: G.pred[n].keys() | G.succ[n].keys() for n in G}\n    dbl_nbrs = {n: G.pred[n].keys() & G.succ[n].keys() for n in G}\n    if Nnot:\n        sgl_nbrs = {n: G.pred[n].keys() ^ G.succ[n].keys() for n in not_nodeset}\n        sgl = sum((1 for n in not_nodeset for nbr in sgl_nbrs[n] if nbr not in nodeset))\n        sgl_edges_outside = sgl // 2\n        dbl = sum((1 for n in not_nodeset for nbr in dbl_nbrs[n] if nbr not in nodeset))\n        dbl_edges_outside = dbl // 2\n    census = {name: 0 for name in TRIAD_NAMES}\n    for v in nodeset:\n        vnbrs = nbrs[v]\n        dbl_vnbrs = dbl_nbrs[v]\n        if Nnot:\n            sgl_unbrs_bdy = sgl_unbrs_out = dbl_unbrs_bdy = dbl_unbrs_out = 0\n        for u in vnbrs:\n            if m[u] <= m[v]:\n                continue\n            unbrs = nbrs[u]\n            neighbors = (vnbrs | unbrs) - {u, v}\n            for w in neighbors:\n                if m[u] < m[w] or (m[v] < m[w] < m[u] and v not in nbrs[w]):\n                    code = _tricode(G, v, u, w)\n                    census[TRICODE_TO_NAME[code]] += 1\n            if u in dbl_vnbrs:\n                census['102'] += N - len(neighbors) - 2\n            else:\n                census['012'] += N - len(neighbors) - 2\n            if Nnot and u not in nodeset:\n                sgl_unbrs = sgl_nbrs[u]\n                sgl_unbrs_bdy += len(sgl_unbrs & vnbrs - nodeset)\n                sgl_unbrs_out += len(sgl_unbrs - vnbrs - nodeset)\n                dbl_unbrs = dbl_nbrs[u]\n                dbl_unbrs_bdy += len(dbl_unbrs & vnbrs - nodeset)\n                dbl_unbrs_out += len(dbl_unbrs - vnbrs - nodeset)\n        if Nnot:\n            census['012'] += sgl_edges_outside - (sgl_unbrs_out + sgl_unbrs_bdy // 2)\n            census['102'] += dbl_edges_outside - (dbl_unbrs_out + dbl_unbrs_bdy // 2)\n    total_triangles = N * (N - 1) * (N - 2) // 6\n    triangles_without_nodeset = Nnot * (Nnot - 1) * (Nnot - 2) // 6\n    total_census = total_triangles - triangles_without_nodeset\n    census['003'] = total_census - sum(census.values())\n    return census",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triadic_census(G, nodelist=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Determines the triadic census of a directed graph.\\n\\n    The triadic census is a count of how many of the 16 possible types of\\n    triads are present in a directed graph. If a list of nodes is passed, then\\n    only those triads are taken into account which have elements of nodelist in them.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    nodelist : list\\n        List of nodes for which you want to calculate triadic census\\n\\n    Returns\\n    -------\\n    census : dict\\n       Dictionary with triad type as keys and number of occurrences as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> triadic_census = nx.triadic_census(G)\\n    >>> for key, value in triadic_census.items():\\n    ...     print(f\"{key}: {value}\")\\n    ...\\n    003: 0\\n    012: 0\\n    102: 0\\n    021D: 0\\n    021U: 0\\n    021C: 0\\n    111D: 0\\n    111U: 0\\n    030T: 2\\n    030C: 2\\n    201: 0\\n    120D: 0\\n    120U: 0\\n    120C: 0\\n    210: 0\\n    300: 0\\n\\n    Notes\\n    -----\\n    This algorithm has complexity $O(m)$ where $m$ is the number of edges in\\n    the graph.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If `nodelist` contains duplicate nodes or nodes not in `G`.\\n        If you want to ignore this you can preprocess with `set(nodelist) & G.nodes`\\n\\n    See also\\n    --------\\n    triad_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\\n        algorithm for large sparse networks with small maximum degree,\\n        University of Ljubljana,\\n        http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf\\n\\n    '\n    nodeset = set(G.nbunch_iter(nodelist))\n    if nodelist is not None and len(nodelist) != len(nodeset):\n        raise ValueError('nodelist includes duplicate nodes or nodes not in G')\n    N = len(G)\n    Nnot = N - len(nodeset)\n    m = {n: i for (i, n) in enumerate(nodeset)}\n    if Nnot:\n        not_nodeset = G.nodes - nodeset\n        m.update(((n, i + N) for (i, n) in enumerate(not_nodeset)))\n    nbrs = {n: G.pred[n].keys() | G.succ[n].keys() for n in G}\n    dbl_nbrs = {n: G.pred[n].keys() & G.succ[n].keys() for n in G}\n    if Nnot:\n        sgl_nbrs = {n: G.pred[n].keys() ^ G.succ[n].keys() for n in not_nodeset}\n        sgl = sum((1 for n in not_nodeset for nbr in sgl_nbrs[n] if nbr not in nodeset))\n        sgl_edges_outside = sgl // 2\n        dbl = sum((1 for n in not_nodeset for nbr in dbl_nbrs[n] if nbr not in nodeset))\n        dbl_edges_outside = dbl // 2\n    census = {name: 0 for name in TRIAD_NAMES}\n    for v in nodeset:\n        vnbrs = nbrs[v]\n        dbl_vnbrs = dbl_nbrs[v]\n        if Nnot:\n            sgl_unbrs_bdy = sgl_unbrs_out = dbl_unbrs_bdy = dbl_unbrs_out = 0\n        for u in vnbrs:\n            if m[u] <= m[v]:\n                continue\n            unbrs = nbrs[u]\n            neighbors = (vnbrs | unbrs) - {u, v}\n            for w in neighbors:\n                if m[u] < m[w] or (m[v] < m[w] < m[u] and v not in nbrs[w]):\n                    code = _tricode(G, v, u, w)\n                    census[TRICODE_TO_NAME[code]] += 1\n            if u in dbl_vnbrs:\n                census['102'] += N - len(neighbors) - 2\n            else:\n                census['012'] += N - len(neighbors) - 2\n            if Nnot and u not in nodeset:\n                sgl_unbrs = sgl_nbrs[u]\n                sgl_unbrs_bdy += len(sgl_unbrs & vnbrs - nodeset)\n                sgl_unbrs_out += len(sgl_unbrs - vnbrs - nodeset)\n                dbl_unbrs = dbl_nbrs[u]\n                dbl_unbrs_bdy += len(dbl_unbrs & vnbrs - nodeset)\n                dbl_unbrs_out += len(dbl_unbrs - vnbrs - nodeset)\n        if Nnot:\n            census['012'] += sgl_edges_outside - (sgl_unbrs_out + sgl_unbrs_bdy // 2)\n            census['102'] += dbl_edges_outside - (dbl_unbrs_out + dbl_unbrs_bdy // 2)\n    total_triangles = N * (N - 1) * (N - 2) // 6\n    triangles_without_nodeset = Nnot * (Nnot - 1) * (Nnot - 2) // 6\n    total_census = total_triangles - triangles_without_nodeset\n    census['003'] = total_census - sum(census.values())\n    return census",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triadic_census(G, nodelist=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Determines the triadic census of a directed graph.\\n\\n    The triadic census is a count of how many of the 16 possible types of\\n    triads are present in a directed graph. If a list of nodes is passed, then\\n    only those triads are taken into account which have elements of nodelist in them.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    nodelist : list\\n        List of nodes for which you want to calculate triadic census\\n\\n    Returns\\n    -------\\n    census : dict\\n       Dictionary with triad type as keys and number of occurrences as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> triadic_census = nx.triadic_census(G)\\n    >>> for key, value in triadic_census.items():\\n    ...     print(f\"{key}: {value}\")\\n    ...\\n    003: 0\\n    012: 0\\n    102: 0\\n    021D: 0\\n    021U: 0\\n    021C: 0\\n    111D: 0\\n    111U: 0\\n    030T: 2\\n    030C: 2\\n    201: 0\\n    120D: 0\\n    120U: 0\\n    120C: 0\\n    210: 0\\n    300: 0\\n\\n    Notes\\n    -----\\n    This algorithm has complexity $O(m)$ where $m$ is the number of edges in\\n    the graph.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If `nodelist` contains duplicate nodes or nodes not in `G`.\\n        If you want to ignore this you can preprocess with `set(nodelist) & G.nodes`\\n\\n    See also\\n    --------\\n    triad_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\\n        algorithm for large sparse networks with small maximum degree,\\n        University of Ljubljana,\\n        http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf\\n\\n    '\n    nodeset = set(G.nbunch_iter(nodelist))\n    if nodelist is not None and len(nodelist) != len(nodeset):\n        raise ValueError('nodelist includes duplicate nodes or nodes not in G')\n    N = len(G)\n    Nnot = N - len(nodeset)\n    m = {n: i for (i, n) in enumerate(nodeset)}\n    if Nnot:\n        not_nodeset = G.nodes - nodeset\n        m.update(((n, i + N) for (i, n) in enumerate(not_nodeset)))\n    nbrs = {n: G.pred[n].keys() | G.succ[n].keys() for n in G}\n    dbl_nbrs = {n: G.pred[n].keys() & G.succ[n].keys() for n in G}\n    if Nnot:\n        sgl_nbrs = {n: G.pred[n].keys() ^ G.succ[n].keys() for n in not_nodeset}\n        sgl = sum((1 for n in not_nodeset for nbr in sgl_nbrs[n] if nbr not in nodeset))\n        sgl_edges_outside = sgl // 2\n        dbl = sum((1 for n in not_nodeset for nbr in dbl_nbrs[n] if nbr not in nodeset))\n        dbl_edges_outside = dbl // 2\n    census = {name: 0 for name in TRIAD_NAMES}\n    for v in nodeset:\n        vnbrs = nbrs[v]\n        dbl_vnbrs = dbl_nbrs[v]\n        if Nnot:\n            sgl_unbrs_bdy = sgl_unbrs_out = dbl_unbrs_bdy = dbl_unbrs_out = 0\n        for u in vnbrs:\n            if m[u] <= m[v]:\n                continue\n            unbrs = nbrs[u]\n            neighbors = (vnbrs | unbrs) - {u, v}\n            for w in neighbors:\n                if m[u] < m[w] or (m[v] < m[w] < m[u] and v not in nbrs[w]):\n                    code = _tricode(G, v, u, w)\n                    census[TRICODE_TO_NAME[code]] += 1\n            if u in dbl_vnbrs:\n                census['102'] += N - len(neighbors) - 2\n            else:\n                census['012'] += N - len(neighbors) - 2\n            if Nnot and u not in nodeset:\n                sgl_unbrs = sgl_nbrs[u]\n                sgl_unbrs_bdy += len(sgl_unbrs & vnbrs - nodeset)\n                sgl_unbrs_out += len(sgl_unbrs - vnbrs - nodeset)\n                dbl_unbrs = dbl_nbrs[u]\n                dbl_unbrs_bdy += len(dbl_unbrs & vnbrs - nodeset)\n                dbl_unbrs_out += len(dbl_unbrs - vnbrs - nodeset)\n        if Nnot:\n            census['012'] += sgl_edges_outside - (sgl_unbrs_out + sgl_unbrs_bdy // 2)\n            census['102'] += dbl_edges_outside - (dbl_unbrs_out + dbl_unbrs_bdy // 2)\n    total_triangles = N * (N - 1) * (N - 2) // 6\n    triangles_without_nodeset = Nnot * (Nnot - 1) * (Nnot - 2) // 6\n    total_census = total_triangles - triangles_without_nodeset\n    census['003'] = total_census - sum(census.values())\n    return census",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triadic_census(G, nodelist=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Determines the triadic census of a directed graph.\\n\\n    The triadic census is a count of how many of the 16 possible types of\\n    triads are present in a directed graph. If a list of nodes is passed, then\\n    only those triads are taken into account which have elements of nodelist in them.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    nodelist : list\\n        List of nodes for which you want to calculate triadic census\\n\\n    Returns\\n    -------\\n    census : dict\\n       Dictionary with triad type as keys and number of occurrences as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> triadic_census = nx.triadic_census(G)\\n    >>> for key, value in triadic_census.items():\\n    ...     print(f\"{key}: {value}\")\\n    ...\\n    003: 0\\n    012: 0\\n    102: 0\\n    021D: 0\\n    021U: 0\\n    021C: 0\\n    111D: 0\\n    111U: 0\\n    030T: 2\\n    030C: 2\\n    201: 0\\n    120D: 0\\n    120U: 0\\n    120C: 0\\n    210: 0\\n    300: 0\\n\\n    Notes\\n    -----\\n    This algorithm has complexity $O(m)$ where $m$ is the number of edges in\\n    the graph.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If `nodelist` contains duplicate nodes or nodes not in `G`.\\n        If you want to ignore this you can preprocess with `set(nodelist) & G.nodes`\\n\\n    See also\\n    --------\\n    triad_graph\\n\\n    References\\n    ----------\\n    .. [1] Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\\n        algorithm for large sparse networks with small maximum degree,\\n        University of Ljubljana,\\n        http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf\\n\\n    '\n    nodeset = set(G.nbunch_iter(nodelist))\n    if nodelist is not None and len(nodelist) != len(nodeset):\n        raise ValueError('nodelist includes duplicate nodes or nodes not in G')\n    N = len(G)\n    Nnot = N - len(nodeset)\n    m = {n: i for (i, n) in enumerate(nodeset)}\n    if Nnot:\n        not_nodeset = G.nodes - nodeset\n        m.update(((n, i + N) for (i, n) in enumerate(not_nodeset)))\n    nbrs = {n: G.pred[n].keys() | G.succ[n].keys() for n in G}\n    dbl_nbrs = {n: G.pred[n].keys() & G.succ[n].keys() for n in G}\n    if Nnot:\n        sgl_nbrs = {n: G.pred[n].keys() ^ G.succ[n].keys() for n in not_nodeset}\n        sgl = sum((1 for n in not_nodeset for nbr in sgl_nbrs[n] if nbr not in nodeset))\n        sgl_edges_outside = sgl // 2\n        dbl = sum((1 for n in not_nodeset for nbr in dbl_nbrs[n] if nbr not in nodeset))\n        dbl_edges_outside = dbl // 2\n    census = {name: 0 for name in TRIAD_NAMES}\n    for v in nodeset:\n        vnbrs = nbrs[v]\n        dbl_vnbrs = dbl_nbrs[v]\n        if Nnot:\n            sgl_unbrs_bdy = sgl_unbrs_out = dbl_unbrs_bdy = dbl_unbrs_out = 0\n        for u in vnbrs:\n            if m[u] <= m[v]:\n                continue\n            unbrs = nbrs[u]\n            neighbors = (vnbrs | unbrs) - {u, v}\n            for w in neighbors:\n                if m[u] < m[w] or (m[v] < m[w] < m[u] and v not in nbrs[w]):\n                    code = _tricode(G, v, u, w)\n                    census[TRICODE_TO_NAME[code]] += 1\n            if u in dbl_vnbrs:\n                census['102'] += N - len(neighbors) - 2\n            else:\n                census['012'] += N - len(neighbors) - 2\n            if Nnot and u not in nodeset:\n                sgl_unbrs = sgl_nbrs[u]\n                sgl_unbrs_bdy += len(sgl_unbrs & vnbrs - nodeset)\n                sgl_unbrs_out += len(sgl_unbrs - vnbrs - nodeset)\n                dbl_unbrs = dbl_nbrs[u]\n                dbl_unbrs_bdy += len(dbl_unbrs & vnbrs - nodeset)\n                dbl_unbrs_out += len(dbl_unbrs - vnbrs - nodeset)\n        if Nnot:\n            census['012'] += sgl_edges_outside - (sgl_unbrs_out + sgl_unbrs_bdy // 2)\n            census['102'] += dbl_edges_outside - (dbl_unbrs_out + dbl_unbrs_bdy // 2)\n    total_triangles = N * (N - 1) * (N - 2) // 6\n    triangles_without_nodeset = Nnot * (Nnot - 1) * (Nnot - 2) // 6\n    total_census = total_triangles - triangles_without_nodeset\n    census['003'] = total_census - sum(census.values())\n    return census"
        ]
    },
    {
        "func_name": "is_triad",
        "original": "@nx._dispatch\ndef is_triad(G):\n    \"\"\"Returns True if the graph G is a triad, else False.\n\n    Parameters\n    ----------\n    G : graph\n       A NetworkX Graph\n\n    Returns\n    -------\n    istriad : boolean\n       Whether G is a valid triad\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\n    >>> nx.is_triad(G)\n    True\n    >>> G.add_edge(0, 1)\n    >>> nx.is_triad(G)\n    False\n    \"\"\"\n    if isinstance(G, nx.Graph):\n        if G.order() == 3 and nx.is_directed(G):\n            if not any(((n, n) in G.edges() for n in G.nodes())):\n                return True\n    return False",
        "mutated": [
            "@nx._dispatch\ndef is_triad(G):\n    if False:\n        i = 10\n    'Returns True if the graph G is a triad, else False.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX Graph\\n\\n    Returns\\n    -------\\n    istriad : boolean\\n       Whether G is a valid triad\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.is_triad(G)\\n    True\\n    >>> G.add_edge(0, 1)\\n    >>> nx.is_triad(G)\\n    False\\n    '\n    if isinstance(G, nx.Graph):\n        if G.order() == 3 and nx.is_directed(G):\n            if not any(((n, n) in G.edges() for n in G.nodes())):\n                return True\n    return False",
            "@nx._dispatch\ndef is_triad(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns True if the graph G is a triad, else False.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX Graph\\n\\n    Returns\\n    -------\\n    istriad : boolean\\n       Whether G is a valid triad\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.is_triad(G)\\n    True\\n    >>> G.add_edge(0, 1)\\n    >>> nx.is_triad(G)\\n    False\\n    '\n    if isinstance(G, nx.Graph):\n        if G.order() == 3 and nx.is_directed(G):\n            if not any(((n, n) in G.edges() for n in G.nodes())):\n                return True\n    return False",
            "@nx._dispatch\ndef is_triad(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns True if the graph G is a triad, else False.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX Graph\\n\\n    Returns\\n    -------\\n    istriad : boolean\\n       Whether G is a valid triad\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.is_triad(G)\\n    True\\n    >>> G.add_edge(0, 1)\\n    >>> nx.is_triad(G)\\n    False\\n    '\n    if isinstance(G, nx.Graph):\n        if G.order() == 3 and nx.is_directed(G):\n            if not any(((n, n) in G.edges() for n in G.nodes())):\n                return True\n    return False",
            "@nx._dispatch\ndef is_triad(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns True if the graph G is a triad, else False.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX Graph\\n\\n    Returns\\n    -------\\n    istriad : boolean\\n       Whether G is a valid triad\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.is_triad(G)\\n    True\\n    >>> G.add_edge(0, 1)\\n    >>> nx.is_triad(G)\\n    False\\n    '\n    if isinstance(G, nx.Graph):\n        if G.order() == 3 and nx.is_directed(G):\n            if not any(((n, n) in G.edges() for n in G.nodes())):\n                return True\n    return False",
            "@nx._dispatch\ndef is_triad(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns True if the graph G is a triad, else False.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX Graph\\n\\n    Returns\\n    -------\\n    istriad : boolean\\n       Whether G is a valid triad\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.is_triad(G)\\n    True\\n    >>> G.add_edge(0, 1)\\n    >>> nx.is_triad(G)\\n    False\\n    '\n    if isinstance(G, nx.Graph):\n        if G.order() == 3 and nx.is_directed(G):\n            if not any(((n, n) in G.edges() for n in G.nodes())):\n                return True\n    return False"
        ]
    },
    {
        "func_name": "all_triplets",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triplets(G):\n    \"\"\"Returns a generator of all possible sets of 3 nodes in a DiGraph.\n\n    .. deprecated:: 3.3\n\n       all_triplets is deprecated and will be removed in NetworkX version 3.5.\n       Use `itertools.combinations` instead::\n\n          all_triplets = itertools.combinations(G, 3)\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph\n\n    Returns\n    -------\n    triplets : generator of 3-tuples\n       Generator of tuples of 3 nodes\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\n    >>> list(nx.all_triplets(G))\n    [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\n\n    \"\"\"\n    import warnings\n    warnings.warn('\\n\\nall_triplets is deprecated and will be rmoved in v3.5.\\nUse `itertools.combinations(G, 3)` instead.', category=DeprecationWarning, stacklevel=4)\n    triplets = combinations(G.nodes(), 3)\n    return triplets",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triplets(G):\n    if False:\n        i = 10\n    'Returns a generator of all possible sets of 3 nodes in a DiGraph.\\n\\n    .. deprecated:: 3.3\\n\\n       all_triplets is deprecated and will be removed in NetworkX version 3.5.\\n       Use `itertools.combinations` instead::\\n\\n          all_triplets = itertools.combinations(G, 3)\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    triplets : generator of 3-tuples\\n       Generator of tuples of 3 nodes\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\\n    >>> list(nx.all_triplets(G))\\n    [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nall_triplets is deprecated and will be rmoved in v3.5.\\nUse `itertools.combinations(G, 3)` instead.', category=DeprecationWarning, stacklevel=4)\n    triplets = combinations(G.nodes(), 3)\n    return triplets",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triplets(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a generator of all possible sets of 3 nodes in a DiGraph.\\n\\n    .. deprecated:: 3.3\\n\\n       all_triplets is deprecated and will be removed in NetworkX version 3.5.\\n       Use `itertools.combinations` instead::\\n\\n          all_triplets = itertools.combinations(G, 3)\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    triplets : generator of 3-tuples\\n       Generator of tuples of 3 nodes\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\\n    >>> list(nx.all_triplets(G))\\n    [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nall_triplets is deprecated and will be rmoved in v3.5.\\nUse `itertools.combinations(G, 3)` instead.', category=DeprecationWarning, stacklevel=4)\n    triplets = combinations(G.nodes(), 3)\n    return triplets",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triplets(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a generator of all possible sets of 3 nodes in a DiGraph.\\n\\n    .. deprecated:: 3.3\\n\\n       all_triplets is deprecated and will be removed in NetworkX version 3.5.\\n       Use `itertools.combinations` instead::\\n\\n          all_triplets = itertools.combinations(G, 3)\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    triplets : generator of 3-tuples\\n       Generator of tuples of 3 nodes\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\\n    >>> list(nx.all_triplets(G))\\n    [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nall_triplets is deprecated and will be rmoved in v3.5.\\nUse `itertools.combinations(G, 3)` instead.', category=DeprecationWarning, stacklevel=4)\n    triplets = combinations(G.nodes(), 3)\n    return triplets",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triplets(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a generator of all possible sets of 3 nodes in a DiGraph.\\n\\n    .. deprecated:: 3.3\\n\\n       all_triplets is deprecated and will be removed in NetworkX version 3.5.\\n       Use `itertools.combinations` instead::\\n\\n          all_triplets = itertools.combinations(G, 3)\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    triplets : generator of 3-tuples\\n       Generator of tuples of 3 nodes\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\\n    >>> list(nx.all_triplets(G))\\n    [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nall_triplets is deprecated and will be rmoved in v3.5.\\nUse `itertools.combinations(G, 3)` instead.', category=DeprecationWarning, stacklevel=4)\n    triplets = combinations(G.nodes(), 3)\n    return triplets",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triplets(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a generator of all possible sets of 3 nodes in a DiGraph.\\n\\n    .. deprecated:: 3.3\\n\\n       all_triplets is deprecated and will be removed in NetworkX version 3.5.\\n       Use `itertools.combinations` instead::\\n\\n          all_triplets = itertools.combinations(G, 3)\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    triplets : generator of 3-tuples\\n       Generator of tuples of 3 nodes\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\\n    >>> list(nx.all_triplets(G))\\n    [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nall_triplets is deprecated and will be rmoved in v3.5.\\nUse `itertools.combinations(G, 3)` instead.', category=DeprecationWarning, stacklevel=4)\n    triplets = combinations(G.nodes(), 3)\n    return triplets"
        ]
    },
    {
        "func_name": "all_triads",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triads(G):\n    \"\"\"A generator of all possible triads in G.\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph\n\n    Returns\n    -------\n    all_triads : generator of DiGraphs\n       Generator of triads (order-3 DiGraphs)\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\n    >>> for triad in nx.all_triads(G):\n    ...     print(triad.edges)\n    [(1, 2), (2, 3), (3, 1)]\n    [(1, 2), (4, 1), (4, 2)]\n    [(3, 1), (3, 4), (4, 1)]\n    [(2, 3), (3, 4), (4, 2)]\n\n    \"\"\"\n    triplets = combinations(G.nodes(), 3)\n    for triplet in triplets:\n        yield G.subgraph(triplet).copy()",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triads(G):\n    if False:\n        i = 10\n    'A generator of all possible triads in G.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    all_triads : generator of DiGraphs\\n       Generator of triads (order-3 DiGraphs)\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> for triad in nx.all_triads(G):\\n    ...     print(triad.edges)\\n    [(1, 2), (2, 3), (3, 1)]\\n    [(1, 2), (4, 1), (4, 2)]\\n    [(3, 1), (3, 4), (4, 1)]\\n    [(2, 3), (3, 4), (4, 2)]\\n\\n    '\n    triplets = combinations(G.nodes(), 3)\n    for triplet in triplets:\n        yield G.subgraph(triplet).copy()",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triads(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A generator of all possible triads in G.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    all_triads : generator of DiGraphs\\n       Generator of triads (order-3 DiGraphs)\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> for triad in nx.all_triads(G):\\n    ...     print(triad.edges)\\n    [(1, 2), (2, 3), (3, 1)]\\n    [(1, 2), (4, 1), (4, 2)]\\n    [(3, 1), (3, 4), (4, 1)]\\n    [(2, 3), (3, 4), (4, 2)]\\n\\n    '\n    triplets = combinations(G.nodes(), 3)\n    for triplet in triplets:\n        yield G.subgraph(triplet).copy()",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triads(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A generator of all possible triads in G.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    all_triads : generator of DiGraphs\\n       Generator of triads (order-3 DiGraphs)\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> for triad in nx.all_triads(G):\\n    ...     print(triad.edges)\\n    [(1, 2), (2, 3), (3, 1)]\\n    [(1, 2), (4, 1), (4, 2)]\\n    [(3, 1), (3, 4), (4, 1)]\\n    [(2, 3), (3, 4), (4, 2)]\\n\\n    '\n    triplets = combinations(G.nodes(), 3)\n    for triplet in triplets:\n        yield G.subgraph(triplet).copy()",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triads(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A generator of all possible triads in G.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    all_triads : generator of DiGraphs\\n       Generator of triads (order-3 DiGraphs)\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> for triad in nx.all_triads(G):\\n    ...     print(triad.edges)\\n    [(1, 2), (2, 3), (3, 1)]\\n    [(1, 2), (4, 1), (4, 2)]\\n    [(3, 1), (3, 4), (4, 1)]\\n    [(2, 3), (3, 4), (4, 2)]\\n\\n    '\n    triplets = combinations(G.nodes(), 3)\n    for triplet in triplets:\n        yield G.subgraph(triplet).copy()",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef all_triads(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A generator of all possible triads in G.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    all_triads : generator of DiGraphs\\n       Generator of triads (order-3 DiGraphs)\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\\n    >>> for triad in nx.all_triads(G):\\n    ...     print(triad.edges)\\n    [(1, 2), (2, 3), (3, 1)]\\n    [(1, 2), (4, 1), (4, 2)]\\n    [(3, 1), (3, 4), (4, 1)]\\n    [(2, 3), (3, 4), (4, 2)]\\n\\n    '\n    triplets = combinations(G.nodes(), 3)\n    for triplet in triplets:\n        yield G.subgraph(triplet).copy()"
        ]
    },
    {
        "func_name": "triads_by_type",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef triads_by_type(G):\n    \"\"\"Returns a list of all triads for each triad type in a directed graph.\n    There are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\n    nodes, they will be classified as a particular triad type if their connections\n    are as follows:\n\n    - 003: 1, 2, 3\n    - 012: 1 -> 2, 3\n    - 102: 1 <-> 2, 3\n    - 021D: 1 <- 2 -> 3\n    - 021U: 1 -> 2 <- 3\n    - 021C: 1 -> 2 -> 3\n    - 111D: 1 <-> 2 <- 3\n    - 111U: 1 <-> 2 -> 3\n    - 030T: 1 -> 2 -> 3, 1 -> 3\n    - 030C: 1 <- 2 <- 3, 1 -> 3\n    - 201: 1 <-> 2 <-> 3\n    - 120D: 1 <- 2 -> 3, 1 <-> 3\n    - 120U: 1 -> 2 <- 3, 1 <-> 3\n    - 120C: 1 -> 2 -> 3, 1 <-> 3\n    - 210: 1 -> 2 <-> 3, 1 <-> 3\n    - 300: 1 <-> 2 <-> 3, 1 <-> 3\n\n    Refer to the :doc:`example gallery </auto_examples/graph/plot_triad_types>`\n    for visual examples of the triad types.\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph\n\n    Returns\n    -------\n    tri_by_type : dict\n       Dictionary with triad types as keys and lists of triads as values.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\n    >>> dict = nx.triads_by_type(G)\n    >>> dict['120C'][0].edges()\n    OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\n    >>> dict['012'][0].edges()\n    OutEdgeView([(1, 2)])\n\n    References\n    ----------\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\n        Oxford.\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\n    \"\"\"\n    all_tri = all_triads(G)\n    tri_by_type = defaultdict(list)\n    for triad in all_tri:\n        name = triad_type(triad)\n        tri_by_type[name].append(triad)\n    return tri_by_type",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triads_by_type(G):\n    if False:\n        i = 10\n    'Returns a list of all triads for each triad type in a directed graph.\\n    There are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\\n    nodes, they will be classified as a particular triad type if their connections\\n    are as follows:\\n\\n    - 003: 1, 2, 3\\n    - 012: 1 -> 2, 3\\n    - 102: 1 <-> 2, 3\\n    - 021D: 1 <- 2 -> 3\\n    - 021U: 1 -> 2 <- 3\\n    - 021C: 1 -> 2 -> 3\\n    - 111D: 1 <-> 2 <- 3\\n    - 111U: 1 <-> 2 -> 3\\n    - 030T: 1 -> 2 -> 3, 1 -> 3\\n    - 030C: 1 <- 2 <- 3, 1 -> 3\\n    - 201: 1 <-> 2 <-> 3\\n    - 120D: 1 <- 2 -> 3, 1 <-> 3\\n    - 120U: 1 -> 2 <- 3, 1 <-> 3\\n    - 120C: 1 -> 2 -> 3, 1 <-> 3\\n    - 210: 1 -> 2 <-> 3, 1 <-> 3\\n    - 300: 1 <-> 2 <-> 3, 1 <-> 3\\n\\n    Refer to the :doc:`example gallery </auto_examples/graph/plot_triad_types>`\\n    for visual examples of the triad types.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    tri_by_type : dict\\n       Dictionary with triad types as keys and lists of triads as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> dict = nx.triads_by_type(G)\\n    >>> dict[\\'120C\\'][0].edges()\\n    OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\\n    >>> dict[\\'012\\'][0].edges()\\n    OutEdgeView([(1, 2)])\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    all_tri = all_triads(G)\n    tri_by_type = defaultdict(list)\n    for triad in all_tri:\n        name = triad_type(triad)\n        tri_by_type[name].append(triad)\n    return tri_by_type",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triads_by_type(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a list of all triads for each triad type in a directed graph.\\n    There are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\\n    nodes, they will be classified as a particular triad type if their connections\\n    are as follows:\\n\\n    - 003: 1, 2, 3\\n    - 012: 1 -> 2, 3\\n    - 102: 1 <-> 2, 3\\n    - 021D: 1 <- 2 -> 3\\n    - 021U: 1 -> 2 <- 3\\n    - 021C: 1 -> 2 -> 3\\n    - 111D: 1 <-> 2 <- 3\\n    - 111U: 1 <-> 2 -> 3\\n    - 030T: 1 -> 2 -> 3, 1 -> 3\\n    - 030C: 1 <- 2 <- 3, 1 -> 3\\n    - 201: 1 <-> 2 <-> 3\\n    - 120D: 1 <- 2 -> 3, 1 <-> 3\\n    - 120U: 1 -> 2 <- 3, 1 <-> 3\\n    - 120C: 1 -> 2 -> 3, 1 <-> 3\\n    - 210: 1 -> 2 <-> 3, 1 <-> 3\\n    - 300: 1 <-> 2 <-> 3, 1 <-> 3\\n\\n    Refer to the :doc:`example gallery </auto_examples/graph/plot_triad_types>`\\n    for visual examples of the triad types.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    tri_by_type : dict\\n       Dictionary with triad types as keys and lists of triads as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> dict = nx.triads_by_type(G)\\n    >>> dict[\\'120C\\'][0].edges()\\n    OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\\n    >>> dict[\\'012\\'][0].edges()\\n    OutEdgeView([(1, 2)])\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    all_tri = all_triads(G)\n    tri_by_type = defaultdict(list)\n    for triad in all_tri:\n        name = triad_type(triad)\n        tri_by_type[name].append(triad)\n    return tri_by_type",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triads_by_type(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a list of all triads for each triad type in a directed graph.\\n    There are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\\n    nodes, they will be classified as a particular triad type if their connections\\n    are as follows:\\n\\n    - 003: 1, 2, 3\\n    - 012: 1 -> 2, 3\\n    - 102: 1 <-> 2, 3\\n    - 021D: 1 <- 2 -> 3\\n    - 021U: 1 -> 2 <- 3\\n    - 021C: 1 -> 2 -> 3\\n    - 111D: 1 <-> 2 <- 3\\n    - 111U: 1 <-> 2 -> 3\\n    - 030T: 1 -> 2 -> 3, 1 -> 3\\n    - 030C: 1 <- 2 <- 3, 1 -> 3\\n    - 201: 1 <-> 2 <-> 3\\n    - 120D: 1 <- 2 -> 3, 1 <-> 3\\n    - 120U: 1 -> 2 <- 3, 1 <-> 3\\n    - 120C: 1 -> 2 -> 3, 1 <-> 3\\n    - 210: 1 -> 2 <-> 3, 1 <-> 3\\n    - 300: 1 <-> 2 <-> 3, 1 <-> 3\\n\\n    Refer to the :doc:`example gallery </auto_examples/graph/plot_triad_types>`\\n    for visual examples of the triad types.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    tri_by_type : dict\\n       Dictionary with triad types as keys and lists of triads as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> dict = nx.triads_by_type(G)\\n    >>> dict[\\'120C\\'][0].edges()\\n    OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\\n    >>> dict[\\'012\\'][0].edges()\\n    OutEdgeView([(1, 2)])\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    all_tri = all_triads(G)\n    tri_by_type = defaultdict(list)\n    for triad in all_tri:\n        name = triad_type(triad)\n        tri_by_type[name].append(triad)\n    return tri_by_type",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triads_by_type(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a list of all triads for each triad type in a directed graph.\\n    There are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\\n    nodes, they will be classified as a particular triad type if their connections\\n    are as follows:\\n\\n    - 003: 1, 2, 3\\n    - 012: 1 -> 2, 3\\n    - 102: 1 <-> 2, 3\\n    - 021D: 1 <- 2 -> 3\\n    - 021U: 1 -> 2 <- 3\\n    - 021C: 1 -> 2 -> 3\\n    - 111D: 1 <-> 2 <- 3\\n    - 111U: 1 <-> 2 -> 3\\n    - 030T: 1 -> 2 -> 3, 1 -> 3\\n    - 030C: 1 <- 2 <- 3, 1 -> 3\\n    - 201: 1 <-> 2 <-> 3\\n    - 120D: 1 <- 2 -> 3, 1 <-> 3\\n    - 120U: 1 -> 2 <- 3, 1 <-> 3\\n    - 120C: 1 -> 2 -> 3, 1 <-> 3\\n    - 210: 1 -> 2 <-> 3, 1 <-> 3\\n    - 300: 1 <-> 2 <-> 3, 1 <-> 3\\n\\n    Refer to the :doc:`example gallery </auto_examples/graph/plot_triad_types>`\\n    for visual examples of the triad types.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    tri_by_type : dict\\n       Dictionary with triad types as keys and lists of triads as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> dict = nx.triads_by_type(G)\\n    >>> dict[\\'120C\\'][0].edges()\\n    OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\\n    >>> dict[\\'012\\'][0].edges()\\n    OutEdgeView([(1, 2)])\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    all_tri = all_triads(G)\n    tri_by_type = defaultdict(list)\n    for triad in all_tri:\n        name = triad_type(triad)\n        tri_by_type[name].append(triad)\n    return tri_by_type",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triads_by_type(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a list of all triads for each triad type in a directed graph.\\n    There are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\\n    nodes, they will be classified as a particular triad type if their connections\\n    are as follows:\\n\\n    - 003: 1, 2, 3\\n    - 012: 1 -> 2, 3\\n    - 102: 1 <-> 2, 3\\n    - 021D: 1 <- 2 -> 3\\n    - 021U: 1 -> 2 <- 3\\n    - 021C: 1 -> 2 -> 3\\n    - 111D: 1 <-> 2 <- 3\\n    - 111U: 1 <-> 2 -> 3\\n    - 030T: 1 -> 2 -> 3, 1 -> 3\\n    - 030C: 1 <- 2 <- 3, 1 -> 3\\n    - 201: 1 <-> 2 <-> 3\\n    - 120D: 1 <- 2 -> 3, 1 <-> 3\\n    - 120U: 1 -> 2 <- 3, 1 <-> 3\\n    - 120C: 1 -> 2 -> 3, 1 <-> 3\\n    - 210: 1 -> 2 <-> 3, 1 <-> 3\\n    - 300: 1 <-> 2 <-> 3, 1 <-> 3\\n\\n    Refer to the :doc:`example gallery </auto_examples/graph/plot_triad_types>`\\n    for visual examples of the triad types.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n\\n    Returns\\n    -------\\n    tri_by_type : dict\\n       Dictionary with triad types as keys and lists of triads as values.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> dict = nx.triads_by_type(G)\\n    >>> dict[\\'120C\\'][0].edges()\\n    OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\\n    >>> dict[\\'012\\'][0].edges()\\n    OutEdgeView([(1, 2)])\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    all_tri = all_triads(G)\n    tri_by_type = defaultdict(list)\n    for triad in all_tri:\n        name = triad_type(triad)\n        tri_by_type[name].append(triad)\n    return tri_by_type"
        ]
    },
    {
        "func_name": "triad_type",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef triad_type(G):\n    \"\"\"Returns the sociological triad type for a triad.\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph with 3 nodes\n\n    Returns\n    -------\n    triad_type : str\n       A string identifying the triad type\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\n    >>> nx.triad_type(G)\n    '030C'\n    >>> G.add_edge(1, 3)\n    >>> nx.triad_type(G)\n    '120C'\n\n    Notes\n    -----\n    There can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\n    triads given 3 nodes). These 64 triads each display exactly 1 of 16\n    topologies of triads (topologies can be permuted). These topologies are\n    identified by the following notation:\n\n    {m}{a}{n}{type} (for example: 111D, 210, 102)\n\n    Here:\n\n    {m}     = number of mutual ties (takes 0, 1, 2, 3); a mutual tie is (0,1)\n              AND (1,0)\n    {a}     = number of asymmetric ties (takes 0, 1, 2, 3); an asymmetric tie\n              is (0,1) BUT NOT (1,0) or vice versa\n    {n}     = number of null ties (takes 0, 1, 2, 3); a null tie is NEITHER\n              (0,1) NOR (1,0)\n    {type}  = a letter (takes U, D, C, T) corresponding to up, down, cyclical\n              and transitive. This is only used for topologies that can have\n              more than one form (eg: 021D and 021U).\n\n    References\n    ----------\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\n        Oxford.\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\n    \"\"\"\n    if not is_triad(G):\n        raise nx.NetworkXAlgorithmError('G is not a triad (order-3 DiGraph)')\n    num_edges = len(G.edges())\n    if num_edges == 0:\n        return '003'\n    elif num_edges == 1:\n        return '012'\n    elif num_edges == 2:\n        (e1, e2) = G.edges()\n        if set(e1) == set(e2):\n            return '102'\n        elif e1[0] == e2[0]:\n            return '021D'\n        elif e1[1] == e2[1]:\n            return '021U'\n        elif e1[1] == e2[0] or e2[1] == e1[0]:\n            return '021C'\n    elif num_edges == 3:\n        for (e1, e2, e3) in permutations(G.edges(), 3):\n            if set(e1) == set(e2):\n                if e3[0] in e1:\n                    return '111U'\n                return '111D'\n            elif set(e1).symmetric_difference(set(e2)) == set(e3):\n                if {e1[0], e2[0], e3[0]} == {e1[0], e2[0], e3[0]} == set(G.nodes()):\n                    return '030C'\n                return '030T'\n    elif num_edges == 4:\n        for (e1, e2, e3, e4) in permutations(G.edges(), 4):\n            if set(e1) == set(e2):\n                if set(e3) == set(e4):\n                    return '201'\n                if {e3[0]} == {e4[0]} == set(e3).intersection(set(e4)):\n                    return '120D'\n                if {e3[1]} == {e4[1]} == set(e3).intersection(set(e4)):\n                    return '120U'\n                if e3[1] == e4[0]:\n                    return '120C'\n    elif num_edges == 5:\n        return '210'\n    elif num_edges == 6:\n        return '300'",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triad_type(G):\n    if False:\n        i = 10\n    'Returns the sociological triad type for a triad.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph with 3 nodes\\n\\n    Returns\\n    -------\\n    triad_type : str\\n       A string identifying the triad type\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.triad_type(G)\\n    \\'030C\\'\\n    >>> G.add_edge(1, 3)\\n    >>> nx.triad_type(G)\\n    \\'120C\\'\\n\\n    Notes\\n    -----\\n    There can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\\n    triads given 3 nodes). These 64 triads each display exactly 1 of 16\\n    topologies of triads (topologies can be permuted). These topologies are\\n    identified by the following notation:\\n\\n    {m}{a}{n}{type} (for example: 111D, 210, 102)\\n\\n    Here:\\n\\n    {m}     = number of mutual ties (takes 0, 1, 2, 3); a mutual tie is (0,1)\\n              AND (1,0)\\n    {a}     = number of asymmetric ties (takes 0, 1, 2, 3); an asymmetric tie\\n              is (0,1) BUT NOT (1,0) or vice versa\\n    {n}     = number of null ties (takes 0, 1, 2, 3); a null tie is NEITHER\\n              (0,1) NOR (1,0)\\n    {type}  = a letter (takes U, D, C, T) corresponding to up, down, cyclical\\n              and transitive. This is only used for topologies that can have\\n              more than one form (eg: 021D and 021U).\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    if not is_triad(G):\n        raise nx.NetworkXAlgorithmError('G is not a triad (order-3 DiGraph)')\n    num_edges = len(G.edges())\n    if num_edges == 0:\n        return '003'\n    elif num_edges == 1:\n        return '012'\n    elif num_edges == 2:\n        (e1, e2) = G.edges()\n        if set(e1) == set(e2):\n            return '102'\n        elif e1[0] == e2[0]:\n            return '021D'\n        elif e1[1] == e2[1]:\n            return '021U'\n        elif e1[1] == e2[0] or e2[1] == e1[0]:\n            return '021C'\n    elif num_edges == 3:\n        for (e1, e2, e3) in permutations(G.edges(), 3):\n            if set(e1) == set(e2):\n                if e3[0] in e1:\n                    return '111U'\n                return '111D'\n            elif set(e1).symmetric_difference(set(e2)) == set(e3):\n                if {e1[0], e2[0], e3[0]} == {e1[0], e2[0], e3[0]} == set(G.nodes()):\n                    return '030C'\n                return '030T'\n    elif num_edges == 4:\n        for (e1, e2, e3, e4) in permutations(G.edges(), 4):\n            if set(e1) == set(e2):\n                if set(e3) == set(e4):\n                    return '201'\n                if {e3[0]} == {e4[0]} == set(e3).intersection(set(e4)):\n                    return '120D'\n                if {e3[1]} == {e4[1]} == set(e3).intersection(set(e4)):\n                    return '120U'\n                if e3[1] == e4[0]:\n                    return '120C'\n    elif num_edges == 5:\n        return '210'\n    elif num_edges == 6:\n        return '300'",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triad_type(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the sociological triad type for a triad.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph with 3 nodes\\n\\n    Returns\\n    -------\\n    triad_type : str\\n       A string identifying the triad type\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.triad_type(G)\\n    \\'030C\\'\\n    >>> G.add_edge(1, 3)\\n    >>> nx.triad_type(G)\\n    \\'120C\\'\\n\\n    Notes\\n    -----\\n    There can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\\n    triads given 3 nodes). These 64 triads each display exactly 1 of 16\\n    topologies of triads (topologies can be permuted). These topologies are\\n    identified by the following notation:\\n\\n    {m}{a}{n}{type} (for example: 111D, 210, 102)\\n\\n    Here:\\n\\n    {m}     = number of mutual ties (takes 0, 1, 2, 3); a mutual tie is (0,1)\\n              AND (1,0)\\n    {a}     = number of asymmetric ties (takes 0, 1, 2, 3); an asymmetric tie\\n              is (0,1) BUT NOT (1,0) or vice versa\\n    {n}     = number of null ties (takes 0, 1, 2, 3); a null tie is NEITHER\\n              (0,1) NOR (1,0)\\n    {type}  = a letter (takes U, D, C, T) corresponding to up, down, cyclical\\n              and transitive. This is only used for topologies that can have\\n              more than one form (eg: 021D and 021U).\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    if not is_triad(G):\n        raise nx.NetworkXAlgorithmError('G is not a triad (order-3 DiGraph)')\n    num_edges = len(G.edges())\n    if num_edges == 0:\n        return '003'\n    elif num_edges == 1:\n        return '012'\n    elif num_edges == 2:\n        (e1, e2) = G.edges()\n        if set(e1) == set(e2):\n            return '102'\n        elif e1[0] == e2[0]:\n            return '021D'\n        elif e1[1] == e2[1]:\n            return '021U'\n        elif e1[1] == e2[0] or e2[1] == e1[0]:\n            return '021C'\n    elif num_edges == 3:\n        for (e1, e2, e3) in permutations(G.edges(), 3):\n            if set(e1) == set(e2):\n                if e3[0] in e1:\n                    return '111U'\n                return '111D'\n            elif set(e1).symmetric_difference(set(e2)) == set(e3):\n                if {e1[0], e2[0], e3[0]} == {e1[0], e2[0], e3[0]} == set(G.nodes()):\n                    return '030C'\n                return '030T'\n    elif num_edges == 4:\n        for (e1, e2, e3, e4) in permutations(G.edges(), 4):\n            if set(e1) == set(e2):\n                if set(e3) == set(e4):\n                    return '201'\n                if {e3[0]} == {e4[0]} == set(e3).intersection(set(e4)):\n                    return '120D'\n                if {e3[1]} == {e4[1]} == set(e3).intersection(set(e4)):\n                    return '120U'\n                if e3[1] == e4[0]:\n                    return '120C'\n    elif num_edges == 5:\n        return '210'\n    elif num_edges == 6:\n        return '300'",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triad_type(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the sociological triad type for a triad.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph with 3 nodes\\n\\n    Returns\\n    -------\\n    triad_type : str\\n       A string identifying the triad type\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.triad_type(G)\\n    \\'030C\\'\\n    >>> G.add_edge(1, 3)\\n    >>> nx.triad_type(G)\\n    \\'120C\\'\\n\\n    Notes\\n    -----\\n    There can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\\n    triads given 3 nodes). These 64 triads each display exactly 1 of 16\\n    topologies of triads (topologies can be permuted). These topologies are\\n    identified by the following notation:\\n\\n    {m}{a}{n}{type} (for example: 111D, 210, 102)\\n\\n    Here:\\n\\n    {m}     = number of mutual ties (takes 0, 1, 2, 3); a mutual tie is (0,1)\\n              AND (1,0)\\n    {a}     = number of asymmetric ties (takes 0, 1, 2, 3); an asymmetric tie\\n              is (0,1) BUT NOT (1,0) or vice versa\\n    {n}     = number of null ties (takes 0, 1, 2, 3); a null tie is NEITHER\\n              (0,1) NOR (1,0)\\n    {type}  = a letter (takes U, D, C, T) corresponding to up, down, cyclical\\n              and transitive. This is only used for topologies that can have\\n              more than one form (eg: 021D and 021U).\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    if not is_triad(G):\n        raise nx.NetworkXAlgorithmError('G is not a triad (order-3 DiGraph)')\n    num_edges = len(G.edges())\n    if num_edges == 0:\n        return '003'\n    elif num_edges == 1:\n        return '012'\n    elif num_edges == 2:\n        (e1, e2) = G.edges()\n        if set(e1) == set(e2):\n            return '102'\n        elif e1[0] == e2[0]:\n            return '021D'\n        elif e1[1] == e2[1]:\n            return '021U'\n        elif e1[1] == e2[0] or e2[1] == e1[0]:\n            return '021C'\n    elif num_edges == 3:\n        for (e1, e2, e3) in permutations(G.edges(), 3):\n            if set(e1) == set(e2):\n                if e3[0] in e1:\n                    return '111U'\n                return '111D'\n            elif set(e1).symmetric_difference(set(e2)) == set(e3):\n                if {e1[0], e2[0], e3[0]} == {e1[0], e2[0], e3[0]} == set(G.nodes()):\n                    return '030C'\n                return '030T'\n    elif num_edges == 4:\n        for (e1, e2, e3, e4) in permutations(G.edges(), 4):\n            if set(e1) == set(e2):\n                if set(e3) == set(e4):\n                    return '201'\n                if {e3[0]} == {e4[0]} == set(e3).intersection(set(e4)):\n                    return '120D'\n                if {e3[1]} == {e4[1]} == set(e3).intersection(set(e4)):\n                    return '120U'\n                if e3[1] == e4[0]:\n                    return '120C'\n    elif num_edges == 5:\n        return '210'\n    elif num_edges == 6:\n        return '300'",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triad_type(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the sociological triad type for a triad.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph with 3 nodes\\n\\n    Returns\\n    -------\\n    triad_type : str\\n       A string identifying the triad type\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.triad_type(G)\\n    \\'030C\\'\\n    >>> G.add_edge(1, 3)\\n    >>> nx.triad_type(G)\\n    \\'120C\\'\\n\\n    Notes\\n    -----\\n    There can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\\n    triads given 3 nodes). These 64 triads each display exactly 1 of 16\\n    topologies of triads (topologies can be permuted). These topologies are\\n    identified by the following notation:\\n\\n    {m}{a}{n}{type} (for example: 111D, 210, 102)\\n\\n    Here:\\n\\n    {m}     = number of mutual ties (takes 0, 1, 2, 3); a mutual tie is (0,1)\\n              AND (1,0)\\n    {a}     = number of asymmetric ties (takes 0, 1, 2, 3); an asymmetric tie\\n              is (0,1) BUT NOT (1,0) or vice versa\\n    {n}     = number of null ties (takes 0, 1, 2, 3); a null tie is NEITHER\\n              (0,1) NOR (1,0)\\n    {type}  = a letter (takes U, D, C, T) corresponding to up, down, cyclical\\n              and transitive. This is only used for topologies that can have\\n              more than one form (eg: 021D and 021U).\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    if not is_triad(G):\n        raise nx.NetworkXAlgorithmError('G is not a triad (order-3 DiGraph)')\n    num_edges = len(G.edges())\n    if num_edges == 0:\n        return '003'\n    elif num_edges == 1:\n        return '012'\n    elif num_edges == 2:\n        (e1, e2) = G.edges()\n        if set(e1) == set(e2):\n            return '102'\n        elif e1[0] == e2[0]:\n            return '021D'\n        elif e1[1] == e2[1]:\n            return '021U'\n        elif e1[1] == e2[0] or e2[1] == e1[0]:\n            return '021C'\n    elif num_edges == 3:\n        for (e1, e2, e3) in permutations(G.edges(), 3):\n            if set(e1) == set(e2):\n                if e3[0] in e1:\n                    return '111U'\n                return '111D'\n            elif set(e1).symmetric_difference(set(e2)) == set(e3):\n                if {e1[0], e2[0], e3[0]} == {e1[0], e2[0], e3[0]} == set(G.nodes()):\n                    return '030C'\n                return '030T'\n    elif num_edges == 4:\n        for (e1, e2, e3, e4) in permutations(G.edges(), 4):\n            if set(e1) == set(e2):\n                if set(e3) == set(e4):\n                    return '201'\n                if {e3[0]} == {e4[0]} == set(e3).intersection(set(e4)):\n                    return '120D'\n                if {e3[1]} == {e4[1]} == set(e3).intersection(set(e4)):\n                    return '120U'\n                if e3[1] == e4[0]:\n                    return '120C'\n    elif num_edges == 5:\n        return '210'\n    elif num_edges == 6:\n        return '300'",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef triad_type(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the sociological triad type for a triad.\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph with 3 nodes\\n\\n    Returns\\n    -------\\n    triad_type : str\\n       A string identifying the triad type\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\\n    >>> nx.triad_type(G)\\n    \\'030C\\'\\n    >>> G.add_edge(1, 3)\\n    >>> nx.triad_type(G)\\n    \\'120C\\'\\n\\n    Notes\\n    -----\\n    There can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\\n    triads given 3 nodes). These 64 triads each display exactly 1 of 16\\n    topologies of triads (topologies can be permuted). These topologies are\\n    identified by the following notation:\\n\\n    {m}{a}{n}{type} (for example: 111D, 210, 102)\\n\\n    Here:\\n\\n    {m}     = number of mutual ties (takes 0, 1, 2, 3); a mutual tie is (0,1)\\n              AND (1,0)\\n    {a}     = number of asymmetric ties (takes 0, 1, 2, 3); an asymmetric tie\\n              is (0,1) BUT NOT (1,0) or vice versa\\n    {n}     = number of null ties (takes 0, 1, 2, 3); a null tie is NEITHER\\n              (0,1) NOR (1,0)\\n    {type}  = a letter (takes U, D, C, T) corresponding to up, down, cyclical\\n              and transitive. This is only used for topologies that can have\\n              more than one form (eg: 021D and 021U).\\n\\n    References\\n    ----------\\n    .. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\\n        Oxford.\\n        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf\\n    '\n    if not is_triad(G):\n        raise nx.NetworkXAlgorithmError('G is not a triad (order-3 DiGraph)')\n    num_edges = len(G.edges())\n    if num_edges == 0:\n        return '003'\n    elif num_edges == 1:\n        return '012'\n    elif num_edges == 2:\n        (e1, e2) = G.edges()\n        if set(e1) == set(e2):\n            return '102'\n        elif e1[0] == e2[0]:\n            return '021D'\n        elif e1[1] == e2[1]:\n            return '021U'\n        elif e1[1] == e2[0] or e2[1] == e1[0]:\n            return '021C'\n    elif num_edges == 3:\n        for (e1, e2, e3) in permutations(G.edges(), 3):\n            if set(e1) == set(e2):\n                if e3[0] in e1:\n                    return '111U'\n                return '111D'\n            elif set(e1).symmetric_difference(set(e2)) == set(e3):\n                if {e1[0], e2[0], e3[0]} == {e1[0], e2[0], e3[0]} == set(G.nodes()):\n                    return '030C'\n                return '030T'\n    elif num_edges == 4:\n        for (e1, e2, e3, e4) in permutations(G.edges(), 4):\n            if set(e1) == set(e2):\n                if set(e3) == set(e4):\n                    return '201'\n                if {e3[0]} == {e4[0]} == set(e3).intersection(set(e4)):\n                    return '120D'\n                if {e3[1]} == {e4[1]} == set(e3).intersection(set(e4)):\n                    return '120U'\n                if e3[1] == e4[0]:\n                    return '120C'\n    elif num_edges == 5:\n        return '210'\n    elif num_edges == 6:\n        return '300'"
        ]
    },
    {
        "func_name": "random_triad",
        "original": "@not_implemented_for('undirected')\n@py_random_state(1)\n@nx._dispatch\ndef random_triad(G, seed=None):\n    \"\"\"Returns a random triad from a directed graph.\n\n    .. deprecated:: 3.3\n\n       random_triad is deprecated and will be removed in version 3.5.\n       Use random sampling directly instead::\n\n          G.subgraph(random.sample(list(G), 3))\n\n    Parameters\n    ----------\n    G : digraph\n       A NetworkX DiGraph\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G2 : subgraph\n       A randomly selected triad (order-3 NetworkX DiGraph)\n\n    Raises\n    ------\n    NetworkXError\n        If the input Graph has less than 3 nodes.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\n    >>> triad = nx.random_triad(G, seed=1)\n    >>> triad.edges\n    OutEdgeView([(1, 2)])\n\n    \"\"\"\n    import warnings\n    warnings.warn('\\n\\nrandom_triad is deprecated and will be removed in NetworkX v3.5.\\nUse random.sample instead, e.g.::\\n\\n\\tG.subgraph(random.sample(list(G), 3))\\n', category=DeprecationWarning, stacklevel=5)\n    if len(G) < 3:\n        raise nx.NetworkXError(f'G needs at least 3 nodes to form a triad; (it has {len(G)} nodes)')\n    nodes = seed.sample(list(G.nodes()), 3)\n    G2 = G.subgraph(nodes)\n    return G2",
        "mutated": [
            "@not_implemented_for('undirected')\n@py_random_state(1)\n@nx._dispatch\ndef random_triad(G, seed=None):\n    if False:\n        i = 10\n    'Returns a random triad from a directed graph.\\n\\n    .. deprecated:: 3.3\\n\\n       random_triad is deprecated and will be removed in version 3.5.\\n       Use random sampling directly instead::\\n\\n          G.subgraph(random.sample(list(G), 3))\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G2 : subgraph\\n       A randomly selected triad (order-3 NetworkX DiGraph)\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the input Graph has less than 3 nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> triad = nx.random_triad(G, seed=1)\\n    >>> triad.edges\\n    OutEdgeView([(1, 2)])\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nrandom_triad is deprecated and will be removed in NetworkX v3.5.\\nUse random.sample instead, e.g.::\\n\\n\\tG.subgraph(random.sample(list(G), 3))\\n', category=DeprecationWarning, stacklevel=5)\n    if len(G) < 3:\n        raise nx.NetworkXError(f'G needs at least 3 nodes to form a triad; (it has {len(G)} nodes)')\n    nodes = seed.sample(list(G.nodes()), 3)\n    G2 = G.subgraph(nodes)\n    return G2",
            "@not_implemented_for('undirected')\n@py_random_state(1)\n@nx._dispatch\ndef random_triad(G, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a random triad from a directed graph.\\n\\n    .. deprecated:: 3.3\\n\\n       random_triad is deprecated and will be removed in version 3.5.\\n       Use random sampling directly instead::\\n\\n          G.subgraph(random.sample(list(G), 3))\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G2 : subgraph\\n       A randomly selected triad (order-3 NetworkX DiGraph)\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the input Graph has less than 3 nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> triad = nx.random_triad(G, seed=1)\\n    >>> triad.edges\\n    OutEdgeView([(1, 2)])\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nrandom_triad is deprecated and will be removed in NetworkX v3.5.\\nUse random.sample instead, e.g.::\\n\\n\\tG.subgraph(random.sample(list(G), 3))\\n', category=DeprecationWarning, stacklevel=5)\n    if len(G) < 3:\n        raise nx.NetworkXError(f'G needs at least 3 nodes to form a triad; (it has {len(G)} nodes)')\n    nodes = seed.sample(list(G.nodes()), 3)\n    G2 = G.subgraph(nodes)\n    return G2",
            "@not_implemented_for('undirected')\n@py_random_state(1)\n@nx._dispatch\ndef random_triad(G, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a random triad from a directed graph.\\n\\n    .. deprecated:: 3.3\\n\\n       random_triad is deprecated and will be removed in version 3.5.\\n       Use random sampling directly instead::\\n\\n          G.subgraph(random.sample(list(G), 3))\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G2 : subgraph\\n       A randomly selected triad (order-3 NetworkX DiGraph)\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the input Graph has less than 3 nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> triad = nx.random_triad(G, seed=1)\\n    >>> triad.edges\\n    OutEdgeView([(1, 2)])\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nrandom_triad is deprecated and will be removed in NetworkX v3.5.\\nUse random.sample instead, e.g.::\\n\\n\\tG.subgraph(random.sample(list(G), 3))\\n', category=DeprecationWarning, stacklevel=5)\n    if len(G) < 3:\n        raise nx.NetworkXError(f'G needs at least 3 nodes to form a triad; (it has {len(G)} nodes)')\n    nodes = seed.sample(list(G.nodes()), 3)\n    G2 = G.subgraph(nodes)\n    return G2",
            "@not_implemented_for('undirected')\n@py_random_state(1)\n@nx._dispatch\ndef random_triad(G, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a random triad from a directed graph.\\n\\n    .. deprecated:: 3.3\\n\\n       random_triad is deprecated and will be removed in version 3.5.\\n       Use random sampling directly instead::\\n\\n          G.subgraph(random.sample(list(G), 3))\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G2 : subgraph\\n       A randomly selected triad (order-3 NetworkX DiGraph)\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the input Graph has less than 3 nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> triad = nx.random_triad(G, seed=1)\\n    >>> triad.edges\\n    OutEdgeView([(1, 2)])\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nrandom_triad is deprecated and will be removed in NetworkX v3.5.\\nUse random.sample instead, e.g.::\\n\\n\\tG.subgraph(random.sample(list(G), 3))\\n', category=DeprecationWarning, stacklevel=5)\n    if len(G) < 3:\n        raise nx.NetworkXError(f'G needs at least 3 nodes to form a triad; (it has {len(G)} nodes)')\n    nodes = seed.sample(list(G.nodes()), 3)\n    G2 = G.subgraph(nodes)\n    return G2",
            "@not_implemented_for('undirected')\n@py_random_state(1)\n@nx._dispatch\ndef random_triad(G, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a random triad from a directed graph.\\n\\n    .. deprecated:: 3.3\\n\\n       random_triad is deprecated and will be removed in version 3.5.\\n       Use random sampling directly instead::\\n\\n          G.subgraph(random.sample(list(G), 3))\\n\\n    Parameters\\n    ----------\\n    G : digraph\\n       A NetworkX DiGraph\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G2 : subgraph\\n       A randomly selected triad (order-3 NetworkX DiGraph)\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the input Graph has less than 3 nodes.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\\n    >>> triad = nx.random_triad(G, seed=1)\\n    >>> triad.edges\\n    OutEdgeView([(1, 2)])\\n\\n    '\n    import warnings\n    warnings.warn('\\n\\nrandom_triad is deprecated and will be removed in NetworkX v3.5.\\nUse random.sample instead, e.g.::\\n\\n\\tG.subgraph(random.sample(list(G), 3))\\n', category=DeprecationWarning, stacklevel=5)\n    if len(G) < 3:\n        raise nx.NetworkXError(f'G needs at least 3 nodes to form a triad; (it has {len(G)} nodes)')\n    nodes = seed.sample(list(G.nodes()), 3)\n    G2 = G.subgraph(nodes)\n    return G2"
        ]
    }
]