[
    {
        "func_name": "_pre",
        "original": "def _pre():\n    maxn = 10 ** 5\n    global _factor\n    global _totient\n    _factor = [0] * maxn\n    _totient = [1] * maxn\n    lim = int(maxn ** 0.5) + 5\n    for i in range(2, lim):\n        if _factor[i] == 0:\n            for j in range(i * i, maxn, i):\n                if _factor[j] == 0:\n                    _factor[j] = i\n    for i in range(2, maxn):\n        if _factor[i] == 0:\n            _factor[i] = i\n            _totient[i] = i - 1\n            continue\n        x = _factor[i]\n        y = i // x\n        if y % x == 0:\n            _totient[i] = _totient[y] * x\n        else:\n            _totient[i] = _totient[y] * (x - 1)",
        "mutated": [
            "def _pre():\n    if False:\n        i = 10\n    maxn = 10 ** 5\n    global _factor\n    global _totient\n    _factor = [0] * maxn\n    _totient = [1] * maxn\n    lim = int(maxn ** 0.5) + 5\n    for i in range(2, lim):\n        if _factor[i] == 0:\n            for j in range(i * i, maxn, i):\n                if _factor[j] == 0:\n                    _factor[j] = i\n    for i in range(2, maxn):\n        if _factor[i] == 0:\n            _factor[i] = i\n            _totient[i] = i - 1\n            continue\n        x = _factor[i]\n        y = i // x\n        if y % x == 0:\n            _totient[i] = _totient[y] * x\n        else:\n            _totient[i] = _totient[y] * (x - 1)",
            "def _pre():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    maxn = 10 ** 5\n    global _factor\n    global _totient\n    _factor = [0] * maxn\n    _totient = [1] * maxn\n    lim = int(maxn ** 0.5) + 5\n    for i in range(2, lim):\n        if _factor[i] == 0:\n            for j in range(i * i, maxn, i):\n                if _factor[j] == 0:\n                    _factor[j] = i\n    for i in range(2, maxn):\n        if _factor[i] == 0:\n            _factor[i] = i\n            _totient[i] = i - 1\n            continue\n        x = _factor[i]\n        y = i // x\n        if y % x == 0:\n            _totient[i] = _totient[y] * x\n        else:\n            _totient[i] = _totient[y] * (x - 1)",
            "def _pre():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    maxn = 10 ** 5\n    global _factor\n    global _totient\n    _factor = [0] * maxn\n    _totient = [1] * maxn\n    lim = int(maxn ** 0.5) + 5\n    for i in range(2, lim):\n        if _factor[i] == 0:\n            for j in range(i * i, maxn, i):\n                if _factor[j] == 0:\n                    _factor[j] = i\n    for i in range(2, maxn):\n        if _factor[i] == 0:\n            _factor[i] = i\n            _totient[i] = i - 1\n            continue\n        x = _factor[i]\n        y = i // x\n        if y % x == 0:\n            _totient[i] = _totient[y] * x\n        else:\n            _totient[i] = _totient[y] * (x - 1)",
            "def _pre():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    maxn = 10 ** 5\n    global _factor\n    global _totient\n    _factor = [0] * maxn\n    _totient = [1] * maxn\n    lim = int(maxn ** 0.5) + 5\n    for i in range(2, lim):\n        if _factor[i] == 0:\n            for j in range(i * i, maxn, i):\n                if _factor[j] == 0:\n                    _factor[j] = i\n    for i in range(2, maxn):\n        if _factor[i] == 0:\n            _factor[i] = i\n            _totient[i] = i - 1\n            continue\n        x = _factor[i]\n        y = i // x\n        if y % x == 0:\n            _totient[i] = _totient[y] * x\n        else:\n            _totient[i] = _totient[y] * (x - 1)",
            "def _pre():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    maxn = 10 ** 5\n    global _factor\n    global _totient\n    _factor = [0] * maxn\n    _totient = [1] * maxn\n    lim = int(maxn ** 0.5) + 5\n    for i in range(2, lim):\n        if _factor[i] == 0:\n            for j in range(i * i, maxn, i):\n                if _factor[j] == 0:\n                    _factor[j] = i\n    for i in range(2, maxn):\n        if _factor[i] == 0:\n            _factor[i] = i\n            _totient[i] = i - 1\n            continue\n        x = _factor[i]\n        y = i // x\n        if y % x == 0:\n            _totient[i] = _totient[y] * x\n        else:\n            _totient[i] = _totient[y] * (x - 1)"
        ]
    },
    {
        "func_name": "_a",
        "original": "def _a(n, k, prec):\n    \"\"\" Compute the inner sum in HRR formula [1]_\n\n    References\n    ==========\n\n    .. [1] https://msp.org/pjm/1956/6-1/pjm-v6-n1-p18-p.pdf\n\n    \"\"\"\n    if k == 1:\n        return fone\n    k1 = k\n    e = 0\n    p = _factor[k]\n    while k1 % p == 0:\n        k1 //= p\n        e += 1\n    k2 = k // k1\n    v = 1 - 24 * n\n    pi = mpf_pi(prec)\n    if k1 == 1:\n        if p == 2:\n            mod = 8 * k\n            v = mod + v % mod\n            v = v * pow(9, k - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 2, e + 3)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int((-1) ** e * jacobi(m - 1, m)), mpf_sqrt(from_int(k), prec), prec), mpf_sin(arg, prec), prec)\n        if p == 3:\n            mod = 3 * k\n            v = mod + v % mod\n            if e > 1:\n                v = v * pow(64, k // 3 - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 3, e + 1)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int(2 * (-1) ** (e + 1) * legendre(m, 3)), mpf_sqrt(from_int(k // 3), prec), prec), mpf_sin(arg, prec), prec)\n        v = k + v % k\n        if v % p == 0:\n            if e == 1:\n                return mpf_mul(from_int(jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec)\n            return fzero\n        if not is_quad_residue(v, p):\n            return fzero\n        _phi = p ** (e - 1) * (p - 1)\n        v = v * pow(576, _phi - 1, k)\n        m = _sqrt_mod_prime_power(v, p, e)[0]\n        arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(k), prec)\n        return mpf_mul(mpf_mul(from_int(2 * jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec), mpf_cos(arg, prec), prec)\n    if p != 2 or e >= 3:\n        (d1, d2) = (gcd(k1, 24), gcd(k2, 24))\n        e = 24 // (d1 * d2)\n        n1 = (d2 * e * n + (k2 ** 2 - 1) // d1) * pow(e * k2 * k2 * d2, _totient[k1] - 1, k1) % k1\n        n2 = (d1 * e * n + (k1 ** 2 - 1) // d2) * pow(e * k1 * k1 * d1, _totient[k2] - 1, k2) % k2\n        return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)\n    if e == 2:\n        n1 = (8 * n + 5) * pow(128, _totient[k1] - 1, k1) % k1\n        n2 = (4 + (n - 2 - (k1 ** 2 - 1) // 8) * k1 ** 2 % 4) % 4\n        return mpf_mul(mpf_mul(from_int(-1), _a(n1, k1, prec), prec), _a(n2, k2, prec))\n    n1 = (8 * n + 1) * pow(32, _totient[k1] - 1, k1) % k1\n    n2 = (2 + (n - (k1 ** 2 - 1) // 8) % 2) % 2\n    return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)",
        "mutated": [
            "def _a(n, k, prec):\n    if False:\n        i = 10\n    ' Compute the inner sum in HRR formula [1]_\\n\\n    References\\n    ==========\\n\\n    .. [1] https://msp.org/pjm/1956/6-1/pjm-v6-n1-p18-p.pdf\\n\\n    '\n    if k == 1:\n        return fone\n    k1 = k\n    e = 0\n    p = _factor[k]\n    while k1 % p == 0:\n        k1 //= p\n        e += 1\n    k2 = k // k1\n    v = 1 - 24 * n\n    pi = mpf_pi(prec)\n    if k1 == 1:\n        if p == 2:\n            mod = 8 * k\n            v = mod + v % mod\n            v = v * pow(9, k - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 2, e + 3)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int((-1) ** e * jacobi(m - 1, m)), mpf_sqrt(from_int(k), prec), prec), mpf_sin(arg, prec), prec)\n        if p == 3:\n            mod = 3 * k\n            v = mod + v % mod\n            if e > 1:\n                v = v * pow(64, k // 3 - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 3, e + 1)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int(2 * (-1) ** (e + 1) * legendre(m, 3)), mpf_sqrt(from_int(k // 3), prec), prec), mpf_sin(arg, prec), prec)\n        v = k + v % k\n        if v % p == 0:\n            if e == 1:\n                return mpf_mul(from_int(jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec)\n            return fzero\n        if not is_quad_residue(v, p):\n            return fzero\n        _phi = p ** (e - 1) * (p - 1)\n        v = v * pow(576, _phi - 1, k)\n        m = _sqrt_mod_prime_power(v, p, e)[0]\n        arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(k), prec)\n        return mpf_mul(mpf_mul(from_int(2 * jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec), mpf_cos(arg, prec), prec)\n    if p != 2 or e >= 3:\n        (d1, d2) = (gcd(k1, 24), gcd(k2, 24))\n        e = 24 // (d1 * d2)\n        n1 = (d2 * e * n + (k2 ** 2 - 1) // d1) * pow(e * k2 * k2 * d2, _totient[k1] - 1, k1) % k1\n        n2 = (d1 * e * n + (k1 ** 2 - 1) // d2) * pow(e * k1 * k1 * d1, _totient[k2] - 1, k2) % k2\n        return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)\n    if e == 2:\n        n1 = (8 * n + 5) * pow(128, _totient[k1] - 1, k1) % k1\n        n2 = (4 + (n - 2 - (k1 ** 2 - 1) // 8) * k1 ** 2 % 4) % 4\n        return mpf_mul(mpf_mul(from_int(-1), _a(n1, k1, prec), prec), _a(n2, k2, prec))\n    n1 = (8 * n + 1) * pow(32, _totient[k1] - 1, k1) % k1\n    n2 = (2 + (n - (k1 ** 2 - 1) // 8) % 2) % 2\n    return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)",
            "def _a(n, k, prec):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Compute the inner sum in HRR formula [1]_\\n\\n    References\\n    ==========\\n\\n    .. [1] https://msp.org/pjm/1956/6-1/pjm-v6-n1-p18-p.pdf\\n\\n    '\n    if k == 1:\n        return fone\n    k1 = k\n    e = 0\n    p = _factor[k]\n    while k1 % p == 0:\n        k1 //= p\n        e += 1\n    k2 = k // k1\n    v = 1 - 24 * n\n    pi = mpf_pi(prec)\n    if k1 == 1:\n        if p == 2:\n            mod = 8 * k\n            v = mod + v % mod\n            v = v * pow(9, k - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 2, e + 3)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int((-1) ** e * jacobi(m - 1, m)), mpf_sqrt(from_int(k), prec), prec), mpf_sin(arg, prec), prec)\n        if p == 3:\n            mod = 3 * k\n            v = mod + v % mod\n            if e > 1:\n                v = v * pow(64, k // 3 - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 3, e + 1)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int(2 * (-1) ** (e + 1) * legendre(m, 3)), mpf_sqrt(from_int(k // 3), prec), prec), mpf_sin(arg, prec), prec)\n        v = k + v % k\n        if v % p == 0:\n            if e == 1:\n                return mpf_mul(from_int(jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec)\n            return fzero\n        if not is_quad_residue(v, p):\n            return fzero\n        _phi = p ** (e - 1) * (p - 1)\n        v = v * pow(576, _phi - 1, k)\n        m = _sqrt_mod_prime_power(v, p, e)[0]\n        arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(k), prec)\n        return mpf_mul(mpf_mul(from_int(2 * jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec), mpf_cos(arg, prec), prec)\n    if p != 2 or e >= 3:\n        (d1, d2) = (gcd(k1, 24), gcd(k2, 24))\n        e = 24 // (d1 * d2)\n        n1 = (d2 * e * n + (k2 ** 2 - 1) // d1) * pow(e * k2 * k2 * d2, _totient[k1] - 1, k1) % k1\n        n2 = (d1 * e * n + (k1 ** 2 - 1) // d2) * pow(e * k1 * k1 * d1, _totient[k2] - 1, k2) % k2\n        return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)\n    if e == 2:\n        n1 = (8 * n + 5) * pow(128, _totient[k1] - 1, k1) % k1\n        n2 = (4 + (n - 2 - (k1 ** 2 - 1) // 8) * k1 ** 2 % 4) % 4\n        return mpf_mul(mpf_mul(from_int(-1), _a(n1, k1, prec), prec), _a(n2, k2, prec))\n    n1 = (8 * n + 1) * pow(32, _totient[k1] - 1, k1) % k1\n    n2 = (2 + (n - (k1 ** 2 - 1) // 8) % 2) % 2\n    return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)",
            "def _a(n, k, prec):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Compute the inner sum in HRR formula [1]_\\n\\n    References\\n    ==========\\n\\n    .. [1] https://msp.org/pjm/1956/6-1/pjm-v6-n1-p18-p.pdf\\n\\n    '\n    if k == 1:\n        return fone\n    k1 = k\n    e = 0\n    p = _factor[k]\n    while k1 % p == 0:\n        k1 //= p\n        e += 1\n    k2 = k // k1\n    v = 1 - 24 * n\n    pi = mpf_pi(prec)\n    if k1 == 1:\n        if p == 2:\n            mod = 8 * k\n            v = mod + v % mod\n            v = v * pow(9, k - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 2, e + 3)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int((-1) ** e * jacobi(m - 1, m)), mpf_sqrt(from_int(k), prec), prec), mpf_sin(arg, prec), prec)\n        if p == 3:\n            mod = 3 * k\n            v = mod + v % mod\n            if e > 1:\n                v = v * pow(64, k // 3 - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 3, e + 1)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int(2 * (-1) ** (e + 1) * legendre(m, 3)), mpf_sqrt(from_int(k // 3), prec), prec), mpf_sin(arg, prec), prec)\n        v = k + v % k\n        if v % p == 0:\n            if e == 1:\n                return mpf_mul(from_int(jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec)\n            return fzero\n        if not is_quad_residue(v, p):\n            return fzero\n        _phi = p ** (e - 1) * (p - 1)\n        v = v * pow(576, _phi - 1, k)\n        m = _sqrt_mod_prime_power(v, p, e)[0]\n        arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(k), prec)\n        return mpf_mul(mpf_mul(from_int(2 * jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec), mpf_cos(arg, prec), prec)\n    if p != 2 or e >= 3:\n        (d1, d2) = (gcd(k1, 24), gcd(k2, 24))\n        e = 24 // (d1 * d2)\n        n1 = (d2 * e * n + (k2 ** 2 - 1) // d1) * pow(e * k2 * k2 * d2, _totient[k1] - 1, k1) % k1\n        n2 = (d1 * e * n + (k1 ** 2 - 1) // d2) * pow(e * k1 * k1 * d1, _totient[k2] - 1, k2) % k2\n        return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)\n    if e == 2:\n        n1 = (8 * n + 5) * pow(128, _totient[k1] - 1, k1) % k1\n        n2 = (4 + (n - 2 - (k1 ** 2 - 1) // 8) * k1 ** 2 % 4) % 4\n        return mpf_mul(mpf_mul(from_int(-1), _a(n1, k1, prec), prec), _a(n2, k2, prec))\n    n1 = (8 * n + 1) * pow(32, _totient[k1] - 1, k1) % k1\n    n2 = (2 + (n - (k1 ** 2 - 1) // 8) % 2) % 2\n    return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)",
            "def _a(n, k, prec):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Compute the inner sum in HRR formula [1]_\\n\\n    References\\n    ==========\\n\\n    .. [1] https://msp.org/pjm/1956/6-1/pjm-v6-n1-p18-p.pdf\\n\\n    '\n    if k == 1:\n        return fone\n    k1 = k\n    e = 0\n    p = _factor[k]\n    while k1 % p == 0:\n        k1 //= p\n        e += 1\n    k2 = k // k1\n    v = 1 - 24 * n\n    pi = mpf_pi(prec)\n    if k1 == 1:\n        if p == 2:\n            mod = 8 * k\n            v = mod + v % mod\n            v = v * pow(9, k - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 2, e + 3)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int((-1) ** e * jacobi(m - 1, m)), mpf_sqrt(from_int(k), prec), prec), mpf_sin(arg, prec), prec)\n        if p == 3:\n            mod = 3 * k\n            v = mod + v % mod\n            if e > 1:\n                v = v * pow(64, k // 3 - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 3, e + 1)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int(2 * (-1) ** (e + 1) * legendre(m, 3)), mpf_sqrt(from_int(k // 3), prec), prec), mpf_sin(arg, prec), prec)\n        v = k + v % k\n        if v % p == 0:\n            if e == 1:\n                return mpf_mul(from_int(jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec)\n            return fzero\n        if not is_quad_residue(v, p):\n            return fzero\n        _phi = p ** (e - 1) * (p - 1)\n        v = v * pow(576, _phi - 1, k)\n        m = _sqrt_mod_prime_power(v, p, e)[0]\n        arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(k), prec)\n        return mpf_mul(mpf_mul(from_int(2 * jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec), mpf_cos(arg, prec), prec)\n    if p != 2 or e >= 3:\n        (d1, d2) = (gcd(k1, 24), gcd(k2, 24))\n        e = 24 // (d1 * d2)\n        n1 = (d2 * e * n + (k2 ** 2 - 1) // d1) * pow(e * k2 * k2 * d2, _totient[k1] - 1, k1) % k1\n        n2 = (d1 * e * n + (k1 ** 2 - 1) // d2) * pow(e * k1 * k1 * d1, _totient[k2] - 1, k2) % k2\n        return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)\n    if e == 2:\n        n1 = (8 * n + 5) * pow(128, _totient[k1] - 1, k1) % k1\n        n2 = (4 + (n - 2 - (k1 ** 2 - 1) // 8) * k1 ** 2 % 4) % 4\n        return mpf_mul(mpf_mul(from_int(-1), _a(n1, k1, prec), prec), _a(n2, k2, prec))\n    n1 = (8 * n + 1) * pow(32, _totient[k1] - 1, k1) % k1\n    n2 = (2 + (n - (k1 ** 2 - 1) // 8) % 2) % 2\n    return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)",
            "def _a(n, k, prec):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Compute the inner sum in HRR formula [1]_\\n\\n    References\\n    ==========\\n\\n    .. [1] https://msp.org/pjm/1956/6-1/pjm-v6-n1-p18-p.pdf\\n\\n    '\n    if k == 1:\n        return fone\n    k1 = k\n    e = 0\n    p = _factor[k]\n    while k1 % p == 0:\n        k1 //= p\n        e += 1\n    k2 = k // k1\n    v = 1 - 24 * n\n    pi = mpf_pi(prec)\n    if k1 == 1:\n        if p == 2:\n            mod = 8 * k\n            v = mod + v % mod\n            v = v * pow(9, k - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 2, e + 3)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int((-1) ** e * jacobi(m - 1, m)), mpf_sqrt(from_int(k), prec), prec), mpf_sin(arg, prec), prec)\n        if p == 3:\n            mod = 3 * k\n            v = mod + v % mod\n            if e > 1:\n                v = v * pow(64, k // 3 - 1, mod) % mod\n            m = _sqrt_mod_prime_power(v, 3, e + 1)[0]\n            arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(mod), prec)\n            return mpf_mul(mpf_mul(from_int(2 * (-1) ** (e + 1) * legendre(m, 3)), mpf_sqrt(from_int(k // 3), prec), prec), mpf_sin(arg, prec), prec)\n        v = k + v % k\n        if v % p == 0:\n            if e == 1:\n                return mpf_mul(from_int(jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec)\n            return fzero\n        if not is_quad_residue(v, p):\n            return fzero\n        _phi = p ** (e - 1) * (p - 1)\n        v = v * pow(576, _phi - 1, k)\n        m = _sqrt_mod_prime_power(v, p, e)[0]\n        arg = mpf_div(mpf_mul(from_int(4 * m), pi, prec), from_int(k), prec)\n        return mpf_mul(mpf_mul(from_int(2 * jacobi(3, k)), mpf_sqrt(from_int(k), prec), prec), mpf_cos(arg, prec), prec)\n    if p != 2 or e >= 3:\n        (d1, d2) = (gcd(k1, 24), gcd(k2, 24))\n        e = 24 // (d1 * d2)\n        n1 = (d2 * e * n + (k2 ** 2 - 1) // d1) * pow(e * k2 * k2 * d2, _totient[k1] - 1, k1) % k1\n        n2 = (d1 * e * n + (k1 ** 2 - 1) // d2) * pow(e * k1 * k1 * d1, _totient[k2] - 1, k2) % k2\n        return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)\n    if e == 2:\n        n1 = (8 * n + 5) * pow(128, _totient[k1] - 1, k1) % k1\n        n2 = (4 + (n - 2 - (k1 ** 2 - 1) // 8) * k1 ** 2 % 4) % 4\n        return mpf_mul(mpf_mul(from_int(-1), _a(n1, k1, prec), prec), _a(n2, k2, prec))\n    n1 = (8 * n + 1) * pow(32, _totient[k1] - 1, k1) % k1\n    n2 = (2 + (n - (k1 ** 2 - 1) // 8) % 2) % 2\n    return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)"
        ]
    },
    {
        "func_name": "_d",
        "original": "def _d(n, j, prec, sq23pi, sqrt8):\n    \"\"\"\n    Compute the sinh term in the outer sum of the HRR formula.\n    The constants sqrt(2/3*pi) and sqrt(8) must be precomputed.\n    \"\"\"\n    j = from_int(j)\n    pi = mpf_pi(prec)\n    a = mpf_div(sq23pi, j, prec)\n    b = mpf_sub(from_int(n), from_rational(1, 24, prec), prec)\n    c = mpf_sqrt(b, prec)\n    (ch, sh) = mpf_cosh_sinh(mpf_mul(a, c), prec)\n    D = mpf_div(mpf_sqrt(j, prec), mpf_mul(mpf_mul(sqrt8, b), pi), prec)\n    E = mpf_sub(mpf_mul(a, ch), mpf_div(sh, c, prec), prec)\n    return mpf_mul(D, E)",
        "mutated": [
            "def _d(n, j, prec, sq23pi, sqrt8):\n    if False:\n        i = 10\n    '\\n    Compute the sinh term in the outer sum of the HRR formula.\\n    The constants sqrt(2/3*pi) and sqrt(8) must be precomputed.\\n    '\n    j = from_int(j)\n    pi = mpf_pi(prec)\n    a = mpf_div(sq23pi, j, prec)\n    b = mpf_sub(from_int(n), from_rational(1, 24, prec), prec)\n    c = mpf_sqrt(b, prec)\n    (ch, sh) = mpf_cosh_sinh(mpf_mul(a, c), prec)\n    D = mpf_div(mpf_sqrt(j, prec), mpf_mul(mpf_mul(sqrt8, b), pi), prec)\n    E = mpf_sub(mpf_mul(a, ch), mpf_div(sh, c, prec), prec)\n    return mpf_mul(D, E)",
            "def _d(n, j, prec, sq23pi, sqrt8):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the sinh term in the outer sum of the HRR formula.\\n    The constants sqrt(2/3*pi) and sqrt(8) must be precomputed.\\n    '\n    j = from_int(j)\n    pi = mpf_pi(prec)\n    a = mpf_div(sq23pi, j, prec)\n    b = mpf_sub(from_int(n), from_rational(1, 24, prec), prec)\n    c = mpf_sqrt(b, prec)\n    (ch, sh) = mpf_cosh_sinh(mpf_mul(a, c), prec)\n    D = mpf_div(mpf_sqrt(j, prec), mpf_mul(mpf_mul(sqrt8, b), pi), prec)\n    E = mpf_sub(mpf_mul(a, ch), mpf_div(sh, c, prec), prec)\n    return mpf_mul(D, E)",
            "def _d(n, j, prec, sq23pi, sqrt8):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the sinh term in the outer sum of the HRR formula.\\n    The constants sqrt(2/3*pi) and sqrt(8) must be precomputed.\\n    '\n    j = from_int(j)\n    pi = mpf_pi(prec)\n    a = mpf_div(sq23pi, j, prec)\n    b = mpf_sub(from_int(n), from_rational(1, 24, prec), prec)\n    c = mpf_sqrt(b, prec)\n    (ch, sh) = mpf_cosh_sinh(mpf_mul(a, c), prec)\n    D = mpf_div(mpf_sqrt(j, prec), mpf_mul(mpf_mul(sqrt8, b), pi), prec)\n    E = mpf_sub(mpf_mul(a, ch), mpf_div(sh, c, prec), prec)\n    return mpf_mul(D, E)",
            "def _d(n, j, prec, sq23pi, sqrt8):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the sinh term in the outer sum of the HRR formula.\\n    The constants sqrt(2/3*pi) and sqrt(8) must be precomputed.\\n    '\n    j = from_int(j)\n    pi = mpf_pi(prec)\n    a = mpf_div(sq23pi, j, prec)\n    b = mpf_sub(from_int(n), from_rational(1, 24, prec), prec)\n    c = mpf_sqrt(b, prec)\n    (ch, sh) = mpf_cosh_sinh(mpf_mul(a, c), prec)\n    D = mpf_div(mpf_sqrt(j, prec), mpf_mul(mpf_mul(sqrt8, b), pi), prec)\n    E = mpf_sub(mpf_mul(a, ch), mpf_div(sh, c, prec), prec)\n    return mpf_mul(D, E)",
            "def _d(n, j, prec, sq23pi, sqrt8):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the sinh term in the outer sum of the HRR formula.\\n    The constants sqrt(2/3*pi) and sqrt(8) must be precomputed.\\n    '\n    j = from_int(j)\n    pi = mpf_pi(prec)\n    a = mpf_div(sq23pi, j, prec)\n    b = mpf_sub(from_int(n), from_rational(1, 24, prec), prec)\n    c = mpf_sqrt(b, prec)\n    (ch, sh) = mpf_cosh_sinh(mpf_mul(a, c), prec)\n    D = mpf_div(mpf_sqrt(j, prec), mpf_mul(mpf_mul(sqrt8, b), pi), prec)\n    E = mpf_sub(mpf_mul(a, ch), mpf_div(sh, c, prec), prec)\n    return mpf_mul(D, E)"
        ]
    },
    {
        "func_name": "M",
        "original": "def M(n, N):\n    sqrt = math.sqrt\n    return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)",
        "mutated": [
            "def M(n, N):\n    if False:\n        i = 10\n    sqrt = math.sqrt\n    return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)",
            "def M(n, N):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sqrt = math.sqrt\n    return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)",
            "def M(n, N):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sqrt = math.sqrt\n    return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)",
            "def M(n, N):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sqrt = math.sqrt\n    return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)",
            "def M(n, N):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sqrt = math.sqrt\n    return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)"
        ]
    },
    {
        "func_name": "npartitions",
        "original": "def npartitions(n, verbose=False):\n    \"\"\"\n    Calculate the partition function P(n), i.e. the number of ways that\n    n can be written as a sum of positive integers.\n\n    P(n) is computed using the Hardy-Ramanujan-Rademacher formula [1]_.\n\n\n    The correctness of this implementation has been tested through $10^{10}$.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import npartitions\n    >>> npartitions(25)\n    1958\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/PartitionFunctionP.html\n\n    \"\"\"\n    from sympy.functions.combinatorial.numbers import _npartition, partition\n    n = int(n)\n    if n < 0:\n        return 0\n    if n <= 5:\n        return [1, 1, 2, 3, 5, 7][n]\n    if n <= 200000 and n - len(_npartition) < 70 or (len(_npartition) == 2 and n < 14400):\n        return partition(n)\n    if '_factor' not in globals():\n        _pre()\n    pbits = int((math.pi * (2 * n / 3.0) ** 0.5 - math.log(4 * n)) / math.log(10) + 1) * math.log(10, 2)\n    prec = p = int(pbits * 1.1 + 100)\n    c1 = 44 * math.pi ** 2 / (225 * math.sqrt(3))\n    c2 = math.pi * math.sqrt(2) / 75\n    c3 = math.pi * math.sqrt(2 / 3)\n\n    def M(n, N):\n        sqrt = math.sqrt\n        return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)\n    big = max(9, math.ceil(n ** 0.5))\n    assert M(n, big) < 0.5\n    while big > 40 and M(n, big) < 0.5:\n        big //= 2\n    small = big\n    big = small * 2\n    while big - small > 1:\n        N = (big + small) // 2\n        if (er := M(n, N)) < 0.5:\n            big = N\n        elif er >= 0.5:\n            small = N\n    M = big\n    if M > 10 ** 5:\n        raise ValueError('Input too big')\n    s = fzero\n    sq23pi = mpf_mul(mpf_sqrt(from_rational(2, 3, p), p), mpf_pi(p), p)\n    sqrt8 = mpf_sqrt(from_int(8), p)\n    for q in range(1, M):\n        a = _a(n, q, p)\n        d = _d(n, q, p, sq23pi, sqrt8)\n        s = mpf_add(s, mpf_mul(a, d), prec)\n        if verbose:\n            print('step', q, 'of', M, to_str(a, 10), to_str(d, 10))\n        p = bitcount(abs(to_int(d))) + 50\n    return int(to_int(mpf_add(s, fhalf, prec)))",
        "mutated": [
            "def npartitions(n, verbose=False):\n    if False:\n        i = 10\n    '\\n    Calculate the partition function P(n), i.e. the number of ways that\\n    n can be written as a sum of positive integers.\\n\\n    P(n) is computed using the Hardy-Ramanujan-Rademacher formula [1]_.\\n\\n\\n    The correctness of this implementation has been tested through $10^{10}$.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import npartitions\\n    >>> npartitions(25)\\n    1958\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/PartitionFunctionP.html\\n\\n    '\n    from sympy.functions.combinatorial.numbers import _npartition, partition\n    n = int(n)\n    if n < 0:\n        return 0\n    if n <= 5:\n        return [1, 1, 2, 3, 5, 7][n]\n    if n <= 200000 and n - len(_npartition) < 70 or (len(_npartition) == 2 and n < 14400):\n        return partition(n)\n    if '_factor' not in globals():\n        _pre()\n    pbits = int((math.pi * (2 * n / 3.0) ** 0.5 - math.log(4 * n)) / math.log(10) + 1) * math.log(10, 2)\n    prec = p = int(pbits * 1.1 + 100)\n    c1 = 44 * math.pi ** 2 / (225 * math.sqrt(3))\n    c2 = math.pi * math.sqrt(2) / 75\n    c3 = math.pi * math.sqrt(2 / 3)\n\n    def M(n, N):\n        sqrt = math.sqrt\n        return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)\n    big = max(9, math.ceil(n ** 0.5))\n    assert M(n, big) < 0.5\n    while big > 40 and M(n, big) < 0.5:\n        big //= 2\n    small = big\n    big = small * 2\n    while big - small > 1:\n        N = (big + small) // 2\n        if (er := M(n, N)) < 0.5:\n            big = N\n        elif er >= 0.5:\n            small = N\n    M = big\n    if M > 10 ** 5:\n        raise ValueError('Input too big')\n    s = fzero\n    sq23pi = mpf_mul(mpf_sqrt(from_rational(2, 3, p), p), mpf_pi(p), p)\n    sqrt8 = mpf_sqrt(from_int(8), p)\n    for q in range(1, M):\n        a = _a(n, q, p)\n        d = _d(n, q, p, sq23pi, sqrt8)\n        s = mpf_add(s, mpf_mul(a, d), prec)\n        if verbose:\n            print('step', q, 'of', M, to_str(a, 10), to_str(d, 10))\n        p = bitcount(abs(to_int(d))) + 50\n    return int(to_int(mpf_add(s, fhalf, prec)))",
            "def npartitions(n, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the partition function P(n), i.e. the number of ways that\\n    n can be written as a sum of positive integers.\\n\\n    P(n) is computed using the Hardy-Ramanujan-Rademacher formula [1]_.\\n\\n\\n    The correctness of this implementation has been tested through $10^{10}$.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import npartitions\\n    >>> npartitions(25)\\n    1958\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/PartitionFunctionP.html\\n\\n    '\n    from sympy.functions.combinatorial.numbers import _npartition, partition\n    n = int(n)\n    if n < 0:\n        return 0\n    if n <= 5:\n        return [1, 1, 2, 3, 5, 7][n]\n    if n <= 200000 and n - len(_npartition) < 70 or (len(_npartition) == 2 and n < 14400):\n        return partition(n)\n    if '_factor' not in globals():\n        _pre()\n    pbits = int((math.pi * (2 * n / 3.0) ** 0.5 - math.log(4 * n)) / math.log(10) + 1) * math.log(10, 2)\n    prec = p = int(pbits * 1.1 + 100)\n    c1 = 44 * math.pi ** 2 / (225 * math.sqrt(3))\n    c2 = math.pi * math.sqrt(2) / 75\n    c3 = math.pi * math.sqrt(2 / 3)\n\n    def M(n, N):\n        sqrt = math.sqrt\n        return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)\n    big = max(9, math.ceil(n ** 0.5))\n    assert M(n, big) < 0.5\n    while big > 40 and M(n, big) < 0.5:\n        big //= 2\n    small = big\n    big = small * 2\n    while big - small > 1:\n        N = (big + small) // 2\n        if (er := M(n, N)) < 0.5:\n            big = N\n        elif er >= 0.5:\n            small = N\n    M = big\n    if M > 10 ** 5:\n        raise ValueError('Input too big')\n    s = fzero\n    sq23pi = mpf_mul(mpf_sqrt(from_rational(2, 3, p), p), mpf_pi(p), p)\n    sqrt8 = mpf_sqrt(from_int(8), p)\n    for q in range(1, M):\n        a = _a(n, q, p)\n        d = _d(n, q, p, sq23pi, sqrt8)\n        s = mpf_add(s, mpf_mul(a, d), prec)\n        if verbose:\n            print('step', q, 'of', M, to_str(a, 10), to_str(d, 10))\n        p = bitcount(abs(to_int(d))) + 50\n    return int(to_int(mpf_add(s, fhalf, prec)))",
            "def npartitions(n, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the partition function P(n), i.e. the number of ways that\\n    n can be written as a sum of positive integers.\\n\\n    P(n) is computed using the Hardy-Ramanujan-Rademacher formula [1]_.\\n\\n\\n    The correctness of this implementation has been tested through $10^{10}$.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import npartitions\\n    >>> npartitions(25)\\n    1958\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/PartitionFunctionP.html\\n\\n    '\n    from sympy.functions.combinatorial.numbers import _npartition, partition\n    n = int(n)\n    if n < 0:\n        return 0\n    if n <= 5:\n        return [1, 1, 2, 3, 5, 7][n]\n    if n <= 200000 and n - len(_npartition) < 70 or (len(_npartition) == 2 and n < 14400):\n        return partition(n)\n    if '_factor' not in globals():\n        _pre()\n    pbits = int((math.pi * (2 * n / 3.0) ** 0.5 - math.log(4 * n)) / math.log(10) + 1) * math.log(10, 2)\n    prec = p = int(pbits * 1.1 + 100)\n    c1 = 44 * math.pi ** 2 / (225 * math.sqrt(3))\n    c2 = math.pi * math.sqrt(2) / 75\n    c3 = math.pi * math.sqrt(2 / 3)\n\n    def M(n, N):\n        sqrt = math.sqrt\n        return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)\n    big = max(9, math.ceil(n ** 0.5))\n    assert M(n, big) < 0.5\n    while big > 40 and M(n, big) < 0.5:\n        big //= 2\n    small = big\n    big = small * 2\n    while big - small > 1:\n        N = (big + small) // 2\n        if (er := M(n, N)) < 0.5:\n            big = N\n        elif er >= 0.5:\n            small = N\n    M = big\n    if M > 10 ** 5:\n        raise ValueError('Input too big')\n    s = fzero\n    sq23pi = mpf_mul(mpf_sqrt(from_rational(2, 3, p), p), mpf_pi(p), p)\n    sqrt8 = mpf_sqrt(from_int(8), p)\n    for q in range(1, M):\n        a = _a(n, q, p)\n        d = _d(n, q, p, sq23pi, sqrt8)\n        s = mpf_add(s, mpf_mul(a, d), prec)\n        if verbose:\n            print('step', q, 'of', M, to_str(a, 10), to_str(d, 10))\n        p = bitcount(abs(to_int(d))) + 50\n    return int(to_int(mpf_add(s, fhalf, prec)))",
            "def npartitions(n, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the partition function P(n), i.e. the number of ways that\\n    n can be written as a sum of positive integers.\\n\\n    P(n) is computed using the Hardy-Ramanujan-Rademacher formula [1]_.\\n\\n\\n    The correctness of this implementation has been tested through $10^{10}$.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import npartitions\\n    >>> npartitions(25)\\n    1958\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/PartitionFunctionP.html\\n\\n    '\n    from sympy.functions.combinatorial.numbers import _npartition, partition\n    n = int(n)\n    if n < 0:\n        return 0\n    if n <= 5:\n        return [1, 1, 2, 3, 5, 7][n]\n    if n <= 200000 and n - len(_npartition) < 70 or (len(_npartition) == 2 and n < 14400):\n        return partition(n)\n    if '_factor' not in globals():\n        _pre()\n    pbits = int((math.pi * (2 * n / 3.0) ** 0.5 - math.log(4 * n)) / math.log(10) + 1) * math.log(10, 2)\n    prec = p = int(pbits * 1.1 + 100)\n    c1 = 44 * math.pi ** 2 / (225 * math.sqrt(3))\n    c2 = math.pi * math.sqrt(2) / 75\n    c3 = math.pi * math.sqrt(2 / 3)\n\n    def M(n, N):\n        sqrt = math.sqrt\n        return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)\n    big = max(9, math.ceil(n ** 0.5))\n    assert M(n, big) < 0.5\n    while big > 40 and M(n, big) < 0.5:\n        big //= 2\n    small = big\n    big = small * 2\n    while big - small > 1:\n        N = (big + small) // 2\n        if (er := M(n, N)) < 0.5:\n            big = N\n        elif er >= 0.5:\n            small = N\n    M = big\n    if M > 10 ** 5:\n        raise ValueError('Input too big')\n    s = fzero\n    sq23pi = mpf_mul(mpf_sqrt(from_rational(2, 3, p), p), mpf_pi(p), p)\n    sqrt8 = mpf_sqrt(from_int(8), p)\n    for q in range(1, M):\n        a = _a(n, q, p)\n        d = _d(n, q, p, sq23pi, sqrt8)\n        s = mpf_add(s, mpf_mul(a, d), prec)\n        if verbose:\n            print('step', q, 'of', M, to_str(a, 10), to_str(d, 10))\n        p = bitcount(abs(to_int(d))) + 50\n    return int(to_int(mpf_add(s, fhalf, prec)))",
            "def npartitions(n, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the partition function P(n), i.e. the number of ways that\\n    n can be written as a sum of positive integers.\\n\\n    P(n) is computed using the Hardy-Ramanujan-Rademacher formula [1]_.\\n\\n\\n    The correctness of this implementation has been tested through $10^{10}$.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import npartitions\\n    >>> npartitions(25)\\n    1958\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/PartitionFunctionP.html\\n\\n    '\n    from sympy.functions.combinatorial.numbers import _npartition, partition\n    n = int(n)\n    if n < 0:\n        return 0\n    if n <= 5:\n        return [1, 1, 2, 3, 5, 7][n]\n    if n <= 200000 and n - len(_npartition) < 70 or (len(_npartition) == 2 and n < 14400):\n        return partition(n)\n    if '_factor' not in globals():\n        _pre()\n    pbits = int((math.pi * (2 * n / 3.0) ** 0.5 - math.log(4 * n)) / math.log(10) + 1) * math.log(10, 2)\n    prec = p = int(pbits * 1.1 + 100)\n    c1 = 44 * math.pi ** 2 / (225 * math.sqrt(3))\n    c2 = math.pi * math.sqrt(2) / 75\n    c3 = math.pi * math.sqrt(2 / 3)\n\n    def M(n, N):\n        sqrt = math.sqrt\n        return c1 / sqrt(N) + c2 * sqrt(N / (n - 1)) * math.sinh(c3 * sqrt(n) / N)\n    big = max(9, math.ceil(n ** 0.5))\n    assert M(n, big) < 0.5\n    while big > 40 and M(n, big) < 0.5:\n        big //= 2\n    small = big\n    big = small * 2\n    while big - small > 1:\n        N = (big + small) // 2\n        if (er := M(n, N)) < 0.5:\n            big = N\n        elif er >= 0.5:\n            small = N\n    M = big\n    if M > 10 ** 5:\n        raise ValueError('Input too big')\n    s = fzero\n    sq23pi = mpf_mul(mpf_sqrt(from_rational(2, 3, p), p), mpf_pi(p), p)\n    sqrt8 = mpf_sqrt(from_int(8), p)\n    for q in range(1, M):\n        a = _a(n, q, p)\n        d = _d(n, q, p, sq23pi, sqrt8)\n        s = mpf_add(s, mpf_mul(a, d), prec)\n        if verbose:\n            print('step', q, 'of', M, to_str(a, 10), to_str(d, 10))\n        p = bitcount(abs(to_int(d))) + 50\n    return int(to_int(mpf_add(s, fhalf, prec)))"
        ]
    }
]