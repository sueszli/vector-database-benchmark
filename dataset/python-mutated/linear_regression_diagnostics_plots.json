[
    {
        "func_name": "__init__",
        "original": "def __init__(self, results: Type[statsmodels.regression.linear_model.RegressionResultsWrapper]) -> None:\n    \"\"\"\n        For a linear regression model, generates following diagnostic plots:\n\n        a. residual\n        b. qq\n        c. scale location and\n        d. leverage\n\n        and a table\n\n        e. vif\n\n        Args:\n            results (Type[statsmodels.regression.linear_model.RegressionResultsWrapper]): \n                must be instance of statsmodels.regression.linear_model object\n\n        Raises:\n            TypeError: if instance does not belong to above object\n\n        Example:\n        >>> import numpy as np\n        >>> import pandas as pd\n        >>> import statsmodels.formula.api as smf\n        >>> x = np.linspace(-np.pi, np.pi, 100)\n        >>> y = 3*x + 8 + np.random.normal(0,1, 100)\n        >>> df = pd.DataFrame({'x':x, 'y':y})\n        >>> res = smf.ols(formula= \"y ~ x\", data=df).fit()\n        >>> cls = Linear_Reg_Diagnostic(res)\n        >>> cls(plot_context=\"seaborn-paper\")     \n\n        In case you do not need all plots you can also independently make an individual plot/table\n        in following ways\n\n        >>> cls = Linear_Reg_Diagnostic(res)\n        >>> cls.residual_plot()\n        >>> cls.qq_plot()\n        >>> cls.scale_location_plot()\n        >>> cls.leverage_plot()\n        >>> cls.vif_table()\n        \"\"\"\n    if isinstance(results, statsmodels.regression.linear_model.RegressionResultsWrapper) is False:\n        raise TypeError('result must be instance of statsmodels.regression.linear_model.RegressionResultsWrapper object')\n    self.results = maybe_unwrap_results(results)\n    self.y_true = self.results.model.endog\n    self.y_predict = self.results.fittedvalues\n    self.xvar = self.results.model.exog\n    self.xvar_names = self.results.model.exog_names\n    self.residual = np.array(self.results.resid)\n    influence = self.results.get_influence()\n    self.residual_norm = influence.resid_studentized_internal\n    self.leverage = influence.hat_matrix_diag\n    self.cooks_distance = influence.cooks_distance[0]\n    self.nparams = len(self.results.params)",
        "mutated": [
            "def __init__(self, results: Type[statsmodels.regression.linear_model.RegressionResultsWrapper]) -> None:\n    if False:\n        i = 10\n    '\\n        For a linear regression model, generates following diagnostic plots:\\n\\n        a. residual\\n        b. qq\\n        c. scale location and\\n        d. leverage\\n\\n        and a table\\n\\n        e. vif\\n\\n        Args:\\n            results (Type[statsmodels.regression.linear_model.RegressionResultsWrapper]): \\n                must be instance of statsmodels.regression.linear_model object\\n\\n        Raises:\\n            TypeError: if instance does not belong to above object\\n\\n        Example:\\n        >>> import numpy as np\\n        >>> import pandas as pd\\n        >>> import statsmodels.formula.api as smf\\n        >>> x = np.linspace(-np.pi, np.pi, 100)\\n        >>> y = 3*x + 8 + np.random.normal(0,1, 100)\\n        >>> df = pd.DataFrame({\\'x\\':x, \\'y\\':y})\\n        >>> res = smf.ols(formula= \"y ~ x\", data=df).fit()\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls(plot_context=\"seaborn-paper\")     \\n\\n        In case you do not need all plots you can also independently make an individual plot/table\\n        in following ways\\n\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls.residual_plot()\\n        >>> cls.qq_plot()\\n        >>> cls.scale_location_plot()\\n        >>> cls.leverage_plot()\\n        >>> cls.vif_table()\\n        '\n    if isinstance(results, statsmodels.regression.linear_model.RegressionResultsWrapper) is False:\n        raise TypeError('result must be instance of statsmodels.regression.linear_model.RegressionResultsWrapper object')\n    self.results = maybe_unwrap_results(results)\n    self.y_true = self.results.model.endog\n    self.y_predict = self.results.fittedvalues\n    self.xvar = self.results.model.exog\n    self.xvar_names = self.results.model.exog_names\n    self.residual = np.array(self.results.resid)\n    influence = self.results.get_influence()\n    self.residual_norm = influence.resid_studentized_internal\n    self.leverage = influence.hat_matrix_diag\n    self.cooks_distance = influence.cooks_distance[0]\n    self.nparams = len(self.results.params)",
            "def __init__(self, results: Type[statsmodels.regression.linear_model.RegressionResultsWrapper]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        For a linear regression model, generates following diagnostic plots:\\n\\n        a. residual\\n        b. qq\\n        c. scale location and\\n        d. leverage\\n\\n        and a table\\n\\n        e. vif\\n\\n        Args:\\n            results (Type[statsmodels.regression.linear_model.RegressionResultsWrapper]): \\n                must be instance of statsmodels.regression.linear_model object\\n\\n        Raises:\\n            TypeError: if instance does not belong to above object\\n\\n        Example:\\n        >>> import numpy as np\\n        >>> import pandas as pd\\n        >>> import statsmodels.formula.api as smf\\n        >>> x = np.linspace(-np.pi, np.pi, 100)\\n        >>> y = 3*x + 8 + np.random.normal(0,1, 100)\\n        >>> df = pd.DataFrame({\\'x\\':x, \\'y\\':y})\\n        >>> res = smf.ols(formula= \"y ~ x\", data=df).fit()\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls(plot_context=\"seaborn-paper\")     \\n\\n        In case you do not need all plots you can also independently make an individual plot/table\\n        in following ways\\n\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls.residual_plot()\\n        >>> cls.qq_plot()\\n        >>> cls.scale_location_plot()\\n        >>> cls.leverage_plot()\\n        >>> cls.vif_table()\\n        '\n    if isinstance(results, statsmodels.regression.linear_model.RegressionResultsWrapper) is False:\n        raise TypeError('result must be instance of statsmodels.regression.linear_model.RegressionResultsWrapper object')\n    self.results = maybe_unwrap_results(results)\n    self.y_true = self.results.model.endog\n    self.y_predict = self.results.fittedvalues\n    self.xvar = self.results.model.exog\n    self.xvar_names = self.results.model.exog_names\n    self.residual = np.array(self.results.resid)\n    influence = self.results.get_influence()\n    self.residual_norm = influence.resid_studentized_internal\n    self.leverage = influence.hat_matrix_diag\n    self.cooks_distance = influence.cooks_distance[0]\n    self.nparams = len(self.results.params)",
            "def __init__(self, results: Type[statsmodels.regression.linear_model.RegressionResultsWrapper]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        For a linear regression model, generates following diagnostic plots:\\n\\n        a. residual\\n        b. qq\\n        c. scale location and\\n        d. leverage\\n\\n        and a table\\n\\n        e. vif\\n\\n        Args:\\n            results (Type[statsmodels.regression.linear_model.RegressionResultsWrapper]): \\n                must be instance of statsmodels.regression.linear_model object\\n\\n        Raises:\\n            TypeError: if instance does not belong to above object\\n\\n        Example:\\n        >>> import numpy as np\\n        >>> import pandas as pd\\n        >>> import statsmodels.formula.api as smf\\n        >>> x = np.linspace(-np.pi, np.pi, 100)\\n        >>> y = 3*x + 8 + np.random.normal(0,1, 100)\\n        >>> df = pd.DataFrame({\\'x\\':x, \\'y\\':y})\\n        >>> res = smf.ols(formula= \"y ~ x\", data=df).fit()\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls(plot_context=\"seaborn-paper\")     \\n\\n        In case you do not need all plots you can also independently make an individual plot/table\\n        in following ways\\n\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls.residual_plot()\\n        >>> cls.qq_plot()\\n        >>> cls.scale_location_plot()\\n        >>> cls.leverage_plot()\\n        >>> cls.vif_table()\\n        '\n    if isinstance(results, statsmodels.regression.linear_model.RegressionResultsWrapper) is False:\n        raise TypeError('result must be instance of statsmodels.regression.linear_model.RegressionResultsWrapper object')\n    self.results = maybe_unwrap_results(results)\n    self.y_true = self.results.model.endog\n    self.y_predict = self.results.fittedvalues\n    self.xvar = self.results.model.exog\n    self.xvar_names = self.results.model.exog_names\n    self.residual = np.array(self.results.resid)\n    influence = self.results.get_influence()\n    self.residual_norm = influence.resid_studentized_internal\n    self.leverage = influence.hat_matrix_diag\n    self.cooks_distance = influence.cooks_distance[0]\n    self.nparams = len(self.results.params)",
            "def __init__(self, results: Type[statsmodels.regression.linear_model.RegressionResultsWrapper]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        For a linear regression model, generates following diagnostic plots:\\n\\n        a. residual\\n        b. qq\\n        c. scale location and\\n        d. leverage\\n\\n        and a table\\n\\n        e. vif\\n\\n        Args:\\n            results (Type[statsmodels.regression.linear_model.RegressionResultsWrapper]): \\n                must be instance of statsmodels.regression.linear_model object\\n\\n        Raises:\\n            TypeError: if instance does not belong to above object\\n\\n        Example:\\n        >>> import numpy as np\\n        >>> import pandas as pd\\n        >>> import statsmodels.formula.api as smf\\n        >>> x = np.linspace(-np.pi, np.pi, 100)\\n        >>> y = 3*x + 8 + np.random.normal(0,1, 100)\\n        >>> df = pd.DataFrame({\\'x\\':x, \\'y\\':y})\\n        >>> res = smf.ols(formula= \"y ~ x\", data=df).fit()\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls(plot_context=\"seaborn-paper\")     \\n\\n        In case you do not need all plots you can also independently make an individual plot/table\\n        in following ways\\n\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls.residual_plot()\\n        >>> cls.qq_plot()\\n        >>> cls.scale_location_plot()\\n        >>> cls.leverage_plot()\\n        >>> cls.vif_table()\\n        '\n    if isinstance(results, statsmodels.regression.linear_model.RegressionResultsWrapper) is False:\n        raise TypeError('result must be instance of statsmodels.regression.linear_model.RegressionResultsWrapper object')\n    self.results = maybe_unwrap_results(results)\n    self.y_true = self.results.model.endog\n    self.y_predict = self.results.fittedvalues\n    self.xvar = self.results.model.exog\n    self.xvar_names = self.results.model.exog_names\n    self.residual = np.array(self.results.resid)\n    influence = self.results.get_influence()\n    self.residual_norm = influence.resid_studentized_internal\n    self.leverage = influence.hat_matrix_diag\n    self.cooks_distance = influence.cooks_distance[0]\n    self.nparams = len(self.results.params)",
            "def __init__(self, results: Type[statsmodels.regression.linear_model.RegressionResultsWrapper]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        For a linear regression model, generates following diagnostic plots:\\n\\n        a. residual\\n        b. qq\\n        c. scale location and\\n        d. leverage\\n\\n        and a table\\n\\n        e. vif\\n\\n        Args:\\n            results (Type[statsmodels.regression.linear_model.RegressionResultsWrapper]): \\n                must be instance of statsmodels.regression.linear_model object\\n\\n        Raises:\\n            TypeError: if instance does not belong to above object\\n\\n        Example:\\n        >>> import numpy as np\\n        >>> import pandas as pd\\n        >>> import statsmodels.formula.api as smf\\n        >>> x = np.linspace(-np.pi, np.pi, 100)\\n        >>> y = 3*x + 8 + np.random.normal(0,1, 100)\\n        >>> df = pd.DataFrame({\\'x\\':x, \\'y\\':y})\\n        >>> res = smf.ols(formula= \"y ~ x\", data=df).fit()\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls(plot_context=\"seaborn-paper\")     \\n\\n        In case you do not need all plots you can also independently make an individual plot/table\\n        in following ways\\n\\n        >>> cls = Linear_Reg_Diagnostic(res)\\n        >>> cls.residual_plot()\\n        >>> cls.qq_plot()\\n        >>> cls.scale_location_plot()\\n        >>> cls.leverage_plot()\\n        >>> cls.vif_table()\\n        '\n    if isinstance(results, statsmodels.regression.linear_model.RegressionResultsWrapper) is False:\n        raise TypeError('result must be instance of statsmodels.regression.linear_model.RegressionResultsWrapper object')\n    self.results = maybe_unwrap_results(results)\n    self.y_true = self.results.model.endog\n    self.y_predict = self.results.fittedvalues\n    self.xvar = self.results.model.exog\n    self.xvar_names = self.results.model.exog_names\n    self.residual = np.array(self.results.resid)\n    influence = self.results.get_influence()\n    self.residual_norm = influence.resid_studentized_internal\n    self.leverage = influence.hat_matrix_diag\n    self.cooks_distance = influence.cooks_distance[0]\n    self.nparams = len(self.results.params)"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, plot_context='seaborn-paper'):\n    with plt.style.context(plot_context):\n        (fig, ax) = plt.subplots(nrows=2, ncols=2, figsize=(10, 10))\n        self.residual_plot(ax=ax[0, 0])\n        self.qq_plot(ax=ax[0, 1])\n        self.scale_location_plot(ax=ax[1, 0])\n        self.leverage_plot(ax=ax[1, 1])\n        plt.show()\n    self.vif_table()\n    return (fig, ax)",
        "mutated": [
            "def __call__(self, plot_context='seaborn-paper'):\n    if False:\n        i = 10\n    with plt.style.context(plot_context):\n        (fig, ax) = plt.subplots(nrows=2, ncols=2, figsize=(10, 10))\n        self.residual_plot(ax=ax[0, 0])\n        self.qq_plot(ax=ax[0, 1])\n        self.scale_location_plot(ax=ax[1, 0])\n        self.leverage_plot(ax=ax[1, 1])\n        plt.show()\n    self.vif_table()\n    return (fig, ax)",
            "def __call__(self, plot_context='seaborn-paper'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with plt.style.context(plot_context):\n        (fig, ax) = plt.subplots(nrows=2, ncols=2, figsize=(10, 10))\n        self.residual_plot(ax=ax[0, 0])\n        self.qq_plot(ax=ax[0, 1])\n        self.scale_location_plot(ax=ax[1, 0])\n        self.leverage_plot(ax=ax[1, 1])\n        plt.show()\n    self.vif_table()\n    return (fig, ax)",
            "def __call__(self, plot_context='seaborn-paper'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with plt.style.context(plot_context):\n        (fig, ax) = plt.subplots(nrows=2, ncols=2, figsize=(10, 10))\n        self.residual_plot(ax=ax[0, 0])\n        self.qq_plot(ax=ax[0, 1])\n        self.scale_location_plot(ax=ax[1, 0])\n        self.leverage_plot(ax=ax[1, 1])\n        plt.show()\n    self.vif_table()\n    return (fig, ax)",
            "def __call__(self, plot_context='seaborn-paper'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with plt.style.context(plot_context):\n        (fig, ax) = plt.subplots(nrows=2, ncols=2, figsize=(10, 10))\n        self.residual_plot(ax=ax[0, 0])\n        self.qq_plot(ax=ax[0, 1])\n        self.scale_location_plot(ax=ax[1, 0])\n        self.leverage_plot(ax=ax[1, 1])\n        plt.show()\n    self.vif_table()\n    return (fig, ax)",
            "def __call__(self, plot_context='seaborn-paper'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with plt.style.context(plot_context):\n        (fig, ax) = plt.subplots(nrows=2, ncols=2, figsize=(10, 10))\n        self.residual_plot(ax=ax[0, 0])\n        self.qq_plot(ax=ax[0, 1])\n        self.scale_location_plot(ax=ax[1, 0])\n        self.leverage_plot(ax=ax[1, 1])\n        plt.show()\n    self.vif_table()\n    return (fig, ax)"
        ]
    },
    {
        "func_name": "residual_plot",
        "original": "def residual_plot(self, ax=None):\n    \"\"\"\n        Residual vs Fitted Plot\n\n        Graphical tool to identify non-linearity.\n        (Roughly) Horizontal red line is an indicator that the residual has a linear pattern\n        \"\"\"\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    sns.residplot(x=self.y_predict, y=self.residual, lowess=True, scatter_kws={'alpha': 0.5}, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    residual_abs = np.abs(self.residual)\n    abs_resid = np.flip(np.sort(residual_abs))\n    abs_resid_top_3 = abs_resid[:3]\n    for (i, _) in enumerate(abs_resid_top_3):\n        ax.annotate(i, xy=(self.y_predict[i], self.residual[i]), color='C3')\n    ax.set_title('Residuals vs Fitted', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('Residuals')\n    return ax",
        "mutated": [
            "def residual_plot(self, ax=None):\n    if False:\n        i = 10\n    '\\n        Residual vs Fitted Plot\\n\\n        Graphical tool to identify non-linearity.\\n        (Roughly) Horizontal red line is an indicator that the residual has a linear pattern\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    sns.residplot(x=self.y_predict, y=self.residual, lowess=True, scatter_kws={'alpha': 0.5}, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    residual_abs = np.abs(self.residual)\n    abs_resid = np.flip(np.sort(residual_abs))\n    abs_resid_top_3 = abs_resid[:3]\n    for (i, _) in enumerate(abs_resid_top_3):\n        ax.annotate(i, xy=(self.y_predict[i], self.residual[i]), color='C3')\n    ax.set_title('Residuals vs Fitted', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('Residuals')\n    return ax",
            "def residual_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Residual vs Fitted Plot\\n\\n        Graphical tool to identify non-linearity.\\n        (Roughly) Horizontal red line is an indicator that the residual has a linear pattern\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    sns.residplot(x=self.y_predict, y=self.residual, lowess=True, scatter_kws={'alpha': 0.5}, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    residual_abs = np.abs(self.residual)\n    abs_resid = np.flip(np.sort(residual_abs))\n    abs_resid_top_3 = abs_resid[:3]\n    for (i, _) in enumerate(abs_resid_top_3):\n        ax.annotate(i, xy=(self.y_predict[i], self.residual[i]), color='C3')\n    ax.set_title('Residuals vs Fitted', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('Residuals')\n    return ax",
            "def residual_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Residual vs Fitted Plot\\n\\n        Graphical tool to identify non-linearity.\\n        (Roughly) Horizontal red line is an indicator that the residual has a linear pattern\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    sns.residplot(x=self.y_predict, y=self.residual, lowess=True, scatter_kws={'alpha': 0.5}, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    residual_abs = np.abs(self.residual)\n    abs_resid = np.flip(np.sort(residual_abs))\n    abs_resid_top_3 = abs_resid[:3]\n    for (i, _) in enumerate(abs_resid_top_3):\n        ax.annotate(i, xy=(self.y_predict[i], self.residual[i]), color='C3')\n    ax.set_title('Residuals vs Fitted', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('Residuals')\n    return ax",
            "def residual_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Residual vs Fitted Plot\\n\\n        Graphical tool to identify non-linearity.\\n        (Roughly) Horizontal red line is an indicator that the residual has a linear pattern\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    sns.residplot(x=self.y_predict, y=self.residual, lowess=True, scatter_kws={'alpha': 0.5}, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    residual_abs = np.abs(self.residual)\n    abs_resid = np.flip(np.sort(residual_abs))\n    abs_resid_top_3 = abs_resid[:3]\n    for (i, _) in enumerate(abs_resid_top_3):\n        ax.annotate(i, xy=(self.y_predict[i], self.residual[i]), color='C3')\n    ax.set_title('Residuals vs Fitted', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('Residuals')\n    return ax",
            "def residual_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Residual vs Fitted Plot\\n\\n        Graphical tool to identify non-linearity.\\n        (Roughly) Horizontal red line is an indicator that the residual has a linear pattern\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    sns.residplot(x=self.y_predict, y=self.residual, lowess=True, scatter_kws={'alpha': 0.5}, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    residual_abs = np.abs(self.residual)\n    abs_resid = np.flip(np.sort(residual_abs))\n    abs_resid_top_3 = abs_resid[:3]\n    for (i, _) in enumerate(abs_resid_top_3):\n        ax.annotate(i, xy=(self.y_predict[i], self.residual[i]), color='C3')\n    ax.set_title('Residuals vs Fitted', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('Residuals')\n    return ax"
        ]
    },
    {
        "func_name": "qq_plot",
        "original": "def qq_plot(self, ax=None):\n    \"\"\"\n        Standarized Residual vs Theoretical Quantile plot\n\n        Used to visually check if residuals are normally distributed.\n        Points spread along the diagonal line will suggest so.\n        \"\"\"\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    QQ = ProbPlot(self.residual_norm)\n    QQ.qqplot(line='45', alpha=0.5, lw=1, ax=ax)\n    abs_norm_resid = np.flip(np.argsort(np.abs(self.residual_norm)), 0)\n    abs_norm_resid_top_3 = abs_norm_resid[:3]\n    for (r, i) in enumerate(abs_norm_resid_top_3):\n        ax.annotate(i, xy=(np.flip(QQ.theoretical_quantiles, 0)[r], self.residual_norm[i]), ha='right', color='C3')\n    ax.set_title('Normal Q-Q', fontweight='bold')\n    ax.set_xlabel('Theoretical Quantiles')\n    ax.set_ylabel('Standardized Residuals')\n    return ax",
        "mutated": [
            "def qq_plot(self, ax=None):\n    if False:\n        i = 10\n    '\\n        Standarized Residual vs Theoretical Quantile plot\\n\\n        Used to visually check if residuals are normally distributed.\\n        Points spread along the diagonal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    QQ = ProbPlot(self.residual_norm)\n    QQ.qqplot(line='45', alpha=0.5, lw=1, ax=ax)\n    abs_norm_resid = np.flip(np.argsort(np.abs(self.residual_norm)), 0)\n    abs_norm_resid_top_3 = abs_norm_resid[:3]\n    for (r, i) in enumerate(abs_norm_resid_top_3):\n        ax.annotate(i, xy=(np.flip(QQ.theoretical_quantiles, 0)[r], self.residual_norm[i]), ha='right', color='C3')\n    ax.set_title('Normal Q-Q', fontweight='bold')\n    ax.set_xlabel('Theoretical Quantiles')\n    ax.set_ylabel('Standardized Residuals')\n    return ax",
            "def qq_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Standarized Residual vs Theoretical Quantile plot\\n\\n        Used to visually check if residuals are normally distributed.\\n        Points spread along the diagonal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    QQ = ProbPlot(self.residual_norm)\n    QQ.qqplot(line='45', alpha=0.5, lw=1, ax=ax)\n    abs_norm_resid = np.flip(np.argsort(np.abs(self.residual_norm)), 0)\n    abs_norm_resid_top_3 = abs_norm_resid[:3]\n    for (r, i) in enumerate(abs_norm_resid_top_3):\n        ax.annotate(i, xy=(np.flip(QQ.theoretical_quantiles, 0)[r], self.residual_norm[i]), ha='right', color='C3')\n    ax.set_title('Normal Q-Q', fontweight='bold')\n    ax.set_xlabel('Theoretical Quantiles')\n    ax.set_ylabel('Standardized Residuals')\n    return ax",
            "def qq_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Standarized Residual vs Theoretical Quantile plot\\n\\n        Used to visually check if residuals are normally distributed.\\n        Points spread along the diagonal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    QQ = ProbPlot(self.residual_norm)\n    QQ.qqplot(line='45', alpha=0.5, lw=1, ax=ax)\n    abs_norm_resid = np.flip(np.argsort(np.abs(self.residual_norm)), 0)\n    abs_norm_resid_top_3 = abs_norm_resid[:3]\n    for (r, i) in enumerate(abs_norm_resid_top_3):\n        ax.annotate(i, xy=(np.flip(QQ.theoretical_quantiles, 0)[r], self.residual_norm[i]), ha='right', color='C3')\n    ax.set_title('Normal Q-Q', fontweight='bold')\n    ax.set_xlabel('Theoretical Quantiles')\n    ax.set_ylabel('Standardized Residuals')\n    return ax",
            "def qq_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Standarized Residual vs Theoretical Quantile plot\\n\\n        Used to visually check if residuals are normally distributed.\\n        Points spread along the diagonal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    QQ = ProbPlot(self.residual_norm)\n    QQ.qqplot(line='45', alpha=0.5, lw=1, ax=ax)\n    abs_norm_resid = np.flip(np.argsort(np.abs(self.residual_norm)), 0)\n    abs_norm_resid_top_3 = abs_norm_resid[:3]\n    for (r, i) in enumerate(abs_norm_resid_top_3):\n        ax.annotate(i, xy=(np.flip(QQ.theoretical_quantiles, 0)[r], self.residual_norm[i]), ha='right', color='C3')\n    ax.set_title('Normal Q-Q', fontweight='bold')\n    ax.set_xlabel('Theoretical Quantiles')\n    ax.set_ylabel('Standardized Residuals')\n    return ax",
            "def qq_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Standarized Residual vs Theoretical Quantile plot\\n\\n        Used to visually check if residuals are normally distributed.\\n        Points spread along the diagonal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    QQ = ProbPlot(self.residual_norm)\n    QQ.qqplot(line='45', alpha=0.5, lw=1, ax=ax)\n    abs_norm_resid = np.flip(np.argsort(np.abs(self.residual_norm)), 0)\n    abs_norm_resid_top_3 = abs_norm_resid[:3]\n    for (r, i) in enumerate(abs_norm_resid_top_3):\n        ax.annotate(i, xy=(np.flip(QQ.theoretical_quantiles, 0)[r], self.residual_norm[i]), ha='right', color='C3')\n    ax.set_title('Normal Q-Q', fontweight='bold')\n    ax.set_xlabel('Theoretical Quantiles')\n    ax.set_ylabel('Standardized Residuals')\n    return ax"
        ]
    },
    {
        "func_name": "scale_location_plot",
        "original": "def scale_location_plot(self, ax=None):\n    \"\"\"\n        Sqrt(Standarized Residual) vs Fitted values plot\n\n        Used to check homoscedasticity of the residuals.\n        Horizontal line will suggest so.\n        \"\"\"\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    residual_norm_abs_sqrt = np.sqrt(np.abs(self.residual_norm))\n    ax.scatter(self.y_predict, residual_norm_abs_sqrt, alpha=0.5)\n    sns.regplot(x=self.y_predict, y=residual_norm_abs_sqrt, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    abs_sq_norm_resid = np.flip(np.argsort(residual_norm_abs_sqrt), 0)\n    abs_sq_norm_resid_top_3 = abs_sq_norm_resid[:3]\n    for i in abs_sq_norm_resid_top_3:\n        ax.annotate(i, xy=(self.y_predict[i], residual_norm_abs_sqrt[i]), color='C3')\n    ax.set_title('Scale-Location', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('$\\\\sqrt{|\\\\mathrm{Standardized\\\\ Residuals}|}$')\n    return ax",
        "mutated": [
            "def scale_location_plot(self, ax=None):\n    if False:\n        i = 10\n    '\\n        Sqrt(Standarized Residual) vs Fitted values plot\\n\\n        Used to check homoscedasticity of the residuals.\\n        Horizontal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    residual_norm_abs_sqrt = np.sqrt(np.abs(self.residual_norm))\n    ax.scatter(self.y_predict, residual_norm_abs_sqrt, alpha=0.5)\n    sns.regplot(x=self.y_predict, y=residual_norm_abs_sqrt, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    abs_sq_norm_resid = np.flip(np.argsort(residual_norm_abs_sqrt), 0)\n    abs_sq_norm_resid_top_3 = abs_sq_norm_resid[:3]\n    for i in abs_sq_norm_resid_top_3:\n        ax.annotate(i, xy=(self.y_predict[i], residual_norm_abs_sqrt[i]), color='C3')\n    ax.set_title('Scale-Location', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('$\\\\sqrt{|\\\\mathrm{Standardized\\\\ Residuals}|}$')\n    return ax",
            "def scale_location_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Sqrt(Standarized Residual) vs Fitted values plot\\n\\n        Used to check homoscedasticity of the residuals.\\n        Horizontal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    residual_norm_abs_sqrt = np.sqrt(np.abs(self.residual_norm))\n    ax.scatter(self.y_predict, residual_norm_abs_sqrt, alpha=0.5)\n    sns.regplot(x=self.y_predict, y=residual_norm_abs_sqrt, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    abs_sq_norm_resid = np.flip(np.argsort(residual_norm_abs_sqrt), 0)\n    abs_sq_norm_resid_top_3 = abs_sq_norm_resid[:3]\n    for i in abs_sq_norm_resid_top_3:\n        ax.annotate(i, xy=(self.y_predict[i], residual_norm_abs_sqrt[i]), color='C3')\n    ax.set_title('Scale-Location', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('$\\\\sqrt{|\\\\mathrm{Standardized\\\\ Residuals}|}$')\n    return ax",
            "def scale_location_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Sqrt(Standarized Residual) vs Fitted values plot\\n\\n        Used to check homoscedasticity of the residuals.\\n        Horizontal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    residual_norm_abs_sqrt = np.sqrt(np.abs(self.residual_norm))\n    ax.scatter(self.y_predict, residual_norm_abs_sqrt, alpha=0.5)\n    sns.regplot(x=self.y_predict, y=residual_norm_abs_sqrt, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    abs_sq_norm_resid = np.flip(np.argsort(residual_norm_abs_sqrt), 0)\n    abs_sq_norm_resid_top_3 = abs_sq_norm_resid[:3]\n    for i in abs_sq_norm_resid_top_3:\n        ax.annotate(i, xy=(self.y_predict[i], residual_norm_abs_sqrt[i]), color='C3')\n    ax.set_title('Scale-Location', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('$\\\\sqrt{|\\\\mathrm{Standardized\\\\ Residuals}|}$')\n    return ax",
            "def scale_location_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Sqrt(Standarized Residual) vs Fitted values plot\\n\\n        Used to check homoscedasticity of the residuals.\\n        Horizontal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    residual_norm_abs_sqrt = np.sqrt(np.abs(self.residual_norm))\n    ax.scatter(self.y_predict, residual_norm_abs_sqrt, alpha=0.5)\n    sns.regplot(x=self.y_predict, y=residual_norm_abs_sqrt, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    abs_sq_norm_resid = np.flip(np.argsort(residual_norm_abs_sqrt), 0)\n    abs_sq_norm_resid_top_3 = abs_sq_norm_resid[:3]\n    for i in abs_sq_norm_resid_top_3:\n        ax.annotate(i, xy=(self.y_predict[i], residual_norm_abs_sqrt[i]), color='C3')\n    ax.set_title('Scale-Location', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('$\\\\sqrt{|\\\\mathrm{Standardized\\\\ Residuals}|}$')\n    return ax",
            "def scale_location_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Sqrt(Standarized Residual) vs Fitted values plot\\n\\n        Used to check homoscedasticity of the residuals.\\n        Horizontal line will suggest so.\\n        '\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    residual_norm_abs_sqrt = np.sqrt(np.abs(self.residual_norm))\n    ax.scatter(self.y_predict, residual_norm_abs_sqrt, alpha=0.5)\n    sns.regplot(x=self.y_predict, y=residual_norm_abs_sqrt, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    abs_sq_norm_resid = np.flip(np.argsort(residual_norm_abs_sqrt), 0)\n    abs_sq_norm_resid_top_3 = abs_sq_norm_resid[:3]\n    for i in abs_sq_norm_resid_top_3:\n        ax.annotate(i, xy=(self.y_predict[i], residual_norm_abs_sqrt[i]), color='C3')\n    ax.set_title('Scale-Location', fontweight='bold')\n    ax.set_xlabel('Fitted values')\n    ax.set_ylabel('$\\\\sqrt{|\\\\mathrm{Standardized\\\\ Residuals}|}$')\n    return ax"
        ]
    },
    {
        "func_name": "leverage_plot",
        "original": "def leverage_plot(self, ax=None):\n    \"\"\"\n        Residual vs Leverage plot\n\n        Points falling outside Cook's distance curves are considered observation that can sway the fit\n        aka are influential.\n        Good to have none outside the curves.\n        \"\"\"\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    ax.scatter(self.leverage, self.residual_norm, alpha=0.5)\n    sns.regplot(x=self.leverage, y=self.residual_norm, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    leverage_top_3 = np.flip(np.argsort(self.cooks_distance), 0)[:3]\n    for i in leverage_top_3:\n        ax.annotate(i, xy=(self.leverage[i], self.residual_norm[i]), color='C3')\n    (xtemp, ytemp) = self.__cooks_dist_line(0.5)\n    ax.plot(xtemp, ytemp, label=\"Cook's distance\", lw=1, ls='--', color='red')\n    (xtemp, ytemp) = self.__cooks_dist_line(1)\n    ax.plot(xtemp, ytemp, lw=1, ls='--', color='red')\n    ax.set_xlim(0, max(self.leverage) + 0.01)\n    ax.set_title('Residuals vs Leverage', fontweight='bold')\n    ax.set_xlabel('Leverage')\n    ax.set_ylabel('Standardized Residuals')\n    ax.legend(loc='upper right')\n    return ax",
        "mutated": [
            "def leverage_plot(self, ax=None):\n    if False:\n        i = 10\n    \"\\n        Residual vs Leverage plot\\n\\n        Points falling outside Cook's distance curves are considered observation that can sway the fit\\n        aka are influential.\\n        Good to have none outside the curves.\\n        \"\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    ax.scatter(self.leverage, self.residual_norm, alpha=0.5)\n    sns.regplot(x=self.leverage, y=self.residual_norm, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    leverage_top_3 = np.flip(np.argsort(self.cooks_distance), 0)[:3]\n    for i in leverage_top_3:\n        ax.annotate(i, xy=(self.leverage[i], self.residual_norm[i]), color='C3')\n    (xtemp, ytemp) = self.__cooks_dist_line(0.5)\n    ax.plot(xtemp, ytemp, label=\"Cook's distance\", lw=1, ls='--', color='red')\n    (xtemp, ytemp) = self.__cooks_dist_line(1)\n    ax.plot(xtemp, ytemp, lw=1, ls='--', color='red')\n    ax.set_xlim(0, max(self.leverage) + 0.01)\n    ax.set_title('Residuals vs Leverage', fontweight='bold')\n    ax.set_xlabel('Leverage')\n    ax.set_ylabel('Standardized Residuals')\n    ax.legend(loc='upper right')\n    return ax",
            "def leverage_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Residual vs Leverage plot\\n\\n        Points falling outside Cook's distance curves are considered observation that can sway the fit\\n        aka are influential.\\n        Good to have none outside the curves.\\n        \"\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    ax.scatter(self.leverage, self.residual_norm, alpha=0.5)\n    sns.regplot(x=self.leverage, y=self.residual_norm, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    leverage_top_3 = np.flip(np.argsort(self.cooks_distance), 0)[:3]\n    for i in leverage_top_3:\n        ax.annotate(i, xy=(self.leverage[i], self.residual_norm[i]), color='C3')\n    (xtemp, ytemp) = self.__cooks_dist_line(0.5)\n    ax.plot(xtemp, ytemp, label=\"Cook's distance\", lw=1, ls='--', color='red')\n    (xtemp, ytemp) = self.__cooks_dist_line(1)\n    ax.plot(xtemp, ytemp, lw=1, ls='--', color='red')\n    ax.set_xlim(0, max(self.leverage) + 0.01)\n    ax.set_title('Residuals vs Leverage', fontweight='bold')\n    ax.set_xlabel('Leverage')\n    ax.set_ylabel('Standardized Residuals')\n    ax.legend(loc='upper right')\n    return ax",
            "def leverage_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Residual vs Leverage plot\\n\\n        Points falling outside Cook's distance curves are considered observation that can sway the fit\\n        aka are influential.\\n        Good to have none outside the curves.\\n        \"\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    ax.scatter(self.leverage, self.residual_norm, alpha=0.5)\n    sns.regplot(x=self.leverage, y=self.residual_norm, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    leverage_top_3 = np.flip(np.argsort(self.cooks_distance), 0)[:3]\n    for i in leverage_top_3:\n        ax.annotate(i, xy=(self.leverage[i], self.residual_norm[i]), color='C3')\n    (xtemp, ytemp) = self.__cooks_dist_line(0.5)\n    ax.plot(xtemp, ytemp, label=\"Cook's distance\", lw=1, ls='--', color='red')\n    (xtemp, ytemp) = self.__cooks_dist_line(1)\n    ax.plot(xtemp, ytemp, lw=1, ls='--', color='red')\n    ax.set_xlim(0, max(self.leverage) + 0.01)\n    ax.set_title('Residuals vs Leverage', fontweight='bold')\n    ax.set_xlabel('Leverage')\n    ax.set_ylabel('Standardized Residuals')\n    ax.legend(loc='upper right')\n    return ax",
            "def leverage_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Residual vs Leverage plot\\n\\n        Points falling outside Cook's distance curves are considered observation that can sway the fit\\n        aka are influential.\\n        Good to have none outside the curves.\\n        \"\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    ax.scatter(self.leverage, self.residual_norm, alpha=0.5)\n    sns.regplot(x=self.leverage, y=self.residual_norm, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    leverage_top_3 = np.flip(np.argsort(self.cooks_distance), 0)[:3]\n    for i in leverage_top_3:\n        ax.annotate(i, xy=(self.leverage[i], self.residual_norm[i]), color='C3')\n    (xtemp, ytemp) = self.__cooks_dist_line(0.5)\n    ax.plot(xtemp, ytemp, label=\"Cook's distance\", lw=1, ls='--', color='red')\n    (xtemp, ytemp) = self.__cooks_dist_line(1)\n    ax.plot(xtemp, ytemp, lw=1, ls='--', color='red')\n    ax.set_xlim(0, max(self.leverage) + 0.01)\n    ax.set_title('Residuals vs Leverage', fontweight='bold')\n    ax.set_xlabel('Leverage')\n    ax.set_ylabel('Standardized Residuals')\n    ax.legend(loc='upper right')\n    return ax",
            "def leverage_plot(self, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Residual vs Leverage plot\\n\\n        Points falling outside Cook's distance curves are considered observation that can sway the fit\\n        aka are influential.\\n        Good to have none outside the curves.\\n        \"\n    if ax is None:\n        (fig, ax) = plt.subplots()\n    ax.scatter(self.leverage, self.residual_norm, alpha=0.5)\n    sns.regplot(x=self.leverage, y=self.residual_norm, scatter=False, ci=False, lowess=True, line_kws={'color': 'red', 'lw': 1, 'alpha': 0.8}, ax=ax)\n    leverage_top_3 = np.flip(np.argsort(self.cooks_distance), 0)[:3]\n    for i in leverage_top_3:\n        ax.annotate(i, xy=(self.leverage[i], self.residual_norm[i]), color='C3')\n    (xtemp, ytemp) = self.__cooks_dist_line(0.5)\n    ax.plot(xtemp, ytemp, label=\"Cook's distance\", lw=1, ls='--', color='red')\n    (xtemp, ytemp) = self.__cooks_dist_line(1)\n    ax.plot(xtemp, ytemp, lw=1, ls='--', color='red')\n    ax.set_xlim(0, max(self.leverage) + 0.01)\n    ax.set_title('Residuals vs Leverage', fontweight='bold')\n    ax.set_xlabel('Leverage')\n    ax.set_ylabel('Standardized Residuals')\n    ax.legend(loc='upper right')\n    return ax"
        ]
    },
    {
        "func_name": "vif_table",
        "original": "def vif_table(self):\n    \"\"\"\n        VIF table\n\n        VIF, the variance inflation factor, is a measure of multicollinearity.\n        VIF > 5 for a variable indicates that it is highly collinear with the \n        other input variables.\n        \"\"\"\n    vif_df = pd.DataFrame()\n    vif_df['Features'] = self.xvar_names\n    vif_df['VIF Factor'] = [variance_inflation_factor(self.xvar, i) for i in range(self.xvar.shape[1])]\n    print(vif_df.sort_values('VIF Factor').round(2))",
        "mutated": [
            "def vif_table(self):\n    if False:\n        i = 10\n    '\\n        VIF table\\n\\n        VIF, the variance inflation factor, is a measure of multicollinearity.\\n        VIF > 5 for a variable indicates that it is highly collinear with the \\n        other input variables.\\n        '\n    vif_df = pd.DataFrame()\n    vif_df['Features'] = self.xvar_names\n    vif_df['VIF Factor'] = [variance_inflation_factor(self.xvar, i) for i in range(self.xvar.shape[1])]\n    print(vif_df.sort_values('VIF Factor').round(2))",
            "def vif_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        VIF table\\n\\n        VIF, the variance inflation factor, is a measure of multicollinearity.\\n        VIF > 5 for a variable indicates that it is highly collinear with the \\n        other input variables.\\n        '\n    vif_df = pd.DataFrame()\n    vif_df['Features'] = self.xvar_names\n    vif_df['VIF Factor'] = [variance_inflation_factor(self.xvar, i) for i in range(self.xvar.shape[1])]\n    print(vif_df.sort_values('VIF Factor').round(2))",
            "def vif_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        VIF table\\n\\n        VIF, the variance inflation factor, is a measure of multicollinearity.\\n        VIF > 5 for a variable indicates that it is highly collinear with the \\n        other input variables.\\n        '\n    vif_df = pd.DataFrame()\n    vif_df['Features'] = self.xvar_names\n    vif_df['VIF Factor'] = [variance_inflation_factor(self.xvar, i) for i in range(self.xvar.shape[1])]\n    print(vif_df.sort_values('VIF Factor').round(2))",
            "def vif_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        VIF table\\n\\n        VIF, the variance inflation factor, is a measure of multicollinearity.\\n        VIF > 5 for a variable indicates that it is highly collinear with the \\n        other input variables.\\n        '\n    vif_df = pd.DataFrame()\n    vif_df['Features'] = self.xvar_names\n    vif_df['VIF Factor'] = [variance_inflation_factor(self.xvar, i) for i in range(self.xvar.shape[1])]\n    print(vif_df.sort_values('VIF Factor').round(2))",
            "def vif_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        VIF table\\n\\n        VIF, the variance inflation factor, is a measure of multicollinearity.\\n        VIF > 5 for a variable indicates that it is highly collinear with the \\n        other input variables.\\n        '\n    vif_df = pd.DataFrame()\n    vif_df['Features'] = self.xvar_names\n    vif_df['VIF Factor'] = [variance_inflation_factor(self.xvar, i) for i in range(self.xvar.shape[1])]\n    print(vif_df.sort_values('VIF Factor').round(2))"
        ]
    },
    {
        "func_name": "__cooks_dist_line",
        "original": "def __cooks_dist_line(self, factor):\n    \"\"\"\n        Helper function for plotting Cook's distance curves\n        \"\"\"\n    p = self.nparams\n    formula = lambda x: np.sqrt(factor * p * (1 - x) / x)\n    x = np.linspace(0.001, max(self.leverage), 50)\n    y = formula(x)\n    return (x, y)",
        "mutated": [
            "def __cooks_dist_line(self, factor):\n    if False:\n        i = 10\n    \"\\n        Helper function for plotting Cook's distance curves\\n        \"\n    p = self.nparams\n    formula = lambda x: np.sqrt(factor * p * (1 - x) / x)\n    x = np.linspace(0.001, max(self.leverage), 50)\n    y = formula(x)\n    return (x, y)",
            "def __cooks_dist_line(self, factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Helper function for plotting Cook's distance curves\\n        \"\n    p = self.nparams\n    formula = lambda x: np.sqrt(factor * p * (1 - x) / x)\n    x = np.linspace(0.001, max(self.leverage), 50)\n    y = formula(x)\n    return (x, y)",
            "def __cooks_dist_line(self, factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Helper function for plotting Cook's distance curves\\n        \"\n    p = self.nparams\n    formula = lambda x: np.sqrt(factor * p * (1 - x) / x)\n    x = np.linspace(0.001, max(self.leverage), 50)\n    y = formula(x)\n    return (x, y)",
            "def __cooks_dist_line(self, factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Helper function for plotting Cook's distance curves\\n        \"\n    p = self.nparams\n    formula = lambda x: np.sqrt(factor * p * (1 - x) / x)\n    x = np.linspace(0.001, max(self.leverage), 50)\n    y = formula(x)\n    return (x, y)",
            "def __cooks_dist_line(self, factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Helper function for plotting Cook's distance curves\\n        \"\n    p = self.nparams\n    formula = lambda x: np.sqrt(factor * p * (1 - x) / x)\n    x = np.linspace(0.001, max(self.leverage), 50)\n    y = formula(x)\n    return (x, y)"
        ]
    }
]