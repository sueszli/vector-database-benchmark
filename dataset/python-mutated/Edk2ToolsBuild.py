import os
import sys
import logging
import argparse
import multiprocessing
from edk2toolext import edk2_logging
from edk2toolext.environment import self_describing_environment
from edk2toolext.base_abstract_invocable import BaseAbstractInvocable
from edk2toollib.utility_functions import RunCmd
from edk2toollib.windows.locate_tools import QueryVcVariables

class Edk2ToolsBuild(BaseAbstractInvocable):

    def ParseCommandLineOptions(self):
        if False:
            print('Hello World!')
        ' parse arguments '
        ParserObj = argparse.ArgumentParser()
        ParserObj.add_argument('-t', '--tool_chain_tag', dest='tct', default='VS2017', help='Set the toolchain used to compile the build tools')
        args = ParserObj.parse_args()
        self.tool_chain_tag = args.tct

    def GetWorkspaceRoot(self):
        if False:
            for i in range(10):
                print('nop')
        ' Return the workspace root for initializing the SDE '
        return os.path.dirname(os.path.abspath(__file__))

    def GetActiveScopes(self):
        if False:
            while True:
                i = 10
        ' return tuple containing scopes that should be active for this process '
        return ('global',)

    def GetLoggingLevel(self, loggerType):
        if False:
            print('Hello World!')
        ' Get the logging level for a given type (return Logging.Level)\n        base == lowest logging level supported\n        con  == Screen logging\n        txt  == plain text file logging\n        md   == markdown file logging\n        '
        if loggerType == 'con':
            return logging.ERROR
        else:
            return logging.DEBUG

    def GetLoggingFolderRelativeToRoot(self):
        if False:
            i = 10
            return i + 15
        ' Return a path to folder for log files '
        return 'BaseToolsBuild'

    def GetVerifyCheckRequired(self):
        if False:
            return 10
        ' Will call self_describing_environment.VerifyEnvironment if this returns True '
        return True

    def GetLoggingFileName(self, loggerType):
        if False:
            i = 10
            return i + 15
        " Get the logging file name for the type.\n        Return None if the logger shouldn't be created\n\n        base == lowest logging level supported\n        con  == Screen logging\n        txt  == plain text file logging\n        md   == markdown file logging\n        "
        return 'BASETOOLS_BUILD'

    def WritePathEnvFile(self, OutputDir):
        if False:
            return 10
        ' Write a PyTool path env file for future PyTool based edk2 builds'
        content = '##\n# Set shell variable EDK_TOOLS_BIN to this folder\n#\n# Autogenerated by Edk2ToolsBuild.py\n#\n# Copyright (c), Microsoft Corporation\n# SPDX-License-Identifier: BSD-2-Clause-Patent\n##\n{\n  "id": "You-Built-BaseTools",\n  "scope": "edk2-build",\n  "flags": ["set_shell_var", "set_path"],\n  "var_name": "EDK_TOOLS_BIN"\n}\n'
        with open(os.path.join(OutputDir, 'basetoolsbin_path_env.yaml'), 'w') as f:
            f.write(content)

    def Go(self):
        if False:
            for i in range(10):
                print('nop')
        logging.info('Running Python version: ' + str(sys.version_info))
        (build_env, shell_env) = self_describing_environment.BootstrapEnvironment(self.GetWorkspaceRoot(), self.GetActiveScopes())
        ph = os.path.dirname(sys.executable)
        if ' ' in ph:
            ph = '"' + ph + '"'
        shell_env.set_shell_var('PYTHON_HOME', ph)
        pc = sys.executable
        if ' ' in pc:
            pc = '"' + pc + '"'
        shell_env.set_shell_var('PYTHON_COMMAND', pc)
        if self.tool_chain_tag.lower().startswith('vs'):
            interesting_keys = ['ExtensionSdkDir', 'INCLUDE', 'LIB']
            interesting_keys.extend(['LIBPATH', 'Path', 'UniversalCRTSdkDir', 'UCRTVersion', 'WindowsLibPath', 'WindowsSdkBinPath'])
            interesting_keys.extend(['WindowsSdkDir', 'WindowsSdkVerBinPath', 'WindowsSDKVersion', 'VCToolsInstallDir'])
            vc_vars = QueryVcVariables(interesting_keys, 'x86', vs_version=self.tool_chain_tag.lower())
            for key in vc_vars.keys():
                logging.debug(f'Var - {key} = {vc_vars[key]}')
                if key.lower() == 'path':
                    shell_env.set_path(vc_vars[key])
                else:
                    shell_env.set_shell_var(key, vc_vars[key])
            self.OutputDir = os.path.join(shell_env.get_shell_var('EDK_TOOLS_PATH'), 'Bin', 'Win32')
            shell_env.insert_path(self.OutputDir)
            output_stream = edk2_logging.create_output_stream()
            ret = RunCmd('nmake.exe', None, workingdir=shell_env.get_shell_var('EDK_TOOLS_PATH'))
            edk2_logging.remove_output_stream(output_stream)
            problems = edk2_logging.scan_compiler_output(output_stream)
            for (level, problem) in problems:
                logging.log(level, problem)
            if ret != 0:
                raise Exception('Failed to build.')
            self.WritePathEnvFile(self.OutputDir)
            return ret
        elif self.tool_chain_tag.lower().startswith('gcc'):
            cpu_count = self.GetCpuThreads()
            output_stream = edk2_logging.create_output_stream()
            ret = RunCmd('make', f'-C .  -j {cpu_count}', workingdir=shell_env.get_shell_var('EDK_TOOLS_PATH'))
            edk2_logging.remove_output_stream(output_stream)
            problems = edk2_logging.scan_compiler_output(output_stream)
            for (level, problem) in problems:
                logging.log(level, problem)
            if ret != 0:
                raise Exception('Failed to build.')
            self.OutputDir = os.path.join(shell_env.get_shell_var('EDK_TOOLS_PATH'), 'Source', 'C', 'bin')
            self.WritePathEnvFile(self.OutputDir)
            return ret
        logging.critical('Tool Chain not supported')
        return -1

    def GetCpuThreads(self) -> int:
        if False:
            while True:
                i = 10
        ' Function to return number of cpus. If error return 1'
        cpus = 1
        try:
            cpus = multiprocessing.cpu_count()
        except:
            pass
        return cpus

def main():
    if False:
        i = 10
        return i + 15
    Edk2ToolsBuild().Invoke()
if __name__ == '__main__':
    main()