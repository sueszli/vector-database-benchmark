[
    {
        "func_name": "SignPayloadSignTool",
        "original": "def SignPayloadSignTool(Payload, ToolPath, PfxFile, SubjectName, Verbose=False):\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'signtool.exe'))\n    Command = Command + 'sign /fd sha256 /p7ce DetachedSignedData /p7co 1.2.840.113549.1.7.2 '\n    Command = Command + '/p7 {TempDir} '.format(TempDir=TempDirectoryName)\n    if PfxFile is not None:\n        Command = Command + '/f {PfxFile} '.format(PfxFile=PfxFile)\n    if SubjectName is not None:\n        Command = Command + '/n {SubjectName} '.format(SubjectName=SubjectName)\n    Command = Command + TempFileName\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate('')\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run signtool.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: signtool failed.')\n    try:\n        with open(TempFileName + '.p7', 'rb') as File:\n            Signature = File.read()\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not read signature file.')\n    shutil.rmtree(TempDirectoryName)\n    return Signature",
        "mutated": [
            "def SignPayloadSignTool(Payload, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'signtool.exe'))\n    Command = Command + 'sign /fd sha256 /p7ce DetachedSignedData /p7co 1.2.840.113549.1.7.2 '\n    Command = Command + '/p7 {TempDir} '.format(TempDir=TempDirectoryName)\n    if PfxFile is not None:\n        Command = Command + '/f {PfxFile} '.format(PfxFile=PfxFile)\n    if SubjectName is not None:\n        Command = Command + '/n {SubjectName} '.format(SubjectName=SubjectName)\n    Command = Command + TempFileName\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate('')\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run signtool.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: signtool failed.')\n    try:\n        with open(TempFileName + '.p7', 'rb') as File:\n            Signature = File.read()\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not read signature file.')\n    shutil.rmtree(TempDirectoryName)\n    return Signature",
            "def SignPayloadSignTool(Payload, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'signtool.exe'))\n    Command = Command + 'sign /fd sha256 /p7ce DetachedSignedData /p7co 1.2.840.113549.1.7.2 '\n    Command = Command + '/p7 {TempDir} '.format(TempDir=TempDirectoryName)\n    if PfxFile is not None:\n        Command = Command + '/f {PfxFile} '.format(PfxFile=PfxFile)\n    if SubjectName is not None:\n        Command = Command + '/n {SubjectName} '.format(SubjectName=SubjectName)\n    Command = Command + TempFileName\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate('')\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run signtool.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: signtool failed.')\n    try:\n        with open(TempFileName + '.p7', 'rb') as File:\n            Signature = File.read()\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not read signature file.')\n    shutil.rmtree(TempDirectoryName)\n    return Signature",
            "def SignPayloadSignTool(Payload, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'signtool.exe'))\n    Command = Command + 'sign /fd sha256 /p7ce DetachedSignedData /p7co 1.2.840.113549.1.7.2 '\n    Command = Command + '/p7 {TempDir} '.format(TempDir=TempDirectoryName)\n    if PfxFile is not None:\n        Command = Command + '/f {PfxFile} '.format(PfxFile=PfxFile)\n    if SubjectName is not None:\n        Command = Command + '/n {SubjectName} '.format(SubjectName=SubjectName)\n    Command = Command + TempFileName\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate('')\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run signtool.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: signtool failed.')\n    try:\n        with open(TempFileName + '.p7', 'rb') as File:\n            Signature = File.read()\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not read signature file.')\n    shutil.rmtree(TempDirectoryName)\n    return Signature",
            "def SignPayloadSignTool(Payload, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'signtool.exe'))\n    Command = Command + 'sign /fd sha256 /p7ce DetachedSignedData /p7co 1.2.840.113549.1.7.2 '\n    Command = Command + '/p7 {TempDir} '.format(TempDir=TempDirectoryName)\n    if PfxFile is not None:\n        Command = Command + '/f {PfxFile} '.format(PfxFile=PfxFile)\n    if SubjectName is not None:\n        Command = Command + '/n {SubjectName} '.format(SubjectName=SubjectName)\n    Command = Command + TempFileName\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate('')\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run signtool.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: signtool failed.')\n    try:\n        with open(TempFileName + '.p7', 'rb') as File:\n            Signature = File.read()\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not read signature file.')\n    shutil.rmtree(TempDirectoryName)\n    return Signature",
            "def SignPayloadSignTool(Payload, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'signtool.exe'))\n    Command = Command + 'sign /fd sha256 /p7ce DetachedSignedData /p7co 1.2.840.113549.1.7.2 '\n    Command = Command + '/p7 {TempDir} '.format(TempDir=TempDirectoryName)\n    if PfxFile is not None:\n        Command = Command + '/f {PfxFile} '.format(PfxFile=PfxFile)\n    if SubjectName is not None:\n        Command = Command + '/n {SubjectName} '.format(SubjectName=SubjectName)\n    Command = Command + TempFileName\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate('')\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run signtool.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: signtool failed.')\n    try:\n        with open(TempFileName + '.p7', 'rb') as File:\n            Signature = File.read()\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not read signature file.')\n    shutil.rmtree(TempDirectoryName)\n    return Signature"
        ]
    },
    {
        "func_name": "VerifyPayloadSignTool",
        "original": "def VerifyPayloadSignTool(Payload, CertData, ToolPath, PfxFile, SubjectName, Verbose=False):\n    print('signtool verify is not supported.')\n    raise ValueError('GenerateCapsule: error: signtool verify is not supported.')",
        "mutated": [
            "def VerifyPayloadSignTool(Payload, CertData, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n    print('signtool verify is not supported.')\n    raise ValueError('GenerateCapsule: error: signtool verify is not supported.')",
            "def VerifyPayloadSignTool(Payload, CertData, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('signtool verify is not supported.')\n    raise ValueError('GenerateCapsule: error: signtool verify is not supported.')",
            "def VerifyPayloadSignTool(Payload, CertData, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('signtool verify is not supported.')\n    raise ValueError('GenerateCapsule: error: signtool verify is not supported.')",
            "def VerifyPayloadSignTool(Payload, CertData, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('signtool verify is not supported.')\n    raise ValueError('GenerateCapsule: error: signtool verify is not supported.')",
            "def VerifyPayloadSignTool(Payload, CertData, ToolPath, PfxFile, SubjectName, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('signtool verify is not supported.')\n    raise ValueError('GenerateCapsule: error: signtool verify is not supported.')"
        ]
    },
    {
        "func_name": "SignPayloadOpenSsl",
        "original": "def SignPayloadOpenSsl(Payload, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -sign -binary -outform DER -md sha256 '\n    Command = Command + '-signer \"{Private}\" -certfile \"{Public}\"'.format(Private=SignerPrivateCertFile, Public=OtherPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=Payload)\n        Signature = Result[0]\n    except:\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    return Signature",
        "mutated": [
            "def SignPayloadOpenSsl(Payload, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -sign -binary -outform DER -md sha256 '\n    Command = Command + '-signer \"{Private}\" -certfile \"{Public}\"'.format(Private=SignerPrivateCertFile, Public=OtherPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=Payload)\n        Signature = Result[0]\n    except:\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    return Signature",
            "def SignPayloadOpenSsl(Payload, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -sign -binary -outform DER -md sha256 '\n    Command = Command + '-signer \"{Private}\" -certfile \"{Public}\"'.format(Private=SignerPrivateCertFile, Public=OtherPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=Payload)\n        Signature = Result[0]\n    except:\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    return Signature",
            "def SignPayloadOpenSsl(Payload, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -sign -binary -outform DER -md sha256 '\n    Command = Command + '-signer \"{Private}\" -certfile \"{Public}\"'.format(Private=SignerPrivateCertFile, Public=OtherPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=Payload)\n        Signature = Result[0]\n    except:\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    return Signature",
            "def SignPayloadOpenSsl(Payload, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -sign -binary -outform DER -md sha256 '\n    Command = Command + '-signer \"{Private}\" -certfile \"{Public}\"'.format(Private=SignerPrivateCertFile, Public=OtherPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=Payload)\n        Signature = Result[0]\n    except:\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    return Signature",
            "def SignPayloadOpenSsl(Payload, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -sign -binary -outform DER -md sha256 '\n    Command = Command + '-signer \"{Private}\" -certfile \"{Public}\"'.format(Private=SignerPrivateCertFile, Public=OtherPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=Payload)\n        Signature = Result[0]\n    except:\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    return Signature"
        ]
    },
    {
        "func_name": "VerifyPayloadOpenSsl",
        "original": "def VerifyPayloadOpenSsl(Payload, CertData, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -verify -inform DER '\n    Command = Command + '-content {Content} -CAfile \"{Public}\"'.format(Content=TempFileName, Public=TrustedPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=CertData)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    shutil.rmtree(TempDirectoryName)\n    return Payload",
        "mutated": [
            "def VerifyPayloadOpenSsl(Payload, CertData, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -verify -inform DER '\n    Command = Command + '-content {Content} -CAfile \"{Public}\"'.format(Content=TempFileName, Public=TrustedPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=CertData)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    shutil.rmtree(TempDirectoryName)\n    return Payload",
            "def VerifyPayloadOpenSsl(Payload, CertData, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -verify -inform DER '\n    Command = Command + '-content {Content} -CAfile \"{Public}\"'.format(Content=TempFileName, Public=TrustedPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=CertData)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    shutil.rmtree(TempDirectoryName)\n    return Payload",
            "def VerifyPayloadOpenSsl(Payload, CertData, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -verify -inform DER '\n    Command = Command + '-content {Content} -CAfile \"{Public}\"'.format(Content=TempFileName, Public=TrustedPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=CertData)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    shutil.rmtree(TempDirectoryName)\n    return Payload",
            "def VerifyPayloadOpenSsl(Payload, CertData, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -verify -inform DER '\n    Command = Command + '-content {Content} -CAfile \"{Public}\"'.format(Content=TempFileName, Public=TrustedPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=CertData)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    shutil.rmtree(TempDirectoryName)\n    return Payload",
            "def VerifyPayloadOpenSsl(Payload, CertData, ToolPath, SignerPrivateCertFile, OtherPublicCertFile, TrustedPublicCertFile, Verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    TempDirectoryName = tempfile.mkdtemp()\n    TempFileName = os.path.join(TempDirectoryName, 'Payload.bin')\n    try:\n        with open(TempFileName, 'wb') as File:\n            File.write(Payload)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not write temporary payload file.')\n    if ToolPath is None:\n        ToolPath = ''\n    Command = ''\n    Command = Command + '\"{Path}\" '.format(Path=os.path.join(ToolPath, 'openssl'))\n    Command = Command + 'smime -verify -inform DER '\n    Command = Command + '-content {Content} -CAfile \"{Public}\"'.format(Content=TempFileName, Public=TrustedPublicCertFile)\n    if Verbose:\n        print(Command)\n    try:\n        Process = subprocess.Popen(Command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        Result = Process.communicate(input=CertData)\n    except:\n        shutil.rmtree(TempDirectoryName)\n        raise ValueError('GenerateCapsule: error: can not run openssl.')\n    if Process.returncode != 0:\n        shutil.rmtree(TempDirectoryName)\n        print(Result[1].decode())\n        raise ValueError('GenerateCapsule: error: openssl failed.')\n    shutil.rmtree(TempDirectoryName)\n    return Payload"
        ]
    },
    {
        "func_name": "convert_arg_line_to_args",
        "original": "def convert_arg_line_to_args(arg_line):\n    for arg in arg_line.split():\n        if not arg.strip():\n            continue\n        yield arg",
        "mutated": [
            "def convert_arg_line_to_args(arg_line):\n    if False:\n        i = 10\n    for arg in arg_line.split():\n        if not arg.strip():\n            continue\n        yield arg",
            "def convert_arg_line_to_args(arg_line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for arg in arg_line.split():\n        if not arg.strip():\n            continue\n        yield arg",
            "def convert_arg_line_to_args(arg_line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for arg in arg_line.split():\n        if not arg.strip():\n            continue\n        yield arg",
            "def convert_arg_line_to_args(arg_line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for arg in arg_line.split():\n        if not arg.strip():\n            continue\n        yield arg",
            "def convert_arg_line_to_args(arg_line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for arg in arg_line.split():\n        if not arg.strip():\n            continue\n        yield arg"
        ]
    },
    {
        "func_name": "ValidateUnsignedInteger",
        "original": "def ValidateUnsignedInteger(Argument):\n    try:\n        Value = int(Argument, 0)\n    except:\n        Message = '{Argument} is not a valid integer value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    if Value < 0:\n        Message = '{Argument} is a negative value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
        "mutated": [
            "def ValidateUnsignedInteger(Argument):\n    if False:\n        i = 10\n    try:\n        Value = int(Argument, 0)\n    except:\n        Message = '{Argument} is not a valid integer value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    if Value < 0:\n        Message = '{Argument} is a negative value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
            "def ValidateUnsignedInteger(Argument):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        Value = int(Argument, 0)\n    except:\n        Message = '{Argument} is not a valid integer value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    if Value < 0:\n        Message = '{Argument} is a negative value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
            "def ValidateUnsignedInteger(Argument):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        Value = int(Argument, 0)\n    except:\n        Message = '{Argument} is not a valid integer value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    if Value < 0:\n        Message = '{Argument} is a negative value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
            "def ValidateUnsignedInteger(Argument):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        Value = int(Argument, 0)\n    except:\n        Message = '{Argument} is not a valid integer value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    if Value < 0:\n        Message = '{Argument} is a negative value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
            "def ValidateUnsignedInteger(Argument):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        Value = int(Argument, 0)\n    except:\n        Message = '{Argument} is not a valid integer value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    if Value < 0:\n        Message = '{Argument} is a negative value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value"
        ]
    },
    {
        "func_name": "ValidateRegistryFormatGuid",
        "original": "def ValidateRegistryFormatGuid(Argument):\n    try:\n        Value = uuid.UUID(Argument)\n    except:\n        Message = '{Argument} is not a valid registry format GUID value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
        "mutated": [
            "def ValidateRegistryFormatGuid(Argument):\n    if False:\n        i = 10\n    try:\n        Value = uuid.UUID(Argument)\n    except:\n        Message = '{Argument} is not a valid registry format GUID value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
            "def ValidateRegistryFormatGuid(Argument):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        Value = uuid.UUID(Argument)\n    except:\n        Message = '{Argument} is not a valid registry format GUID value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
            "def ValidateRegistryFormatGuid(Argument):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        Value = uuid.UUID(Argument)\n    except:\n        Message = '{Argument} is not a valid registry format GUID value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
            "def ValidateRegistryFormatGuid(Argument):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        Value = uuid.UUID(Argument)\n    except:\n        Message = '{Argument} is not a valid registry format GUID value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value",
            "def ValidateRegistryFormatGuid(Argument):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        Value = uuid.UUID(Argument)\n    except:\n        Message = '{Argument} is not a valid registry format GUID value.'.format(Argument=Argument)\n        raise argparse.ArgumentTypeError(Message)\n    return Value"
        ]
    },
    {
        "func_name": "ConvertJsonValue",
        "original": "def ConvertJsonValue(Config, FieldName, Convert, Required=True, Default=None, Open=False):\n    if FieldName not in Config:\n        if Required:\n            print('GenerateCapsule: error: Payload descriptor invalid syntax. Could not find {Key} in payload descriptor.'.format(Key=FieldName))\n            sys.exit(1)\n        return Default\n    try:\n        Value = Convert(Config[FieldName])\n    except:\n        print('GenerateCapsule: error: {Key} in payload descriptor has invalid syntax.'.format(Key=FieldName))\n        sys.exit(1)\n    if Open:\n        try:\n            Value = open(Value, 'rb')\n        except:\n            print('GenerateCapsule: error: can not open file {File}'.format(File=FieldName))\n            sys.exit(1)\n    return Value",
        "mutated": [
            "def ConvertJsonValue(Config, FieldName, Convert, Required=True, Default=None, Open=False):\n    if False:\n        i = 10\n    if FieldName not in Config:\n        if Required:\n            print('GenerateCapsule: error: Payload descriptor invalid syntax. Could not find {Key} in payload descriptor.'.format(Key=FieldName))\n            sys.exit(1)\n        return Default\n    try:\n        Value = Convert(Config[FieldName])\n    except:\n        print('GenerateCapsule: error: {Key} in payload descriptor has invalid syntax.'.format(Key=FieldName))\n        sys.exit(1)\n    if Open:\n        try:\n            Value = open(Value, 'rb')\n        except:\n            print('GenerateCapsule: error: can not open file {File}'.format(File=FieldName))\n            sys.exit(1)\n    return Value",
            "def ConvertJsonValue(Config, FieldName, Convert, Required=True, Default=None, Open=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if FieldName not in Config:\n        if Required:\n            print('GenerateCapsule: error: Payload descriptor invalid syntax. Could not find {Key} in payload descriptor.'.format(Key=FieldName))\n            sys.exit(1)\n        return Default\n    try:\n        Value = Convert(Config[FieldName])\n    except:\n        print('GenerateCapsule: error: {Key} in payload descriptor has invalid syntax.'.format(Key=FieldName))\n        sys.exit(1)\n    if Open:\n        try:\n            Value = open(Value, 'rb')\n        except:\n            print('GenerateCapsule: error: can not open file {File}'.format(File=FieldName))\n            sys.exit(1)\n    return Value",
            "def ConvertJsonValue(Config, FieldName, Convert, Required=True, Default=None, Open=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if FieldName not in Config:\n        if Required:\n            print('GenerateCapsule: error: Payload descriptor invalid syntax. Could not find {Key} in payload descriptor.'.format(Key=FieldName))\n            sys.exit(1)\n        return Default\n    try:\n        Value = Convert(Config[FieldName])\n    except:\n        print('GenerateCapsule: error: {Key} in payload descriptor has invalid syntax.'.format(Key=FieldName))\n        sys.exit(1)\n    if Open:\n        try:\n            Value = open(Value, 'rb')\n        except:\n            print('GenerateCapsule: error: can not open file {File}'.format(File=FieldName))\n            sys.exit(1)\n    return Value",
            "def ConvertJsonValue(Config, FieldName, Convert, Required=True, Default=None, Open=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if FieldName not in Config:\n        if Required:\n            print('GenerateCapsule: error: Payload descriptor invalid syntax. Could not find {Key} in payload descriptor.'.format(Key=FieldName))\n            sys.exit(1)\n        return Default\n    try:\n        Value = Convert(Config[FieldName])\n    except:\n        print('GenerateCapsule: error: {Key} in payload descriptor has invalid syntax.'.format(Key=FieldName))\n        sys.exit(1)\n    if Open:\n        try:\n            Value = open(Value, 'rb')\n        except:\n            print('GenerateCapsule: error: can not open file {File}'.format(File=FieldName))\n            sys.exit(1)\n    return Value",
            "def ConvertJsonValue(Config, FieldName, Convert, Required=True, Default=None, Open=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if FieldName not in Config:\n        if Required:\n            print('GenerateCapsule: error: Payload descriptor invalid syntax. Could not find {Key} in payload descriptor.'.format(Key=FieldName))\n            sys.exit(1)\n        return Default\n    try:\n        Value = Convert(Config[FieldName])\n    except:\n        print('GenerateCapsule: error: {Key} in payload descriptor has invalid syntax.'.format(Key=FieldName))\n        sys.exit(1)\n    if Open:\n        try:\n            Value = open(Value, 'rb')\n        except:\n            print('GenerateCapsule: error: can not open file {File}'.format(File=FieldName))\n            sys.exit(1)\n    return Value"
        ]
    },
    {
        "func_name": "DecodeJsonFileParse",
        "original": "def DecodeJsonFileParse(Json):\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Required=False)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid, Required=False)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger, Required=False)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger, Required=False)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        PayloadDescriptorList.append(PayloadDescriptor(PayloadFile, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath))",
        "mutated": [
            "def DecodeJsonFileParse(Json):\n    if False:\n        i = 10\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Required=False)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid, Required=False)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger, Required=False)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger, Required=False)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        PayloadDescriptorList.append(PayloadDescriptor(PayloadFile, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath))",
            "def DecodeJsonFileParse(Json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Required=False)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid, Required=False)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger, Required=False)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger, Required=False)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        PayloadDescriptorList.append(PayloadDescriptor(PayloadFile, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath))",
            "def DecodeJsonFileParse(Json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Required=False)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid, Required=False)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger, Required=False)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger, Required=False)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        PayloadDescriptorList.append(PayloadDescriptor(PayloadFile, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath))",
            "def DecodeJsonFileParse(Json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Required=False)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid, Required=False)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger, Required=False)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger, Required=False)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        PayloadDescriptorList.append(PayloadDescriptor(PayloadFile, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath))",
            "def DecodeJsonFileParse(Json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Required=False)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid, Required=False)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger, Required=False)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger, Required=False)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        PayloadDescriptorList.append(PayloadDescriptor(PayloadFile, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath))"
        ]
    },
    {
        "func_name": "EncodeJsonFileParse",
        "original": "def EncodeJsonFileParse(Json):\n    if 'EmbeddedDrivers' not in Json:\n        print('GenerateCapsule: warning \"EmbeddedDrivers\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n    else:\n        for Config in Json['EmbeddedDrivers']:\n            EmbeddedDriverFile = ConvertJsonValue(Config, 'Driver', os.path.expandvars, Open=True)\n            try:\n                if args.Verbose:\n                    print('Read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                Driver = EmbeddedDriverFile.read()\n            except:\n                print('GenerateCapsule: error: can not read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                sys.exit(1)\n            EmbeddedDriverDescriptorList.append(Driver)\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error: \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Open=True)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        DepexExp = ConvertJsonValue(Config, 'Dependencies', str, Required=False, Default=None)\n        try:\n            if args.Verbose:\n                print('Read binary input file {File}'.format(File=PayloadFile.name))\n            Payload = PayloadFile.read()\n            PayloadFile.close()\n        except:\n            print('GenerateCapsule: error: can not read binary input file {File}'.format(File=PayloadFile.name))\n            sys.exit(1)\n        PayloadDescriptorList.append(PayloadDescriptor(Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath, DepexExp))",
        "mutated": [
            "def EncodeJsonFileParse(Json):\n    if False:\n        i = 10\n    if 'EmbeddedDrivers' not in Json:\n        print('GenerateCapsule: warning \"EmbeddedDrivers\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n    else:\n        for Config in Json['EmbeddedDrivers']:\n            EmbeddedDriverFile = ConvertJsonValue(Config, 'Driver', os.path.expandvars, Open=True)\n            try:\n                if args.Verbose:\n                    print('Read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                Driver = EmbeddedDriverFile.read()\n            except:\n                print('GenerateCapsule: error: can not read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                sys.exit(1)\n            EmbeddedDriverDescriptorList.append(Driver)\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error: \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Open=True)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        DepexExp = ConvertJsonValue(Config, 'Dependencies', str, Required=False, Default=None)\n        try:\n            if args.Verbose:\n                print('Read binary input file {File}'.format(File=PayloadFile.name))\n            Payload = PayloadFile.read()\n            PayloadFile.close()\n        except:\n            print('GenerateCapsule: error: can not read binary input file {File}'.format(File=PayloadFile.name))\n            sys.exit(1)\n        PayloadDescriptorList.append(PayloadDescriptor(Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath, DepexExp))",
            "def EncodeJsonFileParse(Json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'EmbeddedDrivers' not in Json:\n        print('GenerateCapsule: warning \"EmbeddedDrivers\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n    else:\n        for Config in Json['EmbeddedDrivers']:\n            EmbeddedDriverFile = ConvertJsonValue(Config, 'Driver', os.path.expandvars, Open=True)\n            try:\n                if args.Verbose:\n                    print('Read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                Driver = EmbeddedDriverFile.read()\n            except:\n                print('GenerateCapsule: error: can not read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                sys.exit(1)\n            EmbeddedDriverDescriptorList.append(Driver)\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error: \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Open=True)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        DepexExp = ConvertJsonValue(Config, 'Dependencies', str, Required=False, Default=None)\n        try:\n            if args.Verbose:\n                print('Read binary input file {File}'.format(File=PayloadFile.name))\n            Payload = PayloadFile.read()\n            PayloadFile.close()\n        except:\n            print('GenerateCapsule: error: can not read binary input file {File}'.format(File=PayloadFile.name))\n            sys.exit(1)\n        PayloadDescriptorList.append(PayloadDescriptor(Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath, DepexExp))",
            "def EncodeJsonFileParse(Json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'EmbeddedDrivers' not in Json:\n        print('GenerateCapsule: warning \"EmbeddedDrivers\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n    else:\n        for Config in Json['EmbeddedDrivers']:\n            EmbeddedDriverFile = ConvertJsonValue(Config, 'Driver', os.path.expandvars, Open=True)\n            try:\n                if args.Verbose:\n                    print('Read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                Driver = EmbeddedDriverFile.read()\n            except:\n                print('GenerateCapsule: error: can not read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                sys.exit(1)\n            EmbeddedDriverDescriptorList.append(Driver)\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error: \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Open=True)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        DepexExp = ConvertJsonValue(Config, 'Dependencies', str, Required=False, Default=None)\n        try:\n            if args.Verbose:\n                print('Read binary input file {File}'.format(File=PayloadFile.name))\n            Payload = PayloadFile.read()\n            PayloadFile.close()\n        except:\n            print('GenerateCapsule: error: can not read binary input file {File}'.format(File=PayloadFile.name))\n            sys.exit(1)\n        PayloadDescriptorList.append(PayloadDescriptor(Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath, DepexExp))",
            "def EncodeJsonFileParse(Json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'EmbeddedDrivers' not in Json:\n        print('GenerateCapsule: warning \"EmbeddedDrivers\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n    else:\n        for Config in Json['EmbeddedDrivers']:\n            EmbeddedDriverFile = ConvertJsonValue(Config, 'Driver', os.path.expandvars, Open=True)\n            try:\n                if args.Verbose:\n                    print('Read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                Driver = EmbeddedDriverFile.read()\n            except:\n                print('GenerateCapsule: error: can not read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                sys.exit(1)\n            EmbeddedDriverDescriptorList.append(Driver)\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error: \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Open=True)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        DepexExp = ConvertJsonValue(Config, 'Dependencies', str, Required=False, Default=None)\n        try:\n            if args.Verbose:\n                print('Read binary input file {File}'.format(File=PayloadFile.name))\n            Payload = PayloadFile.read()\n            PayloadFile.close()\n        except:\n            print('GenerateCapsule: error: can not read binary input file {File}'.format(File=PayloadFile.name))\n            sys.exit(1)\n        PayloadDescriptorList.append(PayloadDescriptor(Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath, DepexExp))",
            "def EncodeJsonFileParse(Json):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'EmbeddedDrivers' not in Json:\n        print('GenerateCapsule: warning \"EmbeddedDrivers\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n    else:\n        for Config in Json['EmbeddedDrivers']:\n            EmbeddedDriverFile = ConvertJsonValue(Config, 'Driver', os.path.expandvars, Open=True)\n            try:\n                if args.Verbose:\n                    print('Read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                Driver = EmbeddedDriverFile.read()\n            except:\n                print('GenerateCapsule: error: can not read EmbeddedDriver file {File}'.format(File=EmbeddedDriverFile.name))\n                sys.exit(1)\n            EmbeddedDriverDescriptorList.append(Driver)\n    if 'Payloads' not in Json:\n        print('GenerateCapsule: error: \"Payloads\" section not found in JSON file {File}'.format(File=args.JsonFile.name))\n        sys.exit(1)\n    for Config in Json['Payloads']:\n        PayloadFile = ConvertJsonValue(Config, 'Payload', os.path.expandvars, Open=True)\n        Guid = ConvertJsonValue(Config, 'Guid', ValidateRegistryFormatGuid)\n        FwVersion = ConvertJsonValue(Config, 'FwVersion', ValidateUnsignedInteger)\n        LowestSupportedVersion = ConvertJsonValue(Config, 'LowestSupportedVersion', ValidateUnsignedInteger)\n        HardwareInstance = ConvertJsonValue(Config, 'HardwareInstance', ValidateUnsignedInteger, Required=False, Default=0)\n        UpdateImageIndex = ConvertJsonValue(Config, 'UpdateImageIndex', ValidateUnsignedInteger, Required=False, Default=1)\n        MonotonicCount = ConvertJsonValue(Config, 'MonotonicCount', ValidateUnsignedInteger, Required=False, Default=0)\n        SignToolPfxFile = ConvertJsonValue(Config, 'SignToolPfxFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SignToolSubjectName = ConvertJsonValue(Config, 'SignToolSubjectName', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslSignerPrivateCertFile = ConvertJsonValue(Config, 'OpenSslSignerPrivateCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslOtherPublicCertFile = ConvertJsonValue(Config, 'OpenSslOtherPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        OpenSslTrustedPublicCertFile = ConvertJsonValue(Config, 'OpenSslTrustedPublicCertFile', os.path.expandvars, Required=False, Default=None, Open=True)\n        SigningToolPath = ConvertJsonValue(Config, 'SigningToolPath', os.path.expandvars, Required=False, Default=None)\n        DepexExp = ConvertJsonValue(Config, 'Dependencies', str, Required=False, Default=None)\n        try:\n            if args.Verbose:\n                print('Read binary input file {File}'.format(File=PayloadFile.name))\n            Payload = PayloadFile.read()\n            PayloadFile.close()\n        except:\n            print('GenerateCapsule: error: can not read binary input file {File}'.format(File=PayloadFile.name))\n            sys.exit(1)\n        PayloadDescriptorList.append(PayloadDescriptor(Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount, HardwareInstance, UpdateImageIndex, SignToolPfxFile, SignToolSubjectName, OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile, SigningToolPath, DepexExp))"
        ]
    },
    {
        "func_name": "GenerateOutputJson",
        "original": "def GenerateOutputJson(PayloadJsonDescriptorList):\n    PayloadJson = {'Payloads': [{'Guid': str(PayloadDescriptor.Guid).upper(), 'FwVersion': str(PayloadDescriptor.FwVersion), 'LowestSupportedVersion': str(PayloadDescriptor.LowestSupportedVersion), 'MonotonicCount': str(PayloadDescriptor.MonotonicCount), 'Payload': PayloadDescriptor.Payload, 'HardwareInstance': str(PayloadDescriptor.HardwareInstance), 'UpdateImageIndex': str(PayloadDescriptor.UpdateImageIndex), 'SignToolPfxFile': str(PayloadDescriptor.SignToolPfxFile), 'SignToolSubjectName': str(PayloadDescriptor.SignToolSubjectName), 'OpenSslSignerPrivateCertFile': str(PayloadDescriptor.OpenSslSignerPrivateCertFile), 'OpenSslOtherPublicCertFile': str(PayloadDescriptor.OpenSslOtherPublicCertFile), 'OpenSslTrustedPublicCertFile': str(PayloadDescriptor.OpenSslTrustedPublicCertFile), 'SigningToolPath': str(PayloadDescriptor.SigningToolPath), 'Dependencies': str(PayloadDescriptor.DepexExp)} for PayloadDescriptor in PayloadJsonDescriptorList]}\n    OutputJsonFile = args.OutputFile.name + '.json'\n    if 'Payloads' in PayloadJson:\n        PayloadSection = PayloadJson['Payloads']\n    Index = 0\n    for PayloadField in PayloadSection:\n        if PayloadJsonDescriptorList[Index].SignToolPfxFile is None:\n            del PayloadField['SignToolPfxFile']\n        if PayloadJsonDescriptorList[Index].SignToolSubjectName is None:\n            del PayloadField['SignToolSubjectName']\n        if PayloadJsonDescriptorList[Index].OpenSslSignerPrivateCertFile is None:\n            del PayloadField['OpenSslSignerPrivateCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslOtherPublicCertFile is None:\n            del PayloadField['OpenSslOtherPublicCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslTrustedPublicCertFile is None:\n            del PayloadField['OpenSslTrustedPublicCertFile']\n        if PayloadJsonDescriptorList[Index].SigningToolPath is None:\n            del PayloadField['SigningToolPath']\n        Index = Index + 1\n    Result = json.dumps(PayloadJson, indent=4, sort_keys=True, separators=(',', ': '))\n    with open(OutputJsonFile, 'w') as OutputFile:\n        OutputFile.write(Result)",
        "mutated": [
            "def GenerateOutputJson(PayloadJsonDescriptorList):\n    if False:\n        i = 10\n    PayloadJson = {'Payloads': [{'Guid': str(PayloadDescriptor.Guid).upper(), 'FwVersion': str(PayloadDescriptor.FwVersion), 'LowestSupportedVersion': str(PayloadDescriptor.LowestSupportedVersion), 'MonotonicCount': str(PayloadDescriptor.MonotonicCount), 'Payload': PayloadDescriptor.Payload, 'HardwareInstance': str(PayloadDescriptor.HardwareInstance), 'UpdateImageIndex': str(PayloadDescriptor.UpdateImageIndex), 'SignToolPfxFile': str(PayloadDescriptor.SignToolPfxFile), 'SignToolSubjectName': str(PayloadDescriptor.SignToolSubjectName), 'OpenSslSignerPrivateCertFile': str(PayloadDescriptor.OpenSslSignerPrivateCertFile), 'OpenSslOtherPublicCertFile': str(PayloadDescriptor.OpenSslOtherPublicCertFile), 'OpenSslTrustedPublicCertFile': str(PayloadDescriptor.OpenSslTrustedPublicCertFile), 'SigningToolPath': str(PayloadDescriptor.SigningToolPath), 'Dependencies': str(PayloadDescriptor.DepexExp)} for PayloadDescriptor in PayloadJsonDescriptorList]}\n    OutputJsonFile = args.OutputFile.name + '.json'\n    if 'Payloads' in PayloadJson:\n        PayloadSection = PayloadJson['Payloads']\n    Index = 0\n    for PayloadField in PayloadSection:\n        if PayloadJsonDescriptorList[Index].SignToolPfxFile is None:\n            del PayloadField['SignToolPfxFile']\n        if PayloadJsonDescriptorList[Index].SignToolSubjectName is None:\n            del PayloadField['SignToolSubjectName']\n        if PayloadJsonDescriptorList[Index].OpenSslSignerPrivateCertFile is None:\n            del PayloadField['OpenSslSignerPrivateCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslOtherPublicCertFile is None:\n            del PayloadField['OpenSslOtherPublicCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslTrustedPublicCertFile is None:\n            del PayloadField['OpenSslTrustedPublicCertFile']\n        if PayloadJsonDescriptorList[Index].SigningToolPath is None:\n            del PayloadField['SigningToolPath']\n        Index = Index + 1\n    Result = json.dumps(PayloadJson, indent=4, sort_keys=True, separators=(',', ': '))\n    with open(OutputJsonFile, 'w') as OutputFile:\n        OutputFile.write(Result)",
            "def GenerateOutputJson(PayloadJsonDescriptorList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    PayloadJson = {'Payloads': [{'Guid': str(PayloadDescriptor.Guid).upper(), 'FwVersion': str(PayloadDescriptor.FwVersion), 'LowestSupportedVersion': str(PayloadDescriptor.LowestSupportedVersion), 'MonotonicCount': str(PayloadDescriptor.MonotonicCount), 'Payload': PayloadDescriptor.Payload, 'HardwareInstance': str(PayloadDescriptor.HardwareInstance), 'UpdateImageIndex': str(PayloadDescriptor.UpdateImageIndex), 'SignToolPfxFile': str(PayloadDescriptor.SignToolPfxFile), 'SignToolSubjectName': str(PayloadDescriptor.SignToolSubjectName), 'OpenSslSignerPrivateCertFile': str(PayloadDescriptor.OpenSslSignerPrivateCertFile), 'OpenSslOtherPublicCertFile': str(PayloadDescriptor.OpenSslOtherPublicCertFile), 'OpenSslTrustedPublicCertFile': str(PayloadDescriptor.OpenSslTrustedPublicCertFile), 'SigningToolPath': str(PayloadDescriptor.SigningToolPath), 'Dependencies': str(PayloadDescriptor.DepexExp)} for PayloadDescriptor in PayloadJsonDescriptorList]}\n    OutputJsonFile = args.OutputFile.name + '.json'\n    if 'Payloads' in PayloadJson:\n        PayloadSection = PayloadJson['Payloads']\n    Index = 0\n    for PayloadField in PayloadSection:\n        if PayloadJsonDescriptorList[Index].SignToolPfxFile is None:\n            del PayloadField['SignToolPfxFile']\n        if PayloadJsonDescriptorList[Index].SignToolSubjectName is None:\n            del PayloadField['SignToolSubjectName']\n        if PayloadJsonDescriptorList[Index].OpenSslSignerPrivateCertFile is None:\n            del PayloadField['OpenSslSignerPrivateCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslOtherPublicCertFile is None:\n            del PayloadField['OpenSslOtherPublicCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslTrustedPublicCertFile is None:\n            del PayloadField['OpenSslTrustedPublicCertFile']\n        if PayloadJsonDescriptorList[Index].SigningToolPath is None:\n            del PayloadField['SigningToolPath']\n        Index = Index + 1\n    Result = json.dumps(PayloadJson, indent=4, sort_keys=True, separators=(',', ': '))\n    with open(OutputJsonFile, 'w') as OutputFile:\n        OutputFile.write(Result)",
            "def GenerateOutputJson(PayloadJsonDescriptorList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    PayloadJson = {'Payloads': [{'Guid': str(PayloadDescriptor.Guid).upper(), 'FwVersion': str(PayloadDescriptor.FwVersion), 'LowestSupportedVersion': str(PayloadDescriptor.LowestSupportedVersion), 'MonotonicCount': str(PayloadDescriptor.MonotonicCount), 'Payload': PayloadDescriptor.Payload, 'HardwareInstance': str(PayloadDescriptor.HardwareInstance), 'UpdateImageIndex': str(PayloadDescriptor.UpdateImageIndex), 'SignToolPfxFile': str(PayloadDescriptor.SignToolPfxFile), 'SignToolSubjectName': str(PayloadDescriptor.SignToolSubjectName), 'OpenSslSignerPrivateCertFile': str(PayloadDescriptor.OpenSslSignerPrivateCertFile), 'OpenSslOtherPublicCertFile': str(PayloadDescriptor.OpenSslOtherPublicCertFile), 'OpenSslTrustedPublicCertFile': str(PayloadDescriptor.OpenSslTrustedPublicCertFile), 'SigningToolPath': str(PayloadDescriptor.SigningToolPath), 'Dependencies': str(PayloadDescriptor.DepexExp)} for PayloadDescriptor in PayloadJsonDescriptorList]}\n    OutputJsonFile = args.OutputFile.name + '.json'\n    if 'Payloads' in PayloadJson:\n        PayloadSection = PayloadJson['Payloads']\n    Index = 0\n    for PayloadField in PayloadSection:\n        if PayloadJsonDescriptorList[Index].SignToolPfxFile is None:\n            del PayloadField['SignToolPfxFile']\n        if PayloadJsonDescriptorList[Index].SignToolSubjectName is None:\n            del PayloadField['SignToolSubjectName']\n        if PayloadJsonDescriptorList[Index].OpenSslSignerPrivateCertFile is None:\n            del PayloadField['OpenSslSignerPrivateCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslOtherPublicCertFile is None:\n            del PayloadField['OpenSslOtherPublicCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslTrustedPublicCertFile is None:\n            del PayloadField['OpenSslTrustedPublicCertFile']\n        if PayloadJsonDescriptorList[Index].SigningToolPath is None:\n            del PayloadField['SigningToolPath']\n        Index = Index + 1\n    Result = json.dumps(PayloadJson, indent=4, sort_keys=True, separators=(',', ': '))\n    with open(OutputJsonFile, 'w') as OutputFile:\n        OutputFile.write(Result)",
            "def GenerateOutputJson(PayloadJsonDescriptorList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    PayloadJson = {'Payloads': [{'Guid': str(PayloadDescriptor.Guid).upper(), 'FwVersion': str(PayloadDescriptor.FwVersion), 'LowestSupportedVersion': str(PayloadDescriptor.LowestSupportedVersion), 'MonotonicCount': str(PayloadDescriptor.MonotonicCount), 'Payload': PayloadDescriptor.Payload, 'HardwareInstance': str(PayloadDescriptor.HardwareInstance), 'UpdateImageIndex': str(PayloadDescriptor.UpdateImageIndex), 'SignToolPfxFile': str(PayloadDescriptor.SignToolPfxFile), 'SignToolSubjectName': str(PayloadDescriptor.SignToolSubjectName), 'OpenSslSignerPrivateCertFile': str(PayloadDescriptor.OpenSslSignerPrivateCertFile), 'OpenSslOtherPublicCertFile': str(PayloadDescriptor.OpenSslOtherPublicCertFile), 'OpenSslTrustedPublicCertFile': str(PayloadDescriptor.OpenSslTrustedPublicCertFile), 'SigningToolPath': str(PayloadDescriptor.SigningToolPath), 'Dependencies': str(PayloadDescriptor.DepexExp)} for PayloadDescriptor in PayloadJsonDescriptorList]}\n    OutputJsonFile = args.OutputFile.name + '.json'\n    if 'Payloads' in PayloadJson:\n        PayloadSection = PayloadJson['Payloads']\n    Index = 0\n    for PayloadField in PayloadSection:\n        if PayloadJsonDescriptorList[Index].SignToolPfxFile is None:\n            del PayloadField['SignToolPfxFile']\n        if PayloadJsonDescriptorList[Index].SignToolSubjectName is None:\n            del PayloadField['SignToolSubjectName']\n        if PayloadJsonDescriptorList[Index].OpenSslSignerPrivateCertFile is None:\n            del PayloadField['OpenSslSignerPrivateCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslOtherPublicCertFile is None:\n            del PayloadField['OpenSslOtherPublicCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslTrustedPublicCertFile is None:\n            del PayloadField['OpenSslTrustedPublicCertFile']\n        if PayloadJsonDescriptorList[Index].SigningToolPath is None:\n            del PayloadField['SigningToolPath']\n        Index = Index + 1\n    Result = json.dumps(PayloadJson, indent=4, sort_keys=True, separators=(',', ': '))\n    with open(OutputJsonFile, 'w') as OutputFile:\n        OutputFile.write(Result)",
            "def GenerateOutputJson(PayloadJsonDescriptorList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    PayloadJson = {'Payloads': [{'Guid': str(PayloadDescriptor.Guid).upper(), 'FwVersion': str(PayloadDescriptor.FwVersion), 'LowestSupportedVersion': str(PayloadDescriptor.LowestSupportedVersion), 'MonotonicCount': str(PayloadDescriptor.MonotonicCount), 'Payload': PayloadDescriptor.Payload, 'HardwareInstance': str(PayloadDescriptor.HardwareInstance), 'UpdateImageIndex': str(PayloadDescriptor.UpdateImageIndex), 'SignToolPfxFile': str(PayloadDescriptor.SignToolPfxFile), 'SignToolSubjectName': str(PayloadDescriptor.SignToolSubjectName), 'OpenSslSignerPrivateCertFile': str(PayloadDescriptor.OpenSslSignerPrivateCertFile), 'OpenSslOtherPublicCertFile': str(PayloadDescriptor.OpenSslOtherPublicCertFile), 'OpenSslTrustedPublicCertFile': str(PayloadDescriptor.OpenSslTrustedPublicCertFile), 'SigningToolPath': str(PayloadDescriptor.SigningToolPath), 'Dependencies': str(PayloadDescriptor.DepexExp)} for PayloadDescriptor in PayloadJsonDescriptorList]}\n    OutputJsonFile = args.OutputFile.name + '.json'\n    if 'Payloads' in PayloadJson:\n        PayloadSection = PayloadJson['Payloads']\n    Index = 0\n    for PayloadField in PayloadSection:\n        if PayloadJsonDescriptorList[Index].SignToolPfxFile is None:\n            del PayloadField['SignToolPfxFile']\n        if PayloadJsonDescriptorList[Index].SignToolSubjectName is None:\n            del PayloadField['SignToolSubjectName']\n        if PayloadJsonDescriptorList[Index].OpenSslSignerPrivateCertFile is None:\n            del PayloadField['OpenSslSignerPrivateCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslOtherPublicCertFile is None:\n            del PayloadField['OpenSslOtherPublicCertFile']\n        if PayloadJsonDescriptorList[Index].OpenSslTrustedPublicCertFile is None:\n            del PayloadField['OpenSslTrustedPublicCertFile']\n        if PayloadJsonDescriptorList[Index].SigningToolPath is None:\n            del PayloadField['SigningToolPath']\n        Index = Index + 1\n    Result = json.dumps(PayloadJson, indent=4, sort_keys=True, separators=(',', ': '))\n    with open(OutputJsonFile, 'w') as OutputFile:\n        OutputFile.write(Result)"
        ]
    },
    {
        "func_name": "CheckArgumentConflict",
        "original": "def CheckArgumentConflict(args):\n    if args.Encode:\n        if args.InputFile:\n            print('GenerateCapsule: error: Argument InputFile conflicts with Argument -j')\n            sys.exit(1)\n        if args.EmbeddedDriver:\n            print('GenerateCapsule: error: Argument --embedded-driver conflicts with Argument -j')\n            sys.exit(1)\n    if args.Guid:\n        print('GenerateCapsule: error: Argument --guid conflicts with Argument -j')\n        sys.exit(1)\n    if args.FwVersion:\n        print('GenerateCapsule: error: Argument --fw-version conflicts with Argument -j')\n        sys.exit(1)\n    if args.LowestSupportedVersion:\n        print('GenerateCapsule: error: Argument --lsv conflicts with Argument -j')\n        sys.exit(1)\n    if args.MonotonicCount:\n        print('GenerateCapsule: error: Argument --monotonic-count conflicts with Argument -j')\n        sys.exit(1)\n    if args.HardwareInstance:\n        print('GenerateCapsule: error: Argument --hardware-instance conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolPfxFile:\n        print('GenerateCapsule: error: Argument --pfx-file conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolSubjectName:\n        print('GenerateCapsule: error: Argument --SubjectName conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslSignerPrivateCertFile:\n        print('GenerateCapsule: error: Argument --signer-private-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslOtherPublicCertFile:\n        print('GenerateCapsule: error: Argument --other-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslTrustedPublicCertFile:\n        print('GenerateCapsule: error: Argument --trusted-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.SigningToolPath:\n        print('GenerateCapsule: error: Argument --signing-tool-path conflicts with Argument -j')\n        sys.exit(1)",
        "mutated": [
            "def CheckArgumentConflict(args):\n    if False:\n        i = 10\n    if args.Encode:\n        if args.InputFile:\n            print('GenerateCapsule: error: Argument InputFile conflicts with Argument -j')\n            sys.exit(1)\n        if args.EmbeddedDriver:\n            print('GenerateCapsule: error: Argument --embedded-driver conflicts with Argument -j')\n            sys.exit(1)\n    if args.Guid:\n        print('GenerateCapsule: error: Argument --guid conflicts with Argument -j')\n        sys.exit(1)\n    if args.FwVersion:\n        print('GenerateCapsule: error: Argument --fw-version conflicts with Argument -j')\n        sys.exit(1)\n    if args.LowestSupportedVersion:\n        print('GenerateCapsule: error: Argument --lsv conflicts with Argument -j')\n        sys.exit(1)\n    if args.MonotonicCount:\n        print('GenerateCapsule: error: Argument --monotonic-count conflicts with Argument -j')\n        sys.exit(1)\n    if args.HardwareInstance:\n        print('GenerateCapsule: error: Argument --hardware-instance conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolPfxFile:\n        print('GenerateCapsule: error: Argument --pfx-file conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolSubjectName:\n        print('GenerateCapsule: error: Argument --SubjectName conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslSignerPrivateCertFile:\n        print('GenerateCapsule: error: Argument --signer-private-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslOtherPublicCertFile:\n        print('GenerateCapsule: error: Argument --other-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslTrustedPublicCertFile:\n        print('GenerateCapsule: error: Argument --trusted-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.SigningToolPath:\n        print('GenerateCapsule: error: Argument --signing-tool-path conflicts with Argument -j')\n        sys.exit(1)",
            "def CheckArgumentConflict(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if args.Encode:\n        if args.InputFile:\n            print('GenerateCapsule: error: Argument InputFile conflicts with Argument -j')\n            sys.exit(1)\n        if args.EmbeddedDriver:\n            print('GenerateCapsule: error: Argument --embedded-driver conflicts with Argument -j')\n            sys.exit(1)\n    if args.Guid:\n        print('GenerateCapsule: error: Argument --guid conflicts with Argument -j')\n        sys.exit(1)\n    if args.FwVersion:\n        print('GenerateCapsule: error: Argument --fw-version conflicts with Argument -j')\n        sys.exit(1)\n    if args.LowestSupportedVersion:\n        print('GenerateCapsule: error: Argument --lsv conflicts with Argument -j')\n        sys.exit(1)\n    if args.MonotonicCount:\n        print('GenerateCapsule: error: Argument --monotonic-count conflicts with Argument -j')\n        sys.exit(1)\n    if args.HardwareInstance:\n        print('GenerateCapsule: error: Argument --hardware-instance conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolPfxFile:\n        print('GenerateCapsule: error: Argument --pfx-file conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolSubjectName:\n        print('GenerateCapsule: error: Argument --SubjectName conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslSignerPrivateCertFile:\n        print('GenerateCapsule: error: Argument --signer-private-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslOtherPublicCertFile:\n        print('GenerateCapsule: error: Argument --other-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslTrustedPublicCertFile:\n        print('GenerateCapsule: error: Argument --trusted-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.SigningToolPath:\n        print('GenerateCapsule: error: Argument --signing-tool-path conflicts with Argument -j')\n        sys.exit(1)",
            "def CheckArgumentConflict(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if args.Encode:\n        if args.InputFile:\n            print('GenerateCapsule: error: Argument InputFile conflicts with Argument -j')\n            sys.exit(1)\n        if args.EmbeddedDriver:\n            print('GenerateCapsule: error: Argument --embedded-driver conflicts with Argument -j')\n            sys.exit(1)\n    if args.Guid:\n        print('GenerateCapsule: error: Argument --guid conflicts with Argument -j')\n        sys.exit(1)\n    if args.FwVersion:\n        print('GenerateCapsule: error: Argument --fw-version conflicts with Argument -j')\n        sys.exit(1)\n    if args.LowestSupportedVersion:\n        print('GenerateCapsule: error: Argument --lsv conflicts with Argument -j')\n        sys.exit(1)\n    if args.MonotonicCount:\n        print('GenerateCapsule: error: Argument --monotonic-count conflicts with Argument -j')\n        sys.exit(1)\n    if args.HardwareInstance:\n        print('GenerateCapsule: error: Argument --hardware-instance conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolPfxFile:\n        print('GenerateCapsule: error: Argument --pfx-file conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolSubjectName:\n        print('GenerateCapsule: error: Argument --SubjectName conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslSignerPrivateCertFile:\n        print('GenerateCapsule: error: Argument --signer-private-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslOtherPublicCertFile:\n        print('GenerateCapsule: error: Argument --other-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslTrustedPublicCertFile:\n        print('GenerateCapsule: error: Argument --trusted-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.SigningToolPath:\n        print('GenerateCapsule: error: Argument --signing-tool-path conflicts with Argument -j')\n        sys.exit(1)",
            "def CheckArgumentConflict(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if args.Encode:\n        if args.InputFile:\n            print('GenerateCapsule: error: Argument InputFile conflicts with Argument -j')\n            sys.exit(1)\n        if args.EmbeddedDriver:\n            print('GenerateCapsule: error: Argument --embedded-driver conflicts with Argument -j')\n            sys.exit(1)\n    if args.Guid:\n        print('GenerateCapsule: error: Argument --guid conflicts with Argument -j')\n        sys.exit(1)\n    if args.FwVersion:\n        print('GenerateCapsule: error: Argument --fw-version conflicts with Argument -j')\n        sys.exit(1)\n    if args.LowestSupportedVersion:\n        print('GenerateCapsule: error: Argument --lsv conflicts with Argument -j')\n        sys.exit(1)\n    if args.MonotonicCount:\n        print('GenerateCapsule: error: Argument --monotonic-count conflicts with Argument -j')\n        sys.exit(1)\n    if args.HardwareInstance:\n        print('GenerateCapsule: error: Argument --hardware-instance conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolPfxFile:\n        print('GenerateCapsule: error: Argument --pfx-file conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolSubjectName:\n        print('GenerateCapsule: error: Argument --SubjectName conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslSignerPrivateCertFile:\n        print('GenerateCapsule: error: Argument --signer-private-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslOtherPublicCertFile:\n        print('GenerateCapsule: error: Argument --other-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslTrustedPublicCertFile:\n        print('GenerateCapsule: error: Argument --trusted-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.SigningToolPath:\n        print('GenerateCapsule: error: Argument --signing-tool-path conflicts with Argument -j')\n        sys.exit(1)",
            "def CheckArgumentConflict(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if args.Encode:\n        if args.InputFile:\n            print('GenerateCapsule: error: Argument InputFile conflicts with Argument -j')\n            sys.exit(1)\n        if args.EmbeddedDriver:\n            print('GenerateCapsule: error: Argument --embedded-driver conflicts with Argument -j')\n            sys.exit(1)\n    if args.Guid:\n        print('GenerateCapsule: error: Argument --guid conflicts with Argument -j')\n        sys.exit(1)\n    if args.FwVersion:\n        print('GenerateCapsule: error: Argument --fw-version conflicts with Argument -j')\n        sys.exit(1)\n    if args.LowestSupportedVersion:\n        print('GenerateCapsule: error: Argument --lsv conflicts with Argument -j')\n        sys.exit(1)\n    if args.MonotonicCount:\n        print('GenerateCapsule: error: Argument --monotonic-count conflicts with Argument -j')\n        sys.exit(1)\n    if args.HardwareInstance:\n        print('GenerateCapsule: error: Argument --hardware-instance conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolPfxFile:\n        print('GenerateCapsule: error: Argument --pfx-file conflicts with Argument -j')\n        sys.exit(1)\n    if args.SignToolSubjectName:\n        print('GenerateCapsule: error: Argument --SubjectName conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslSignerPrivateCertFile:\n        print('GenerateCapsule: error: Argument --signer-private-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslOtherPublicCertFile:\n        print('GenerateCapsule: error: Argument --other-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.OpenSslTrustedPublicCertFile:\n        print('GenerateCapsule: error: Argument --trusted-public-cert conflicts with Argument -j')\n        sys.exit(1)\n    if args.SigningToolPath:\n        print('GenerateCapsule: error: Argument --signing-tool-path conflicts with Argument -j')\n        sys.exit(1)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount=0, HardwareInstance=0, UpdateImageIndex=1, SignToolPfxFile=None, SignToolSubjectName=None, OpenSslSignerPrivateCertFile=None, OpenSslOtherPublicCertFile=None, OpenSslTrustedPublicCertFile=None, SigningToolPath=None, DepexExp=None):\n    self.Payload = Payload\n    self.Guid = Guid\n    self.FwVersion = FwVersion\n    self.LowestSupportedVersion = LowestSupportedVersion\n    self.MonotonicCount = MonotonicCount\n    self.HardwareInstance = HardwareInstance\n    self.UpdateImageIndex = UpdateImageIndex\n    self.SignToolPfxFile = SignToolPfxFile\n    self.SignToolSubjectName = SignToolSubjectName\n    self.OpenSslSignerPrivateCertFile = OpenSslSignerPrivateCertFile\n    self.OpenSslOtherPublicCertFile = OpenSslOtherPublicCertFile\n    self.OpenSslTrustedPublicCertFile = OpenSslTrustedPublicCertFile\n    self.SigningToolPath = SigningToolPath\n    self.DepexExp = DepexExp\n    self.UseSignTool = self.SignToolPfxFile is not None or self.SignToolSubjectName is not None\n    self.UseOpenSsl = self.OpenSslSignerPrivateCertFile is not None and self.OpenSslOtherPublicCertFile is not None and (self.OpenSslTrustedPublicCertFile is not None)\n    self.AnyOpenSsl = self.OpenSslSignerPrivateCertFile is not None or self.OpenSslOtherPublicCertFile is not None or self.OpenSslTrustedPublicCertFile is not None\n    self.UseDependency = self.DepexExp is not None",
        "mutated": [
            "def __init__(self, Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount=0, HardwareInstance=0, UpdateImageIndex=1, SignToolPfxFile=None, SignToolSubjectName=None, OpenSslSignerPrivateCertFile=None, OpenSslOtherPublicCertFile=None, OpenSslTrustedPublicCertFile=None, SigningToolPath=None, DepexExp=None):\n    if False:\n        i = 10\n    self.Payload = Payload\n    self.Guid = Guid\n    self.FwVersion = FwVersion\n    self.LowestSupportedVersion = LowestSupportedVersion\n    self.MonotonicCount = MonotonicCount\n    self.HardwareInstance = HardwareInstance\n    self.UpdateImageIndex = UpdateImageIndex\n    self.SignToolPfxFile = SignToolPfxFile\n    self.SignToolSubjectName = SignToolSubjectName\n    self.OpenSslSignerPrivateCertFile = OpenSslSignerPrivateCertFile\n    self.OpenSslOtherPublicCertFile = OpenSslOtherPublicCertFile\n    self.OpenSslTrustedPublicCertFile = OpenSslTrustedPublicCertFile\n    self.SigningToolPath = SigningToolPath\n    self.DepexExp = DepexExp\n    self.UseSignTool = self.SignToolPfxFile is not None or self.SignToolSubjectName is not None\n    self.UseOpenSsl = self.OpenSslSignerPrivateCertFile is not None and self.OpenSslOtherPublicCertFile is not None and (self.OpenSslTrustedPublicCertFile is not None)\n    self.AnyOpenSsl = self.OpenSslSignerPrivateCertFile is not None or self.OpenSslOtherPublicCertFile is not None or self.OpenSslTrustedPublicCertFile is not None\n    self.UseDependency = self.DepexExp is not None",
            "def __init__(self, Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount=0, HardwareInstance=0, UpdateImageIndex=1, SignToolPfxFile=None, SignToolSubjectName=None, OpenSslSignerPrivateCertFile=None, OpenSslOtherPublicCertFile=None, OpenSslTrustedPublicCertFile=None, SigningToolPath=None, DepexExp=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.Payload = Payload\n    self.Guid = Guid\n    self.FwVersion = FwVersion\n    self.LowestSupportedVersion = LowestSupportedVersion\n    self.MonotonicCount = MonotonicCount\n    self.HardwareInstance = HardwareInstance\n    self.UpdateImageIndex = UpdateImageIndex\n    self.SignToolPfxFile = SignToolPfxFile\n    self.SignToolSubjectName = SignToolSubjectName\n    self.OpenSslSignerPrivateCertFile = OpenSslSignerPrivateCertFile\n    self.OpenSslOtherPublicCertFile = OpenSslOtherPublicCertFile\n    self.OpenSslTrustedPublicCertFile = OpenSslTrustedPublicCertFile\n    self.SigningToolPath = SigningToolPath\n    self.DepexExp = DepexExp\n    self.UseSignTool = self.SignToolPfxFile is not None or self.SignToolSubjectName is not None\n    self.UseOpenSsl = self.OpenSslSignerPrivateCertFile is not None and self.OpenSslOtherPublicCertFile is not None and (self.OpenSslTrustedPublicCertFile is not None)\n    self.AnyOpenSsl = self.OpenSslSignerPrivateCertFile is not None or self.OpenSslOtherPublicCertFile is not None or self.OpenSslTrustedPublicCertFile is not None\n    self.UseDependency = self.DepexExp is not None",
            "def __init__(self, Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount=0, HardwareInstance=0, UpdateImageIndex=1, SignToolPfxFile=None, SignToolSubjectName=None, OpenSslSignerPrivateCertFile=None, OpenSslOtherPublicCertFile=None, OpenSslTrustedPublicCertFile=None, SigningToolPath=None, DepexExp=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.Payload = Payload\n    self.Guid = Guid\n    self.FwVersion = FwVersion\n    self.LowestSupportedVersion = LowestSupportedVersion\n    self.MonotonicCount = MonotonicCount\n    self.HardwareInstance = HardwareInstance\n    self.UpdateImageIndex = UpdateImageIndex\n    self.SignToolPfxFile = SignToolPfxFile\n    self.SignToolSubjectName = SignToolSubjectName\n    self.OpenSslSignerPrivateCertFile = OpenSslSignerPrivateCertFile\n    self.OpenSslOtherPublicCertFile = OpenSslOtherPublicCertFile\n    self.OpenSslTrustedPublicCertFile = OpenSslTrustedPublicCertFile\n    self.SigningToolPath = SigningToolPath\n    self.DepexExp = DepexExp\n    self.UseSignTool = self.SignToolPfxFile is not None or self.SignToolSubjectName is not None\n    self.UseOpenSsl = self.OpenSslSignerPrivateCertFile is not None and self.OpenSslOtherPublicCertFile is not None and (self.OpenSslTrustedPublicCertFile is not None)\n    self.AnyOpenSsl = self.OpenSslSignerPrivateCertFile is not None or self.OpenSslOtherPublicCertFile is not None or self.OpenSslTrustedPublicCertFile is not None\n    self.UseDependency = self.DepexExp is not None",
            "def __init__(self, Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount=0, HardwareInstance=0, UpdateImageIndex=1, SignToolPfxFile=None, SignToolSubjectName=None, OpenSslSignerPrivateCertFile=None, OpenSslOtherPublicCertFile=None, OpenSslTrustedPublicCertFile=None, SigningToolPath=None, DepexExp=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.Payload = Payload\n    self.Guid = Guid\n    self.FwVersion = FwVersion\n    self.LowestSupportedVersion = LowestSupportedVersion\n    self.MonotonicCount = MonotonicCount\n    self.HardwareInstance = HardwareInstance\n    self.UpdateImageIndex = UpdateImageIndex\n    self.SignToolPfxFile = SignToolPfxFile\n    self.SignToolSubjectName = SignToolSubjectName\n    self.OpenSslSignerPrivateCertFile = OpenSslSignerPrivateCertFile\n    self.OpenSslOtherPublicCertFile = OpenSslOtherPublicCertFile\n    self.OpenSslTrustedPublicCertFile = OpenSslTrustedPublicCertFile\n    self.SigningToolPath = SigningToolPath\n    self.DepexExp = DepexExp\n    self.UseSignTool = self.SignToolPfxFile is not None or self.SignToolSubjectName is not None\n    self.UseOpenSsl = self.OpenSslSignerPrivateCertFile is not None and self.OpenSslOtherPublicCertFile is not None and (self.OpenSslTrustedPublicCertFile is not None)\n    self.AnyOpenSsl = self.OpenSslSignerPrivateCertFile is not None or self.OpenSslOtherPublicCertFile is not None or self.OpenSslTrustedPublicCertFile is not None\n    self.UseDependency = self.DepexExp is not None",
            "def __init__(self, Payload, Guid, FwVersion, LowestSupportedVersion, MonotonicCount=0, HardwareInstance=0, UpdateImageIndex=1, SignToolPfxFile=None, SignToolSubjectName=None, OpenSslSignerPrivateCertFile=None, OpenSslOtherPublicCertFile=None, OpenSslTrustedPublicCertFile=None, SigningToolPath=None, DepexExp=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.Payload = Payload\n    self.Guid = Guid\n    self.FwVersion = FwVersion\n    self.LowestSupportedVersion = LowestSupportedVersion\n    self.MonotonicCount = MonotonicCount\n    self.HardwareInstance = HardwareInstance\n    self.UpdateImageIndex = UpdateImageIndex\n    self.SignToolPfxFile = SignToolPfxFile\n    self.SignToolSubjectName = SignToolSubjectName\n    self.OpenSslSignerPrivateCertFile = OpenSslSignerPrivateCertFile\n    self.OpenSslOtherPublicCertFile = OpenSslOtherPublicCertFile\n    self.OpenSslTrustedPublicCertFile = OpenSslTrustedPublicCertFile\n    self.SigningToolPath = SigningToolPath\n    self.DepexExp = DepexExp\n    self.UseSignTool = self.SignToolPfxFile is not None or self.SignToolSubjectName is not None\n    self.UseOpenSsl = self.OpenSslSignerPrivateCertFile is not None and self.OpenSslOtherPublicCertFile is not None and (self.OpenSslTrustedPublicCertFile is not None)\n    self.AnyOpenSsl = self.OpenSslSignerPrivateCertFile is not None or self.OpenSslOtherPublicCertFile is not None or self.OpenSslTrustedPublicCertFile is not None\n    self.UseDependency = self.DepexExp is not None"
        ]
    },
    {
        "func_name": "Validate",
        "original": "def Validate(self, args):\n    if self.UseSignTool and self.AnyOpenSsl:\n        raise argparse.ArgumentTypeError('Providing both signtool and OpenSSL options is not supported')\n    if not self.UseSignTool and (not self.UseOpenSsl) and self.AnyOpenSsl:\n        if args.JsonFile:\n            raise argparse.ArgumentTypeError('the following JSON fields are required for OpenSSL: OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile')\n        else:\n            raise argparse.ArgumentTypeError('the following options are required for OpenSSL: --signer-private-cert, --other-public-cert, --trusted-public-cert')\n    if self.UseSignTool and platform.system() != 'Windows':\n        raise argparse.ArgumentTypeError('Use of signtool is not supported on this operating system.')\n    if args.Encode:\n        if self.FwVersion is None or self.LowestSupportedVersion is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON fields are required: FwVersion, LowestSupportedVersion')\n            else:\n                raise argparse.ArgumentTypeError('the following options are required: --fw-version, --lsv')\n        if self.FwVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field FwVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--fw-version must be an integer in range 0x0..0xffffffff')\n        if self.LowestSupportedVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field LowestSupportedVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--lsv must be an integer in range 0x0..0xffffffff')\n    if args.Encode:\n        if self.Guid is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON field is required: Guid')\n            else:\n                raise argparse.ArgumentTypeError('the following option is required: --guid')\n        if self.HardwareInstance > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field HardwareInstance must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--hardware-instance must be an integer in range 0x0..0xffffffffffffffff')\n        if self.MonotonicCount > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field MonotonicCount must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--monotonic-count must be an integer in range 0x0..0xffffffffffffffff')\n        if self.UpdateImageIndex > 255:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field UpdateImageIndex must be an integer in range 0x0..0xff')\n            else:\n                raise argparse.ArgumentTypeError('--update-image-index must be an integer in range 0x0..0xff')\n    if self.UseSignTool:\n        if self.SignToolPfxFile is not None:\n            self.SignToolPfxFile.close()\n            self.SignToolPfxFile = self.SignToolPfxFile.name\n    if self.UseOpenSsl:\n        self.OpenSslSignerPrivateCertFile.close()\n        self.OpenSslOtherPublicCertFile.close()\n        self.OpenSslTrustedPublicCertFile.close()\n        self.OpenSslSignerPrivateCertFile = self.OpenSslSignerPrivateCertFile.name\n        self.OpenSslOtherPublicCertFile = self.OpenSslOtherPublicCertFile.name\n        self.OpenSslTrustedPublicCertFile = self.OpenSslTrustedPublicCertFile.name\n    if args.Encode:\n        if 'PersistAcrossReset' not in args.CapsuleFlag:\n            if 'InitiateReset' in args.CapsuleFlag:\n                raise argparse.ArgumentTypeError('--capflag InitiateReset also requires --capflag PersistAcrossReset')\n        if args.CapsuleOemFlag > 65535:\n            raise argparse.ArgumentTypeError('--capoemflag must be an integer between 0x0000 and 0xffff')\n    return True",
        "mutated": [
            "def Validate(self, args):\n    if False:\n        i = 10\n    if self.UseSignTool and self.AnyOpenSsl:\n        raise argparse.ArgumentTypeError('Providing both signtool and OpenSSL options is not supported')\n    if not self.UseSignTool and (not self.UseOpenSsl) and self.AnyOpenSsl:\n        if args.JsonFile:\n            raise argparse.ArgumentTypeError('the following JSON fields are required for OpenSSL: OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile')\n        else:\n            raise argparse.ArgumentTypeError('the following options are required for OpenSSL: --signer-private-cert, --other-public-cert, --trusted-public-cert')\n    if self.UseSignTool and platform.system() != 'Windows':\n        raise argparse.ArgumentTypeError('Use of signtool is not supported on this operating system.')\n    if args.Encode:\n        if self.FwVersion is None or self.LowestSupportedVersion is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON fields are required: FwVersion, LowestSupportedVersion')\n            else:\n                raise argparse.ArgumentTypeError('the following options are required: --fw-version, --lsv')\n        if self.FwVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field FwVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--fw-version must be an integer in range 0x0..0xffffffff')\n        if self.LowestSupportedVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field LowestSupportedVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--lsv must be an integer in range 0x0..0xffffffff')\n    if args.Encode:\n        if self.Guid is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON field is required: Guid')\n            else:\n                raise argparse.ArgumentTypeError('the following option is required: --guid')\n        if self.HardwareInstance > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field HardwareInstance must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--hardware-instance must be an integer in range 0x0..0xffffffffffffffff')\n        if self.MonotonicCount > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field MonotonicCount must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--monotonic-count must be an integer in range 0x0..0xffffffffffffffff')\n        if self.UpdateImageIndex > 255:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field UpdateImageIndex must be an integer in range 0x0..0xff')\n            else:\n                raise argparse.ArgumentTypeError('--update-image-index must be an integer in range 0x0..0xff')\n    if self.UseSignTool:\n        if self.SignToolPfxFile is not None:\n            self.SignToolPfxFile.close()\n            self.SignToolPfxFile = self.SignToolPfxFile.name\n    if self.UseOpenSsl:\n        self.OpenSslSignerPrivateCertFile.close()\n        self.OpenSslOtherPublicCertFile.close()\n        self.OpenSslTrustedPublicCertFile.close()\n        self.OpenSslSignerPrivateCertFile = self.OpenSslSignerPrivateCertFile.name\n        self.OpenSslOtherPublicCertFile = self.OpenSslOtherPublicCertFile.name\n        self.OpenSslTrustedPublicCertFile = self.OpenSslTrustedPublicCertFile.name\n    if args.Encode:\n        if 'PersistAcrossReset' not in args.CapsuleFlag:\n            if 'InitiateReset' in args.CapsuleFlag:\n                raise argparse.ArgumentTypeError('--capflag InitiateReset also requires --capflag PersistAcrossReset')\n        if args.CapsuleOemFlag > 65535:\n            raise argparse.ArgumentTypeError('--capoemflag must be an integer between 0x0000 and 0xffff')\n    return True",
            "def Validate(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.UseSignTool and self.AnyOpenSsl:\n        raise argparse.ArgumentTypeError('Providing both signtool and OpenSSL options is not supported')\n    if not self.UseSignTool and (not self.UseOpenSsl) and self.AnyOpenSsl:\n        if args.JsonFile:\n            raise argparse.ArgumentTypeError('the following JSON fields are required for OpenSSL: OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile')\n        else:\n            raise argparse.ArgumentTypeError('the following options are required for OpenSSL: --signer-private-cert, --other-public-cert, --trusted-public-cert')\n    if self.UseSignTool and platform.system() != 'Windows':\n        raise argparse.ArgumentTypeError('Use of signtool is not supported on this operating system.')\n    if args.Encode:\n        if self.FwVersion is None or self.LowestSupportedVersion is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON fields are required: FwVersion, LowestSupportedVersion')\n            else:\n                raise argparse.ArgumentTypeError('the following options are required: --fw-version, --lsv')\n        if self.FwVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field FwVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--fw-version must be an integer in range 0x0..0xffffffff')\n        if self.LowestSupportedVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field LowestSupportedVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--lsv must be an integer in range 0x0..0xffffffff')\n    if args.Encode:\n        if self.Guid is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON field is required: Guid')\n            else:\n                raise argparse.ArgumentTypeError('the following option is required: --guid')\n        if self.HardwareInstance > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field HardwareInstance must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--hardware-instance must be an integer in range 0x0..0xffffffffffffffff')\n        if self.MonotonicCount > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field MonotonicCount must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--monotonic-count must be an integer in range 0x0..0xffffffffffffffff')\n        if self.UpdateImageIndex > 255:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field UpdateImageIndex must be an integer in range 0x0..0xff')\n            else:\n                raise argparse.ArgumentTypeError('--update-image-index must be an integer in range 0x0..0xff')\n    if self.UseSignTool:\n        if self.SignToolPfxFile is not None:\n            self.SignToolPfxFile.close()\n            self.SignToolPfxFile = self.SignToolPfxFile.name\n    if self.UseOpenSsl:\n        self.OpenSslSignerPrivateCertFile.close()\n        self.OpenSslOtherPublicCertFile.close()\n        self.OpenSslTrustedPublicCertFile.close()\n        self.OpenSslSignerPrivateCertFile = self.OpenSslSignerPrivateCertFile.name\n        self.OpenSslOtherPublicCertFile = self.OpenSslOtherPublicCertFile.name\n        self.OpenSslTrustedPublicCertFile = self.OpenSslTrustedPublicCertFile.name\n    if args.Encode:\n        if 'PersistAcrossReset' not in args.CapsuleFlag:\n            if 'InitiateReset' in args.CapsuleFlag:\n                raise argparse.ArgumentTypeError('--capflag InitiateReset also requires --capflag PersistAcrossReset')\n        if args.CapsuleOemFlag > 65535:\n            raise argparse.ArgumentTypeError('--capoemflag must be an integer between 0x0000 and 0xffff')\n    return True",
            "def Validate(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.UseSignTool and self.AnyOpenSsl:\n        raise argparse.ArgumentTypeError('Providing both signtool and OpenSSL options is not supported')\n    if not self.UseSignTool and (not self.UseOpenSsl) and self.AnyOpenSsl:\n        if args.JsonFile:\n            raise argparse.ArgumentTypeError('the following JSON fields are required for OpenSSL: OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile')\n        else:\n            raise argparse.ArgumentTypeError('the following options are required for OpenSSL: --signer-private-cert, --other-public-cert, --trusted-public-cert')\n    if self.UseSignTool and platform.system() != 'Windows':\n        raise argparse.ArgumentTypeError('Use of signtool is not supported on this operating system.')\n    if args.Encode:\n        if self.FwVersion is None or self.LowestSupportedVersion is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON fields are required: FwVersion, LowestSupportedVersion')\n            else:\n                raise argparse.ArgumentTypeError('the following options are required: --fw-version, --lsv')\n        if self.FwVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field FwVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--fw-version must be an integer in range 0x0..0xffffffff')\n        if self.LowestSupportedVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field LowestSupportedVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--lsv must be an integer in range 0x0..0xffffffff')\n    if args.Encode:\n        if self.Guid is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON field is required: Guid')\n            else:\n                raise argparse.ArgumentTypeError('the following option is required: --guid')\n        if self.HardwareInstance > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field HardwareInstance must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--hardware-instance must be an integer in range 0x0..0xffffffffffffffff')\n        if self.MonotonicCount > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field MonotonicCount must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--monotonic-count must be an integer in range 0x0..0xffffffffffffffff')\n        if self.UpdateImageIndex > 255:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field UpdateImageIndex must be an integer in range 0x0..0xff')\n            else:\n                raise argparse.ArgumentTypeError('--update-image-index must be an integer in range 0x0..0xff')\n    if self.UseSignTool:\n        if self.SignToolPfxFile is not None:\n            self.SignToolPfxFile.close()\n            self.SignToolPfxFile = self.SignToolPfxFile.name\n    if self.UseOpenSsl:\n        self.OpenSslSignerPrivateCertFile.close()\n        self.OpenSslOtherPublicCertFile.close()\n        self.OpenSslTrustedPublicCertFile.close()\n        self.OpenSslSignerPrivateCertFile = self.OpenSslSignerPrivateCertFile.name\n        self.OpenSslOtherPublicCertFile = self.OpenSslOtherPublicCertFile.name\n        self.OpenSslTrustedPublicCertFile = self.OpenSslTrustedPublicCertFile.name\n    if args.Encode:\n        if 'PersistAcrossReset' not in args.CapsuleFlag:\n            if 'InitiateReset' in args.CapsuleFlag:\n                raise argparse.ArgumentTypeError('--capflag InitiateReset also requires --capflag PersistAcrossReset')\n        if args.CapsuleOemFlag > 65535:\n            raise argparse.ArgumentTypeError('--capoemflag must be an integer between 0x0000 and 0xffff')\n    return True",
            "def Validate(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.UseSignTool and self.AnyOpenSsl:\n        raise argparse.ArgumentTypeError('Providing both signtool and OpenSSL options is not supported')\n    if not self.UseSignTool and (not self.UseOpenSsl) and self.AnyOpenSsl:\n        if args.JsonFile:\n            raise argparse.ArgumentTypeError('the following JSON fields are required for OpenSSL: OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile')\n        else:\n            raise argparse.ArgumentTypeError('the following options are required for OpenSSL: --signer-private-cert, --other-public-cert, --trusted-public-cert')\n    if self.UseSignTool and platform.system() != 'Windows':\n        raise argparse.ArgumentTypeError('Use of signtool is not supported on this operating system.')\n    if args.Encode:\n        if self.FwVersion is None or self.LowestSupportedVersion is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON fields are required: FwVersion, LowestSupportedVersion')\n            else:\n                raise argparse.ArgumentTypeError('the following options are required: --fw-version, --lsv')\n        if self.FwVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field FwVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--fw-version must be an integer in range 0x0..0xffffffff')\n        if self.LowestSupportedVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field LowestSupportedVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--lsv must be an integer in range 0x0..0xffffffff')\n    if args.Encode:\n        if self.Guid is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON field is required: Guid')\n            else:\n                raise argparse.ArgumentTypeError('the following option is required: --guid')\n        if self.HardwareInstance > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field HardwareInstance must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--hardware-instance must be an integer in range 0x0..0xffffffffffffffff')\n        if self.MonotonicCount > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field MonotonicCount must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--monotonic-count must be an integer in range 0x0..0xffffffffffffffff')\n        if self.UpdateImageIndex > 255:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field UpdateImageIndex must be an integer in range 0x0..0xff')\n            else:\n                raise argparse.ArgumentTypeError('--update-image-index must be an integer in range 0x0..0xff')\n    if self.UseSignTool:\n        if self.SignToolPfxFile is not None:\n            self.SignToolPfxFile.close()\n            self.SignToolPfxFile = self.SignToolPfxFile.name\n    if self.UseOpenSsl:\n        self.OpenSslSignerPrivateCertFile.close()\n        self.OpenSslOtherPublicCertFile.close()\n        self.OpenSslTrustedPublicCertFile.close()\n        self.OpenSslSignerPrivateCertFile = self.OpenSslSignerPrivateCertFile.name\n        self.OpenSslOtherPublicCertFile = self.OpenSslOtherPublicCertFile.name\n        self.OpenSslTrustedPublicCertFile = self.OpenSslTrustedPublicCertFile.name\n    if args.Encode:\n        if 'PersistAcrossReset' not in args.CapsuleFlag:\n            if 'InitiateReset' in args.CapsuleFlag:\n                raise argparse.ArgumentTypeError('--capflag InitiateReset also requires --capflag PersistAcrossReset')\n        if args.CapsuleOemFlag > 65535:\n            raise argparse.ArgumentTypeError('--capoemflag must be an integer between 0x0000 and 0xffff')\n    return True",
            "def Validate(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.UseSignTool and self.AnyOpenSsl:\n        raise argparse.ArgumentTypeError('Providing both signtool and OpenSSL options is not supported')\n    if not self.UseSignTool and (not self.UseOpenSsl) and self.AnyOpenSsl:\n        if args.JsonFile:\n            raise argparse.ArgumentTypeError('the following JSON fields are required for OpenSSL: OpenSslSignerPrivateCertFile, OpenSslOtherPublicCertFile, OpenSslTrustedPublicCertFile')\n        else:\n            raise argparse.ArgumentTypeError('the following options are required for OpenSSL: --signer-private-cert, --other-public-cert, --trusted-public-cert')\n    if self.UseSignTool and platform.system() != 'Windows':\n        raise argparse.ArgumentTypeError('Use of signtool is not supported on this operating system.')\n    if args.Encode:\n        if self.FwVersion is None or self.LowestSupportedVersion is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON fields are required: FwVersion, LowestSupportedVersion')\n            else:\n                raise argparse.ArgumentTypeError('the following options are required: --fw-version, --lsv')\n        if self.FwVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field FwVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--fw-version must be an integer in range 0x0..0xffffffff')\n        if self.LowestSupportedVersion > 4294967295:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field LowestSupportedVersion must be an integer in range 0x0..0xffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--lsv must be an integer in range 0x0..0xffffffff')\n    if args.Encode:\n        if self.Guid is None:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('the following JSON field is required: Guid')\n            else:\n                raise argparse.ArgumentTypeError('the following option is required: --guid')\n        if self.HardwareInstance > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field HardwareInstance must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--hardware-instance must be an integer in range 0x0..0xffffffffffffffff')\n        if self.MonotonicCount > 18446744073709551615:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field MonotonicCount must be an integer in range 0x0..0xffffffffffffffff')\n            else:\n                raise argparse.ArgumentTypeError('--monotonic-count must be an integer in range 0x0..0xffffffffffffffff')\n        if self.UpdateImageIndex > 255:\n            if args.JsonFile:\n                raise argparse.ArgumentTypeError('JSON field UpdateImageIndex must be an integer in range 0x0..0xff')\n            else:\n                raise argparse.ArgumentTypeError('--update-image-index must be an integer in range 0x0..0xff')\n    if self.UseSignTool:\n        if self.SignToolPfxFile is not None:\n            self.SignToolPfxFile.close()\n            self.SignToolPfxFile = self.SignToolPfxFile.name\n    if self.UseOpenSsl:\n        self.OpenSslSignerPrivateCertFile.close()\n        self.OpenSslOtherPublicCertFile.close()\n        self.OpenSslTrustedPublicCertFile.close()\n        self.OpenSslSignerPrivateCertFile = self.OpenSslSignerPrivateCertFile.name\n        self.OpenSslOtherPublicCertFile = self.OpenSslOtherPublicCertFile.name\n        self.OpenSslTrustedPublicCertFile = self.OpenSslTrustedPublicCertFile.name\n    if args.Encode:\n        if 'PersistAcrossReset' not in args.CapsuleFlag:\n            if 'InitiateReset' in args.CapsuleFlag:\n                raise argparse.ArgumentTypeError('--capflag InitiateReset also requires --capflag PersistAcrossReset')\n        if args.CapsuleOemFlag > 65535:\n            raise argparse.ArgumentTypeError('--capoemflag must be an integer between 0x0000 and 0xffff')\n    return True"
        ]
    },
    {
        "func_name": "Encode",
        "original": "def Encode(PayloadDescriptorList, EmbeddedDriverDescriptorList, Buffer):\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        EncodeJsonFileParse(Json)\n    else:\n        for Driver in args.EmbeddedDriver:\n            EmbeddedDriverDescriptorList.append(Driver.read())\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignToolSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        ImageCapsuleSupport = 0\n        Result = SinglePayloadDescriptor.Payload\n        try:\n            FmpPayloadHeader.FwVersion = SinglePayloadDescriptor.FwVersion\n            FmpPayloadHeader.LowestSupportedVersion = SinglePayloadDescriptor.LowestSupportedVersion\n            FmpPayloadHeader.Payload = SinglePayloadDescriptor.Payload\n            Result = FmpPayloadHeader.Encode()\n            if args.Verbose:\n                FmpPayloadHeader.DumpInfo()\n        except:\n            print('GenerateCapsule: error: can not encode FMP Payload Header')\n            sys.exit(1)\n        if SinglePayloadDescriptor.UseDependency:\n            CapsuleDependency.Payload = Result\n            CapsuleDependency.DepexExp = SinglePayloadDescriptor.DepexExp\n            ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_DEPENDENCY\n            Result = CapsuleDependency.Encode()\n            if args.Verbose:\n                CapsuleDependency.DumpInfo()\n        if SinglePayloadDescriptor.UseOpenSsl or SinglePayloadDescriptor.UseSignTool:\n            try:\n                if SinglePayloadDescriptor.UseSignTool:\n                    CertData = SignPayloadSignTool(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                else:\n                    CertData = SignPayloadOpenSsl(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n            except Exception as Msg:\n                print('GenerateCapsule: error: can not sign payload \\n' + str(Msg))\n                sys.exit(1)\n            try:\n                FmpAuthHeader.MonotonicCount = SinglePayloadDescriptor.MonotonicCount\n                FmpAuthHeader.CertData = CertData\n                FmpAuthHeader.Payload = Result\n                ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_AUTHENTICATION\n                Result = FmpAuthHeader.Encode()\n                if args.Verbose:\n                    FmpAuthHeader.DumpInfo()\n            except:\n                print('GenerateCapsule: error: can not encode FMP Auth Header')\n                sys.exit(1)\n        FmpCapsuleHeader.AddPayload(SinglePayloadDescriptor.Guid, Result, HardwareInstance=SinglePayloadDescriptor.HardwareInstance, UpdateImageIndex=SinglePayloadDescriptor.UpdateImageIndex, CapsuleSupport=ImageCapsuleSupport)\n    try:\n        for EmbeddedDriver in EmbeddedDriverDescriptorList:\n            FmpCapsuleHeader.AddEmbeddedDriver(EmbeddedDriver)\n        Result = FmpCapsuleHeader.Encode()\n        if args.Verbose:\n            FmpCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode FMP Capsule Header')\n        sys.exit(1)\n    try:\n        UefiCapsuleHeader.OemFlags = args.CapsuleOemFlag\n        UefiCapsuleHeader.PersistAcrossReset = 'PersistAcrossReset' in args.CapsuleFlag\n        UefiCapsuleHeader.PopulateSystemTable = False\n        UefiCapsuleHeader.InitiateReset = 'InitiateReset' in args.CapsuleFlag\n        UefiCapsuleHeader.Payload = Result\n        Result = UefiCapsuleHeader.Encode()\n        if args.Verbose:\n            UefiCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode UEFI Capsule Header')\n        sys.exit(1)\n    try:\n        if args.Verbose:\n            print('Write binary output file {File}'.format(File=args.OutputFile.name))\n        args.OutputFile.write(Result)\n        args.OutputFile.close()\n    except:\n        print('GenerateCapsule: error: can not write binary output file {File}'.format(File=args.OutputFile.name))\n        sys.exit(1)",
        "mutated": [
            "def Encode(PayloadDescriptorList, EmbeddedDriverDescriptorList, Buffer):\n    if False:\n        i = 10\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        EncodeJsonFileParse(Json)\n    else:\n        for Driver in args.EmbeddedDriver:\n            EmbeddedDriverDescriptorList.append(Driver.read())\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignToolSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        ImageCapsuleSupport = 0\n        Result = SinglePayloadDescriptor.Payload\n        try:\n            FmpPayloadHeader.FwVersion = SinglePayloadDescriptor.FwVersion\n            FmpPayloadHeader.LowestSupportedVersion = SinglePayloadDescriptor.LowestSupportedVersion\n            FmpPayloadHeader.Payload = SinglePayloadDescriptor.Payload\n            Result = FmpPayloadHeader.Encode()\n            if args.Verbose:\n                FmpPayloadHeader.DumpInfo()\n        except:\n            print('GenerateCapsule: error: can not encode FMP Payload Header')\n            sys.exit(1)\n        if SinglePayloadDescriptor.UseDependency:\n            CapsuleDependency.Payload = Result\n            CapsuleDependency.DepexExp = SinglePayloadDescriptor.DepexExp\n            ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_DEPENDENCY\n            Result = CapsuleDependency.Encode()\n            if args.Verbose:\n                CapsuleDependency.DumpInfo()\n        if SinglePayloadDescriptor.UseOpenSsl or SinglePayloadDescriptor.UseSignTool:\n            try:\n                if SinglePayloadDescriptor.UseSignTool:\n                    CertData = SignPayloadSignTool(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                else:\n                    CertData = SignPayloadOpenSsl(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n            except Exception as Msg:\n                print('GenerateCapsule: error: can not sign payload \\n' + str(Msg))\n                sys.exit(1)\n            try:\n                FmpAuthHeader.MonotonicCount = SinglePayloadDescriptor.MonotonicCount\n                FmpAuthHeader.CertData = CertData\n                FmpAuthHeader.Payload = Result\n                ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_AUTHENTICATION\n                Result = FmpAuthHeader.Encode()\n                if args.Verbose:\n                    FmpAuthHeader.DumpInfo()\n            except:\n                print('GenerateCapsule: error: can not encode FMP Auth Header')\n                sys.exit(1)\n        FmpCapsuleHeader.AddPayload(SinglePayloadDescriptor.Guid, Result, HardwareInstance=SinglePayloadDescriptor.HardwareInstance, UpdateImageIndex=SinglePayloadDescriptor.UpdateImageIndex, CapsuleSupport=ImageCapsuleSupport)\n    try:\n        for EmbeddedDriver in EmbeddedDriverDescriptorList:\n            FmpCapsuleHeader.AddEmbeddedDriver(EmbeddedDriver)\n        Result = FmpCapsuleHeader.Encode()\n        if args.Verbose:\n            FmpCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode FMP Capsule Header')\n        sys.exit(1)\n    try:\n        UefiCapsuleHeader.OemFlags = args.CapsuleOemFlag\n        UefiCapsuleHeader.PersistAcrossReset = 'PersistAcrossReset' in args.CapsuleFlag\n        UefiCapsuleHeader.PopulateSystemTable = False\n        UefiCapsuleHeader.InitiateReset = 'InitiateReset' in args.CapsuleFlag\n        UefiCapsuleHeader.Payload = Result\n        Result = UefiCapsuleHeader.Encode()\n        if args.Verbose:\n            UefiCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode UEFI Capsule Header')\n        sys.exit(1)\n    try:\n        if args.Verbose:\n            print('Write binary output file {File}'.format(File=args.OutputFile.name))\n        args.OutputFile.write(Result)\n        args.OutputFile.close()\n    except:\n        print('GenerateCapsule: error: can not write binary output file {File}'.format(File=args.OutputFile.name))\n        sys.exit(1)",
            "def Encode(PayloadDescriptorList, EmbeddedDriverDescriptorList, Buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        EncodeJsonFileParse(Json)\n    else:\n        for Driver in args.EmbeddedDriver:\n            EmbeddedDriverDescriptorList.append(Driver.read())\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignToolSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        ImageCapsuleSupport = 0\n        Result = SinglePayloadDescriptor.Payload\n        try:\n            FmpPayloadHeader.FwVersion = SinglePayloadDescriptor.FwVersion\n            FmpPayloadHeader.LowestSupportedVersion = SinglePayloadDescriptor.LowestSupportedVersion\n            FmpPayloadHeader.Payload = SinglePayloadDescriptor.Payload\n            Result = FmpPayloadHeader.Encode()\n            if args.Verbose:\n                FmpPayloadHeader.DumpInfo()\n        except:\n            print('GenerateCapsule: error: can not encode FMP Payload Header')\n            sys.exit(1)\n        if SinglePayloadDescriptor.UseDependency:\n            CapsuleDependency.Payload = Result\n            CapsuleDependency.DepexExp = SinglePayloadDescriptor.DepexExp\n            ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_DEPENDENCY\n            Result = CapsuleDependency.Encode()\n            if args.Verbose:\n                CapsuleDependency.DumpInfo()\n        if SinglePayloadDescriptor.UseOpenSsl or SinglePayloadDescriptor.UseSignTool:\n            try:\n                if SinglePayloadDescriptor.UseSignTool:\n                    CertData = SignPayloadSignTool(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                else:\n                    CertData = SignPayloadOpenSsl(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n            except Exception as Msg:\n                print('GenerateCapsule: error: can not sign payload \\n' + str(Msg))\n                sys.exit(1)\n            try:\n                FmpAuthHeader.MonotonicCount = SinglePayloadDescriptor.MonotonicCount\n                FmpAuthHeader.CertData = CertData\n                FmpAuthHeader.Payload = Result\n                ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_AUTHENTICATION\n                Result = FmpAuthHeader.Encode()\n                if args.Verbose:\n                    FmpAuthHeader.DumpInfo()\n            except:\n                print('GenerateCapsule: error: can not encode FMP Auth Header')\n                sys.exit(1)\n        FmpCapsuleHeader.AddPayload(SinglePayloadDescriptor.Guid, Result, HardwareInstance=SinglePayloadDescriptor.HardwareInstance, UpdateImageIndex=SinglePayloadDescriptor.UpdateImageIndex, CapsuleSupport=ImageCapsuleSupport)\n    try:\n        for EmbeddedDriver in EmbeddedDriverDescriptorList:\n            FmpCapsuleHeader.AddEmbeddedDriver(EmbeddedDriver)\n        Result = FmpCapsuleHeader.Encode()\n        if args.Verbose:\n            FmpCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode FMP Capsule Header')\n        sys.exit(1)\n    try:\n        UefiCapsuleHeader.OemFlags = args.CapsuleOemFlag\n        UefiCapsuleHeader.PersistAcrossReset = 'PersistAcrossReset' in args.CapsuleFlag\n        UefiCapsuleHeader.PopulateSystemTable = False\n        UefiCapsuleHeader.InitiateReset = 'InitiateReset' in args.CapsuleFlag\n        UefiCapsuleHeader.Payload = Result\n        Result = UefiCapsuleHeader.Encode()\n        if args.Verbose:\n            UefiCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode UEFI Capsule Header')\n        sys.exit(1)\n    try:\n        if args.Verbose:\n            print('Write binary output file {File}'.format(File=args.OutputFile.name))\n        args.OutputFile.write(Result)\n        args.OutputFile.close()\n    except:\n        print('GenerateCapsule: error: can not write binary output file {File}'.format(File=args.OutputFile.name))\n        sys.exit(1)",
            "def Encode(PayloadDescriptorList, EmbeddedDriverDescriptorList, Buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        EncodeJsonFileParse(Json)\n    else:\n        for Driver in args.EmbeddedDriver:\n            EmbeddedDriverDescriptorList.append(Driver.read())\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignToolSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        ImageCapsuleSupport = 0\n        Result = SinglePayloadDescriptor.Payload\n        try:\n            FmpPayloadHeader.FwVersion = SinglePayloadDescriptor.FwVersion\n            FmpPayloadHeader.LowestSupportedVersion = SinglePayloadDescriptor.LowestSupportedVersion\n            FmpPayloadHeader.Payload = SinglePayloadDescriptor.Payload\n            Result = FmpPayloadHeader.Encode()\n            if args.Verbose:\n                FmpPayloadHeader.DumpInfo()\n        except:\n            print('GenerateCapsule: error: can not encode FMP Payload Header')\n            sys.exit(1)\n        if SinglePayloadDescriptor.UseDependency:\n            CapsuleDependency.Payload = Result\n            CapsuleDependency.DepexExp = SinglePayloadDescriptor.DepexExp\n            ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_DEPENDENCY\n            Result = CapsuleDependency.Encode()\n            if args.Verbose:\n                CapsuleDependency.DumpInfo()\n        if SinglePayloadDescriptor.UseOpenSsl or SinglePayloadDescriptor.UseSignTool:\n            try:\n                if SinglePayloadDescriptor.UseSignTool:\n                    CertData = SignPayloadSignTool(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                else:\n                    CertData = SignPayloadOpenSsl(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n            except Exception as Msg:\n                print('GenerateCapsule: error: can not sign payload \\n' + str(Msg))\n                sys.exit(1)\n            try:\n                FmpAuthHeader.MonotonicCount = SinglePayloadDescriptor.MonotonicCount\n                FmpAuthHeader.CertData = CertData\n                FmpAuthHeader.Payload = Result\n                ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_AUTHENTICATION\n                Result = FmpAuthHeader.Encode()\n                if args.Verbose:\n                    FmpAuthHeader.DumpInfo()\n            except:\n                print('GenerateCapsule: error: can not encode FMP Auth Header')\n                sys.exit(1)\n        FmpCapsuleHeader.AddPayload(SinglePayloadDescriptor.Guid, Result, HardwareInstance=SinglePayloadDescriptor.HardwareInstance, UpdateImageIndex=SinglePayloadDescriptor.UpdateImageIndex, CapsuleSupport=ImageCapsuleSupport)\n    try:\n        for EmbeddedDriver in EmbeddedDriverDescriptorList:\n            FmpCapsuleHeader.AddEmbeddedDriver(EmbeddedDriver)\n        Result = FmpCapsuleHeader.Encode()\n        if args.Verbose:\n            FmpCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode FMP Capsule Header')\n        sys.exit(1)\n    try:\n        UefiCapsuleHeader.OemFlags = args.CapsuleOemFlag\n        UefiCapsuleHeader.PersistAcrossReset = 'PersistAcrossReset' in args.CapsuleFlag\n        UefiCapsuleHeader.PopulateSystemTable = False\n        UefiCapsuleHeader.InitiateReset = 'InitiateReset' in args.CapsuleFlag\n        UefiCapsuleHeader.Payload = Result\n        Result = UefiCapsuleHeader.Encode()\n        if args.Verbose:\n            UefiCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode UEFI Capsule Header')\n        sys.exit(1)\n    try:\n        if args.Verbose:\n            print('Write binary output file {File}'.format(File=args.OutputFile.name))\n        args.OutputFile.write(Result)\n        args.OutputFile.close()\n    except:\n        print('GenerateCapsule: error: can not write binary output file {File}'.format(File=args.OutputFile.name))\n        sys.exit(1)",
            "def Encode(PayloadDescriptorList, EmbeddedDriverDescriptorList, Buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        EncodeJsonFileParse(Json)\n    else:\n        for Driver in args.EmbeddedDriver:\n            EmbeddedDriverDescriptorList.append(Driver.read())\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignToolSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        ImageCapsuleSupport = 0\n        Result = SinglePayloadDescriptor.Payload\n        try:\n            FmpPayloadHeader.FwVersion = SinglePayloadDescriptor.FwVersion\n            FmpPayloadHeader.LowestSupportedVersion = SinglePayloadDescriptor.LowestSupportedVersion\n            FmpPayloadHeader.Payload = SinglePayloadDescriptor.Payload\n            Result = FmpPayloadHeader.Encode()\n            if args.Verbose:\n                FmpPayloadHeader.DumpInfo()\n        except:\n            print('GenerateCapsule: error: can not encode FMP Payload Header')\n            sys.exit(1)\n        if SinglePayloadDescriptor.UseDependency:\n            CapsuleDependency.Payload = Result\n            CapsuleDependency.DepexExp = SinglePayloadDescriptor.DepexExp\n            ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_DEPENDENCY\n            Result = CapsuleDependency.Encode()\n            if args.Verbose:\n                CapsuleDependency.DumpInfo()\n        if SinglePayloadDescriptor.UseOpenSsl or SinglePayloadDescriptor.UseSignTool:\n            try:\n                if SinglePayloadDescriptor.UseSignTool:\n                    CertData = SignPayloadSignTool(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                else:\n                    CertData = SignPayloadOpenSsl(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n            except Exception as Msg:\n                print('GenerateCapsule: error: can not sign payload \\n' + str(Msg))\n                sys.exit(1)\n            try:\n                FmpAuthHeader.MonotonicCount = SinglePayloadDescriptor.MonotonicCount\n                FmpAuthHeader.CertData = CertData\n                FmpAuthHeader.Payload = Result\n                ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_AUTHENTICATION\n                Result = FmpAuthHeader.Encode()\n                if args.Verbose:\n                    FmpAuthHeader.DumpInfo()\n            except:\n                print('GenerateCapsule: error: can not encode FMP Auth Header')\n                sys.exit(1)\n        FmpCapsuleHeader.AddPayload(SinglePayloadDescriptor.Guid, Result, HardwareInstance=SinglePayloadDescriptor.HardwareInstance, UpdateImageIndex=SinglePayloadDescriptor.UpdateImageIndex, CapsuleSupport=ImageCapsuleSupport)\n    try:\n        for EmbeddedDriver in EmbeddedDriverDescriptorList:\n            FmpCapsuleHeader.AddEmbeddedDriver(EmbeddedDriver)\n        Result = FmpCapsuleHeader.Encode()\n        if args.Verbose:\n            FmpCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode FMP Capsule Header')\n        sys.exit(1)\n    try:\n        UefiCapsuleHeader.OemFlags = args.CapsuleOemFlag\n        UefiCapsuleHeader.PersistAcrossReset = 'PersistAcrossReset' in args.CapsuleFlag\n        UefiCapsuleHeader.PopulateSystemTable = False\n        UefiCapsuleHeader.InitiateReset = 'InitiateReset' in args.CapsuleFlag\n        UefiCapsuleHeader.Payload = Result\n        Result = UefiCapsuleHeader.Encode()\n        if args.Verbose:\n            UefiCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode UEFI Capsule Header')\n        sys.exit(1)\n    try:\n        if args.Verbose:\n            print('Write binary output file {File}'.format(File=args.OutputFile.name))\n        args.OutputFile.write(Result)\n        args.OutputFile.close()\n    except:\n        print('GenerateCapsule: error: can not write binary output file {File}'.format(File=args.OutputFile.name))\n        sys.exit(1)",
            "def Encode(PayloadDescriptorList, EmbeddedDriverDescriptorList, Buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        EncodeJsonFileParse(Json)\n    else:\n        for Driver in args.EmbeddedDriver:\n            EmbeddedDriverDescriptorList.append(Driver.read())\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignToolSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        ImageCapsuleSupport = 0\n        Result = SinglePayloadDescriptor.Payload\n        try:\n            FmpPayloadHeader.FwVersion = SinglePayloadDescriptor.FwVersion\n            FmpPayloadHeader.LowestSupportedVersion = SinglePayloadDescriptor.LowestSupportedVersion\n            FmpPayloadHeader.Payload = SinglePayloadDescriptor.Payload\n            Result = FmpPayloadHeader.Encode()\n            if args.Verbose:\n                FmpPayloadHeader.DumpInfo()\n        except:\n            print('GenerateCapsule: error: can not encode FMP Payload Header')\n            sys.exit(1)\n        if SinglePayloadDescriptor.UseDependency:\n            CapsuleDependency.Payload = Result\n            CapsuleDependency.DepexExp = SinglePayloadDescriptor.DepexExp\n            ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_DEPENDENCY\n            Result = CapsuleDependency.Encode()\n            if args.Verbose:\n                CapsuleDependency.DumpInfo()\n        if SinglePayloadDescriptor.UseOpenSsl or SinglePayloadDescriptor.UseSignTool:\n            try:\n                if SinglePayloadDescriptor.UseSignTool:\n                    CertData = SignPayloadSignTool(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                else:\n                    CertData = SignPayloadOpenSsl(Result + struct.pack('<Q', SinglePayloadDescriptor.MonotonicCount), SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n            except Exception as Msg:\n                print('GenerateCapsule: error: can not sign payload \\n' + str(Msg))\n                sys.exit(1)\n            try:\n                FmpAuthHeader.MonotonicCount = SinglePayloadDescriptor.MonotonicCount\n                FmpAuthHeader.CertData = CertData\n                FmpAuthHeader.Payload = Result\n                ImageCapsuleSupport |= FmpCapsuleHeader.CAPSULE_SUPPORT_AUTHENTICATION\n                Result = FmpAuthHeader.Encode()\n                if args.Verbose:\n                    FmpAuthHeader.DumpInfo()\n            except:\n                print('GenerateCapsule: error: can not encode FMP Auth Header')\n                sys.exit(1)\n        FmpCapsuleHeader.AddPayload(SinglePayloadDescriptor.Guid, Result, HardwareInstance=SinglePayloadDescriptor.HardwareInstance, UpdateImageIndex=SinglePayloadDescriptor.UpdateImageIndex, CapsuleSupport=ImageCapsuleSupport)\n    try:\n        for EmbeddedDriver in EmbeddedDriverDescriptorList:\n            FmpCapsuleHeader.AddEmbeddedDriver(EmbeddedDriver)\n        Result = FmpCapsuleHeader.Encode()\n        if args.Verbose:\n            FmpCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode FMP Capsule Header')\n        sys.exit(1)\n    try:\n        UefiCapsuleHeader.OemFlags = args.CapsuleOemFlag\n        UefiCapsuleHeader.PersistAcrossReset = 'PersistAcrossReset' in args.CapsuleFlag\n        UefiCapsuleHeader.PopulateSystemTable = False\n        UefiCapsuleHeader.InitiateReset = 'InitiateReset' in args.CapsuleFlag\n        UefiCapsuleHeader.Payload = Result\n        Result = UefiCapsuleHeader.Encode()\n        if args.Verbose:\n            UefiCapsuleHeader.DumpInfo()\n    except:\n        print('GenerateCapsule: error: can not encode UEFI Capsule Header')\n        sys.exit(1)\n    try:\n        if args.Verbose:\n            print('Write binary output file {File}'.format(File=args.OutputFile.name))\n        args.OutputFile.write(Result)\n        args.OutputFile.close()\n    except:\n        print('GenerateCapsule: error: can not write binary output file {File}'.format(File=args.OutputFile.name))\n        sys.exit(1)"
        ]
    },
    {
        "func_name": "Decode",
        "original": "def Decode(PayloadDescriptorList, PayloadJsonDescriptorList, Buffer):\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        DecodeJsonFileParse(Json)\n    else:\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        if len(Result) > 0:\n            Result = FmpCapsuleHeader.Decode(Result)\n            if args.JsonFile:\n                if FmpCapsuleHeader.PayloadItemCount != len(PayloadDescriptorList):\n                    CapsulePayloadNum = FmpCapsuleHeader.PayloadItemCount\n                    JsonPayloadNum = len(PayloadDescriptorList)\n                    print('GenerateCapsule: Decode error: {JsonPayloadNumber} payloads in JSON file {File} and {CapsulePayloadNumber} payloads in Capsule {CapsuleName}'.format(JsonPayloadNumber=JsonPayloadNum, File=args.JsonFile.name, CapsulePayloadNumber=CapsulePayloadNum, CapsuleName=args.InputFile.name))\n                    sys.exit(1)\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index < len(PayloadDescriptorList):\n                        GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                        HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                        UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                        if PayloadDescriptorList[Index].Guid != GUID or PayloadDescriptorList[Index].HardwareInstance != HardwareInstance:\n                            print('GenerateCapsule: Decode error: Guid or HardwareInstance pair in input JSON file {File} does not match the payload {PayloadIndex} in Capsule {InputCapsule}'.format(File=args.JsonFile.name, PayloadIndex=Index + 1, InputCapsule=args.InputFile.name))\n                            sys.exit(1)\n                        PayloadDescriptorList[Index].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                        PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            else:\n                PayloadDescriptorList[0].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(0).Payload\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index > 0:\n                        PayloadDecodeFile = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        PayloadDescriptorList.append(PayloadDescriptor(PayloadDecodeFile, None, None, None, None, None, None, None, None, None, None, None, None))\n                    GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                    HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                    UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                    DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                    PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            JsonIndex = 0\n            for SinglePayloadDescriptor in PayloadDescriptorList:\n                if args.Verbose:\n                    print('========')\n                    UefiCapsuleHeader.DumpInfo()\n                    print('--------')\n                    FmpCapsuleHeader.DumpInfo()\n                if FmpAuthHeader.IsSigned(SinglePayloadDescriptor.Payload):\n                    if not SinglePayloadDescriptor.UseOpenSsl and (not SinglePayloadDescriptor.UseSignTool):\n                        print('GenerateCapsule: decode warning: can not verify singed payload without cert or pfx file. Index = {Index}'.format(Index=JsonIndex + 1))\n                    SinglePayloadDescriptor.Payload = FmpAuthHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].MonotonicCount = FmpAuthHeader.MonotonicCount\n                    if args.Verbose:\n                        print('--------')\n                        FmpAuthHeader.DumpInfo()\n                    try:\n                        if SinglePayloadDescriptor.UseSignTool:\n                            CertData = VerifyPayloadSignTool(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                        else:\n                            CertData = VerifyPayloadOpenSsl(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n                    except Exception as Msg:\n                        print('GenerateCapsule: warning: payload verification failed Index = {Index} \\n'.format(Index=JsonIndex + 1) + str(Msg))\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', SinglePayloadDescriptor.Payload[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    SinglePayloadDescriptor.UseDependency = True\n                    try:\n                        SinglePayloadDescriptor.Payload = CapsuleDependency.Decode(SinglePayloadDescriptor.Payload)\n                        PayloadJsonDescriptorList[JsonIndex].DepexExp = CapsuleDependency.DepexExp\n                        if args.Verbose:\n                            print('--------')\n                            CapsuleDependency.DumpInfo()\n                    except Exception as Msg:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    SinglePayloadDescriptor.Payload = FmpPayloadHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].FwVersion = FmpPayloadHeader.FwVersion\n                    PayloadJsonDescriptorList[JsonIndex].LowestSupportedVersion = FmpPayloadHeader.LowestSupportedVersion\n                    JsonIndex = JsonIndex + 1\n                    if args.Verbose:\n                        print('--------')\n                        FmpPayloadHeader.DumpInfo()\n                        print('========')\n                except:\n                    if args.Verbose:\n                        print('--------')\n                        print('No FMP_PAYLOAD_HEADER')\n                        print('========')\n                    sys.exit(1)\n            for Index in range(0, FmpCapsuleHeader.EmbeddedDriverCount):\n                EmbeddedDriverBuffer = FmpCapsuleHeader.GetEmbeddedDriver(Index)\n                EmbeddedDriverPath = args.OutputFile.name + '.EmbeddedDriver.{Index:d}.efi'.format(Index=Index + 1)\n                try:\n                    if args.Verbose:\n                        print('Write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    with open(EmbeddedDriverPath, 'wb') as EmbeddedDriverFile:\n                        EmbeddedDriverFile.write(EmbeddedDriverBuffer)\n                except:\n                    print('GenerateCapsule: error: can not write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    sys.exit(1)\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)\n    GenerateOutputJson(PayloadJsonDescriptorList)\n    PayloadIndex = 0\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        if args.OutputFile is None:\n            print('GenerateCapsule: Decode error: OutputFile is needed for decode output')\n            sys.exit(1)\n        try:\n            if args.Verbose:\n                print('Write binary output file {File}'.format(File=args.OutputFile.name))\n            PayloadDecodePath = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=PayloadIndex + 1)\n            with open(PayloadDecodePath, 'wb') as PayloadDecodeFile:\n                PayloadDecodeFile.write(SinglePayloadDescriptor.Payload)\n            PayloadIndex = PayloadIndex + 1\n        except:\n            print('GenerateCapsule: error: can not write binary output file {File}'.format(File=SinglePayloadDescriptor.OutputFile.name))\n            sys.exit(1)",
        "mutated": [
            "def Decode(PayloadDescriptorList, PayloadJsonDescriptorList, Buffer):\n    if False:\n        i = 10\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        DecodeJsonFileParse(Json)\n    else:\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        if len(Result) > 0:\n            Result = FmpCapsuleHeader.Decode(Result)\n            if args.JsonFile:\n                if FmpCapsuleHeader.PayloadItemCount != len(PayloadDescriptorList):\n                    CapsulePayloadNum = FmpCapsuleHeader.PayloadItemCount\n                    JsonPayloadNum = len(PayloadDescriptorList)\n                    print('GenerateCapsule: Decode error: {JsonPayloadNumber} payloads in JSON file {File} and {CapsulePayloadNumber} payloads in Capsule {CapsuleName}'.format(JsonPayloadNumber=JsonPayloadNum, File=args.JsonFile.name, CapsulePayloadNumber=CapsulePayloadNum, CapsuleName=args.InputFile.name))\n                    sys.exit(1)\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index < len(PayloadDescriptorList):\n                        GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                        HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                        UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                        if PayloadDescriptorList[Index].Guid != GUID or PayloadDescriptorList[Index].HardwareInstance != HardwareInstance:\n                            print('GenerateCapsule: Decode error: Guid or HardwareInstance pair in input JSON file {File} does not match the payload {PayloadIndex} in Capsule {InputCapsule}'.format(File=args.JsonFile.name, PayloadIndex=Index + 1, InputCapsule=args.InputFile.name))\n                            sys.exit(1)\n                        PayloadDescriptorList[Index].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                        PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            else:\n                PayloadDescriptorList[0].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(0).Payload\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index > 0:\n                        PayloadDecodeFile = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        PayloadDescriptorList.append(PayloadDescriptor(PayloadDecodeFile, None, None, None, None, None, None, None, None, None, None, None, None))\n                    GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                    HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                    UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                    DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                    PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            JsonIndex = 0\n            for SinglePayloadDescriptor in PayloadDescriptorList:\n                if args.Verbose:\n                    print('========')\n                    UefiCapsuleHeader.DumpInfo()\n                    print('--------')\n                    FmpCapsuleHeader.DumpInfo()\n                if FmpAuthHeader.IsSigned(SinglePayloadDescriptor.Payload):\n                    if not SinglePayloadDescriptor.UseOpenSsl and (not SinglePayloadDescriptor.UseSignTool):\n                        print('GenerateCapsule: decode warning: can not verify singed payload without cert or pfx file. Index = {Index}'.format(Index=JsonIndex + 1))\n                    SinglePayloadDescriptor.Payload = FmpAuthHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].MonotonicCount = FmpAuthHeader.MonotonicCount\n                    if args.Verbose:\n                        print('--------')\n                        FmpAuthHeader.DumpInfo()\n                    try:\n                        if SinglePayloadDescriptor.UseSignTool:\n                            CertData = VerifyPayloadSignTool(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                        else:\n                            CertData = VerifyPayloadOpenSsl(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n                    except Exception as Msg:\n                        print('GenerateCapsule: warning: payload verification failed Index = {Index} \\n'.format(Index=JsonIndex + 1) + str(Msg))\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', SinglePayloadDescriptor.Payload[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    SinglePayloadDescriptor.UseDependency = True\n                    try:\n                        SinglePayloadDescriptor.Payload = CapsuleDependency.Decode(SinglePayloadDescriptor.Payload)\n                        PayloadJsonDescriptorList[JsonIndex].DepexExp = CapsuleDependency.DepexExp\n                        if args.Verbose:\n                            print('--------')\n                            CapsuleDependency.DumpInfo()\n                    except Exception as Msg:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    SinglePayloadDescriptor.Payload = FmpPayloadHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].FwVersion = FmpPayloadHeader.FwVersion\n                    PayloadJsonDescriptorList[JsonIndex].LowestSupportedVersion = FmpPayloadHeader.LowestSupportedVersion\n                    JsonIndex = JsonIndex + 1\n                    if args.Verbose:\n                        print('--------')\n                        FmpPayloadHeader.DumpInfo()\n                        print('========')\n                except:\n                    if args.Verbose:\n                        print('--------')\n                        print('No FMP_PAYLOAD_HEADER')\n                        print('========')\n                    sys.exit(1)\n            for Index in range(0, FmpCapsuleHeader.EmbeddedDriverCount):\n                EmbeddedDriverBuffer = FmpCapsuleHeader.GetEmbeddedDriver(Index)\n                EmbeddedDriverPath = args.OutputFile.name + '.EmbeddedDriver.{Index:d}.efi'.format(Index=Index + 1)\n                try:\n                    if args.Verbose:\n                        print('Write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    with open(EmbeddedDriverPath, 'wb') as EmbeddedDriverFile:\n                        EmbeddedDriverFile.write(EmbeddedDriverBuffer)\n                except:\n                    print('GenerateCapsule: error: can not write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    sys.exit(1)\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)\n    GenerateOutputJson(PayloadJsonDescriptorList)\n    PayloadIndex = 0\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        if args.OutputFile is None:\n            print('GenerateCapsule: Decode error: OutputFile is needed for decode output')\n            sys.exit(1)\n        try:\n            if args.Verbose:\n                print('Write binary output file {File}'.format(File=args.OutputFile.name))\n            PayloadDecodePath = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=PayloadIndex + 1)\n            with open(PayloadDecodePath, 'wb') as PayloadDecodeFile:\n                PayloadDecodeFile.write(SinglePayloadDescriptor.Payload)\n            PayloadIndex = PayloadIndex + 1\n        except:\n            print('GenerateCapsule: error: can not write binary output file {File}'.format(File=SinglePayloadDescriptor.OutputFile.name))\n            sys.exit(1)",
            "def Decode(PayloadDescriptorList, PayloadJsonDescriptorList, Buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        DecodeJsonFileParse(Json)\n    else:\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        if len(Result) > 0:\n            Result = FmpCapsuleHeader.Decode(Result)\n            if args.JsonFile:\n                if FmpCapsuleHeader.PayloadItemCount != len(PayloadDescriptorList):\n                    CapsulePayloadNum = FmpCapsuleHeader.PayloadItemCount\n                    JsonPayloadNum = len(PayloadDescriptorList)\n                    print('GenerateCapsule: Decode error: {JsonPayloadNumber} payloads in JSON file {File} and {CapsulePayloadNumber} payloads in Capsule {CapsuleName}'.format(JsonPayloadNumber=JsonPayloadNum, File=args.JsonFile.name, CapsulePayloadNumber=CapsulePayloadNum, CapsuleName=args.InputFile.name))\n                    sys.exit(1)\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index < len(PayloadDescriptorList):\n                        GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                        HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                        UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                        if PayloadDescriptorList[Index].Guid != GUID or PayloadDescriptorList[Index].HardwareInstance != HardwareInstance:\n                            print('GenerateCapsule: Decode error: Guid or HardwareInstance pair in input JSON file {File} does not match the payload {PayloadIndex} in Capsule {InputCapsule}'.format(File=args.JsonFile.name, PayloadIndex=Index + 1, InputCapsule=args.InputFile.name))\n                            sys.exit(1)\n                        PayloadDescriptorList[Index].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                        PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            else:\n                PayloadDescriptorList[0].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(0).Payload\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index > 0:\n                        PayloadDecodeFile = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        PayloadDescriptorList.append(PayloadDescriptor(PayloadDecodeFile, None, None, None, None, None, None, None, None, None, None, None, None))\n                    GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                    HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                    UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                    DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                    PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            JsonIndex = 0\n            for SinglePayloadDescriptor in PayloadDescriptorList:\n                if args.Verbose:\n                    print('========')\n                    UefiCapsuleHeader.DumpInfo()\n                    print('--------')\n                    FmpCapsuleHeader.DumpInfo()\n                if FmpAuthHeader.IsSigned(SinglePayloadDescriptor.Payload):\n                    if not SinglePayloadDescriptor.UseOpenSsl and (not SinglePayloadDescriptor.UseSignTool):\n                        print('GenerateCapsule: decode warning: can not verify singed payload without cert or pfx file. Index = {Index}'.format(Index=JsonIndex + 1))\n                    SinglePayloadDescriptor.Payload = FmpAuthHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].MonotonicCount = FmpAuthHeader.MonotonicCount\n                    if args.Verbose:\n                        print('--------')\n                        FmpAuthHeader.DumpInfo()\n                    try:\n                        if SinglePayloadDescriptor.UseSignTool:\n                            CertData = VerifyPayloadSignTool(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                        else:\n                            CertData = VerifyPayloadOpenSsl(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n                    except Exception as Msg:\n                        print('GenerateCapsule: warning: payload verification failed Index = {Index} \\n'.format(Index=JsonIndex + 1) + str(Msg))\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', SinglePayloadDescriptor.Payload[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    SinglePayloadDescriptor.UseDependency = True\n                    try:\n                        SinglePayloadDescriptor.Payload = CapsuleDependency.Decode(SinglePayloadDescriptor.Payload)\n                        PayloadJsonDescriptorList[JsonIndex].DepexExp = CapsuleDependency.DepexExp\n                        if args.Verbose:\n                            print('--------')\n                            CapsuleDependency.DumpInfo()\n                    except Exception as Msg:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    SinglePayloadDescriptor.Payload = FmpPayloadHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].FwVersion = FmpPayloadHeader.FwVersion\n                    PayloadJsonDescriptorList[JsonIndex].LowestSupportedVersion = FmpPayloadHeader.LowestSupportedVersion\n                    JsonIndex = JsonIndex + 1\n                    if args.Verbose:\n                        print('--------')\n                        FmpPayloadHeader.DumpInfo()\n                        print('========')\n                except:\n                    if args.Verbose:\n                        print('--------')\n                        print('No FMP_PAYLOAD_HEADER')\n                        print('========')\n                    sys.exit(1)\n            for Index in range(0, FmpCapsuleHeader.EmbeddedDriverCount):\n                EmbeddedDriverBuffer = FmpCapsuleHeader.GetEmbeddedDriver(Index)\n                EmbeddedDriverPath = args.OutputFile.name + '.EmbeddedDriver.{Index:d}.efi'.format(Index=Index + 1)\n                try:\n                    if args.Verbose:\n                        print('Write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    with open(EmbeddedDriverPath, 'wb') as EmbeddedDriverFile:\n                        EmbeddedDriverFile.write(EmbeddedDriverBuffer)\n                except:\n                    print('GenerateCapsule: error: can not write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    sys.exit(1)\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)\n    GenerateOutputJson(PayloadJsonDescriptorList)\n    PayloadIndex = 0\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        if args.OutputFile is None:\n            print('GenerateCapsule: Decode error: OutputFile is needed for decode output')\n            sys.exit(1)\n        try:\n            if args.Verbose:\n                print('Write binary output file {File}'.format(File=args.OutputFile.name))\n            PayloadDecodePath = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=PayloadIndex + 1)\n            with open(PayloadDecodePath, 'wb') as PayloadDecodeFile:\n                PayloadDecodeFile.write(SinglePayloadDescriptor.Payload)\n            PayloadIndex = PayloadIndex + 1\n        except:\n            print('GenerateCapsule: error: can not write binary output file {File}'.format(File=SinglePayloadDescriptor.OutputFile.name))\n            sys.exit(1)",
            "def Decode(PayloadDescriptorList, PayloadJsonDescriptorList, Buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        DecodeJsonFileParse(Json)\n    else:\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        if len(Result) > 0:\n            Result = FmpCapsuleHeader.Decode(Result)\n            if args.JsonFile:\n                if FmpCapsuleHeader.PayloadItemCount != len(PayloadDescriptorList):\n                    CapsulePayloadNum = FmpCapsuleHeader.PayloadItemCount\n                    JsonPayloadNum = len(PayloadDescriptorList)\n                    print('GenerateCapsule: Decode error: {JsonPayloadNumber} payloads in JSON file {File} and {CapsulePayloadNumber} payloads in Capsule {CapsuleName}'.format(JsonPayloadNumber=JsonPayloadNum, File=args.JsonFile.name, CapsulePayloadNumber=CapsulePayloadNum, CapsuleName=args.InputFile.name))\n                    sys.exit(1)\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index < len(PayloadDescriptorList):\n                        GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                        HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                        UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                        if PayloadDescriptorList[Index].Guid != GUID or PayloadDescriptorList[Index].HardwareInstance != HardwareInstance:\n                            print('GenerateCapsule: Decode error: Guid or HardwareInstance pair in input JSON file {File} does not match the payload {PayloadIndex} in Capsule {InputCapsule}'.format(File=args.JsonFile.name, PayloadIndex=Index + 1, InputCapsule=args.InputFile.name))\n                            sys.exit(1)\n                        PayloadDescriptorList[Index].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                        PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            else:\n                PayloadDescriptorList[0].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(0).Payload\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index > 0:\n                        PayloadDecodeFile = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        PayloadDescriptorList.append(PayloadDescriptor(PayloadDecodeFile, None, None, None, None, None, None, None, None, None, None, None, None))\n                    GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                    HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                    UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                    DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                    PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            JsonIndex = 0\n            for SinglePayloadDescriptor in PayloadDescriptorList:\n                if args.Verbose:\n                    print('========')\n                    UefiCapsuleHeader.DumpInfo()\n                    print('--------')\n                    FmpCapsuleHeader.DumpInfo()\n                if FmpAuthHeader.IsSigned(SinglePayloadDescriptor.Payload):\n                    if not SinglePayloadDescriptor.UseOpenSsl and (not SinglePayloadDescriptor.UseSignTool):\n                        print('GenerateCapsule: decode warning: can not verify singed payload without cert or pfx file. Index = {Index}'.format(Index=JsonIndex + 1))\n                    SinglePayloadDescriptor.Payload = FmpAuthHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].MonotonicCount = FmpAuthHeader.MonotonicCount\n                    if args.Verbose:\n                        print('--------')\n                        FmpAuthHeader.DumpInfo()\n                    try:\n                        if SinglePayloadDescriptor.UseSignTool:\n                            CertData = VerifyPayloadSignTool(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                        else:\n                            CertData = VerifyPayloadOpenSsl(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n                    except Exception as Msg:\n                        print('GenerateCapsule: warning: payload verification failed Index = {Index} \\n'.format(Index=JsonIndex + 1) + str(Msg))\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', SinglePayloadDescriptor.Payload[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    SinglePayloadDescriptor.UseDependency = True\n                    try:\n                        SinglePayloadDescriptor.Payload = CapsuleDependency.Decode(SinglePayloadDescriptor.Payload)\n                        PayloadJsonDescriptorList[JsonIndex].DepexExp = CapsuleDependency.DepexExp\n                        if args.Verbose:\n                            print('--------')\n                            CapsuleDependency.DumpInfo()\n                    except Exception as Msg:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    SinglePayloadDescriptor.Payload = FmpPayloadHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].FwVersion = FmpPayloadHeader.FwVersion\n                    PayloadJsonDescriptorList[JsonIndex].LowestSupportedVersion = FmpPayloadHeader.LowestSupportedVersion\n                    JsonIndex = JsonIndex + 1\n                    if args.Verbose:\n                        print('--------')\n                        FmpPayloadHeader.DumpInfo()\n                        print('========')\n                except:\n                    if args.Verbose:\n                        print('--------')\n                        print('No FMP_PAYLOAD_HEADER')\n                        print('========')\n                    sys.exit(1)\n            for Index in range(0, FmpCapsuleHeader.EmbeddedDriverCount):\n                EmbeddedDriverBuffer = FmpCapsuleHeader.GetEmbeddedDriver(Index)\n                EmbeddedDriverPath = args.OutputFile.name + '.EmbeddedDriver.{Index:d}.efi'.format(Index=Index + 1)\n                try:\n                    if args.Verbose:\n                        print('Write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    with open(EmbeddedDriverPath, 'wb') as EmbeddedDriverFile:\n                        EmbeddedDriverFile.write(EmbeddedDriverBuffer)\n                except:\n                    print('GenerateCapsule: error: can not write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    sys.exit(1)\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)\n    GenerateOutputJson(PayloadJsonDescriptorList)\n    PayloadIndex = 0\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        if args.OutputFile is None:\n            print('GenerateCapsule: Decode error: OutputFile is needed for decode output')\n            sys.exit(1)\n        try:\n            if args.Verbose:\n                print('Write binary output file {File}'.format(File=args.OutputFile.name))\n            PayloadDecodePath = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=PayloadIndex + 1)\n            with open(PayloadDecodePath, 'wb') as PayloadDecodeFile:\n                PayloadDecodeFile.write(SinglePayloadDescriptor.Payload)\n            PayloadIndex = PayloadIndex + 1\n        except:\n            print('GenerateCapsule: error: can not write binary output file {File}'.format(File=SinglePayloadDescriptor.OutputFile.name))\n            sys.exit(1)",
            "def Decode(PayloadDescriptorList, PayloadJsonDescriptorList, Buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        DecodeJsonFileParse(Json)\n    else:\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        if len(Result) > 0:\n            Result = FmpCapsuleHeader.Decode(Result)\n            if args.JsonFile:\n                if FmpCapsuleHeader.PayloadItemCount != len(PayloadDescriptorList):\n                    CapsulePayloadNum = FmpCapsuleHeader.PayloadItemCount\n                    JsonPayloadNum = len(PayloadDescriptorList)\n                    print('GenerateCapsule: Decode error: {JsonPayloadNumber} payloads in JSON file {File} and {CapsulePayloadNumber} payloads in Capsule {CapsuleName}'.format(JsonPayloadNumber=JsonPayloadNum, File=args.JsonFile.name, CapsulePayloadNumber=CapsulePayloadNum, CapsuleName=args.InputFile.name))\n                    sys.exit(1)\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index < len(PayloadDescriptorList):\n                        GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                        HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                        UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                        if PayloadDescriptorList[Index].Guid != GUID or PayloadDescriptorList[Index].HardwareInstance != HardwareInstance:\n                            print('GenerateCapsule: Decode error: Guid or HardwareInstance pair in input JSON file {File} does not match the payload {PayloadIndex} in Capsule {InputCapsule}'.format(File=args.JsonFile.name, PayloadIndex=Index + 1, InputCapsule=args.InputFile.name))\n                            sys.exit(1)\n                        PayloadDescriptorList[Index].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                        PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            else:\n                PayloadDescriptorList[0].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(0).Payload\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index > 0:\n                        PayloadDecodeFile = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        PayloadDescriptorList.append(PayloadDescriptor(PayloadDecodeFile, None, None, None, None, None, None, None, None, None, None, None, None))\n                    GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                    HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                    UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                    DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                    PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            JsonIndex = 0\n            for SinglePayloadDescriptor in PayloadDescriptorList:\n                if args.Verbose:\n                    print('========')\n                    UefiCapsuleHeader.DumpInfo()\n                    print('--------')\n                    FmpCapsuleHeader.DumpInfo()\n                if FmpAuthHeader.IsSigned(SinglePayloadDescriptor.Payload):\n                    if not SinglePayloadDescriptor.UseOpenSsl and (not SinglePayloadDescriptor.UseSignTool):\n                        print('GenerateCapsule: decode warning: can not verify singed payload without cert or pfx file. Index = {Index}'.format(Index=JsonIndex + 1))\n                    SinglePayloadDescriptor.Payload = FmpAuthHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].MonotonicCount = FmpAuthHeader.MonotonicCount\n                    if args.Verbose:\n                        print('--------')\n                        FmpAuthHeader.DumpInfo()\n                    try:\n                        if SinglePayloadDescriptor.UseSignTool:\n                            CertData = VerifyPayloadSignTool(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                        else:\n                            CertData = VerifyPayloadOpenSsl(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n                    except Exception as Msg:\n                        print('GenerateCapsule: warning: payload verification failed Index = {Index} \\n'.format(Index=JsonIndex + 1) + str(Msg))\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', SinglePayloadDescriptor.Payload[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    SinglePayloadDescriptor.UseDependency = True\n                    try:\n                        SinglePayloadDescriptor.Payload = CapsuleDependency.Decode(SinglePayloadDescriptor.Payload)\n                        PayloadJsonDescriptorList[JsonIndex].DepexExp = CapsuleDependency.DepexExp\n                        if args.Verbose:\n                            print('--------')\n                            CapsuleDependency.DumpInfo()\n                    except Exception as Msg:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    SinglePayloadDescriptor.Payload = FmpPayloadHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].FwVersion = FmpPayloadHeader.FwVersion\n                    PayloadJsonDescriptorList[JsonIndex].LowestSupportedVersion = FmpPayloadHeader.LowestSupportedVersion\n                    JsonIndex = JsonIndex + 1\n                    if args.Verbose:\n                        print('--------')\n                        FmpPayloadHeader.DumpInfo()\n                        print('========')\n                except:\n                    if args.Verbose:\n                        print('--------')\n                        print('No FMP_PAYLOAD_HEADER')\n                        print('========')\n                    sys.exit(1)\n            for Index in range(0, FmpCapsuleHeader.EmbeddedDriverCount):\n                EmbeddedDriverBuffer = FmpCapsuleHeader.GetEmbeddedDriver(Index)\n                EmbeddedDriverPath = args.OutputFile.name + '.EmbeddedDriver.{Index:d}.efi'.format(Index=Index + 1)\n                try:\n                    if args.Verbose:\n                        print('Write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    with open(EmbeddedDriverPath, 'wb') as EmbeddedDriverFile:\n                        EmbeddedDriverFile.write(EmbeddedDriverBuffer)\n                except:\n                    print('GenerateCapsule: error: can not write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    sys.exit(1)\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)\n    GenerateOutputJson(PayloadJsonDescriptorList)\n    PayloadIndex = 0\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        if args.OutputFile is None:\n            print('GenerateCapsule: Decode error: OutputFile is needed for decode output')\n            sys.exit(1)\n        try:\n            if args.Verbose:\n                print('Write binary output file {File}'.format(File=args.OutputFile.name))\n            PayloadDecodePath = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=PayloadIndex + 1)\n            with open(PayloadDecodePath, 'wb') as PayloadDecodeFile:\n                PayloadDecodeFile.write(SinglePayloadDescriptor.Payload)\n            PayloadIndex = PayloadIndex + 1\n        except:\n            print('GenerateCapsule: error: can not write binary output file {File}'.format(File=SinglePayloadDescriptor.OutputFile.name))\n            sys.exit(1)",
            "def Decode(PayloadDescriptorList, PayloadJsonDescriptorList, Buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if args.JsonFile:\n        CheckArgumentConflict(args)\n        try:\n            Json = json.loads(args.JsonFile.read())\n        except:\n            print('GenerateCapsule: error: {JSONFile} loads failure. '.format(JSONFile=args.JsonFile))\n            sys.exit(1)\n        DecodeJsonFileParse(Json)\n    else:\n        PayloadDescriptorList.append(PayloadDescriptor(Buffer, args.Guid, args.FwVersion, args.LowestSupportedVersion, args.MonotonicCount, args.HardwareInstance, args.UpdateImageIndex, args.SignToolPfxFile, args.SignSubjectName, args.OpenSslSignerPrivateCertFile, args.OpenSslOtherPublicCertFile, args.OpenSslTrustedPublicCertFile, args.SigningToolPath, None))\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        try:\n            SinglePayloadDescriptor.Validate(args)\n        except Exception as Msg:\n            print('GenerateCapsule: error:' + str(Msg))\n            sys.exit(1)\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        if len(Result) > 0:\n            Result = FmpCapsuleHeader.Decode(Result)\n            if args.JsonFile:\n                if FmpCapsuleHeader.PayloadItemCount != len(PayloadDescriptorList):\n                    CapsulePayloadNum = FmpCapsuleHeader.PayloadItemCount\n                    JsonPayloadNum = len(PayloadDescriptorList)\n                    print('GenerateCapsule: Decode error: {JsonPayloadNumber} payloads in JSON file {File} and {CapsulePayloadNumber} payloads in Capsule {CapsuleName}'.format(JsonPayloadNumber=JsonPayloadNum, File=args.JsonFile.name, CapsulePayloadNumber=CapsulePayloadNum, CapsuleName=args.InputFile.name))\n                    sys.exit(1)\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index < len(PayloadDescriptorList):\n                        GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                        HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                        UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                        if PayloadDescriptorList[Index].Guid != GUID or PayloadDescriptorList[Index].HardwareInstance != HardwareInstance:\n                            print('GenerateCapsule: Decode error: Guid or HardwareInstance pair in input JSON file {File} does not match the payload {PayloadIndex} in Capsule {InputCapsule}'.format(File=args.JsonFile.name, PayloadIndex=Index + 1, InputCapsule=args.InputFile.name))\n                            sys.exit(1)\n                        PayloadDescriptorList[Index].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                        PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            else:\n                PayloadDescriptorList[0].Payload = FmpCapsuleHeader.GetFmpCapsuleImageHeader(0).Payload\n                for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                    if Index > 0:\n                        PayloadDecodeFile = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                        PayloadDescriptorList.append(PayloadDescriptor(PayloadDecodeFile, None, None, None, None, None, None, None, None, None, None, None, None))\n                    GUID = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageTypeId\n                    HardwareInstance = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateHardwareInstance\n                    UpdateImageIndex = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).UpdateImageIndex\n                    DecodeJsonOutput = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=Index + 1)\n                    PayloadJsonDescriptorList.append(PayloadDescriptor(DecodeJsonOutput, GUID, None, None, None, HardwareInstance, UpdateImageIndex, PayloadDescriptorList[Index].SignToolPfxFile, PayloadDescriptorList[Index].SignToolSubjectName, PayloadDescriptorList[Index].OpenSslSignerPrivateCertFile, PayloadDescriptorList[Index].OpenSslOtherPublicCertFile, PayloadDescriptorList[Index].OpenSslTrustedPublicCertFile, PayloadDescriptorList[Index].SigningToolPath, None))\n            JsonIndex = 0\n            for SinglePayloadDescriptor in PayloadDescriptorList:\n                if args.Verbose:\n                    print('========')\n                    UefiCapsuleHeader.DumpInfo()\n                    print('--------')\n                    FmpCapsuleHeader.DumpInfo()\n                if FmpAuthHeader.IsSigned(SinglePayloadDescriptor.Payload):\n                    if not SinglePayloadDescriptor.UseOpenSsl and (not SinglePayloadDescriptor.UseSignTool):\n                        print('GenerateCapsule: decode warning: can not verify singed payload without cert or pfx file. Index = {Index}'.format(Index=JsonIndex + 1))\n                    SinglePayloadDescriptor.Payload = FmpAuthHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].MonotonicCount = FmpAuthHeader.MonotonicCount\n                    if args.Verbose:\n                        print('--------')\n                        FmpAuthHeader.DumpInfo()\n                    try:\n                        if SinglePayloadDescriptor.UseSignTool:\n                            CertData = VerifyPayloadSignTool(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.SignToolPfxFile, SinglePayloadDescriptor.SignToolSubjectName, Verbose=args.Verbose)\n                        else:\n                            CertData = VerifyPayloadOpenSsl(FmpAuthHeader.Payload + struct.pack('<Q', FmpAuthHeader.MonotonicCount), FmpAuthHeader.CertData, SinglePayloadDescriptor.SigningToolPath, SinglePayloadDescriptor.OpenSslSignerPrivateCertFile, SinglePayloadDescriptor.OpenSslOtherPublicCertFile, SinglePayloadDescriptor.OpenSslTrustedPublicCertFile, Verbose=args.Verbose)\n                    except Exception as Msg:\n                        print('GenerateCapsule: warning: payload verification failed Index = {Index} \\n'.format(Index=JsonIndex + 1) + str(Msg))\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', SinglePayloadDescriptor.Payload[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    SinglePayloadDescriptor.UseDependency = True\n                    try:\n                        SinglePayloadDescriptor.Payload = CapsuleDependency.Decode(SinglePayloadDescriptor.Payload)\n                        PayloadJsonDescriptorList[JsonIndex].DepexExp = CapsuleDependency.DepexExp\n                        if args.Verbose:\n                            print('--------')\n                            CapsuleDependency.DumpInfo()\n                    except Exception as Msg:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                elif args.Verbose:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    SinglePayloadDescriptor.Payload = FmpPayloadHeader.Decode(SinglePayloadDescriptor.Payload)\n                    PayloadJsonDescriptorList[JsonIndex].FwVersion = FmpPayloadHeader.FwVersion\n                    PayloadJsonDescriptorList[JsonIndex].LowestSupportedVersion = FmpPayloadHeader.LowestSupportedVersion\n                    JsonIndex = JsonIndex + 1\n                    if args.Verbose:\n                        print('--------')\n                        FmpPayloadHeader.DumpInfo()\n                        print('========')\n                except:\n                    if args.Verbose:\n                        print('--------')\n                        print('No FMP_PAYLOAD_HEADER')\n                        print('========')\n                    sys.exit(1)\n            for Index in range(0, FmpCapsuleHeader.EmbeddedDriverCount):\n                EmbeddedDriverBuffer = FmpCapsuleHeader.GetEmbeddedDriver(Index)\n                EmbeddedDriverPath = args.OutputFile.name + '.EmbeddedDriver.{Index:d}.efi'.format(Index=Index + 1)\n                try:\n                    if args.Verbose:\n                        print('Write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    with open(EmbeddedDriverPath, 'wb') as EmbeddedDriverFile:\n                        EmbeddedDriverFile.write(EmbeddedDriverBuffer)\n                except:\n                    print('GenerateCapsule: error: can not write embedded driver file {File}'.format(File=EmbeddedDriverPath))\n                    sys.exit(1)\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)\n    GenerateOutputJson(PayloadJsonDescriptorList)\n    PayloadIndex = 0\n    for SinglePayloadDescriptor in PayloadDescriptorList:\n        if args.OutputFile is None:\n            print('GenerateCapsule: Decode error: OutputFile is needed for decode output')\n            sys.exit(1)\n        try:\n            if args.Verbose:\n                print('Write binary output file {File}'.format(File=args.OutputFile.name))\n            PayloadDecodePath = args.OutputFile.name + '.Payload.{Index:d}.bin'.format(Index=PayloadIndex + 1)\n            with open(PayloadDecodePath, 'wb') as PayloadDecodeFile:\n                PayloadDecodeFile.write(SinglePayloadDescriptor.Payload)\n            PayloadIndex = PayloadIndex + 1\n        except:\n            print('GenerateCapsule: error: can not write binary output file {File}'.format(File=SinglePayloadDescriptor.OutputFile.name))\n            sys.exit(1)"
        ]
    },
    {
        "func_name": "DumpInfo",
        "original": "def DumpInfo(Buffer, args):\n    if args.OutputFile is not None:\n        raise argparse.ArgumentTypeError('the following option is not supported for dumpinfo operations: --output')\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        print('========')\n        UefiCapsuleHeader.DumpInfo()\n        if len(Result) > 0:\n            FmpCapsuleHeader.Decode(Result)\n            print('--------')\n            FmpCapsuleHeader.DumpInfo()\n            for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                Result = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                try:\n                    Result = FmpAuthHeader.Decode(Result)\n                    print('--------')\n                    FmpAuthHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', Result[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    try:\n                        Result = CapsuleDependency.Decode(Result)\n                        print('--------')\n                        CapsuleDependency.DumpInfo()\n                    except:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                else:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    Result = FmpPayloadHeader.Decode(Result)\n                    print('--------')\n                    FmpPayloadHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No FMP_PAYLOAD_HEADER')\n                print('========')\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)",
        "mutated": [
            "def DumpInfo(Buffer, args):\n    if False:\n        i = 10\n    if args.OutputFile is not None:\n        raise argparse.ArgumentTypeError('the following option is not supported for dumpinfo operations: --output')\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        print('========')\n        UefiCapsuleHeader.DumpInfo()\n        if len(Result) > 0:\n            FmpCapsuleHeader.Decode(Result)\n            print('--------')\n            FmpCapsuleHeader.DumpInfo()\n            for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                Result = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                try:\n                    Result = FmpAuthHeader.Decode(Result)\n                    print('--------')\n                    FmpAuthHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', Result[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    try:\n                        Result = CapsuleDependency.Decode(Result)\n                        print('--------')\n                        CapsuleDependency.DumpInfo()\n                    except:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                else:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    Result = FmpPayloadHeader.Decode(Result)\n                    print('--------')\n                    FmpPayloadHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No FMP_PAYLOAD_HEADER')\n                print('========')\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)",
            "def DumpInfo(Buffer, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if args.OutputFile is not None:\n        raise argparse.ArgumentTypeError('the following option is not supported for dumpinfo operations: --output')\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        print('========')\n        UefiCapsuleHeader.DumpInfo()\n        if len(Result) > 0:\n            FmpCapsuleHeader.Decode(Result)\n            print('--------')\n            FmpCapsuleHeader.DumpInfo()\n            for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                Result = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                try:\n                    Result = FmpAuthHeader.Decode(Result)\n                    print('--------')\n                    FmpAuthHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', Result[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    try:\n                        Result = CapsuleDependency.Decode(Result)\n                        print('--------')\n                        CapsuleDependency.DumpInfo()\n                    except:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                else:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    Result = FmpPayloadHeader.Decode(Result)\n                    print('--------')\n                    FmpPayloadHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No FMP_PAYLOAD_HEADER')\n                print('========')\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)",
            "def DumpInfo(Buffer, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if args.OutputFile is not None:\n        raise argparse.ArgumentTypeError('the following option is not supported for dumpinfo operations: --output')\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        print('========')\n        UefiCapsuleHeader.DumpInfo()\n        if len(Result) > 0:\n            FmpCapsuleHeader.Decode(Result)\n            print('--------')\n            FmpCapsuleHeader.DumpInfo()\n            for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                Result = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                try:\n                    Result = FmpAuthHeader.Decode(Result)\n                    print('--------')\n                    FmpAuthHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', Result[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    try:\n                        Result = CapsuleDependency.Decode(Result)\n                        print('--------')\n                        CapsuleDependency.DumpInfo()\n                    except:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                else:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    Result = FmpPayloadHeader.Decode(Result)\n                    print('--------')\n                    FmpPayloadHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No FMP_PAYLOAD_HEADER')\n                print('========')\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)",
            "def DumpInfo(Buffer, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if args.OutputFile is not None:\n        raise argparse.ArgumentTypeError('the following option is not supported for dumpinfo operations: --output')\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        print('========')\n        UefiCapsuleHeader.DumpInfo()\n        if len(Result) > 0:\n            FmpCapsuleHeader.Decode(Result)\n            print('--------')\n            FmpCapsuleHeader.DumpInfo()\n            for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                Result = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                try:\n                    Result = FmpAuthHeader.Decode(Result)\n                    print('--------')\n                    FmpAuthHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', Result[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    try:\n                        Result = CapsuleDependency.Decode(Result)\n                        print('--------')\n                        CapsuleDependency.DumpInfo()\n                    except:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                else:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    Result = FmpPayloadHeader.Decode(Result)\n                    print('--------')\n                    FmpPayloadHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No FMP_PAYLOAD_HEADER')\n                print('========')\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)",
            "def DumpInfo(Buffer, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if args.OutputFile is not None:\n        raise argparse.ArgumentTypeError('the following option is not supported for dumpinfo operations: --output')\n    try:\n        Result = UefiCapsuleHeader.Decode(Buffer)\n        print('========')\n        UefiCapsuleHeader.DumpInfo()\n        if len(Result) > 0:\n            FmpCapsuleHeader.Decode(Result)\n            print('--------')\n            FmpCapsuleHeader.DumpInfo()\n            for Index in range(0, FmpCapsuleHeader.PayloadItemCount):\n                Result = FmpCapsuleHeader.GetFmpCapsuleImageHeader(Index).Payload\n                try:\n                    Result = FmpAuthHeader.Decode(Result)\n                    print('--------')\n                    FmpAuthHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_AUTHENTICATION')\n                PayloadSignature = struct.unpack('<I', Result[0:4])\n                if PayloadSignature != FmpPayloadHeader.Signature:\n                    try:\n                        Result = CapsuleDependency.Decode(Result)\n                        print('--------')\n                        CapsuleDependency.DumpInfo()\n                    except:\n                        print('GenerateCapsule: error: invalid dependency expression')\n                else:\n                    print('--------')\n                    print('No EFI_FIRMWARE_IMAGE_DEP')\n                try:\n                    Result = FmpPayloadHeader.Decode(Result)\n                    print('--------')\n                    FmpPayloadHeader.DumpInfo()\n                except:\n                    print('--------')\n                    print('No FMP_PAYLOAD_HEADER')\n                print('========')\n    except:\n        print('GenerateCapsule: error: can not decode capsule')\n        sys.exit(1)"
        ]
    }
]