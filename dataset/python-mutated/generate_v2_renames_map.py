"""Script for updating tensorflow/tools/compatibility/renames_v2.py.

To update renames_v2.py, run:
  bazel run tensorflow/tools/compatibility/update:generate_v2_renames_map
Afterwards, you need to update reoders_v2.py by running:
  bazel run tensorflow/tools/compatibility/update:generate_v2_reorders_map
"""
import sys
from absl import app
import tensorflow as tf
from tensorflow import python as tf_python
from tensorflow.python import modules_with_exports
from tensorflow.python.lib.io import file_io
from tensorflow.python.util import tf_decorator
from tensorflow.python.util import tf_export
from tensorflow.tools.common import public_api
from tensorflow.tools.common import traverse
from tensorflow.tools.compatibility import all_renames_v2
_OUTPUT_FILE_PATH = 'third_party/tensorflow/tools/compatibility/renames_v2.py'
_FILE_HEADER = '# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n# pylint: disable=line-too-long\n"""List of renames to apply when converting from TF 1.0 to TF 2.0.\n\nTHIS FILE IS AUTOGENERATED: To update, please run:\n  bazel run tensorflow/tools/compatibility/update:generate_v2_renames_map\nThis file should be updated whenever endpoints are deprecated.\n"""\n'

def get_canonical_name(v2_names, v1_name):
    if False:
        print('Hello World!')
    if v2_names:
        return v2_names[0]
    return 'compat.v1.%s' % v1_name

def get_all_v2_names():
    if False:
        i = 10
        return i + 15
    'Get a set of function/class names available in TensorFlow 2.0.'
    v2_names = set()

    def visit(unused_path, unused_parent, children):
        if False:
            print('Hello World!')
        'Visitor that collects TF 2.0 names.'
        for child in children:
            (_, attr) = tf_decorator.unwrap(child[1])
            api_names_v2 = tf_export.get_v2_names(attr)
            for name in api_names_v2:
                v2_names.add(name)
    visitor = public_api.PublicAPIVisitor(visit)
    visitor.do_not_descend_map['tf'].append('contrib')
    visitor.private_map['tf.compat'] = ['v1', 'v2']
    traverse.traverse(tf.compat.v2, visitor)
    traverse.traverse(tf.compat.v2.estimator, visitor)
    return v2_names

def collect_constant_renames():
    if False:
        print('Hello World!')
    'Looks for constants that need to be renamed in TF 2.0.\n\n  Returns:\n    Set of tuples of the form (current name, new name).\n  '
    renames = set()
    for module in sys.modules.copy().values():
        try:
            constants_v1_list = tf_export.get_v1_constants(module)
            constants_v2_list = tf_export.get_v2_constants(module)
        except:
            pass
        constants_v1 = {constant_name: api_names for (api_names, constant_name) in constants_v1_list}
        constants_v2 = {constant_name: api_names for (api_names, constant_name) in constants_v2_list}
        for (constant_name, api_names_v1) in constants_v1.items():
            api_names_v2 = constants_v2[constant_name]
            for name in api_names_v1:
                if name not in api_names_v2:
                    renames.add((name, get_canonical_name(api_names_v2, name)))
    return renames

def collect_function_renames():
    if False:
        return 10
    'Looks for functions/classes that need to be renamed in TF 2.0.\n\n  Returns:\n    Set of tuples of the form (current name, new name).\n  '
    renames = set()
    all_v2_names = get_all_v2_names()

    def visit(unused_path, unused_parent, children):
        if False:
            for i in range(10):
                print('nop')
        'Visitor that collects rename strings to add to rename_line_set.'
        for child in children:
            (_, attr) = tf_decorator.unwrap(child[1])
            api_names_v1 = [name for name in tf_export.get_v1_names(attr) if '.__internal__.' not in name]
            api_names_v2 = tf_export.get_v2_names(attr)
            if not api_names_v2:
                api_names_v2 = [name for name in api_names_v1 if name in all_v2_names]
            deprecated_api_names = set(api_names_v1) - set(api_names_v2)
            for name in deprecated_api_names:
                renames.add((name, get_canonical_name(api_names_v2, name)))
    visitor = public_api.PublicAPIVisitor(visit)
    visitor.do_not_descend_map['tf'].append('contrib')
    visitor.private_map['tf.compat'] = ['v1', 'v2']
    traverse.traverse(tf.version, visitor)
    traverse.traverse(tf.compat.v1, visitor)
    traverse.traverse(tf.compat.v1.estimator, visitor)
    traverse.traverse(tf.compat.v2, visitor)
    traverse.traverse(tf.compat.v2.estimator, visitor)
    return renames

def get_rename_line(name, canonical_name):
    if False:
        print('Hello World!')
    return "    'tf.%s':\n        'tf.%s'" % (name, canonical_name)

def update_renames_v2(output_file_path):
    if False:
        return 10
    'Writes a Python dictionary mapping deprecated to canonical API names.\n\n  Args:\n    output_file_path: File path to write output to. Any existing contents\n      would be replaced.\n  '
    function_renames = collect_function_renames()
    constant_renames = collect_constant_renames()
    all_renames = function_renames.union(constant_renames)
    manual_renames = all_renames_v2.manual_symbol_renames
    rename_lines = [get_rename_line(name, canonical_name) for (name, canonical_name) in all_renames if 'tf.' + name not in manual_renames]
    renames_file_text = '%srenames = {\n%s\n}\n' % (_FILE_HEADER, ',\n'.join(sorted(rename_lines)))
    file_io.write_string_to_file(output_file_path, renames_file_text)

def main(unused_argv):
    if False:
        return 10
    update_renames_v2(_OUTPUT_FILE_PATH)
if __name__ == '__main__':
    app.run(main=main)