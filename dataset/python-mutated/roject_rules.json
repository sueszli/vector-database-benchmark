[
    {
        "func_name": "clean_rule_data",
        "original": "def clean_rule_data(data):\n    for datum in data:\n        if datum.get('name'):\n            del datum['name']",
        "mutated": [
            "def clean_rule_data(data):\n    if False:\n        i = 10\n    for datum in data:\n        if datum.get('name'):\n            del datum['name']",
            "def clean_rule_data(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for datum in data:\n        if datum.get('name'):\n            del datum['name']",
            "def clean_rule_data(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for datum in data:\n        if datum.get('name'):\n            del datum['name']",
            "def clean_rule_data(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for datum in data:\n        if datum.get('name'):\n            del datum['name']",
            "def clean_rule_data(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for datum in data:\n        if datum.get('name'):\n            del datum['name']"
        ]
    },
    {
        "func_name": "pre_save_rule",
        "original": "@receiver(pre_save, sender=Rule)\ndef pre_save_rule(instance, sender, *args, **kwargs):\n    clean_rule_data(instance.data.get('conditions', []))\n    clean_rule_data(instance.data.get('actions', []))",
        "mutated": [
            "@receiver(pre_save, sender=Rule)\ndef pre_save_rule(instance, sender, *args, **kwargs):\n    if False:\n        i = 10\n    clean_rule_data(instance.data.get('conditions', []))\n    clean_rule_data(instance.data.get('actions', []))",
            "@receiver(pre_save, sender=Rule)\ndef pre_save_rule(instance, sender, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    clean_rule_data(instance.data.get('conditions', []))\n    clean_rule_data(instance.data.get('actions', []))",
            "@receiver(pre_save, sender=Rule)\ndef pre_save_rule(instance, sender, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    clean_rule_data(instance.data.get('conditions', []))\n    clean_rule_data(instance.data.get('actions', []))",
            "@receiver(pre_save, sender=Rule)\ndef pre_save_rule(instance, sender, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    clean_rule_data(instance.data.get('conditions', []))\n    clean_rule_data(instance.data.get('actions', []))",
            "@receiver(pre_save, sender=Rule)\ndef pre_save_rule(instance, sender, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    clean_rule_data(instance.data.get('conditions', []))\n    clean_rule_data(instance.data.get('actions', []))"
        ]
    },
    {
        "func_name": "find_duplicate_rule",
        "original": "def find_duplicate_rule(project, rule_data=None, rule_id=None, rule=None):\n    if rule:\n        rule_data = rule.data\n    matchers = {key for key in list(rule_data.keys()) if key not in ('name', 'user_id')}\n    extra_fields = ['actions', 'environment']\n    matchers.update(extra_fields)\n    existing_rules = Rule.objects.exclude(id=rule_id).filter(project=project, status=ObjectStatus.ACTIVE)\n    for existing_rule in existing_rules:\n        keys = 0\n        matches = 0\n        for matcher in matchers:\n            if existing_rule.data.get(matcher) and rule_data.get(matcher):\n                keys += 1\n                if existing_rule.data[matcher] == rule_data[matcher]:\n                    matches += 1\n            elif matcher in extra_fields:\n                if matcher == 'environment':\n                    if rule:\n                        if existing_rule.environment_id and rule.environment_id:\n                            keys += 1\n                            if existing_rule.environment_id == rule.environment_id:\n                                matches += 1\n                        elif existing_rule.environment_id and (not rule.environment_id) or (not existing_rule.environment_id and rule.environment_id):\n                            keys += 1\n                    elif existing_rule.environment_id and rule_data.get(matcher):\n                        keys += 1\n                        if existing_rule.environment_id == rule_data.get(matcher):\n                            matches += 1\n                    elif existing_rule.environment_id and (not rule_data.get(matcher)) or (not existing_rule.environment_id and rule_data.get(matcher)):\n                        keys += 1\n                elif not existing_rule.data.get(matcher) and (not rule_data.get(matcher)):\n                    continue\n                else:\n                    keys += 1\n        if keys == matches:\n            return existing_rule\n    return None",
        "mutated": [
            "def find_duplicate_rule(project, rule_data=None, rule_id=None, rule=None):\n    if False:\n        i = 10\n    if rule:\n        rule_data = rule.data\n    matchers = {key for key in list(rule_data.keys()) if key not in ('name', 'user_id')}\n    extra_fields = ['actions', 'environment']\n    matchers.update(extra_fields)\n    existing_rules = Rule.objects.exclude(id=rule_id).filter(project=project, status=ObjectStatus.ACTIVE)\n    for existing_rule in existing_rules:\n        keys = 0\n        matches = 0\n        for matcher in matchers:\n            if existing_rule.data.get(matcher) and rule_data.get(matcher):\n                keys += 1\n                if existing_rule.data[matcher] == rule_data[matcher]:\n                    matches += 1\n            elif matcher in extra_fields:\n                if matcher == 'environment':\n                    if rule:\n                        if existing_rule.environment_id and rule.environment_id:\n                            keys += 1\n                            if existing_rule.environment_id == rule.environment_id:\n                                matches += 1\n                        elif existing_rule.environment_id and (not rule.environment_id) or (not existing_rule.environment_id and rule.environment_id):\n                            keys += 1\n                    elif existing_rule.environment_id and rule_data.get(matcher):\n                        keys += 1\n                        if existing_rule.environment_id == rule_data.get(matcher):\n                            matches += 1\n                    elif existing_rule.environment_id and (not rule_data.get(matcher)) or (not existing_rule.environment_id and rule_data.get(matcher)):\n                        keys += 1\n                elif not existing_rule.data.get(matcher) and (not rule_data.get(matcher)):\n                    continue\n                else:\n                    keys += 1\n        if keys == matches:\n            return existing_rule\n    return None",
            "def find_duplicate_rule(project, rule_data=None, rule_id=None, rule=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if rule:\n        rule_data = rule.data\n    matchers = {key for key in list(rule_data.keys()) if key not in ('name', 'user_id')}\n    extra_fields = ['actions', 'environment']\n    matchers.update(extra_fields)\n    existing_rules = Rule.objects.exclude(id=rule_id).filter(project=project, status=ObjectStatus.ACTIVE)\n    for existing_rule in existing_rules:\n        keys = 0\n        matches = 0\n        for matcher in matchers:\n            if existing_rule.data.get(matcher) and rule_data.get(matcher):\n                keys += 1\n                if existing_rule.data[matcher] == rule_data[matcher]:\n                    matches += 1\n            elif matcher in extra_fields:\n                if matcher == 'environment':\n                    if rule:\n                        if existing_rule.environment_id and rule.environment_id:\n                            keys += 1\n                            if existing_rule.environment_id == rule.environment_id:\n                                matches += 1\n                        elif existing_rule.environment_id and (not rule.environment_id) or (not existing_rule.environment_id and rule.environment_id):\n                            keys += 1\n                    elif existing_rule.environment_id and rule_data.get(matcher):\n                        keys += 1\n                        if existing_rule.environment_id == rule_data.get(matcher):\n                            matches += 1\n                    elif existing_rule.environment_id and (not rule_data.get(matcher)) or (not existing_rule.environment_id and rule_data.get(matcher)):\n                        keys += 1\n                elif not existing_rule.data.get(matcher) and (not rule_data.get(matcher)):\n                    continue\n                else:\n                    keys += 1\n        if keys == matches:\n            return existing_rule\n    return None",
            "def find_duplicate_rule(project, rule_data=None, rule_id=None, rule=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if rule:\n        rule_data = rule.data\n    matchers = {key for key in list(rule_data.keys()) if key not in ('name', 'user_id')}\n    extra_fields = ['actions', 'environment']\n    matchers.update(extra_fields)\n    existing_rules = Rule.objects.exclude(id=rule_id).filter(project=project, status=ObjectStatus.ACTIVE)\n    for existing_rule in existing_rules:\n        keys = 0\n        matches = 0\n        for matcher in matchers:\n            if existing_rule.data.get(matcher) and rule_data.get(matcher):\n                keys += 1\n                if existing_rule.data[matcher] == rule_data[matcher]:\n                    matches += 1\n            elif matcher in extra_fields:\n                if matcher == 'environment':\n                    if rule:\n                        if existing_rule.environment_id and rule.environment_id:\n                            keys += 1\n                            if existing_rule.environment_id == rule.environment_id:\n                                matches += 1\n                        elif existing_rule.environment_id and (not rule.environment_id) or (not existing_rule.environment_id and rule.environment_id):\n                            keys += 1\n                    elif existing_rule.environment_id and rule_data.get(matcher):\n                        keys += 1\n                        if existing_rule.environment_id == rule_data.get(matcher):\n                            matches += 1\n                    elif existing_rule.environment_id and (not rule_data.get(matcher)) or (not existing_rule.environment_id and rule_data.get(matcher)):\n                        keys += 1\n                elif not existing_rule.data.get(matcher) and (not rule_data.get(matcher)):\n                    continue\n                else:\n                    keys += 1\n        if keys == matches:\n            return existing_rule\n    return None",
            "def find_duplicate_rule(project, rule_data=None, rule_id=None, rule=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if rule:\n        rule_data = rule.data\n    matchers = {key for key in list(rule_data.keys()) if key not in ('name', 'user_id')}\n    extra_fields = ['actions', 'environment']\n    matchers.update(extra_fields)\n    existing_rules = Rule.objects.exclude(id=rule_id).filter(project=project, status=ObjectStatus.ACTIVE)\n    for existing_rule in existing_rules:\n        keys = 0\n        matches = 0\n        for matcher in matchers:\n            if existing_rule.data.get(matcher) and rule_data.get(matcher):\n                keys += 1\n                if existing_rule.data[matcher] == rule_data[matcher]:\n                    matches += 1\n            elif matcher in extra_fields:\n                if matcher == 'environment':\n                    if rule:\n                        if existing_rule.environment_id and rule.environment_id:\n                            keys += 1\n                            if existing_rule.environment_id == rule.environment_id:\n                                matches += 1\n                        elif existing_rule.environment_id and (not rule.environment_id) or (not existing_rule.environment_id and rule.environment_id):\n                            keys += 1\n                    elif existing_rule.environment_id and rule_data.get(matcher):\n                        keys += 1\n                        if existing_rule.environment_id == rule_data.get(matcher):\n                            matches += 1\n                    elif existing_rule.environment_id and (not rule_data.get(matcher)) or (not existing_rule.environment_id and rule_data.get(matcher)):\n                        keys += 1\n                elif not existing_rule.data.get(matcher) and (not rule_data.get(matcher)):\n                    continue\n                else:\n                    keys += 1\n        if keys == matches:\n            return existing_rule\n    return None",
            "def find_duplicate_rule(project, rule_data=None, rule_id=None, rule=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if rule:\n        rule_data = rule.data\n    matchers = {key for key in list(rule_data.keys()) if key not in ('name', 'user_id')}\n    extra_fields = ['actions', 'environment']\n    matchers.update(extra_fields)\n    existing_rules = Rule.objects.exclude(id=rule_id).filter(project=project, status=ObjectStatus.ACTIVE)\n    for existing_rule in existing_rules:\n        keys = 0\n        matches = 0\n        for matcher in matchers:\n            if existing_rule.data.get(matcher) and rule_data.get(matcher):\n                keys += 1\n                if existing_rule.data[matcher] == rule_data[matcher]:\n                    matches += 1\n            elif matcher in extra_fields:\n                if matcher == 'environment':\n                    if rule:\n                        if existing_rule.environment_id and rule.environment_id:\n                            keys += 1\n                            if existing_rule.environment_id == rule.environment_id:\n                                matches += 1\n                        elif existing_rule.environment_id and (not rule.environment_id) or (not existing_rule.environment_id and rule.environment_id):\n                            keys += 1\n                    elif existing_rule.environment_id and rule_data.get(matcher):\n                        keys += 1\n                        if existing_rule.environment_id == rule_data.get(matcher):\n                            matches += 1\n                    elif existing_rule.environment_id and (not rule_data.get(matcher)) or (not existing_rule.environment_id and rule_data.get(matcher)):\n                        keys += 1\n                elif not existing_rule.data.get(matcher) and (not rule_data.get(matcher)):\n                    continue\n                else:\n                    keys += 1\n        if keys == matches:\n            return existing_rule\n    return None"
        ]
    },
    {
        "func_name": "get",
        "original": "@extend_schema(operation_id=\"List a Project's Issue Alert Rules\", parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=None, responses={200: inline_sentry_response_serializer('ListRules', List[RuleSerializerResponse]), 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.LIST_PROJECT_RULES)\n@transaction_start('ProjectRulesEndpoint')\ndef get(self, request: Request, project) -> Response:\n    \"\"\"\n        Return a list of active issue alert rules bound to a project.\n\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\n        \"\"\"\n    queryset = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE).select_related('project')\n    return self.paginate(request=request, queryset=queryset, order_by='-id', on_results=lambda x: serialize(x, request.user))",
        "mutated": [
            "@extend_schema(operation_id=\"List a Project's Issue Alert Rules\", parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=None, responses={200: inline_sentry_response_serializer('ListRules', List[RuleSerializerResponse]), 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.LIST_PROJECT_RULES)\n@transaction_start('ProjectRulesEndpoint')\ndef get(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n    \"\\n        Return a list of active issue alert rules bound to a project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    queryset = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE).select_related('project')\n    return self.paginate(request=request, queryset=queryset, order_by='-id', on_results=lambda x: serialize(x, request.user))",
            "@extend_schema(operation_id=\"List a Project's Issue Alert Rules\", parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=None, responses={200: inline_sentry_response_serializer('ListRules', List[RuleSerializerResponse]), 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.LIST_PROJECT_RULES)\n@transaction_start('ProjectRulesEndpoint')\ndef get(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Return a list of active issue alert rules bound to a project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    queryset = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE).select_related('project')\n    return self.paginate(request=request, queryset=queryset, order_by='-id', on_results=lambda x: serialize(x, request.user))",
            "@extend_schema(operation_id=\"List a Project's Issue Alert Rules\", parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=None, responses={200: inline_sentry_response_serializer('ListRules', List[RuleSerializerResponse]), 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.LIST_PROJECT_RULES)\n@transaction_start('ProjectRulesEndpoint')\ndef get(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Return a list of active issue alert rules bound to a project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    queryset = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE).select_related('project')\n    return self.paginate(request=request, queryset=queryset, order_by='-id', on_results=lambda x: serialize(x, request.user))",
            "@extend_schema(operation_id=\"List a Project's Issue Alert Rules\", parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=None, responses={200: inline_sentry_response_serializer('ListRules', List[RuleSerializerResponse]), 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.LIST_PROJECT_RULES)\n@transaction_start('ProjectRulesEndpoint')\ndef get(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Return a list of active issue alert rules bound to a project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    queryset = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE).select_related('project')\n    return self.paginate(request=request, queryset=queryset, order_by='-id', on_results=lambda x: serialize(x, request.user))",
            "@extend_schema(operation_id=\"List a Project's Issue Alert Rules\", parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=None, responses={200: inline_sentry_response_serializer('ListRules', List[RuleSerializerResponse]), 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.LIST_PROJECT_RULES)\n@transaction_start('ProjectRulesEndpoint')\ndef get(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Return a list of active issue alert rules bound to a project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    queryset = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE).select_related('project')\n    return self.paginate(request=request, queryset=queryset, order_by='-id', on_results=lambda x: serialize(x, request.user))"
        ]
    },
    {
        "func_name": "post",
        "original": "@extend_schema(operation_id='Create an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=ProjectRulesPostSerializer, responses={201: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.CREATE_ISSUE_ALERT_RULE)\n@transaction_start('ProjectRulesEndpoint')\ndef post(self, request: Request, project) -> Response:\n    \"\"\"\n        Create a new issue alert rule for the given project.\n\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\n        \"\"\"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    data = serializer.validated_data\n    if not data.get('actions', []):\n        return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n    conditions = data.get('conditions', [])\n    if 'filters' in data:\n        conditions.extend(data['filters'])\n    new_rule_is_slow = False\n    for condition in conditions:\n        if is_condition_slow(condition):\n            new_rule_is_slow = True\n            break\n    rules = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE)\n    slow_rules = 0\n    for rule in rules:\n        for condition in rule.data['conditions']:\n            if is_condition_slow(condition):\n                slow_rules += 1\n                break\n    if new_rule_is_slow:\n        max_slow_alerts = settings.MAX_SLOW_CONDITION_ISSUE_ALERTS\n        if features.has('organizations:more-slow-alerts', project.organization):\n            max_slow_alerts = settings.MAX_MORE_SLOW_CONDITION_ISSUE_ALERTS\n        if slow_rules >= max_slow_alerts:\n            return Response({'conditions': [f'You may not exceed {max_slow_alerts} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    if not new_rule_is_slow and len(rules) - slow_rules >= settings.MAX_FAST_CONDITION_ISSUE_ALERTS:\n        return Response({'conditions': [f'You may not exceed {settings.MAX_FAST_CONDITION_ISSUE_ALERTS} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data.get('actions', []), 'frequency': data.get('frequency'), 'user_id': request.user.id}\n    duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs)\n    if duplicate_rule:\n        return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n    owner = data.get('owner')\n    if owner:\n        try:\n            kwargs['owner'] = owner.resolve_to_actor().id\n        except (User.DoesNotExist, Team.DoesNotExist):\n            return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n    if data.get('pending_save'):\n        client = RedisRuleStatus()\n        uuid_context = {'uuid': client.uuid}\n        kwargs.update(uuid_context)\n        find_channel_id_for_rule.apply_async(kwargs=kwargs)\n        return Response(uuid_context, status=202)\n    created_alert_rule_ui_component = trigger_sentry_app_action_creators_for_issues(kwargs.get('actions'))\n    rule = Creator.run(request=request, **kwargs)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.CREATED.value)\n    duplicate_rule = request.query_params.get('duplicateRule')\n    wizard_v3 = request.query_params.get('wizardV3')\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_ADD'), data=rule.get_audit_log_data())\n    alert_rule_created.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None, alert_rule_ui_component=created_alert_rule_ui_component, duplicate_rule=duplicate_rule, wizard_v3=wizard_v3)\n    return Response(serialize(rule, request.user))",
        "mutated": [
            "@extend_schema(operation_id='Create an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=ProjectRulesPostSerializer, responses={201: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.CREATE_ISSUE_ALERT_RULE)\n@transaction_start('ProjectRulesEndpoint')\ndef post(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n    \"\\n        Create a new issue alert rule for the given project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    data = serializer.validated_data\n    if not data.get('actions', []):\n        return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n    conditions = data.get('conditions', [])\n    if 'filters' in data:\n        conditions.extend(data['filters'])\n    new_rule_is_slow = False\n    for condition in conditions:\n        if is_condition_slow(condition):\n            new_rule_is_slow = True\n            break\n    rules = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE)\n    slow_rules = 0\n    for rule in rules:\n        for condition in rule.data['conditions']:\n            if is_condition_slow(condition):\n                slow_rules += 1\n                break\n    if new_rule_is_slow:\n        max_slow_alerts = settings.MAX_SLOW_CONDITION_ISSUE_ALERTS\n        if features.has('organizations:more-slow-alerts', project.organization):\n            max_slow_alerts = settings.MAX_MORE_SLOW_CONDITION_ISSUE_ALERTS\n        if slow_rules >= max_slow_alerts:\n            return Response({'conditions': [f'You may not exceed {max_slow_alerts} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    if not new_rule_is_slow and len(rules) - slow_rules >= settings.MAX_FAST_CONDITION_ISSUE_ALERTS:\n        return Response({'conditions': [f'You may not exceed {settings.MAX_FAST_CONDITION_ISSUE_ALERTS} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data.get('actions', []), 'frequency': data.get('frequency'), 'user_id': request.user.id}\n    duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs)\n    if duplicate_rule:\n        return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n    owner = data.get('owner')\n    if owner:\n        try:\n            kwargs['owner'] = owner.resolve_to_actor().id\n        except (User.DoesNotExist, Team.DoesNotExist):\n            return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n    if data.get('pending_save'):\n        client = RedisRuleStatus()\n        uuid_context = {'uuid': client.uuid}\n        kwargs.update(uuid_context)\n        find_channel_id_for_rule.apply_async(kwargs=kwargs)\n        return Response(uuid_context, status=202)\n    created_alert_rule_ui_component = trigger_sentry_app_action_creators_for_issues(kwargs.get('actions'))\n    rule = Creator.run(request=request, **kwargs)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.CREATED.value)\n    duplicate_rule = request.query_params.get('duplicateRule')\n    wizard_v3 = request.query_params.get('wizardV3')\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_ADD'), data=rule.get_audit_log_data())\n    alert_rule_created.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None, alert_rule_ui_component=created_alert_rule_ui_component, duplicate_rule=duplicate_rule, wizard_v3=wizard_v3)\n    return Response(serialize(rule, request.user))",
            "@extend_schema(operation_id='Create an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=ProjectRulesPostSerializer, responses={201: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.CREATE_ISSUE_ALERT_RULE)\n@transaction_start('ProjectRulesEndpoint')\ndef post(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Create a new issue alert rule for the given project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    data = serializer.validated_data\n    if not data.get('actions', []):\n        return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n    conditions = data.get('conditions', [])\n    if 'filters' in data:\n        conditions.extend(data['filters'])\n    new_rule_is_slow = False\n    for condition in conditions:\n        if is_condition_slow(condition):\n            new_rule_is_slow = True\n            break\n    rules = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE)\n    slow_rules = 0\n    for rule in rules:\n        for condition in rule.data['conditions']:\n            if is_condition_slow(condition):\n                slow_rules += 1\n                break\n    if new_rule_is_slow:\n        max_slow_alerts = settings.MAX_SLOW_CONDITION_ISSUE_ALERTS\n        if features.has('organizations:more-slow-alerts', project.organization):\n            max_slow_alerts = settings.MAX_MORE_SLOW_CONDITION_ISSUE_ALERTS\n        if slow_rules >= max_slow_alerts:\n            return Response({'conditions': [f'You may not exceed {max_slow_alerts} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    if not new_rule_is_slow and len(rules) - slow_rules >= settings.MAX_FAST_CONDITION_ISSUE_ALERTS:\n        return Response({'conditions': [f'You may not exceed {settings.MAX_FAST_CONDITION_ISSUE_ALERTS} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data.get('actions', []), 'frequency': data.get('frequency'), 'user_id': request.user.id}\n    duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs)\n    if duplicate_rule:\n        return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n    owner = data.get('owner')\n    if owner:\n        try:\n            kwargs['owner'] = owner.resolve_to_actor().id\n        except (User.DoesNotExist, Team.DoesNotExist):\n            return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n    if data.get('pending_save'):\n        client = RedisRuleStatus()\n        uuid_context = {'uuid': client.uuid}\n        kwargs.update(uuid_context)\n        find_channel_id_for_rule.apply_async(kwargs=kwargs)\n        return Response(uuid_context, status=202)\n    created_alert_rule_ui_component = trigger_sentry_app_action_creators_for_issues(kwargs.get('actions'))\n    rule = Creator.run(request=request, **kwargs)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.CREATED.value)\n    duplicate_rule = request.query_params.get('duplicateRule')\n    wizard_v3 = request.query_params.get('wizardV3')\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_ADD'), data=rule.get_audit_log_data())\n    alert_rule_created.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None, alert_rule_ui_component=created_alert_rule_ui_component, duplicate_rule=duplicate_rule, wizard_v3=wizard_v3)\n    return Response(serialize(rule, request.user))",
            "@extend_schema(operation_id='Create an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=ProjectRulesPostSerializer, responses={201: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.CREATE_ISSUE_ALERT_RULE)\n@transaction_start('ProjectRulesEndpoint')\ndef post(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Create a new issue alert rule for the given project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    data = serializer.validated_data\n    if not data.get('actions', []):\n        return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n    conditions = data.get('conditions', [])\n    if 'filters' in data:\n        conditions.extend(data['filters'])\n    new_rule_is_slow = False\n    for condition in conditions:\n        if is_condition_slow(condition):\n            new_rule_is_slow = True\n            break\n    rules = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE)\n    slow_rules = 0\n    for rule in rules:\n        for condition in rule.data['conditions']:\n            if is_condition_slow(condition):\n                slow_rules += 1\n                break\n    if new_rule_is_slow:\n        max_slow_alerts = settings.MAX_SLOW_CONDITION_ISSUE_ALERTS\n        if features.has('organizations:more-slow-alerts', project.organization):\n            max_slow_alerts = settings.MAX_MORE_SLOW_CONDITION_ISSUE_ALERTS\n        if slow_rules >= max_slow_alerts:\n            return Response({'conditions': [f'You may not exceed {max_slow_alerts} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    if not new_rule_is_slow and len(rules) - slow_rules >= settings.MAX_FAST_CONDITION_ISSUE_ALERTS:\n        return Response({'conditions': [f'You may not exceed {settings.MAX_FAST_CONDITION_ISSUE_ALERTS} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data.get('actions', []), 'frequency': data.get('frequency'), 'user_id': request.user.id}\n    duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs)\n    if duplicate_rule:\n        return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n    owner = data.get('owner')\n    if owner:\n        try:\n            kwargs['owner'] = owner.resolve_to_actor().id\n        except (User.DoesNotExist, Team.DoesNotExist):\n            return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n    if data.get('pending_save'):\n        client = RedisRuleStatus()\n        uuid_context = {'uuid': client.uuid}\n        kwargs.update(uuid_context)\n        find_channel_id_for_rule.apply_async(kwargs=kwargs)\n        return Response(uuid_context, status=202)\n    created_alert_rule_ui_component = trigger_sentry_app_action_creators_for_issues(kwargs.get('actions'))\n    rule = Creator.run(request=request, **kwargs)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.CREATED.value)\n    duplicate_rule = request.query_params.get('duplicateRule')\n    wizard_v3 = request.query_params.get('wizardV3')\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_ADD'), data=rule.get_audit_log_data())\n    alert_rule_created.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None, alert_rule_ui_component=created_alert_rule_ui_component, duplicate_rule=duplicate_rule, wizard_v3=wizard_v3)\n    return Response(serialize(rule, request.user))",
            "@extend_schema(operation_id='Create an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=ProjectRulesPostSerializer, responses={201: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.CREATE_ISSUE_ALERT_RULE)\n@transaction_start('ProjectRulesEndpoint')\ndef post(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Create a new issue alert rule for the given project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    data = serializer.validated_data\n    if not data.get('actions', []):\n        return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n    conditions = data.get('conditions', [])\n    if 'filters' in data:\n        conditions.extend(data['filters'])\n    new_rule_is_slow = False\n    for condition in conditions:\n        if is_condition_slow(condition):\n            new_rule_is_slow = True\n            break\n    rules = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE)\n    slow_rules = 0\n    for rule in rules:\n        for condition in rule.data['conditions']:\n            if is_condition_slow(condition):\n                slow_rules += 1\n                break\n    if new_rule_is_slow:\n        max_slow_alerts = settings.MAX_SLOW_CONDITION_ISSUE_ALERTS\n        if features.has('organizations:more-slow-alerts', project.organization):\n            max_slow_alerts = settings.MAX_MORE_SLOW_CONDITION_ISSUE_ALERTS\n        if slow_rules >= max_slow_alerts:\n            return Response({'conditions': [f'You may not exceed {max_slow_alerts} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    if not new_rule_is_slow and len(rules) - slow_rules >= settings.MAX_FAST_CONDITION_ISSUE_ALERTS:\n        return Response({'conditions': [f'You may not exceed {settings.MAX_FAST_CONDITION_ISSUE_ALERTS} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data.get('actions', []), 'frequency': data.get('frequency'), 'user_id': request.user.id}\n    duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs)\n    if duplicate_rule:\n        return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n    owner = data.get('owner')\n    if owner:\n        try:\n            kwargs['owner'] = owner.resolve_to_actor().id\n        except (User.DoesNotExist, Team.DoesNotExist):\n            return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n    if data.get('pending_save'):\n        client = RedisRuleStatus()\n        uuid_context = {'uuid': client.uuid}\n        kwargs.update(uuid_context)\n        find_channel_id_for_rule.apply_async(kwargs=kwargs)\n        return Response(uuid_context, status=202)\n    created_alert_rule_ui_component = trigger_sentry_app_action_creators_for_issues(kwargs.get('actions'))\n    rule = Creator.run(request=request, **kwargs)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.CREATED.value)\n    duplicate_rule = request.query_params.get('duplicateRule')\n    wizard_v3 = request.query_params.get('wizardV3')\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_ADD'), data=rule.get_audit_log_data())\n    alert_rule_created.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None, alert_rule_ui_component=created_alert_rule_ui_component, duplicate_rule=duplicate_rule, wizard_v3=wizard_v3)\n    return Response(serialize(rule, request.user))",
            "@extend_schema(operation_id='Create an Issue Alert Rule for a Project', parameters=[GlobalParams.ORG_SLUG, GlobalParams.PROJECT_SLUG], request=ProjectRulesPostSerializer, responses={201: RuleSerializer, 401: RESPONSE_UNAUTHORIZED, 403: RESPONSE_FORBIDDEN, 404: RESPONSE_NOT_FOUND}, examples=IssueAlertExamples.CREATE_ISSUE_ALERT_RULE)\n@transaction_start('ProjectRulesEndpoint')\ndef post(self, request: Request, project) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Create a new issue alert rule for the given project.\\n\\n        An issue alert rule triggers whenever a new event is received for any issue in a project that matches the specified alert conditions. These conditions can include a resolved issue re-appearing or an issue affecting many users. Alert conditions have three parts:\\n        - Triggers: specify what type of activity you'd like monitored or when an alert should be triggered.\\n        - Filters: help control noise by triggering an alert only if the issue matches the specified criteria.\\n        - Actions: specify what should happen when the trigger conditions are met and the filters match.\\n        \"\n    serializer = DrfRuleSerializer(context={'project': project, 'organization': project.organization}, data=request.data)\n    if not serializer.is_valid():\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    data = serializer.validated_data\n    if not data.get('actions', []):\n        return Response({'actions': ['You must add an action for this alert to fire.']}, status=status.HTTP_400_BAD_REQUEST)\n    conditions = data.get('conditions', [])\n    if 'filters' in data:\n        conditions.extend(data['filters'])\n    new_rule_is_slow = False\n    for condition in conditions:\n        if is_condition_slow(condition):\n            new_rule_is_slow = True\n            break\n    rules = Rule.objects.filter(project=project, status=ObjectStatus.ACTIVE)\n    slow_rules = 0\n    for rule in rules:\n        for condition in rule.data['conditions']:\n            if is_condition_slow(condition):\n                slow_rules += 1\n                break\n    if new_rule_is_slow:\n        max_slow_alerts = settings.MAX_SLOW_CONDITION_ISSUE_ALERTS\n        if features.has('organizations:more-slow-alerts', project.organization):\n            max_slow_alerts = settings.MAX_MORE_SLOW_CONDITION_ISSUE_ALERTS\n        if slow_rules >= max_slow_alerts:\n            return Response({'conditions': [f'You may not exceed {max_slow_alerts} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    if not new_rule_is_slow and len(rules) - slow_rules >= settings.MAX_FAST_CONDITION_ISSUE_ALERTS:\n        return Response({'conditions': [f'You may not exceed {settings.MAX_FAST_CONDITION_ISSUE_ALERTS} rules with this type of condition per project.']}, status=status.HTTP_400_BAD_REQUEST)\n    kwargs = {'name': data['name'], 'environment': data.get('environment'), 'project': project, 'action_match': data['actionMatch'], 'filter_match': data.get('filterMatch'), 'conditions': conditions, 'actions': data.get('actions', []), 'frequency': data.get('frequency'), 'user_id': request.user.id}\n    duplicate_rule = find_duplicate_rule(project=project, rule_data=kwargs)\n    if duplicate_rule:\n        return Response({'name': [f\"This rule is an exact duplicate of '{duplicate_rule.label}' in this project and may not be created.\"], 'ruleId': [duplicate_rule.id]}, status=status.HTTP_400_BAD_REQUEST)\n    owner = data.get('owner')\n    if owner:\n        try:\n            kwargs['owner'] = owner.resolve_to_actor().id\n        except (User.DoesNotExist, Team.DoesNotExist):\n            return Response('Could not resolve owner', status=status.HTTP_400_BAD_REQUEST)\n    if data.get('pending_save'):\n        client = RedisRuleStatus()\n        uuid_context = {'uuid': client.uuid}\n        kwargs.update(uuid_context)\n        find_channel_id_for_rule.apply_async(kwargs=kwargs)\n        return Response(uuid_context, status=202)\n    created_alert_rule_ui_component = trigger_sentry_app_action_creators_for_issues(kwargs.get('actions'))\n    rule = Creator.run(request=request, **kwargs)\n    RuleActivity.objects.create(rule=rule, user_id=request.user.id, type=RuleActivityType.CREATED.value)\n    duplicate_rule = request.query_params.get('duplicateRule')\n    wizard_v3 = request.query_params.get('wizardV3')\n    self.create_audit_entry(request=request, organization=project.organization, target_object=rule.id, event=audit_log.get_event_id('RULE_ADD'), data=rule.get_audit_log_data())\n    alert_rule_created.send_robust(user=request.user, project=project, rule=rule, rule_type='issue', sender=self, is_api_token=request.auth is not None, alert_rule_ui_component=created_alert_rule_ui_component, duplicate_rule=duplicate_rule, wizard_v3=wizard_v3)\n    return Response(serialize(rule, request.user))"
        ]
    }
]