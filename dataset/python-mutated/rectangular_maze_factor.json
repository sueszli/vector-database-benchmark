[
    {
        "func_name": "rectangular_maze",
        "original": "@staticmethod\ndef rectangular_maze(grid_width: int=10, grid_height: int=10):\n    \"\"\"\n        This function generates a perfect rectangular maze.\n        :param grid_width:      the width of the grid (expressed in cells)\n        :param grid_height:     the height of the grid (expressed in cells)\n        :return:                a perfect maze, represented as a typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]]\n        \"\"\"\n    cells: typing.List[typing.List[typing.Tuple[bool, bool, bool, bool]]] = [[(True, True, True, True) for _ in range(0, grid_height)] for _ in range(0, grid_width)]\n    cells_stk: typing.List[typing.Tuple[int, int]] = [(random.randint(0, grid_width - 1), random.randint(0, grid_height - 1))]\n    while sum([sum([1 for t in row if all(t)]) for row in cells]) > 0:\n        (x, y) = cells_stk[-1]\n        nbs: typing.List[typing.Tuple[int, int]] = []\n        if x != 0 and all(cells[x - 1][y]):\n            nbs.append((x - 1, y))\n        if x != grid_width - 1 and all(cells[x + 1][y]):\n            nbs.append((x + 1, y))\n        if y != 0 and all(cells[x][y - 1]):\n            nbs.append((x, y - 1))\n        if y != grid_height - 1 and all(cells[x][y + 1]):\n            nbs.append((x, y + 1))\n        if len(nbs) == 0:\n            cells_stk.pop(-1)\n            continue\n        nb: typing.Tuple[int, int] = random.choice(nbs)\n        cells_stk.append(nb)\n        if x == nb[0] + 1 and y == nb[1]:\n            cells[x - 1][y] = (cells[x - 1][y][0], False, cells[x - 1][y][2], cells[x - 1][y][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], cells[x][y][2], False)\n        if x == nb[0] - 1 and y == nb[1]:\n            cells[x + 1][y] = (cells[x + 1][y][0], cells[x + 1][y][1], cells[x + 1][y][2], False)\n            cells[x][y] = (cells[x][y][0], False, cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] + 1:\n            cells[x][y - 1] = (cells[x][y - 1][0], cells[x][y - 1][0], False, cells[x][y - 1][3])\n            cells[x][y] = (False, cells[x][y][1], cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] - 1:\n            cells[x][y + 1] = (False, cells[x][y + 1][1], cells[x][y + 1][2], cells[x][y + 1][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], False, cells[x][y][3])\n    lines: typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]] = []\n    for i in range(0, grid_width):\n        for j in range(0, grid_height):\n            if cells[i][j][0]:\n                lines.append(((Decimal(i * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal(j * 10))))\n            if cells[i][j][1]:\n                lines.append(((Decimal((i + 1) * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][2]:\n                lines.append(((Decimal((i + 1) * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][3]:\n                lines.append(((Decimal(i * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal(j * 10))))\n    return lines",
        "mutated": [
            "@staticmethod\ndef rectangular_maze(grid_width: int=10, grid_height: int=10):\n    if False:\n        i = 10\n    '\\n        This function generates a perfect rectangular maze.\\n        :param grid_width:      the width of the grid (expressed in cells)\\n        :param grid_height:     the height of the grid (expressed in cells)\\n        :return:                a perfect maze, represented as a typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]]\\n        '\n    cells: typing.List[typing.List[typing.Tuple[bool, bool, bool, bool]]] = [[(True, True, True, True) for _ in range(0, grid_height)] for _ in range(0, grid_width)]\n    cells_stk: typing.List[typing.Tuple[int, int]] = [(random.randint(0, grid_width - 1), random.randint(0, grid_height - 1))]\n    while sum([sum([1 for t in row if all(t)]) for row in cells]) > 0:\n        (x, y) = cells_stk[-1]\n        nbs: typing.List[typing.Tuple[int, int]] = []\n        if x != 0 and all(cells[x - 1][y]):\n            nbs.append((x - 1, y))\n        if x != grid_width - 1 and all(cells[x + 1][y]):\n            nbs.append((x + 1, y))\n        if y != 0 and all(cells[x][y - 1]):\n            nbs.append((x, y - 1))\n        if y != grid_height - 1 and all(cells[x][y + 1]):\n            nbs.append((x, y + 1))\n        if len(nbs) == 0:\n            cells_stk.pop(-1)\n            continue\n        nb: typing.Tuple[int, int] = random.choice(nbs)\n        cells_stk.append(nb)\n        if x == nb[0] + 1 and y == nb[1]:\n            cells[x - 1][y] = (cells[x - 1][y][0], False, cells[x - 1][y][2], cells[x - 1][y][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], cells[x][y][2], False)\n        if x == nb[0] - 1 and y == nb[1]:\n            cells[x + 1][y] = (cells[x + 1][y][0], cells[x + 1][y][1], cells[x + 1][y][2], False)\n            cells[x][y] = (cells[x][y][0], False, cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] + 1:\n            cells[x][y - 1] = (cells[x][y - 1][0], cells[x][y - 1][0], False, cells[x][y - 1][3])\n            cells[x][y] = (False, cells[x][y][1], cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] - 1:\n            cells[x][y + 1] = (False, cells[x][y + 1][1], cells[x][y + 1][2], cells[x][y + 1][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], False, cells[x][y][3])\n    lines: typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]] = []\n    for i in range(0, grid_width):\n        for j in range(0, grid_height):\n            if cells[i][j][0]:\n                lines.append(((Decimal(i * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal(j * 10))))\n            if cells[i][j][1]:\n                lines.append(((Decimal((i + 1) * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][2]:\n                lines.append(((Decimal((i + 1) * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][3]:\n                lines.append(((Decimal(i * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal(j * 10))))\n    return lines",
            "@staticmethod\ndef rectangular_maze(grid_width: int=10, grid_height: int=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        This function generates a perfect rectangular maze.\\n        :param grid_width:      the width of the grid (expressed in cells)\\n        :param grid_height:     the height of the grid (expressed in cells)\\n        :return:                a perfect maze, represented as a typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]]\\n        '\n    cells: typing.List[typing.List[typing.Tuple[bool, bool, bool, bool]]] = [[(True, True, True, True) for _ in range(0, grid_height)] for _ in range(0, grid_width)]\n    cells_stk: typing.List[typing.Tuple[int, int]] = [(random.randint(0, grid_width - 1), random.randint(0, grid_height - 1))]\n    while sum([sum([1 for t in row if all(t)]) for row in cells]) > 0:\n        (x, y) = cells_stk[-1]\n        nbs: typing.List[typing.Tuple[int, int]] = []\n        if x != 0 and all(cells[x - 1][y]):\n            nbs.append((x - 1, y))\n        if x != grid_width - 1 and all(cells[x + 1][y]):\n            nbs.append((x + 1, y))\n        if y != 0 and all(cells[x][y - 1]):\n            nbs.append((x, y - 1))\n        if y != grid_height - 1 and all(cells[x][y + 1]):\n            nbs.append((x, y + 1))\n        if len(nbs) == 0:\n            cells_stk.pop(-1)\n            continue\n        nb: typing.Tuple[int, int] = random.choice(nbs)\n        cells_stk.append(nb)\n        if x == nb[0] + 1 and y == nb[1]:\n            cells[x - 1][y] = (cells[x - 1][y][0], False, cells[x - 1][y][2], cells[x - 1][y][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], cells[x][y][2], False)\n        if x == nb[0] - 1 and y == nb[1]:\n            cells[x + 1][y] = (cells[x + 1][y][0], cells[x + 1][y][1], cells[x + 1][y][2], False)\n            cells[x][y] = (cells[x][y][0], False, cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] + 1:\n            cells[x][y - 1] = (cells[x][y - 1][0], cells[x][y - 1][0], False, cells[x][y - 1][3])\n            cells[x][y] = (False, cells[x][y][1], cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] - 1:\n            cells[x][y + 1] = (False, cells[x][y + 1][1], cells[x][y + 1][2], cells[x][y + 1][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], False, cells[x][y][3])\n    lines: typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]] = []\n    for i in range(0, grid_width):\n        for j in range(0, grid_height):\n            if cells[i][j][0]:\n                lines.append(((Decimal(i * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal(j * 10))))\n            if cells[i][j][1]:\n                lines.append(((Decimal((i + 1) * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][2]:\n                lines.append(((Decimal((i + 1) * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][3]:\n                lines.append(((Decimal(i * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal(j * 10))))\n    return lines",
            "@staticmethod\ndef rectangular_maze(grid_width: int=10, grid_height: int=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        This function generates a perfect rectangular maze.\\n        :param grid_width:      the width of the grid (expressed in cells)\\n        :param grid_height:     the height of the grid (expressed in cells)\\n        :return:                a perfect maze, represented as a typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]]\\n        '\n    cells: typing.List[typing.List[typing.Tuple[bool, bool, bool, bool]]] = [[(True, True, True, True) for _ in range(0, grid_height)] for _ in range(0, grid_width)]\n    cells_stk: typing.List[typing.Tuple[int, int]] = [(random.randint(0, grid_width - 1), random.randint(0, grid_height - 1))]\n    while sum([sum([1 for t in row if all(t)]) for row in cells]) > 0:\n        (x, y) = cells_stk[-1]\n        nbs: typing.List[typing.Tuple[int, int]] = []\n        if x != 0 and all(cells[x - 1][y]):\n            nbs.append((x - 1, y))\n        if x != grid_width - 1 and all(cells[x + 1][y]):\n            nbs.append((x + 1, y))\n        if y != 0 and all(cells[x][y - 1]):\n            nbs.append((x, y - 1))\n        if y != grid_height - 1 and all(cells[x][y + 1]):\n            nbs.append((x, y + 1))\n        if len(nbs) == 0:\n            cells_stk.pop(-1)\n            continue\n        nb: typing.Tuple[int, int] = random.choice(nbs)\n        cells_stk.append(nb)\n        if x == nb[0] + 1 and y == nb[1]:\n            cells[x - 1][y] = (cells[x - 1][y][0], False, cells[x - 1][y][2], cells[x - 1][y][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], cells[x][y][2], False)\n        if x == nb[0] - 1 and y == nb[1]:\n            cells[x + 1][y] = (cells[x + 1][y][0], cells[x + 1][y][1], cells[x + 1][y][2], False)\n            cells[x][y] = (cells[x][y][0], False, cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] + 1:\n            cells[x][y - 1] = (cells[x][y - 1][0], cells[x][y - 1][0], False, cells[x][y - 1][3])\n            cells[x][y] = (False, cells[x][y][1], cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] - 1:\n            cells[x][y + 1] = (False, cells[x][y + 1][1], cells[x][y + 1][2], cells[x][y + 1][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], False, cells[x][y][3])\n    lines: typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]] = []\n    for i in range(0, grid_width):\n        for j in range(0, grid_height):\n            if cells[i][j][0]:\n                lines.append(((Decimal(i * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal(j * 10))))\n            if cells[i][j][1]:\n                lines.append(((Decimal((i + 1) * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][2]:\n                lines.append(((Decimal((i + 1) * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][3]:\n                lines.append(((Decimal(i * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal(j * 10))))\n    return lines",
            "@staticmethod\ndef rectangular_maze(grid_width: int=10, grid_height: int=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        This function generates a perfect rectangular maze.\\n        :param grid_width:      the width of the grid (expressed in cells)\\n        :param grid_height:     the height of the grid (expressed in cells)\\n        :return:                a perfect maze, represented as a typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]]\\n        '\n    cells: typing.List[typing.List[typing.Tuple[bool, bool, bool, bool]]] = [[(True, True, True, True) for _ in range(0, grid_height)] for _ in range(0, grid_width)]\n    cells_stk: typing.List[typing.Tuple[int, int]] = [(random.randint(0, grid_width - 1), random.randint(0, grid_height - 1))]\n    while sum([sum([1 for t in row if all(t)]) for row in cells]) > 0:\n        (x, y) = cells_stk[-1]\n        nbs: typing.List[typing.Tuple[int, int]] = []\n        if x != 0 and all(cells[x - 1][y]):\n            nbs.append((x - 1, y))\n        if x != grid_width - 1 and all(cells[x + 1][y]):\n            nbs.append((x + 1, y))\n        if y != 0 and all(cells[x][y - 1]):\n            nbs.append((x, y - 1))\n        if y != grid_height - 1 and all(cells[x][y + 1]):\n            nbs.append((x, y + 1))\n        if len(nbs) == 0:\n            cells_stk.pop(-1)\n            continue\n        nb: typing.Tuple[int, int] = random.choice(nbs)\n        cells_stk.append(nb)\n        if x == nb[0] + 1 and y == nb[1]:\n            cells[x - 1][y] = (cells[x - 1][y][0], False, cells[x - 1][y][2], cells[x - 1][y][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], cells[x][y][2], False)\n        if x == nb[0] - 1 and y == nb[1]:\n            cells[x + 1][y] = (cells[x + 1][y][0], cells[x + 1][y][1], cells[x + 1][y][2], False)\n            cells[x][y] = (cells[x][y][0], False, cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] + 1:\n            cells[x][y - 1] = (cells[x][y - 1][0], cells[x][y - 1][0], False, cells[x][y - 1][3])\n            cells[x][y] = (False, cells[x][y][1], cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] - 1:\n            cells[x][y + 1] = (False, cells[x][y + 1][1], cells[x][y + 1][2], cells[x][y + 1][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], False, cells[x][y][3])\n    lines: typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]] = []\n    for i in range(0, grid_width):\n        for j in range(0, grid_height):\n            if cells[i][j][0]:\n                lines.append(((Decimal(i * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal(j * 10))))\n            if cells[i][j][1]:\n                lines.append(((Decimal((i + 1) * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][2]:\n                lines.append(((Decimal((i + 1) * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][3]:\n                lines.append(((Decimal(i * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal(j * 10))))\n    return lines",
            "@staticmethod\ndef rectangular_maze(grid_width: int=10, grid_height: int=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        This function generates a perfect rectangular maze.\\n        :param grid_width:      the width of the grid (expressed in cells)\\n        :param grid_height:     the height of the grid (expressed in cells)\\n        :return:                a perfect maze, represented as a typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]]\\n        '\n    cells: typing.List[typing.List[typing.Tuple[bool, bool, bool, bool]]] = [[(True, True, True, True) for _ in range(0, grid_height)] for _ in range(0, grid_width)]\n    cells_stk: typing.List[typing.Tuple[int, int]] = [(random.randint(0, grid_width - 1), random.randint(0, grid_height - 1))]\n    while sum([sum([1 for t in row if all(t)]) for row in cells]) > 0:\n        (x, y) = cells_stk[-1]\n        nbs: typing.List[typing.Tuple[int, int]] = []\n        if x != 0 and all(cells[x - 1][y]):\n            nbs.append((x - 1, y))\n        if x != grid_width - 1 and all(cells[x + 1][y]):\n            nbs.append((x + 1, y))\n        if y != 0 and all(cells[x][y - 1]):\n            nbs.append((x, y - 1))\n        if y != grid_height - 1 and all(cells[x][y + 1]):\n            nbs.append((x, y + 1))\n        if len(nbs) == 0:\n            cells_stk.pop(-1)\n            continue\n        nb: typing.Tuple[int, int] = random.choice(nbs)\n        cells_stk.append(nb)\n        if x == nb[0] + 1 and y == nb[1]:\n            cells[x - 1][y] = (cells[x - 1][y][0], False, cells[x - 1][y][2], cells[x - 1][y][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], cells[x][y][2], False)\n        if x == nb[0] - 1 and y == nb[1]:\n            cells[x + 1][y] = (cells[x + 1][y][0], cells[x + 1][y][1], cells[x + 1][y][2], False)\n            cells[x][y] = (cells[x][y][0], False, cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] + 1:\n            cells[x][y - 1] = (cells[x][y - 1][0], cells[x][y - 1][0], False, cells[x][y - 1][3])\n            cells[x][y] = (False, cells[x][y][1], cells[x][y][2], cells[x][y][3])\n        if x == nb[0] and y == nb[1] - 1:\n            cells[x][y + 1] = (False, cells[x][y + 1][1], cells[x][y + 1][2], cells[x][y + 1][3])\n            cells[x][y] = (cells[x][y][0], cells[x][y][1], False, cells[x][y][3])\n    lines: typing.List[typing.Tuple[typing.Tuple[Decimal, Decimal], typing.Tuple[Decimal, Decimal]]] = []\n    for i in range(0, grid_width):\n        for j in range(0, grid_height):\n            if cells[i][j][0]:\n                lines.append(((Decimal(i * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal(j * 10))))\n            if cells[i][j][1]:\n                lines.append(((Decimal((i + 1) * 10), Decimal(j * 10)), (Decimal((i + 1) * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][2]:\n                lines.append(((Decimal((i + 1) * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal((j + 1) * 10))))\n            if cells[i][j][3]:\n                lines.append(((Decimal(i * 10), Decimal((j + 1) * 10)), (Decimal(i * 10), Decimal(j * 10))))\n    return lines"
        ]
    }
]