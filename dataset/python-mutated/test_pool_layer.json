[
    {
        "func_name": "pytest_generate_tests",
        "original": "def pytest_generate_tests(metafunc):\n    np.random.seed(1)\n    if metafunc.config.option.all:\n        bsz_rng = [32, 64]\n    else:\n        bsz_rng = [128]\n    if 'poolargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            fs_rng = [2, 3, 5]\n            pad_rng = [0, 1]\n            nifm_rng = [16, 32]\n            in_sz_rng = [8, 16]\n        else:\n            fs_rng = [2, 4]\n            pad_rng = [0, 1]\n            nifm_rng = [8]\n            in_sz_rng = [8]\n        fargs_ = []\n        for fs in fs_rng:\n            stride_rng = set([1, fs // 2, fs])\n            fargs_.append(itt.product(fs_rng, nifm_rng, pad_rng, stride_rng, in_sz_rng, bsz_rng))\n        fargs = itt.chain(*fargs_)\n        metafunc.parametrize('poolargs', fargs)",
        "mutated": [
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n    np.random.seed(1)\n    if metafunc.config.option.all:\n        bsz_rng = [32, 64]\n    else:\n        bsz_rng = [128]\n    if 'poolargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            fs_rng = [2, 3, 5]\n            pad_rng = [0, 1]\n            nifm_rng = [16, 32]\n            in_sz_rng = [8, 16]\n        else:\n            fs_rng = [2, 4]\n            pad_rng = [0, 1]\n            nifm_rng = [8]\n            in_sz_rng = [8]\n        fargs_ = []\n        for fs in fs_rng:\n            stride_rng = set([1, fs // 2, fs])\n            fargs_.append(itt.product(fs_rng, nifm_rng, pad_rng, stride_rng, in_sz_rng, bsz_rng))\n        fargs = itt.chain(*fargs_)\n        metafunc.parametrize('poolargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(1)\n    if metafunc.config.option.all:\n        bsz_rng = [32, 64]\n    else:\n        bsz_rng = [128]\n    if 'poolargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            fs_rng = [2, 3, 5]\n            pad_rng = [0, 1]\n            nifm_rng = [16, 32]\n            in_sz_rng = [8, 16]\n        else:\n            fs_rng = [2, 4]\n            pad_rng = [0, 1]\n            nifm_rng = [8]\n            in_sz_rng = [8]\n        fargs_ = []\n        for fs in fs_rng:\n            stride_rng = set([1, fs // 2, fs])\n            fargs_.append(itt.product(fs_rng, nifm_rng, pad_rng, stride_rng, in_sz_rng, bsz_rng))\n        fargs = itt.chain(*fargs_)\n        metafunc.parametrize('poolargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(1)\n    if metafunc.config.option.all:\n        bsz_rng = [32, 64]\n    else:\n        bsz_rng = [128]\n    if 'poolargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            fs_rng = [2, 3, 5]\n            pad_rng = [0, 1]\n            nifm_rng = [16, 32]\n            in_sz_rng = [8, 16]\n        else:\n            fs_rng = [2, 4]\n            pad_rng = [0, 1]\n            nifm_rng = [8]\n            in_sz_rng = [8]\n        fargs_ = []\n        for fs in fs_rng:\n            stride_rng = set([1, fs // 2, fs])\n            fargs_.append(itt.product(fs_rng, nifm_rng, pad_rng, stride_rng, in_sz_rng, bsz_rng))\n        fargs = itt.chain(*fargs_)\n        metafunc.parametrize('poolargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(1)\n    if metafunc.config.option.all:\n        bsz_rng = [32, 64]\n    else:\n        bsz_rng = [128]\n    if 'poolargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            fs_rng = [2, 3, 5]\n            pad_rng = [0, 1]\n            nifm_rng = [16, 32]\n            in_sz_rng = [8, 16]\n        else:\n            fs_rng = [2, 4]\n            pad_rng = [0, 1]\n            nifm_rng = [8]\n            in_sz_rng = [8]\n        fargs_ = []\n        for fs in fs_rng:\n            stride_rng = set([1, fs // 2, fs])\n            fargs_.append(itt.product(fs_rng, nifm_rng, pad_rng, stride_rng, in_sz_rng, bsz_rng))\n        fargs = itt.chain(*fargs_)\n        metafunc.parametrize('poolargs', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(1)\n    if metafunc.config.option.all:\n        bsz_rng = [32, 64]\n    else:\n        bsz_rng = [128]\n    if 'poolargs' in metafunc.fixturenames:\n        fargs = []\n        if metafunc.config.option.all:\n            fs_rng = [2, 3, 5]\n            pad_rng = [0, 1]\n            nifm_rng = [16, 32]\n            in_sz_rng = [8, 16]\n        else:\n            fs_rng = [2, 4]\n            pad_rng = [0, 1]\n            nifm_rng = [8]\n            in_sz_rng = [8]\n        fargs_ = []\n        for fs in fs_rng:\n            stride_rng = set([1, fs // 2, fs])\n            fargs_.append(itt.product(fs_rng, nifm_rng, pad_rng, stride_rng, in_sz_rng, bsz_rng))\n        fargs = itt.chain(*fargs_)\n        metafunc.parametrize('poolargs', fargs)"
        ]
    },
    {
        "func_name": "ref_pooling",
        "original": "def ref_pooling(inp, inp_shape, fshape, padding, strides, be, ncheck=None):\n    inp_lshape = list(inp_shape)\n    bsz = inp.shape[-1]\n    if ncheck is None:\n        check_inds = np.arange(bsz)\n    elif type(ncheck) is int:\n        check_inds = np.random.permutation(bsz)\n        check_inds = check_inds[0:ncheck]\n    else:\n        check_inds = ncheck\n    check_inds = np.sort(check_inds)\n    inp_lshape.append(bsz)\n    inpa = inp.get().reshape(inp_lshape)\n    outshape = (inp_lshape[0], be.output_dim(inp_lshape[1], fshape[0], padding, strides[0], pooling=True), be.output_dim(inp_lshape[2], fshape[1], padding, strides[1], pooling=True), len(check_inds))\n    if padding > 0:\n        padded_shape = (inp_lshape[0], inp_lshape[1] + 2 * padding, inp_lshape[2] + 2 * padding, inp_lshape[-1])\n        inp_pad = np.zeros(padded_shape)\n        inp_pad[:, padding:-padding, padding:-padding, :] = inpa[:, 0:, 0:, :]\n    else:\n        inp_pad = inpa\n    out_exp = np.zeros(outshape)\n    for indC in range(outshape[0]):\n        for indh in range(outshape[1]):\n            hrng = (indh * strides[0], indh * strides[0] + fshape[0])\n            for indw in range(outshape[2]):\n                wrng = (indw * strides[1], indw * strides[1] + fshape[1])\n                for (cnt, indb) in enumerate(check_inds):\n                    inp_check = inp_pad[indC, hrng[0]:hrng[1], wrng[0]:wrng[1], indb]\n                    out_exp[indC, indh, indw, cnt] = np.max(inp_check)\n    return (out_exp, check_inds)",
        "mutated": [
            "def ref_pooling(inp, inp_shape, fshape, padding, strides, be, ncheck=None):\n    if False:\n        i = 10\n    inp_lshape = list(inp_shape)\n    bsz = inp.shape[-1]\n    if ncheck is None:\n        check_inds = np.arange(bsz)\n    elif type(ncheck) is int:\n        check_inds = np.random.permutation(bsz)\n        check_inds = check_inds[0:ncheck]\n    else:\n        check_inds = ncheck\n    check_inds = np.sort(check_inds)\n    inp_lshape.append(bsz)\n    inpa = inp.get().reshape(inp_lshape)\n    outshape = (inp_lshape[0], be.output_dim(inp_lshape[1], fshape[0], padding, strides[0], pooling=True), be.output_dim(inp_lshape[2], fshape[1], padding, strides[1], pooling=True), len(check_inds))\n    if padding > 0:\n        padded_shape = (inp_lshape[0], inp_lshape[1] + 2 * padding, inp_lshape[2] + 2 * padding, inp_lshape[-1])\n        inp_pad = np.zeros(padded_shape)\n        inp_pad[:, padding:-padding, padding:-padding, :] = inpa[:, 0:, 0:, :]\n    else:\n        inp_pad = inpa\n    out_exp = np.zeros(outshape)\n    for indC in range(outshape[0]):\n        for indh in range(outshape[1]):\n            hrng = (indh * strides[0], indh * strides[0] + fshape[0])\n            for indw in range(outshape[2]):\n                wrng = (indw * strides[1], indw * strides[1] + fshape[1])\n                for (cnt, indb) in enumerate(check_inds):\n                    inp_check = inp_pad[indC, hrng[0]:hrng[1], wrng[0]:wrng[1], indb]\n                    out_exp[indC, indh, indw, cnt] = np.max(inp_check)\n    return (out_exp, check_inds)",
            "def ref_pooling(inp, inp_shape, fshape, padding, strides, be, ncheck=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    inp_lshape = list(inp_shape)\n    bsz = inp.shape[-1]\n    if ncheck is None:\n        check_inds = np.arange(bsz)\n    elif type(ncheck) is int:\n        check_inds = np.random.permutation(bsz)\n        check_inds = check_inds[0:ncheck]\n    else:\n        check_inds = ncheck\n    check_inds = np.sort(check_inds)\n    inp_lshape.append(bsz)\n    inpa = inp.get().reshape(inp_lshape)\n    outshape = (inp_lshape[0], be.output_dim(inp_lshape[1], fshape[0], padding, strides[0], pooling=True), be.output_dim(inp_lshape[2], fshape[1], padding, strides[1], pooling=True), len(check_inds))\n    if padding > 0:\n        padded_shape = (inp_lshape[0], inp_lshape[1] + 2 * padding, inp_lshape[2] + 2 * padding, inp_lshape[-1])\n        inp_pad = np.zeros(padded_shape)\n        inp_pad[:, padding:-padding, padding:-padding, :] = inpa[:, 0:, 0:, :]\n    else:\n        inp_pad = inpa\n    out_exp = np.zeros(outshape)\n    for indC in range(outshape[0]):\n        for indh in range(outshape[1]):\n            hrng = (indh * strides[0], indh * strides[0] + fshape[0])\n            for indw in range(outshape[2]):\n                wrng = (indw * strides[1], indw * strides[1] + fshape[1])\n                for (cnt, indb) in enumerate(check_inds):\n                    inp_check = inp_pad[indC, hrng[0]:hrng[1], wrng[0]:wrng[1], indb]\n                    out_exp[indC, indh, indw, cnt] = np.max(inp_check)\n    return (out_exp, check_inds)",
            "def ref_pooling(inp, inp_shape, fshape, padding, strides, be, ncheck=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    inp_lshape = list(inp_shape)\n    bsz = inp.shape[-1]\n    if ncheck is None:\n        check_inds = np.arange(bsz)\n    elif type(ncheck) is int:\n        check_inds = np.random.permutation(bsz)\n        check_inds = check_inds[0:ncheck]\n    else:\n        check_inds = ncheck\n    check_inds = np.sort(check_inds)\n    inp_lshape.append(bsz)\n    inpa = inp.get().reshape(inp_lshape)\n    outshape = (inp_lshape[0], be.output_dim(inp_lshape[1], fshape[0], padding, strides[0], pooling=True), be.output_dim(inp_lshape[2], fshape[1], padding, strides[1], pooling=True), len(check_inds))\n    if padding > 0:\n        padded_shape = (inp_lshape[0], inp_lshape[1] + 2 * padding, inp_lshape[2] + 2 * padding, inp_lshape[-1])\n        inp_pad = np.zeros(padded_shape)\n        inp_pad[:, padding:-padding, padding:-padding, :] = inpa[:, 0:, 0:, :]\n    else:\n        inp_pad = inpa\n    out_exp = np.zeros(outshape)\n    for indC in range(outshape[0]):\n        for indh in range(outshape[1]):\n            hrng = (indh * strides[0], indh * strides[0] + fshape[0])\n            for indw in range(outshape[2]):\n                wrng = (indw * strides[1], indw * strides[1] + fshape[1])\n                for (cnt, indb) in enumerate(check_inds):\n                    inp_check = inp_pad[indC, hrng[0]:hrng[1], wrng[0]:wrng[1], indb]\n                    out_exp[indC, indh, indw, cnt] = np.max(inp_check)\n    return (out_exp, check_inds)",
            "def ref_pooling(inp, inp_shape, fshape, padding, strides, be, ncheck=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    inp_lshape = list(inp_shape)\n    bsz = inp.shape[-1]\n    if ncheck is None:\n        check_inds = np.arange(bsz)\n    elif type(ncheck) is int:\n        check_inds = np.random.permutation(bsz)\n        check_inds = check_inds[0:ncheck]\n    else:\n        check_inds = ncheck\n    check_inds = np.sort(check_inds)\n    inp_lshape.append(bsz)\n    inpa = inp.get().reshape(inp_lshape)\n    outshape = (inp_lshape[0], be.output_dim(inp_lshape[1], fshape[0], padding, strides[0], pooling=True), be.output_dim(inp_lshape[2], fshape[1], padding, strides[1], pooling=True), len(check_inds))\n    if padding > 0:\n        padded_shape = (inp_lshape[0], inp_lshape[1] + 2 * padding, inp_lshape[2] + 2 * padding, inp_lshape[-1])\n        inp_pad = np.zeros(padded_shape)\n        inp_pad[:, padding:-padding, padding:-padding, :] = inpa[:, 0:, 0:, :]\n    else:\n        inp_pad = inpa\n    out_exp = np.zeros(outshape)\n    for indC in range(outshape[0]):\n        for indh in range(outshape[1]):\n            hrng = (indh * strides[0], indh * strides[0] + fshape[0])\n            for indw in range(outshape[2]):\n                wrng = (indw * strides[1], indw * strides[1] + fshape[1])\n                for (cnt, indb) in enumerate(check_inds):\n                    inp_check = inp_pad[indC, hrng[0]:hrng[1], wrng[0]:wrng[1], indb]\n                    out_exp[indC, indh, indw, cnt] = np.max(inp_check)\n    return (out_exp, check_inds)",
            "def ref_pooling(inp, inp_shape, fshape, padding, strides, be, ncheck=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    inp_lshape = list(inp_shape)\n    bsz = inp.shape[-1]\n    if ncheck is None:\n        check_inds = np.arange(bsz)\n    elif type(ncheck) is int:\n        check_inds = np.random.permutation(bsz)\n        check_inds = check_inds[0:ncheck]\n    else:\n        check_inds = ncheck\n    check_inds = np.sort(check_inds)\n    inp_lshape.append(bsz)\n    inpa = inp.get().reshape(inp_lshape)\n    outshape = (inp_lshape[0], be.output_dim(inp_lshape[1], fshape[0], padding, strides[0], pooling=True), be.output_dim(inp_lshape[2], fshape[1], padding, strides[1], pooling=True), len(check_inds))\n    if padding > 0:\n        padded_shape = (inp_lshape[0], inp_lshape[1] + 2 * padding, inp_lshape[2] + 2 * padding, inp_lshape[-1])\n        inp_pad = np.zeros(padded_shape)\n        inp_pad[:, padding:-padding, padding:-padding, :] = inpa[:, 0:, 0:, :]\n    else:\n        inp_pad = inpa\n    out_exp = np.zeros(outshape)\n    for indC in range(outshape[0]):\n        for indh in range(outshape[1]):\n            hrng = (indh * strides[0], indh * strides[0] + fshape[0])\n            for indw in range(outshape[2]):\n                wrng = (indw * strides[1], indw * strides[1] + fshape[1])\n                for (cnt, indb) in enumerate(check_inds):\n                    inp_check = inp_pad[indC, hrng[0]:hrng[1], wrng[0]:wrng[1], indb]\n                    out_exp[indC, indh, indw, cnt] = np.max(inp_check)\n    return (out_exp, check_inds)"
        ]
    },
    {
        "func_name": "test_padding",
        "original": "def test_padding(backend_default, poolargs, deltas_buffer):\n    (fshape, nifm, padding, stride, in_sz, batch_size) = poolargs\n    NervanaObject.be.bsz = batch_size\n    inshape = (nifm, in_sz, in_sz)\n    insize = np.prod(inshape)\n    neon_layer = Pooling(fshape=fshape, strides=stride, padding=padding)\n    inp = neon_layer.be.array(np.random.random((insize, batch_size)))\n    inp.lshape = inshape\n    neon_layer.configure(inshape)\n    neon_layer.prev_layer = True\n    neon_layer.allocate()\n    neon_layer.allocate_deltas(deltas_buffer)\n    neon_layer.set_deltas(deltas_buffer)\n    neon_layer.argmax = neon_layer.be.iobuf(neon_layer.outputs.shape[0], dtype=np.uint8)\n    out = neon_layer.fprop(inp).get()\n    ncheck = [0, batch_size // 2, batch_size - 1]\n    (out_exp, check_inds) = ref_pooling(inp, inp.lshape, (fshape, fshape), padding, (stride, stride), neon_layer.be, ncheck=ncheck)\n    out_shape = list(out_exp.shape[0:3])\n    out_shape.append(batch_size)\n    outa = out.reshape(out_shape)\n    assert allclose_with_out(out_exp, outa[:, :, :, check_inds], atol=0.0, rtol=0.0)",
        "mutated": [
            "def test_padding(backend_default, poolargs, deltas_buffer):\n    if False:\n        i = 10\n    (fshape, nifm, padding, stride, in_sz, batch_size) = poolargs\n    NervanaObject.be.bsz = batch_size\n    inshape = (nifm, in_sz, in_sz)\n    insize = np.prod(inshape)\n    neon_layer = Pooling(fshape=fshape, strides=stride, padding=padding)\n    inp = neon_layer.be.array(np.random.random((insize, batch_size)))\n    inp.lshape = inshape\n    neon_layer.configure(inshape)\n    neon_layer.prev_layer = True\n    neon_layer.allocate()\n    neon_layer.allocate_deltas(deltas_buffer)\n    neon_layer.set_deltas(deltas_buffer)\n    neon_layer.argmax = neon_layer.be.iobuf(neon_layer.outputs.shape[0], dtype=np.uint8)\n    out = neon_layer.fprop(inp).get()\n    ncheck = [0, batch_size // 2, batch_size - 1]\n    (out_exp, check_inds) = ref_pooling(inp, inp.lshape, (fshape, fshape), padding, (stride, stride), neon_layer.be, ncheck=ncheck)\n    out_shape = list(out_exp.shape[0:3])\n    out_shape.append(batch_size)\n    outa = out.reshape(out_shape)\n    assert allclose_with_out(out_exp, outa[:, :, :, check_inds], atol=0.0, rtol=0.0)",
            "def test_padding(backend_default, poolargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (fshape, nifm, padding, stride, in_sz, batch_size) = poolargs\n    NervanaObject.be.bsz = batch_size\n    inshape = (nifm, in_sz, in_sz)\n    insize = np.prod(inshape)\n    neon_layer = Pooling(fshape=fshape, strides=stride, padding=padding)\n    inp = neon_layer.be.array(np.random.random((insize, batch_size)))\n    inp.lshape = inshape\n    neon_layer.configure(inshape)\n    neon_layer.prev_layer = True\n    neon_layer.allocate()\n    neon_layer.allocate_deltas(deltas_buffer)\n    neon_layer.set_deltas(deltas_buffer)\n    neon_layer.argmax = neon_layer.be.iobuf(neon_layer.outputs.shape[0], dtype=np.uint8)\n    out = neon_layer.fprop(inp).get()\n    ncheck = [0, batch_size // 2, batch_size - 1]\n    (out_exp, check_inds) = ref_pooling(inp, inp.lshape, (fshape, fshape), padding, (stride, stride), neon_layer.be, ncheck=ncheck)\n    out_shape = list(out_exp.shape[0:3])\n    out_shape.append(batch_size)\n    outa = out.reshape(out_shape)\n    assert allclose_with_out(out_exp, outa[:, :, :, check_inds], atol=0.0, rtol=0.0)",
            "def test_padding(backend_default, poolargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (fshape, nifm, padding, stride, in_sz, batch_size) = poolargs\n    NervanaObject.be.bsz = batch_size\n    inshape = (nifm, in_sz, in_sz)\n    insize = np.prod(inshape)\n    neon_layer = Pooling(fshape=fshape, strides=stride, padding=padding)\n    inp = neon_layer.be.array(np.random.random((insize, batch_size)))\n    inp.lshape = inshape\n    neon_layer.configure(inshape)\n    neon_layer.prev_layer = True\n    neon_layer.allocate()\n    neon_layer.allocate_deltas(deltas_buffer)\n    neon_layer.set_deltas(deltas_buffer)\n    neon_layer.argmax = neon_layer.be.iobuf(neon_layer.outputs.shape[0], dtype=np.uint8)\n    out = neon_layer.fprop(inp).get()\n    ncheck = [0, batch_size // 2, batch_size - 1]\n    (out_exp, check_inds) = ref_pooling(inp, inp.lshape, (fshape, fshape), padding, (stride, stride), neon_layer.be, ncheck=ncheck)\n    out_shape = list(out_exp.shape[0:3])\n    out_shape.append(batch_size)\n    outa = out.reshape(out_shape)\n    assert allclose_with_out(out_exp, outa[:, :, :, check_inds], atol=0.0, rtol=0.0)",
            "def test_padding(backend_default, poolargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (fshape, nifm, padding, stride, in_sz, batch_size) = poolargs\n    NervanaObject.be.bsz = batch_size\n    inshape = (nifm, in_sz, in_sz)\n    insize = np.prod(inshape)\n    neon_layer = Pooling(fshape=fshape, strides=stride, padding=padding)\n    inp = neon_layer.be.array(np.random.random((insize, batch_size)))\n    inp.lshape = inshape\n    neon_layer.configure(inshape)\n    neon_layer.prev_layer = True\n    neon_layer.allocate()\n    neon_layer.allocate_deltas(deltas_buffer)\n    neon_layer.set_deltas(deltas_buffer)\n    neon_layer.argmax = neon_layer.be.iobuf(neon_layer.outputs.shape[0], dtype=np.uint8)\n    out = neon_layer.fprop(inp).get()\n    ncheck = [0, batch_size // 2, batch_size - 1]\n    (out_exp, check_inds) = ref_pooling(inp, inp.lshape, (fshape, fshape), padding, (stride, stride), neon_layer.be, ncheck=ncheck)\n    out_shape = list(out_exp.shape[0:3])\n    out_shape.append(batch_size)\n    outa = out.reshape(out_shape)\n    assert allclose_with_out(out_exp, outa[:, :, :, check_inds], atol=0.0, rtol=0.0)",
            "def test_padding(backend_default, poolargs, deltas_buffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (fshape, nifm, padding, stride, in_sz, batch_size) = poolargs\n    NervanaObject.be.bsz = batch_size\n    inshape = (nifm, in_sz, in_sz)\n    insize = np.prod(inshape)\n    neon_layer = Pooling(fshape=fshape, strides=stride, padding=padding)\n    inp = neon_layer.be.array(np.random.random((insize, batch_size)))\n    inp.lshape = inshape\n    neon_layer.configure(inshape)\n    neon_layer.prev_layer = True\n    neon_layer.allocate()\n    neon_layer.allocate_deltas(deltas_buffer)\n    neon_layer.set_deltas(deltas_buffer)\n    neon_layer.argmax = neon_layer.be.iobuf(neon_layer.outputs.shape[0], dtype=np.uint8)\n    out = neon_layer.fprop(inp).get()\n    ncheck = [0, batch_size // 2, batch_size - 1]\n    (out_exp, check_inds) = ref_pooling(inp, inp.lshape, (fshape, fshape), padding, (stride, stride), neon_layer.be, ncheck=ncheck)\n    out_shape = list(out_exp.shape[0:3])\n    out_shape.append(batch_size)\n    outa = out.reshape(out_shape)\n    assert allclose_with_out(out_exp, outa[:, :, :, check_inds], atol=0.0, rtol=0.0)"
        ]
    }
]