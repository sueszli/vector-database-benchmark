[
    {
        "func_name": "hex_to_rgba",
        "original": "def hex_to_rgba(value):\n    value = value.lstrip('#')\n    length = len(value)\n    if length == 3:\n        value = ''.join([v * 2 for v in list(value)])\n    alpha = [str(round(int(value[6:], 16) / 255.0, 2) if length > 6 else 1.0)]\n    return [str(int(value[i:i + 2], 16)) for i in range(0, 6, 2)] + alpha",
        "mutated": [
            "def hex_to_rgba(value):\n    if False:\n        i = 10\n    value = value.lstrip('#')\n    length = len(value)\n    if length == 3:\n        value = ''.join([v * 2 for v in list(value)])\n    alpha = [str(round(int(value[6:], 16) / 255.0, 2) if length > 6 else 1.0)]\n    return [str(int(value[i:i + 2], 16)) for i in range(0, 6, 2)] + alpha",
            "def hex_to_rgba(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    value = value.lstrip('#')\n    length = len(value)\n    if length == 3:\n        value = ''.join([v * 2 for v in list(value)])\n    alpha = [str(round(int(value[6:], 16) / 255.0, 2) if length > 6 else 1.0)]\n    return [str(int(value[i:i + 2], 16)) for i in range(0, 6, 2)] + alpha",
            "def hex_to_rgba(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    value = value.lstrip('#')\n    length = len(value)\n    if length == 3:\n        value = ''.join([v * 2 for v in list(value)])\n    alpha = [str(round(int(value[6:], 16) / 255.0, 2) if length > 6 else 1.0)]\n    return [str(int(value[i:i + 2], 16)) for i in range(0, 6, 2)] + alpha",
            "def hex_to_rgba(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    value = value.lstrip('#')\n    length = len(value)\n    if length == 3:\n        value = ''.join([v * 2 for v in list(value)])\n    alpha = [str(round(int(value[6:], 16) / 255.0, 2) if length > 6 else 1.0)]\n    return [str(int(value[i:i + 2], 16)) for i in range(0, 6, 2)] + alpha",
            "def hex_to_rgba(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    value = value.lstrip('#')\n    length = len(value)\n    if length == 3:\n        value = ''.join([v * 2 for v in list(value)])\n    alpha = [str(round(int(value[6:], 16) / 255.0, 2) if length > 6 else 1.0)]\n    return [str(int(value[i:i + 2], 16)) for i in range(0, 6, 2)] + alpha"
        ]
    },
    {
        "func_name": "convert_to_rgba_css",
        "original": "def convert_to_rgba_css(word):\n    rgba = hex_to_rgba(word)\n    rgba_css = 'rgb%s(%s)' % ('a' if len(rgba) > 3 else '', ','.join(rgba))\n    return rgba_css",
        "mutated": [
            "def convert_to_rgba_css(word):\n    if False:\n        i = 10\n    rgba = hex_to_rgba(word)\n    rgba_css = 'rgb%s(%s)' % ('a' if len(rgba) > 3 else '', ','.join(rgba))\n    return rgba_css",
            "def convert_to_rgba_css(word):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rgba = hex_to_rgba(word)\n    rgba_css = 'rgb%s(%s)' % ('a' if len(rgba) > 3 else '', ','.join(rgba))\n    return rgba_css",
            "def convert_to_rgba_css(word):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rgba = hex_to_rgba(word)\n    rgba_css = 'rgb%s(%s)' % ('a' if len(rgba) > 3 else '', ','.join(rgba))\n    return rgba_css",
            "def convert_to_rgba_css(word):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rgba = hex_to_rgba(word)\n    rgba_css = 'rgb%s(%s)' % ('a' if len(rgba) > 3 else '', ','.join(rgba))\n    return rgba_css",
            "def convert_to_rgba_css(word):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rgba = hex_to_rgba(word)\n    rgba_css = 'rgb%s(%s)' % ('a' if len(rgba) > 3 else '', ','.join(rgba))\n    return rgba_css"
        ]
    },
    {
        "func_name": "convert_tmtheme_to_css",
        "original": "def convert_tmtheme_to_css(theme_file):\n    \"\"\"return list of css lines ready to be pasted\"\"\"\n    if not theme_file:\n        return default_ccsl\n    theme_as_dict = parse_file(theme_file)\n    cssl = []\n    default_color = 'rgb(236,9,140)'\n    for i in theme_as_dict.get('settings'):\n        s = i.get('settings', {})\n        if 'caret' in s:\n            default_color = convert_to_rgba_css(s['caret'])\n    for item in theme_as_dict.get('settings'):\n        scope = item.get('scope', 'body')\n        props = item.get('settings', {})\n        props_str = ''\n        if props:\n            for (k, v) in props.items():\n                k = k.replace('foreground', 'color')\n                if v:\n                    if any((k == w for w in ('background', 'color'))):\n                        props_str += '%s: %s; ' % (k, convert_to_rgba_css(v) or v)\n                    elif k == 'fontStyle':\n                        if 'bold' in v:\n                            props_str += 'font-weight: bold; font-style: normal; '\n                        elif 'italic' in v:\n                            props_str += 'font-weight: normal; font-style: italic; '\n            if not props.get('fontStyle'):\n                props_str += 'font-weight: normal; font-style: normal; '\n            if not props.get('foreground'):\n                props_str += 'color: %s; ' % default_color\n        else:\n            props_str += 'color: %s; font-weight: normal; font-style: normal; ' % default_color\n        if scope == 'keyword':\n            props_str += 'width: 100%; '\n        mo = re.search(SCOPES_REGEX, scope)\n        tag = mo.lastgroup.replace('__', '.').replace('_', '-') if mo else ''\n        if tag:\n            cssl.append('%s { %s}' % (tag, props_str))\n    return cssl",
        "mutated": [
            "def convert_tmtheme_to_css(theme_file):\n    if False:\n        i = 10\n    'return list of css lines ready to be pasted'\n    if not theme_file:\n        return default_ccsl\n    theme_as_dict = parse_file(theme_file)\n    cssl = []\n    default_color = 'rgb(236,9,140)'\n    for i in theme_as_dict.get('settings'):\n        s = i.get('settings', {})\n        if 'caret' in s:\n            default_color = convert_to_rgba_css(s['caret'])\n    for item in theme_as_dict.get('settings'):\n        scope = item.get('scope', 'body')\n        props = item.get('settings', {})\n        props_str = ''\n        if props:\n            for (k, v) in props.items():\n                k = k.replace('foreground', 'color')\n                if v:\n                    if any((k == w for w in ('background', 'color'))):\n                        props_str += '%s: %s; ' % (k, convert_to_rgba_css(v) or v)\n                    elif k == 'fontStyle':\n                        if 'bold' in v:\n                            props_str += 'font-weight: bold; font-style: normal; '\n                        elif 'italic' in v:\n                            props_str += 'font-weight: normal; font-style: italic; '\n            if not props.get('fontStyle'):\n                props_str += 'font-weight: normal; font-style: normal; '\n            if not props.get('foreground'):\n                props_str += 'color: %s; ' % default_color\n        else:\n            props_str += 'color: %s; font-weight: normal; font-style: normal; ' % default_color\n        if scope == 'keyword':\n            props_str += 'width: 100%; '\n        mo = re.search(SCOPES_REGEX, scope)\n        tag = mo.lastgroup.replace('__', '.').replace('_', '-') if mo else ''\n        if tag:\n            cssl.append('%s { %s}' % (tag, props_str))\n    return cssl",
            "def convert_tmtheme_to_css(theme_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'return list of css lines ready to be pasted'\n    if not theme_file:\n        return default_ccsl\n    theme_as_dict = parse_file(theme_file)\n    cssl = []\n    default_color = 'rgb(236,9,140)'\n    for i in theme_as_dict.get('settings'):\n        s = i.get('settings', {})\n        if 'caret' in s:\n            default_color = convert_to_rgba_css(s['caret'])\n    for item in theme_as_dict.get('settings'):\n        scope = item.get('scope', 'body')\n        props = item.get('settings', {})\n        props_str = ''\n        if props:\n            for (k, v) in props.items():\n                k = k.replace('foreground', 'color')\n                if v:\n                    if any((k == w for w in ('background', 'color'))):\n                        props_str += '%s: %s; ' % (k, convert_to_rgba_css(v) or v)\n                    elif k == 'fontStyle':\n                        if 'bold' in v:\n                            props_str += 'font-weight: bold; font-style: normal; '\n                        elif 'italic' in v:\n                            props_str += 'font-weight: normal; font-style: italic; '\n            if not props.get('fontStyle'):\n                props_str += 'font-weight: normal; font-style: normal; '\n            if not props.get('foreground'):\n                props_str += 'color: %s; ' % default_color\n        else:\n            props_str += 'color: %s; font-weight: normal; font-style: normal; ' % default_color\n        if scope == 'keyword':\n            props_str += 'width: 100%; '\n        mo = re.search(SCOPES_REGEX, scope)\n        tag = mo.lastgroup.replace('__', '.').replace('_', '-') if mo else ''\n        if tag:\n            cssl.append('%s { %s}' % (tag, props_str))\n    return cssl",
            "def convert_tmtheme_to_css(theme_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'return list of css lines ready to be pasted'\n    if not theme_file:\n        return default_ccsl\n    theme_as_dict = parse_file(theme_file)\n    cssl = []\n    default_color = 'rgb(236,9,140)'\n    for i in theme_as_dict.get('settings'):\n        s = i.get('settings', {})\n        if 'caret' in s:\n            default_color = convert_to_rgba_css(s['caret'])\n    for item in theme_as_dict.get('settings'):\n        scope = item.get('scope', 'body')\n        props = item.get('settings', {})\n        props_str = ''\n        if props:\n            for (k, v) in props.items():\n                k = k.replace('foreground', 'color')\n                if v:\n                    if any((k == w for w in ('background', 'color'))):\n                        props_str += '%s: %s; ' % (k, convert_to_rgba_css(v) or v)\n                    elif k == 'fontStyle':\n                        if 'bold' in v:\n                            props_str += 'font-weight: bold; font-style: normal; '\n                        elif 'italic' in v:\n                            props_str += 'font-weight: normal; font-style: italic; '\n            if not props.get('fontStyle'):\n                props_str += 'font-weight: normal; font-style: normal; '\n            if not props.get('foreground'):\n                props_str += 'color: %s; ' % default_color\n        else:\n            props_str += 'color: %s; font-weight: normal; font-style: normal; ' % default_color\n        if scope == 'keyword':\n            props_str += 'width: 100%; '\n        mo = re.search(SCOPES_REGEX, scope)\n        tag = mo.lastgroup.replace('__', '.').replace('_', '-') if mo else ''\n        if tag:\n            cssl.append('%s { %s}' % (tag, props_str))\n    return cssl",
            "def convert_tmtheme_to_css(theme_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'return list of css lines ready to be pasted'\n    if not theme_file:\n        return default_ccsl\n    theme_as_dict = parse_file(theme_file)\n    cssl = []\n    default_color = 'rgb(236,9,140)'\n    for i in theme_as_dict.get('settings'):\n        s = i.get('settings', {})\n        if 'caret' in s:\n            default_color = convert_to_rgba_css(s['caret'])\n    for item in theme_as_dict.get('settings'):\n        scope = item.get('scope', 'body')\n        props = item.get('settings', {})\n        props_str = ''\n        if props:\n            for (k, v) in props.items():\n                k = k.replace('foreground', 'color')\n                if v:\n                    if any((k == w for w in ('background', 'color'))):\n                        props_str += '%s: %s; ' % (k, convert_to_rgba_css(v) or v)\n                    elif k == 'fontStyle':\n                        if 'bold' in v:\n                            props_str += 'font-weight: bold; font-style: normal; '\n                        elif 'italic' in v:\n                            props_str += 'font-weight: normal; font-style: italic; '\n            if not props.get('fontStyle'):\n                props_str += 'font-weight: normal; font-style: normal; '\n            if not props.get('foreground'):\n                props_str += 'color: %s; ' % default_color\n        else:\n            props_str += 'color: %s; font-weight: normal; font-style: normal; ' % default_color\n        if scope == 'keyword':\n            props_str += 'width: 100%; '\n        mo = re.search(SCOPES_REGEX, scope)\n        tag = mo.lastgroup.replace('__', '.').replace('_', '-') if mo else ''\n        if tag:\n            cssl.append('%s { %s}' % (tag, props_str))\n    return cssl",
            "def convert_tmtheme_to_css(theme_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'return list of css lines ready to be pasted'\n    if not theme_file:\n        return default_ccsl\n    theme_as_dict = parse_file(theme_file)\n    cssl = []\n    default_color = 'rgb(236,9,140)'\n    for i in theme_as_dict.get('settings'):\n        s = i.get('settings', {})\n        if 'caret' in s:\n            default_color = convert_to_rgba_css(s['caret'])\n    for item in theme_as_dict.get('settings'):\n        scope = item.get('scope', 'body')\n        props = item.get('settings', {})\n        props_str = ''\n        if props:\n            for (k, v) in props.items():\n                k = k.replace('foreground', 'color')\n                if v:\n                    if any((k == w for w in ('background', 'color'))):\n                        props_str += '%s: %s; ' % (k, convert_to_rgba_css(v) or v)\n                    elif k == 'fontStyle':\n                        if 'bold' in v:\n                            props_str += 'font-weight: bold; font-style: normal; '\n                        elif 'italic' in v:\n                            props_str += 'font-weight: normal; font-style: italic; '\n            if not props.get('fontStyle'):\n                props_str += 'font-weight: normal; font-style: normal; '\n            if not props.get('foreground'):\n                props_str += 'color: %s; ' % default_color\n        else:\n            props_str += 'color: %s; font-weight: normal; font-style: normal; ' % default_color\n        if scope == 'keyword':\n            props_str += 'width: 100%; '\n        mo = re.search(SCOPES_REGEX, scope)\n        tag = mo.lastgroup.replace('__', '.').replace('_', '-') if mo else ''\n        if tag:\n            cssl.append('%s { %s}' % (tag, props_str))\n    return cssl"
        ]
    },
    {
        "func_name": "is_enabled",
        "original": "def is_enabled(self):\n    return self.view.score_selector(0, 'text.todo') > 0",
        "mutated": [
            "def is_enabled(self):\n    if False:\n        i = 10\n    return self.view.score_selector(0, 'text.todo') > 0",
            "def is_enabled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.view.score_selector(0, 'text.todo') > 0",
            "def is_enabled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.view.score_selector(0, 'text.todo') > 0",
            "def is_enabled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.view.score_selector(0, 'text.todo') > 0",
            "def is_enabled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.view.score_selector(0, 'text.todo') > 0"
        ]
    },
    {
        "func_name": "runCommand",
        "original": "def runCommand(self, edit, ask=False):\n    all_lines_regions = self.view.split_by_newlines(sublime.Region(0, self.view.size()))\n    html_doc = []\n    patterns = {'HEADER': 'text.todo keyword.control.header.todo ', 'EMPTY': 'text.todo ', 'NOTE': 'text.todo notes.todo ', 'OPEN': 'text.todo meta.item.todo.pending ', 'DONE': 'text.todo meta.item.todo.completed ', 'CANCELLED': 'text.todo meta.item.todo.cancelled ', 'SEPARATOR': 'text.todo meta.punctuation.separator.todo ', 'ARCHIVE': 'text.todo meta.punctuation.archive.todo '}\n    for r in all_lines_regions:\n        i = self.view.scope_name(r.a)\n        if patterns['HEADER'] in i:\n            ht = '<span class=\"header\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif i == patterns['EMPTY']:\n            ht = '<span class=\"empty-line\">%s</span>' % self.view.substr(r)\n        elif patterns['NOTE'] in i:\n            scopes = self.extracting_scopes(self, r, i)\n            note = '<span class=\"note\">'\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'italic' in sn:\n                    note += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    note += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    note += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    note += cgi.escape(self.view.substr(s))\n            ht = note + '</span>'\n        elif patterns['OPEN'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            pending = '<span class=\"open\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    pending += '<span class=\"bullet-pending\">%s</span>' % self.view.substr(s)\n                elif 'meta.tag' in sn:\n                    pending += '<span class=\"tag\">%s</span>' % cgi.escape(self.view.substr(s))\n                elif 'tag.todo.today' in sn:\n                    pending += '<span class=\"tag-today\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.critical' in sn:\n                    pending += '<span class=\"tag-critical\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.high' in sn:\n                    pending += '<span class=\"tag-high\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.low' in sn:\n                    pending += '<span class=\"tag-low\">%s</span>' % self.view.substr(s)\n                elif 'italic' in sn:\n                    pending += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    pending += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    pending += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    pending += cgi.escape(self.view.substr(s))\n            ht = pending + '</span>'\n        elif patterns['DONE'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            done = '<span class=\"done\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    done += '<span class=\"bullet-done\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.completed' in sn:\n                    done += '<span class=\"tag-done\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    done += cgi.escape(self.view.substr(s))\n            ht = done + '</span>'\n        elif patterns['CANCELLED'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            cancelled = '<span class=\"cancelled\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    cancelled += '<span class=\"bullet-cancelled\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.cancelled' in sn:\n                    cancelled += '<span class=\"tag-cancelled\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    cancelled += cgi.escape(self.view.substr(s))\n            ht = cancelled + '</span>'\n        elif patterns['SEPARATOR'] in i:\n            ht = '<span class=\"sep\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif patterns['ARCHIVE'] in i:\n            ht = '<span class=\"sep-archive\">%s</span>' % cgi.escape(self.view.substr(r))\n        else:\n            sublime.error_message('Hey! you are not supposed to see this message.\\nPlease, report an issue in PlainTasks repository on GitHub.')\n        html_doc.append(ht)\n    title = os.path.basename(self.view.file_name()) if self.view.file_name() else 'Export'\n    html = self.produce_html_from_template(title, html_doc)\n    if ask:\n        window = sublime.active_window()\n        nv = window.new_file()\n        nv.set_syntax_file('Packages/HTML/HTML.tmLanguage')\n        nv.set_name(title + '.html')\n        nv.insert(edit, 0, html)\n        window.run_command('close_file')\n        return\n    tmp_html = tempfile.NamedTemporaryFile(delete=False, suffix='.html')\n    tmp_html.write(html.encode('utf-8'))\n    tmp_html.close()\n    webbrowser.open_new_tab('file://%s' % tmp_html.name)",
        "mutated": [
            "def runCommand(self, edit, ask=False):\n    if False:\n        i = 10\n    all_lines_regions = self.view.split_by_newlines(sublime.Region(0, self.view.size()))\n    html_doc = []\n    patterns = {'HEADER': 'text.todo keyword.control.header.todo ', 'EMPTY': 'text.todo ', 'NOTE': 'text.todo notes.todo ', 'OPEN': 'text.todo meta.item.todo.pending ', 'DONE': 'text.todo meta.item.todo.completed ', 'CANCELLED': 'text.todo meta.item.todo.cancelled ', 'SEPARATOR': 'text.todo meta.punctuation.separator.todo ', 'ARCHIVE': 'text.todo meta.punctuation.archive.todo '}\n    for r in all_lines_regions:\n        i = self.view.scope_name(r.a)\n        if patterns['HEADER'] in i:\n            ht = '<span class=\"header\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif i == patterns['EMPTY']:\n            ht = '<span class=\"empty-line\">%s</span>' % self.view.substr(r)\n        elif patterns['NOTE'] in i:\n            scopes = self.extracting_scopes(self, r, i)\n            note = '<span class=\"note\">'\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'italic' in sn:\n                    note += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    note += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    note += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    note += cgi.escape(self.view.substr(s))\n            ht = note + '</span>'\n        elif patterns['OPEN'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            pending = '<span class=\"open\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    pending += '<span class=\"bullet-pending\">%s</span>' % self.view.substr(s)\n                elif 'meta.tag' in sn:\n                    pending += '<span class=\"tag\">%s</span>' % cgi.escape(self.view.substr(s))\n                elif 'tag.todo.today' in sn:\n                    pending += '<span class=\"tag-today\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.critical' in sn:\n                    pending += '<span class=\"tag-critical\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.high' in sn:\n                    pending += '<span class=\"tag-high\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.low' in sn:\n                    pending += '<span class=\"tag-low\">%s</span>' % self.view.substr(s)\n                elif 'italic' in sn:\n                    pending += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    pending += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    pending += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    pending += cgi.escape(self.view.substr(s))\n            ht = pending + '</span>'\n        elif patterns['DONE'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            done = '<span class=\"done\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    done += '<span class=\"bullet-done\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.completed' in sn:\n                    done += '<span class=\"tag-done\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    done += cgi.escape(self.view.substr(s))\n            ht = done + '</span>'\n        elif patterns['CANCELLED'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            cancelled = '<span class=\"cancelled\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    cancelled += '<span class=\"bullet-cancelled\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.cancelled' in sn:\n                    cancelled += '<span class=\"tag-cancelled\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    cancelled += cgi.escape(self.view.substr(s))\n            ht = cancelled + '</span>'\n        elif patterns['SEPARATOR'] in i:\n            ht = '<span class=\"sep\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif patterns['ARCHIVE'] in i:\n            ht = '<span class=\"sep-archive\">%s</span>' % cgi.escape(self.view.substr(r))\n        else:\n            sublime.error_message('Hey! you are not supposed to see this message.\\nPlease, report an issue in PlainTasks repository on GitHub.')\n        html_doc.append(ht)\n    title = os.path.basename(self.view.file_name()) if self.view.file_name() else 'Export'\n    html = self.produce_html_from_template(title, html_doc)\n    if ask:\n        window = sublime.active_window()\n        nv = window.new_file()\n        nv.set_syntax_file('Packages/HTML/HTML.tmLanguage')\n        nv.set_name(title + '.html')\n        nv.insert(edit, 0, html)\n        window.run_command('close_file')\n        return\n    tmp_html = tempfile.NamedTemporaryFile(delete=False, suffix='.html')\n    tmp_html.write(html.encode('utf-8'))\n    tmp_html.close()\n    webbrowser.open_new_tab('file://%s' % tmp_html.name)",
            "def runCommand(self, edit, ask=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    all_lines_regions = self.view.split_by_newlines(sublime.Region(0, self.view.size()))\n    html_doc = []\n    patterns = {'HEADER': 'text.todo keyword.control.header.todo ', 'EMPTY': 'text.todo ', 'NOTE': 'text.todo notes.todo ', 'OPEN': 'text.todo meta.item.todo.pending ', 'DONE': 'text.todo meta.item.todo.completed ', 'CANCELLED': 'text.todo meta.item.todo.cancelled ', 'SEPARATOR': 'text.todo meta.punctuation.separator.todo ', 'ARCHIVE': 'text.todo meta.punctuation.archive.todo '}\n    for r in all_lines_regions:\n        i = self.view.scope_name(r.a)\n        if patterns['HEADER'] in i:\n            ht = '<span class=\"header\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif i == patterns['EMPTY']:\n            ht = '<span class=\"empty-line\">%s</span>' % self.view.substr(r)\n        elif patterns['NOTE'] in i:\n            scopes = self.extracting_scopes(self, r, i)\n            note = '<span class=\"note\">'\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'italic' in sn:\n                    note += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    note += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    note += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    note += cgi.escape(self.view.substr(s))\n            ht = note + '</span>'\n        elif patterns['OPEN'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            pending = '<span class=\"open\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    pending += '<span class=\"bullet-pending\">%s</span>' % self.view.substr(s)\n                elif 'meta.tag' in sn:\n                    pending += '<span class=\"tag\">%s</span>' % cgi.escape(self.view.substr(s))\n                elif 'tag.todo.today' in sn:\n                    pending += '<span class=\"tag-today\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.critical' in sn:\n                    pending += '<span class=\"tag-critical\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.high' in sn:\n                    pending += '<span class=\"tag-high\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.low' in sn:\n                    pending += '<span class=\"tag-low\">%s</span>' % self.view.substr(s)\n                elif 'italic' in sn:\n                    pending += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    pending += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    pending += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    pending += cgi.escape(self.view.substr(s))\n            ht = pending + '</span>'\n        elif patterns['DONE'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            done = '<span class=\"done\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    done += '<span class=\"bullet-done\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.completed' in sn:\n                    done += '<span class=\"tag-done\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    done += cgi.escape(self.view.substr(s))\n            ht = done + '</span>'\n        elif patterns['CANCELLED'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            cancelled = '<span class=\"cancelled\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    cancelled += '<span class=\"bullet-cancelled\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.cancelled' in sn:\n                    cancelled += '<span class=\"tag-cancelled\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    cancelled += cgi.escape(self.view.substr(s))\n            ht = cancelled + '</span>'\n        elif patterns['SEPARATOR'] in i:\n            ht = '<span class=\"sep\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif patterns['ARCHIVE'] in i:\n            ht = '<span class=\"sep-archive\">%s</span>' % cgi.escape(self.view.substr(r))\n        else:\n            sublime.error_message('Hey! you are not supposed to see this message.\\nPlease, report an issue in PlainTasks repository on GitHub.')\n        html_doc.append(ht)\n    title = os.path.basename(self.view.file_name()) if self.view.file_name() else 'Export'\n    html = self.produce_html_from_template(title, html_doc)\n    if ask:\n        window = sublime.active_window()\n        nv = window.new_file()\n        nv.set_syntax_file('Packages/HTML/HTML.tmLanguage')\n        nv.set_name(title + '.html')\n        nv.insert(edit, 0, html)\n        window.run_command('close_file')\n        return\n    tmp_html = tempfile.NamedTemporaryFile(delete=False, suffix='.html')\n    tmp_html.write(html.encode('utf-8'))\n    tmp_html.close()\n    webbrowser.open_new_tab('file://%s' % tmp_html.name)",
            "def runCommand(self, edit, ask=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    all_lines_regions = self.view.split_by_newlines(sublime.Region(0, self.view.size()))\n    html_doc = []\n    patterns = {'HEADER': 'text.todo keyword.control.header.todo ', 'EMPTY': 'text.todo ', 'NOTE': 'text.todo notes.todo ', 'OPEN': 'text.todo meta.item.todo.pending ', 'DONE': 'text.todo meta.item.todo.completed ', 'CANCELLED': 'text.todo meta.item.todo.cancelled ', 'SEPARATOR': 'text.todo meta.punctuation.separator.todo ', 'ARCHIVE': 'text.todo meta.punctuation.archive.todo '}\n    for r in all_lines_regions:\n        i = self.view.scope_name(r.a)\n        if patterns['HEADER'] in i:\n            ht = '<span class=\"header\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif i == patterns['EMPTY']:\n            ht = '<span class=\"empty-line\">%s</span>' % self.view.substr(r)\n        elif patterns['NOTE'] in i:\n            scopes = self.extracting_scopes(self, r, i)\n            note = '<span class=\"note\">'\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'italic' in sn:\n                    note += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    note += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    note += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    note += cgi.escape(self.view.substr(s))\n            ht = note + '</span>'\n        elif patterns['OPEN'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            pending = '<span class=\"open\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    pending += '<span class=\"bullet-pending\">%s</span>' % self.view.substr(s)\n                elif 'meta.tag' in sn:\n                    pending += '<span class=\"tag\">%s</span>' % cgi.escape(self.view.substr(s))\n                elif 'tag.todo.today' in sn:\n                    pending += '<span class=\"tag-today\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.critical' in sn:\n                    pending += '<span class=\"tag-critical\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.high' in sn:\n                    pending += '<span class=\"tag-high\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.low' in sn:\n                    pending += '<span class=\"tag-low\">%s</span>' % self.view.substr(s)\n                elif 'italic' in sn:\n                    pending += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    pending += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    pending += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    pending += cgi.escape(self.view.substr(s))\n            ht = pending + '</span>'\n        elif patterns['DONE'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            done = '<span class=\"done\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    done += '<span class=\"bullet-done\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.completed' in sn:\n                    done += '<span class=\"tag-done\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    done += cgi.escape(self.view.substr(s))\n            ht = done + '</span>'\n        elif patterns['CANCELLED'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            cancelled = '<span class=\"cancelled\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    cancelled += '<span class=\"bullet-cancelled\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.cancelled' in sn:\n                    cancelled += '<span class=\"tag-cancelled\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    cancelled += cgi.escape(self.view.substr(s))\n            ht = cancelled + '</span>'\n        elif patterns['SEPARATOR'] in i:\n            ht = '<span class=\"sep\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif patterns['ARCHIVE'] in i:\n            ht = '<span class=\"sep-archive\">%s</span>' % cgi.escape(self.view.substr(r))\n        else:\n            sublime.error_message('Hey! you are not supposed to see this message.\\nPlease, report an issue in PlainTasks repository on GitHub.')\n        html_doc.append(ht)\n    title = os.path.basename(self.view.file_name()) if self.view.file_name() else 'Export'\n    html = self.produce_html_from_template(title, html_doc)\n    if ask:\n        window = sublime.active_window()\n        nv = window.new_file()\n        nv.set_syntax_file('Packages/HTML/HTML.tmLanguage')\n        nv.set_name(title + '.html')\n        nv.insert(edit, 0, html)\n        window.run_command('close_file')\n        return\n    tmp_html = tempfile.NamedTemporaryFile(delete=False, suffix='.html')\n    tmp_html.write(html.encode('utf-8'))\n    tmp_html.close()\n    webbrowser.open_new_tab('file://%s' % tmp_html.name)",
            "def runCommand(self, edit, ask=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    all_lines_regions = self.view.split_by_newlines(sublime.Region(0, self.view.size()))\n    html_doc = []\n    patterns = {'HEADER': 'text.todo keyword.control.header.todo ', 'EMPTY': 'text.todo ', 'NOTE': 'text.todo notes.todo ', 'OPEN': 'text.todo meta.item.todo.pending ', 'DONE': 'text.todo meta.item.todo.completed ', 'CANCELLED': 'text.todo meta.item.todo.cancelled ', 'SEPARATOR': 'text.todo meta.punctuation.separator.todo ', 'ARCHIVE': 'text.todo meta.punctuation.archive.todo '}\n    for r in all_lines_regions:\n        i = self.view.scope_name(r.a)\n        if patterns['HEADER'] in i:\n            ht = '<span class=\"header\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif i == patterns['EMPTY']:\n            ht = '<span class=\"empty-line\">%s</span>' % self.view.substr(r)\n        elif patterns['NOTE'] in i:\n            scopes = self.extracting_scopes(self, r, i)\n            note = '<span class=\"note\">'\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'italic' in sn:\n                    note += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    note += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    note += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    note += cgi.escape(self.view.substr(s))\n            ht = note + '</span>'\n        elif patterns['OPEN'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            pending = '<span class=\"open\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    pending += '<span class=\"bullet-pending\">%s</span>' % self.view.substr(s)\n                elif 'meta.tag' in sn:\n                    pending += '<span class=\"tag\">%s</span>' % cgi.escape(self.view.substr(s))\n                elif 'tag.todo.today' in sn:\n                    pending += '<span class=\"tag-today\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.critical' in sn:\n                    pending += '<span class=\"tag-critical\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.high' in sn:\n                    pending += '<span class=\"tag-high\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.low' in sn:\n                    pending += '<span class=\"tag-low\">%s</span>' % self.view.substr(s)\n                elif 'italic' in sn:\n                    pending += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    pending += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    pending += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    pending += cgi.escape(self.view.substr(s))\n            ht = pending + '</span>'\n        elif patterns['DONE'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            done = '<span class=\"done\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    done += '<span class=\"bullet-done\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.completed' in sn:\n                    done += '<span class=\"tag-done\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    done += cgi.escape(self.view.substr(s))\n            ht = done + '</span>'\n        elif patterns['CANCELLED'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            cancelled = '<span class=\"cancelled\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    cancelled += '<span class=\"bullet-cancelled\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.cancelled' in sn:\n                    cancelled += '<span class=\"tag-cancelled\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    cancelled += cgi.escape(self.view.substr(s))\n            ht = cancelled + '</span>'\n        elif patterns['SEPARATOR'] in i:\n            ht = '<span class=\"sep\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif patterns['ARCHIVE'] in i:\n            ht = '<span class=\"sep-archive\">%s</span>' % cgi.escape(self.view.substr(r))\n        else:\n            sublime.error_message('Hey! you are not supposed to see this message.\\nPlease, report an issue in PlainTasks repository on GitHub.')\n        html_doc.append(ht)\n    title = os.path.basename(self.view.file_name()) if self.view.file_name() else 'Export'\n    html = self.produce_html_from_template(title, html_doc)\n    if ask:\n        window = sublime.active_window()\n        nv = window.new_file()\n        nv.set_syntax_file('Packages/HTML/HTML.tmLanguage')\n        nv.set_name(title + '.html')\n        nv.insert(edit, 0, html)\n        window.run_command('close_file')\n        return\n    tmp_html = tempfile.NamedTemporaryFile(delete=False, suffix='.html')\n    tmp_html.write(html.encode('utf-8'))\n    tmp_html.close()\n    webbrowser.open_new_tab('file://%s' % tmp_html.name)",
            "def runCommand(self, edit, ask=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    all_lines_regions = self.view.split_by_newlines(sublime.Region(0, self.view.size()))\n    html_doc = []\n    patterns = {'HEADER': 'text.todo keyword.control.header.todo ', 'EMPTY': 'text.todo ', 'NOTE': 'text.todo notes.todo ', 'OPEN': 'text.todo meta.item.todo.pending ', 'DONE': 'text.todo meta.item.todo.completed ', 'CANCELLED': 'text.todo meta.item.todo.cancelled ', 'SEPARATOR': 'text.todo meta.punctuation.separator.todo ', 'ARCHIVE': 'text.todo meta.punctuation.archive.todo '}\n    for r in all_lines_regions:\n        i = self.view.scope_name(r.a)\n        if patterns['HEADER'] in i:\n            ht = '<span class=\"header\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif i == patterns['EMPTY']:\n            ht = '<span class=\"empty-line\">%s</span>' % self.view.substr(r)\n        elif patterns['NOTE'] in i:\n            scopes = self.extracting_scopes(self, r, i)\n            note = '<span class=\"note\">'\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'italic' in sn:\n                    note += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    note += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    note += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    note += cgi.escape(self.view.substr(s))\n            ht = note + '</span>'\n        elif patterns['OPEN'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            pending = '<span class=\"open\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    pending += '<span class=\"bullet-pending\">%s</span>' % self.view.substr(s)\n                elif 'meta.tag' in sn:\n                    pending += '<span class=\"tag\">%s</span>' % cgi.escape(self.view.substr(s))\n                elif 'tag.todo.today' in sn:\n                    pending += '<span class=\"tag-today\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.critical' in sn:\n                    pending += '<span class=\"tag-critical\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.high' in sn:\n                    pending += '<span class=\"tag-high\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.low' in sn:\n                    pending += '<span class=\"tag-low\">%s</span>' % self.view.substr(s)\n                elif 'italic' in sn:\n                    pending += '<i>%s</i>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'bold' in sn:\n                    pending += '<b>%s</b>' % cgi.escape(self.view.substr(s).strip('_*'))\n                elif 'url' in sn:\n                    pending += '<a href=\"{0}\">{0}</a>'.format(cgi.escape(self.view.substr(s).strip('<>')))\n                else:\n                    pending += cgi.escape(self.view.substr(s))\n            ht = pending + '</span>'\n        elif patterns['DONE'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            done = '<span class=\"done\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    done += '<span class=\"bullet-done\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.completed' in sn:\n                    done += '<span class=\"tag-done\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    done += cgi.escape(self.view.substr(s))\n            ht = done + '</span>'\n        elif patterns['CANCELLED'] in i:\n            scopes = self.extracting_scopes(self, r)\n            indent = self.view.substr(sublime.Region(r.a, scopes[0].a)) if r.a != scopes[0].a else ''\n            cancelled = '<span class=\"cancelled\">%s' % indent\n            for s in scopes:\n                sn = self.view.scope_name(s.a)\n                if 'bullet' in sn:\n                    cancelled += '<span class=\"bullet-cancelled\">%s</span>' % self.view.substr(s)\n                elif 'tag.todo.cancelled' in sn:\n                    cancelled += '<span class=\"tag-cancelled\">%s</span>' % cgi.escape(self.view.substr(s))\n                else:\n                    cancelled += cgi.escape(self.view.substr(s))\n            ht = cancelled + '</span>'\n        elif patterns['SEPARATOR'] in i:\n            ht = '<span class=\"sep\">%s</span>' % cgi.escape(self.view.substr(r))\n        elif patterns['ARCHIVE'] in i:\n            ht = '<span class=\"sep-archive\">%s</span>' % cgi.escape(self.view.substr(r))\n        else:\n            sublime.error_message('Hey! you are not supposed to see this message.\\nPlease, report an issue in PlainTasks repository on GitHub.')\n        html_doc.append(ht)\n    title = os.path.basename(self.view.file_name()) if self.view.file_name() else 'Export'\n    html = self.produce_html_from_template(title, html_doc)\n    if ask:\n        window = sublime.active_window()\n        nv = window.new_file()\n        nv.set_syntax_file('Packages/HTML/HTML.tmLanguage')\n        nv.set_name(title + '.html')\n        nv.insert(edit, 0, html)\n        window.run_command('close_file')\n        return\n    tmp_html = tempfile.NamedTemporaryFile(delete=False, suffix='.html')\n    tmp_html.write(html.encode('utf-8'))\n    tmp_html.close()\n    webbrowser.open_new_tab('file://%s' % tmp_html.name)"
        ]
    },
    {
        "func_name": "produce_html_from_template",
        "original": "def produce_html_from_template(self, title, html_doc):\n    html_lines = []\n    ppath = sublime.packages_path()\n    tmtheme = os.path.join(ppath, self.view.settings().get('color_scheme').replace('Packages/', '', 1))\n    css = '\\n'.join(convert_tmtheme_to_css(tmtheme))\n    with io.open(os.path.join(ppath, 'PlainTasks/templates/template.html'), 'r', encoding='utf8') as template:\n        for line in template:\n            line = line.replace('$title', title).replace('$content', '\\n'.join(html_doc)).replace('$css', css).strip('\\n')\n            html_lines.append(line)\n    return u'\\n'.join(html_lines)",
        "mutated": [
            "def produce_html_from_template(self, title, html_doc):\n    if False:\n        i = 10\n    html_lines = []\n    ppath = sublime.packages_path()\n    tmtheme = os.path.join(ppath, self.view.settings().get('color_scheme').replace('Packages/', '', 1))\n    css = '\\n'.join(convert_tmtheme_to_css(tmtheme))\n    with io.open(os.path.join(ppath, 'PlainTasks/templates/template.html'), 'r', encoding='utf8') as template:\n        for line in template:\n            line = line.replace('$title', title).replace('$content', '\\n'.join(html_doc)).replace('$css', css).strip('\\n')\n            html_lines.append(line)\n    return u'\\n'.join(html_lines)",
            "def produce_html_from_template(self, title, html_doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    html_lines = []\n    ppath = sublime.packages_path()\n    tmtheme = os.path.join(ppath, self.view.settings().get('color_scheme').replace('Packages/', '', 1))\n    css = '\\n'.join(convert_tmtheme_to_css(tmtheme))\n    with io.open(os.path.join(ppath, 'PlainTasks/templates/template.html'), 'r', encoding='utf8') as template:\n        for line in template:\n            line = line.replace('$title', title).replace('$content', '\\n'.join(html_doc)).replace('$css', css).strip('\\n')\n            html_lines.append(line)\n    return u'\\n'.join(html_lines)",
            "def produce_html_from_template(self, title, html_doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    html_lines = []\n    ppath = sublime.packages_path()\n    tmtheme = os.path.join(ppath, self.view.settings().get('color_scheme').replace('Packages/', '', 1))\n    css = '\\n'.join(convert_tmtheme_to_css(tmtheme))\n    with io.open(os.path.join(ppath, 'PlainTasks/templates/template.html'), 'r', encoding='utf8') as template:\n        for line in template:\n            line = line.replace('$title', title).replace('$content', '\\n'.join(html_doc)).replace('$css', css).strip('\\n')\n            html_lines.append(line)\n    return u'\\n'.join(html_lines)",
            "def produce_html_from_template(self, title, html_doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    html_lines = []\n    ppath = sublime.packages_path()\n    tmtheme = os.path.join(ppath, self.view.settings().get('color_scheme').replace('Packages/', '', 1))\n    css = '\\n'.join(convert_tmtheme_to_css(tmtheme))\n    with io.open(os.path.join(ppath, 'PlainTasks/templates/template.html'), 'r', encoding='utf8') as template:\n        for line in template:\n            line = line.replace('$title', title).replace('$content', '\\n'.join(html_doc)).replace('$css', css).strip('\\n')\n            html_lines.append(line)\n    return u'\\n'.join(html_lines)",
            "def produce_html_from_template(self, title, html_doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    html_lines = []\n    ppath = sublime.packages_path()\n    tmtheme = os.path.join(ppath, self.view.settings().get('color_scheme').replace('Packages/', '', 1))\n    css = '\\n'.join(convert_tmtheme_to_css(tmtheme))\n    with io.open(os.path.join(ppath, 'PlainTasks/templates/template.html'), 'r', encoding='utf8') as template:\n        for line in template:\n            line = line.replace('$title', title).replace('$content', '\\n'.join(html_doc)).replace('$css', css).strip('\\n')\n            html_lines.append(line)\n    return u'\\n'.join(html_lines)"
        ]
    },
    {
        "func_name": "extracting_scopes",
        "original": "def extracting_scopes(self, edit, region, scope_name=''):\n    \"\"\"extract scope for each char in line wo dups, ineffective but it works?\"\"\"\n    scopes = []\n    for p in range(region.b - region.a):\n        p += region.a\n        sr = self.view.extract_scope(p)\n        if sr.a < region.a or sr.b - 1 > region.b:\n            if scopes and p == scopes[~0].b:\n                sr = sublime.Region(p, region.b)\n            else:\n                sr = sublime.Region(region.a, region.b)\n        if sr not in scopes:\n            scopes.append(sr)\n        elif scopes and self.view.scope_name(p) != self.view.scope_name(scopes[~0].a):\n            scopes.append(sublime.Region(p, region.b))\n        if scopes and sr.a < scopes[~0].b and (p - 1 == scopes[~0].b):\n            scopes.append(sublime.Region(scopes[~0].b, sr.b))\n    if scopes and scopes[~0].b > region.b:\n        scopes[~0] = sublime.Region(scopes[~0].a, region.b)\n    if len(scopes) > 1:\n        if scopes[0].intersects(scopes[1]):\n            scopes[0] = sublime.Region(scopes[0].a, scopes[1].a)\n        if scopes[~0].b < region.b or scopes[~0].a < region.a:\n            scopes.append(sublime.Region(scopes[~0].b, region.b))\n        new_scopes = scopes[:0:~0]\n        for (i, s) in enumerate(new_scopes):\n            if s.intersects(scopes[~(i + 1)]):\n                if scopes[~(i + 1)].b < s.b:\n                    scopes[~i] = sublime.Region(scopes[~(i + 1)].b, s.b)\n                    new_scopes[i] = scopes[~i]\n                else:\n                    scopes[~(i + 1)] = sublime.Region(scopes[~(i + 1)].a, s.a)\n                    if len(new_scopes) > i + 1:\n                        new_scopes[i + 1] = scopes[~(i + 1)]\n    return scopes",
        "mutated": [
            "def extracting_scopes(self, edit, region, scope_name=''):\n    if False:\n        i = 10\n    'extract scope for each char in line wo dups, ineffective but it works?'\n    scopes = []\n    for p in range(region.b - region.a):\n        p += region.a\n        sr = self.view.extract_scope(p)\n        if sr.a < region.a or sr.b - 1 > region.b:\n            if scopes and p == scopes[~0].b:\n                sr = sublime.Region(p, region.b)\n            else:\n                sr = sublime.Region(region.a, region.b)\n        if sr not in scopes:\n            scopes.append(sr)\n        elif scopes and self.view.scope_name(p) != self.view.scope_name(scopes[~0].a):\n            scopes.append(sublime.Region(p, region.b))\n        if scopes and sr.a < scopes[~0].b and (p - 1 == scopes[~0].b):\n            scopes.append(sublime.Region(scopes[~0].b, sr.b))\n    if scopes and scopes[~0].b > region.b:\n        scopes[~0] = sublime.Region(scopes[~0].a, region.b)\n    if len(scopes) > 1:\n        if scopes[0].intersects(scopes[1]):\n            scopes[0] = sublime.Region(scopes[0].a, scopes[1].a)\n        if scopes[~0].b < region.b or scopes[~0].a < region.a:\n            scopes.append(sublime.Region(scopes[~0].b, region.b))\n        new_scopes = scopes[:0:~0]\n        for (i, s) in enumerate(new_scopes):\n            if s.intersects(scopes[~(i + 1)]):\n                if scopes[~(i + 1)].b < s.b:\n                    scopes[~i] = sublime.Region(scopes[~(i + 1)].b, s.b)\n                    new_scopes[i] = scopes[~i]\n                else:\n                    scopes[~(i + 1)] = sublime.Region(scopes[~(i + 1)].a, s.a)\n                    if len(new_scopes) > i + 1:\n                        new_scopes[i + 1] = scopes[~(i + 1)]\n    return scopes",
            "def extracting_scopes(self, edit, region, scope_name=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'extract scope for each char in line wo dups, ineffective but it works?'\n    scopes = []\n    for p in range(region.b - region.a):\n        p += region.a\n        sr = self.view.extract_scope(p)\n        if sr.a < region.a or sr.b - 1 > region.b:\n            if scopes and p == scopes[~0].b:\n                sr = sublime.Region(p, region.b)\n            else:\n                sr = sublime.Region(region.a, region.b)\n        if sr not in scopes:\n            scopes.append(sr)\n        elif scopes and self.view.scope_name(p) != self.view.scope_name(scopes[~0].a):\n            scopes.append(sublime.Region(p, region.b))\n        if scopes and sr.a < scopes[~0].b and (p - 1 == scopes[~0].b):\n            scopes.append(sublime.Region(scopes[~0].b, sr.b))\n    if scopes and scopes[~0].b > region.b:\n        scopes[~0] = sublime.Region(scopes[~0].a, region.b)\n    if len(scopes) > 1:\n        if scopes[0].intersects(scopes[1]):\n            scopes[0] = sublime.Region(scopes[0].a, scopes[1].a)\n        if scopes[~0].b < region.b or scopes[~0].a < region.a:\n            scopes.append(sublime.Region(scopes[~0].b, region.b))\n        new_scopes = scopes[:0:~0]\n        for (i, s) in enumerate(new_scopes):\n            if s.intersects(scopes[~(i + 1)]):\n                if scopes[~(i + 1)].b < s.b:\n                    scopes[~i] = sublime.Region(scopes[~(i + 1)].b, s.b)\n                    new_scopes[i] = scopes[~i]\n                else:\n                    scopes[~(i + 1)] = sublime.Region(scopes[~(i + 1)].a, s.a)\n                    if len(new_scopes) > i + 1:\n                        new_scopes[i + 1] = scopes[~(i + 1)]\n    return scopes",
            "def extracting_scopes(self, edit, region, scope_name=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'extract scope for each char in line wo dups, ineffective but it works?'\n    scopes = []\n    for p in range(region.b - region.a):\n        p += region.a\n        sr = self.view.extract_scope(p)\n        if sr.a < region.a or sr.b - 1 > region.b:\n            if scopes and p == scopes[~0].b:\n                sr = sublime.Region(p, region.b)\n            else:\n                sr = sublime.Region(region.a, region.b)\n        if sr not in scopes:\n            scopes.append(sr)\n        elif scopes and self.view.scope_name(p) != self.view.scope_name(scopes[~0].a):\n            scopes.append(sublime.Region(p, region.b))\n        if scopes and sr.a < scopes[~0].b and (p - 1 == scopes[~0].b):\n            scopes.append(sublime.Region(scopes[~0].b, sr.b))\n    if scopes and scopes[~0].b > region.b:\n        scopes[~0] = sublime.Region(scopes[~0].a, region.b)\n    if len(scopes) > 1:\n        if scopes[0].intersects(scopes[1]):\n            scopes[0] = sublime.Region(scopes[0].a, scopes[1].a)\n        if scopes[~0].b < region.b or scopes[~0].a < region.a:\n            scopes.append(sublime.Region(scopes[~0].b, region.b))\n        new_scopes = scopes[:0:~0]\n        for (i, s) in enumerate(new_scopes):\n            if s.intersects(scopes[~(i + 1)]):\n                if scopes[~(i + 1)].b < s.b:\n                    scopes[~i] = sublime.Region(scopes[~(i + 1)].b, s.b)\n                    new_scopes[i] = scopes[~i]\n                else:\n                    scopes[~(i + 1)] = sublime.Region(scopes[~(i + 1)].a, s.a)\n                    if len(new_scopes) > i + 1:\n                        new_scopes[i + 1] = scopes[~(i + 1)]\n    return scopes",
            "def extracting_scopes(self, edit, region, scope_name=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'extract scope for each char in line wo dups, ineffective but it works?'\n    scopes = []\n    for p in range(region.b - region.a):\n        p += region.a\n        sr = self.view.extract_scope(p)\n        if sr.a < region.a or sr.b - 1 > region.b:\n            if scopes and p == scopes[~0].b:\n                sr = sublime.Region(p, region.b)\n            else:\n                sr = sublime.Region(region.a, region.b)\n        if sr not in scopes:\n            scopes.append(sr)\n        elif scopes and self.view.scope_name(p) != self.view.scope_name(scopes[~0].a):\n            scopes.append(sublime.Region(p, region.b))\n        if scopes and sr.a < scopes[~0].b and (p - 1 == scopes[~0].b):\n            scopes.append(sublime.Region(scopes[~0].b, sr.b))\n    if scopes and scopes[~0].b > region.b:\n        scopes[~0] = sublime.Region(scopes[~0].a, region.b)\n    if len(scopes) > 1:\n        if scopes[0].intersects(scopes[1]):\n            scopes[0] = sublime.Region(scopes[0].a, scopes[1].a)\n        if scopes[~0].b < region.b or scopes[~0].a < region.a:\n            scopes.append(sublime.Region(scopes[~0].b, region.b))\n        new_scopes = scopes[:0:~0]\n        for (i, s) in enumerate(new_scopes):\n            if s.intersects(scopes[~(i + 1)]):\n                if scopes[~(i + 1)].b < s.b:\n                    scopes[~i] = sublime.Region(scopes[~(i + 1)].b, s.b)\n                    new_scopes[i] = scopes[~i]\n                else:\n                    scopes[~(i + 1)] = sublime.Region(scopes[~(i + 1)].a, s.a)\n                    if len(new_scopes) > i + 1:\n                        new_scopes[i + 1] = scopes[~(i + 1)]\n    return scopes",
            "def extracting_scopes(self, edit, region, scope_name=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'extract scope for each char in line wo dups, ineffective but it works?'\n    scopes = []\n    for p in range(region.b - region.a):\n        p += region.a\n        sr = self.view.extract_scope(p)\n        if sr.a < region.a or sr.b - 1 > region.b:\n            if scopes and p == scopes[~0].b:\n                sr = sublime.Region(p, region.b)\n            else:\n                sr = sublime.Region(region.a, region.b)\n        if sr not in scopes:\n            scopes.append(sr)\n        elif scopes and self.view.scope_name(p) != self.view.scope_name(scopes[~0].a):\n            scopes.append(sublime.Region(p, region.b))\n        if scopes and sr.a < scopes[~0].b and (p - 1 == scopes[~0].b):\n            scopes.append(sublime.Region(scopes[~0].b, sr.b))\n    if scopes and scopes[~0].b > region.b:\n        scopes[~0] = sublime.Region(scopes[~0].a, region.b)\n    if len(scopes) > 1:\n        if scopes[0].intersects(scopes[1]):\n            scopes[0] = sublime.Region(scopes[0].a, scopes[1].a)\n        if scopes[~0].b < region.b or scopes[~0].a < region.a:\n            scopes.append(sublime.Region(scopes[~0].b, region.b))\n        new_scopes = scopes[:0:~0]\n        for (i, s) in enumerate(new_scopes):\n            if s.intersects(scopes[~(i + 1)]):\n                if scopes[~(i + 1)].b < s.b:\n                    scopes[~i] = sublime.Region(scopes[~(i + 1)].b, s.b)\n                    new_scopes[i] = scopes[~i]\n                else:\n                    scopes[~(i + 1)] = sublime.Region(scopes[~(i + 1)].a, s.a)\n                    if len(new_scopes) > i + 1:\n                        new_scopes[i + 1] = scopes[~(i + 1)]\n    return scopes"
        ]
    }
]