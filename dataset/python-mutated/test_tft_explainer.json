[
    {
        "func_name": "helper_get_input",
        "original": "def helper_get_input(self, series_option: str):\n    if series_option == 'univariate':\n        return (self.series_lin_pos, self.pc, self.fc)\n    elif series_option == 'multivariate':\n        return (self.series_mv1, self.pc, self.fc)\n    else:\n        return (self.series_multi, self.pc_multi, self.fc_multi)",
        "mutated": [
            "def helper_get_input(self, series_option: str):\n    if False:\n        i = 10\n    if series_option == 'univariate':\n        return (self.series_lin_pos, self.pc, self.fc)\n    elif series_option == 'multivariate':\n        return (self.series_mv1, self.pc, self.fc)\n    else:\n        return (self.series_multi, self.pc_multi, self.fc_multi)",
            "def helper_get_input(self, series_option: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if series_option == 'univariate':\n        return (self.series_lin_pos, self.pc, self.fc)\n    elif series_option == 'multivariate':\n        return (self.series_mv1, self.pc, self.fc)\n    else:\n        return (self.series_multi, self.pc_multi, self.fc_multi)",
            "def helper_get_input(self, series_option: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if series_option == 'univariate':\n        return (self.series_lin_pos, self.pc, self.fc)\n    elif series_option == 'multivariate':\n        return (self.series_mv1, self.pc, self.fc)\n    else:\n        return (self.series_multi, self.pc_multi, self.fc_multi)",
            "def helper_get_input(self, series_option: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if series_option == 'univariate':\n        return (self.series_lin_pos, self.pc, self.fc)\n    elif series_option == 'multivariate':\n        return (self.series_mv1, self.pc, self.fc)\n    else:\n        return (self.series_multi, self.pc_multi, self.fc_multi)",
            "def helper_get_input(self, series_option: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if series_option == 'univariate':\n        return (self.series_lin_pos, self.pc, self.fc)\n    elif series_option == 'multivariate':\n        return (self.series_mv1, self.pc, self.fc)\n    else:\n        return (self.series_multi, self.pc_multi, self.fc_multi)"
        ]
    },
    {
        "func_name": "helper_create_test_cases",
        "original": "def helper_create_test_cases(self, series_options: list):\n    covariates_options = [{}, {'past_covariates'}, {'future_covariates'}, {'past_covariates', 'future_covariates'}]\n    relative_index_options = [False, True]\n    use_encoders_options = [False, True]\n    return itertools.product(*[series_options, covariates_options, relative_index_options, use_encoders_options])",
        "mutated": [
            "def helper_create_test_cases(self, series_options: list):\n    if False:\n        i = 10\n    covariates_options = [{}, {'past_covariates'}, {'future_covariates'}, {'past_covariates', 'future_covariates'}]\n    relative_index_options = [False, True]\n    use_encoders_options = [False, True]\n    return itertools.product(*[series_options, covariates_options, relative_index_options, use_encoders_options])",
            "def helper_create_test_cases(self, series_options: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    covariates_options = [{}, {'past_covariates'}, {'future_covariates'}, {'past_covariates', 'future_covariates'}]\n    relative_index_options = [False, True]\n    use_encoders_options = [False, True]\n    return itertools.product(*[series_options, covariates_options, relative_index_options, use_encoders_options])",
            "def helper_create_test_cases(self, series_options: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    covariates_options = [{}, {'past_covariates'}, {'future_covariates'}, {'past_covariates', 'future_covariates'}]\n    relative_index_options = [False, True]\n    use_encoders_options = [False, True]\n    return itertools.product(*[series_options, covariates_options, relative_index_options, use_encoders_options])",
            "def helper_create_test_cases(self, series_options: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    covariates_options = [{}, {'past_covariates'}, {'future_covariates'}, {'past_covariates', 'future_covariates'}]\n    relative_index_options = [False, True]\n    use_encoders_options = [False, True]\n    return itertools.product(*[series_options, covariates_options, relative_index_options, use_encoders_options])",
            "def helper_create_test_cases(self, series_options: list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    covariates_options = [{}, {'past_covariates'}, {'future_covariates'}, {'past_covariates', 'future_covariates'}]\n    relative_index_options = [False, True]\n    use_encoders_options = [False, True]\n    return itertools.product(*[series_options, covariates_options, relative_index_options, use_encoders_options])"
        ]
    },
    {
        "func_name": "test_explainer_single_univariate_multivariate_series",
        "original": "def test_explainer_single_univariate_multivariate_series(self):\n    \"\"\"Test TFTExplainer with single univariate and multivariate series and a combination of\n            encoders, covariates, and addition of relative index.\"\"\"\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['univariate', 'multivariate']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series.n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        explainer = TFTExplainer(model)\n        explainer2 = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert explainer.background_series == explainer2.background_series\n        assert explainer.background_past_covariates == explainer2.background_past_covariates\n        assert explainer.background_future_covariates == explainer2.background_future_covariates\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series[0] == series\n        if use_pc:\n            assert explainer.background_past_covariates[0] == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates[0] == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, pd.DataFrame) for imp in imps])\n        assert all([imp.squeeze().sum() == pytest.approx(100.0, rel=0.2) for imp in imps])\n        assert all([len(imp.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected])])\n        attention = result.get_attention()\n        assert isinstance(attention, TimeSeries)\n        (icl, ocl) = (5, 2)\n        freq = series.freq\n        assert len(attention) == icl + ocl\n        assert attention.start_time() == series.end_time() - (icl - 1) * freq\n        assert attention.end_time() == series.end_time() + ocl * freq\n        assert attention.n_components == ocl",
        "mutated": [
            "def test_explainer_single_univariate_multivariate_series(self):\n    if False:\n        i = 10\n    'Test TFTExplainer with single univariate and multivariate series and a combination of\\n            encoders, covariates, and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['univariate', 'multivariate']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series.n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        explainer = TFTExplainer(model)\n        explainer2 = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert explainer.background_series == explainer2.background_series\n        assert explainer.background_past_covariates == explainer2.background_past_covariates\n        assert explainer.background_future_covariates == explainer2.background_future_covariates\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series[0] == series\n        if use_pc:\n            assert explainer.background_past_covariates[0] == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates[0] == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, pd.DataFrame) for imp in imps])\n        assert all([imp.squeeze().sum() == pytest.approx(100.0, rel=0.2) for imp in imps])\n        assert all([len(imp.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected])])\n        attention = result.get_attention()\n        assert isinstance(attention, TimeSeries)\n        (icl, ocl) = (5, 2)\n        freq = series.freq\n        assert len(attention) == icl + ocl\n        assert attention.start_time() == series.end_time() - (icl - 1) * freq\n        assert attention.end_time() == series.end_time() + ocl * freq\n        assert attention.n_components == ocl",
            "def test_explainer_single_univariate_multivariate_series(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test TFTExplainer with single univariate and multivariate series and a combination of\\n            encoders, covariates, and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['univariate', 'multivariate']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series.n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        explainer = TFTExplainer(model)\n        explainer2 = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert explainer.background_series == explainer2.background_series\n        assert explainer.background_past_covariates == explainer2.background_past_covariates\n        assert explainer.background_future_covariates == explainer2.background_future_covariates\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series[0] == series\n        if use_pc:\n            assert explainer.background_past_covariates[0] == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates[0] == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, pd.DataFrame) for imp in imps])\n        assert all([imp.squeeze().sum() == pytest.approx(100.0, rel=0.2) for imp in imps])\n        assert all([len(imp.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected])])\n        attention = result.get_attention()\n        assert isinstance(attention, TimeSeries)\n        (icl, ocl) = (5, 2)\n        freq = series.freq\n        assert len(attention) == icl + ocl\n        assert attention.start_time() == series.end_time() - (icl - 1) * freq\n        assert attention.end_time() == series.end_time() + ocl * freq\n        assert attention.n_components == ocl",
            "def test_explainer_single_univariate_multivariate_series(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test TFTExplainer with single univariate and multivariate series and a combination of\\n            encoders, covariates, and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['univariate', 'multivariate']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series.n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        explainer = TFTExplainer(model)\n        explainer2 = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert explainer.background_series == explainer2.background_series\n        assert explainer.background_past_covariates == explainer2.background_past_covariates\n        assert explainer.background_future_covariates == explainer2.background_future_covariates\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series[0] == series\n        if use_pc:\n            assert explainer.background_past_covariates[0] == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates[0] == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, pd.DataFrame) for imp in imps])\n        assert all([imp.squeeze().sum() == pytest.approx(100.0, rel=0.2) for imp in imps])\n        assert all([len(imp.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected])])\n        attention = result.get_attention()\n        assert isinstance(attention, TimeSeries)\n        (icl, ocl) = (5, 2)\n        freq = series.freq\n        assert len(attention) == icl + ocl\n        assert attention.start_time() == series.end_time() - (icl - 1) * freq\n        assert attention.end_time() == series.end_time() + ocl * freq\n        assert attention.n_components == ocl",
            "def test_explainer_single_univariate_multivariate_series(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test TFTExplainer with single univariate and multivariate series and a combination of\\n            encoders, covariates, and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['univariate', 'multivariate']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series.n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        explainer = TFTExplainer(model)\n        explainer2 = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert explainer.background_series == explainer2.background_series\n        assert explainer.background_past_covariates == explainer2.background_past_covariates\n        assert explainer.background_future_covariates == explainer2.background_future_covariates\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series[0] == series\n        if use_pc:\n            assert explainer.background_past_covariates[0] == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates[0] == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, pd.DataFrame) for imp in imps])\n        assert all([imp.squeeze().sum() == pytest.approx(100.0, rel=0.2) for imp in imps])\n        assert all([len(imp.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected])])\n        attention = result.get_attention()\n        assert isinstance(attention, TimeSeries)\n        (icl, ocl) = (5, 2)\n        freq = series.freq\n        assert len(attention) == icl + ocl\n        assert attention.start_time() == series.end_time() - (icl - 1) * freq\n        assert attention.end_time() == series.end_time() + ocl * freq\n        assert attention.n_components == ocl",
            "def test_explainer_single_univariate_multivariate_series(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test TFTExplainer with single univariate and multivariate series and a combination of\\n            encoders, covariates, and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['univariate', 'multivariate']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series.n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        explainer = TFTExplainer(model)\n        explainer2 = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert explainer.background_series == explainer2.background_series\n        assert explainer.background_past_covariates == explainer2.background_past_covariates\n        assert explainer.background_future_covariates == explainer2.background_future_covariates\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series[0] == series\n        if use_pc:\n            assert explainer.background_past_covariates[0] == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates[0] == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, pd.DataFrame) for imp in imps])\n        assert all([imp.squeeze().sum() == pytest.approx(100.0, rel=0.2) for imp in imps])\n        assert all([len(imp.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected])])\n        attention = result.get_attention()\n        assert isinstance(attention, TimeSeries)\n        (icl, ocl) = (5, 2)\n        freq = series.freq\n        assert len(attention) == icl + ocl\n        assert attention.start_time() == series.end_time() - (icl - 1) * freq\n        assert attention.end_time() == series.end_time() + ocl * freq\n        assert attention.n_components == ocl"
        ]
    },
    {
        "func_name": "test_explainer_multiple_multivariate_series",
        "original": "def test_explainer_multiple_multivariate_series(self):\n    \"\"\"Test TFTExplainer with multiple multivaraites series and a combination of encoders, covariates,\n            and addition of relative index.\"\"\"\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['multiple']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series[0].n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        with pytest.raises(ValueError):\n            explainer = TFTExplainer(model)\n        explainer = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series, series\n        if use_pc:\n            assert explainer.background_past_covariates == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, list) for imp in imps])\n        assert all([len(imp) == len(series) for imp in imps])\n        assert all([isinstance(imp_, pd.DataFrame) for imp in imps for imp_ in imp])\n        assert all([imp_.squeeze().sum() == pytest.approx(100.0, abs=0.11) for imp in imps for imp_ in imp])\n        assert all([len(imp_.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected]) for imp_ in imp])\n        attention = result.get_attention()\n        assert isinstance(attention, list)\n        assert len(attention) == len(series)\n        assert all([isinstance(att, TimeSeries) for att in attention])\n        (icl, ocl) = (5, 2)\n        freq = series[0].freq\n        assert all([len(att) == icl + ocl for att in attention])\n        assert all([att.start_time() == series_.end_time() - (icl - 1) * freq for (att, series_) in zip(attention, series)])\n        assert all([att.end_time() == series_.end_time() + ocl * freq for (att, series_) in zip(attention, series)])\n        assert all([att.n_components == ocl for att in attention])",
        "mutated": [
            "def test_explainer_multiple_multivariate_series(self):\n    if False:\n        i = 10\n    'Test TFTExplainer with multiple multivaraites series and a combination of encoders, covariates,\\n            and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['multiple']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series[0].n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        with pytest.raises(ValueError):\n            explainer = TFTExplainer(model)\n        explainer = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series, series\n        if use_pc:\n            assert explainer.background_past_covariates == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, list) for imp in imps])\n        assert all([len(imp) == len(series) for imp in imps])\n        assert all([isinstance(imp_, pd.DataFrame) for imp in imps for imp_ in imp])\n        assert all([imp_.squeeze().sum() == pytest.approx(100.0, abs=0.11) for imp in imps for imp_ in imp])\n        assert all([len(imp_.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected]) for imp_ in imp])\n        attention = result.get_attention()\n        assert isinstance(attention, list)\n        assert len(attention) == len(series)\n        assert all([isinstance(att, TimeSeries) for att in attention])\n        (icl, ocl) = (5, 2)\n        freq = series[0].freq\n        assert all([len(att) == icl + ocl for att in attention])\n        assert all([att.start_time() == series_.end_time() - (icl - 1) * freq for (att, series_) in zip(attention, series)])\n        assert all([att.end_time() == series_.end_time() + ocl * freq for (att, series_) in zip(attention, series)])\n        assert all([att.n_components == ocl for att in attention])",
            "def test_explainer_multiple_multivariate_series(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test TFTExplainer with multiple multivaraites series and a combination of encoders, covariates,\\n            and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['multiple']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series[0].n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        with pytest.raises(ValueError):\n            explainer = TFTExplainer(model)\n        explainer = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series, series\n        if use_pc:\n            assert explainer.background_past_covariates == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, list) for imp in imps])\n        assert all([len(imp) == len(series) for imp in imps])\n        assert all([isinstance(imp_, pd.DataFrame) for imp in imps for imp_ in imp])\n        assert all([imp_.squeeze().sum() == pytest.approx(100.0, abs=0.11) for imp in imps for imp_ in imp])\n        assert all([len(imp_.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected]) for imp_ in imp])\n        attention = result.get_attention()\n        assert isinstance(attention, list)\n        assert len(attention) == len(series)\n        assert all([isinstance(att, TimeSeries) for att in attention])\n        (icl, ocl) = (5, 2)\n        freq = series[0].freq\n        assert all([len(att) == icl + ocl for att in attention])\n        assert all([att.start_time() == series_.end_time() - (icl - 1) * freq for (att, series_) in zip(attention, series)])\n        assert all([att.end_time() == series_.end_time() + ocl * freq for (att, series_) in zip(attention, series)])\n        assert all([att.n_components == ocl for att in attention])",
            "def test_explainer_multiple_multivariate_series(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test TFTExplainer with multiple multivaraites series and a combination of encoders, covariates,\\n            and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['multiple']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series[0].n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        with pytest.raises(ValueError):\n            explainer = TFTExplainer(model)\n        explainer = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series, series\n        if use_pc:\n            assert explainer.background_past_covariates == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, list) for imp in imps])\n        assert all([len(imp) == len(series) for imp in imps])\n        assert all([isinstance(imp_, pd.DataFrame) for imp in imps for imp_ in imp])\n        assert all([imp_.squeeze().sum() == pytest.approx(100.0, abs=0.11) for imp in imps for imp_ in imp])\n        assert all([len(imp_.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected]) for imp_ in imp])\n        attention = result.get_attention()\n        assert isinstance(attention, list)\n        assert len(attention) == len(series)\n        assert all([isinstance(att, TimeSeries) for att in attention])\n        (icl, ocl) = (5, 2)\n        freq = series[0].freq\n        assert all([len(att) == icl + ocl for att in attention])\n        assert all([att.start_time() == series_.end_time() - (icl - 1) * freq for (att, series_) in zip(attention, series)])\n        assert all([att.end_time() == series_.end_time() + ocl * freq for (att, series_) in zip(attention, series)])\n        assert all([att.n_components == ocl for att in attention])",
            "def test_explainer_multiple_multivariate_series(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test TFTExplainer with multiple multivaraites series and a combination of encoders, covariates,\\n            and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['multiple']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series[0].n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        with pytest.raises(ValueError):\n            explainer = TFTExplainer(model)\n        explainer = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series, series\n        if use_pc:\n            assert explainer.background_past_covariates == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, list) for imp in imps])\n        assert all([len(imp) == len(series) for imp in imps])\n        assert all([isinstance(imp_, pd.DataFrame) for imp in imps for imp_ in imp])\n        assert all([imp_.squeeze().sum() == pytest.approx(100.0, abs=0.11) for imp in imps for imp_ in imp])\n        assert all([len(imp_.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected]) for imp_ in imp])\n        attention = result.get_attention()\n        assert isinstance(attention, list)\n        assert len(attention) == len(series)\n        assert all([isinstance(att, TimeSeries) for att in attention])\n        (icl, ocl) = (5, 2)\n        freq = series[0].freq\n        assert all([len(att) == icl + ocl for att in attention])\n        assert all([att.start_time() == series_.end_time() - (icl - 1) * freq for (att, series_) in zip(attention, series)])\n        assert all([att.end_time() == series_.end_time() + ocl * freq for (att, series_) in zip(attention, series)])\n        assert all([att.n_components == ocl for att in attention])",
            "def test_explainer_multiple_multivariate_series(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test TFTExplainer with multiple multivaraites series and a combination of encoders, covariates,\\n            and addition of relative index.'\n    series_option: str\n    cov_option: set\n    add_relative_idx: bool\n    use_encoders: bool\n    series_options = ['multiple']\n    test_cases = self.helper_create_test_cases(series_options)\n    for (series_option, cov_option, add_relative_idx, use_encoders) in test_cases:\n        (series, pc, fc) = self.helper_get_input(series_option)\n        cov_test_case = dict()\n        (use_pc, use_fc) = (False, False)\n        if 'past_covariates' in cov_option:\n            cov_test_case['past_covariates'] = pc\n            use_pc = True\n        if 'future_covariates' in cov_option:\n            cov_test_case['future_covariates'] = fc\n            use_fc = True\n        n_target_expected = series[0].n_components\n        n_pc_expected = 1 if 'past_covariates' in cov_test_case else 0\n        n_fc_expected = 1 if 'future_covariates' in cov_test_case else 0\n        n_sc_expected = 2\n        n_enc_expected = n_pc_expected + n_fc_expected + n_target_expected + (4 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        n_dec_expected = n_fc_expected + (2 if use_encoders else 0) + (1 if add_relative_idx else 0)\n        model = self.helper_create_model(use_encoders=use_encoders, add_relative_idx=add_relative_idx)\n        if not add_relative_idx and 'future_covariates' not in cov_test_case and (not use_encoders):\n            with pytest.raises(ValueError):\n                model.fit(series=series, **cov_test_case)\n            continue\n        model.fit(series=series, **cov_test_case)\n        with pytest.raises(ValueError):\n            explainer = TFTExplainer(model)\n        explainer = TFTExplainer(model, background_series=series, background_past_covariates=pc if use_pc else None, background_future_covariates=fc if use_fc else None)\n        assert hasattr(explainer, 'model')\n        assert explainer.background_series, series\n        if use_pc:\n            assert explainer.background_past_covariates == pc\n            assert explainer.background_past_covariates[0].n_components == n_pc_expected\n        else:\n            assert explainer.background_past_covariates is None\n        if use_fc:\n            assert explainer.background_future_covariates == fc\n            assert explainer.background_future_covariates[0].n_components == n_fc_expected\n        else:\n            assert explainer.background_future_covariates is None\n        result = explainer.explain()\n        assert isinstance(result, TFTExplainabilityResult)\n        enc_imp = result.get_encoder_importance()\n        dec_imp = result.get_decoder_importance()\n        stc_imp = result.get_static_covariates_importance()\n        imps = [enc_imp, dec_imp, stc_imp]\n        assert all([isinstance(imp, list) for imp in imps])\n        assert all([len(imp) == len(series) for imp in imps])\n        assert all([isinstance(imp_, pd.DataFrame) for imp in imps for imp_ in imp])\n        assert all([imp_.squeeze().sum() == pytest.approx(100.0, abs=0.11) for imp in imps for imp_ in imp])\n        assert all([len(imp_.columns) == n for (imp, n) in zip(imps, [n_enc_expected, n_dec_expected, n_sc_expected]) for imp_ in imp])\n        attention = result.get_attention()\n        assert isinstance(attention, list)\n        assert len(attention) == len(series)\n        assert all([isinstance(att, TimeSeries) for att in attention])\n        (icl, ocl) = (5, 2)\n        freq = series[0].freq\n        assert all([len(att) == icl + ocl for att in attention])\n        assert all([att.start_time() == series_.end_time() - (icl - 1) * freq for (att, series_) in zip(attention, series)])\n        assert all([att.end_time() == series_.end_time() + ocl * freq for (att, series_) in zip(attention, series)])\n        assert all([att.n_components == ocl for att in attention])"
        ]
    },
    {
        "func_name": "test_variable_selection_explanation",
        "original": "def test_variable_selection_explanation(self):\n    \"\"\"Test variable selection (feature importance) explanation results and plotting.\"\"\"\n    model = self.helper_create_model(use_encoders=True, add_relative_idx=True)\n    (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n    model.fit(series, past_covariates=pc, future_covariates=fc)\n    explainer = TFTExplainer(model)\n    results = explainer.explain()\n    imps = results.get_feature_importances()\n    enc_imp = results.get_encoder_importance()\n    dec_imp = results.get_decoder_importance()\n    stc_imp = results.get_static_covariates_importance()\n    imps_direct = [enc_imp, dec_imp, stc_imp]\n    imp_names = ['encoder_importance', 'decoder_importance', 'static_covariates_importance']\n    assert list(imps.keys()) == imp_names\n    for (imp, imp_name) in zip(imps_direct, imp_names):\n        assert imps[imp_name].equals(imp)\n    enc_expected = pd.DataFrame({'linear_target': 1.6, 'sine_target': 3.0, 'add_relative_index_futcov': 3.0, 'constant_pastcov': 4.0, 'darts_enc_fc_cyc_month_sin_futcov': 6.2, 'darts_enc_pc_cyc_month_sin_pastcov': 8.6, 'darts_enc_pc_cyc_month_cos_pastcov': 20.0, 'constant_futcov': 20.2, 'darts_enc_fc_cyc_month_cos_futcov': 33.3}, index=[0])\n    assert ((enc_imp.round(decimals=1) - enc_expected).abs() <= 3).all().all()\n    dec_expected = pd.DataFrame({'darts_enc_fc_cyc_month_cos_futcov': 4.3, 'darts_enc_fc_cyc_month_sin_futcov': 17.1, 'constant_futcov': 19.3, 'add_relative_index_futcov': 59.3}, index=[0])\n    assert ((dec_imp.round(decimals=1) - dec_expected).abs() <= 0.6).all().all()\n    stc_expected = pd.DataFrame({'num_statcov': 11.9, 'cat_statcov': 88.1}, index=[0])\n    assert ((stc_imp.round(decimals=1) - stc_expected).abs() <= 0.1).all().all()\n    with patch('matplotlib.pyplot.show') as _:\n        _ = explainer.plot_variable_selection(results)",
        "mutated": [
            "def test_variable_selection_explanation(self):\n    if False:\n        i = 10\n    'Test variable selection (feature importance) explanation results and plotting.'\n    model = self.helper_create_model(use_encoders=True, add_relative_idx=True)\n    (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n    model.fit(series, past_covariates=pc, future_covariates=fc)\n    explainer = TFTExplainer(model)\n    results = explainer.explain()\n    imps = results.get_feature_importances()\n    enc_imp = results.get_encoder_importance()\n    dec_imp = results.get_decoder_importance()\n    stc_imp = results.get_static_covariates_importance()\n    imps_direct = [enc_imp, dec_imp, stc_imp]\n    imp_names = ['encoder_importance', 'decoder_importance', 'static_covariates_importance']\n    assert list(imps.keys()) == imp_names\n    for (imp, imp_name) in zip(imps_direct, imp_names):\n        assert imps[imp_name].equals(imp)\n    enc_expected = pd.DataFrame({'linear_target': 1.6, 'sine_target': 3.0, 'add_relative_index_futcov': 3.0, 'constant_pastcov': 4.0, 'darts_enc_fc_cyc_month_sin_futcov': 6.2, 'darts_enc_pc_cyc_month_sin_pastcov': 8.6, 'darts_enc_pc_cyc_month_cos_pastcov': 20.0, 'constant_futcov': 20.2, 'darts_enc_fc_cyc_month_cos_futcov': 33.3}, index=[0])\n    assert ((enc_imp.round(decimals=1) - enc_expected).abs() <= 3).all().all()\n    dec_expected = pd.DataFrame({'darts_enc_fc_cyc_month_cos_futcov': 4.3, 'darts_enc_fc_cyc_month_sin_futcov': 17.1, 'constant_futcov': 19.3, 'add_relative_index_futcov': 59.3}, index=[0])\n    assert ((dec_imp.round(decimals=1) - dec_expected).abs() <= 0.6).all().all()\n    stc_expected = pd.DataFrame({'num_statcov': 11.9, 'cat_statcov': 88.1}, index=[0])\n    assert ((stc_imp.round(decimals=1) - stc_expected).abs() <= 0.1).all().all()\n    with patch('matplotlib.pyplot.show') as _:\n        _ = explainer.plot_variable_selection(results)",
            "def test_variable_selection_explanation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test variable selection (feature importance) explanation results and plotting.'\n    model = self.helper_create_model(use_encoders=True, add_relative_idx=True)\n    (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n    model.fit(series, past_covariates=pc, future_covariates=fc)\n    explainer = TFTExplainer(model)\n    results = explainer.explain()\n    imps = results.get_feature_importances()\n    enc_imp = results.get_encoder_importance()\n    dec_imp = results.get_decoder_importance()\n    stc_imp = results.get_static_covariates_importance()\n    imps_direct = [enc_imp, dec_imp, stc_imp]\n    imp_names = ['encoder_importance', 'decoder_importance', 'static_covariates_importance']\n    assert list(imps.keys()) == imp_names\n    for (imp, imp_name) in zip(imps_direct, imp_names):\n        assert imps[imp_name].equals(imp)\n    enc_expected = pd.DataFrame({'linear_target': 1.6, 'sine_target': 3.0, 'add_relative_index_futcov': 3.0, 'constant_pastcov': 4.0, 'darts_enc_fc_cyc_month_sin_futcov': 6.2, 'darts_enc_pc_cyc_month_sin_pastcov': 8.6, 'darts_enc_pc_cyc_month_cos_pastcov': 20.0, 'constant_futcov': 20.2, 'darts_enc_fc_cyc_month_cos_futcov': 33.3}, index=[0])\n    assert ((enc_imp.round(decimals=1) - enc_expected).abs() <= 3).all().all()\n    dec_expected = pd.DataFrame({'darts_enc_fc_cyc_month_cos_futcov': 4.3, 'darts_enc_fc_cyc_month_sin_futcov': 17.1, 'constant_futcov': 19.3, 'add_relative_index_futcov': 59.3}, index=[0])\n    assert ((dec_imp.round(decimals=1) - dec_expected).abs() <= 0.6).all().all()\n    stc_expected = pd.DataFrame({'num_statcov': 11.9, 'cat_statcov': 88.1}, index=[0])\n    assert ((stc_imp.round(decimals=1) - stc_expected).abs() <= 0.1).all().all()\n    with patch('matplotlib.pyplot.show') as _:\n        _ = explainer.plot_variable_selection(results)",
            "def test_variable_selection_explanation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test variable selection (feature importance) explanation results and plotting.'\n    model = self.helper_create_model(use_encoders=True, add_relative_idx=True)\n    (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n    model.fit(series, past_covariates=pc, future_covariates=fc)\n    explainer = TFTExplainer(model)\n    results = explainer.explain()\n    imps = results.get_feature_importances()\n    enc_imp = results.get_encoder_importance()\n    dec_imp = results.get_decoder_importance()\n    stc_imp = results.get_static_covariates_importance()\n    imps_direct = [enc_imp, dec_imp, stc_imp]\n    imp_names = ['encoder_importance', 'decoder_importance', 'static_covariates_importance']\n    assert list(imps.keys()) == imp_names\n    for (imp, imp_name) in zip(imps_direct, imp_names):\n        assert imps[imp_name].equals(imp)\n    enc_expected = pd.DataFrame({'linear_target': 1.6, 'sine_target': 3.0, 'add_relative_index_futcov': 3.0, 'constant_pastcov': 4.0, 'darts_enc_fc_cyc_month_sin_futcov': 6.2, 'darts_enc_pc_cyc_month_sin_pastcov': 8.6, 'darts_enc_pc_cyc_month_cos_pastcov': 20.0, 'constant_futcov': 20.2, 'darts_enc_fc_cyc_month_cos_futcov': 33.3}, index=[0])\n    assert ((enc_imp.round(decimals=1) - enc_expected).abs() <= 3).all().all()\n    dec_expected = pd.DataFrame({'darts_enc_fc_cyc_month_cos_futcov': 4.3, 'darts_enc_fc_cyc_month_sin_futcov': 17.1, 'constant_futcov': 19.3, 'add_relative_index_futcov': 59.3}, index=[0])\n    assert ((dec_imp.round(decimals=1) - dec_expected).abs() <= 0.6).all().all()\n    stc_expected = pd.DataFrame({'num_statcov': 11.9, 'cat_statcov': 88.1}, index=[0])\n    assert ((stc_imp.round(decimals=1) - stc_expected).abs() <= 0.1).all().all()\n    with patch('matplotlib.pyplot.show') as _:\n        _ = explainer.plot_variable_selection(results)",
            "def test_variable_selection_explanation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test variable selection (feature importance) explanation results and plotting.'\n    model = self.helper_create_model(use_encoders=True, add_relative_idx=True)\n    (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n    model.fit(series, past_covariates=pc, future_covariates=fc)\n    explainer = TFTExplainer(model)\n    results = explainer.explain()\n    imps = results.get_feature_importances()\n    enc_imp = results.get_encoder_importance()\n    dec_imp = results.get_decoder_importance()\n    stc_imp = results.get_static_covariates_importance()\n    imps_direct = [enc_imp, dec_imp, stc_imp]\n    imp_names = ['encoder_importance', 'decoder_importance', 'static_covariates_importance']\n    assert list(imps.keys()) == imp_names\n    for (imp, imp_name) in zip(imps_direct, imp_names):\n        assert imps[imp_name].equals(imp)\n    enc_expected = pd.DataFrame({'linear_target': 1.6, 'sine_target': 3.0, 'add_relative_index_futcov': 3.0, 'constant_pastcov': 4.0, 'darts_enc_fc_cyc_month_sin_futcov': 6.2, 'darts_enc_pc_cyc_month_sin_pastcov': 8.6, 'darts_enc_pc_cyc_month_cos_pastcov': 20.0, 'constant_futcov': 20.2, 'darts_enc_fc_cyc_month_cos_futcov': 33.3}, index=[0])\n    assert ((enc_imp.round(decimals=1) - enc_expected).abs() <= 3).all().all()\n    dec_expected = pd.DataFrame({'darts_enc_fc_cyc_month_cos_futcov': 4.3, 'darts_enc_fc_cyc_month_sin_futcov': 17.1, 'constant_futcov': 19.3, 'add_relative_index_futcov': 59.3}, index=[0])\n    assert ((dec_imp.round(decimals=1) - dec_expected).abs() <= 0.6).all().all()\n    stc_expected = pd.DataFrame({'num_statcov': 11.9, 'cat_statcov': 88.1}, index=[0])\n    assert ((stc_imp.round(decimals=1) - stc_expected).abs() <= 0.1).all().all()\n    with patch('matplotlib.pyplot.show') as _:\n        _ = explainer.plot_variable_selection(results)",
            "def test_variable_selection_explanation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test variable selection (feature importance) explanation results and plotting.'\n    model = self.helper_create_model(use_encoders=True, add_relative_idx=True)\n    (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n    model.fit(series, past_covariates=pc, future_covariates=fc)\n    explainer = TFTExplainer(model)\n    results = explainer.explain()\n    imps = results.get_feature_importances()\n    enc_imp = results.get_encoder_importance()\n    dec_imp = results.get_decoder_importance()\n    stc_imp = results.get_static_covariates_importance()\n    imps_direct = [enc_imp, dec_imp, stc_imp]\n    imp_names = ['encoder_importance', 'decoder_importance', 'static_covariates_importance']\n    assert list(imps.keys()) == imp_names\n    for (imp, imp_name) in zip(imps_direct, imp_names):\n        assert imps[imp_name].equals(imp)\n    enc_expected = pd.DataFrame({'linear_target': 1.6, 'sine_target': 3.0, 'add_relative_index_futcov': 3.0, 'constant_pastcov': 4.0, 'darts_enc_fc_cyc_month_sin_futcov': 6.2, 'darts_enc_pc_cyc_month_sin_pastcov': 8.6, 'darts_enc_pc_cyc_month_cos_pastcov': 20.0, 'constant_futcov': 20.2, 'darts_enc_fc_cyc_month_cos_futcov': 33.3}, index=[0])\n    assert ((enc_imp.round(decimals=1) - enc_expected).abs() <= 3).all().all()\n    dec_expected = pd.DataFrame({'darts_enc_fc_cyc_month_cos_futcov': 4.3, 'darts_enc_fc_cyc_month_sin_futcov': 17.1, 'constant_futcov': 19.3, 'add_relative_index_futcov': 59.3}, index=[0])\n    assert ((dec_imp.round(decimals=1) - dec_expected).abs() <= 0.6).all().all()\n    stc_expected = pd.DataFrame({'num_statcov': 11.9, 'cat_statcov': 88.1}, index=[0])\n    assert ((stc_imp.round(decimals=1) - stc_expected).abs() <= 0.1).all().all()\n    with patch('matplotlib.pyplot.show') as _:\n        _ = explainer.plot_variable_selection(results)"
        ]
    },
    {
        "func_name": "test_attention_explanation",
        "original": "def test_attention_explanation(self):\n    \"\"\"Test attention (feature importance) explanation results and plotting.\"\"\"\n    att_exp_past_att = np.array([[1.1, 1.1], [0.7, 0.7], [0.6, 0.5], [0.7, 0.5], [0.8, 0.5], [0.0, 0.7], [0.0, 0.0]])\n    att_exp_full_att = np.array([[0.9, 1.0], [0.6, 0.6], [0.3, 0.4], [0.3, 0.4], [0.4, 0.4], [0.6, 0.5], [0.9, 0.8]])\n    for (full_attention, att_exp) in zip([False, True], [att_exp_past_att, att_exp_full_att]):\n        model = self.helper_create_model(use_encoders=True, add_relative_idx=True, full_attention=full_attention)\n        (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n        model.fit(series, past_covariates=pc, future_covariates=fc)\n        explainer = TFTExplainer(model)\n        results = explainer.explain()\n        att = results.get_attention()\n        assert np.all(np.abs(np.round(att.values(), decimals=1) - att_exp) <= 0.2)\n        assert att.columns.tolist() == ['horizon 1', 'horizon 2']\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='time')\n            plt.close()",
        "mutated": [
            "def test_attention_explanation(self):\n    if False:\n        i = 10\n    'Test attention (feature importance) explanation results and plotting.'\n    att_exp_past_att = np.array([[1.1, 1.1], [0.7, 0.7], [0.6, 0.5], [0.7, 0.5], [0.8, 0.5], [0.0, 0.7], [0.0, 0.0]])\n    att_exp_full_att = np.array([[0.9, 1.0], [0.6, 0.6], [0.3, 0.4], [0.3, 0.4], [0.4, 0.4], [0.6, 0.5], [0.9, 0.8]])\n    for (full_attention, att_exp) in zip([False, True], [att_exp_past_att, att_exp_full_att]):\n        model = self.helper_create_model(use_encoders=True, add_relative_idx=True, full_attention=full_attention)\n        (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n        model.fit(series, past_covariates=pc, future_covariates=fc)\n        explainer = TFTExplainer(model)\n        results = explainer.explain()\n        att = results.get_attention()\n        assert np.all(np.abs(np.round(att.values(), decimals=1) - att_exp) <= 0.2)\n        assert att.columns.tolist() == ['horizon 1', 'horizon 2']\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='time')\n            plt.close()",
            "def test_attention_explanation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test attention (feature importance) explanation results and plotting.'\n    att_exp_past_att = np.array([[1.1, 1.1], [0.7, 0.7], [0.6, 0.5], [0.7, 0.5], [0.8, 0.5], [0.0, 0.7], [0.0, 0.0]])\n    att_exp_full_att = np.array([[0.9, 1.0], [0.6, 0.6], [0.3, 0.4], [0.3, 0.4], [0.4, 0.4], [0.6, 0.5], [0.9, 0.8]])\n    for (full_attention, att_exp) in zip([False, True], [att_exp_past_att, att_exp_full_att]):\n        model = self.helper_create_model(use_encoders=True, add_relative_idx=True, full_attention=full_attention)\n        (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n        model.fit(series, past_covariates=pc, future_covariates=fc)\n        explainer = TFTExplainer(model)\n        results = explainer.explain()\n        att = results.get_attention()\n        assert np.all(np.abs(np.round(att.values(), decimals=1) - att_exp) <= 0.2)\n        assert att.columns.tolist() == ['horizon 1', 'horizon 2']\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='time')\n            plt.close()",
            "def test_attention_explanation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test attention (feature importance) explanation results and plotting.'\n    att_exp_past_att = np.array([[1.1, 1.1], [0.7, 0.7], [0.6, 0.5], [0.7, 0.5], [0.8, 0.5], [0.0, 0.7], [0.0, 0.0]])\n    att_exp_full_att = np.array([[0.9, 1.0], [0.6, 0.6], [0.3, 0.4], [0.3, 0.4], [0.4, 0.4], [0.6, 0.5], [0.9, 0.8]])\n    for (full_attention, att_exp) in zip([False, True], [att_exp_past_att, att_exp_full_att]):\n        model = self.helper_create_model(use_encoders=True, add_relative_idx=True, full_attention=full_attention)\n        (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n        model.fit(series, past_covariates=pc, future_covariates=fc)\n        explainer = TFTExplainer(model)\n        results = explainer.explain()\n        att = results.get_attention()\n        assert np.all(np.abs(np.round(att.values(), decimals=1) - att_exp) <= 0.2)\n        assert att.columns.tolist() == ['horizon 1', 'horizon 2']\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='time')\n            plt.close()",
            "def test_attention_explanation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test attention (feature importance) explanation results and plotting.'\n    att_exp_past_att = np.array([[1.1, 1.1], [0.7, 0.7], [0.6, 0.5], [0.7, 0.5], [0.8, 0.5], [0.0, 0.7], [0.0, 0.0]])\n    att_exp_full_att = np.array([[0.9, 1.0], [0.6, 0.6], [0.3, 0.4], [0.3, 0.4], [0.4, 0.4], [0.6, 0.5], [0.9, 0.8]])\n    for (full_attention, att_exp) in zip([False, True], [att_exp_past_att, att_exp_full_att]):\n        model = self.helper_create_model(use_encoders=True, add_relative_idx=True, full_attention=full_attention)\n        (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n        model.fit(series, past_covariates=pc, future_covariates=fc)\n        explainer = TFTExplainer(model)\n        results = explainer.explain()\n        att = results.get_attention()\n        assert np.all(np.abs(np.round(att.values(), decimals=1) - att_exp) <= 0.2)\n        assert att.columns.tolist() == ['horizon 1', 'horizon 2']\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='time')\n            plt.close()",
            "def test_attention_explanation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test attention (feature importance) explanation results and plotting.'\n    att_exp_past_att = np.array([[1.1, 1.1], [0.7, 0.7], [0.6, 0.5], [0.7, 0.5], [0.8, 0.5], [0.0, 0.7], [0.0, 0.0]])\n    att_exp_full_att = np.array([[0.9, 1.0], [0.6, 0.6], [0.3, 0.4], [0.3, 0.4], [0.4, 0.4], [0.6, 0.5], [0.9, 0.8]])\n    for (full_attention, att_exp) in zip([False, True], [att_exp_past_att, att_exp_full_att]):\n        model = self.helper_create_model(use_encoders=True, add_relative_idx=True, full_attention=full_attention)\n        (series, pc, fc) = self.helper_get_input(series_option='multivariate')\n        model.fit(series, past_covariates=pc, future_covariates=fc)\n        explainer = TFTExplainer(model)\n        results = explainer.explain()\n        att = results.get_attention()\n        assert np.all(np.abs(np.round(att.values(), decimals=1) - att_exp) <= 0.2)\n        assert att.columns.tolist() == ['horizon 1', 'horizon 2']\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='all', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='time', show_index_as='time')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='relative')\n            plt.close()\n        with patch('matplotlib.pyplot.show') as _:\n            _ = explainer.plot_attention(results, plot_type='heatmap', show_index_as='time')\n            plt.close()"
        ]
    },
    {
        "func_name": "helper_create_model",
        "original": "def helper_create_model(self, use_encoders=True, add_relative_idx=True, full_attention=False):\n    add_encoders = {'cyclic': {'past': ['month'], 'future': ['month']}} if use_encoders else None\n    return TFTModel(input_chunk_length=5, output_chunk_length=2, n_epochs=1, add_encoders=add_encoders, add_relative_index=add_relative_idx, full_attention=full_attention, random_state=42, **tfm_kwargs)",
        "mutated": [
            "def helper_create_model(self, use_encoders=True, add_relative_idx=True, full_attention=False):\n    if False:\n        i = 10\n    add_encoders = {'cyclic': {'past': ['month'], 'future': ['month']}} if use_encoders else None\n    return TFTModel(input_chunk_length=5, output_chunk_length=2, n_epochs=1, add_encoders=add_encoders, add_relative_index=add_relative_idx, full_attention=full_attention, random_state=42, **tfm_kwargs)",
            "def helper_create_model(self, use_encoders=True, add_relative_idx=True, full_attention=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    add_encoders = {'cyclic': {'past': ['month'], 'future': ['month']}} if use_encoders else None\n    return TFTModel(input_chunk_length=5, output_chunk_length=2, n_epochs=1, add_encoders=add_encoders, add_relative_index=add_relative_idx, full_attention=full_attention, random_state=42, **tfm_kwargs)",
            "def helper_create_model(self, use_encoders=True, add_relative_idx=True, full_attention=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    add_encoders = {'cyclic': {'past': ['month'], 'future': ['month']}} if use_encoders else None\n    return TFTModel(input_chunk_length=5, output_chunk_length=2, n_epochs=1, add_encoders=add_encoders, add_relative_index=add_relative_idx, full_attention=full_attention, random_state=42, **tfm_kwargs)",
            "def helper_create_model(self, use_encoders=True, add_relative_idx=True, full_attention=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    add_encoders = {'cyclic': {'past': ['month'], 'future': ['month']}} if use_encoders else None\n    return TFTModel(input_chunk_length=5, output_chunk_length=2, n_epochs=1, add_encoders=add_encoders, add_relative_index=add_relative_idx, full_attention=full_attention, random_state=42, **tfm_kwargs)",
            "def helper_create_model(self, use_encoders=True, add_relative_idx=True, full_attention=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    add_encoders = {'cyclic': {'past': ['month'], 'future': ['month']}} if use_encoders else None\n    return TFTModel(input_chunk_length=5, output_chunk_length=2, n_epochs=1, add_encoders=add_encoders, add_relative_index=add_relative_idx, full_attention=full_attention, random_state=42, **tfm_kwargs)"
        ]
    }
]