[
    {
        "func_name": "floyd_warshall_slow",
        "original": "def floyd_warshall_slow(graph, directed=False):\n    N = graph.shape[0]\n    graph[np.where(graph == 0)] = np.inf\n    graph.flat[::N + 1] = 0\n    if not directed:\n        graph = np.minimum(graph, graph.T)\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                graph[i, j] = min(graph[i, j], graph[i, k] + graph[k, j])\n    graph[np.where(np.isinf(graph))] = 0\n    return graph",
        "mutated": [
            "def floyd_warshall_slow(graph, directed=False):\n    if False:\n        i = 10\n    N = graph.shape[0]\n    graph[np.where(graph == 0)] = np.inf\n    graph.flat[::N + 1] = 0\n    if not directed:\n        graph = np.minimum(graph, graph.T)\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                graph[i, j] = min(graph[i, j], graph[i, k] + graph[k, j])\n    graph[np.where(np.isinf(graph))] = 0\n    return graph",
            "def floyd_warshall_slow(graph, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    N = graph.shape[0]\n    graph[np.where(graph == 0)] = np.inf\n    graph.flat[::N + 1] = 0\n    if not directed:\n        graph = np.minimum(graph, graph.T)\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                graph[i, j] = min(graph[i, j], graph[i, k] + graph[k, j])\n    graph[np.where(np.isinf(graph))] = 0\n    return graph",
            "def floyd_warshall_slow(graph, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    N = graph.shape[0]\n    graph[np.where(graph == 0)] = np.inf\n    graph.flat[::N + 1] = 0\n    if not directed:\n        graph = np.minimum(graph, graph.T)\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                graph[i, j] = min(graph[i, j], graph[i, k] + graph[k, j])\n    graph[np.where(np.isinf(graph))] = 0\n    return graph",
            "def floyd_warshall_slow(graph, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    N = graph.shape[0]\n    graph[np.where(graph == 0)] = np.inf\n    graph.flat[::N + 1] = 0\n    if not directed:\n        graph = np.minimum(graph, graph.T)\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                graph[i, j] = min(graph[i, j], graph[i, k] + graph[k, j])\n    graph[np.where(np.isinf(graph))] = 0\n    return graph",
            "def floyd_warshall_slow(graph, directed=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    N = graph.shape[0]\n    graph[np.where(graph == 0)] = np.inf\n    graph.flat[::N + 1] = 0\n    if not directed:\n        graph = np.minimum(graph, graph.T)\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                graph[i, j] = min(graph[i, j], graph[i, k] + graph[k, j])\n    graph[np.where(np.isinf(graph))] = 0\n    return graph"
        ]
    },
    {
        "func_name": "generate_graph",
        "original": "def generate_graph(N=20):\n    rng = np.random.RandomState(0)\n    dist_matrix = rng.random_sample((N, N))\n    dist_matrix = dist_matrix + dist_matrix.T\n    i = (rng.randint(N, size=N * N // 2), rng.randint(N, size=N * N // 2))\n    dist_matrix[i] = 0\n    dist_matrix.flat[::N + 1] = 0\n    return dist_matrix",
        "mutated": [
            "def generate_graph(N=20):\n    if False:\n        i = 10\n    rng = np.random.RandomState(0)\n    dist_matrix = rng.random_sample((N, N))\n    dist_matrix = dist_matrix + dist_matrix.T\n    i = (rng.randint(N, size=N * N // 2), rng.randint(N, size=N * N // 2))\n    dist_matrix[i] = 0\n    dist_matrix.flat[::N + 1] = 0\n    return dist_matrix",
            "def generate_graph(N=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rng = np.random.RandomState(0)\n    dist_matrix = rng.random_sample((N, N))\n    dist_matrix = dist_matrix + dist_matrix.T\n    i = (rng.randint(N, size=N * N // 2), rng.randint(N, size=N * N // 2))\n    dist_matrix[i] = 0\n    dist_matrix.flat[::N + 1] = 0\n    return dist_matrix",
            "def generate_graph(N=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rng = np.random.RandomState(0)\n    dist_matrix = rng.random_sample((N, N))\n    dist_matrix = dist_matrix + dist_matrix.T\n    i = (rng.randint(N, size=N * N // 2), rng.randint(N, size=N * N // 2))\n    dist_matrix[i] = 0\n    dist_matrix.flat[::N + 1] = 0\n    return dist_matrix",
            "def generate_graph(N=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rng = np.random.RandomState(0)\n    dist_matrix = rng.random_sample((N, N))\n    dist_matrix = dist_matrix + dist_matrix.T\n    i = (rng.randint(N, size=N * N // 2), rng.randint(N, size=N * N // 2))\n    dist_matrix[i] = 0\n    dist_matrix.flat[::N + 1] = 0\n    return dist_matrix",
            "def generate_graph(N=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rng = np.random.RandomState(0)\n    dist_matrix = rng.random_sample((N, N))\n    dist_matrix = dist_matrix + dist_matrix.T\n    i = (rng.randint(N, size=N * N // 2), rng.randint(N, size=N * N // 2))\n    dist_matrix[i] = 0\n    dist_matrix.flat[::N + 1] = 0\n    return dist_matrix"
        ]
    },
    {
        "func_name": "test_shortest_path",
        "original": "def test_shortest_path():\n    dist_matrix = generate_graph(20)\n    dist_matrix[dist_matrix != 0] = 1\n    for directed in (True, False):\n        if not directed:\n            dist_matrix = np.minimum(dist_matrix, dist_matrix.T)\n        graph_py = floyd_warshall_slow(dist_matrix.copy(), directed)\n        for i in range(dist_matrix.shape[0]):\n            dist_dict = defaultdict(int)\n            dist_dict.update(single_source_shortest_path_length(dist_matrix, i))\n            for j in range(graph_py[i].shape[0]):\n                assert_array_almost_equal(dist_dict[j], graph_py[i, j])",
        "mutated": [
            "def test_shortest_path():\n    if False:\n        i = 10\n    dist_matrix = generate_graph(20)\n    dist_matrix[dist_matrix != 0] = 1\n    for directed in (True, False):\n        if not directed:\n            dist_matrix = np.minimum(dist_matrix, dist_matrix.T)\n        graph_py = floyd_warshall_slow(dist_matrix.copy(), directed)\n        for i in range(dist_matrix.shape[0]):\n            dist_dict = defaultdict(int)\n            dist_dict.update(single_source_shortest_path_length(dist_matrix, i))\n            for j in range(graph_py[i].shape[0]):\n                assert_array_almost_equal(dist_dict[j], graph_py[i, j])",
            "def test_shortest_path():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dist_matrix = generate_graph(20)\n    dist_matrix[dist_matrix != 0] = 1\n    for directed in (True, False):\n        if not directed:\n            dist_matrix = np.minimum(dist_matrix, dist_matrix.T)\n        graph_py = floyd_warshall_slow(dist_matrix.copy(), directed)\n        for i in range(dist_matrix.shape[0]):\n            dist_dict = defaultdict(int)\n            dist_dict.update(single_source_shortest_path_length(dist_matrix, i))\n            for j in range(graph_py[i].shape[0]):\n                assert_array_almost_equal(dist_dict[j], graph_py[i, j])",
            "def test_shortest_path():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dist_matrix = generate_graph(20)\n    dist_matrix[dist_matrix != 0] = 1\n    for directed in (True, False):\n        if not directed:\n            dist_matrix = np.minimum(dist_matrix, dist_matrix.T)\n        graph_py = floyd_warshall_slow(dist_matrix.copy(), directed)\n        for i in range(dist_matrix.shape[0]):\n            dist_dict = defaultdict(int)\n            dist_dict.update(single_source_shortest_path_length(dist_matrix, i))\n            for j in range(graph_py[i].shape[0]):\n                assert_array_almost_equal(dist_dict[j], graph_py[i, j])",
            "def test_shortest_path():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dist_matrix = generate_graph(20)\n    dist_matrix[dist_matrix != 0] = 1\n    for directed in (True, False):\n        if not directed:\n            dist_matrix = np.minimum(dist_matrix, dist_matrix.T)\n        graph_py = floyd_warshall_slow(dist_matrix.copy(), directed)\n        for i in range(dist_matrix.shape[0]):\n            dist_dict = defaultdict(int)\n            dist_dict.update(single_source_shortest_path_length(dist_matrix, i))\n            for j in range(graph_py[i].shape[0]):\n                assert_array_almost_equal(dist_dict[j], graph_py[i, j])",
            "def test_shortest_path():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dist_matrix = generate_graph(20)\n    dist_matrix[dist_matrix != 0] = 1\n    for directed in (True, False):\n        if not directed:\n            dist_matrix = np.minimum(dist_matrix, dist_matrix.T)\n        graph_py = floyd_warshall_slow(dist_matrix.copy(), directed)\n        for i in range(dist_matrix.shape[0]):\n            dist_dict = defaultdict(int)\n            dist_dict.update(single_source_shortest_path_length(dist_matrix, i))\n            for j in range(graph_py[i].shape[0]):\n                assert_array_almost_equal(dist_dict[j], graph_py[i, j])"
        ]
    }
]