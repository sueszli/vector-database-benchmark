[
    {
        "func_name": "validate_version_pragma",
        "original": "def validate_version_pragma(version_str: str, start: ParserPosition) -> None:\n    \"\"\"\n    Validates a version pragma directive against the current compiler version.\n    \"\"\"\n    from vyper import __version__\n    if len(version_str) == 0:\n        raise VersionException('Version specification cannot be empty', start)\n    if re.match('[v0-9]', version_str):\n        version_str = '==' + version_str\n    version_str = re.sub('^\\\\^', '~=', version_str)\n    try:\n        spec = SpecifierSet(version_str)\n    except InvalidSpecifier:\n        raise VersionException(f'Version specification \"{version_str}\" is not a valid PEP440 specifier', start)\n    if not spec.contains(__version__, prereleases=True):\n        raise VersionException(f'Version specification \"{version_str}\" is not compatible with compiler version \"{__version__}\"', start)",
        "mutated": [
            "def validate_version_pragma(version_str: str, start: ParserPosition) -> None:\n    if False:\n        i = 10\n    '\\n    Validates a version pragma directive against the current compiler version.\\n    '\n    from vyper import __version__\n    if len(version_str) == 0:\n        raise VersionException('Version specification cannot be empty', start)\n    if re.match('[v0-9]', version_str):\n        version_str = '==' + version_str\n    version_str = re.sub('^\\\\^', '~=', version_str)\n    try:\n        spec = SpecifierSet(version_str)\n    except InvalidSpecifier:\n        raise VersionException(f'Version specification \"{version_str}\" is not a valid PEP440 specifier', start)\n    if not spec.contains(__version__, prereleases=True):\n        raise VersionException(f'Version specification \"{version_str}\" is not compatible with compiler version \"{__version__}\"', start)",
            "def validate_version_pragma(version_str: str, start: ParserPosition) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Validates a version pragma directive against the current compiler version.\\n    '\n    from vyper import __version__\n    if len(version_str) == 0:\n        raise VersionException('Version specification cannot be empty', start)\n    if re.match('[v0-9]', version_str):\n        version_str = '==' + version_str\n    version_str = re.sub('^\\\\^', '~=', version_str)\n    try:\n        spec = SpecifierSet(version_str)\n    except InvalidSpecifier:\n        raise VersionException(f'Version specification \"{version_str}\" is not a valid PEP440 specifier', start)\n    if not spec.contains(__version__, prereleases=True):\n        raise VersionException(f'Version specification \"{version_str}\" is not compatible with compiler version \"{__version__}\"', start)",
            "def validate_version_pragma(version_str: str, start: ParserPosition) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Validates a version pragma directive against the current compiler version.\\n    '\n    from vyper import __version__\n    if len(version_str) == 0:\n        raise VersionException('Version specification cannot be empty', start)\n    if re.match('[v0-9]', version_str):\n        version_str = '==' + version_str\n    version_str = re.sub('^\\\\^', '~=', version_str)\n    try:\n        spec = SpecifierSet(version_str)\n    except InvalidSpecifier:\n        raise VersionException(f'Version specification \"{version_str}\" is not a valid PEP440 specifier', start)\n    if not spec.contains(__version__, prereleases=True):\n        raise VersionException(f'Version specification \"{version_str}\" is not compatible with compiler version \"{__version__}\"', start)",
            "def validate_version_pragma(version_str: str, start: ParserPosition) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Validates a version pragma directive against the current compiler version.\\n    '\n    from vyper import __version__\n    if len(version_str) == 0:\n        raise VersionException('Version specification cannot be empty', start)\n    if re.match('[v0-9]', version_str):\n        version_str = '==' + version_str\n    version_str = re.sub('^\\\\^', '~=', version_str)\n    try:\n        spec = SpecifierSet(version_str)\n    except InvalidSpecifier:\n        raise VersionException(f'Version specification \"{version_str}\" is not a valid PEP440 specifier', start)\n    if not spec.contains(__version__, prereleases=True):\n        raise VersionException(f'Version specification \"{version_str}\" is not compatible with compiler version \"{__version__}\"', start)",
            "def validate_version_pragma(version_str: str, start: ParserPosition) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Validates a version pragma directive against the current compiler version.\\n    '\n    from vyper import __version__\n    if len(version_str) == 0:\n        raise VersionException('Version specification cannot be empty', start)\n    if re.match('[v0-9]', version_str):\n        version_str = '==' + version_str\n    version_str = re.sub('^\\\\^', '~=', version_str)\n    try:\n        spec = SpecifierSet(version_str)\n    except InvalidSpecifier:\n        raise VersionException(f'Version specification \"{version_str}\" is not a valid PEP440 specifier', start)\n    if not spec.contains(__version__, prereleases=True):\n        raise VersionException(f'Version specification \"{version_str}\" is not compatible with compiler version \"{__version__}\"', start)"
        ]
    },
    {
        "func_name": "pre_parse",
        "original": "def pre_parse(code: str) -> tuple[Settings, ModificationOffsets, str]:\n    \"\"\"\n    Re-formats a vyper source string into a python source string and performs\n    some validation.  More specifically,\n\n    * Translates \"interface\", \"struct\", \"enum, and \"event\" keywords into python \"class\" keyword\n    * Validates \"@version\" pragma against current compiler version\n    * Prevents direct use of python \"class\" keyword\n    * Prevents use of python semi-colon statement separator\n\n    Also returns a mapping of detected interface and struct names to their\n    respective vyper class types (\"interface\" or \"struct\").\n\n    Parameters\n    ----------\n    code : str\n        The vyper source code to be re-formatted.\n\n    Returns\n    -------\n    dict\n        Mapping of offsets where source was modified.\n    str\n        Reformatted python source string.\n    \"\"\"\n    result = []\n    modification_offsets: ModificationOffsets = {}\n    settings = Settings()\n    try:\n        code_bytes = code.encode('utf-8')\n        token_list = list(tokenize(io.BytesIO(code_bytes).readline))\n        for i in range(len(token_list)):\n            token = token_list[i]\n            toks = [token]\n            typ = token.type\n            string = token.string\n            start = token.start\n            end = token.end\n            line = token.line\n            if typ == COMMENT:\n                contents = string[1:].strip()\n                if contents.startswith('@version'):\n                    if settings.compiler_version is not None:\n                        raise StructureException('compiler version specified twice!', start)\n                    compiler_version = contents.removeprefix('@version ').strip()\n                    validate_version_pragma(compiler_version, start)\n                    settings.compiler_version = compiler_version\n                if contents.startswith('pragma '):\n                    pragma = contents.removeprefix('pragma ').strip()\n                    if pragma.startswith('version '):\n                        if settings.compiler_version is not None:\n                            raise StructureException('pragma version specified twice!', start)\n                        compiler_version = pragma.removeprefix('version ').strip()\n                        validate_version_pragma(compiler_version, start)\n                        settings.compiler_version = compiler_version\n                    elif pragma.startswith('optimize '):\n                        if settings.optimize is not None:\n                            raise StructureException('pragma optimize specified twice!', start)\n                        try:\n                            mode = pragma.removeprefix('optimize').strip()\n                            settings.optimize = OptimizationLevel.from_string(mode)\n                        except ValueError:\n                            raise StructureException(f'Invalid optimization mode `{mode}`', start)\n                    elif pragma.startswith('evm-version '):\n                        if settings.evm_version is not None:\n                            raise StructureException('pragma evm-version specified twice!', start)\n                        evm_version = pragma.removeprefix('evm-version').strip()\n                        if evm_version not in EVM_VERSIONS:\n                            raise StructureException('Invalid evm version: `{evm_version}`', start)\n                        settings.evm_version = evm_version\n                    else:\n                        raise StructureException(f'Unknown pragma `{pragma.split()[0]}`')\n            if typ == NAME and string in ('class', 'yield'):\n                raise SyntaxException(f'The `{string}` keyword is not allowed. ', code, start[0], start[1])\n            if typ == NAME:\n                if string in VYPER_CLASS_TYPES and start[1] == 0:\n                    toks = [TokenInfo(NAME, 'class', start, end, line)]\n                    modification_offsets[start] = f'{string.capitalize()}Def'\n                elif string in VYPER_EXPRESSION_TYPES:\n                    toks = [TokenInfo(NAME, 'yield', start, end, line)]\n                    modification_offsets[start] = string.capitalize()\n            if (typ, string) == (OP, ';'):\n                raise SyntaxException('Semi-colon statements not allowed', code, start[0], start[1])\n            result.extend(toks)\n    except TokenError as e:\n        raise SyntaxException(e.args[0], code, e.args[1][0], e.args[1][1]) from e\n    return (settings, modification_offsets, untokenize(result).decode('utf-8'))",
        "mutated": [
            "def pre_parse(code: str) -> tuple[Settings, ModificationOffsets, str]:\n    if False:\n        i = 10\n    '\\n    Re-formats a vyper source string into a python source string and performs\\n    some validation.  More specifically,\\n\\n    * Translates \"interface\", \"struct\", \"enum, and \"event\" keywords into python \"class\" keyword\\n    * Validates \"@version\" pragma against current compiler version\\n    * Prevents direct use of python \"class\" keyword\\n    * Prevents use of python semi-colon statement separator\\n\\n    Also returns a mapping of detected interface and struct names to their\\n    respective vyper class types (\"interface\" or \"struct\").\\n\\n    Parameters\\n    ----------\\n    code : str\\n        The vyper source code to be re-formatted.\\n\\n    Returns\\n    -------\\n    dict\\n        Mapping of offsets where source was modified.\\n    str\\n        Reformatted python source string.\\n    '\n    result = []\n    modification_offsets: ModificationOffsets = {}\n    settings = Settings()\n    try:\n        code_bytes = code.encode('utf-8')\n        token_list = list(tokenize(io.BytesIO(code_bytes).readline))\n        for i in range(len(token_list)):\n            token = token_list[i]\n            toks = [token]\n            typ = token.type\n            string = token.string\n            start = token.start\n            end = token.end\n            line = token.line\n            if typ == COMMENT:\n                contents = string[1:].strip()\n                if contents.startswith('@version'):\n                    if settings.compiler_version is not None:\n                        raise StructureException('compiler version specified twice!', start)\n                    compiler_version = contents.removeprefix('@version ').strip()\n                    validate_version_pragma(compiler_version, start)\n                    settings.compiler_version = compiler_version\n                if contents.startswith('pragma '):\n                    pragma = contents.removeprefix('pragma ').strip()\n                    if pragma.startswith('version '):\n                        if settings.compiler_version is not None:\n                            raise StructureException('pragma version specified twice!', start)\n                        compiler_version = pragma.removeprefix('version ').strip()\n                        validate_version_pragma(compiler_version, start)\n                        settings.compiler_version = compiler_version\n                    elif pragma.startswith('optimize '):\n                        if settings.optimize is not None:\n                            raise StructureException('pragma optimize specified twice!', start)\n                        try:\n                            mode = pragma.removeprefix('optimize').strip()\n                            settings.optimize = OptimizationLevel.from_string(mode)\n                        except ValueError:\n                            raise StructureException(f'Invalid optimization mode `{mode}`', start)\n                    elif pragma.startswith('evm-version '):\n                        if settings.evm_version is not None:\n                            raise StructureException('pragma evm-version specified twice!', start)\n                        evm_version = pragma.removeprefix('evm-version').strip()\n                        if evm_version not in EVM_VERSIONS:\n                            raise StructureException('Invalid evm version: `{evm_version}`', start)\n                        settings.evm_version = evm_version\n                    else:\n                        raise StructureException(f'Unknown pragma `{pragma.split()[0]}`')\n            if typ == NAME and string in ('class', 'yield'):\n                raise SyntaxException(f'The `{string}` keyword is not allowed. ', code, start[0], start[1])\n            if typ == NAME:\n                if string in VYPER_CLASS_TYPES and start[1] == 0:\n                    toks = [TokenInfo(NAME, 'class', start, end, line)]\n                    modification_offsets[start] = f'{string.capitalize()}Def'\n                elif string in VYPER_EXPRESSION_TYPES:\n                    toks = [TokenInfo(NAME, 'yield', start, end, line)]\n                    modification_offsets[start] = string.capitalize()\n            if (typ, string) == (OP, ';'):\n                raise SyntaxException('Semi-colon statements not allowed', code, start[0], start[1])\n            result.extend(toks)\n    except TokenError as e:\n        raise SyntaxException(e.args[0], code, e.args[1][0], e.args[1][1]) from e\n    return (settings, modification_offsets, untokenize(result).decode('utf-8'))",
            "def pre_parse(code: str) -> tuple[Settings, ModificationOffsets, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Re-formats a vyper source string into a python source string and performs\\n    some validation.  More specifically,\\n\\n    * Translates \"interface\", \"struct\", \"enum, and \"event\" keywords into python \"class\" keyword\\n    * Validates \"@version\" pragma against current compiler version\\n    * Prevents direct use of python \"class\" keyword\\n    * Prevents use of python semi-colon statement separator\\n\\n    Also returns a mapping of detected interface and struct names to their\\n    respective vyper class types (\"interface\" or \"struct\").\\n\\n    Parameters\\n    ----------\\n    code : str\\n        The vyper source code to be re-formatted.\\n\\n    Returns\\n    -------\\n    dict\\n        Mapping of offsets where source was modified.\\n    str\\n        Reformatted python source string.\\n    '\n    result = []\n    modification_offsets: ModificationOffsets = {}\n    settings = Settings()\n    try:\n        code_bytes = code.encode('utf-8')\n        token_list = list(tokenize(io.BytesIO(code_bytes).readline))\n        for i in range(len(token_list)):\n            token = token_list[i]\n            toks = [token]\n            typ = token.type\n            string = token.string\n            start = token.start\n            end = token.end\n            line = token.line\n            if typ == COMMENT:\n                contents = string[1:].strip()\n                if contents.startswith('@version'):\n                    if settings.compiler_version is not None:\n                        raise StructureException('compiler version specified twice!', start)\n                    compiler_version = contents.removeprefix('@version ').strip()\n                    validate_version_pragma(compiler_version, start)\n                    settings.compiler_version = compiler_version\n                if contents.startswith('pragma '):\n                    pragma = contents.removeprefix('pragma ').strip()\n                    if pragma.startswith('version '):\n                        if settings.compiler_version is not None:\n                            raise StructureException('pragma version specified twice!', start)\n                        compiler_version = pragma.removeprefix('version ').strip()\n                        validate_version_pragma(compiler_version, start)\n                        settings.compiler_version = compiler_version\n                    elif pragma.startswith('optimize '):\n                        if settings.optimize is not None:\n                            raise StructureException('pragma optimize specified twice!', start)\n                        try:\n                            mode = pragma.removeprefix('optimize').strip()\n                            settings.optimize = OptimizationLevel.from_string(mode)\n                        except ValueError:\n                            raise StructureException(f'Invalid optimization mode `{mode}`', start)\n                    elif pragma.startswith('evm-version '):\n                        if settings.evm_version is not None:\n                            raise StructureException('pragma evm-version specified twice!', start)\n                        evm_version = pragma.removeprefix('evm-version').strip()\n                        if evm_version not in EVM_VERSIONS:\n                            raise StructureException('Invalid evm version: `{evm_version}`', start)\n                        settings.evm_version = evm_version\n                    else:\n                        raise StructureException(f'Unknown pragma `{pragma.split()[0]}`')\n            if typ == NAME and string in ('class', 'yield'):\n                raise SyntaxException(f'The `{string}` keyword is not allowed. ', code, start[0], start[1])\n            if typ == NAME:\n                if string in VYPER_CLASS_TYPES and start[1] == 0:\n                    toks = [TokenInfo(NAME, 'class', start, end, line)]\n                    modification_offsets[start] = f'{string.capitalize()}Def'\n                elif string in VYPER_EXPRESSION_TYPES:\n                    toks = [TokenInfo(NAME, 'yield', start, end, line)]\n                    modification_offsets[start] = string.capitalize()\n            if (typ, string) == (OP, ';'):\n                raise SyntaxException('Semi-colon statements not allowed', code, start[0], start[1])\n            result.extend(toks)\n    except TokenError as e:\n        raise SyntaxException(e.args[0], code, e.args[1][0], e.args[1][1]) from e\n    return (settings, modification_offsets, untokenize(result).decode('utf-8'))",
            "def pre_parse(code: str) -> tuple[Settings, ModificationOffsets, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Re-formats a vyper source string into a python source string and performs\\n    some validation.  More specifically,\\n\\n    * Translates \"interface\", \"struct\", \"enum, and \"event\" keywords into python \"class\" keyword\\n    * Validates \"@version\" pragma against current compiler version\\n    * Prevents direct use of python \"class\" keyword\\n    * Prevents use of python semi-colon statement separator\\n\\n    Also returns a mapping of detected interface and struct names to their\\n    respective vyper class types (\"interface\" or \"struct\").\\n\\n    Parameters\\n    ----------\\n    code : str\\n        The vyper source code to be re-formatted.\\n\\n    Returns\\n    -------\\n    dict\\n        Mapping of offsets where source was modified.\\n    str\\n        Reformatted python source string.\\n    '\n    result = []\n    modification_offsets: ModificationOffsets = {}\n    settings = Settings()\n    try:\n        code_bytes = code.encode('utf-8')\n        token_list = list(tokenize(io.BytesIO(code_bytes).readline))\n        for i in range(len(token_list)):\n            token = token_list[i]\n            toks = [token]\n            typ = token.type\n            string = token.string\n            start = token.start\n            end = token.end\n            line = token.line\n            if typ == COMMENT:\n                contents = string[1:].strip()\n                if contents.startswith('@version'):\n                    if settings.compiler_version is not None:\n                        raise StructureException('compiler version specified twice!', start)\n                    compiler_version = contents.removeprefix('@version ').strip()\n                    validate_version_pragma(compiler_version, start)\n                    settings.compiler_version = compiler_version\n                if contents.startswith('pragma '):\n                    pragma = contents.removeprefix('pragma ').strip()\n                    if pragma.startswith('version '):\n                        if settings.compiler_version is not None:\n                            raise StructureException('pragma version specified twice!', start)\n                        compiler_version = pragma.removeprefix('version ').strip()\n                        validate_version_pragma(compiler_version, start)\n                        settings.compiler_version = compiler_version\n                    elif pragma.startswith('optimize '):\n                        if settings.optimize is not None:\n                            raise StructureException('pragma optimize specified twice!', start)\n                        try:\n                            mode = pragma.removeprefix('optimize').strip()\n                            settings.optimize = OptimizationLevel.from_string(mode)\n                        except ValueError:\n                            raise StructureException(f'Invalid optimization mode `{mode}`', start)\n                    elif pragma.startswith('evm-version '):\n                        if settings.evm_version is not None:\n                            raise StructureException('pragma evm-version specified twice!', start)\n                        evm_version = pragma.removeprefix('evm-version').strip()\n                        if evm_version not in EVM_VERSIONS:\n                            raise StructureException('Invalid evm version: `{evm_version}`', start)\n                        settings.evm_version = evm_version\n                    else:\n                        raise StructureException(f'Unknown pragma `{pragma.split()[0]}`')\n            if typ == NAME and string in ('class', 'yield'):\n                raise SyntaxException(f'The `{string}` keyword is not allowed. ', code, start[0], start[1])\n            if typ == NAME:\n                if string in VYPER_CLASS_TYPES and start[1] == 0:\n                    toks = [TokenInfo(NAME, 'class', start, end, line)]\n                    modification_offsets[start] = f'{string.capitalize()}Def'\n                elif string in VYPER_EXPRESSION_TYPES:\n                    toks = [TokenInfo(NAME, 'yield', start, end, line)]\n                    modification_offsets[start] = string.capitalize()\n            if (typ, string) == (OP, ';'):\n                raise SyntaxException('Semi-colon statements not allowed', code, start[0], start[1])\n            result.extend(toks)\n    except TokenError as e:\n        raise SyntaxException(e.args[0], code, e.args[1][0], e.args[1][1]) from e\n    return (settings, modification_offsets, untokenize(result).decode('utf-8'))",
            "def pre_parse(code: str) -> tuple[Settings, ModificationOffsets, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Re-formats a vyper source string into a python source string and performs\\n    some validation.  More specifically,\\n\\n    * Translates \"interface\", \"struct\", \"enum, and \"event\" keywords into python \"class\" keyword\\n    * Validates \"@version\" pragma against current compiler version\\n    * Prevents direct use of python \"class\" keyword\\n    * Prevents use of python semi-colon statement separator\\n\\n    Also returns a mapping of detected interface and struct names to their\\n    respective vyper class types (\"interface\" or \"struct\").\\n\\n    Parameters\\n    ----------\\n    code : str\\n        The vyper source code to be re-formatted.\\n\\n    Returns\\n    -------\\n    dict\\n        Mapping of offsets where source was modified.\\n    str\\n        Reformatted python source string.\\n    '\n    result = []\n    modification_offsets: ModificationOffsets = {}\n    settings = Settings()\n    try:\n        code_bytes = code.encode('utf-8')\n        token_list = list(tokenize(io.BytesIO(code_bytes).readline))\n        for i in range(len(token_list)):\n            token = token_list[i]\n            toks = [token]\n            typ = token.type\n            string = token.string\n            start = token.start\n            end = token.end\n            line = token.line\n            if typ == COMMENT:\n                contents = string[1:].strip()\n                if contents.startswith('@version'):\n                    if settings.compiler_version is not None:\n                        raise StructureException('compiler version specified twice!', start)\n                    compiler_version = contents.removeprefix('@version ').strip()\n                    validate_version_pragma(compiler_version, start)\n                    settings.compiler_version = compiler_version\n                if contents.startswith('pragma '):\n                    pragma = contents.removeprefix('pragma ').strip()\n                    if pragma.startswith('version '):\n                        if settings.compiler_version is not None:\n                            raise StructureException('pragma version specified twice!', start)\n                        compiler_version = pragma.removeprefix('version ').strip()\n                        validate_version_pragma(compiler_version, start)\n                        settings.compiler_version = compiler_version\n                    elif pragma.startswith('optimize '):\n                        if settings.optimize is not None:\n                            raise StructureException('pragma optimize specified twice!', start)\n                        try:\n                            mode = pragma.removeprefix('optimize').strip()\n                            settings.optimize = OptimizationLevel.from_string(mode)\n                        except ValueError:\n                            raise StructureException(f'Invalid optimization mode `{mode}`', start)\n                    elif pragma.startswith('evm-version '):\n                        if settings.evm_version is not None:\n                            raise StructureException('pragma evm-version specified twice!', start)\n                        evm_version = pragma.removeprefix('evm-version').strip()\n                        if evm_version not in EVM_VERSIONS:\n                            raise StructureException('Invalid evm version: `{evm_version}`', start)\n                        settings.evm_version = evm_version\n                    else:\n                        raise StructureException(f'Unknown pragma `{pragma.split()[0]}`')\n            if typ == NAME and string in ('class', 'yield'):\n                raise SyntaxException(f'The `{string}` keyword is not allowed. ', code, start[0], start[1])\n            if typ == NAME:\n                if string in VYPER_CLASS_TYPES and start[1] == 0:\n                    toks = [TokenInfo(NAME, 'class', start, end, line)]\n                    modification_offsets[start] = f'{string.capitalize()}Def'\n                elif string in VYPER_EXPRESSION_TYPES:\n                    toks = [TokenInfo(NAME, 'yield', start, end, line)]\n                    modification_offsets[start] = string.capitalize()\n            if (typ, string) == (OP, ';'):\n                raise SyntaxException('Semi-colon statements not allowed', code, start[0], start[1])\n            result.extend(toks)\n    except TokenError as e:\n        raise SyntaxException(e.args[0], code, e.args[1][0], e.args[1][1]) from e\n    return (settings, modification_offsets, untokenize(result).decode('utf-8'))",
            "def pre_parse(code: str) -> tuple[Settings, ModificationOffsets, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Re-formats a vyper source string into a python source string and performs\\n    some validation.  More specifically,\\n\\n    * Translates \"interface\", \"struct\", \"enum, and \"event\" keywords into python \"class\" keyword\\n    * Validates \"@version\" pragma against current compiler version\\n    * Prevents direct use of python \"class\" keyword\\n    * Prevents use of python semi-colon statement separator\\n\\n    Also returns a mapping of detected interface and struct names to their\\n    respective vyper class types (\"interface\" or \"struct\").\\n\\n    Parameters\\n    ----------\\n    code : str\\n        The vyper source code to be re-formatted.\\n\\n    Returns\\n    -------\\n    dict\\n        Mapping of offsets where source was modified.\\n    str\\n        Reformatted python source string.\\n    '\n    result = []\n    modification_offsets: ModificationOffsets = {}\n    settings = Settings()\n    try:\n        code_bytes = code.encode('utf-8')\n        token_list = list(tokenize(io.BytesIO(code_bytes).readline))\n        for i in range(len(token_list)):\n            token = token_list[i]\n            toks = [token]\n            typ = token.type\n            string = token.string\n            start = token.start\n            end = token.end\n            line = token.line\n            if typ == COMMENT:\n                contents = string[1:].strip()\n                if contents.startswith('@version'):\n                    if settings.compiler_version is not None:\n                        raise StructureException('compiler version specified twice!', start)\n                    compiler_version = contents.removeprefix('@version ').strip()\n                    validate_version_pragma(compiler_version, start)\n                    settings.compiler_version = compiler_version\n                if contents.startswith('pragma '):\n                    pragma = contents.removeprefix('pragma ').strip()\n                    if pragma.startswith('version '):\n                        if settings.compiler_version is not None:\n                            raise StructureException('pragma version specified twice!', start)\n                        compiler_version = pragma.removeprefix('version ').strip()\n                        validate_version_pragma(compiler_version, start)\n                        settings.compiler_version = compiler_version\n                    elif pragma.startswith('optimize '):\n                        if settings.optimize is not None:\n                            raise StructureException('pragma optimize specified twice!', start)\n                        try:\n                            mode = pragma.removeprefix('optimize').strip()\n                            settings.optimize = OptimizationLevel.from_string(mode)\n                        except ValueError:\n                            raise StructureException(f'Invalid optimization mode `{mode}`', start)\n                    elif pragma.startswith('evm-version '):\n                        if settings.evm_version is not None:\n                            raise StructureException('pragma evm-version specified twice!', start)\n                        evm_version = pragma.removeprefix('evm-version').strip()\n                        if evm_version not in EVM_VERSIONS:\n                            raise StructureException('Invalid evm version: `{evm_version}`', start)\n                        settings.evm_version = evm_version\n                    else:\n                        raise StructureException(f'Unknown pragma `{pragma.split()[0]}`')\n            if typ == NAME and string in ('class', 'yield'):\n                raise SyntaxException(f'The `{string}` keyword is not allowed. ', code, start[0], start[1])\n            if typ == NAME:\n                if string in VYPER_CLASS_TYPES and start[1] == 0:\n                    toks = [TokenInfo(NAME, 'class', start, end, line)]\n                    modification_offsets[start] = f'{string.capitalize()}Def'\n                elif string in VYPER_EXPRESSION_TYPES:\n                    toks = [TokenInfo(NAME, 'yield', start, end, line)]\n                    modification_offsets[start] = string.capitalize()\n            if (typ, string) == (OP, ';'):\n                raise SyntaxException('Semi-colon statements not allowed', code, start[0], start[1])\n            result.extend(toks)\n    except TokenError as e:\n        raise SyntaxException(e.args[0], code, e.args[1][0], e.args[1][1]) from e\n    return (settings, modification_offsets, untokenize(result).decode('utf-8'))"
        ]
    }
]