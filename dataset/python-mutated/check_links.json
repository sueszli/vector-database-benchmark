[
    {
        "func_name": "url_ok",
        "original": "def url_ok(match_tuple: MatchTuple) -> Tuple[bool, str]:\n    \"\"\"Check if a URL is reachable.\"\"\"\n    try:\n        result = http_session.head(match_tuple.link, timeout=5, allow_redirects=True)\n        return (result.ok or result.status_code in OK_STATUS_CODES, f'status code = {result.status_code}')\n    except (requests.ConnectionError, requests.Timeout):\n        return (False, 'connection error')",
        "mutated": [
            "def url_ok(match_tuple: MatchTuple) -> Tuple[bool, str]:\n    if False:\n        i = 10\n    'Check if a URL is reachable.'\n    try:\n        result = http_session.head(match_tuple.link, timeout=5, allow_redirects=True)\n        return (result.ok or result.status_code in OK_STATUS_CODES, f'status code = {result.status_code}')\n    except (requests.ConnectionError, requests.Timeout):\n        return (False, 'connection error')",
            "def url_ok(match_tuple: MatchTuple) -> Tuple[bool, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Check if a URL is reachable.'\n    try:\n        result = http_session.head(match_tuple.link, timeout=5, allow_redirects=True)\n        return (result.ok or result.status_code in OK_STATUS_CODES, f'status code = {result.status_code}')\n    except (requests.ConnectionError, requests.Timeout):\n        return (False, 'connection error')",
            "def url_ok(match_tuple: MatchTuple) -> Tuple[bool, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Check if a URL is reachable.'\n    try:\n        result = http_session.head(match_tuple.link, timeout=5, allow_redirects=True)\n        return (result.ok or result.status_code in OK_STATUS_CODES, f'status code = {result.status_code}')\n    except (requests.ConnectionError, requests.Timeout):\n        return (False, 'connection error')",
            "def url_ok(match_tuple: MatchTuple) -> Tuple[bool, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Check if a URL is reachable.'\n    try:\n        result = http_session.head(match_tuple.link, timeout=5, allow_redirects=True)\n        return (result.ok or result.status_code in OK_STATUS_CODES, f'status code = {result.status_code}')\n    except (requests.ConnectionError, requests.Timeout):\n        return (False, 'connection error')",
            "def url_ok(match_tuple: MatchTuple) -> Tuple[bool, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Check if a URL is reachable.'\n    try:\n        result = http_session.head(match_tuple.link, timeout=5, allow_redirects=True)\n        return (result.ok or result.status_code in OK_STATUS_CODES, f'status code = {result.status_code}')\n    except (requests.ConnectionError, requests.Timeout):\n        return (False, 'connection error')"
        ]
    },
    {
        "func_name": "path_ok",
        "original": "def path_ok(match_tuple: MatchTuple) -> bool:\n    \"\"\"Check if a file in this repository exists.\"\"\"\n    relative_path = match_tuple.link.split('#')[0]\n    full_path = os.path.join(os.path.dirname(str(match_tuple.source)), relative_path)\n    return os.path.exists(full_path)",
        "mutated": [
            "def path_ok(match_tuple: MatchTuple) -> bool:\n    if False:\n        i = 10\n    'Check if a file in this repository exists.'\n    relative_path = match_tuple.link.split('#')[0]\n    full_path = os.path.join(os.path.dirname(str(match_tuple.source)), relative_path)\n    return os.path.exists(full_path)",
            "def path_ok(match_tuple: MatchTuple) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Check if a file in this repository exists.'\n    relative_path = match_tuple.link.split('#')[0]\n    full_path = os.path.join(os.path.dirname(str(match_tuple.source)), relative_path)\n    return os.path.exists(full_path)",
            "def path_ok(match_tuple: MatchTuple) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Check if a file in this repository exists.'\n    relative_path = match_tuple.link.split('#')[0]\n    full_path = os.path.join(os.path.dirname(str(match_tuple.source)), relative_path)\n    return os.path.exists(full_path)",
            "def path_ok(match_tuple: MatchTuple) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Check if a file in this repository exists.'\n    relative_path = match_tuple.link.split('#')[0]\n    full_path = os.path.join(os.path.dirname(str(match_tuple.source)), relative_path)\n    return os.path.exists(full_path)",
            "def path_ok(match_tuple: MatchTuple) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Check if a file in this repository exists.'\n    relative_path = match_tuple.link.split('#')[0]\n    full_path = os.path.join(os.path.dirname(str(match_tuple.source)), relative_path)\n    return os.path.exists(full_path)"
        ]
    },
    {
        "func_name": "link_ok",
        "original": "def link_ok(match_tuple: MatchTuple) -> Tuple[MatchTuple, bool, Optional[str]]:\n    reason: Optional[str] = None\n    if match_tuple.link.startswith('http'):\n        (result_ok, reason) = url_ok(match_tuple)\n    else:\n        result_ok = path_ok(match_tuple)\n    print(f\"  {('\u2713' if result_ok else '\u2717')} {match_tuple.link}\")\n    return (match_tuple, result_ok, reason)",
        "mutated": [
            "def link_ok(match_tuple: MatchTuple) -> Tuple[MatchTuple, bool, Optional[str]]:\n    if False:\n        i = 10\n    reason: Optional[str] = None\n    if match_tuple.link.startswith('http'):\n        (result_ok, reason) = url_ok(match_tuple)\n    else:\n        result_ok = path_ok(match_tuple)\n    print(f\"  {('\u2713' if result_ok else '\u2717')} {match_tuple.link}\")\n    return (match_tuple, result_ok, reason)",
            "def link_ok(match_tuple: MatchTuple) -> Tuple[MatchTuple, bool, Optional[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    reason: Optional[str] = None\n    if match_tuple.link.startswith('http'):\n        (result_ok, reason) = url_ok(match_tuple)\n    else:\n        result_ok = path_ok(match_tuple)\n    print(f\"  {('\u2713' if result_ok else '\u2717')} {match_tuple.link}\")\n    return (match_tuple, result_ok, reason)",
            "def link_ok(match_tuple: MatchTuple) -> Tuple[MatchTuple, bool, Optional[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    reason: Optional[str] = None\n    if match_tuple.link.startswith('http'):\n        (result_ok, reason) = url_ok(match_tuple)\n    else:\n        result_ok = path_ok(match_tuple)\n    print(f\"  {('\u2713' if result_ok else '\u2717')} {match_tuple.link}\")\n    return (match_tuple, result_ok, reason)",
            "def link_ok(match_tuple: MatchTuple) -> Tuple[MatchTuple, bool, Optional[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    reason: Optional[str] = None\n    if match_tuple.link.startswith('http'):\n        (result_ok, reason) = url_ok(match_tuple)\n    else:\n        result_ok = path_ok(match_tuple)\n    print(f\"  {('\u2713' if result_ok else '\u2717')} {match_tuple.link}\")\n    return (match_tuple, result_ok, reason)",
            "def link_ok(match_tuple: MatchTuple) -> Tuple[MatchTuple, bool, Optional[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    reason: Optional[str] = None\n    if match_tuple.link.startswith('http'):\n        (result_ok, reason) = url_ok(match_tuple)\n    else:\n        result_ok = path_ok(match_tuple)\n    print(f\"  {('\u2713' if result_ok else '\u2717')} {match_tuple.link}\")\n    return (match_tuple, result_ok, reason)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    print('Finding all markdown files in the current directory...')\n    project_root = (pathlib.Path(__file__).parent / '..').resolve()\n    markdown_files = project_root.glob('**/*.md')\n    all_matches = set()\n    url_regex = re.compile('\\\\[([^!][^\\\\]]+)\\\\]\\\\(([^)(]+)\\\\)')\n    for markdown_file in markdown_files:\n        with open(markdown_file) as handle:\n            for line in handle.readlines():\n                matches = url_regex.findall(line)\n                for (name, link) in matches:\n                    if 'localhost' not in link:\n                        all_matches.add(MatchTuple(source=str(markdown_file), name=name, link=link))\n    print(f'  {len(all_matches)} markdown files found')\n    print('Checking to make sure we can retrieve each link...')\n    with Pool(processes=THREADS) as pool:\n        results = pool.map(link_ok, [match for match in list(all_matches)])\n    unreachable_results = [(match_tuple, reason) for (match_tuple, success, reason) in results if not success]\n    if unreachable_results:\n        print(f'Unreachable links ({len(unreachable_results)}):')\n        for (match_tuple, reason) in unreachable_results:\n            print('  > Source: ' + match_tuple.source)\n            print('    Name: ' + match_tuple.name)\n            print('    Link: ' + match_tuple.link)\n            if reason is not None:\n                print('    Reason: ' + reason)\n        sys.exit(1)\n    print('No Unreachable link found.')",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    print('Finding all markdown files in the current directory...')\n    project_root = (pathlib.Path(__file__).parent / '..').resolve()\n    markdown_files = project_root.glob('**/*.md')\n    all_matches = set()\n    url_regex = re.compile('\\\\[([^!][^\\\\]]+)\\\\]\\\\(([^)(]+)\\\\)')\n    for markdown_file in markdown_files:\n        with open(markdown_file) as handle:\n            for line in handle.readlines():\n                matches = url_regex.findall(line)\n                for (name, link) in matches:\n                    if 'localhost' not in link:\n                        all_matches.add(MatchTuple(source=str(markdown_file), name=name, link=link))\n    print(f'  {len(all_matches)} markdown files found')\n    print('Checking to make sure we can retrieve each link...')\n    with Pool(processes=THREADS) as pool:\n        results = pool.map(link_ok, [match for match in list(all_matches)])\n    unreachable_results = [(match_tuple, reason) for (match_tuple, success, reason) in results if not success]\n    if unreachable_results:\n        print(f'Unreachable links ({len(unreachable_results)}):')\n        for (match_tuple, reason) in unreachable_results:\n            print('  > Source: ' + match_tuple.source)\n            print('    Name: ' + match_tuple.name)\n            print('    Link: ' + match_tuple.link)\n            if reason is not None:\n                print('    Reason: ' + reason)\n        sys.exit(1)\n    print('No Unreachable link found.')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('Finding all markdown files in the current directory...')\n    project_root = (pathlib.Path(__file__).parent / '..').resolve()\n    markdown_files = project_root.glob('**/*.md')\n    all_matches = set()\n    url_regex = re.compile('\\\\[([^!][^\\\\]]+)\\\\]\\\\(([^)(]+)\\\\)')\n    for markdown_file in markdown_files:\n        with open(markdown_file) as handle:\n            for line in handle.readlines():\n                matches = url_regex.findall(line)\n                for (name, link) in matches:\n                    if 'localhost' not in link:\n                        all_matches.add(MatchTuple(source=str(markdown_file), name=name, link=link))\n    print(f'  {len(all_matches)} markdown files found')\n    print('Checking to make sure we can retrieve each link...')\n    with Pool(processes=THREADS) as pool:\n        results = pool.map(link_ok, [match for match in list(all_matches)])\n    unreachable_results = [(match_tuple, reason) for (match_tuple, success, reason) in results if not success]\n    if unreachable_results:\n        print(f'Unreachable links ({len(unreachable_results)}):')\n        for (match_tuple, reason) in unreachable_results:\n            print('  > Source: ' + match_tuple.source)\n            print('    Name: ' + match_tuple.name)\n            print('    Link: ' + match_tuple.link)\n            if reason is not None:\n                print('    Reason: ' + reason)\n        sys.exit(1)\n    print('No Unreachable link found.')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('Finding all markdown files in the current directory...')\n    project_root = (pathlib.Path(__file__).parent / '..').resolve()\n    markdown_files = project_root.glob('**/*.md')\n    all_matches = set()\n    url_regex = re.compile('\\\\[([^!][^\\\\]]+)\\\\]\\\\(([^)(]+)\\\\)')\n    for markdown_file in markdown_files:\n        with open(markdown_file) as handle:\n            for line in handle.readlines():\n                matches = url_regex.findall(line)\n                for (name, link) in matches:\n                    if 'localhost' not in link:\n                        all_matches.add(MatchTuple(source=str(markdown_file), name=name, link=link))\n    print(f'  {len(all_matches)} markdown files found')\n    print('Checking to make sure we can retrieve each link...')\n    with Pool(processes=THREADS) as pool:\n        results = pool.map(link_ok, [match for match in list(all_matches)])\n    unreachable_results = [(match_tuple, reason) for (match_tuple, success, reason) in results if not success]\n    if unreachable_results:\n        print(f'Unreachable links ({len(unreachable_results)}):')\n        for (match_tuple, reason) in unreachable_results:\n            print('  > Source: ' + match_tuple.source)\n            print('    Name: ' + match_tuple.name)\n            print('    Link: ' + match_tuple.link)\n            if reason is not None:\n                print('    Reason: ' + reason)\n        sys.exit(1)\n    print('No Unreachable link found.')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('Finding all markdown files in the current directory...')\n    project_root = (pathlib.Path(__file__).parent / '..').resolve()\n    markdown_files = project_root.glob('**/*.md')\n    all_matches = set()\n    url_regex = re.compile('\\\\[([^!][^\\\\]]+)\\\\]\\\\(([^)(]+)\\\\)')\n    for markdown_file in markdown_files:\n        with open(markdown_file) as handle:\n            for line in handle.readlines():\n                matches = url_regex.findall(line)\n                for (name, link) in matches:\n                    if 'localhost' not in link:\n                        all_matches.add(MatchTuple(source=str(markdown_file), name=name, link=link))\n    print(f'  {len(all_matches)} markdown files found')\n    print('Checking to make sure we can retrieve each link...')\n    with Pool(processes=THREADS) as pool:\n        results = pool.map(link_ok, [match for match in list(all_matches)])\n    unreachable_results = [(match_tuple, reason) for (match_tuple, success, reason) in results if not success]\n    if unreachable_results:\n        print(f'Unreachable links ({len(unreachable_results)}):')\n        for (match_tuple, reason) in unreachable_results:\n            print('  > Source: ' + match_tuple.source)\n            print('    Name: ' + match_tuple.name)\n            print('    Link: ' + match_tuple.link)\n            if reason is not None:\n                print('    Reason: ' + reason)\n        sys.exit(1)\n    print('No Unreachable link found.')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('Finding all markdown files in the current directory...')\n    project_root = (pathlib.Path(__file__).parent / '..').resolve()\n    markdown_files = project_root.glob('**/*.md')\n    all_matches = set()\n    url_regex = re.compile('\\\\[([^!][^\\\\]]+)\\\\]\\\\(([^)(]+)\\\\)')\n    for markdown_file in markdown_files:\n        with open(markdown_file) as handle:\n            for line in handle.readlines():\n                matches = url_regex.findall(line)\n                for (name, link) in matches:\n                    if 'localhost' not in link:\n                        all_matches.add(MatchTuple(source=str(markdown_file), name=name, link=link))\n    print(f'  {len(all_matches)} markdown files found')\n    print('Checking to make sure we can retrieve each link...')\n    with Pool(processes=THREADS) as pool:\n        results = pool.map(link_ok, [match for match in list(all_matches)])\n    unreachable_results = [(match_tuple, reason) for (match_tuple, success, reason) in results if not success]\n    if unreachable_results:\n        print(f'Unreachable links ({len(unreachable_results)}):')\n        for (match_tuple, reason) in unreachable_results:\n            print('  > Source: ' + match_tuple.source)\n            print('    Name: ' + match_tuple.name)\n            print('    Link: ' + match_tuple.link)\n            if reason is not None:\n                print('    Reason: ' + reason)\n        sys.exit(1)\n    print('No Unreachable link found.')"
        ]
    }
]