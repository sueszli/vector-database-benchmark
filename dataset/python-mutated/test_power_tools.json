[
    {
        "func_name": "test_multi_step_dyad_completion",
        "original": "def test_multi_step_dyad_completion(self) -> None:\n    \"\"\"\n        Consider four market equilibrium problems.\n\n        The budgets \"b\" in these problems are chosen so that canonicalization\n        of geo_mean(u, b) hits a recursive code-path in power_tools.dyad_completion(...).\n\n        The reference solution is computed by taking the log of the geo_mean objective,\n        which has the effect of making the problem ExpCone representable.\n        \"\"\"\n    if 'MOSEK' in cp.installed_solvers():\n        log_solve_args = {'solver': 'MOSEK'}\n    else:\n        log_solve_args = {'solver': 'ECOS'}\n    n_buyer = 5\n    n_items = 7\n    np.random.seed(0)\n    V = 0.5 * (1 + np.random.rand(n_buyer, n_items))\n    X = cp.Variable(shape=(n_buyer, n_items), nonneg=True)\n    cons = [cp.sum(X, axis=0) <= 1]\n    u = cp.sum(cp.multiply(V, X), axis=1)\n    bs = np.array([[110, 14, 6, 77, 108], [15.0, 4.0, 8.0, 0.0, 9.0], [14.0, 21.0, 217.0, 57.0, 6.0], [3.0, 36.0, 77.0, 8.0, 8.0]])\n    for (i, b) in enumerate(bs):\n        log_objective = cp.Maximize(b @ cp.log(u))\n        log_prob = cp.Problem(log_objective, cons)\n        log_prob.solve(**log_solve_args)\n        expect_X = X.value\n        geo_objective = cp.Maximize(cp.geo_mean(u, b))\n        geo_prob = cp.Problem(geo_objective, cons)\n        geo_prob.solve()\n        actual_X = X.value\n        try:\n            self.assertItemsAlmostEqual(actual_X, expect_X, places=3)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when b={str(b)}).')\n            log_prob.solve(**log_solve_args, verbose=True)\n            print(X.value)\n            geo_prob.solve(verbose=True)\n            print(X.value)\n            print('The valuation matrix was')\n            print(V)\n            raise e",
        "mutated": [
            "def test_multi_step_dyad_completion(self) -> None:\n    if False:\n        i = 10\n    '\\n        Consider four market equilibrium problems.\\n\\n        The budgets \"b\" in these problems are chosen so that canonicalization\\n        of geo_mean(u, b) hits a recursive code-path in power_tools.dyad_completion(...).\\n\\n        The reference solution is computed by taking the log of the geo_mean objective,\\n        which has the effect of making the problem ExpCone representable.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        log_solve_args = {'solver': 'MOSEK'}\n    else:\n        log_solve_args = {'solver': 'ECOS'}\n    n_buyer = 5\n    n_items = 7\n    np.random.seed(0)\n    V = 0.5 * (1 + np.random.rand(n_buyer, n_items))\n    X = cp.Variable(shape=(n_buyer, n_items), nonneg=True)\n    cons = [cp.sum(X, axis=0) <= 1]\n    u = cp.sum(cp.multiply(V, X), axis=1)\n    bs = np.array([[110, 14, 6, 77, 108], [15.0, 4.0, 8.0, 0.0, 9.0], [14.0, 21.0, 217.0, 57.0, 6.0], [3.0, 36.0, 77.0, 8.0, 8.0]])\n    for (i, b) in enumerate(bs):\n        log_objective = cp.Maximize(b @ cp.log(u))\n        log_prob = cp.Problem(log_objective, cons)\n        log_prob.solve(**log_solve_args)\n        expect_X = X.value\n        geo_objective = cp.Maximize(cp.geo_mean(u, b))\n        geo_prob = cp.Problem(geo_objective, cons)\n        geo_prob.solve()\n        actual_X = X.value\n        try:\n            self.assertItemsAlmostEqual(actual_X, expect_X, places=3)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when b={str(b)}).')\n            log_prob.solve(**log_solve_args, verbose=True)\n            print(X.value)\n            geo_prob.solve(verbose=True)\n            print(X.value)\n            print('The valuation matrix was')\n            print(V)\n            raise e",
            "def test_multi_step_dyad_completion(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Consider four market equilibrium problems.\\n\\n        The budgets \"b\" in these problems are chosen so that canonicalization\\n        of geo_mean(u, b) hits a recursive code-path in power_tools.dyad_completion(...).\\n\\n        The reference solution is computed by taking the log of the geo_mean objective,\\n        which has the effect of making the problem ExpCone representable.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        log_solve_args = {'solver': 'MOSEK'}\n    else:\n        log_solve_args = {'solver': 'ECOS'}\n    n_buyer = 5\n    n_items = 7\n    np.random.seed(0)\n    V = 0.5 * (1 + np.random.rand(n_buyer, n_items))\n    X = cp.Variable(shape=(n_buyer, n_items), nonneg=True)\n    cons = [cp.sum(X, axis=0) <= 1]\n    u = cp.sum(cp.multiply(V, X), axis=1)\n    bs = np.array([[110, 14, 6, 77, 108], [15.0, 4.0, 8.0, 0.0, 9.0], [14.0, 21.0, 217.0, 57.0, 6.0], [3.0, 36.0, 77.0, 8.0, 8.0]])\n    for (i, b) in enumerate(bs):\n        log_objective = cp.Maximize(b @ cp.log(u))\n        log_prob = cp.Problem(log_objective, cons)\n        log_prob.solve(**log_solve_args)\n        expect_X = X.value\n        geo_objective = cp.Maximize(cp.geo_mean(u, b))\n        geo_prob = cp.Problem(geo_objective, cons)\n        geo_prob.solve()\n        actual_X = X.value\n        try:\n            self.assertItemsAlmostEqual(actual_X, expect_X, places=3)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when b={str(b)}).')\n            log_prob.solve(**log_solve_args, verbose=True)\n            print(X.value)\n            geo_prob.solve(verbose=True)\n            print(X.value)\n            print('The valuation matrix was')\n            print(V)\n            raise e",
            "def test_multi_step_dyad_completion(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Consider four market equilibrium problems.\\n\\n        The budgets \"b\" in these problems are chosen so that canonicalization\\n        of geo_mean(u, b) hits a recursive code-path in power_tools.dyad_completion(...).\\n\\n        The reference solution is computed by taking the log of the geo_mean objective,\\n        which has the effect of making the problem ExpCone representable.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        log_solve_args = {'solver': 'MOSEK'}\n    else:\n        log_solve_args = {'solver': 'ECOS'}\n    n_buyer = 5\n    n_items = 7\n    np.random.seed(0)\n    V = 0.5 * (1 + np.random.rand(n_buyer, n_items))\n    X = cp.Variable(shape=(n_buyer, n_items), nonneg=True)\n    cons = [cp.sum(X, axis=0) <= 1]\n    u = cp.sum(cp.multiply(V, X), axis=1)\n    bs = np.array([[110, 14, 6, 77, 108], [15.0, 4.0, 8.0, 0.0, 9.0], [14.0, 21.0, 217.0, 57.0, 6.0], [3.0, 36.0, 77.0, 8.0, 8.0]])\n    for (i, b) in enumerate(bs):\n        log_objective = cp.Maximize(b @ cp.log(u))\n        log_prob = cp.Problem(log_objective, cons)\n        log_prob.solve(**log_solve_args)\n        expect_X = X.value\n        geo_objective = cp.Maximize(cp.geo_mean(u, b))\n        geo_prob = cp.Problem(geo_objective, cons)\n        geo_prob.solve()\n        actual_X = X.value\n        try:\n            self.assertItemsAlmostEqual(actual_X, expect_X, places=3)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when b={str(b)}).')\n            log_prob.solve(**log_solve_args, verbose=True)\n            print(X.value)\n            geo_prob.solve(verbose=True)\n            print(X.value)\n            print('The valuation matrix was')\n            print(V)\n            raise e",
            "def test_multi_step_dyad_completion(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Consider four market equilibrium problems.\\n\\n        The budgets \"b\" in these problems are chosen so that canonicalization\\n        of geo_mean(u, b) hits a recursive code-path in power_tools.dyad_completion(...).\\n\\n        The reference solution is computed by taking the log of the geo_mean objective,\\n        which has the effect of making the problem ExpCone representable.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        log_solve_args = {'solver': 'MOSEK'}\n    else:\n        log_solve_args = {'solver': 'ECOS'}\n    n_buyer = 5\n    n_items = 7\n    np.random.seed(0)\n    V = 0.5 * (1 + np.random.rand(n_buyer, n_items))\n    X = cp.Variable(shape=(n_buyer, n_items), nonneg=True)\n    cons = [cp.sum(X, axis=0) <= 1]\n    u = cp.sum(cp.multiply(V, X), axis=1)\n    bs = np.array([[110, 14, 6, 77, 108], [15.0, 4.0, 8.0, 0.0, 9.0], [14.0, 21.0, 217.0, 57.0, 6.0], [3.0, 36.0, 77.0, 8.0, 8.0]])\n    for (i, b) in enumerate(bs):\n        log_objective = cp.Maximize(b @ cp.log(u))\n        log_prob = cp.Problem(log_objective, cons)\n        log_prob.solve(**log_solve_args)\n        expect_X = X.value\n        geo_objective = cp.Maximize(cp.geo_mean(u, b))\n        geo_prob = cp.Problem(geo_objective, cons)\n        geo_prob.solve()\n        actual_X = X.value\n        try:\n            self.assertItemsAlmostEqual(actual_X, expect_X, places=3)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when b={str(b)}).')\n            log_prob.solve(**log_solve_args, verbose=True)\n            print(X.value)\n            geo_prob.solve(verbose=True)\n            print(X.value)\n            print('The valuation matrix was')\n            print(V)\n            raise e",
            "def test_multi_step_dyad_completion(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Consider four market equilibrium problems.\\n\\n        The budgets \"b\" in these problems are chosen so that canonicalization\\n        of geo_mean(u, b) hits a recursive code-path in power_tools.dyad_completion(...).\\n\\n        The reference solution is computed by taking the log of the geo_mean objective,\\n        which has the effect of making the problem ExpCone representable.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        log_solve_args = {'solver': 'MOSEK'}\n    else:\n        log_solve_args = {'solver': 'ECOS'}\n    n_buyer = 5\n    n_items = 7\n    np.random.seed(0)\n    V = 0.5 * (1 + np.random.rand(n_buyer, n_items))\n    X = cp.Variable(shape=(n_buyer, n_items), nonneg=True)\n    cons = [cp.sum(X, axis=0) <= 1]\n    u = cp.sum(cp.multiply(V, X), axis=1)\n    bs = np.array([[110, 14, 6, 77, 108], [15.0, 4.0, 8.0, 0.0, 9.0], [14.0, 21.0, 217.0, 57.0, 6.0], [3.0, 36.0, 77.0, 8.0, 8.0]])\n    for (i, b) in enumerate(bs):\n        log_objective = cp.Maximize(b @ cp.log(u))\n        log_prob = cp.Problem(log_objective, cons)\n        log_prob.solve(**log_solve_args)\n        expect_X = X.value\n        geo_objective = cp.Maximize(cp.geo_mean(u, b))\n        geo_prob = cp.Problem(geo_objective, cons)\n        geo_prob.solve()\n        actual_X = X.value\n        try:\n            self.assertItemsAlmostEqual(actual_X, expect_X, places=3)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when b={str(b)}).')\n            log_prob.solve(**log_solve_args, verbose=True)\n            print(X.value)\n            geo_prob.solve(verbose=True)\n            print(X.value)\n            print('The valuation matrix was')\n            print(V)\n            raise e"
        ]
    },
    {
        "func_name": "test_3d_power_cone_approx",
        "original": "def test_3d_power_cone_approx(self):\n    \"\"\"\n        Use\n            geo_mean((x,y), (alpha, 1-alpha)) >= |z|\n        as a reformulation of\n            PowCone3D(x, y, z, alpha).\n\n        Check validity of the reformulation by solving\n        orthogonal projection problems.\n        \"\"\"\n    if 'MOSEK' in cp.installed_solvers():\n        proj_solve_args = {'solver': 'MOSEK'}\n    else:\n        proj_solve_args = {'solver': 'SCS', 'eps': 1e-10}\n    min_numerator = 2\n    denominator = 25\n    x = cp.Variable(3)\n    np.random.seed(0)\n    y = 10 * np.random.rand(3)\n    for (i, numerator) in enumerate(range(min_numerator, denominator, 3)):\n        alpha_float = numerator / denominator\n        y[2] = y[0] ** alpha_float * y[1] ** (1 - alpha_float) + 0.05\n        objective = cp.Minimize(cp.norm(y - x, 2))\n        actual_constraints = [cp.constraints.PowCone3D(x[0], x[1], x[2], [alpha_float])]\n        actual_prob = cp.Problem(objective, actual_constraints)\n        actual_prob.solve(**proj_solve_args)\n        actual_x = x.value.copy()\n        weights = np.array([alpha_float, 1 - alpha_float])\n        approx_constraints = [cp.geo_mean(x[:2], weights) >= cp.abs(x[2])]\n        approx_prob = cp.Problem(objective, approx_constraints)\n        approx_prob.solve()\n        approx_x = x.value.copy()\n        try:\n            self.assertItemsAlmostEqual(actual_x, approx_x, places=4)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when alpha={alpha_float}).')\n            raise e",
        "mutated": [
            "def test_3d_power_cone_approx(self):\n    if False:\n        i = 10\n    '\\n        Use\\n            geo_mean((x,y), (alpha, 1-alpha)) >= |z|\\n        as a reformulation of\\n            PowCone3D(x, y, z, alpha).\\n\\n        Check validity of the reformulation by solving\\n        orthogonal projection problems.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        proj_solve_args = {'solver': 'MOSEK'}\n    else:\n        proj_solve_args = {'solver': 'SCS', 'eps': 1e-10}\n    min_numerator = 2\n    denominator = 25\n    x = cp.Variable(3)\n    np.random.seed(0)\n    y = 10 * np.random.rand(3)\n    for (i, numerator) in enumerate(range(min_numerator, denominator, 3)):\n        alpha_float = numerator / denominator\n        y[2] = y[0] ** alpha_float * y[1] ** (1 - alpha_float) + 0.05\n        objective = cp.Minimize(cp.norm(y - x, 2))\n        actual_constraints = [cp.constraints.PowCone3D(x[0], x[1], x[2], [alpha_float])]\n        actual_prob = cp.Problem(objective, actual_constraints)\n        actual_prob.solve(**proj_solve_args)\n        actual_x = x.value.copy()\n        weights = np.array([alpha_float, 1 - alpha_float])\n        approx_constraints = [cp.geo_mean(x[:2], weights) >= cp.abs(x[2])]\n        approx_prob = cp.Problem(objective, approx_constraints)\n        approx_prob.solve()\n        approx_x = x.value.copy()\n        try:\n            self.assertItemsAlmostEqual(actual_x, approx_x, places=4)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when alpha={alpha_float}).')\n            raise e",
            "def test_3d_power_cone_approx(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Use\\n            geo_mean((x,y), (alpha, 1-alpha)) >= |z|\\n        as a reformulation of\\n            PowCone3D(x, y, z, alpha).\\n\\n        Check validity of the reformulation by solving\\n        orthogonal projection problems.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        proj_solve_args = {'solver': 'MOSEK'}\n    else:\n        proj_solve_args = {'solver': 'SCS', 'eps': 1e-10}\n    min_numerator = 2\n    denominator = 25\n    x = cp.Variable(3)\n    np.random.seed(0)\n    y = 10 * np.random.rand(3)\n    for (i, numerator) in enumerate(range(min_numerator, denominator, 3)):\n        alpha_float = numerator / denominator\n        y[2] = y[0] ** alpha_float * y[1] ** (1 - alpha_float) + 0.05\n        objective = cp.Minimize(cp.norm(y - x, 2))\n        actual_constraints = [cp.constraints.PowCone3D(x[0], x[1], x[2], [alpha_float])]\n        actual_prob = cp.Problem(objective, actual_constraints)\n        actual_prob.solve(**proj_solve_args)\n        actual_x = x.value.copy()\n        weights = np.array([alpha_float, 1 - alpha_float])\n        approx_constraints = [cp.geo_mean(x[:2], weights) >= cp.abs(x[2])]\n        approx_prob = cp.Problem(objective, approx_constraints)\n        approx_prob.solve()\n        approx_x = x.value.copy()\n        try:\n            self.assertItemsAlmostEqual(actual_x, approx_x, places=4)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when alpha={alpha_float}).')\n            raise e",
            "def test_3d_power_cone_approx(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Use\\n            geo_mean((x,y), (alpha, 1-alpha)) >= |z|\\n        as a reformulation of\\n            PowCone3D(x, y, z, alpha).\\n\\n        Check validity of the reformulation by solving\\n        orthogonal projection problems.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        proj_solve_args = {'solver': 'MOSEK'}\n    else:\n        proj_solve_args = {'solver': 'SCS', 'eps': 1e-10}\n    min_numerator = 2\n    denominator = 25\n    x = cp.Variable(3)\n    np.random.seed(0)\n    y = 10 * np.random.rand(3)\n    for (i, numerator) in enumerate(range(min_numerator, denominator, 3)):\n        alpha_float = numerator / denominator\n        y[2] = y[0] ** alpha_float * y[1] ** (1 - alpha_float) + 0.05\n        objective = cp.Minimize(cp.norm(y - x, 2))\n        actual_constraints = [cp.constraints.PowCone3D(x[0], x[1], x[2], [alpha_float])]\n        actual_prob = cp.Problem(objective, actual_constraints)\n        actual_prob.solve(**proj_solve_args)\n        actual_x = x.value.copy()\n        weights = np.array([alpha_float, 1 - alpha_float])\n        approx_constraints = [cp.geo_mean(x[:2], weights) >= cp.abs(x[2])]\n        approx_prob = cp.Problem(objective, approx_constraints)\n        approx_prob.solve()\n        approx_x = x.value.copy()\n        try:\n            self.assertItemsAlmostEqual(actual_x, approx_x, places=4)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when alpha={alpha_float}).')\n            raise e",
            "def test_3d_power_cone_approx(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Use\\n            geo_mean((x,y), (alpha, 1-alpha)) >= |z|\\n        as a reformulation of\\n            PowCone3D(x, y, z, alpha).\\n\\n        Check validity of the reformulation by solving\\n        orthogonal projection problems.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        proj_solve_args = {'solver': 'MOSEK'}\n    else:\n        proj_solve_args = {'solver': 'SCS', 'eps': 1e-10}\n    min_numerator = 2\n    denominator = 25\n    x = cp.Variable(3)\n    np.random.seed(0)\n    y = 10 * np.random.rand(3)\n    for (i, numerator) in enumerate(range(min_numerator, denominator, 3)):\n        alpha_float = numerator / denominator\n        y[2] = y[0] ** alpha_float * y[1] ** (1 - alpha_float) + 0.05\n        objective = cp.Minimize(cp.norm(y - x, 2))\n        actual_constraints = [cp.constraints.PowCone3D(x[0], x[1], x[2], [alpha_float])]\n        actual_prob = cp.Problem(objective, actual_constraints)\n        actual_prob.solve(**proj_solve_args)\n        actual_x = x.value.copy()\n        weights = np.array([alpha_float, 1 - alpha_float])\n        approx_constraints = [cp.geo_mean(x[:2], weights) >= cp.abs(x[2])]\n        approx_prob = cp.Problem(objective, approx_constraints)\n        approx_prob.solve()\n        approx_x = x.value.copy()\n        try:\n            self.assertItemsAlmostEqual(actual_x, approx_x, places=4)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when alpha={alpha_float}).')\n            raise e",
            "def test_3d_power_cone_approx(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Use\\n            geo_mean((x,y), (alpha, 1-alpha)) >= |z|\\n        as a reformulation of\\n            PowCone3D(x, y, z, alpha).\\n\\n        Check validity of the reformulation by solving\\n        orthogonal projection problems.\\n        '\n    if 'MOSEK' in cp.installed_solvers():\n        proj_solve_args = {'solver': 'MOSEK'}\n    else:\n        proj_solve_args = {'solver': 'SCS', 'eps': 1e-10}\n    min_numerator = 2\n    denominator = 25\n    x = cp.Variable(3)\n    np.random.seed(0)\n    y = 10 * np.random.rand(3)\n    for (i, numerator) in enumerate(range(min_numerator, denominator, 3)):\n        alpha_float = numerator / denominator\n        y[2] = y[0] ** alpha_float * y[1] ** (1 - alpha_float) + 0.05\n        objective = cp.Minimize(cp.norm(y - x, 2))\n        actual_constraints = [cp.constraints.PowCone3D(x[0], x[1], x[2], [alpha_float])]\n        actual_prob = cp.Problem(objective, actual_constraints)\n        actual_prob.solve(**proj_solve_args)\n        actual_x = x.value.copy()\n        weights = np.array([alpha_float, 1 - alpha_float])\n        approx_constraints = [cp.geo_mean(x[:2], weights) >= cp.abs(x[2])]\n        approx_prob = cp.Problem(objective, approx_constraints)\n        approx_prob.solve()\n        approx_x = x.value.copy()\n        try:\n            self.assertItemsAlmostEqual(actual_x, approx_x, places=4)\n        except AssertionError as e:\n            print(f'Failure at index {i} (when alpha={alpha_float}).')\n            raise e"
        ]
    }
]