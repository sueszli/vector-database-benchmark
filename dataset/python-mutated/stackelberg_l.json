[
    {
        "func_name": "solve_stackelberg",
        "original": "def solve_stackelberg(game, is_first_leader=True):\n    \"\"\"Solves the optimal mixed strategty to commit to for the leader.\n\n  Args:\n    game: a pyspiel game,\n    is_first_leader: if true, then player 0 is the leader, o.w. player 1 is\n      the leader.\n\n  Returns:\n    (player0 strategy, player1 strategy, player0 payoff, player1 payoff) at an\n    SSE.\n  \"\"\"\n    p_mat = game_payoffs_array(game)\n    assert len(p_mat) == 2\n    if is_first_leader:\n        (leader_payoff, follower_payoff) = (p_mat[0], p_mat[1])\n    else:\n        (leader_payoff, follower_payoff) = (p_mat[1].T, p_mat[0].T)\n    (num_leader_strategies, num_follower_strategies) = leader_payoff.shape\n    leader_eq_value = -float('inf')\n    follower_eq_value = None\n    leader_eq_strategy = None\n    follower_eq_strategy = None\n    for t in range(num_follower_strategies):\n        p_s = cp.Variable(num_leader_strategies, nonneg=True)\n        constraints = [p_s <= 1, cp.sum(p_s) == 1]\n        for t_ in range(num_follower_strategies):\n            if t_ == t:\n                continue\n            constraints.append(p_s @ follower_payoff[:, t_] <= p_s @ follower_payoff[:, t])\n        prob = cp.Problem(cp.Maximize(p_s @ leader_payoff[:, t]), constraints)\n        prob.solve()\n        p_s_value = p_s.value\n        if p_s_value is None:\n            continue\n        leader_strategy = _simplex_projection(p_s.value.reshape(-1)).reshape(-1, 1)\n        leader_value = leader_strategy.T.dot(leader_payoff)[0, t]\n        if leader_value > leader_eq_value:\n            leader_eq_strategy = leader_strategy\n            follower_eq_strategy = t\n            leader_eq_value = leader_value\n            follower_eq_value = leader_strategy.T.dot(follower_payoff)[0, t]\n    assert leader_eq_strategy is not None, p_mat\n    if is_first_leader:\n        return (leader_eq_strategy.reshape(-1), np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_value, follower_eq_value)\n    else:\n        return (np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_strategy.reshape(-1), follower_eq_value, leader_eq_value)",
        "mutated": [
            "def solve_stackelberg(game, is_first_leader=True):\n    if False:\n        i = 10\n    'Solves the optimal mixed strategty to commit to for the leader.\\n\\n  Args:\\n    game: a pyspiel game,\\n    is_first_leader: if true, then player 0 is the leader, o.w. player 1 is\\n      the leader.\\n\\n  Returns:\\n    (player0 strategy, player1 strategy, player0 payoff, player1 payoff) at an\\n    SSE.\\n  '\n    p_mat = game_payoffs_array(game)\n    assert len(p_mat) == 2\n    if is_first_leader:\n        (leader_payoff, follower_payoff) = (p_mat[0], p_mat[1])\n    else:\n        (leader_payoff, follower_payoff) = (p_mat[1].T, p_mat[0].T)\n    (num_leader_strategies, num_follower_strategies) = leader_payoff.shape\n    leader_eq_value = -float('inf')\n    follower_eq_value = None\n    leader_eq_strategy = None\n    follower_eq_strategy = None\n    for t in range(num_follower_strategies):\n        p_s = cp.Variable(num_leader_strategies, nonneg=True)\n        constraints = [p_s <= 1, cp.sum(p_s) == 1]\n        for t_ in range(num_follower_strategies):\n            if t_ == t:\n                continue\n            constraints.append(p_s @ follower_payoff[:, t_] <= p_s @ follower_payoff[:, t])\n        prob = cp.Problem(cp.Maximize(p_s @ leader_payoff[:, t]), constraints)\n        prob.solve()\n        p_s_value = p_s.value\n        if p_s_value is None:\n            continue\n        leader_strategy = _simplex_projection(p_s.value.reshape(-1)).reshape(-1, 1)\n        leader_value = leader_strategy.T.dot(leader_payoff)[0, t]\n        if leader_value > leader_eq_value:\n            leader_eq_strategy = leader_strategy\n            follower_eq_strategy = t\n            leader_eq_value = leader_value\n            follower_eq_value = leader_strategy.T.dot(follower_payoff)[0, t]\n    assert leader_eq_strategy is not None, p_mat\n    if is_first_leader:\n        return (leader_eq_strategy.reshape(-1), np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_value, follower_eq_value)\n    else:\n        return (np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_strategy.reshape(-1), follower_eq_value, leader_eq_value)",
            "def solve_stackelberg(game, is_first_leader=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Solves the optimal mixed strategty to commit to for the leader.\\n\\n  Args:\\n    game: a pyspiel game,\\n    is_first_leader: if true, then player 0 is the leader, o.w. player 1 is\\n      the leader.\\n\\n  Returns:\\n    (player0 strategy, player1 strategy, player0 payoff, player1 payoff) at an\\n    SSE.\\n  '\n    p_mat = game_payoffs_array(game)\n    assert len(p_mat) == 2\n    if is_first_leader:\n        (leader_payoff, follower_payoff) = (p_mat[0], p_mat[1])\n    else:\n        (leader_payoff, follower_payoff) = (p_mat[1].T, p_mat[0].T)\n    (num_leader_strategies, num_follower_strategies) = leader_payoff.shape\n    leader_eq_value = -float('inf')\n    follower_eq_value = None\n    leader_eq_strategy = None\n    follower_eq_strategy = None\n    for t in range(num_follower_strategies):\n        p_s = cp.Variable(num_leader_strategies, nonneg=True)\n        constraints = [p_s <= 1, cp.sum(p_s) == 1]\n        for t_ in range(num_follower_strategies):\n            if t_ == t:\n                continue\n            constraints.append(p_s @ follower_payoff[:, t_] <= p_s @ follower_payoff[:, t])\n        prob = cp.Problem(cp.Maximize(p_s @ leader_payoff[:, t]), constraints)\n        prob.solve()\n        p_s_value = p_s.value\n        if p_s_value is None:\n            continue\n        leader_strategy = _simplex_projection(p_s.value.reshape(-1)).reshape(-1, 1)\n        leader_value = leader_strategy.T.dot(leader_payoff)[0, t]\n        if leader_value > leader_eq_value:\n            leader_eq_strategy = leader_strategy\n            follower_eq_strategy = t\n            leader_eq_value = leader_value\n            follower_eq_value = leader_strategy.T.dot(follower_payoff)[0, t]\n    assert leader_eq_strategy is not None, p_mat\n    if is_first_leader:\n        return (leader_eq_strategy.reshape(-1), np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_value, follower_eq_value)\n    else:\n        return (np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_strategy.reshape(-1), follower_eq_value, leader_eq_value)",
            "def solve_stackelberg(game, is_first_leader=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Solves the optimal mixed strategty to commit to for the leader.\\n\\n  Args:\\n    game: a pyspiel game,\\n    is_first_leader: if true, then player 0 is the leader, o.w. player 1 is\\n      the leader.\\n\\n  Returns:\\n    (player0 strategy, player1 strategy, player0 payoff, player1 payoff) at an\\n    SSE.\\n  '\n    p_mat = game_payoffs_array(game)\n    assert len(p_mat) == 2\n    if is_first_leader:\n        (leader_payoff, follower_payoff) = (p_mat[0], p_mat[1])\n    else:\n        (leader_payoff, follower_payoff) = (p_mat[1].T, p_mat[0].T)\n    (num_leader_strategies, num_follower_strategies) = leader_payoff.shape\n    leader_eq_value = -float('inf')\n    follower_eq_value = None\n    leader_eq_strategy = None\n    follower_eq_strategy = None\n    for t in range(num_follower_strategies):\n        p_s = cp.Variable(num_leader_strategies, nonneg=True)\n        constraints = [p_s <= 1, cp.sum(p_s) == 1]\n        for t_ in range(num_follower_strategies):\n            if t_ == t:\n                continue\n            constraints.append(p_s @ follower_payoff[:, t_] <= p_s @ follower_payoff[:, t])\n        prob = cp.Problem(cp.Maximize(p_s @ leader_payoff[:, t]), constraints)\n        prob.solve()\n        p_s_value = p_s.value\n        if p_s_value is None:\n            continue\n        leader_strategy = _simplex_projection(p_s.value.reshape(-1)).reshape(-1, 1)\n        leader_value = leader_strategy.T.dot(leader_payoff)[0, t]\n        if leader_value > leader_eq_value:\n            leader_eq_strategy = leader_strategy\n            follower_eq_strategy = t\n            leader_eq_value = leader_value\n            follower_eq_value = leader_strategy.T.dot(follower_payoff)[0, t]\n    assert leader_eq_strategy is not None, p_mat\n    if is_first_leader:\n        return (leader_eq_strategy.reshape(-1), np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_value, follower_eq_value)\n    else:\n        return (np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_strategy.reshape(-1), follower_eq_value, leader_eq_value)",
            "def solve_stackelberg(game, is_first_leader=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Solves the optimal mixed strategty to commit to for the leader.\\n\\n  Args:\\n    game: a pyspiel game,\\n    is_first_leader: if true, then player 0 is the leader, o.w. player 1 is\\n      the leader.\\n\\n  Returns:\\n    (player0 strategy, player1 strategy, player0 payoff, player1 payoff) at an\\n    SSE.\\n  '\n    p_mat = game_payoffs_array(game)\n    assert len(p_mat) == 2\n    if is_first_leader:\n        (leader_payoff, follower_payoff) = (p_mat[0], p_mat[1])\n    else:\n        (leader_payoff, follower_payoff) = (p_mat[1].T, p_mat[0].T)\n    (num_leader_strategies, num_follower_strategies) = leader_payoff.shape\n    leader_eq_value = -float('inf')\n    follower_eq_value = None\n    leader_eq_strategy = None\n    follower_eq_strategy = None\n    for t in range(num_follower_strategies):\n        p_s = cp.Variable(num_leader_strategies, nonneg=True)\n        constraints = [p_s <= 1, cp.sum(p_s) == 1]\n        for t_ in range(num_follower_strategies):\n            if t_ == t:\n                continue\n            constraints.append(p_s @ follower_payoff[:, t_] <= p_s @ follower_payoff[:, t])\n        prob = cp.Problem(cp.Maximize(p_s @ leader_payoff[:, t]), constraints)\n        prob.solve()\n        p_s_value = p_s.value\n        if p_s_value is None:\n            continue\n        leader_strategy = _simplex_projection(p_s.value.reshape(-1)).reshape(-1, 1)\n        leader_value = leader_strategy.T.dot(leader_payoff)[0, t]\n        if leader_value > leader_eq_value:\n            leader_eq_strategy = leader_strategy\n            follower_eq_strategy = t\n            leader_eq_value = leader_value\n            follower_eq_value = leader_strategy.T.dot(follower_payoff)[0, t]\n    assert leader_eq_strategy is not None, p_mat\n    if is_first_leader:\n        return (leader_eq_strategy.reshape(-1), np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_value, follower_eq_value)\n    else:\n        return (np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_strategy.reshape(-1), follower_eq_value, leader_eq_value)",
            "def solve_stackelberg(game, is_first_leader=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Solves the optimal mixed strategty to commit to for the leader.\\n\\n  Args:\\n    game: a pyspiel game,\\n    is_first_leader: if true, then player 0 is the leader, o.w. player 1 is\\n      the leader.\\n\\n  Returns:\\n    (player0 strategy, player1 strategy, player0 payoff, player1 payoff) at an\\n    SSE.\\n  '\n    p_mat = game_payoffs_array(game)\n    assert len(p_mat) == 2\n    if is_first_leader:\n        (leader_payoff, follower_payoff) = (p_mat[0], p_mat[1])\n    else:\n        (leader_payoff, follower_payoff) = (p_mat[1].T, p_mat[0].T)\n    (num_leader_strategies, num_follower_strategies) = leader_payoff.shape\n    leader_eq_value = -float('inf')\n    follower_eq_value = None\n    leader_eq_strategy = None\n    follower_eq_strategy = None\n    for t in range(num_follower_strategies):\n        p_s = cp.Variable(num_leader_strategies, nonneg=True)\n        constraints = [p_s <= 1, cp.sum(p_s) == 1]\n        for t_ in range(num_follower_strategies):\n            if t_ == t:\n                continue\n            constraints.append(p_s @ follower_payoff[:, t_] <= p_s @ follower_payoff[:, t])\n        prob = cp.Problem(cp.Maximize(p_s @ leader_payoff[:, t]), constraints)\n        prob.solve()\n        p_s_value = p_s.value\n        if p_s_value is None:\n            continue\n        leader_strategy = _simplex_projection(p_s.value.reshape(-1)).reshape(-1, 1)\n        leader_value = leader_strategy.T.dot(leader_payoff)[0, t]\n        if leader_value > leader_eq_value:\n            leader_eq_strategy = leader_strategy\n            follower_eq_strategy = t\n            leader_eq_value = leader_value\n            follower_eq_value = leader_strategy.T.dot(follower_payoff)[0, t]\n    assert leader_eq_strategy is not None, p_mat\n    if is_first_leader:\n        return (leader_eq_strategy.reshape(-1), np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_value, follower_eq_value)\n    else:\n        return (np.identity(num_follower_strategies)[follower_eq_strategy], leader_eq_strategy.reshape(-1), follower_eq_value, leader_eq_value)"
        ]
    }
]