[
    {
        "func_name": "__init__",
        "original": "def __init__(self, address=None, port=None, protocol=None, pattern=0, receive_mode=False, logging=False, **options):\n    \"\"\"\n        This constructor method initializes the object state and attributes of the NetGear class.\n\n        Parameters:\n            address (str): sets the valid network address of the Server/Client.\n            port (str): sets the valid Network Port of the Server/Client.\n            protocol (str): sets the valid messaging protocol between Server/Client.\n            pattern (int): sets the supported messaging pattern(flow of communication) between Server/Client\n            receive_mode (bool): select the Netgear's Mode of operation.\n            logging (bool): enables/disables logging.\n            options (dict): provides the flexibility to alter various NetGear internal properties.\n        \"\"\"\n    logcurr_vidgear_ver(logging=logging)\n    import_dependency_safe('zmq' if zmq is None else '', min_version='4.0', pkg_name='pyzmq')\n    import_dependency_safe('simplejpeg' if simplejpeg is None else '', error='log', min_version='1.6.1')\n    self.__logging = True if logging else False\n    valid_messaging_patterns = {0: (zmq.PAIR, zmq.PAIR), 1: (zmq.REQ, zmq.REP), 2: (zmq.PUB, zmq.SUB)}\n    msg_pattern = None\n    if isinstance(pattern, int) and pattern in valid_messaging_patterns.keys():\n        msg_pattern = valid_messaging_patterns[pattern]\n    else:\n        pattern = 0\n        msg_pattern = valid_messaging_patterns[pattern]\n        self.__logging and logger.warning('Wrong pattern value, Defaulting to `zmq.PAIR`! Kindly refer Docs for more Information.')\n    self.__pattern = pattern\n    if protocol is None or not protocol in ['tcp', 'ipc']:\n        protocol = 'tcp'\n        self.__logging and logger.warning('Protocol is not supported or not provided. Defaulting to `tcp` protocol!')\n    self.__msg_flag = 0\n    self.__msg_copy = False\n    self.__msg_track = False\n    self.__ssh_tunnel_mode = None\n    self.__ssh_tunnel_pwd = None\n    self.__ssh_tunnel_keyfile = None\n    self.__paramiko_present = False if paramiko is None else True\n    self.__multiserver_mode = False\n    self.__multiclient_mode = False\n    self.__bi_mode = False\n    valid_security_mech = {0: 'Grasslands', 1: 'StoneHouse', 2: 'IronHouse'}\n    self.__secure_mode = 0\n    auth_cert_dir = ''\n    self.__auth_publickeys_dir = ''\n    self.__auth_secretkeys_dir = ''\n    overwrite_cert = False\n    custom_cert_location = ''\n    self.__jpeg_compression = True if not simplejpeg is None else False\n    self.__jpeg_compression_quality = 90\n    self.__jpeg_compression_fastdct = True\n    self.__jpeg_compression_fastupsample = False\n    self.__jpeg_compression_colorspace = 'BGR'\n    self.__ex_compression_params = None\n    self.__return_data = None\n    self.__id = ''.join((secrets.choice(string.ascii_uppercase + string.digits) for i in range(8)))\n    self.__terminate = False\n    if pattern < 2:\n        self.__poll = zmq.Poller()\n        self.__max_retries = 3\n        self.__request_timeout = 4000\n    else:\n        self.__subscriber_timeout = None\n    options = {str(k).strip(): v for (k, v) in options.items()}\n    for (key, value) in options.items():\n        if key == 'multiserver_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiserver_mode = value\n            else:\n                self.__multiserver_mode = False\n                logger.critical('Multi-Server Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Server Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'multiclient_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiclient_mode = value\n            else:\n                self.__multiclient_mode = False\n                logger.critical('Multi-Client Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Client Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'bidirectional_mode' and isinstance(value, bool):\n            if pattern < 2:\n                self.__bi_mode = value\n            else:\n                self.__bi_mode = False\n                logger.warning('Bidirectional data transmission is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Bidirectional Mode is enabled. Kindly refer Docs for more Information!'.format(pattern))\n        elif key == 'secure_mode' and isinstance(value, int) and (value in valid_security_mech):\n            self.__secure_mode = value\n        elif key == 'custom_cert_location' and isinstance(value, str):\n            custom_cert_location = os.path.abspath(value)\n            assert os.path.isdir(custom_cert_location), '[NetGear:ERROR] :: `custom_cert_location` value must be the path to a valid directory!'\n            assert check_WriteAccess(custom_cert_location, is_windows=True if os.name == 'nt' else False, logging=self.__logging), \"[NetGear:ERROR] :: Permission Denied!, cannot write ZMQ authentication certificates to '{}' directory!\".format(value)\n        elif key == 'overwrite_cert' and isinstance(value, bool):\n            overwrite_cert = value\n        elif key == 'ssh_tunnel_mode' and isinstance(value, str):\n            self.__ssh_tunnel_mode = value.strip()\n        elif key == 'ssh_tunnel_pwd' and isinstance(value, str):\n            self.__ssh_tunnel_pwd = value\n        elif key == 'ssh_tunnel_keyfile' and isinstance(value, str):\n            self.__ssh_tunnel_keyfile = value if os.path.isfile(value) else None\n            if self.__ssh_tunnel_keyfile is None:\n                logger.warning('Discarded invalid or non-existential SSH Tunnel Key-file at {}!'.format(value))\n        elif key == 'jpeg_compression' and (not simplejpeg is None) and isinstance(value, (bool, str)):\n            if isinstance(value, str) and value.strip().upper() in ['RGB', 'BGR', 'RGBX', 'BGRX', 'XBGR', 'XRGB', 'GRAY', 'RGBA', 'BGRA', 'ABGR', 'ARGB', 'CMYK']:\n                self.__jpeg_compression_colorspace = value.strip().upper()\n                self.__jpeg_compression = True\n            else:\n                self.__jpeg_compression = value\n        elif key == 'jpeg_compression_quality' and isinstance(value, (int, float)):\n            if value >= 10 and value <= 100:\n                self.__jpeg_compression_quality = int(value)\n            else:\n                logger.warning('Skipped invalid `jpeg_compression_quality` value!')\n        elif key == 'jpeg_compression_fastdct' and isinstance(value, bool):\n            self.__jpeg_compression_fastdct = value\n        elif key == 'jpeg_compression_fastupsample' and isinstance(value, bool):\n            self.__jpeg_compression_fastupsample = value\n        elif key == 'max_retries' and isinstance(value, int) and (pattern < 2):\n            if value >= 0:\n                self.__max_retries = value\n            else:\n                logger.warning('Invalid `max_retries` value skipped!')\n        elif key == 'request_timeout' and isinstance(value, int) and (pattern < 2):\n            if value >= 4:\n                self.__request_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'subscriber_timeout' and isinstance(value, int) and (pattern == 2):\n            if value > 0:\n                self.__subscriber_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'flag' and isinstance(value, int):\n            self.__msg_flag = value\n        elif key == 'copy' and isinstance(value, bool):\n            self.__msg_copy = value\n        elif key == 'track' and isinstance(value, bool):\n            self.__msg_track = value\n        else:\n            pass\n    if self.__secure_mode:\n        if overwrite_cert:\n            if not receive_mode:\n                self.__logging and logger.warning('Overwriting ZMQ Authentication certificates over previous ones!')\n            else:\n                overwrite_cert = False\n                self.__logging and logger.critical(\"Overwriting ZMQ Authentication certificates is disabled for Client's end!\")\n        try:\n            if custom_cert_location:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(custom_cert_location, overwrite=overwrite_cert, logging=logging)\n            else:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(os.path.join(expanduser('~'), '.vidgear'), overwrite=overwrite_cert, logging=logging)\n            self.__logging and logger.debug('`{}` is the default location for storing ZMQ authentication certificates/keys.'.format(auth_cert_dir))\n        except Exception as e:\n            logger.exception(str(e))\n            self.__secure_mode = 0\n            logger.critical('ZMQ Security Mechanism is disabled for this connection due to errors!')\n    if not self.__ssh_tunnel_mode is None:\n        if receive_mode:\n            logger.error('SSH Tunneling cannot be enabled for Client-end!')\n        else:\n            ssh_address = self.__ssh_tunnel_mode\n            (ssh_address, ssh_port) = ssh_address.split(':') if ':' in ssh_address else [ssh_address, '22']\n            if '47' in ssh_port:\n                self.__ssh_tunnel_mode = self.__ssh_tunnel_mode.replace(':47', '')\n            else:\n                (ssh_user, ssh_ip) = ssh_address.split('@') if '@' in ssh_address else ['', ssh_address]\n                assert check_open_port(ssh_ip, port=int(ssh_port)), '[NetGear:ERROR] :: Host `{}` is not available for SSH Tunneling at port-{}!'.format(ssh_address, ssh_port)\n    if self.__multiclient_mode and self.__multiserver_mode:\n        raise ValueError('[NetGear:ERROR] :: Multi-Client and Multi-Server Mode cannot be enabled simultaneously!')\n    elif self.__multiserver_mode or self.__multiclient_mode:\n        if self.__bi_mode:\n            self.__logging and logger.debug('Bidirectional Data Transmission is also enabled for this connection!')\n        if self.__ssh_tunnel_mode:\n            raise ValueError('[NetGear:ERROR] :: SSH Tunneling and {} Mode cannot be enabled simultaneously. Kindly refer docs!'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client'))\n    elif self.__bi_mode:\n        self.__logging and logger.debug('Bidirectional Data Transmission is enabled for this connection!')\n    elif self.__ssh_tunnel_mode:\n        self.__logging and logger.debug('SSH Tunneling is enabled for host:`{}` with `{}` back-end.'.format(self.__ssh_tunnel_mode, 'paramiko' if self.__paramiko_present else 'pexpect'))\n    self.__msg_context = zmq.Context.instance()\n    self.__receive_mode = receive_mode\n    if self.__receive_mode:\n        if address is None:\n            address = '*'\n        if self.__multiserver_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Server ports while Multi-Server mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif self.__multiclient_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Client-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[1])\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                server_secret_file = os.path.join(self.__auth_secretkeys_dir, 'server.key_secret')\n                (server_public, server_secret) = auth.load_certificate(server_secret_file)\n                self.__msg_socket.curve_secretkey = server_secret\n                self.__msg_socket.curve_publickey = server_public\n                self.__msg_socket.curve_server = True\n            if self.__pattern == 2:\n                self.__msg_socket.setsockopt_string(zmq.SUBSCRIBE, '')\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.RCVTIMEO, self.__subscriber_timeout)\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            if self.__multiserver_mode:\n                for pt in port:\n                    self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(pt))\n            else:\n                self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiserver_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[1]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n            else:\n                self.__logging and self.__subscriber_timeout and logger.debug('Timeout: {} secs is enabled for this system.'.format(self.__subscriber_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to bind address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        self.__logging and logger.debug('Threaded Queue Mode is enabled by default for this connection.')\n        self.__queue = deque(maxlen=96)\n        self.__thread = Thread(target=self.__recv_handler, name='NetGear', args=())\n        self.__thread.daemon = True\n        self.__thread.start()\n        if self.__logging:\n            logger.debug('Successfully Binded to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Successfully enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Multi-threaded Receive Mode is successfully enabled.')\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Receive Mode is now activated.')\n    else:\n        if address is None:\n            address = 'localhost'\n        if self.__multiserver_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Server-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif self.__multiclient_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Client ports while Multi-Client mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[0])\n            if self.__pattern == 1:\n                self.__msg_socket.REQ_RELAXED = True\n                self.__msg_socket.REQ_CORRELATE = True\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                client_secret_file = os.path.join(self.__auth_secretkeys_dir, 'client.key_secret')\n                (client_public, client_secret) = auth.load_certificate(client_secret_file)\n                self.__msg_socket.curve_secretkey = client_secret\n                self.__msg_socket.curve_publickey = client_public\n                server_public_file = os.path.join(self.__auth_publickeys_dir, 'server.key')\n                (server_public, _) = auth.load_certificate(server_public_file)\n                self.__msg_socket.curve_serverkey = server_public\n            if self.__multiclient_mode:\n                for pt in port:\n                    self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(pt))\n            elif self.__ssh_tunnel_mode:\n                ssh.tunnel_connection(self.__msg_socket, protocol + '://' + str(address) + ':' + str(port), self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n            else:\n                self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiclient_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[0]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                if self.__ssh_tunnel_mode:\n                    logger.critical('Failed to initiate SSH Tunneling Mode for this server with `{}` back-end!'.format('paramiko' if self.__paramiko_present else 'pexpect'))\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to connect address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        if self.__logging:\n            logger.debug('Successfully connected to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Send Mode is successfully activated and ready to send data.')",
        "mutated": [
            "def __init__(self, address=None, port=None, protocol=None, pattern=0, receive_mode=False, logging=False, **options):\n    if False:\n        i = 10\n    \"\\n        This constructor method initializes the object state and attributes of the NetGear class.\\n\\n        Parameters:\\n            address (str): sets the valid network address of the Server/Client.\\n            port (str): sets the valid Network Port of the Server/Client.\\n            protocol (str): sets the valid messaging protocol between Server/Client.\\n            pattern (int): sets the supported messaging pattern(flow of communication) between Server/Client\\n            receive_mode (bool): select the Netgear's Mode of operation.\\n            logging (bool): enables/disables logging.\\n            options (dict): provides the flexibility to alter various NetGear internal properties.\\n        \"\n    logcurr_vidgear_ver(logging=logging)\n    import_dependency_safe('zmq' if zmq is None else '', min_version='4.0', pkg_name='pyzmq')\n    import_dependency_safe('simplejpeg' if simplejpeg is None else '', error='log', min_version='1.6.1')\n    self.__logging = True if logging else False\n    valid_messaging_patterns = {0: (zmq.PAIR, zmq.PAIR), 1: (zmq.REQ, zmq.REP), 2: (zmq.PUB, zmq.SUB)}\n    msg_pattern = None\n    if isinstance(pattern, int) and pattern in valid_messaging_patterns.keys():\n        msg_pattern = valid_messaging_patterns[pattern]\n    else:\n        pattern = 0\n        msg_pattern = valid_messaging_patterns[pattern]\n        self.__logging and logger.warning('Wrong pattern value, Defaulting to `zmq.PAIR`! Kindly refer Docs for more Information.')\n    self.__pattern = pattern\n    if protocol is None or not protocol in ['tcp', 'ipc']:\n        protocol = 'tcp'\n        self.__logging and logger.warning('Protocol is not supported or not provided. Defaulting to `tcp` protocol!')\n    self.__msg_flag = 0\n    self.__msg_copy = False\n    self.__msg_track = False\n    self.__ssh_tunnel_mode = None\n    self.__ssh_tunnel_pwd = None\n    self.__ssh_tunnel_keyfile = None\n    self.__paramiko_present = False if paramiko is None else True\n    self.__multiserver_mode = False\n    self.__multiclient_mode = False\n    self.__bi_mode = False\n    valid_security_mech = {0: 'Grasslands', 1: 'StoneHouse', 2: 'IronHouse'}\n    self.__secure_mode = 0\n    auth_cert_dir = ''\n    self.__auth_publickeys_dir = ''\n    self.__auth_secretkeys_dir = ''\n    overwrite_cert = False\n    custom_cert_location = ''\n    self.__jpeg_compression = True if not simplejpeg is None else False\n    self.__jpeg_compression_quality = 90\n    self.__jpeg_compression_fastdct = True\n    self.__jpeg_compression_fastupsample = False\n    self.__jpeg_compression_colorspace = 'BGR'\n    self.__ex_compression_params = None\n    self.__return_data = None\n    self.__id = ''.join((secrets.choice(string.ascii_uppercase + string.digits) for i in range(8)))\n    self.__terminate = False\n    if pattern < 2:\n        self.__poll = zmq.Poller()\n        self.__max_retries = 3\n        self.__request_timeout = 4000\n    else:\n        self.__subscriber_timeout = None\n    options = {str(k).strip(): v for (k, v) in options.items()}\n    for (key, value) in options.items():\n        if key == 'multiserver_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiserver_mode = value\n            else:\n                self.__multiserver_mode = False\n                logger.critical('Multi-Server Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Server Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'multiclient_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiclient_mode = value\n            else:\n                self.__multiclient_mode = False\n                logger.critical('Multi-Client Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Client Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'bidirectional_mode' and isinstance(value, bool):\n            if pattern < 2:\n                self.__bi_mode = value\n            else:\n                self.__bi_mode = False\n                logger.warning('Bidirectional data transmission is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Bidirectional Mode is enabled. Kindly refer Docs for more Information!'.format(pattern))\n        elif key == 'secure_mode' and isinstance(value, int) and (value in valid_security_mech):\n            self.__secure_mode = value\n        elif key == 'custom_cert_location' and isinstance(value, str):\n            custom_cert_location = os.path.abspath(value)\n            assert os.path.isdir(custom_cert_location), '[NetGear:ERROR] :: `custom_cert_location` value must be the path to a valid directory!'\n            assert check_WriteAccess(custom_cert_location, is_windows=True if os.name == 'nt' else False, logging=self.__logging), \"[NetGear:ERROR] :: Permission Denied!, cannot write ZMQ authentication certificates to '{}' directory!\".format(value)\n        elif key == 'overwrite_cert' and isinstance(value, bool):\n            overwrite_cert = value\n        elif key == 'ssh_tunnel_mode' and isinstance(value, str):\n            self.__ssh_tunnel_mode = value.strip()\n        elif key == 'ssh_tunnel_pwd' and isinstance(value, str):\n            self.__ssh_tunnel_pwd = value\n        elif key == 'ssh_tunnel_keyfile' and isinstance(value, str):\n            self.__ssh_tunnel_keyfile = value if os.path.isfile(value) else None\n            if self.__ssh_tunnel_keyfile is None:\n                logger.warning('Discarded invalid or non-existential SSH Tunnel Key-file at {}!'.format(value))\n        elif key == 'jpeg_compression' and (not simplejpeg is None) and isinstance(value, (bool, str)):\n            if isinstance(value, str) and value.strip().upper() in ['RGB', 'BGR', 'RGBX', 'BGRX', 'XBGR', 'XRGB', 'GRAY', 'RGBA', 'BGRA', 'ABGR', 'ARGB', 'CMYK']:\n                self.__jpeg_compression_colorspace = value.strip().upper()\n                self.__jpeg_compression = True\n            else:\n                self.__jpeg_compression = value\n        elif key == 'jpeg_compression_quality' and isinstance(value, (int, float)):\n            if value >= 10 and value <= 100:\n                self.__jpeg_compression_quality = int(value)\n            else:\n                logger.warning('Skipped invalid `jpeg_compression_quality` value!')\n        elif key == 'jpeg_compression_fastdct' and isinstance(value, bool):\n            self.__jpeg_compression_fastdct = value\n        elif key == 'jpeg_compression_fastupsample' and isinstance(value, bool):\n            self.__jpeg_compression_fastupsample = value\n        elif key == 'max_retries' and isinstance(value, int) and (pattern < 2):\n            if value >= 0:\n                self.__max_retries = value\n            else:\n                logger.warning('Invalid `max_retries` value skipped!')\n        elif key == 'request_timeout' and isinstance(value, int) and (pattern < 2):\n            if value >= 4:\n                self.__request_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'subscriber_timeout' and isinstance(value, int) and (pattern == 2):\n            if value > 0:\n                self.__subscriber_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'flag' and isinstance(value, int):\n            self.__msg_flag = value\n        elif key == 'copy' and isinstance(value, bool):\n            self.__msg_copy = value\n        elif key == 'track' and isinstance(value, bool):\n            self.__msg_track = value\n        else:\n            pass\n    if self.__secure_mode:\n        if overwrite_cert:\n            if not receive_mode:\n                self.__logging and logger.warning('Overwriting ZMQ Authentication certificates over previous ones!')\n            else:\n                overwrite_cert = False\n                self.__logging and logger.critical(\"Overwriting ZMQ Authentication certificates is disabled for Client's end!\")\n        try:\n            if custom_cert_location:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(custom_cert_location, overwrite=overwrite_cert, logging=logging)\n            else:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(os.path.join(expanduser('~'), '.vidgear'), overwrite=overwrite_cert, logging=logging)\n            self.__logging and logger.debug('`{}` is the default location for storing ZMQ authentication certificates/keys.'.format(auth_cert_dir))\n        except Exception as e:\n            logger.exception(str(e))\n            self.__secure_mode = 0\n            logger.critical('ZMQ Security Mechanism is disabled for this connection due to errors!')\n    if not self.__ssh_tunnel_mode is None:\n        if receive_mode:\n            logger.error('SSH Tunneling cannot be enabled for Client-end!')\n        else:\n            ssh_address = self.__ssh_tunnel_mode\n            (ssh_address, ssh_port) = ssh_address.split(':') if ':' in ssh_address else [ssh_address, '22']\n            if '47' in ssh_port:\n                self.__ssh_tunnel_mode = self.__ssh_tunnel_mode.replace(':47', '')\n            else:\n                (ssh_user, ssh_ip) = ssh_address.split('@') if '@' in ssh_address else ['', ssh_address]\n                assert check_open_port(ssh_ip, port=int(ssh_port)), '[NetGear:ERROR] :: Host `{}` is not available for SSH Tunneling at port-{}!'.format(ssh_address, ssh_port)\n    if self.__multiclient_mode and self.__multiserver_mode:\n        raise ValueError('[NetGear:ERROR] :: Multi-Client and Multi-Server Mode cannot be enabled simultaneously!')\n    elif self.__multiserver_mode or self.__multiclient_mode:\n        if self.__bi_mode:\n            self.__logging and logger.debug('Bidirectional Data Transmission is also enabled for this connection!')\n        if self.__ssh_tunnel_mode:\n            raise ValueError('[NetGear:ERROR] :: SSH Tunneling and {} Mode cannot be enabled simultaneously. Kindly refer docs!'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client'))\n    elif self.__bi_mode:\n        self.__logging and logger.debug('Bidirectional Data Transmission is enabled for this connection!')\n    elif self.__ssh_tunnel_mode:\n        self.__logging and logger.debug('SSH Tunneling is enabled for host:`{}` with `{}` back-end.'.format(self.__ssh_tunnel_mode, 'paramiko' if self.__paramiko_present else 'pexpect'))\n    self.__msg_context = zmq.Context.instance()\n    self.__receive_mode = receive_mode\n    if self.__receive_mode:\n        if address is None:\n            address = '*'\n        if self.__multiserver_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Server ports while Multi-Server mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif self.__multiclient_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Client-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[1])\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                server_secret_file = os.path.join(self.__auth_secretkeys_dir, 'server.key_secret')\n                (server_public, server_secret) = auth.load_certificate(server_secret_file)\n                self.__msg_socket.curve_secretkey = server_secret\n                self.__msg_socket.curve_publickey = server_public\n                self.__msg_socket.curve_server = True\n            if self.__pattern == 2:\n                self.__msg_socket.setsockopt_string(zmq.SUBSCRIBE, '')\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.RCVTIMEO, self.__subscriber_timeout)\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            if self.__multiserver_mode:\n                for pt in port:\n                    self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(pt))\n            else:\n                self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiserver_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[1]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n            else:\n                self.__logging and self.__subscriber_timeout and logger.debug('Timeout: {} secs is enabled for this system.'.format(self.__subscriber_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to bind address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        self.__logging and logger.debug('Threaded Queue Mode is enabled by default for this connection.')\n        self.__queue = deque(maxlen=96)\n        self.__thread = Thread(target=self.__recv_handler, name='NetGear', args=())\n        self.__thread.daemon = True\n        self.__thread.start()\n        if self.__logging:\n            logger.debug('Successfully Binded to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Successfully enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Multi-threaded Receive Mode is successfully enabled.')\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Receive Mode is now activated.')\n    else:\n        if address is None:\n            address = 'localhost'\n        if self.__multiserver_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Server-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif self.__multiclient_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Client ports while Multi-Client mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[0])\n            if self.__pattern == 1:\n                self.__msg_socket.REQ_RELAXED = True\n                self.__msg_socket.REQ_CORRELATE = True\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                client_secret_file = os.path.join(self.__auth_secretkeys_dir, 'client.key_secret')\n                (client_public, client_secret) = auth.load_certificate(client_secret_file)\n                self.__msg_socket.curve_secretkey = client_secret\n                self.__msg_socket.curve_publickey = client_public\n                server_public_file = os.path.join(self.__auth_publickeys_dir, 'server.key')\n                (server_public, _) = auth.load_certificate(server_public_file)\n                self.__msg_socket.curve_serverkey = server_public\n            if self.__multiclient_mode:\n                for pt in port:\n                    self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(pt))\n            elif self.__ssh_tunnel_mode:\n                ssh.tunnel_connection(self.__msg_socket, protocol + '://' + str(address) + ':' + str(port), self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n            else:\n                self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiclient_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[0]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                if self.__ssh_tunnel_mode:\n                    logger.critical('Failed to initiate SSH Tunneling Mode for this server with `{}` back-end!'.format('paramiko' if self.__paramiko_present else 'pexpect'))\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to connect address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        if self.__logging:\n            logger.debug('Successfully connected to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Send Mode is successfully activated and ready to send data.')",
            "def __init__(self, address=None, port=None, protocol=None, pattern=0, receive_mode=False, logging=False, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        This constructor method initializes the object state and attributes of the NetGear class.\\n\\n        Parameters:\\n            address (str): sets the valid network address of the Server/Client.\\n            port (str): sets the valid Network Port of the Server/Client.\\n            protocol (str): sets the valid messaging protocol between Server/Client.\\n            pattern (int): sets the supported messaging pattern(flow of communication) between Server/Client\\n            receive_mode (bool): select the Netgear's Mode of operation.\\n            logging (bool): enables/disables logging.\\n            options (dict): provides the flexibility to alter various NetGear internal properties.\\n        \"\n    logcurr_vidgear_ver(logging=logging)\n    import_dependency_safe('zmq' if zmq is None else '', min_version='4.0', pkg_name='pyzmq')\n    import_dependency_safe('simplejpeg' if simplejpeg is None else '', error='log', min_version='1.6.1')\n    self.__logging = True if logging else False\n    valid_messaging_patterns = {0: (zmq.PAIR, zmq.PAIR), 1: (zmq.REQ, zmq.REP), 2: (zmq.PUB, zmq.SUB)}\n    msg_pattern = None\n    if isinstance(pattern, int) and pattern in valid_messaging_patterns.keys():\n        msg_pattern = valid_messaging_patterns[pattern]\n    else:\n        pattern = 0\n        msg_pattern = valid_messaging_patterns[pattern]\n        self.__logging and logger.warning('Wrong pattern value, Defaulting to `zmq.PAIR`! Kindly refer Docs for more Information.')\n    self.__pattern = pattern\n    if protocol is None or not protocol in ['tcp', 'ipc']:\n        protocol = 'tcp'\n        self.__logging and logger.warning('Protocol is not supported or not provided. Defaulting to `tcp` protocol!')\n    self.__msg_flag = 0\n    self.__msg_copy = False\n    self.__msg_track = False\n    self.__ssh_tunnel_mode = None\n    self.__ssh_tunnel_pwd = None\n    self.__ssh_tunnel_keyfile = None\n    self.__paramiko_present = False if paramiko is None else True\n    self.__multiserver_mode = False\n    self.__multiclient_mode = False\n    self.__bi_mode = False\n    valid_security_mech = {0: 'Grasslands', 1: 'StoneHouse', 2: 'IronHouse'}\n    self.__secure_mode = 0\n    auth_cert_dir = ''\n    self.__auth_publickeys_dir = ''\n    self.__auth_secretkeys_dir = ''\n    overwrite_cert = False\n    custom_cert_location = ''\n    self.__jpeg_compression = True if not simplejpeg is None else False\n    self.__jpeg_compression_quality = 90\n    self.__jpeg_compression_fastdct = True\n    self.__jpeg_compression_fastupsample = False\n    self.__jpeg_compression_colorspace = 'BGR'\n    self.__ex_compression_params = None\n    self.__return_data = None\n    self.__id = ''.join((secrets.choice(string.ascii_uppercase + string.digits) for i in range(8)))\n    self.__terminate = False\n    if pattern < 2:\n        self.__poll = zmq.Poller()\n        self.__max_retries = 3\n        self.__request_timeout = 4000\n    else:\n        self.__subscriber_timeout = None\n    options = {str(k).strip(): v for (k, v) in options.items()}\n    for (key, value) in options.items():\n        if key == 'multiserver_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiserver_mode = value\n            else:\n                self.__multiserver_mode = False\n                logger.critical('Multi-Server Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Server Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'multiclient_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiclient_mode = value\n            else:\n                self.__multiclient_mode = False\n                logger.critical('Multi-Client Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Client Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'bidirectional_mode' and isinstance(value, bool):\n            if pattern < 2:\n                self.__bi_mode = value\n            else:\n                self.__bi_mode = False\n                logger.warning('Bidirectional data transmission is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Bidirectional Mode is enabled. Kindly refer Docs for more Information!'.format(pattern))\n        elif key == 'secure_mode' and isinstance(value, int) and (value in valid_security_mech):\n            self.__secure_mode = value\n        elif key == 'custom_cert_location' and isinstance(value, str):\n            custom_cert_location = os.path.abspath(value)\n            assert os.path.isdir(custom_cert_location), '[NetGear:ERROR] :: `custom_cert_location` value must be the path to a valid directory!'\n            assert check_WriteAccess(custom_cert_location, is_windows=True if os.name == 'nt' else False, logging=self.__logging), \"[NetGear:ERROR] :: Permission Denied!, cannot write ZMQ authentication certificates to '{}' directory!\".format(value)\n        elif key == 'overwrite_cert' and isinstance(value, bool):\n            overwrite_cert = value\n        elif key == 'ssh_tunnel_mode' and isinstance(value, str):\n            self.__ssh_tunnel_mode = value.strip()\n        elif key == 'ssh_tunnel_pwd' and isinstance(value, str):\n            self.__ssh_tunnel_pwd = value\n        elif key == 'ssh_tunnel_keyfile' and isinstance(value, str):\n            self.__ssh_tunnel_keyfile = value if os.path.isfile(value) else None\n            if self.__ssh_tunnel_keyfile is None:\n                logger.warning('Discarded invalid or non-existential SSH Tunnel Key-file at {}!'.format(value))\n        elif key == 'jpeg_compression' and (not simplejpeg is None) and isinstance(value, (bool, str)):\n            if isinstance(value, str) and value.strip().upper() in ['RGB', 'BGR', 'RGBX', 'BGRX', 'XBGR', 'XRGB', 'GRAY', 'RGBA', 'BGRA', 'ABGR', 'ARGB', 'CMYK']:\n                self.__jpeg_compression_colorspace = value.strip().upper()\n                self.__jpeg_compression = True\n            else:\n                self.__jpeg_compression = value\n        elif key == 'jpeg_compression_quality' and isinstance(value, (int, float)):\n            if value >= 10 and value <= 100:\n                self.__jpeg_compression_quality = int(value)\n            else:\n                logger.warning('Skipped invalid `jpeg_compression_quality` value!')\n        elif key == 'jpeg_compression_fastdct' and isinstance(value, bool):\n            self.__jpeg_compression_fastdct = value\n        elif key == 'jpeg_compression_fastupsample' and isinstance(value, bool):\n            self.__jpeg_compression_fastupsample = value\n        elif key == 'max_retries' and isinstance(value, int) and (pattern < 2):\n            if value >= 0:\n                self.__max_retries = value\n            else:\n                logger.warning('Invalid `max_retries` value skipped!')\n        elif key == 'request_timeout' and isinstance(value, int) and (pattern < 2):\n            if value >= 4:\n                self.__request_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'subscriber_timeout' and isinstance(value, int) and (pattern == 2):\n            if value > 0:\n                self.__subscriber_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'flag' and isinstance(value, int):\n            self.__msg_flag = value\n        elif key == 'copy' and isinstance(value, bool):\n            self.__msg_copy = value\n        elif key == 'track' and isinstance(value, bool):\n            self.__msg_track = value\n        else:\n            pass\n    if self.__secure_mode:\n        if overwrite_cert:\n            if not receive_mode:\n                self.__logging and logger.warning('Overwriting ZMQ Authentication certificates over previous ones!')\n            else:\n                overwrite_cert = False\n                self.__logging and logger.critical(\"Overwriting ZMQ Authentication certificates is disabled for Client's end!\")\n        try:\n            if custom_cert_location:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(custom_cert_location, overwrite=overwrite_cert, logging=logging)\n            else:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(os.path.join(expanduser('~'), '.vidgear'), overwrite=overwrite_cert, logging=logging)\n            self.__logging and logger.debug('`{}` is the default location for storing ZMQ authentication certificates/keys.'.format(auth_cert_dir))\n        except Exception as e:\n            logger.exception(str(e))\n            self.__secure_mode = 0\n            logger.critical('ZMQ Security Mechanism is disabled for this connection due to errors!')\n    if not self.__ssh_tunnel_mode is None:\n        if receive_mode:\n            logger.error('SSH Tunneling cannot be enabled for Client-end!')\n        else:\n            ssh_address = self.__ssh_tunnel_mode\n            (ssh_address, ssh_port) = ssh_address.split(':') if ':' in ssh_address else [ssh_address, '22']\n            if '47' in ssh_port:\n                self.__ssh_tunnel_mode = self.__ssh_tunnel_mode.replace(':47', '')\n            else:\n                (ssh_user, ssh_ip) = ssh_address.split('@') if '@' in ssh_address else ['', ssh_address]\n                assert check_open_port(ssh_ip, port=int(ssh_port)), '[NetGear:ERROR] :: Host `{}` is not available for SSH Tunneling at port-{}!'.format(ssh_address, ssh_port)\n    if self.__multiclient_mode and self.__multiserver_mode:\n        raise ValueError('[NetGear:ERROR] :: Multi-Client and Multi-Server Mode cannot be enabled simultaneously!')\n    elif self.__multiserver_mode or self.__multiclient_mode:\n        if self.__bi_mode:\n            self.__logging and logger.debug('Bidirectional Data Transmission is also enabled for this connection!')\n        if self.__ssh_tunnel_mode:\n            raise ValueError('[NetGear:ERROR] :: SSH Tunneling and {} Mode cannot be enabled simultaneously. Kindly refer docs!'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client'))\n    elif self.__bi_mode:\n        self.__logging and logger.debug('Bidirectional Data Transmission is enabled for this connection!')\n    elif self.__ssh_tunnel_mode:\n        self.__logging and logger.debug('SSH Tunneling is enabled for host:`{}` with `{}` back-end.'.format(self.__ssh_tunnel_mode, 'paramiko' if self.__paramiko_present else 'pexpect'))\n    self.__msg_context = zmq.Context.instance()\n    self.__receive_mode = receive_mode\n    if self.__receive_mode:\n        if address is None:\n            address = '*'\n        if self.__multiserver_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Server ports while Multi-Server mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif self.__multiclient_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Client-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[1])\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                server_secret_file = os.path.join(self.__auth_secretkeys_dir, 'server.key_secret')\n                (server_public, server_secret) = auth.load_certificate(server_secret_file)\n                self.__msg_socket.curve_secretkey = server_secret\n                self.__msg_socket.curve_publickey = server_public\n                self.__msg_socket.curve_server = True\n            if self.__pattern == 2:\n                self.__msg_socket.setsockopt_string(zmq.SUBSCRIBE, '')\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.RCVTIMEO, self.__subscriber_timeout)\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            if self.__multiserver_mode:\n                for pt in port:\n                    self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(pt))\n            else:\n                self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiserver_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[1]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n            else:\n                self.__logging and self.__subscriber_timeout and logger.debug('Timeout: {} secs is enabled for this system.'.format(self.__subscriber_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to bind address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        self.__logging and logger.debug('Threaded Queue Mode is enabled by default for this connection.')\n        self.__queue = deque(maxlen=96)\n        self.__thread = Thread(target=self.__recv_handler, name='NetGear', args=())\n        self.__thread.daemon = True\n        self.__thread.start()\n        if self.__logging:\n            logger.debug('Successfully Binded to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Successfully enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Multi-threaded Receive Mode is successfully enabled.')\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Receive Mode is now activated.')\n    else:\n        if address is None:\n            address = 'localhost'\n        if self.__multiserver_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Server-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif self.__multiclient_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Client ports while Multi-Client mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[0])\n            if self.__pattern == 1:\n                self.__msg_socket.REQ_RELAXED = True\n                self.__msg_socket.REQ_CORRELATE = True\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                client_secret_file = os.path.join(self.__auth_secretkeys_dir, 'client.key_secret')\n                (client_public, client_secret) = auth.load_certificate(client_secret_file)\n                self.__msg_socket.curve_secretkey = client_secret\n                self.__msg_socket.curve_publickey = client_public\n                server_public_file = os.path.join(self.__auth_publickeys_dir, 'server.key')\n                (server_public, _) = auth.load_certificate(server_public_file)\n                self.__msg_socket.curve_serverkey = server_public\n            if self.__multiclient_mode:\n                for pt in port:\n                    self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(pt))\n            elif self.__ssh_tunnel_mode:\n                ssh.tunnel_connection(self.__msg_socket, protocol + '://' + str(address) + ':' + str(port), self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n            else:\n                self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiclient_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[0]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                if self.__ssh_tunnel_mode:\n                    logger.critical('Failed to initiate SSH Tunneling Mode for this server with `{}` back-end!'.format('paramiko' if self.__paramiko_present else 'pexpect'))\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to connect address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        if self.__logging:\n            logger.debug('Successfully connected to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Send Mode is successfully activated and ready to send data.')",
            "def __init__(self, address=None, port=None, protocol=None, pattern=0, receive_mode=False, logging=False, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        This constructor method initializes the object state and attributes of the NetGear class.\\n\\n        Parameters:\\n            address (str): sets the valid network address of the Server/Client.\\n            port (str): sets the valid Network Port of the Server/Client.\\n            protocol (str): sets the valid messaging protocol between Server/Client.\\n            pattern (int): sets the supported messaging pattern(flow of communication) between Server/Client\\n            receive_mode (bool): select the Netgear's Mode of operation.\\n            logging (bool): enables/disables logging.\\n            options (dict): provides the flexibility to alter various NetGear internal properties.\\n        \"\n    logcurr_vidgear_ver(logging=logging)\n    import_dependency_safe('zmq' if zmq is None else '', min_version='4.0', pkg_name='pyzmq')\n    import_dependency_safe('simplejpeg' if simplejpeg is None else '', error='log', min_version='1.6.1')\n    self.__logging = True if logging else False\n    valid_messaging_patterns = {0: (zmq.PAIR, zmq.PAIR), 1: (zmq.REQ, zmq.REP), 2: (zmq.PUB, zmq.SUB)}\n    msg_pattern = None\n    if isinstance(pattern, int) and pattern in valid_messaging_patterns.keys():\n        msg_pattern = valid_messaging_patterns[pattern]\n    else:\n        pattern = 0\n        msg_pattern = valid_messaging_patterns[pattern]\n        self.__logging and logger.warning('Wrong pattern value, Defaulting to `zmq.PAIR`! Kindly refer Docs for more Information.')\n    self.__pattern = pattern\n    if protocol is None or not protocol in ['tcp', 'ipc']:\n        protocol = 'tcp'\n        self.__logging and logger.warning('Protocol is not supported or not provided. Defaulting to `tcp` protocol!')\n    self.__msg_flag = 0\n    self.__msg_copy = False\n    self.__msg_track = False\n    self.__ssh_tunnel_mode = None\n    self.__ssh_tunnel_pwd = None\n    self.__ssh_tunnel_keyfile = None\n    self.__paramiko_present = False if paramiko is None else True\n    self.__multiserver_mode = False\n    self.__multiclient_mode = False\n    self.__bi_mode = False\n    valid_security_mech = {0: 'Grasslands', 1: 'StoneHouse', 2: 'IronHouse'}\n    self.__secure_mode = 0\n    auth_cert_dir = ''\n    self.__auth_publickeys_dir = ''\n    self.__auth_secretkeys_dir = ''\n    overwrite_cert = False\n    custom_cert_location = ''\n    self.__jpeg_compression = True if not simplejpeg is None else False\n    self.__jpeg_compression_quality = 90\n    self.__jpeg_compression_fastdct = True\n    self.__jpeg_compression_fastupsample = False\n    self.__jpeg_compression_colorspace = 'BGR'\n    self.__ex_compression_params = None\n    self.__return_data = None\n    self.__id = ''.join((secrets.choice(string.ascii_uppercase + string.digits) for i in range(8)))\n    self.__terminate = False\n    if pattern < 2:\n        self.__poll = zmq.Poller()\n        self.__max_retries = 3\n        self.__request_timeout = 4000\n    else:\n        self.__subscriber_timeout = None\n    options = {str(k).strip(): v for (k, v) in options.items()}\n    for (key, value) in options.items():\n        if key == 'multiserver_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiserver_mode = value\n            else:\n                self.__multiserver_mode = False\n                logger.critical('Multi-Server Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Server Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'multiclient_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiclient_mode = value\n            else:\n                self.__multiclient_mode = False\n                logger.critical('Multi-Client Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Client Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'bidirectional_mode' and isinstance(value, bool):\n            if pattern < 2:\n                self.__bi_mode = value\n            else:\n                self.__bi_mode = False\n                logger.warning('Bidirectional data transmission is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Bidirectional Mode is enabled. Kindly refer Docs for more Information!'.format(pattern))\n        elif key == 'secure_mode' and isinstance(value, int) and (value in valid_security_mech):\n            self.__secure_mode = value\n        elif key == 'custom_cert_location' and isinstance(value, str):\n            custom_cert_location = os.path.abspath(value)\n            assert os.path.isdir(custom_cert_location), '[NetGear:ERROR] :: `custom_cert_location` value must be the path to a valid directory!'\n            assert check_WriteAccess(custom_cert_location, is_windows=True if os.name == 'nt' else False, logging=self.__logging), \"[NetGear:ERROR] :: Permission Denied!, cannot write ZMQ authentication certificates to '{}' directory!\".format(value)\n        elif key == 'overwrite_cert' and isinstance(value, bool):\n            overwrite_cert = value\n        elif key == 'ssh_tunnel_mode' and isinstance(value, str):\n            self.__ssh_tunnel_mode = value.strip()\n        elif key == 'ssh_tunnel_pwd' and isinstance(value, str):\n            self.__ssh_tunnel_pwd = value\n        elif key == 'ssh_tunnel_keyfile' and isinstance(value, str):\n            self.__ssh_tunnel_keyfile = value if os.path.isfile(value) else None\n            if self.__ssh_tunnel_keyfile is None:\n                logger.warning('Discarded invalid or non-existential SSH Tunnel Key-file at {}!'.format(value))\n        elif key == 'jpeg_compression' and (not simplejpeg is None) and isinstance(value, (bool, str)):\n            if isinstance(value, str) and value.strip().upper() in ['RGB', 'BGR', 'RGBX', 'BGRX', 'XBGR', 'XRGB', 'GRAY', 'RGBA', 'BGRA', 'ABGR', 'ARGB', 'CMYK']:\n                self.__jpeg_compression_colorspace = value.strip().upper()\n                self.__jpeg_compression = True\n            else:\n                self.__jpeg_compression = value\n        elif key == 'jpeg_compression_quality' and isinstance(value, (int, float)):\n            if value >= 10 and value <= 100:\n                self.__jpeg_compression_quality = int(value)\n            else:\n                logger.warning('Skipped invalid `jpeg_compression_quality` value!')\n        elif key == 'jpeg_compression_fastdct' and isinstance(value, bool):\n            self.__jpeg_compression_fastdct = value\n        elif key == 'jpeg_compression_fastupsample' and isinstance(value, bool):\n            self.__jpeg_compression_fastupsample = value\n        elif key == 'max_retries' and isinstance(value, int) and (pattern < 2):\n            if value >= 0:\n                self.__max_retries = value\n            else:\n                logger.warning('Invalid `max_retries` value skipped!')\n        elif key == 'request_timeout' and isinstance(value, int) and (pattern < 2):\n            if value >= 4:\n                self.__request_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'subscriber_timeout' and isinstance(value, int) and (pattern == 2):\n            if value > 0:\n                self.__subscriber_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'flag' and isinstance(value, int):\n            self.__msg_flag = value\n        elif key == 'copy' and isinstance(value, bool):\n            self.__msg_copy = value\n        elif key == 'track' and isinstance(value, bool):\n            self.__msg_track = value\n        else:\n            pass\n    if self.__secure_mode:\n        if overwrite_cert:\n            if not receive_mode:\n                self.__logging and logger.warning('Overwriting ZMQ Authentication certificates over previous ones!')\n            else:\n                overwrite_cert = False\n                self.__logging and logger.critical(\"Overwriting ZMQ Authentication certificates is disabled for Client's end!\")\n        try:\n            if custom_cert_location:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(custom_cert_location, overwrite=overwrite_cert, logging=logging)\n            else:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(os.path.join(expanduser('~'), '.vidgear'), overwrite=overwrite_cert, logging=logging)\n            self.__logging and logger.debug('`{}` is the default location for storing ZMQ authentication certificates/keys.'.format(auth_cert_dir))\n        except Exception as e:\n            logger.exception(str(e))\n            self.__secure_mode = 0\n            logger.critical('ZMQ Security Mechanism is disabled for this connection due to errors!')\n    if not self.__ssh_tunnel_mode is None:\n        if receive_mode:\n            logger.error('SSH Tunneling cannot be enabled for Client-end!')\n        else:\n            ssh_address = self.__ssh_tunnel_mode\n            (ssh_address, ssh_port) = ssh_address.split(':') if ':' in ssh_address else [ssh_address, '22']\n            if '47' in ssh_port:\n                self.__ssh_tunnel_mode = self.__ssh_tunnel_mode.replace(':47', '')\n            else:\n                (ssh_user, ssh_ip) = ssh_address.split('@') if '@' in ssh_address else ['', ssh_address]\n                assert check_open_port(ssh_ip, port=int(ssh_port)), '[NetGear:ERROR] :: Host `{}` is not available for SSH Tunneling at port-{}!'.format(ssh_address, ssh_port)\n    if self.__multiclient_mode and self.__multiserver_mode:\n        raise ValueError('[NetGear:ERROR] :: Multi-Client and Multi-Server Mode cannot be enabled simultaneously!')\n    elif self.__multiserver_mode or self.__multiclient_mode:\n        if self.__bi_mode:\n            self.__logging and logger.debug('Bidirectional Data Transmission is also enabled for this connection!')\n        if self.__ssh_tunnel_mode:\n            raise ValueError('[NetGear:ERROR] :: SSH Tunneling and {} Mode cannot be enabled simultaneously. Kindly refer docs!'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client'))\n    elif self.__bi_mode:\n        self.__logging and logger.debug('Bidirectional Data Transmission is enabled for this connection!')\n    elif self.__ssh_tunnel_mode:\n        self.__logging and logger.debug('SSH Tunneling is enabled for host:`{}` with `{}` back-end.'.format(self.__ssh_tunnel_mode, 'paramiko' if self.__paramiko_present else 'pexpect'))\n    self.__msg_context = zmq.Context.instance()\n    self.__receive_mode = receive_mode\n    if self.__receive_mode:\n        if address is None:\n            address = '*'\n        if self.__multiserver_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Server ports while Multi-Server mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif self.__multiclient_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Client-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[1])\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                server_secret_file = os.path.join(self.__auth_secretkeys_dir, 'server.key_secret')\n                (server_public, server_secret) = auth.load_certificate(server_secret_file)\n                self.__msg_socket.curve_secretkey = server_secret\n                self.__msg_socket.curve_publickey = server_public\n                self.__msg_socket.curve_server = True\n            if self.__pattern == 2:\n                self.__msg_socket.setsockopt_string(zmq.SUBSCRIBE, '')\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.RCVTIMEO, self.__subscriber_timeout)\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            if self.__multiserver_mode:\n                for pt in port:\n                    self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(pt))\n            else:\n                self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiserver_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[1]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n            else:\n                self.__logging and self.__subscriber_timeout and logger.debug('Timeout: {} secs is enabled for this system.'.format(self.__subscriber_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to bind address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        self.__logging and logger.debug('Threaded Queue Mode is enabled by default for this connection.')\n        self.__queue = deque(maxlen=96)\n        self.__thread = Thread(target=self.__recv_handler, name='NetGear', args=())\n        self.__thread.daemon = True\n        self.__thread.start()\n        if self.__logging:\n            logger.debug('Successfully Binded to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Successfully enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Multi-threaded Receive Mode is successfully enabled.')\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Receive Mode is now activated.')\n    else:\n        if address is None:\n            address = 'localhost'\n        if self.__multiserver_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Server-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif self.__multiclient_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Client ports while Multi-Client mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[0])\n            if self.__pattern == 1:\n                self.__msg_socket.REQ_RELAXED = True\n                self.__msg_socket.REQ_CORRELATE = True\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                client_secret_file = os.path.join(self.__auth_secretkeys_dir, 'client.key_secret')\n                (client_public, client_secret) = auth.load_certificate(client_secret_file)\n                self.__msg_socket.curve_secretkey = client_secret\n                self.__msg_socket.curve_publickey = client_public\n                server_public_file = os.path.join(self.__auth_publickeys_dir, 'server.key')\n                (server_public, _) = auth.load_certificate(server_public_file)\n                self.__msg_socket.curve_serverkey = server_public\n            if self.__multiclient_mode:\n                for pt in port:\n                    self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(pt))\n            elif self.__ssh_tunnel_mode:\n                ssh.tunnel_connection(self.__msg_socket, protocol + '://' + str(address) + ':' + str(port), self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n            else:\n                self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiclient_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[0]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                if self.__ssh_tunnel_mode:\n                    logger.critical('Failed to initiate SSH Tunneling Mode for this server with `{}` back-end!'.format('paramiko' if self.__paramiko_present else 'pexpect'))\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to connect address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        if self.__logging:\n            logger.debug('Successfully connected to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Send Mode is successfully activated and ready to send data.')",
            "def __init__(self, address=None, port=None, protocol=None, pattern=0, receive_mode=False, logging=False, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        This constructor method initializes the object state and attributes of the NetGear class.\\n\\n        Parameters:\\n            address (str): sets the valid network address of the Server/Client.\\n            port (str): sets the valid Network Port of the Server/Client.\\n            protocol (str): sets the valid messaging protocol between Server/Client.\\n            pattern (int): sets the supported messaging pattern(flow of communication) between Server/Client\\n            receive_mode (bool): select the Netgear's Mode of operation.\\n            logging (bool): enables/disables logging.\\n            options (dict): provides the flexibility to alter various NetGear internal properties.\\n        \"\n    logcurr_vidgear_ver(logging=logging)\n    import_dependency_safe('zmq' if zmq is None else '', min_version='4.0', pkg_name='pyzmq')\n    import_dependency_safe('simplejpeg' if simplejpeg is None else '', error='log', min_version='1.6.1')\n    self.__logging = True if logging else False\n    valid_messaging_patterns = {0: (zmq.PAIR, zmq.PAIR), 1: (zmq.REQ, zmq.REP), 2: (zmq.PUB, zmq.SUB)}\n    msg_pattern = None\n    if isinstance(pattern, int) and pattern in valid_messaging_patterns.keys():\n        msg_pattern = valid_messaging_patterns[pattern]\n    else:\n        pattern = 0\n        msg_pattern = valid_messaging_patterns[pattern]\n        self.__logging and logger.warning('Wrong pattern value, Defaulting to `zmq.PAIR`! Kindly refer Docs for more Information.')\n    self.__pattern = pattern\n    if protocol is None or not protocol in ['tcp', 'ipc']:\n        protocol = 'tcp'\n        self.__logging and logger.warning('Protocol is not supported or not provided. Defaulting to `tcp` protocol!')\n    self.__msg_flag = 0\n    self.__msg_copy = False\n    self.__msg_track = False\n    self.__ssh_tunnel_mode = None\n    self.__ssh_tunnel_pwd = None\n    self.__ssh_tunnel_keyfile = None\n    self.__paramiko_present = False if paramiko is None else True\n    self.__multiserver_mode = False\n    self.__multiclient_mode = False\n    self.__bi_mode = False\n    valid_security_mech = {0: 'Grasslands', 1: 'StoneHouse', 2: 'IronHouse'}\n    self.__secure_mode = 0\n    auth_cert_dir = ''\n    self.__auth_publickeys_dir = ''\n    self.__auth_secretkeys_dir = ''\n    overwrite_cert = False\n    custom_cert_location = ''\n    self.__jpeg_compression = True if not simplejpeg is None else False\n    self.__jpeg_compression_quality = 90\n    self.__jpeg_compression_fastdct = True\n    self.__jpeg_compression_fastupsample = False\n    self.__jpeg_compression_colorspace = 'BGR'\n    self.__ex_compression_params = None\n    self.__return_data = None\n    self.__id = ''.join((secrets.choice(string.ascii_uppercase + string.digits) for i in range(8)))\n    self.__terminate = False\n    if pattern < 2:\n        self.__poll = zmq.Poller()\n        self.__max_retries = 3\n        self.__request_timeout = 4000\n    else:\n        self.__subscriber_timeout = None\n    options = {str(k).strip(): v for (k, v) in options.items()}\n    for (key, value) in options.items():\n        if key == 'multiserver_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiserver_mode = value\n            else:\n                self.__multiserver_mode = False\n                logger.critical('Multi-Server Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Server Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'multiclient_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiclient_mode = value\n            else:\n                self.__multiclient_mode = False\n                logger.critical('Multi-Client Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Client Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'bidirectional_mode' and isinstance(value, bool):\n            if pattern < 2:\n                self.__bi_mode = value\n            else:\n                self.__bi_mode = False\n                logger.warning('Bidirectional data transmission is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Bidirectional Mode is enabled. Kindly refer Docs for more Information!'.format(pattern))\n        elif key == 'secure_mode' and isinstance(value, int) and (value in valid_security_mech):\n            self.__secure_mode = value\n        elif key == 'custom_cert_location' and isinstance(value, str):\n            custom_cert_location = os.path.abspath(value)\n            assert os.path.isdir(custom_cert_location), '[NetGear:ERROR] :: `custom_cert_location` value must be the path to a valid directory!'\n            assert check_WriteAccess(custom_cert_location, is_windows=True if os.name == 'nt' else False, logging=self.__logging), \"[NetGear:ERROR] :: Permission Denied!, cannot write ZMQ authentication certificates to '{}' directory!\".format(value)\n        elif key == 'overwrite_cert' and isinstance(value, bool):\n            overwrite_cert = value\n        elif key == 'ssh_tunnel_mode' and isinstance(value, str):\n            self.__ssh_tunnel_mode = value.strip()\n        elif key == 'ssh_tunnel_pwd' and isinstance(value, str):\n            self.__ssh_tunnel_pwd = value\n        elif key == 'ssh_tunnel_keyfile' and isinstance(value, str):\n            self.__ssh_tunnel_keyfile = value if os.path.isfile(value) else None\n            if self.__ssh_tunnel_keyfile is None:\n                logger.warning('Discarded invalid or non-existential SSH Tunnel Key-file at {}!'.format(value))\n        elif key == 'jpeg_compression' and (not simplejpeg is None) and isinstance(value, (bool, str)):\n            if isinstance(value, str) and value.strip().upper() in ['RGB', 'BGR', 'RGBX', 'BGRX', 'XBGR', 'XRGB', 'GRAY', 'RGBA', 'BGRA', 'ABGR', 'ARGB', 'CMYK']:\n                self.__jpeg_compression_colorspace = value.strip().upper()\n                self.__jpeg_compression = True\n            else:\n                self.__jpeg_compression = value\n        elif key == 'jpeg_compression_quality' and isinstance(value, (int, float)):\n            if value >= 10 and value <= 100:\n                self.__jpeg_compression_quality = int(value)\n            else:\n                logger.warning('Skipped invalid `jpeg_compression_quality` value!')\n        elif key == 'jpeg_compression_fastdct' and isinstance(value, bool):\n            self.__jpeg_compression_fastdct = value\n        elif key == 'jpeg_compression_fastupsample' and isinstance(value, bool):\n            self.__jpeg_compression_fastupsample = value\n        elif key == 'max_retries' and isinstance(value, int) and (pattern < 2):\n            if value >= 0:\n                self.__max_retries = value\n            else:\n                logger.warning('Invalid `max_retries` value skipped!')\n        elif key == 'request_timeout' and isinstance(value, int) and (pattern < 2):\n            if value >= 4:\n                self.__request_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'subscriber_timeout' and isinstance(value, int) and (pattern == 2):\n            if value > 0:\n                self.__subscriber_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'flag' and isinstance(value, int):\n            self.__msg_flag = value\n        elif key == 'copy' and isinstance(value, bool):\n            self.__msg_copy = value\n        elif key == 'track' and isinstance(value, bool):\n            self.__msg_track = value\n        else:\n            pass\n    if self.__secure_mode:\n        if overwrite_cert:\n            if not receive_mode:\n                self.__logging and logger.warning('Overwriting ZMQ Authentication certificates over previous ones!')\n            else:\n                overwrite_cert = False\n                self.__logging and logger.critical(\"Overwriting ZMQ Authentication certificates is disabled for Client's end!\")\n        try:\n            if custom_cert_location:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(custom_cert_location, overwrite=overwrite_cert, logging=logging)\n            else:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(os.path.join(expanduser('~'), '.vidgear'), overwrite=overwrite_cert, logging=logging)\n            self.__logging and logger.debug('`{}` is the default location for storing ZMQ authentication certificates/keys.'.format(auth_cert_dir))\n        except Exception as e:\n            logger.exception(str(e))\n            self.__secure_mode = 0\n            logger.critical('ZMQ Security Mechanism is disabled for this connection due to errors!')\n    if not self.__ssh_tunnel_mode is None:\n        if receive_mode:\n            logger.error('SSH Tunneling cannot be enabled for Client-end!')\n        else:\n            ssh_address = self.__ssh_tunnel_mode\n            (ssh_address, ssh_port) = ssh_address.split(':') if ':' in ssh_address else [ssh_address, '22']\n            if '47' in ssh_port:\n                self.__ssh_tunnel_mode = self.__ssh_tunnel_mode.replace(':47', '')\n            else:\n                (ssh_user, ssh_ip) = ssh_address.split('@') if '@' in ssh_address else ['', ssh_address]\n                assert check_open_port(ssh_ip, port=int(ssh_port)), '[NetGear:ERROR] :: Host `{}` is not available for SSH Tunneling at port-{}!'.format(ssh_address, ssh_port)\n    if self.__multiclient_mode and self.__multiserver_mode:\n        raise ValueError('[NetGear:ERROR] :: Multi-Client and Multi-Server Mode cannot be enabled simultaneously!')\n    elif self.__multiserver_mode or self.__multiclient_mode:\n        if self.__bi_mode:\n            self.__logging and logger.debug('Bidirectional Data Transmission is also enabled for this connection!')\n        if self.__ssh_tunnel_mode:\n            raise ValueError('[NetGear:ERROR] :: SSH Tunneling and {} Mode cannot be enabled simultaneously. Kindly refer docs!'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client'))\n    elif self.__bi_mode:\n        self.__logging and logger.debug('Bidirectional Data Transmission is enabled for this connection!')\n    elif self.__ssh_tunnel_mode:\n        self.__logging and logger.debug('SSH Tunneling is enabled for host:`{}` with `{}` back-end.'.format(self.__ssh_tunnel_mode, 'paramiko' if self.__paramiko_present else 'pexpect'))\n    self.__msg_context = zmq.Context.instance()\n    self.__receive_mode = receive_mode\n    if self.__receive_mode:\n        if address is None:\n            address = '*'\n        if self.__multiserver_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Server ports while Multi-Server mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif self.__multiclient_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Client-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[1])\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                server_secret_file = os.path.join(self.__auth_secretkeys_dir, 'server.key_secret')\n                (server_public, server_secret) = auth.load_certificate(server_secret_file)\n                self.__msg_socket.curve_secretkey = server_secret\n                self.__msg_socket.curve_publickey = server_public\n                self.__msg_socket.curve_server = True\n            if self.__pattern == 2:\n                self.__msg_socket.setsockopt_string(zmq.SUBSCRIBE, '')\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.RCVTIMEO, self.__subscriber_timeout)\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            if self.__multiserver_mode:\n                for pt in port:\n                    self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(pt))\n            else:\n                self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiserver_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[1]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n            else:\n                self.__logging and self.__subscriber_timeout and logger.debug('Timeout: {} secs is enabled for this system.'.format(self.__subscriber_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to bind address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        self.__logging and logger.debug('Threaded Queue Mode is enabled by default for this connection.')\n        self.__queue = deque(maxlen=96)\n        self.__thread = Thread(target=self.__recv_handler, name='NetGear', args=())\n        self.__thread.daemon = True\n        self.__thread.start()\n        if self.__logging:\n            logger.debug('Successfully Binded to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Successfully enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Multi-threaded Receive Mode is successfully enabled.')\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Receive Mode is now activated.')\n    else:\n        if address is None:\n            address = 'localhost'\n        if self.__multiserver_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Server-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif self.__multiclient_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Client ports while Multi-Client mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[0])\n            if self.__pattern == 1:\n                self.__msg_socket.REQ_RELAXED = True\n                self.__msg_socket.REQ_CORRELATE = True\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                client_secret_file = os.path.join(self.__auth_secretkeys_dir, 'client.key_secret')\n                (client_public, client_secret) = auth.load_certificate(client_secret_file)\n                self.__msg_socket.curve_secretkey = client_secret\n                self.__msg_socket.curve_publickey = client_public\n                server_public_file = os.path.join(self.__auth_publickeys_dir, 'server.key')\n                (server_public, _) = auth.load_certificate(server_public_file)\n                self.__msg_socket.curve_serverkey = server_public\n            if self.__multiclient_mode:\n                for pt in port:\n                    self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(pt))\n            elif self.__ssh_tunnel_mode:\n                ssh.tunnel_connection(self.__msg_socket, protocol + '://' + str(address) + ':' + str(port), self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n            else:\n                self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiclient_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[0]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                if self.__ssh_tunnel_mode:\n                    logger.critical('Failed to initiate SSH Tunneling Mode for this server with `{}` back-end!'.format('paramiko' if self.__paramiko_present else 'pexpect'))\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to connect address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        if self.__logging:\n            logger.debug('Successfully connected to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Send Mode is successfully activated and ready to send data.')",
            "def __init__(self, address=None, port=None, protocol=None, pattern=0, receive_mode=False, logging=False, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        This constructor method initializes the object state and attributes of the NetGear class.\\n\\n        Parameters:\\n            address (str): sets the valid network address of the Server/Client.\\n            port (str): sets the valid Network Port of the Server/Client.\\n            protocol (str): sets the valid messaging protocol between Server/Client.\\n            pattern (int): sets the supported messaging pattern(flow of communication) between Server/Client\\n            receive_mode (bool): select the Netgear's Mode of operation.\\n            logging (bool): enables/disables logging.\\n            options (dict): provides the flexibility to alter various NetGear internal properties.\\n        \"\n    logcurr_vidgear_ver(logging=logging)\n    import_dependency_safe('zmq' if zmq is None else '', min_version='4.0', pkg_name='pyzmq')\n    import_dependency_safe('simplejpeg' if simplejpeg is None else '', error='log', min_version='1.6.1')\n    self.__logging = True if logging else False\n    valid_messaging_patterns = {0: (zmq.PAIR, zmq.PAIR), 1: (zmq.REQ, zmq.REP), 2: (zmq.PUB, zmq.SUB)}\n    msg_pattern = None\n    if isinstance(pattern, int) and pattern in valid_messaging_patterns.keys():\n        msg_pattern = valid_messaging_patterns[pattern]\n    else:\n        pattern = 0\n        msg_pattern = valid_messaging_patterns[pattern]\n        self.__logging and logger.warning('Wrong pattern value, Defaulting to `zmq.PAIR`! Kindly refer Docs for more Information.')\n    self.__pattern = pattern\n    if protocol is None or not protocol in ['tcp', 'ipc']:\n        protocol = 'tcp'\n        self.__logging and logger.warning('Protocol is not supported or not provided. Defaulting to `tcp` protocol!')\n    self.__msg_flag = 0\n    self.__msg_copy = False\n    self.__msg_track = False\n    self.__ssh_tunnel_mode = None\n    self.__ssh_tunnel_pwd = None\n    self.__ssh_tunnel_keyfile = None\n    self.__paramiko_present = False if paramiko is None else True\n    self.__multiserver_mode = False\n    self.__multiclient_mode = False\n    self.__bi_mode = False\n    valid_security_mech = {0: 'Grasslands', 1: 'StoneHouse', 2: 'IronHouse'}\n    self.__secure_mode = 0\n    auth_cert_dir = ''\n    self.__auth_publickeys_dir = ''\n    self.__auth_secretkeys_dir = ''\n    overwrite_cert = False\n    custom_cert_location = ''\n    self.__jpeg_compression = True if not simplejpeg is None else False\n    self.__jpeg_compression_quality = 90\n    self.__jpeg_compression_fastdct = True\n    self.__jpeg_compression_fastupsample = False\n    self.__jpeg_compression_colorspace = 'BGR'\n    self.__ex_compression_params = None\n    self.__return_data = None\n    self.__id = ''.join((secrets.choice(string.ascii_uppercase + string.digits) for i in range(8)))\n    self.__terminate = False\n    if pattern < 2:\n        self.__poll = zmq.Poller()\n        self.__max_retries = 3\n        self.__request_timeout = 4000\n    else:\n        self.__subscriber_timeout = None\n    options = {str(k).strip(): v for (k, v) in options.items()}\n    for (key, value) in options.items():\n        if key == 'multiserver_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiserver_mode = value\n            else:\n                self.__multiserver_mode = False\n                logger.critical('Multi-Server Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Server Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'multiclient_mode' and isinstance(value, bool):\n            if pattern > 0:\n                self.__multiclient_mode = value\n            else:\n                self.__multiclient_mode = False\n                logger.critical('Multi-Client Mode is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Multi-Client Mode is enabled. Kindly refer Docs for more Information.'.format(pattern))\n        elif key == 'bidirectional_mode' and isinstance(value, bool):\n            if pattern < 2:\n                self.__bi_mode = value\n            else:\n                self.__bi_mode = False\n                logger.warning('Bidirectional data transmission is disabled!')\n                raise ValueError('[NetGear:ERROR] :: `{}` pattern is not valid when Bidirectional Mode is enabled. Kindly refer Docs for more Information!'.format(pattern))\n        elif key == 'secure_mode' and isinstance(value, int) and (value in valid_security_mech):\n            self.__secure_mode = value\n        elif key == 'custom_cert_location' and isinstance(value, str):\n            custom_cert_location = os.path.abspath(value)\n            assert os.path.isdir(custom_cert_location), '[NetGear:ERROR] :: `custom_cert_location` value must be the path to a valid directory!'\n            assert check_WriteAccess(custom_cert_location, is_windows=True if os.name == 'nt' else False, logging=self.__logging), \"[NetGear:ERROR] :: Permission Denied!, cannot write ZMQ authentication certificates to '{}' directory!\".format(value)\n        elif key == 'overwrite_cert' and isinstance(value, bool):\n            overwrite_cert = value\n        elif key == 'ssh_tunnel_mode' and isinstance(value, str):\n            self.__ssh_tunnel_mode = value.strip()\n        elif key == 'ssh_tunnel_pwd' and isinstance(value, str):\n            self.__ssh_tunnel_pwd = value\n        elif key == 'ssh_tunnel_keyfile' and isinstance(value, str):\n            self.__ssh_tunnel_keyfile = value if os.path.isfile(value) else None\n            if self.__ssh_tunnel_keyfile is None:\n                logger.warning('Discarded invalid or non-existential SSH Tunnel Key-file at {}!'.format(value))\n        elif key == 'jpeg_compression' and (not simplejpeg is None) and isinstance(value, (bool, str)):\n            if isinstance(value, str) and value.strip().upper() in ['RGB', 'BGR', 'RGBX', 'BGRX', 'XBGR', 'XRGB', 'GRAY', 'RGBA', 'BGRA', 'ABGR', 'ARGB', 'CMYK']:\n                self.__jpeg_compression_colorspace = value.strip().upper()\n                self.__jpeg_compression = True\n            else:\n                self.__jpeg_compression = value\n        elif key == 'jpeg_compression_quality' and isinstance(value, (int, float)):\n            if value >= 10 and value <= 100:\n                self.__jpeg_compression_quality = int(value)\n            else:\n                logger.warning('Skipped invalid `jpeg_compression_quality` value!')\n        elif key == 'jpeg_compression_fastdct' and isinstance(value, bool):\n            self.__jpeg_compression_fastdct = value\n        elif key == 'jpeg_compression_fastupsample' and isinstance(value, bool):\n            self.__jpeg_compression_fastupsample = value\n        elif key == 'max_retries' and isinstance(value, int) and (pattern < 2):\n            if value >= 0:\n                self.__max_retries = value\n            else:\n                logger.warning('Invalid `max_retries` value skipped!')\n        elif key == 'request_timeout' and isinstance(value, int) and (pattern < 2):\n            if value >= 4:\n                self.__request_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'subscriber_timeout' and isinstance(value, int) and (pattern == 2):\n            if value > 0:\n                self.__subscriber_timeout = value * 1000\n            else:\n                logger.warning('Invalid `request_timeout` value skipped!')\n        elif key == 'flag' and isinstance(value, int):\n            self.__msg_flag = value\n        elif key == 'copy' and isinstance(value, bool):\n            self.__msg_copy = value\n        elif key == 'track' and isinstance(value, bool):\n            self.__msg_track = value\n        else:\n            pass\n    if self.__secure_mode:\n        if overwrite_cert:\n            if not receive_mode:\n                self.__logging and logger.warning('Overwriting ZMQ Authentication certificates over previous ones!')\n            else:\n                overwrite_cert = False\n                self.__logging and logger.critical(\"Overwriting ZMQ Authentication certificates is disabled for Client's end!\")\n        try:\n            if custom_cert_location:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(custom_cert_location, overwrite=overwrite_cert, logging=logging)\n            else:\n                (auth_cert_dir, self.__auth_secretkeys_dir, self.__auth_publickeys_dir) = generate_auth_certificates(os.path.join(expanduser('~'), '.vidgear'), overwrite=overwrite_cert, logging=logging)\n            self.__logging and logger.debug('`{}` is the default location for storing ZMQ authentication certificates/keys.'.format(auth_cert_dir))\n        except Exception as e:\n            logger.exception(str(e))\n            self.__secure_mode = 0\n            logger.critical('ZMQ Security Mechanism is disabled for this connection due to errors!')\n    if not self.__ssh_tunnel_mode is None:\n        if receive_mode:\n            logger.error('SSH Tunneling cannot be enabled for Client-end!')\n        else:\n            ssh_address = self.__ssh_tunnel_mode\n            (ssh_address, ssh_port) = ssh_address.split(':') if ':' in ssh_address else [ssh_address, '22']\n            if '47' in ssh_port:\n                self.__ssh_tunnel_mode = self.__ssh_tunnel_mode.replace(':47', '')\n            else:\n                (ssh_user, ssh_ip) = ssh_address.split('@') if '@' in ssh_address else ['', ssh_address]\n                assert check_open_port(ssh_ip, port=int(ssh_port)), '[NetGear:ERROR] :: Host `{}` is not available for SSH Tunneling at port-{}!'.format(ssh_address, ssh_port)\n    if self.__multiclient_mode and self.__multiserver_mode:\n        raise ValueError('[NetGear:ERROR] :: Multi-Client and Multi-Server Mode cannot be enabled simultaneously!')\n    elif self.__multiserver_mode or self.__multiclient_mode:\n        if self.__bi_mode:\n            self.__logging and logger.debug('Bidirectional Data Transmission is also enabled for this connection!')\n        if self.__ssh_tunnel_mode:\n            raise ValueError('[NetGear:ERROR] :: SSH Tunneling and {} Mode cannot be enabled simultaneously. Kindly refer docs!'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client'))\n    elif self.__bi_mode:\n        self.__logging and logger.debug('Bidirectional Data Transmission is enabled for this connection!')\n    elif self.__ssh_tunnel_mode:\n        self.__logging and logger.debug('SSH Tunneling is enabled for host:`{}` with `{}` back-end.'.format(self.__ssh_tunnel_mode, 'paramiko' if self.__paramiko_present else 'pexpect'))\n    self.__msg_context = zmq.Context.instance()\n    self.__receive_mode = receive_mode\n    if self.__receive_mode:\n        if address is None:\n            address = '*'\n        if self.__multiserver_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Server ports while Multi-Server mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif self.__multiclient_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Client-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[1])\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                server_secret_file = os.path.join(self.__auth_secretkeys_dir, 'server.key_secret')\n                (server_public, server_secret) = auth.load_certificate(server_secret_file)\n                self.__msg_socket.curve_secretkey = server_secret\n                self.__msg_socket.curve_publickey = server_public\n                self.__msg_socket.curve_server = True\n            if self.__pattern == 2:\n                self.__msg_socket.setsockopt_string(zmq.SUBSCRIBE, '')\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.RCVTIMEO, self.__subscriber_timeout)\n                self.__subscriber_timeout and self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            if self.__multiserver_mode:\n                for pt in port:\n                    self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(pt))\n            else:\n                self.__msg_socket.bind(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiserver_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[1]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n            else:\n                self.__logging and self.__subscriber_timeout and logger.debug('Timeout: {} secs is enabled for this system.'.format(self.__subscriber_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                raise RuntimeError('[NetGear:ERROR] :: Receive Mode failed to bind address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        self.__logging and logger.debug('Threaded Queue Mode is enabled by default for this connection.')\n        self.__queue = deque(maxlen=96)\n        self.__thread = Thread(target=self.__recv_handler, name='NetGear', args=())\n        self.__thread.daemon = True\n        self.__thread.start()\n        if self.__logging:\n            logger.debug('Successfully Binded to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Successfully enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Multi-threaded Receive Mode is successfully enabled.')\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Receive Mode is now activated.')\n    else:\n        if address is None:\n            address = 'localhost'\n        if self.__multiserver_mode:\n            if port is None:\n                raise ValueError('[NetGear:ERROR] :: Kindly provide a unique & valid port value at Server-end. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Server Mode at PORT: {} on this device!'.format(port))\n            self.__port = port\n        elif self.__multiclient_mode:\n            if port is None or not isinstance(port, (tuple, list)):\n                raise ValueError('[NetGear:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Client ports while Multi-Client mode is enabled. For more information refer VidGear docs.')\n            else:\n                logger.debug('Enabling Multi-Client Mode at PORTS: {}!'.format(port))\n            self.__port_buffer = []\n        elif port is None:\n            port = '5555'\n        try:\n            if self.__secure_mode > 0:\n                z_auth = ThreadAuthenticator(self.__msg_context)\n                z_auth.start()\n                z_auth.allow(str(address))\n                if self.__secure_mode == 2:\n                    z_auth.configure_curve(domain='*', location=self.__auth_publickeys_dir)\n                else:\n                    z_auth.configure_curve(domain='*', location=auth.CURVE_ALLOW_ANY)\n            self.__msg_socket = self.__msg_context.socket(msg_pattern[0])\n            if self.__pattern == 1:\n                self.__msg_socket.REQ_RELAXED = True\n                self.__msg_socket.REQ_CORRELATE = True\n            if self.__pattern == 2:\n                self.__msg_socket.set_hwm(1)\n            if self.__secure_mode > 0:\n                client_secret_file = os.path.join(self.__auth_secretkeys_dir, 'client.key_secret')\n                (client_public, client_secret) = auth.load_certificate(client_secret_file)\n                self.__msg_socket.curve_secretkey = client_secret\n                self.__msg_socket.curve_publickey = client_public\n                server_public_file = os.path.join(self.__auth_publickeys_dir, 'server.key')\n                (server_public, _) = auth.load_certificate(server_public_file)\n                self.__msg_socket.curve_serverkey = server_public\n            if self.__multiclient_mode:\n                for pt in port:\n                    self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(pt))\n            elif self.__ssh_tunnel_mode:\n                ssh.tunnel_connection(self.__msg_socket, protocol + '://' + str(address) + ':' + str(port), self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n            else:\n                self.__msg_socket.connect(protocol + '://' + str(address) + ':' + str(port))\n            if pattern < 2:\n                if self.__multiclient_mode:\n                    self.__connection_address = []\n                    for pt in port:\n                        self.__connection_address.append(protocol + '://' + str(address) + ':' + str(pt))\n                else:\n                    self.__connection_address = protocol + '://' + str(address) + ':' + str(port)\n                self.__msg_pattern = msg_pattern[0]\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                self.__logging and logger.debug('Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.'.format(self.__max_retries, self.__request_timeout / 1000))\n        except Exception as e:\n            logger.exception(str(e))\n            if self.__secure_mode:\n                logger.critical('Failed to activate Secure Mode: `{}` for this connection!'.format(valid_security_mech[self.__secure_mode]))\n            if self.__multiserver_mode or self.__multiclient_mode:\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.'.format('Multi-Server' if self.__multiserver_mode else 'Multi-Client', protocol + '://' + str(address) + ':' + str(port), pattern))\n            else:\n                if self.__bi_mode:\n                    logger.critical('Failed to activate Bidirectional Mode for this connection!')\n                if self.__ssh_tunnel_mode:\n                    logger.critical('Failed to initiate SSH Tunneling Mode for this server with `{}` back-end!'.format('paramiko' if self.__paramiko_present else 'pexpect'))\n                raise RuntimeError('[NetGear:ERROR] :: Send Mode failed to connect address: {} and pattern: {}! Kindly recheck all parameters.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n        if self.__logging:\n            logger.debug('Successfully connected to address: {} with pattern: {}.'.format(protocol + '://' + str(address) + ':' + str(port), pattern))\n            if self.__jpeg_compression:\n                logger.debug('JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.'.format(self.__jpeg_compression_colorspace, self.__jpeg_compression_quality, 'enabled' if self.__jpeg_compression_fastdct else 'disabled', 'enabled' if self.__jpeg_compression_fastupsample else 'disabled'))\n            if self.__secure_mode:\n                logger.debug('Enabled ZMQ Security Mechanism: `{}` for this connection.'.format(valid_security_mech[self.__secure_mode]))\n            logger.debug('Unique System ID is {}.'.format(self.__id))\n            logger.debug('Send Mode is successfully activated and ready to send data.')"
        ]
    },
    {
        "func_name": "__recv_handler",
        "original": "def __recv_handler(self):\n    \"\"\"\n        A threaded receiver handler, that keep iterating data from ZMQ socket to a internally monitored deque,\n        until the thread is terminated, or socket disconnects.\n        \"\"\"\n    frame = None\n    while not self.__terminate:\n        if len(self.__queue) >= 96:\n            time.sleep(1e-06)\n            continue\n        if self.__pattern < 2:\n            socks = dict(self.__poll.poll(self.__request_timeout * 3))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag | zmq.DONTWAIT)\n            else:\n                logger.critical('No response from Server(s), Reconnecting again...')\n                self.__msg_socket.close(linger=0)\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiserver_mode:\n                        logger.error('All Servers seems to be offline, Abandoning!')\n                    else:\n                        logger.error('Server seems to be offline, Abandoning!')\n                    self.__terminate = True\n                    continue\n                try:\n                    self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                    if isinstance(self.__connection_address, list):\n                        for _connection in self.__connection_address:\n                            self.__msg_socket.bind(_connection)\n                    else:\n                        self.__msg_socket.bind(self.__connection_address)\n                except Exception as e:\n                    logger.exception(str(e))\n                    self.__terminate = True\n                    raise RuntimeError('API failed to restart the Client-end!')\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                continue\n        else:\n            try:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            except zmq.ZMQError as e:\n                if e.errno == zmq.EAGAIN:\n                    logger.critical('Connection Timeout. Exiting!')\n                    self.__terminate = True\n                    self.__queue.append(None)\n                    break\n        if msg_json['terminate_flag']:\n            if self.__multiserver_mode:\n                if msg_json['port'] in self.__port_buffer:\n                    if self.__pattern == 1:\n                        self.__msg_socket.send_string('Termination signal successfully received at client!')\n                    self.__port_buffer.remove(msg_json['port'])\n                    self.__logging and logger.warning('Termination signal received from Server at port: {}!'.format(msg_json['port']))\n                if not self.__port_buffer:\n                    logger.critical('Termination signal received from all Servers!!!')\n                    self.__terminate = True\n            else:\n                if self.__pattern == 1:\n                    self.__msg_socket.send_string(\"Termination signal successfully received at Client's end!\")\n                self.__terminate = True\n                self.__logging and logger.critical('Termination signal received from server!')\n            continue\n        msg_data = self.__msg_socket.recv(flags=self.__msg_flag | zmq.DONTWAIT, copy=self.__msg_copy, track=self.__msg_track)\n        if self.__pattern < 2:\n            if self.__bi_mode or self.__multiclient_mode:\n                if not self.__return_data is None and isinstance(self.__return_data, np.ndarray):\n                    return_data = np.copy(self.__return_data)\n                    if not return_data.flags['C_CONTIGUOUS']:\n                        return_data = np.ascontiguousarray(return_data, dtype=return_data.dtype)\n                    if self.__jpeg_compression:\n                        if self.__jpeg_compression_colorspace == 'GRAY':\n                            if return_data.ndim == 2:\n                                return_data = return_data[:, :, np.newaxis]\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n                        else:\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, array_dtype=str(self.__return_data.dtype) if not self.__jpeg_compression else '', array_shape=self.__return_data.shape if not self.__jpeg_compression else '', data=None))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag | zmq.SNDMORE)\n                    self.__msg_socket.send(return_data, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                else:\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, data=self.__return_data))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag)\n            else:\n                self.__msg_socket.send_string('Data received on device: {} !'.format(self.__id))\n        elif self.__return_data:\n            logger.warning('`return_data` is disabled for this pattern!')\n        if msg_json['compression']:\n            frame = simplejpeg.decode_jpeg(msg_data, colorspace=msg_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or msg_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or msg_json['compression']['ups'])\n            if frame is None:\n                self.__terminate = True\n                raise RuntimeError('[NetGear:ERROR] :: Received compressed JPEG frame decoding failed')\n            if msg_json['compression']['colorspace'] == 'GRAY' and frame.ndim == 3:\n                frame = np.squeeze(frame, axis=2)\n        else:\n            frame_buffer = np.frombuffer(msg_data, dtype=msg_json['dtype'])\n            frame = frame_buffer.reshape(msg_json['shape'])\n        if self.__multiserver_mode:\n            if not msg_json['port'] in self.__port_buffer:\n                self.__port_buffer.append(msg_json['port'])\n            if msg_json['message']:\n                self.__queue.append((msg_json['port'], msg_json['message'], frame))\n            else:\n                self.__queue.append((msg_json['port'], frame))\n        elif self.__bi_mode:\n            if msg_json['message']:\n                self.__queue.append((msg_json['message'], frame))\n            else:\n                self.__queue.append((None, frame))\n        else:\n            self.__queue.append(frame)",
        "mutated": [
            "def __recv_handler(self):\n    if False:\n        i = 10\n    '\\n        A threaded receiver handler, that keep iterating data from ZMQ socket to a internally monitored deque,\\n        until the thread is terminated, or socket disconnects.\\n        '\n    frame = None\n    while not self.__terminate:\n        if len(self.__queue) >= 96:\n            time.sleep(1e-06)\n            continue\n        if self.__pattern < 2:\n            socks = dict(self.__poll.poll(self.__request_timeout * 3))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag | zmq.DONTWAIT)\n            else:\n                logger.critical('No response from Server(s), Reconnecting again...')\n                self.__msg_socket.close(linger=0)\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiserver_mode:\n                        logger.error('All Servers seems to be offline, Abandoning!')\n                    else:\n                        logger.error('Server seems to be offline, Abandoning!')\n                    self.__terminate = True\n                    continue\n                try:\n                    self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                    if isinstance(self.__connection_address, list):\n                        for _connection in self.__connection_address:\n                            self.__msg_socket.bind(_connection)\n                    else:\n                        self.__msg_socket.bind(self.__connection_address)\n                except Exception as e:\n                    logger.exception(str(e))\n                    self.__terminate = True\n                    raise RuntimeError('API failed to restart the Client-end!')\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                continue\n        else:\n            try:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            except zmq.ZMQError as e:\n                if e.errno == zmq.EAGAIN:\n                    logger.critical('Connection Timeout. Exiting!')\n                    self.__terminate = True\n                    self.__queue.append(None)\n                    break\n        if msg_json['terminate_flag']:\n            if self.__multiserver_mode:\n                if msg_json['port'] in self.__port_buffer:\n                    if self.__pattern == 1:\n                        self.__msg_socket.send_string('Termination signal successfully received at client!')\n                    self.__port_buffer.remove(msg_json['port'])\n                    self.__logging and logger.warning('Termination signal received from Server at port: {}!'.format(msg_json['port']))\n                if not self.__port_buffer:\n                    logger.critical('Termination signal received from all Servers!!!')\n                    self.__terminate = True\n            else:\n                if self.__pattern == 1:\n                    self.__msg_socket.send_string(\"Termination signal successfully received at Client's end!\")\n                self.__terminate = True\n                self.__logging and logger.critical('Termination signal received from server!')\n            continue\n        msg_data = self.__msg_socket.recv(flags=self.__msg_flag | zmq.DONTWAIT, copy=self.__msg_copy, track=self.__msg_track)\n        if self.__pattern < 2:\n            if self.__bi_mode or self.__multiclient_mode:\n                if not self.__return_data is None and isinstance(self.__return_data, np.ndarray):\n                    return_data = np.copy(self.__return_data)\n                    if not return_data.flags['C_CONTIGUOUS']:\n                        return_data = np.ascontiguousarray(return_data, dtype=return_data.dtype)\n                    if self.__jpeg_compression:\n                        if self.__jpeg_compression_colorspace == 'GRAY':\n                            if return_data.ndim == 2:\n                                return_data = return_data[:, :, np.newaxis]\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n                        else:\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, array_dtype=str(self.__return_data.dtype) if not self.__jpeg_compression else '', array_shape=self.__return_data.shape if not self.__jpeg_compression else '', data=None))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag | zmq.SNDMORE)\n                    self.__msg_socket.send(return_data, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                else:\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, data=self.__return_data))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag)\n            else:\n                self.__msg_socket.send_string('Data received on device: {} !'.format(self.__id))\n        elif self.__return_data:\n            logger.warning('`return_data` is disabled for this pattern!')\n        if msg_json['compression']:\n            frame = simplejpeg.decode_jpeg(msg_data, colorspace=msg_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or msg_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or msg_json['compression']['ups'])\n            if frame is None:\n                self.__terminate = True\n                raise RuntimeError('[NetGear:ERROR] :: Received compressed JPEG frame decoding failed')\n            if msg_json['compression']['colorspace'] == 'GRAY' and frame.ndim == 3:\n                frame = np.squeeze(frame, axis=2)\n        else:\n            frame_buffer = np.frombuffer(msg_data, dtype=msg_json['dtype'])\n            frame = frame_buffer.reshape(msg_json['shape'])\n        if self.__multiserver_mode:\n            if not msg_json['port'] in self.__port_buffer:\n                self.__port_buffer.append(msg_json['port'])\n            if msg_json['message']:\n                self.__queue.append((msg_json['port'], msg_json['message'], frame))\n            else:\n                self.__queue.append((msg_json['port'], frame))\n        elif self.__bi_mode:\n            if msg_json['message']:\n                self.__queue.append((msg_json['message'], frame))\n            else:\n                self.__queue.append((None, frame))\n        else:\n            self.__queue.append(frame)",
            "def __recv_handler(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        A threaded receiver handler, that keep iterating data from ZMQ socket to a internally monitored deque,\\n        until the thread is terminated, or socket disconnects.\\n        '\n    frame = None\n    while not self.__terminate:\n        if len(self.__queue) >= 96:\n            time.sleep(1e-06)\n            continue\n        if self.__pattern < 2:\n            socks = dict(self.__poll.poll(self.__request_timeout * 3))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag | zmq.DONTWAIT)\n            else:\n                logger.critical('No response from Server(s), Reconnecting again...')\n                self.__msg_socket.close(linger=0)\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiserver_mode:\n                        logger.error('All Servers seems to be offline, Abandoning!')\n                    else:\n                        logger.error('Server seems to be offline, Abandoning!')\n                    self.__terminate = True\n                    continue\n                try:\n                    self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                    if isinstance(self.__connection_address, list):\n                        for _connection in self.__connection_address:\n                            self.__msg_socket.bind(_connection)\n                    else:\n                        self.__msg_socket.bind(self.__connection_address)\n                except Exception as e:\n                    logger.exception(str(e))\n                    self.__terminate = True\n                    raise RuntimeError('API failed to restart the Client-end!')\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                continue\n        else:\n            try:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            except zmq.ZMQError as e:\n                if e.errno == zmq.EAGAIN:\n                    logger.critical('Connection Timeout. Exiting!')\n                    self.__terminate = True\n                    self.__queue.append(None)\n                    break\n        if msg_json['terminate_flag']:\n            if self.__multiserver_mode:\n                if msg_json['port'] in self.__port_buffer:\n                    if self.__pattern == 1:\n                        self.__msg_socket.send_string('Termination signal successfully received at client!')\n                    self.__port_buffer.remove(msg_json['port'])\n                    self.__logging and logger.warning('Termination signal received from Server at port: {}!'.format(msg_json['port']))\n                if not self.__port_buffer:\n                    logger.critical('Termination signal received from all Servers!!!')\n                    self.__terminate = True\n            else:\n                if self.__pattern == 1:\n                    self.__msg_socket.send_string(\"Termination signal successfully received at Client's end!\")\n                self.__terminate = True\n                self.__logging and logger.critical('Termination signal received from server!')\n            continue\n        msg_data = self.__msg_socket.recv(flags=self.__msg_flag | zmq.DONTWAIT, copy=self.__msg_copy, track=self.__msg_track)\n        if self.__pattern < 2:\n            if self.__bi_mode or self.__multiclient_mode:\n                if not self.__return_data is None and isinstance(self.__return_data, np.ndarray):\n                    return_data = np.copy(self.__return_data)\n                    if not return_data.flags['C_CONTIGUOUS']:\n                        return_data = np.ascontiguousarray(return_data, dtype=return_data.dtype)\n                    if self.__jpeg_compression:\n                        if self.__jpeg_compression_colorspace == 'GRAY':\n                            if return_data.ndim == 2:\n                                return_data = return_data[:, :, np.newaxis]\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n                        else:\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, array_dtype=str(self.__return_data.dtype) if not self.__jpeg_compression else '', array_shape=self.__return_data.shape if not self.__jpeg_compression else '', data=None))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag | zmq.SNDMORE)\n                    self.__msg_socket.send(return_data, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                else:\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, data=self.__return_data))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag)\n            else:\n                self.__msg_socket.send_string('Data received on device: {} !'.format(self.__id))\n        elif self.__return_data:\n            logger.warning('`return_data` is disabled for this pattern!')\n        if msg_json['compression']:\n            frame = simplejpeg.decode_jpeg(msg_data, colorspace=msg_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or msg_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or msg_json['compression']['ups'])\n            if frame is None:\n                self.__terminate = True\n                raise RuntimeError('[NetGear:ERROR] :: Received compressed JPEG frame decoding failed')\n            if msg_json['compression']['colorspace'] == 'GRAY' and frame.ndim == 3:\n                frame = np.squeeze(frame, axis=2)\n        else:\n            frame_buffer = np.frombuffer(msg_data, dtype=msg_json['dtype'])\n            frame = frame_buffer.reshape(msg_json['shape'])\n        if self.__multiserver_mode:\n            if not msg_json['port'] in self.__port_buffer:\n                self.__port_buffer.append(msg_json['port'])\n            if msg_json['message']:\n                self.__queue.append((msg_json['port'], msg_json['message'], frame))\n            else:\n                self.__queue.append((msg_json['port'], frame))\n        elif self.__bi_mode:\n            if msg_json['message']:\n                self.__queue.append((msg_json['message'], frame))\n            else:\n                self.__queue.append((None, frame))\n        else:\n            self.__queue.append(frame)",
            "def __recv_handler(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        A threaded receiver handler, that keep iterating data from ZMQ socket to a internally monitored deque,\\n        until the thread is terminated, or socket disconnects.\\n        '\n    frame = None\n    while not self.__terminate:\n        if len(self.__queue) >= 96:\n            time.sleep(1e-06)\n            continue\n        if self.__pattern < 2:\n            socks = dict(self.__poll.poll(self.__request_timeout * 3))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag | zmq.DONTWAIT)\n            else:\n                logger.critical('No response from Server(s), Reconnecting again...')\n                self.__msg_socket.close(linger=0)\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiserver_mode:\n                        logger.error('All Servers seems to be offline, Abandoning!')\n                    else:\n                        logger.error('Server seems to be offline, Abandoning!')\n                    self.__terminate = True\n                    continue\n                try:\n                    self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                    if isinstance(self.__connection_address, list):\n                        for _connection in self.__connection_address:\n                            self.__msg_socket.bind(_connection)\n                    else:\n                        self.__msg_socket.bind(self.__connection_address)\n                except Exception as e:\n                    logger.exception(str(e))\n                    self.__terminate = True\n                    raise RuntimeError('API failed to restart the Client-end!')\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                continue\n        else:\n            try:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            except zmq.ZMQError as e:\n                if e.errno == zmq.EAGAIN:\n                    logger.critical('Connection Timeout. Exiting!')\n                    self.__terminate = True\n                    self.__queue.append(None)\n                    break\n        if msg_json['terminate_flag']:\n            if self.__multiserver_mode:\n                if msg_json['port'] in self.__port_buffer:\n                    if self.__pattern == 1:\n                        self.__msg_socket.send_string('Termination signal successfully received at client!')\n                    self.__port_buffer.remove(msg_json['port'])\n                    self.__logging and logger.warning('Termination signal received from Server at port: {}!'.format(msg_json['port']))\n                if not self.__port_buffer:\n                    logger.critical('Termination signal received from all Servers!!!')\n                    self.__terminate = True\n            else:\n                if self.__pattern == 1:\n                    self.__msg_socket.send_string(\"Termination signal successfully received at Client's end!\")\n                self.__terminate = True\n                self.__logging and logger.critical('Termination signal received from server!')\n            continue\n        msg_data = self.__msg_socket.recv(flags=self.__msg_flag | zmq.DONTWAIT, copy=self.__msg_copy, track=self.__msg_track)\n        if self.__pattern < 2:\n            if self.__bi_mode or self.__multiclient_mode:\n                if not self.__return_data is None and isinstance(self.__return_data, np.ndarray):\n                    return_data = np.copy(self.__return_data)\n                    if not return_data.flags['C_CONTIGUOUS']:\n                        return_data = np.ascontiguousarray(return_data, dtype=return_data.dtype)\n                    if self.__jpeg_compression:\n                        if self.__jpeg_compression_colorspace == 'GRAY':\n                            if return_data.ndim == 2:\n                                return_data = return_data[:, :, np.newaxis]\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n                        else:\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, array_dtype=str(self.__return_data.dtype) if not self.__jpeg_compression else '', array_shape=self.__return_data.shape if not self.__jpeg_compression else '', data=None))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag | zmq.SNDMORE)\n                    self.__msg_socket.send(return_data, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                else:\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, data=self.__return_data))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag)\n            else:\n                self.__msg_socket.send_string('Data received on device: {} !'.format(self.__id))\n        elif self.__return_data:\n            logger.warning('`return_data` is disabled for this pattern!')\n        if msg_json['compression']:\n            frame = simplejpeg.decode_jpeg(msg_data, colorspace=msg_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or msg_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or msg_json['compression']['ups'])\n            if frame is None:\n                self.__terminate = True\n                raise RuntimeError('[NetGear:ERROR] :: Received compressed JPEG frame decoding failed')\n            if msg_json['compression']['colorspace'] == 'GRAY' and frame.ndim == 3:\n                frame = np.squeeze(frame, axis=2)\n        else:\n            frame_buffer = np.frombuffer(msg_data, dtype=msg_json['dtype'])\n            frame = frame_buffer.reshape(msg_json['shape'])\n        if self.__multiserver_mode:\n            if not msg_json['port'] in self.__port_buffer:\n                self.__port_buffer.append(msg_json['port'])\n            if msg_json['message']:\n                self.__queue.append((msg_json['port'], msg_json['message'], frame))\n            else:\n                self.__queue.append((msg_json['port'], frame))\n        elif self.__bi_mode:\n            if msg_json['message']:\n                self.__queue.append((msg_json['message'], frame))\n            else:\n                self.__queue.append((None, frame))\n        else:\n            self.__queue.append(frame)",
            "def __recv_handler(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        A threaded receiver handler, that keep iterating data from ZMQ socket to a internally monitored deque,\\n        until the thread is terminated, or socket disconnects.\\n        '\n    frame = None\n    while not self.__terminate:\n        if len(self.__queue) >= 96:\n            time.sleep(1e-06)\n            continue\n        if self.__pattern < 2:\n            socks = dict(self.__poll.poll(self.__request_timeout * 3))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag | zmq.DONTWAIT)\n            else:\n                logger.critical('No response from Server(s), Reconnecting again...')\n                self.__msg_socket.close(linger=0)\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiserver_mode:\n                        logger.error('All Servers seems to be offline, Abandoning!')\n                    else:\n                        logger.error('Server seems to be offline, Abandoning!')\n                    self.__terminate = True\n                    continue\n                try:\n                    self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                    if isinstance(self.__connection_address, list):\n                        for _connection in self.__connection_address:\n                            self.__msg_socket.bind(_connection)\n                    else:\n                        self.__msg_socket.bind(self.__connection_address)\n                except Exception as e:\n                    logger.exception(str(e))\n                    self.__terminate = True\n                    raise RuntimeError('API failed to restart the Client-end!')\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                continue\n        else:\n            try:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            except zmq.ZMQError as e:\n                if e.errno == zmq.EAGAIN:\n                    logger.critical('Connection Timeout. Exiting!')\n                    self.__terminate = True\n                    self.__queue.append(None)\n                    break\n        if msg_json['terminate_flag']:\n            if self.__multiserver_mode:\n                if msg_json['port'] in self.__port_buffer:\n                    if self.__pattern == 1:\n                        self.__msg_socket.send_string('Termination signal successfully received at client!')\n                    self.__port_buffer.remove(msg_json['port'])\n                    self.__logging and logger.warning('Termination signal received from Server at port: {}!'.format(msg_json['port']))\n                if not self.__port_buffer:\n                    logger.critical('Termination signal received from all Servers!!!')\n                    self.__terminate = True\n            else:\n                if self.__pattern == 1:\n                    self.__msg_socket.send_string(\"Termination signal successfully received at Client's end!\")\n                self.__terminate = True\n                self.__logging and logger.critical('Termination signal received from server!')\n            continue\n        msg_data = self.__msg_socket.recv(flags=self.__msg_flag | zmq.DONTWAIT, copy=self.__msg_copy, track=self.__msg_track)\n        if self.__pattern < 2:\n            if self.__bi_mode or self.__multiclient_mode:\n                if not self.__return_data is None and isinstance(self.__return_data, np.ndarray):\n                    return_data = np.copy(self.__return_data)\n                    if not return_data.flags['C_CONTIGUOUS']:\n                        return_data = np.ascontiguousarray(return_data, dtype=return_data.dtype)\n                    if self.__jpeg_compression:\n                        if self.__jpeg_compression_colorspace == 'GRAY':\n                            if return_data.ndim == 2:\n                                return_data = return_data[:, :, np.newaxis]\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n                        else:\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, array_dtype=str(self.__return_data.dtype) if not self.__jpeg_compression else '', array_shape=self.__return_data.shape if not self.__jpeg_compression else '', data=None))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag | zmq.SNDMORE)\n                    self.__msg_socket.send(return_data, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                else:\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, data=self.__return_data))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag)\n            else:\n                self.__msg_socket.send_string('Data received on device: {} !'.format(self.__id))\n        elif self.__return_data:\n            logger.warning('`return_data` is disabled for this pattern!')\n        if msg_json['compression']:\n            frame = simplejpeg.decode_jpeg(msg_data, colorspace=msg_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or msg_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or msg_json['compression']['ups'])\n            if frame is None:\n                self.__terminate = True\n                raise RuntimeError('[NetGear:ERROR] :: Received compressed JPEG frame decoding failed')\n            if msg_json['compression']['colorspace'] == 'GRAY' and frame.ndim == 3:\n                frame = np.squeeze(frame, axis=2)\n        else:\n            frame_buffer = np.frombuffer(msg_data, dtype=msg_json['dtype'])\n            frame = frame_buffer.reshape(msg_json['shape'])\n        if self.__multiserver_mode:\n            if not msg_json['port'] in self.__port_buffer:\n                self.__port_buffer.append(msg_json['port'])\n            if msg_json['message']:\n                self.__queue.append((msg_json['port'], msg_json['message'], frame))\n            else:\n                self.__queue.append((msg_json['port'], frame))\n        elif self.__bi_mode:\n            if msg_json['message']:\n                self.__queue.append((msg_json['message'], frame))\n            else:\n                self.__queue.append((None, frame))\n        else:\n            self.__queue.append(frame)",
            "def __recv_handler(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        A threaded receiver handler, that keep iterating data from ZMQ socket to a internally monitored deque,\\n        until the thread is terminated, or socket disconnects.\\n        '\n    frame = None\n    while not self.__terminate:\n        if len(self.__queue) >= 96:\n            time.sleep(1e-06)\n            continue\n        if self.__pattern < 2:\n            socks = dict(self.__poll.poll(self.__request_timeout * 3))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag | zmq.DONTWAIT)\n            else:\n                logger.critical('No response from Server(s), Reconnecting again...')\n                self.__msg_socket.close(linger=0)\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiserver_mode:\n                        logger.error('All Servers seems to be offline, Abandoning!')\n                    else:\n                        logger.error('Server seems to be offline, Abandoning!')\n                    self.__terminate = True\n                    continue\n                try:\n                    self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                    if isinstance(self.__connection_address, list):\n                        for _connection in self.__connection_address:\n                            self.__msg_socket.bind(_connection)\n                    else:\n                        self.__msg_socket.bind(self.__connection_address)\n                except Exception as e:\n                    logger.exception(str(e))\n                    self.__terminate = True\n                    raise RuntimeError('API failed to restart the Client-end!')\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                continue\n        else:\n            try:\n                msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            except zmq.ZMQError as e:\n                if e.errno == zmq.EAGAIN:\n                    logger.critical('Connection Timeout. Exiting!')\n                    self.__terminate = True\n                    self.__queue.append(None)\n                    break\n        if msg_json['terminate_flag']:\n            if self.__multiserver_mode:\n                if msg_json['port'] in self.__port_buffer:\n                    if self.__pattern == 1:\n                        self.__msg_socket.send_string('Termination signal successfully received at client!')\n                    self.__port_buffer.remove(msg_json['port'])\n                    self.__logging and logger.warning('Termination signal received from Server at port: {}!'.format(msg_json['port']))\n                if not self.__port_buffer:\n                    logger.critical('Termination signal received from all Servers!!!')\n                    self.__terminate = True\n            else:\n                if self.__pattern == 1:\n                    self.__msg_socket.send_string(\"Termination signal successfully received at Client's end!\")\n                self.__terminate = True\n                self.__logging and logger.critical('Termination signal received from server!')\n            continue\n        msg_data = self.__msg_socket.recv(flags=self.__msg_flag | zmq.DONTWAIT, copy=self.__msg_copy, track=self.__msg_track)\n        if self.__pattern < 2:\n            if self.__bi_mode or self.__multiclient_mode:\n                if not self.__return_data is None and isinstance(self.__return_data, np.ndarray):\n                    return_data = np.copy(self.__return_data)\n                    if not return_data.flags['C_CONTIGUOUS']:\n                        return_data = np.ascontiguousarray(return_data, dtype=return_data.dtype)\n                    if self.__jpeg_compression:\n                        if self.__jpeg_compression_colorspace == 'GRAY':\n                            if return_data.ndim == 2:\n                                return_data = return_data[:, :, np.newaxis]\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n                        else:\n                            return_data = simplejpeg.encode_jpeg(return_data, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, array_dtype=str(self.__return_data.dtype) if not self.__jpeg_compression else '', array_shape=self.__return_data.shape if not self.__jpeg_compression else '', data=None))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag | zmq.SNDMORE)\n                    self.__msg_socket.send(return_data, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                else:\n                    return_dict = dict(port=self.__port) if self.__multiclient_mode else dict()\n                    return_dict.update(dict(return_type=type(self.__return_data).__name__, data=self.__return_data))\n                    self.__msg_socket.send_json(return_dict, self.__msg_flag)\n            else:\n                self.__msg_socket.send_string('Data received on device: {} !'.format(self.__id))\n        elif self.__return_data:\n            logger.warning('`return_data` is disabled for this pattern!')\n        if msg_json['compression']:\n            frame = simplejpeg.decode_jpeg(msg_data, colorspace=msg_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or msg_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or msg_json['compression']['ups'])\n            if frame is None:\n                self.__terminate = True\n                raise RuntimeError('[NetGear:ERROR] :: Received compressed JPEG frame decoding failed')\n            if msg_json['compression']['colorspace'] == 'GRAY' and frame.ndim == 3:\n                frame = np.squeeze(frame, axis=2)\n        else:\n            frame_buffer = np.frombuffer(msg_data, dtype=msg_json['dtype'])\n            frame = frame_buffer.reshape(msg_json['shape'])\n        if self.__multiserver_mode:\n            if not msg_json['port'] in self.__port_buffer:\n                self.__port_buffer.append(msg_json['port'])\n            if msg_json['message']:\n                self.__queue.append((msg_json['port'], msg_json['message'], frame))\n            else:\n                self.__queue.append((msg_json['port'], frame))\n        elif self.__bi_mode:\n            if msg_json['message']:\n                self.__queue.append((msg_json['message'], frame))\n            else:\n                self.__queue.append((None, frame))\n        else:\n            self.__queue.append(frame)"
        ]
    },
    {
        "func_name": "recv",
        "original": "def recv(self, return_data=None):\n    \"\"\"\n        A Receiver end method, that extracts received frames synchronously from monitored deque, while maintaining a\n        fixed-length frame buffer in the memory, and blocks the thread if the deque is full.\n\n        Parameters:\n            return_data (any): inputs return data _(of any datatype)_, for sending back to Server.\n\n        **Returns:** A n-dimensional numpy array.\n        \"\"\"\n    if not self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `recv()` function cannot be used while receive_mode is disabled. Kindly refer vidgear docs!')\n    if (self.__bi_mode or self.__multiclient_mode) and (not return_data is None):\n        self.__return_data = return_data\n    while not self.__terminate:\n        try:\n            if len(self.__queue) > 0:\n                return self.__queue.popleft()\n            else:\n                time.sleep(1e-05)\n                continue\n        except KeyboardInterrupt:\n            self.__terminate = True\n            break\n    return None",
        "mutated": [
            "def recv(self, return_data=None):\n    if False:\n        i = 10\n    '\\n        A Receiver end method, that extracts received frames synchronously from monitored deque, while maintaining a\\n        fixed-length frame buffer in the memory, and blocks the thread if the deque is full.\\n\\n        Parameters:\\n            return_data (any): inputs return data _(of any datatype)_, for sending back to Server.\\n\\n        **Returns:** A n-dimensional numpy array.\\n        '\n    if not self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `recv()` function cannot be used while receive_mode is disabled. Kindly refer vidgear docs!')\n    if (self.__bi_mode or self.__multiclient_mode) and (not return_data is None):\n        self.__return_data = return_data\n    while not self.__terminate:\n        try:\n            if len(self.__queue) > 0:\n                return self.__queue.popleft()\n            else:\n                time.sleep(1e-05)\n                continue\n        except KeyboardInterrupt:\n            self.__terminate = True\n            break\n    return None",
            "def recv(self, return_data=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        A Receiver end method, that extracts received frames synchronously from monitored deque, while maintaining a\\n        fixed-length frame buffer in the memory, and blocks the thread if the deque is full.\\n\\n        Parameters:\\n            return_data (any): inputs return data _(of any datatype)_, for sending back to Server.\\n\\n        **Returns:** A n-dimensional numpy array.\\n        '\n    if not self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `recv()` function cannot be used while receive_mode is disabled. Kindly refer vidgear docs!')\n    if (self.__bi_mode or self.__multiclient_mode) and (not return_data is None):\n        self.__return_data = return_data\n    while not self.__terminate:\n        try:\n            if len(self.__queue) > 0:\n                return self.__queue.popleft()\n            else:\n                time.sleep(1e-05)\n                continue\n        except KeyboardInterrupt:\n            self.__terminate = True\n            break\n    return None",
            "def recv(self, return_data=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        A Receiver end method, that extracts received frames synchronously from monitored deque, while maintaining a\\n        fixed-length frame buffer in the memory, and blocks the thread if the deque is full.\\n\\n        Parameters:\\n            return_data (any): inputs return data _(of any datatype)_, for sending back to Server.\\n\\n        **Returns:** A n-dimensional numpy array.\\n        '\n    if not self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `recv()` function cannot be used while receive_mode is disabled. Kindly refer vidgear docs!')\n    if (self.__bi_mode or self.__multiclient_mode) and (not return_data is None):\n        self.__return_data = return_data\n    while not self.__terminate:\n        try:\n            if len(self.__queue) > 0:\n                return self.__queue.popleft()\n            else:\n                time.sleep(1e-05)\n                continue\n        except KeyboardInterrupt:\n            self.__terminate = True\n            break\n    return None",
            "def recv(self, return_data=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        A Receiver end method, that extracts received frames synchronously from monitored deque, while maintaining a\\n        fixed-length frame buffer in the memory, and blocks the thread if the deque is full.\\n\\n        Parameters:\\n            return_data (any): inputs return data _(of any datatype)_, for sending back to Server.\\n\\n        **Returns:** A n-dimensional numpy array.\\n        '\n    if not self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `recv()` function cannot be used while receive_mode is disabled. Kindly refer vidgear docs!')\n    if (self.__bi_mode or self.__multiclient_mode) and (not return_data is None):\n        self.__return_data = return_data\n    while not self.__terminate:\n        try:\n            if len(self.__queue) > 0:\n                return self.__queue.popleft()\n            else:\n                time.sleep(1e-05)\n                continue\n        except KeyboardInterrupt:\n            self.__terminate = True\n            break\n    return None",
            "def recv(self, return_data=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        A Receiver end method, that extracts received frames synchronously from monitored deque, while maintaining a\\n        fixed-length frame buffer in the memory, and blocks the thread if the deque is full.\\n\\n        Parameters:\\n            return_data (any): inputs return data _(of any datatype)_, for sending back to Server.\\n\\n        **Returns:** A n-dimensional numpy array.\\n        '\n    if not self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `recv()` function cannot be used while receive_mode is disabled. Kindly refer vidgear docs!')\n    if (self.__bi_mode or self.__multiclient_mode) and (not return_data is None):\n        self.__return_data = return_data\n    while not self.__terminate:\n        try:\n            if len(self.__queue) > 0:\n                return self.__queue.popleft()\n            else:\n                time.sleep(1e-05)\n                continue\n        except KeyboardInterrupt:\n            self.__terminate = True\n            break\n    return None"
        ]
    },
    {
        "func_name": "send",
        "original": "def send(self, frame, message=None):\n    \"\"\"\n        A Server end method, that sends the data and frames over the network to Client(s).\n\n        Parameters:\n            frame (numpy.ndarray): inputs numpy array(frame).\n            message (any): input for sending additional data _(of any datatype except `numpy.ndarray`)_ to Client(s).\n\n        **Returns:** Data _(of any datatype)_ in selected exclusive modes, otherwise None-type.\n\n        \"\"\"\n    if self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `send()` function cannot be used while receive_mode is enabled. Kindly refer vidgear docs!')\n    if not message is None and isinstance(message, np.ndarray):\n        logger.warning('Skipped unsupported `message` of datatype: {}!'.format(type(message).__name__))\n        message = None\n    exit_flag = True if frame is None or self.__terminate else False\n    if not exit_flag and (not frame.flags['C_CONTIGUOUS']):\n        frame = np.ascontiguousarray(frame, dtype=frame.dtype)\n    if self.__jpeg_compression:\n        if self.__jpeg_compression_colorspace == 'GRAY':\n            if frame.ndim == 2:\n                frame = np.expand_dims(frame, axis=2)\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n        else:\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n    msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()\n    msg_dict.update(dict(terminate_flag=exit_flag, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, message=message, pattern=str(self.__pattern), dtype=str(frame.dtype) if not self.__jpeg_compression else '', shape=frame.shape if not self.__jpeg_compression else ''))\n    self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)\n    self.__msg_socket.send(frame, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n    if self.__pattern < 2:\n        if self.__bi_mode or self.__multiclient_mode:\n            recvd_data = None\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiclient_mode:\n                        logger.error('All Clients failed to respond on multiple attempts.')\n                    else:\n                        logger.error('Client failed to respond on multiple attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client(s) seems to be offline, Abandoning.')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if isinstance(self.__connection_address, list):\n                    for _connection in self.__connection_address:\n                        self.__msg_socket.connect(_connection)\n                elif self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            if self.__multiclient_mode and (not recv_json['port'] in self.__port_buffer):\n                self.__port_buffer.append(recv_json['port'])\n            if recv_json['return_type'] == 'ndarray':\n                recv_array = self.__msg_socket.recv(flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                if recv_json['compression']:\n                    recvd_data = simplejpeg.decode_jpeg(recv_array, colorspace=recv_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or recv_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or recv_json['compression']['ups'])\n                    if recvd_data is None:\n                        self.__terminate = True\n                        raise RuntimeError('[NetGear:ERROR] :: Received compressed frame `{}` decoding failed with flag: {}.'.format(recv_json['compression'], self.__ex_compression_params))\n                    if recv_json['compression']['colorspace'] == 'GRAY' and recvd_data.ndim == 3:\n                        recvd_data = np.squeeze(recvd_data, axis=2)\n                else:\n                    recvd_data = np.frombuffer(recv_array, dtype=recv_json['array_dtype']).reshape(recv_json['array_shape'])\n            else:\n                recvd_data = recv_json['data']\n            return (recv_json['port'], recvd_data) if self.__multiclient_mode else recvd_data\n        else:\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_confirmation = self.__msg_socket.recv()\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    logger.error('Client failed to respond on repeated attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client seems to be offline, Abandoning!')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            self.__logging and logger.debug(recv_confirmation)",
        "mutated": [
            "def send(self, frame, message=None):\n    if False:\n        i = 10\n    '\\n        A Server end method, that sends the data and frames over the network to Client(s).\\n\\n        Parameters:\\n            frame (numpy.ndarray): inputs numpy array(frame).\\n            message (any): input for sending additional data _(of any datatype except `numpy.ndarray`)_ to Client(s).\\n\\n        **Returns:** Data _(of any datatype)_ in selected exclusive modes, otherwise None-type.\\n\\n        '\n    if self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `send()` function cannot be used while receive_mode is enabled. Kindly refer vidgear docs!')\n    if not message is None and isinstance(message, np.ndarray):\n        logger.warning('Skipped unsupported `message` of datatype: {}!'.format(type(message).__name__))\n        message = None\n    exit_flag = True if frame is None or self.__terminate else False\n    if not exit_flag and (not frame.flags['C_CONTIGUOUS']):\n        frame = np.ascontiguousarray(frame, dtype=frame.dtype)\n    if self.__jpeg_compression:\n        if self.__jpeg_compression_colorspace == 'GRAY':\n            if frame.ndim == 2:\n                frame = np.expand_dims(frame, axis=2)\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n        else:\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n    msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()\n    msg_dict.update(dict(terminate_flag=exit_flag, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, message=message, pattern=str(self.__pattern), dtype=str(frame.dtype) if not self.__jpeg_compression else '', shape=frame.shape if not self.__jpeg_compression else ''))\n    self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)\n    self.__msg_socket.send(frame, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n    if self.__pattern < 2:\n        if self.__bi_mode or self.__multiclient_mode:\n            recvd_data = None\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiclient_mode:\n                        logger.error('All Clients failed to respond on multiple attempts.')\n                    else:\n                        logger.error('Client failed to respond on multiple attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client(s) seems to be offline, Abandoning.')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if isinstance(self.__connection_address, list):\n                    for _connection in self.__connection_address:\n                        self.__msg_socket.connect(_connection)\n                elif self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            if self.__multiclient_mode and (not recv_json['port'] in self.__port_buffer):\n                self.__port_buffer.append(recv_json['port'])\n            if recv_json['return_type'] == 'ndarray':\n                recv_array = self.__msg_socket.recv(flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                if recv_json['compression']:\n                    recvd_data = simplejpeg.decode_jpeg(recv_array, colorspace=recv_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or recv_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or recv_json['compression']['ups'])\n                    if recvd_data is None:\n                        self.__terminate = True\n                        raise RuntimeError('[NetGear:ERROR] :: Received compressed frame `{}` decoding failed with flag: {}.'.format(recv_json['compression'], self.__ex_compression_params))\n                    if recv_json['compression']['colorspace'] == 'GRAY' and recvd_data.ndim == 3:\n                        recvd_data = np.squeeze(recvd_data, axis=2)\n                else:\n                    recvd_data = np.frombuffer(recv_array, dtype=recv_json['array_dtype']).reshape(recv_json['array_shape'])\n            else:\n                recvd_data = recv_json['data']\n            return (recv_json['port'], recvd_data) if self.__multiclient_mode else recvd_data\n        else:\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_confirmation = self.__msg_socket.recv()\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    logger.error('Client failed to respond on repeated attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client seems to be offline, Abandoning!')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            self.__logging and logger.debug(recv_confirmation)",
            "def send(self, frame, message=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        A Server end method, that sends the data and frames over the network to Client(s).\\n\\n        Parameters:\\n            frame (numpy.ndarray): inputs numpy array(frame).\\n            message (any): input for sending additional data _(of any datatype except `numpy.ndarray`)_ to Client(s).\\n\\n        **Returns:** Data _(of any datatype)_ in selected exclusive modes, otherwise None-type.\\n\\n        '\n    if self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `send()` function cannot be used while receive_mode is enabled. Kindly refer vidgear docs!')\n    if not message is None and isinstance(message, np.ndarray):\n        logger.warning('Skipped unsupported `message` of datatype: {}!'.format(type(message).__name__))\n        message = None\n    exit_flag = True if frame is None or self.__terminate else False\n    if not exit_flag and (not frame.flags['C_CONTIGUOUS']):\n        frame = np.ascontiguousarray(frame, dtype=frame.dtype)\n    if self.__jpeg_compression:\n        if self.__jpeg_compression_colorspace == 'GRAY':\n            if frame.ndim == 2:\n                frame = np.expand_dims(frame, axis=2)\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n        else:\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n    msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()\n    msg_dict.update(dict(terminate_flag=exit_flag, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, message=message, pattern=str(self.__pattern), dtype=str(frame.dtype) if not self.__jpeg_compression else '', shape=frame.shape if not self.__jpeg_compression else ''))\n    self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)\n    self.__msg_socket.send(frame, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n    if self.__pattern < 2:\n        if self.__bi_mode or self.__multiclient_mode:\n            recvd_data = None\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiclient_mode:\n                        logger.error('All Clients failed to respond on multiple attempts.')\n                    else:\n                        logger.error('Client failed to respond on multiple attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client(s) seems to be offline, Abandoning.')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if isinstance(self.__connection_address, list):\n                    for _connection in self.__connection_address:\n                        self.__msg_socket.connect(_connection)\n                elif self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            if self.__multiclient_mode and (not recv_json['port'] in self.__port_buffer):\n                self.__port_buffer.append(recv_json['port'])\n            if recv_json['return_type'] == 'ndarray':\n                recv_array = self.__msg_socket.recv(flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                if recv_json['compression']:\n                    recvd_data = simplejpeg.decode_jpeg(recv_array, colorspace=recv_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or recv_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or recv_json['compression']['ups'])\n                    if recvd_data is None:\n                        self.__terminate = True\n                        raise RuntimeError('[NetGear:ERROR] :: Received compressed frame `{}` decoding failed with flag: {}.'.format(recv_json['compression'], self.__ex_compression_params))\n                    if recv_json['compression']['colorspace'] == 'GRAY' and recvd_data.ndim == 3:\n                        recvd_data = np.squeeze(recvd_data, axis=2)\n                else:\n                    recvd_data = np.frombuffer(recv_array, dtype=recv_json['array_dtype']).reshape(recv_json['array_shape'])\n            else:\n                recvd_data = recv_json['data']\n            return (recv_json['port'], recvd_data) if self.__multiclient_mode else recvd_data\n        else:\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_confirmation = self.__msg_socket.recv()\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    logger.error('Client failed to respond on repeated attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client seems to be offline, Abandoning!')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            self.__logging and logger.debug(recv_confirmation)",
            "def send(self, frame, message=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        A Server end method, that sends the data and frames over the network to Client(s).\\n\\n        Parameters:\\n            frame (numpy.ndarray): inputs numpy array(frame).\\n            message (any): input for sending additional data _(of any datatype except `numpy.ndarray`)_ to Client(s).\\n\\n        **Returns:** Data _(of any datatype)_ in selected exclusive modes, otherwise None-type.\\n\\n        '\n    if self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `send()` function cannot be used while receive_mode is enabled. Kindly refer vidgear docs!')\n    if not message is None and isinstance(message, np.ndarray):\n        logger.warning('Skipped unsupported `message` of datatype: {}!'.format(type(message).__name__))\n        message = None\n    exit_flag = True if frame is None or self.__terminate else False\n    if not exit_flag and (not frame.flags['C_CONTIGUOUS']):\n        frame = np.ascontiguousarray(frame, dtype=frame.dtype)\n    if self.__jpeg_compression:\n        if self.__jpeg_compression_colorspace == 'GRAY':\n            if frame.ndim == 2:\n                frame = np.expand_dims(frame, axis=2)\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n        else:\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n    msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()\n    msg_dict.update(dict(terminate_flag=exit_flag, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, message=message, pattern=str(self.__pattern), dtype=str(frame.dtype) if not self.__jpeg_compression else '', shape=frame.shape if not self.__jpeg_compression else ''))\n    self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)\n    self.__msg_socket.send(frame, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n    if self.__pattern < 2:\n        if self.__bi_mode or self.__multiclient_mode:\n            recvd_data = None\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiclient_mode:\n                        logger.error('All Clients failed to respond on multiple attempts.')\n                    else:\n                        logger.error('Client failed to respond on multiple attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client(s) seems to be offline, Abandoning.')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if isinstance(self.__connection_address, list):\n                    for _connection in self.__connection_address:\n                        self.__msg_socket.connect(_connection)\n                elif self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            if self.__multiclient_mode and (not recv_json['port'] in self.__port_buffer):\n                self.__port_buffer.append(recv_json['port'])\n            if recv_json['return_type'] == 'ndarray':\n                recv_array = self.__msg_socket.recv(flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                if recv_json['compression']:\n                    recvd_data = simplejpeg.decode_jpeg(recv_array, colorspace=recv_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or recv_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or recv_json['compression']['ups'])\n                    if recvd_data is None:\n                        self.__terminate = True\n                        raise RuntimeError('[NetGear:ERROR] :: Received compressed frame `{}` decoding failed with flag: {}.'.format(recv_json['compression'], self.__ex_compression_params))\n                    if recv_json['compression']['colorspace'] == 'GRAY' and recvd_data.ndim == 3:\n                        recvd_data = np.squeeze(recvd_data, axis=2)\n                else:\n                    recvd_data = np.frombuffer(recv_array, dtype=recv_json['array_dtype']).reshape(recv_json['array_shape'])\n            else:\n                recvd_data = recv_json['data']\n            return (recv_json['port'], recvd_data) if self.__multiclient_mode else recvd_data\n        else:\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_confirmation = self.__msg_socket.recv()\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    logger.error('Client failed to respond on repeated attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client seems to be offline, Abandoning!')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            self.__logging and logger.debug(recv_confirmation)",
            "def send(self, frame, message=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        A Server end method, that sends the data and frames over the network to Client(s).\\n\\n        Parameters:\\n            frame (numpy.ndarray): inputs numpy array(frame).\\n            message (any): input for sending additional data _(of any datatype except `numpy.ndarray`)_ to Client(s).\\n\\n        **Returns:** Data _(of any datatype)_ in selected exclusive modes, otherwise None-type.\\n\\n        '\n    if self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `send()` function cannot be used while receive_mode is enabled. Kindly refer vidgear docs!')\n    if not message is None and isinstance(message, np.ndarray):\n        logger.warning('Skipped unsupported `message` of datatype: {}!'.format(type(message).__name__))\n        message = None\n    exit_flag = True if frame is None or self.__terminate else False\n    if not exit_flag and (not frame.flags['C_CONTIGUOUS']):\n        frame = np.ascontiguousarray(frame, dtype=frame.dtype)\n    if self.__jpeg_compression:\n        if self.__jpeg_compression_colorspace == 'GRAY':\n            if frame.ndim == 2:\n                frame = np.expand_dims(frame, axis=2)\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n        else:\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n    msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()\n    msg_dict.update(dict(terminate_flag=exit_flag, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, message=message, pattern=str(self.__pattern), dtype=str(frame.dtype) if not self.__jpeg_compression else '', shape=frame.shape if not self.__jpeg_compression else ''))\n    self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)\n    self.__msg_socket.send(frame, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n    if self.__pattern < 2:\n        if self.__bi_mode or self.__multiclient_mode:\n            recvd_data = None\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiclient_mode:\n                        logger.error('All Clients failed to respond on multiple attempts.')\n                    else:\n                        logger.error('Client failed to respond on multiple attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client(s) seems to be offline, Abandoning.')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if isinstance(self.__connection_address, list):\n                    for _connection in self.__connection_address:\n                        self.__msg_socket.connect(_connection)\n                elif self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            if self.__multiclient_mode and (not recv_json['port'] in self.__port_buffer):\n                self.__port_buffer.append(recv_json['port'])\n            if recv_json['return_type'] == 'ndarray':\n                recv_array = self.__msg_socket.recv(flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                if recv_json['compression']:\n                    recvd_data = simplejpeg.decode_jpeg(recv_array, colorspace=recv_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or recv_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or recv_json['compression']['ups'])\n                    if recvd_data is None:\n                        self.__terminate = True\n                        raise RuntimeError('[NetGear:ERROR] :: Received compressed frame `{}` decoding failed with flag: {}.'.format(recv_json['compression'], self.__ex_compression_params))\n                    if recv_json['compression']['colorspace'] == 'GRAY' and recvd_data.ndim == 3:\n                        recvd_data = np.squeeze(recvd_data, axis=2)\n                else:\n                    recvd_data = np.frombuffer(recv_array, dtype=recv_json['array_dtype']).reshape(recv_json['array_shape'])\n            else:\n                recvd_data = recv_json['data']\n            return (recv_json['port'], recvd_data) if self.__multiclient_mode else recvd_data\n        else:\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_confirmation = self.__msg_socket.recv()\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    logger.error('Client failed to respond on repeated attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client seems to be offline, Abandoning!')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            self.__logging and logger.debug(recv_confirmation)",
            "def send(self, frame, message=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        A Server end method, that sends the data and frames over the network to Client(s).\\n\\n        Parameters:\\n            frame (numpy.ndarray): inputs numpy array(frame).\\n            message (any): input for sending additional data _(of any datatype except `numpy.ndarray`)_ to Client(s).\\n\\n        **Returns:** Data _(of any datatype)_ in selected exclusive modes, otherwise None-type.\\n\\n        '\n    if self.__receive_mode:\n        self.__terminate = True\n        raise ValueError('[NetGear:ERROR] :: `send()` function cannot be used while receive_mode is enabled. Kindly refer vidgear docs!')\n    if not message is None and isinstance(message, np.ndarray):\n        logger.warning('Skipped unsupported `message` of datatype: {}!'.format(type(message).__name__))\n        message = None\n    exit_flag = True if frame is None or self.__terminate else False\n    if not exit_flag and (not frame.flags['C_CONTIGUOUS']):\n        frame = np.ascontiguousarray(frame, dtype=frame.dtype)\n    if self.__jpeg_compression:\n        if self.__jpeg_compression_colorspace == 'GRAY':\n            if frame.ndim == 2:\n                frame = np.expand_dims(frame, axis=2)\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, fastdct=self.__jpeg_compression_fastdct)\n        else:\n            frame = simplejpeg.encode_jpeg(frame, quality=self.__jpeg_compression_quality, colorspace=self.__jpeg_compression_colorspace, colorsubsampling='422', fastdct=self.__jpeg_compression_fastdct)\n    msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()\n    msg_dict.update(dict(terminate_flag=exit_flag, compression={'dct': self.__jpeg_compression_fastdct, 'ups': self.__jpeg_compression_fastupsample, 'colorspace': self.__jpeg_compression_colorspace} if self.__jpeg_compression else False, message=message, pattern=str(self.__pattern), dtype=str(frame.dtype) if not self.__jpeg_compression else '', shape=frame.shape if not self.__jpeg_compression else ''))\n    self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)\n    self.__msg_socket.send(frame, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n    if self.__pattern < 2:\n        if self.__bi_mode or self.__multiclient_mode:\n            recvd_data = None\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_json = self.__msg_socket.recv_json(flags=self.__msg_flag)\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    if self.__multiclient_mode:\n                        logger.error('All Clients failed to respond on multiple attempts.')\n                    else:\n                        logger.error('Client failed to respond on multiple attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client(s) seems to be offline, Abandoning.')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if isinstance(self.__connection_address, list):\n                    for _connection in self.__connection_address:\n                        self.__msg_socket.connect(_connection)\n                elif self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            if self.__multiclient_mode and (not recv_json['port'] in self.__port_buffer):\n                self.__port_buffer.append(recv_json['port'])\n            if recv_json['return_type'] == 'ndarray':\n                recv_array = self.__msg_socket.recv(flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track)\n                if recv_json['compression']:\n                    recvd_data = simplejpeg.decode_jpeg(recv_array, colorspace=recv_json['compression']['colorspace'], fastdct=self.__jpeg_compression_fastdct or recv_json['compression']['dct'], fastupsample=self.__jpeg_compression_fastupsample or recv_json['compression']['ups'])\n                    if recvd_data is None:\n                        self.__terminate = True\n                        raise RuntimeError('[NetGear:ERROR] :: Received compressed frame `{}` decoding failed with flag: {}.'.format(recv_json['compression'], self.__ex_compression_params))\n                    if recv_json['compression']['colorspace'] == 'GRAY' and recvd_data.ndim == 3:\n                        recvd_data = np.squeeze(recvd_data, axis=2)\n                else:\n                    recvd_data = np.frombuffer(recv_array, dtype=recv_json['array_dtype']).reshape(recv_json['array_shape'])\n            else:\n                recvd_data = recv_json['data']\n            return (recv_json['port'], recvd_data) if self.__multiclient_mode else recvd_data\n        else:\n            socks = dict(self.__poll.poll(self.__request_timeout))\n            if socks.get(self.__msg_socket) == zmq.POLLIN:\n                recv_confirmation = self.__msg_socket.recv()\n            else:\n                logger.critical('No response from Client, Reconnecting again...')\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n                self.__poll.unregister(self.__msg_socket)\n                self.__max_retries -= 1\n                if not self.__max_retries:\n                    logger.error('Client failed to respond on repeated attempts.')\n                    self.__terminate = True\n                    raise RuntimeError('[NetGear:ERROR] :: Client seems to be offline, Abandoning!')\n                self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)\n                if self.__ssh_tunnel_mode:\n                    ssh.tunnel_connection(self.__msg_socket, self.__connection_address, self.__ssh_tunnel_mode, keyfile=self.__ssh_tunnel_keyfile, password=self.__ssh_tunnel_pwd, paramiko=self.__paramiko_present)\n                else:\n                    self.__msg_socket.connect(self.__connection_address)\n                self.__poll.register(self.__msg_socket, zmq.POLLIN)\n                return None\n            self.__logging and logger.debug(recv_confirmation)"
        ]
    },
    {
        "func_name": "close",
        "original": "def close(self, kill=False):\n    \"\"\"\n        Safely terminates the threads, and NetGear resources.\n\n        Parameters:\n            kill (bool): Kills ZMQ context instead of graceful exiting in receive mode.\n        \"\"\"\n    self.__logging and logger.debug('Terminating various {} Processes.'.format('Receive Mode' if self.__receive_mode else 'Send Mode'))\n    if self.__receive_mode:\n        if not self.__queue is None and self.__queue:\n            self.__queue.clear()\n        self.__terminate = True\n        self.__logging and logger.debug('Terminating. Please wait...')\n        if self.__thread is not None:\n            if self.__thread.is_alive() and kill:\n                logger.warning('Thread still running...Killing it forcefully!')\n                self.__msg_context.destroy()\n                self.__thread.join()\n            else:\n                self.__thread.join()\n                self.__msg_socket.close(linger=0)\n            self.__thread = None\n        self.__logging and logger.debug('Terminated Successfully!')\n    else:\n        self.__terminate = True\n        kill and logger.warning('`kill` parmeter is only available in the receive mode.')\n        if self.__pattern < 2 and (not self.__max_retries) or (self.__multiclient_mode and (not self.__port_buffer)):\n            try:\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n            except ZMQError:\n                pass\n            finally:\n                return\n        if self.__multiserver_mode:\n            term_dict = dict(terminate_flag=True, port=self.__port)\n        else:\n            term_dict = dict(terminate_flag=True)\n        try:\n            if self.__multiclient_mode:\n                for _ in self.__port_buffer:\n                    self.__msg_socket.send_json(term_dict)\n            else:\n                self.__msg_socket.send_json(term_dict)\n            if self.__pattern < 2:\n                self.__logging and logger.debug('Terminating. Please wait...')\n                if self.__msg_socket.poll(self.__request_timeout // 5, zmq.POLLIN):\n                    self.__msg_socket.recv()\n        except Exception as e:\n            if not isinstance(e, ZMQError):\n                logger.exception(str(e))\n        finally:\n            self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            self.__msg_socket.close()\n            self.__logging and logger.debug('Terminated Successfully!')",
        "mutated": [
            "def close(self, kill=False):\n    if False:\n        i = 10\n    '\\n        Safely terminates the threads, and NetGear resources.\\n\\n        Parameters:\\n            kill (bool): Kills ZMQ context instead of graceful exiting in receive mode.\\n        '\n    self.__logging and logger.debug('Terminating various {} Processes.'.format('Receive Mode' if self.__receive_mode else 'Send Mode'))\n    if self.__receive_mode:\n        if not self.__queue is None and self.__queue:\n            self.__queue.clear()\n        self.__terminate = True\n        self.__logging and logger.debug('Terminating. Please wait...')\n        if self.__thread is not None:\n            if self.__thread.is_alive() and kill:\n                logger.warning('Thread still running...Killing it forcefully!')\n                self.__msg_context.destroy()\n                self.__thread.join()\n            else:\n                self.__thread.join()\n                self.__msg_socket.close(linger=0)\n            self.__thread = None\n        self.__logging and logger.debug('Terminated Successfully!')\n    else:\n        self.__terminate = True\n        kill and logger.warning('`kill` parmeter is only available in the receive mode.')\n        if self.__pattern < 2 and (not self.__max_retries) or (self.__multiclient_mode and (not self.__port_buffer)):\n            try:\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n            except ZMQError:\n                pass\n            finally:\n                return\n        if self.__multiserver_mode:\n            term_dict = dict(terminate_flag=True, port=self.__port)\n        else:\n            term_dict = dict(terminate_flag=True)\n        try:\n            if self.__multiclient_mode:\n                for _ in self.__port_buffer:\n                    self.__msg_socket.send_json(term_dict)\n            else:\n                self.__msg_socket.send_json(term_dict)\n            if self.__pattern < 2:\n                self.__logging and logger.debug('Terminating. Please wait...')\n                if self.__msg_socket.poll(self.__request_timeout // 5, zmq.POLLIN):\n                    self.__msg_socket.recv()\n        except Exception as e:\n            if not isinstance(e, ZMQError):\n                logger.exception(str(e))\n        finally:\n            self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            self.__msg_socket.close()\n            self.__logging and logger.debug('Terminated Successfully!')",
            "def close(self, kill=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Safely terminates the threads, and NetGear resources.\\n\\n        Parameters:\\n            kill (bool): Kills ZMQ context instead of graceful exiting in receive mode.\\n        '\n    self.__logging and logger.debug('Terminating various {} Processes.'.format('Receive Mode' if self.__receive_mode else 'Send Mode'))\n    if self.__receive_mode:\n        if not self.__queue is None and self.__queue:\n            self.__queue.clear()\n        self.__terminate = True\n        self.__logging and logger.debug('Terminating. Please wait...')\n        if self.__thread is not None:\n            if self.__thread.is_alive() and kill:\n                logger.warning('Thread still running...Killing it forcefully!')\n                self.__msg_context.destroy()\n                self.__thread.join()\n            else:\n                self.__thread.join()\n                self.__msg_socket.close(linger=0)\n            self.__thread = None\n        self.__logging and logger.debug('Terminated Successfully!')\n    else:\n        self.__terminate = True\n        kill and logger.warning('`kill` parmeter is only available in the receive mode.')\n        if self.__pattern < 2 and (not self.__max_retries) or (self.__multiclient_mode and (not self.__port_buffer)):\n            try:\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n            except ZMQError:\n                pass\n            finally:\n                return\n        if self.__multiserver_mode:\n            term_dict = dict(terminate_flag=True, port=self.__port)\n        else:\n            term_dict = dict(terminate_flag=True)\n        try:\n            if self.__multiclient_mode:\n                for _ in self.__port_buffer:\n                    self.__msg_socket.send_json(term_dict)\n            else:\n                self.__msg_socket.send_json(term_dict)\n            if self.__pattern < 2:\n                self.__logging and logger.debug('Terminating. Please wait...')\n                if self.__msg_socket.poll(self.__request_timeout // 5, zmq.POLLIN):\n                    self.__msg_socket.recv()\n        except Exception as e:\n            if not isinstance(e, ZMQError):\n                logger.exception(str(e))\n        finally:\n            self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            self.__msg_socket.close()\n            self.__logging and logger.debug('Terminated Successfully!')",
            "def close(self, kill=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Safely terminates the threads, and NetGear resources.\\n\\n        Parameters:\\n            kill (bool): Kills ZMQ context instead of graceful exiting in receive mode.\\n        '\n    self.__logging and logger.debug('Terminating various {} Processes.'.format('Receive Mode' if self.__receive_mode else 'Send Mode'))\n    if self.__receive_mode:\n        if not self.__queue is None and self.__queue:\n            self.__queue.clear()\n        self.__terminate = True\n        self.__logging and logger.debug('Terminating. Please wait...')\n        if self.__thread is not None:\n            if self.__thread.is_alive() and kill:\n                logger.warning('Thread still running...Killing it forcefully!')\n                self.__msg_context.destroy()\n                self.__thread.join()\n            else:\n                self.__thread.join()\n                self.__msg_socket.close(linger=0)\n            self.__thread = None\n        self.__logging and logger.debug('Terminated Successfully!')\n    else:\n        self.__terminate = True\n        kill and logger.warning('`kill` parmeter is only available in the receive mode.')\n        if self.__pattern < 2 and (not self.__max_retries) or (self.__multiclient_mode and (not self.__port_buffer)):\n            try:\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n            except ZMQError:\n                pass\n            finally:\n                return\n        if self.__multiserver_mode:\n            term_dict = dict(terminate_flag=True, port=self.__port)\n        else:\n            term_dict = dict(terminate_flag=True)\n        try:\n            if self.__multiclient_mode:\n                for _ in self.__port_buffer:\n                    self.__msg_socket.send_json(term_dict)\n            else:\n                self.__msg_socket.send_json(term_dict)\n            if self.__pattern < 2:\n                self.__logging and logger.debug('Terminating. Please wait...')\n                if self.__msg_socket.poll(self.__request_timeout // 5, zmq.POLLIN):\n                    self.__msg_socket.recv()\n        except Exception as e:\n            if not isinstance(e, ZMQError):\n                logger.exception(str(e))\n        finally:\n            self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            self.__msg_socket.close()\n            self.__logging and logger.debug('Terminated Successfully!')",
            "def close(self, kill=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Safely terminates the threads, and NetGear resources.\\n\\n        Parameters:\\n            kill (bool): Kills ZMQ context instead of graceful exiting in receive mode.\\n        '\n    self.__logging and logger.debug('Terminating various {} Processes.'.format('Receive Mode' if self.__receive_mode else 'Send Mode'))\n    if self.__receive_mode:\n        if not self.__queue is None and self.__queue:\n            self.__queue.clear()\n        self.__terminate = True\n        self.__logging and logger.debug('Terminating. Please wait...')\n        if self.__thread is not None:\n            if self.__thread.is_alive() and kill:\n                logger.warning('Thread still running...Killing it forcefully!')\n                self.__msg_context.destroy()\n                self.__thread.join()\n            else:\n                self.__thread.join()\n                self.__msg_socket.close(linger=0)\n            self.__thread = None\n        self.__logging and logger.debug('Terminated Successfully!')\n    else:\n        self.__terminate = True\n        kill and logger.warning('`kill` parmeter is only available in the receive mode.')\n        if self.__pattern < 2 and (not self.__max_retries) or (self.__multiclient_mode and (not self.__port_buffer)):\n            try:\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n            except ZMQError:\n                pass\n            finally:\n                return\n        if self.__multiserver_mode:\n            term_dict = dict(terminate_flag=True, port=self.__port)\n        else:\n            term_dict = dict(terminate_flag=True)\n        try:\n            if self.__multiclient_mode:\n                for _ in self.__port_buffer:\n                    self.__msg_socket.send_json(term_dict)\n            else:\n                self.__msg_socket.send_json(term_dict)\n            if self.__pattern < 2:\n                self.__logging and logger.debug('Terminating. Please wait...')\n                if self.__msg_socket.poll(self.__request_timeout // 5, zmq.POLLIN):\n                    self.__msg_socket.recv()\n        except Exception as e:\n            if not isinstance(e, ZMQError):\n                logger.exception(str(e))\n        finally:\n            self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            self.__msg_socket.close()\n            self.__logging and logger.debug('Terminated Successfully!')",
            "def close(self, kill=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Safely terminates the threads, and NetGear resources.\\n\\n        Parameters:\\n            kill (bool): Kills ZMQ context instead of graceful exiting in receive mode.\\n        '\n    self.__logging and logger.debug('Terminating various {} Processes.'.format('Receive Mode' if self.__receive_mode else 'Send Mode'))\n    if self.__receive_mode:\n        if not self.__queue is None and self.__queue:\n            self.__queue.clear()\n        self.__terminate = True\n        self.__logging and logger.debug('Terminating. Please wait...')\n        if self.__thread is not None:\n            if self.__thread.is_alive() and kill:\n                logger.warning('Thread still running...Killing it forcefully!')\n                self.__msg_context.destroy()\n                self.__thread.join()\n            else:\n                self.__thread.join()\n                self.__msg_socket.close(linger=0)\n            self.__thread = None\n        self.__logging and logger.debug('Terminated Successfully!')\n    else:\n        self.__terminate = True\n        kill and logger.warning('`kill` parmeter is only available in the receive mode.')\n        if self.__pattern < 2 and (not self.__max_retries) or (self.__multiclient_mode and (not self.__port_buffer)):\n            try:\n                self.__msg_socket.setsockopt(zmq.LINGER, 0)\n                self.__msg_socket.close()\n            except ZMQError:\n                pass\n            finally:\n                return\n        if self.__multiserver_mode:\n            term_dict = dict(terminate_flag=True, port=self.__port)\n        else:\n            term_dict = dict(terminate_flag=True)\n        try:\n            if self.__multiclient_mode:\n                for _ in self.__port_buffer:\n                    self.__msg_socket.send_json(term_dict)\n            else:\n                self.__msg_socket.send_json(term_dict)\n            if self.__pattern < 2:\n                self.__logging and logger.debug('Terminating. Please wait...')\n                if self.__msg_socket.poll(self.__request_timeout // 5, zmq.POLLIN):\n                    self.__msg_socket.recv()\n        except Exception as e:\n            if not isinstance(e, ZMQError):\n                logger.exception(str(e))\n        finally:\n            self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            self.__msg_socket.close()\n            self.__logging and logger.debug('Terminated Successfully!')"
        ]
    }
]