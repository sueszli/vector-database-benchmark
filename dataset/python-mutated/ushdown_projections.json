[
    {
        "func_name": "pushdown_projections",
        "original": "def pushdown_projections(expression, schema=None, remove_unused_selections=True):\n    \"\"\"\n    Rewrite sqlglot AST to remove unused columns projections.\n\n    Example:\n        >>> import sqlglot\n        >>> sql = \"SELECT y.a AS a FROM (SELECT x.a AS a, x.b AS b FROM x) AS y\"\n        >>> expression = sqlglot.parse_one(sql)\n        >>> pushdown_projections(expression).sql()\n        'SELECT y.a AS a FROM (SELECT x.a AS a FROM x) AS y'\n\n    Args:\n        expression (sqlglot.Expression): expression to optimize\n        remove_unused_selections (bool): remove selects that are unused\n    Returns:\n        sqlglot.Expression: optimized expression\n    \"\"\"\n    schema = ensure_schema(schema)\n    source_column_alias_count = {}\n    referenced_columns = defaultdict(set)\n    for scope in reversed(traverse_scope(expression)):\n        parent_selections = referenced_columns.get(scope, {SELECT_ALL})\n        alias_count = source_column_alias_count.get(scope, 0)\n        if scope.expression.args.get('distinct') or (scope.parent and scope.parent.pivots):\n            parent_selections = {SELECT_ALL}\n        if isinstance(scope.expression, exp.Union):\n            (left, right) = scope.union_scopes\n            referenced_columns[left] = parent_selections\n            if any((select.is_star for select in right.expression.selects)):\n                referenced_columns[right] = parent_selections\n            elif not any((select.is_star for select in left.expression.selects)):\n                referenced_columns[right] = [right.expression.selects[i].alias_or_name for (i, select) in enumerate(left.expression.selects) if SELECT_ALL in parent_selections or select.alias_or_name in parent_selections]\n        if isinstance(scope.expression, exp.Select):\n            if remove_unused_selections:\n                _remove_unused_selections(scope, parent_selections, schema, alias_count)\n            if scope.expression.is_star:\n                continue\n            selects = defaultdict(set)\n            for col in scope.columns:\n                table_name = col.table\n                col_name = col.name\n                selects[table_name].add(col_name)\n            for (name, (node, source)) in scope.selected_sources.items():\n                if isinstance(source, Scope):\n                    columns = selects.get(name) or set()\n                    referenced_columns[source].update(columns)\n                column_aliases = node.alias_column_names\n                if column_aliases:\n                    source_column_alias_count[source] = len(column_aliases)\n    return expression",
        "mutated": [
            "def pushdown_projections(expression, schema=None, remove_unused_selections=True):\n    if False:\n        i = 10\n    '\\n    Rewrite sqlglot AST to remove unused columns projections.\\n\\n    Example:\\n        >>> import sqlglot\\n        >>> sql = \"SELECT y.a AS a FROM (SELECT x.a AS a, x.b AS b FROM x) AS y\"\\n        >>> expression = sqlglot.parse_one(sql)\\n        >>> pushdown_projections(expression).sql()\\n        \\'SELECT y.a AS a FROM (SELECT x.a AS a FROM x) AS y\\'\\n\\n    Args:\\n        expression (sqlglot.Expression): expression to optimize\\n        remove_unused_selections (bool): remove selects that are unused\\n    Returns:\\n        sqlglot.Expression: optimized expression\\n    '\n    schema = ensure_schema(schema)\n    source_column_alias_count = {}\n    referenced_columns = defaultdict(set)\n    for scope in reversed(traverse_scope(expression)):\n        parent_selections = referenced_columns.get(scope, {SELECT_ALL})\n        alias_count = source_column_alias_count.get(scope, 0)\n        if scope.expression.args.get('distinct') or (scope.parent and scope.parent.pivots):\n            parent_selections = {SELECT_ALL}\n        if isinstance(scope.expression, exp.Union):\n            (left, right) = scope.union_scopes\n            referenced_columns[left] = parent_selections\n            if any((select.is_star for select in right.expression.selects)):\n                referenced_columns[right] = parent_selections\n            elif not any((select.is_star for select in left.expression.selects)):\n                referenced_columns[right] = [right.expression.selects[i].alias_or_name for (i, select) in enumerate(left.expression.selects) if SELECT_ALL in parent_selections or select.alias_or_name in parent_selections]\n        if isinstance(scope.expression, exp.Select):\n            if remove_unused_selections:\n                _remove_unused_selections(scope, parent_selections, schema, alias_count)\n            if scope.expression.is_star:\n                continue\n            selects = defaultdict(set)\n            for col in scope.columns:\n                table_name = col.table\n                col_name = col.name\n                selects[table_name].add(col_name)\n            for (name, (node, source)) in scope.selected_sources.items():\n                if isinstance(source, Scope):\n                    columns = selects.get(name) or set()\n                    referenced_columns[source].update(columns)\n                column_aliases = node.alias_column_names\n                if column_aliases:\n                    source_column_alias_count[source] = len(column_aliases)\n    return expression",
            "def pushdown_projections(expression, schema=None, remove_unused_selections=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Rewrite sqlglot AST to remove unused columns projections.\\n\\n    Example:\\n        >>> import sqlglot\\n        >>> sql = \"SELECT y.a AS a FROM (SELECT x.a AS a, x.b AS b FROM x) AS y\"\\n        >>> expression = sqlglot.parse_one(sql)\\n        >>> pushdown_projections(expression).sql()\\n        \\'SELECT y.a AS a FROM (SELECT x.a AS a FROM x) AS y\\'\\n\\n    Args:\\n        expression (sqlglot.Expression): expression to optimize\\n        remove_unused_selections (bool): remove selects that are unused\\n    Returns:\\n        sqlglot.Expression: optimized expression\\n    '\n    schema = ensure_schema(schema)\n    source_column_alias_count = {}\n    referenced_columns = defaultdict(set)\n    for scope in reversed(traverse_scope(expression)):\n        parent_selections = referenced_columns.get(scope, {SELECT_ALL})\n        alias_count = source_column_alias_count.get(scope, 0)\n        if scope.expression.args.get('distinct') or (scope.parent and scope.parent.pivots):\n            parent_selections = {SELECT_ALL}\n        if isinstance(scope.expression, exp.Union):\n            (left, right) = scope.union_scopes\n            referenced_columns[left] = parent_selections\n            if any((select.is_star for select in right.expression.selects)):\n                referenced_columns[right] = parent_selections\n            elif not any((select.is_star for select in left.expression.selects)):\n                referenced_columns[right] = [right.expression.selects[i].alias_or_name for (i, select) in enumerate(left.expression.selects) if SELECT_ALL in parent_selections or select.alias_or_name in parent_selections]\n        if isinstance(scope.expression, exp.Select):\n            if remove_unused_selections:\n                _remove_unused_selections(scope, parent_selections, schema, alias_count)\n            if scope.expression.is_star:\n                continue\n            selects = defaultdict(set)\n            for col in scope.columns:\n                table_name = col.table\n                col_name = col.name\n                selects[table_name].add(col_name)\n            for (name, (node, source)) in scope.selected_sources.items():\n                if isinstance(source, Scope):\n                    columns = selects.get(name) or set()\n                    referenced_columns[source].update(columns)\n                column_aliases = node.alias_column_names\n                if column_aliases:\n                    source_column_alias_count[source] = len(column_aliases)\n    return expression",
            "def pushdown_projections(expression, schema=None, remove_unused_selections=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Rewrite sqlglot AST to remove unused columns projections.\\n\\n    Example:\\n        >>> import sqlglot\\n        >>> sql = \"SELECT y.a AS a FROM (SELECT x.a AS a, x.b AS b FROM x) AS y\"\\n        >>> expression = sqlglot.parse_one(sql)\\n        >>> pushdown_projections(expression).sql()\\n        \\'SELECT y.a AS a FROM (SELECT x.a AS a FROM x) AS y\\'\\n\\n    Args:\\n        expression (sqlglot.Expression): expression to optimize\\n        remove_unused_selections (bool): remove selects that are unused\\n    Returns:\\n        sqlglot.Expression: optimized expression\\n    '\n    schema = ensure_schema(schema)\n    source_column_alias_count = {}\n    referenced_columns = defaultdict(set)\n    for scope in reversed(traverse_scope(expression)):\n        parent_selections = referenced_columns.get(scope, {SELECT_ALL})\n        alias_count = source_column_alias_count.get(scope, 0)\n        if scope.expression.args.get('distinct') or (scope.parent and scope.parent.pivots):\n            parent_selections = {SELECT_ALL}\n        if isinstance(scope.expression, exp.Union):\n            (left, right) = scope.union_scopes\n            referenced_columns[left] = parent_selections\n            if any((select.is_star for select in right.expression.selects)):\n                referenced_columns[right] = parent_selections\n            elif not any((select.is_star for select in left.expression.selects)):\n                referenced_columns[right] = [right.expression.selects[i].alias_or_name for (i, select) in enumerate(left.expression.selects) if SELECT_ALL in parent_selections or select.alias_or_name in parent_selections]\n        if isinstance(scope.expression, exp.Select):\n            if remove_unused_selections:\n                _remove_unused_selections(scope, parent_selections, schema, alias_count)\n            if scope.expression.is_star:\n                continue\n            selects = defaultdict(set)\n            for col in scope.columns:\n                table_name = col.table\n                col_name = col.name\n                selects[table_name].add(col_name)\n            for (name, (node, source)) in scope.selected_sources.items():\n                if isinstance(source, Scope):\n                    columns = selects.get(name) or set()\n                    referenced_columns[source].update(columns)\n                column_aliases = node.alias_column_names\n                if column_aliases:\n                    source_column_alias_count[source] = len(column_aliases)\n    return expression",
            "def pushdown_projections(expression, schema=None, remove_unused_selections=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Rewrite sqlglot AST to remove unused columns projections.\\n\\n    Example:\\n        >>> import sqlglot\\n        >>> sql = \"SELECT y.a AS a FROM (SELECT x.a AS a, x.b AS b FROM x) AS y\"\\n        >>> expression = sqlglot.parse_one(sql)\\n        >>> pushdown_projections(expression).sql()\\n        \\'SELECT y.a AS a FROM (SELECT x.a AS a FROM x) AS y\\'\\n\\n    Args:\\n        expression (sqlglot.Expression): expression to optimize\\n        remove_unused_selections (bool): remove selects that are unused\\n    Returns:\\n        sqlglot.Expression: optimized expression\\n    '\n    schema = ensure_schema(schema)\n    source_column_alias_count = {}\n    referenced_columns = defaultdict(set)\n    for scope in reversed(traverse_scope(expression)):\n        parent_selections = referenced_columns.get(scope, {SELECT_ALL})\n        alias_count = source_column_alias_count.get(scope, 0)\n        if scope.expression.args.get('distinct') or (scope.parent and scope.parent.pivots):\n            parent_selections = {SELECT_ALL}\n        if isinstance(scope.expression, exp.Union):\n            (left, right) = scope.union_scopes\n            referenced_columns[left] = parent_selections\n            if any((select.is_star for select in right.expression.selects)):\n                referenced_columns[right] = parent_selections\n            elif not any((select.is_star for select in left.expression.selects)):\n                referenced_columns[right] = [right.expression.selects[i].alias_or_name for (i, select) in enumerate(left.expression.selects) if SELECT_ALL in parent_selections or select.alias_or_name in parent_selections]\n        if isinstance(scope.expression, exp.Select):\n            if remove_unused_selections:\n                _remove_unused_selections(scope, parent_selections, schema, alias_count)\n            if scope.expression.is_star:\n                continue\n            selects = defaultdict(set)\n            for col in scope.columns:\n                table_name = col.table\n                col_name = col.name\n                selects[table_name].add(col_name)\n            for (name, (node, source)) in scope.selected_sources.items():\n                if isinstance(source, Scope):\n                    columns = selects.get(name) or set()\n                    referenced_columns[source].update(columns)\n                column_aliases = node.alias_column_names\n                if column_aliases:\n                    source_column_alias_count[source] = len(column_aliases)\n    return expression",
            "def pushdown_projections(expression, schema=None, remove_unused_selections=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Rewrite sqlglot AST to remove unused columns projections.\\n\\n    Example:\\n        >>> import sqlglot\\n        >>> sql = \"SELECT y.a AS a FROM (SELECT x.a AS a, x.b AS b FROM x) AS y\"\\n        >>> expression = sqlglot.parse_one(sql)\\n        >>> pushdown_projections(expression).sql()\\n        \\'SELECT y.a AS a FROM (SELECT x.a AS a FROM x) AS y\\'\\n\\n    Args:\\n        expression (sqlglot.Expression): expression to optimize\\n        remove_unused_selections (bool): remove selects that are unused\\n    Returns:\\n        sqlglot.Expression: optimized expression\\n    '\n    schema = ensure_schema(schema)\n    source_column_alias_count = {}\n    referenced_columns = defaultdict(set)\n    for scope in reversed(traverse_scope(expression)):\n        parent_selections = referenced_columns.get(scope, {SELECT_ALL})\n        alias_count = source_column_alias_count.get(scope, 0)\n        if scope.expression.args.get('distinct') or (scope.parent and scope.parent.pivots):\n            parent_selections = {SELECT_ALL}\n        if isinstance(scope.expression, exp.Union):\n            (left, right) = scope.union_scopes\n            referenced_columns[left] = parent_selections\n            if any((select.is_star for select in right.expression.selects)):\n                referenced_columns[right] = parent_selections\n            elif not any((select.is_star for select in left.expression.selects)):\n                referenced_columns[right] = [right.expression.selects[i].alias_or_name for (i, select) in enumerate(left.expression.selects) if SELECT_ALL in parent_selections or select.alias_or_name in parent_selections]\n        if isinstance(scope.expression, exp.Select):\n            if remove_unused_selections:\n                _remove_unused_selections(scope, parent_selections, schema, alias_count)\n            if scope.expression.is_star:\n                continue\n            selects = defaultdict(set)\n            for col in scope.columns:\n                table_name = col.table\n                col_name = col.name\n                selects[table_name].add(col_name)\n            for (name, (node, source)) in scope.selected_sources.items():\n                if isinstance(source, Scope):\n                    columns = selects.get(name) or set()\n                    referenced_columns[source].update(columns)\n                column_aliases = node.alias_column_names\n                if column_aliases:\n                    source_column_alias_count[source] = len(column_aliases)\n    return expression"
        ]
    },
    {
        "func_name": "_remove_unused_selections",
        "original": "def _remove_unused_selections(scope, parent_selections, schema, alias_count):\n    order = scope.expression.args.get('order')\n    if order:\n        order_refs = {c.name for c in order.find_all(exp.Column) if not c.table}\n    else:\n        order_refs = set()\n    new_selections = []\n    removed = False\n    star = False\n    is_agg = False\n    select_all = SELECT_ALL in parent_selections\n    for selection in scope.expression.selects:\n        name = selection.alias_or_name\n        if select_all or name in parent_selections or name in order_refs or (alias_count > 0):\n            new_selections.append(selection)\n            alias_count -= 1\n        else:\n            if selection.is_star:\n                star = True\n            removed = True\n        if not is_agg and selection.find(exp.AggFunc):\n            is_agg = True\n    if star:\n        resolver = Resolver(scope, schema)\n        names = {s.alias_or_name for s in new_selections}\n        for name in sorted(parent_selections):\n            if name not in names:\n                new_selections.append(alias(exp.column(name, table=resolver.get_table(name)), name, copy=False))\n    if not new_selections:\n        new_selections.append(DEFAULT_SELECTION(is_agg))\n    scope.expression.select(*new_selections, append=False, copy=False)\n    if removed:\n        scope.clear_cache()",
        "mutated": [
            "def _remove_unused_selections(scope, parent_selections, schema, alias_count):\n    if False:\n        i = 10\n    order = scope.expression.args.get('order')\n    if order:\n        order_refs = {c.name for c in order.find_all(exp.Column) if not c.table}\n    else:\n        order_refs = set()\n    new_selections = []\n    removed = False\n    star = False\n    is_agg = False\n    select_all = SELECT_ALL in parent_selections\n    for selection in scope.expression.selects:\n        name = selection.alias_or_name\n        if select_all or name in parent_selections or name in order_refs or (alias_count > 0):\n            new_selections.append(selection)\n            alias_count -= 1\n        else:\n            if selection.is_star:\n                star = True\n            removed = True\n        if not is_agg and selection.find(exp.AggFunc):\n            is_agg = True\n    if star:\n        resolver = Resolver(scope, schema)\n        names = {s.alias_or_name for s in new_selections}\n        for name in sorted(parent_selections):\n            if name not in names:\n                new_selections.append(alias(exp.column(name, table=resolver.get_table(name)), name, copy=False))\n    if not new_selections:\n        new_selections.append(DEFAULT_SELECTION(is_agg))\n    scope.expression.select(*new_selections, append=False, copy=False)\n    if removed:\n        scope.clear_cache()",
            "def _remove_unused_selections(scope, parent_selections, schema, alias_count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    order = scope.expression.args.get('order')\n    if order:\n        order_refs = {c.name for c in order.find_all(exp.Column) if not c.table}\n    else:\n        order_refs = set()\n    new_selections = []\n    removed = False\n    star = False\n    is_agg = False\n    select_all = SELECT_ALL in parent_selections\n    for selection in scope.expression.selects:\n        name = selection.alias_or_name\n        if select_all or name in parent_selections or name in order_refs or (alias_count > 0):\n            new_selections.append(selection)\n            alias_count -= 1\n        else:\n            if selection.is_star:\n                star = True\n            removed = True\n        if not is_agg and selection.find(exp.AggFunc):\n            is_agg = True\n    if star:\n        resolver = Resolver(scope, schema)\n        names = {s.alias_or_name for s in new_selections}\n        for name in sorted(parent_selections):\n            if name not in names:\n                new_selections.append(alias(exp.column(name, table=resolver.get_table(name)), name, copy=False))\n    if not new_selections:\n        new_selections.append(DEFAULT_SELECTION(is_agg))\n    scope.expression.select(*new_selections, append=False, copy=False)\n    if removed:\n        scope.clear_cache()",
            "def _remove_unused_selections(scope, parent_selections, schema, alias_count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    order = scope.expression.args.get('order')\n    if order:\n        order_refs = {c.name for c in order.find_all(exp.Column) if not c.table}\n    else:\n        order_refs = set()\n    new_selections = []\n    removed = False\n    star = False\n    is_agg = False\n    select_all = SELECT_ALL in parent_selections\n    for selection in scope.expression.selects:\n        name = selection.alias_or_name\n        if select_all or name in parent_selections or name in order_refs or (alias_count > 0):\n            new_selections.append(selection)\n            alias_count -= 1\n        else:\n            if selection.is_star:\n                star = True\n            removed = True\n        if not is_agg and selection.find(exp.AggFunc):\n            is_agg = True\n    if star:\n        resolver = Resolver(scope, schema)\n        names = {s.alias_or_name for s in new_selections}\n        for name in sorted(parent_selections):\n            if name not in names:\n                new_selections.append(alias(exp.column(name, table=resolver.get_table(name)), name, copy=False))\n    if not new_selections:\n        new_selections.append(DEFAULT_SELECTION(is_agg))\n    scope.expression.select(*new_selections, append=False, copy=False)\n    if removed:\n        scope.clear_cache()",
            "def _remove_unused_selections(scope, parent_selections, schema, alias_count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    order = scope.expression.args.get('order')\n    if order:\n        order_refs = {c.name for c in order.find_all(exp.Column) if not c.table}\n    else:\n        order_refs = set()\n    new_selections = []\n    removed = False\n    star = False\n    is_agg = False\n    select_all = SELECT_ALL in parent_selections\n    for selection in scope.expression.selects:\n        name = selection.alias_or_name\n        if select_all or name in parent_selections or name in order_refs or (alias_count > 0):\n            new_selections.append(selection)\n            alias_count -= 1\n        else:\n            if selection.is_star:\n                star = True\n            removed = True\n        if not is_agg and selection.find(exp.AggFunc):\n            is_agg = True\n    if star:\n        resolver = Resolver(scope, schema)\n        names = {s.alias_or_name for s in new_selections}\n        for name in sorted(parent_selections):\n            if name not in names:\n                new_selections.append(alias(exp.column(name, table=resolver.get_table(name)), name, copy=False))\n    if not new_selections:\n        new_selections.append(DEFAULT_SELECTION(is_agg))\n    scope.expression.select(*new_selections, append=False, copy=False)\n    if removed:\n        scope.clear_cache()",
            "def _remove_unused_selections(scope, parent_selections, schema, alias_count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    order = scope.expression.args.get('order')\n    if order:\n        order_refs = {c.name for c in order.find_all(exp.Column) if not c.table}\n    else:\n        order_refs = set()\n    new_selections = []\n    removed = False\n    star = False\n    is_agg = False\n    select_all = SELECT_ALL in parent_selections\n    for selection in scope.expression.selects:\n        name = selection.alias_or_name\n        if select_all or name in parent_selections or name in order_refs or (alias_count > 0):\n            new_selections.append(selection)\n            alias_count -= 1\n        else:\n            if selection.is_star:\n                star = True\n            removed = True\n        if not is_agg and selection.find(exp.AggFunc):\n            is_agg = True\n    if star:\n        resolver = Resolver(scope, schema)\n        names = {s.alias_or_name for s in new_selections}\n        for name in sorted(parent_selections):\n            if name not in names:\n                new_selections.append(alias(exp.column(name, table=resolver.get_table(name)), name, copy=False))\n    if not new_selections:\n        new_selections.append(DEFAULT_SELECTION(is_agg))\n    scope.expression.select(*new_selections, append=False, copy=False)\n    if removed:\n        scope.clear_cache()"
        ]
    }
]