[
    {
        "func_name": "__init__",
        "original": "def __init__(self, classifier: 'CLASSIFIER_TYPE', attack: str='dct', max_iter: int=3000, order: str='random', epsilon: float=0.1, freq_dim: int=4, stride: int=1, targeted: bool=False, batch_size: int=1, verbose: bool=True):\n    \"\"\"\n        Create a SimBA (dct) attack instance.\n\n        :param classifier: A trained classifier predicting probabilities and not logits.\n        :param attack: attack type: pixel (px) or DCT (dct) attacks\n        :param max_iter: The maximum number of iterations.\n        :param epsilon: Overshoot parameter.\n        :param order: order of pixel attacks: random or diagonal (diag)\n        :param freq_dim: dimensionality of 2D frequency space (DCT).\n        :param stride: stride for block order (DCT).\n        :param targeted: perform targeted attack\n        :param batch_size: Batch size (but, batch process unavailable in this implementation)\n        :param verbose: Show progress bars.\n        \"\"\"\n    super().__init__(estimator=classifier)\n    self.attack = attack\n    self.max_iter = max_iter\n    self.epsilon = epsilon\n    self.order = order\n    self.freq_dim = freq_dim\n    self.stride = stride\n    self._targeted = targeted\n    self.batch_size = batch_size\n    self.verbose = verbose\n    self._check_params()",
        "mutated": [
            "def __init__(self, classifier: 'CLASSIFIER_TYPE', attack: str='dct', max_iter: int=3000, order: str='random', epsilon: float=0.1, freq_dim: int=4, stride: int=1, targeted: bool=False, batch_size: int=1, verbose: bool=True):\n    if False:\n        i = 10\n    '\\n        Create a SimBA (dct) attack instance.\\n\\n        :param classifier: A trained classifier predicting probabilities and not logits.\\n        :param attack: attack type: pixel (px) or DCT (dct) attacks\\n        :param max_iter: The maximum number of iterations.\\n        :param epsilon: Overshoot parameter.\\n        :param order: order of pixel attacks: random or diagonal (diag)\\n        :param freq_dim: dimensionality of 2D frequency space (DCT).\\n        :param stride: stride for block order (DCT).\\n        :param targeted: perform targeted attack\\n        :param batch_size: Batch size (but, batch process unavailable in this implementation)\\n        :param verbose: Show progress bars.\\n        '\n    super().__init__(estimator=classifier)\n    self.attack = attack\n    self.max_iter = max_iter\n    self.epsilon = epsilon\n    self.order = order\n    self.freq_dim = freq_dim\n    self.stride = stride\n    self._targeted = targeted\n    self.batch_size = batch_size\n    self.verbose = verbose\n    self._check_params()",
            "def __init__(self, classifier: 'CLASSIFIER_TYPE', attack: str='dct', max_iter: int=3000, order: str='random', epsilon: float=0.1, freq_dim: int=4, stride: int=1, targeted: bool=False, batch_size: int=1, verbose: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Create a SimBA (dct) attack instance.\\n\\n        :param classifier: A trained classifier predicting probabilities and not logits.\\n        :param attack: attack type: pixel (px) or DCT (dct) attacks\\n        :param max_iter: The maximum number of iterations.\\n        :param epsilon: Overshoot parameter.\\n        :param order: order of pixel attacks: random or diagonal (diag)\\n        :param freq_dim: dimensionality of 2D frequency space (DCT).\\n        :param stride: stride for block order (DCT).\\n        :param targeted: perform targeted attack\\n        :param batch_size: Batch size (but, batch process unavailable in this implementation)\\n        :param verbose: Show progress bars.\\n        '\n    super().__init__(estimator=classifier)\n    self.attack = attack\n    self.max_iter = max_iter\n    self.epsilon = epsilon\n    self.order = order\n    self.freq_dim = freq_dim\n    self.stride = stride\n    self._targeted = targeted\n    self.batch_size = batch_size\n    self.verbose = verbose\n    self._check_params()",
            "def __init__(self, classifier: 'CLASSIFIER_TYPE', attack: str='dct', max_iter: int=3000, order: str='random', epsilon: float=0.1, freq_dim: int=4, stride: int=1, targeted: bool=False, batch_size: int=1, verbose: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Create a SimBA (dct) attack instance.\\n\\n        :param classifier: A trained classifier predicting probabilities and not logits.\\n        :param attack: attack type: pixel (px) or DCT (dct) attacks\\n        :param max_iter: The maximum number of iterations.\\n        :param epsilon: Overshoot parameter.\\n        :param order: order of pixel attacks: random or diagonal (diag)\\n        :param freq_dim: dimensionality of 2D frequency space (DCT).\\n        :param stride: stride for block order (DCT).\\n        :param targeted: perform targeted attack\\n        :param batch_size: Batch size (but, batch process unavailable in this implementation)\\n        :param verbose: Show progress bars.\\n        '\n    super().__init__(estimator=classifier)\n    self.attack = attack\n    self.max_iter = max_iter\n    self.epsilon = epsilon\n    self.order = order\n    self.freq_dim = freq_dim\n    self.stride = stride\n    self._targeted = targeted\n    self.batch_size = batch_size\n    self.verbose = verbose\n    self._check_params()",
            "def __init__(self, classifier: 'CLASSIFIER_TYPE', attack: str='dct', max_iter: int=3000, order: str='random', epsilon: float=0.1, freq_dim: int=4, stride: int=1, targeted: bool=False, batch_size: int=1, verbose: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Create a SimBA (dct) attack instance.\\n\\n        :param classifier: A trained classifier predicting probabilities and not logits.\\n        :param attack: attack type: pixel (px) or DCT (dct) attacks\\n        :param max_iter: The maximum number of iterations.\\n        :param epsilon: Overshoot parameter.\\n        :param order: order of pixel attacks: random or diagonal (diag)\\n        :param freq_dim: dimensionality of 2D frequency space (DCT).\\n        :param stride: stride for block order (DCT).\\n        :param targeted: perform targeted attack\\n        :param batch_size: Batch size (but, batch process unavailable in this implementation)\\n        :param verbose: Show progress bars.\\n        '\n    super().__init__(estimator=classifier)\n    self.attack = attack\n    self.max_iter = max_iter\n    self.epsilon = epsilon\n    self.order = order\n    self.freq_dim = freq_dim\n    self.stride = stride\n    self._targeted = targeted\n    self.batch_size = batch_size\n    self.verbose = verbose\n    self._check_params()",
            "def __init__(self, classifier: 'CLASSIFIER_TYPE', attack: str='dct', max_iter: int=3000, order: str='random', epsilon: float=0.1, freq_dim: int=4, stride: int=1, targeted: bool=False, batch_size: int=1, verbose: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Create a SimBA (dct) attack instance.\\n\\n        :param classifier: A trained classifier predicting probabilities and not logits.\\n        :param attack: attack type: pixel (px) or DCT (dct) attacks\\n        :param max_iter: The maximum number of iterations.\\n        :param epsilon: Overshoot parameter.\\n        :param order: order of pixel attacks: random or diagonal (diag)\\n        :param freq_dim: dimensionality of 2D frequency space (DCT).\\n        :param stride: stride for block order (DCT).\\n        :param targeted: perform targeted attack\\n        :param batch_size: Batch size (but, batch process unavailable in this implementation)\\n        :param verbose: Show progress bars.\\n        '\n    super().__init__(estimator=classifier)\n    self.attack = attack\n    self.max_iter = max_iter\n    self.epsilon = epsilon\n    self.order = order\n    self.freq_dim = freq_dim\n    self.stride = stride\n    self._targeted = targeted\n    self.batch_size = batch_size\n    self.verbose = verbose\n    self._check_params()"
        ]
    },
    {
        "func_name": "trans",
        "original": "def trans(var_z):\n    return self._block_idct(var_z, block_size=x.shape[2])",
        "mutated": [
            "def trans(var_z):\n    if False:\n        i = 10\n    return self._block_idct(var_z, block_size=x.shape[2])",
            "def trans(var_z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self._block_idct(var_z, block_size=x.shape[2])",
            "def trans(var_z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self._block_idct(var_z, block_size=x.shape[2])",
            "def trans(var_z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self._block_idct(var_z, block_size=x.shape[2])",
            "def trans(var_z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self._block_idct(var_z, block_size=x.shape[2])"
        ]
    },
    {
        "func_name": "generate",
        "original": "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    \"\"\"\n        Generate adversarial samples and return them in an array.\n\n        :param x: An array with the original inputs to be attacked.\n        :param y: An array with the true or target labels.\n        :return: An array holding the adversarial examples.\n        \"\"\"\n    x = x.astype(ART_NUMPY_DTYPE)\n    x_adv = x.copy()\n    y_prob_pred = self.estimator.predict(x, batch_size=self.batch_size)\n    if not is_probability(y_prob_pred[0]):\n        raise ValueError('This attack requires an estimator predicting probabilities. It looks like the current estimator is not predicting probabilities')\n    if self.estimator.nb_classes == 2 and y_prob_pred.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    if divmod(x.shape[2] - self.freq_dim, self.stride)[1] != 0:\n        raise ValueError('Incompatible value combination in image height/width, freq_dim and stride detected. Adapt these parameters to fulfill the following conditions: divmod(image_height - freq_dim, stride)[1] == 0 and divmod(image_width - freq_dim, stride)[1] == 0')\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        logger.info('Using the model prediction as the correct label for SimBA.')\n        y_i = np.argmax(y_prob_pred, axis=1)\n    else:\n        y_i = np.argmax(y, axis=1)\n    for i_sample in trange(x.shape[0], desc='SimBA - sample', disable=not self.verbose):\n        desired_label = y_i[i_sample]\n        current_label = np.argmax(y_prob_pred, axis=1)[i_sample]\n        last_prob = y_prob_pred[i_sample].reshape(-1)[desired_label]\n        if self.estimator.channels_first:\n            nb_channels = x.shape[1]\n        else:\n            nb_channels = x.shape[3]\n        n_dims = np.prod(x[[0]].shape)\n        if self.attack == 'px':\n            if self.order == 'diag':\n                indices = self.diagonal_order(x.shape[2], nb_channels)[:self.max_iter]\n            elif self.order == 'random':\n                indices = np.random.permutation(n_dims)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                if self.order == 'diag':\n                    tmp_indices = self.diagonal_order(x.shape[2], nb_channels)\n                elif self.order == 'random':\n                    tmp_indices = np.random.permutation(n_dims)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n        elif self.attack == 'dct':\n            indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                tmp_indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n\n            def trans(var_z):\n                return self._block_idct(var_z, block_size=x.shape[2])\n        clip_min = -np.inf\n        clip_max = np.inf\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n        term_flag = 1\n        if self.targeted:\n            if desired_label != current_label:\n                term_flag = 0\n        elif desired_label == current_label:\n            term_flag = 0\n        nb_iter = 0\n        while term_flag == 0 and nb_iter < self.max_iter:\n            diff = np.zeros(n_dims).astype(ART_NUMPY_DTYPE)\n            diff[indices[nb_iter]] = self.epsilon\n            if self.attack == 'dct':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            left_prob = left_preds.reshape(-1)[desired_label]\n            if self.attack == 'dct':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            right_prob = right_preds.reshape(-1)[desired_label]\n            if self.targeted:\n                if left_prob > last_prob:\n                    if left_prob > right_prob:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = left_prob\n                        current_label = np.argmax(left_preds, axis=1)[0]\n                    else:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = right_prob\n                        current_label = np.argmax(right_preds, axis=1)[0]\n                elif right_prob > last_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif left_prob < last_prob:\n                if left_prob < right_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = left_prob\n                    current_label = np.argmax(left_preds, axis=1)[0]\n                else:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif right_prob < last_prob:\n                if self.attack == 'dct':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                elif self.attack == 'px':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                last_prob = right_prob\n                current_label = np.argmax(right_preds, axis=1)[0]\n            if self.targeted:\n                if desired_label == current_label:\n                    term_flag = 1\n            elif desired_label != current_label:\n                term_flag = 1\n            nb_iter = nb_iter + 1\n        if nb_iter < self.max_iter:\n            logger.info('SimBA (%s) %s attack succeed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        else:\n            logger.info('SimBA (%s) %s attack failed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        x_adv[i_sample] = x[i_sample]\n    return x_adv",
        "mutated": [
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs to be attacked.\\n        :param y: An array with the true or target labels.\\n        :return: An array holding the adversarial examples.\\n        '\n    x = x.astype(ART_NUMPY_DTYPE)\n    x_adv = x.copy()\n    y_prob_pred = self.estimator.predict(x, batch_size=self.batch_size)\n    if not is_probability(y_prob_pred[0]):\n        raise ValueError('This attack requires an estimator predicting probabilities. It looks like the current estimator is not predicting probabilities')\n    if self.estimator.nb_classes == 2 and y_prob_pred.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    if divmod(x.shape[2] - self.freq_dim, self.stride)[1] != 0:\n        raise ValueError('Incompatible value combination in image height/width, freq_dim and stride detected. Adapt these parameters to fulfill the following conditions: divmod(image_height - freq_dim, stride)[1] == 0 and divmod(image_width - freq_dim, stride)[1] == 0')\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        logger.info('Using the model prediction as the correct label for SimBA.')\n        y_i = np.argmax(y_prob_pred, axis=1)\n    else:\n        y_i = np.argmax(y, axis=1)\n    for i_sample in trange(x.shape[0], desc='SimBA - sample', disable=not self.verbose):\n        desired_label = y_i[i_sample]\n        current_label = np.argmax(y_prob_pred, axis=1)[i_sample]\n        last_prob = y_prob_pred[i_sample].reshape(-1)[desired_label]\n        if self.estimator.channels_first:\n            nb_channels = x.shape[1]\n        else:\n            nb_channels = x.shape[3]\n        n_dims = np.prod(x[[0]].shape)\n        if self.attack == 'px':\n            if self.order == 'diag':\n                indices = self.diagonal_order(x.shape[2], nb_channels)[:self.max_iter]\n            elif self.order == 'random':\n                indices = np.random.permutation(n_dims)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                if self.order == 'diag':\n                    tmp_indices = self.diagonal_order(x.shape[2], nb_channels)\n                elif self.order == 'random':\n                    tmp_indices = np.random.permutation(n_dims)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n        elif self.attack == 'dct':\n            indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                tmp_indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n\n            def trans(var_z):\n                return self._block_idct(var_z, block_size=x.shape[2])\n        clip_min = -np.inf\n        clip_max = np.inf\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n        term_flag = 1\n        if self.targeted:\n            if desired_label != current_label:\n                term_flag = 0\n        elif desired_label == current_label:\n            term_flag = 0\n        nb_iter = 0\n        while term_flag == 0 and nb_iter < self.max_iter:\n            diff = np.zeros(n_dims).astype(ART_NUMPY_DTYPE)\n            diff[indices[nb_iter]] = self.epsilon\n            if self.attack == 'dct':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            left_prob = left_preds.reshape(-1)[desired_label]\n            if self.attack == 'dct':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            right_prob = right_preds.reshape(-1)[desired_label]\n            if self.targeted:\n                if left_prob > last_prob:\n                    if left_prob > right_prob:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = left_prob\n                        current_label = np.argmax(left_preds, axis=1)[0]\n                    else:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = right_prob\n                        current_label = np.argmax(right_preds, axis=1)[0]\n                elif right_prob > last_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif left_prob < last_prob:\n                if left_prob < right_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = left_prob\n                    current_label = np.argmax(left_preds, axis=1)[0]\n                else:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif right_prob < last_prob:\n                if self.attack == 'dct':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                elif self.attack == 'px':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                last_prob = right_prob\n                current_label = np.argmax(right_preds, axis=1)[0]\n            if self.targeted:\n                if desired_label == current_label:\n                    term_flag = 1\n            elif desired_label != current_label:\n                term_flag = 1\n            nb_iter = nb_iter + 1\n        if nb_iter < self.max_iter:\n            logger.info('SimBA (%s) %s attack succeed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        else:\n            logger.info('SimBA (%s) %s attack failed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        x_adv[i_sample] = x[i_sample]\n    return x_adv",
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs to be attacked.\\n        :param y: An array with the true or target labels.\\n        :return: An array holding the adversarial examples.\\n        '\n    x = x.astype(ART_NUMPY_DTYPE)\n    x_adv = x.copy()\n    y_prob_pred = self.estimator.predict(x, batch_size=self.batch_size)\n    if not is_probability(y_prob_pred[0]):\n        raise ValueError('This attack requires an estimator predicting probabilities. It looks like the current estimator is not predicting probabilities')\n    if self.estimator.nb_classes == 2 and y_prob_pred.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    if divmod(x.shape[2] - self.freq_dim, self.stride)[1] != 0:\n        raise ValueError('Incompatible value combination in image height/width, freq_dim and stride detected. Adapt these parameters to fulfill the following conditions: divmod(image_height - freq_dim, stride)[1] == 0 and divmod(image_width - freq_dim, stride)[1] == 0')\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        logger.info('Using the model prediction as the correct label for SimBA.')\n        y_i = np.argmax(y_prob_pred, axis=1)\n    else:\n        y_i = np.argmax(y, axis=1)\n    for i_sample in trange(x.shape[0], desc='SimBA - sample', disable=not self.verbose):\n        desired_label = y_i[i_sample]\n        current_label = np.argmax(y_prob_pred, axis=1)[i_sample]\n        last_prob = y_prob_pred[i_sample].reshape(-1)[desired_label]\n        if self.estimator.channels_first:\n            nb_channels = x.shape[1]\n        else:\n            nb_channels = x.shape[3]\n        n_dims = np.prod(x[[0]].shape)\n        if self.attack == 'px':\n            if self.order == 'diag':\n                indices = self.diagonal_order(x.shape[2], nb_channels)[:self.max_iter]\n            elif self.order == 'random':\n                indices = np.random.permutation(n_dims)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                if self.order == 'diag':\n                    tmp_indices = self.diagonal_order(x.shape[2], nb_channels)\n                elif self.order == 'random':\n                    tmp_indices = np.random.permutation(n_dims)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n        elif self.attack == 'dct':\n            indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                tmp_indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n\n            def trans(var_z):\n                return self._block_idct(var_z, block_size=x.shape[2])\n        clip_min = -np.inf\n        clip_max = np.inf\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n        term_flag = 1\n        if self.targeted:\n            if desired_label != current_label:\n                term_flag = 0\n        elif desired_label == current_label:\n            term_flag = 0\n        nb_iter = 0\n        while term_flag == 0 and nb_iter < self.max_iter:\n            diff = np.zeros(n_dims).astype(ART_NUMPY_DTYPE)\n            diff[indices[nb_iter]] = self.epsilon\n            if self.attack == 'dct':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            left_prob = left_preds.reshape(-1)[desired_label]\n            if self.attack == 'dct':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            right_prob = right_preds.reshape(-1)[desired_label]\n            if self.targeted:\n                if left_prob > last_prob:\n                    if left_prob > right_prob:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = left_prob\n                        current_label = np.argmax(left_preds, axis=1)[0]\n                    else:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = right_prob\n                        current_label = np.argmax(right_preds, axis=1)[0]\n                elif right_prob > last_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif left_prob < last_prob:\n                if left_prob < right_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = left_prob\n                    current_label = np.argmax(left_preds, axis=1)[0]\n                else:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif right_prob < last_prob:\n                if self.attack == 'dct':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                elif self.attack == 'px':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                last_prob = right_prob\n                current_label = np.argmax(right_preds, axis=1)[0]\n            if self.targeted:\n                if desired_label == current_label:\n                    term_flag = 1\n            elif desired_label != current_label:\n                term_flag = 1\n            nb_iter = nb_iter + 1\n        if nb_iter < self.max_iter:\n            logger.info('SimBA (%s) %s attack succeed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        else:\n            logger.info('SimBA (%s) %s attack failed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        x_adv[i_sample] = x[i_sample]\n    return x_adv",
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs to be attacked.\\n        :param y: An array with the true or target labels.\\n        :return: An array holding the adversarial examples.\\n        '\n    x = x.astype(ART_NUMPY_DTYPE)\n    x_adv = x.copy()\n    y_prob_pred = self.estimator.predict(x, batch_size=self.batch_size)\n    if not is_probability(y_prob_pred[0]):\n        raise ValueError('This attack requires an estimator predicting probabilities. It looks like the current estimator is not predicting probabilities')\n    if self.estimator.nb_classes == 2 and y_prob_pred.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    if divmod(x.shape[2] - self.freq_dim, self.stride)[1] != 0:\n        raise ValueError('Incompatible value combination in image height/width, freq_dim and stride detected. Adapt these parameters to fulfill the following conditions: divmod(image_height - freq_dim, stride)[1] == 0 and divmod(image_width - freq_dim, stride)[1] == 0')\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        logger.info('Using the model prediction as the correct label for SimBA.')\n        y_i = np.argmax(y_prob_pred, axis=1)\n    else:\n        y_i = np.argmax(y, axis=1)\n    for i_sample in trange(x.shape[0], desc='SimBA - sample', disable=not self.verbose):\n        desired_label = y_i[i_sample]\n        current_label = np.argmax(y_prob_pred, axis=1)[i_sample]\n        last_prob = y_prob_pred[i_sample].reshape(-1)[desired_label]\n        if self.estimator.channels_first:\n            nb_channels = x.shape[1]\n        else:\n            nb_channels = x.shape[3]\n        n_dims = np.prod(x[[0]].shape)\n        if self.attack == 'px':\n            if self.order == 'diag':\n                indices = self.diagonal_order(x.shape[2], nb_channels)[:self.max_iter]\n            elif self.order == 'random':\n                indices = np.random.permutation(n_dims)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                if self.order == 'diag':\n                    tmp_indices = self.diagonal_order(x.shape[2], nb_channels)\n                elif self.order == 'random':\n                    tmp_indices = np.random.permutation(n_dims)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n        elif self.attack == 'dct':\n            indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                tmp_indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n\n            def trans(var_z):\n                return self._block_idct(var_z, block_size=x.shape[2])\n        clip_min = -np.inf\n        clip_max = np.inf\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n        term_flag = 1\n        if self.targeted:\n            if desired_label != current_label:\n                term_flag = 0\n        elif desired_label == current_label:\n            term_flag = 0\n        nb_iter = 0\n        while term_flag == 0 and nb_iter < self.max_iter:\n            diff = np.zeros(n_dims).astype(ART_NUMPY_DTYPE)\n            diff[indices[nb_iter]] = self.epsilon\n            if self.attack == 'dct':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            left_prob = left_preds.reshape(-1)[desired_label]\n            if self.attack == 'dct':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            right_prob = right_preds.reshape(-1)[desired_label]\n            if self.targeted:\n                if left_prob > last_prob:\n                    if left_prob > right_prob:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = left_prob\n                        current_label = np.argmax(left_preds, axis=1)[0]\n                    else:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = right_prob\n                        current_label = np.argmax(right_preds, axis=1)[0]\n                elif right_prob > last_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif left_prob < last_prob:\n                if left_prob < right_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = left_prob\n                    current_label = np.argmax(left_preds, axis=1)[0]\n                else:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif right_prob < last_prob:\n                if self.attack == 'dct':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                elif self.attack == 'px':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                last_prob = right_prob\n                current_label = np.argmax(right_preds, axis=1)[0]\n            if self.targeted:\n                if desired_label == current_label:\n                    term_flag = 1\n            elif desired_label != current_label:\n                term_flag = 1\n            nb_iter = nb_iter + 1\n        if nb_iter < self.max_iter:\n            logger.info('SimBA (%s) %s attack succeed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        else:\n            logger.info('SimBA (%s) %s attack failed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        x_adv[i_sample] = x[i_sample]\n    return x_adv",
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs to be attacked.\\n        :param y: An array with the true or target labels.\\n        :return: An array holding the adversarial examples.\\n        '\n    x = x.astype(ART_NUMPY_DTYPE)\n    x_adv = x.copy()\n    y_prob_pred = self.estimator.predict(x, batch_size=self.batch_size)\n    if not is_probability(y_prob_pred[0]):\n        raise ValueError('This attack requires an estimator predicting probabilities. It looks like the current estimator is not predicting probabilities')\n    if self.estimator.nb_classes == 2 and y_prob_pred.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    if divmod(x.shape[2] - self.freq_dim, self.stride)[1] != 0:\n        raise ValueError('Incompatible value combination in image height/width, freq_dim and stride detected. Adapt these parameters to fulfill the following conditions: divmod(image_height - freq_dim, stride)[1] == 0 and divmod(image_width - freq_dim, stride)[1] == 0')\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        logger.info('Using the model prediction as the correct label for SimBA.')\n        y_i = np.argmax(y_prob_pred, axis=1)\n    else:\n        y_i = np.argmax(y, axis=1)\n    for i_sample in trange(x.shape[0], desc='SimBA - sample', disable=not self.verbose):\n        desired_label = y_i[i_sample]\n        current_label = np.argmax(y_prob_pred, axis=1)[i_sample]\n        last_prob = y_prob_pred[i_sample].reshape(-1)[desired_label]\n        if self.estimator.channels_first:\n            nb_channels = x.shape[1]\n        else:\n            nb_channels = x.shape[3]\n        n_dims = np.prod(x[[0]].shape)\n        if self.attack == 'px':\n            if self.order == 'diag':\n                indices = self.diagonal_order(x.shape[2], nb_channels)[:self.max_iter]\n            elif self.order == 'random':\n                indices = np.random.permutation(n_dims)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                if self.order == 'diag':\n                    tmp_indices = self.diagonal_order(x.shape[2], nb_channels)\n                elif self.order == 'random':\n                    tmp_indices = np.random.permutation(n_dims)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n        elif self.attack == 'dct':\n            indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                tmp_indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n\n            def trans(var_z):\n                return self._block_idct(var_z, block_size=x.shape[2])\n        clip_min = -np.inf\n        clip_max = np.inf\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n        term_flag = 1\n        if self.targeted:\n            if desired_label != current_label:\n                term_flag = 0\n        elif desired_label == current_label:\n            term_flag = 0\n        nb_iter = 0\n        while term_flag == 0 and nb_iter < self.max_iter:\n            diff = np.zeros(n_dims).astype(ART_NUMPY_DTYPE)\n            diff[indices[nb_iter]] = self.epsilon\n            if self.attack == 'dct':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            left_prob = left_preds.reshape(-1)[desired_label]\n            if self.attack == 'dct':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            right_prob = right_preds.reshape(-1)[desired_label]\n            if self.targeted:\n                if left_prob > last_prob:\n                    if left_prob > right_prob:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = left_prob\n                        current_label = np.argmax(left_preds, axis=1)[0]\n                    else:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = right_prob\n                        current_label = np.argmax(right_preds, axis=1)[0]\n                elif right_prob > last_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif left_prob < last_prob:\n                if left_prob < right_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = left_prob\n                    current_label = np.argmax(left_preds, axis=1)[0]\n                else:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif right_prob < last_prob:\n                if self.attack == 'dct':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                elif self.attack == 'px':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                last_prob = right_prob\n                current_label = np.argmax(right_preds, axis=1)[0]\n            if self.targeted:\n                if desired_label == current_label:\n                    term_flag = 1\n            elif desired_label != current_label:\n                term_flag = 1\n            nb_iter = nb_iter + 1\n        if nb_iter < self.max_iter:\n            logger.info('SimBA (%s) %s attack succeed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        else:\n            logger.info('SimBA (%s) %s attack failed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        x_adv[i_sample] = x[i_sample]\n    return x_adv",
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs to be attacked.\\n        :param y: An array with the true or target labels.\\n        :return: An array holding the adversarial examples.\\n        '\n    x = x.astype(ART_NUMPY_DTYPE)\n    x_adv = x.copy()\n    y_prob_pred = self.estimator.predict(x, batch_size=self.batch_size)\n    if not is_probability(y_prob_pred[0]):\n        raise ValueError('This attack requires an estimator predicting probabilities. It looks like the current estimator is not predicting probabilities')\n    if self.estimator.nb_classes == 2 and y_prob_pred.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    if divmod(x.shape[2] - self.freq_dim, self.stride)[1] != 0:\n        raise ValueError('Incompatible value combination in image height/width, freq_dim and stride detected. Adapt these parameters to fulfill the following conditions: divmod(image_height - freq_dim, stride)[1] == 0 and divmod(image_width - freq_dim, stride)[1] == 0')\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        logger.info('Using the model prediction as the correct label for SimBA.')\n        y_i = np.argmax(y_prob_pred, axis=1)\n    else:\n        y_i = np.argmax(y, axis=1)\n    for i_sample in trange(x.shape[0], desc='SimBA - sample', disable=not self.verbose):\n        desired_label = y_i[i_sample]\n        current_label = np.argmax(y_prob_pred, axis=1)[i_sample]\n        last_prob = y_prob_pred[i_sample].reshape(-1)[desired_label]\n        if self.estimator.channels_first:\n            nb_channels = x.shape[1]\n        else:\n            nb_channels = x.shape[3]\n        n_dims = np.prod(x[[0]].shape)\n        if self.attack == 'px':\n            if self.order == 'diag':\n                indices = self.diagonal_order(x.shape[2], nb_channels)[:self.max_iter]\n            elif self.order == 'random':\n                indices = np.random.permutation(n_dims)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                if self.order == 'diag':\n                    tmp_indices = self.diagonal_order(x.shape[2], nb_channels)\n                elif self.order == 'random':\n                    tmp_indices = np.random.permutation(n_dims)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n        elif self.attack == 'dct':\n            indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)[:self.max_iter]\n            indices_size = len(indices)\n            while indices_size < self.max_iter:\n                tmp_indices = self._block_order(x.shape[2], nb_channels, initial_size=self.freq_dim, stride=self.stride)\n                indices = np.hstack((indices, tmp_indices))[:self.max_iter]\n                indices_size = len(indices)\n\n            def trans(var_z):\n                return self._block_idct(var_z, block_size=x.shape[2])\n        clip_min = -np.inf\n        clip_max = np.inf\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n        term_flag = 1\n        if self.targeted:\n            if desired_label != current_label:\n                term_flag = 0\n        elif desired_label == current_label:\n            term_flag = 0\n        nb_iter = 0\n        while term_flag == 0 and nb_iter < self.max_iter:\n            diff = np.zeros(n_dims).astype(ART_NUMPY_DTYPE)\n            diff[indices[nb_iter]] = self.epsilon\n            if self.attack == 'dct':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                left_preds = self.estimator.predict(np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            left_prob = left_preds.reshape(-1)[desired_label]\n            if self.attack == 'dct':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max), batch_size=self.batch_size)\n            elif self.attack == 'px':\n                right_preds = self.estimator.predict(np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max), batch_size=self.batch_size)\n            right_prob = right_preds.reshape(-1)[desired_label]\n            if self.targeted:\n                if left_prob > last_prob:\n                    if left_prob > right_prob:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = left_prob\n                        current_label = np.argmax(left_preds, axis=1)[0]\n                    else:\n                        if self.attack == 'dct':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                        elif self.attack == 'px':\n                            x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                        last_prob = right_prob\n                        current_label = np.argmax(right_preds, axis=1)[0]\n                elif right_prob > last_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif left_prob < last_prob:\n                if left_prob < right_prob:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] - diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = left_prob\n                    current_label = np.argmax(left_preds, axis=1)[0]\n                else:\n                    if self.attack == 'dct':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                    elif self.attack == 'px':\n                        x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                    last_prob = right_prob\n                    current_label = np.argmax(right_preds, axis=1)[0]\n            elif right_prob < last_prob:\n                if self.attack == 'dct':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + trans(diff.reshape(x[[i_sample]].shape)), clip_min, clip_max)\n                elif self.attack == 'px':\n                    x[[i_sample]] = np.clip(x[[i_sample]] + diff.reshape(x[[i_sample]].shape), clip_min, clip_max)\n                last_prob = right_prob\n                current_label = np.argmax(right_preds, axis=1)[0]\n            if self.targeted:\n                if desired_label == current_label:\n                    term_flag = 1\n            elif desired_label != current_label:\n                term_flag = 1\n            nb_iter = nb_iter + 1\n        if nb_iter < self.max_iter:\n            logger.info('SimBA (%s) %s attack succeed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        else:\n            logger.info('SimBA (%s) %s attack failed', self.attack, ['non-targeted', 'targeted'][int(self.targeted)])\n        x_adv[i_sample] = x[i_sample]\n    return x_adv"
        ]
    },
    {
        "func_name": "_check_params",
        "original": "def _check_params(self) -> None:\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The number of iterations must be a positive integer.')\n    if self.epsilon < 0:\n        raise ValueError('The overshoot parameter must not be negative.')\n    if self.batch_size != 1:\n        raise ValueError('The batch size `batch_size` has to be 1 in this implementation.')\n    if not isinstance(self.stride, int) or self.stride <= 0:\n        raise ValueError('The `stride` value must be a positive integer.')\n    if not isinstance(self.freq_dim, int) or self.freq_dim <= 0:\n        raise ValueError('The `freq_dim` value must be a positive integer.')\n    if self.order not in ('random', 'diag'):\n        raise ValueError('The order of pixel attacks has to be `random` or `diag`.')\n    if self.attack not in ('px', 'dct'):\n        raise ValueError('The attack type has to be `px` or `dct`.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('`targeted` has to be a Boolean value.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
        "mutated": [
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The number of iterations must be a positive integer.')\n    if self.epsilon < 0:\n        raise ValueError('The overshoot parameter must not be negative.')\n    if self.batch_size != 1:\n        raise ValueError('The batch size `batch_size` has to be 1 in this implementation.')\n    if not isinstance(self.stride, int) or self.stride <= 0:\n        raise ValueError('The `stride` value must be a positive integer.')\n    if not isinstance(self.freq_dim, int) or self.freq_dim <= 0:\n        raise ValueError('The `freq_dim` value must be a positive integer.')\n    if self.order not in ('random', 'diag'):\n        raise ValueError('The order of pixel attacks has to be `random` or `diag`.')\n    if self.attack not in ('px', 'dct'):\n        raise ValueError('The attack type has to be `px` or `dct`.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('`targeted` has to be a Boolean value.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The number of iterations must be a positive integer.')\n    if self.epsilon < 0:\n        raise ValueError('The overshoot parameter must not be negative.')\n    if self.batch_size != 1:\n        raise ValueError('The batch size `batch_size` has to be 1 in this implementation.')\n    if not isinstance(self.stride, int) or self.stride <= 0:\n        raise ValueError('The `stride` value must be a positive integer.')\n    if not isinstance(self.freq_dim, int) or self.freq_dim <= 0:\n        raise ValueError('The `freq_dim` value must be a positive integer.')\n    if self.order not in ('random', 'diag'):\n        raise ValueError('The order of pixel attacks has to be `random` or `diag`.')\n    if self.attack not in ('px', 'dct'):\n        raise ValueError('The attack type has to be `px` or `dct`.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('`targeted` has to be a Boolean value.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The number of iterations must be a positive integer.')\n    if self.epsilon < 0:\n        raise ValueError('The overshoot parameter must not be negative.')\n    if self.batch_size != 1:\n        raise ValueError('The batch size `batch_size` has to be 1 in this implementation.')\n    if not isinstance(self.stride, int) or self.stride <= 0:\n        raise ValueError('The `stride` value must be a positive integer.')\n    if not isinstance(self.freq_dim, int) or self.freq_dim <= 0:\n        raise ValueError('The `freq_dim` value must be a positive integer.')\n    if self.order not in ('random', 'diag'):\n        raise ValueError('The order of pixel attacks has to be `random` or `diag`.')\n    if self.attack not in ('px', 'dct'):\n        raise ValueError('The attack type has to be `px` or `dct`.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('`targeted` has to be a Boolean value.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The number of iterations must be a positive integer.')\n    if self.epsilon < 0:\n        raise ValueError('The overshoot parameter must not be negative.')\n    if self.batch_size != 1:\n        raise ValueError('The batch size `batch_size` has to be 1 in this implementation.')\n    if not isinstance(self.stride, int) or self.stride <= 0:\n        raise ValueError('The `stride` value must be a positive integer.')\n    if not isinstance(self.freq_dim, int) or self.freq_dim <= 0:\n        raise ValueError('The `freq_dim` value must be a positive integer.')\n    if self.order not in ('random', 'diag'):\n        raise ValueError('The order of pixel attacks has to be `random` or `diag`.')\n    if self.attack not in ('px', 'dct'):\n        raise ValueError('The attack type has to be `px` or `dct`.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('`targeted` has to be a Boolean value.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The number of iterations must be a positive integer.')\n    if self.epsilon < 0:\n        raise ValueError('The overshoot parameter must not be negative.')\n    if self.batch_size != 1:\n        raise ValueError('The batch size `batch_size` has to be 1 in this implementation.')\n    if not isinstance(self.stride, int) or self.stride <= 0:\n        raise ValueError('The `stride` value must be a positive integer.')\n    if not isinstance(self.freq_dim, int) or self.freq_dim <= 0:\n        raise ValueError('The `freq_dim` value must be a positive integer.')\n    if self.order not in ('random', 'diag'):\n        raise ValueError('The order of pixel attacks has to be `random` or `diag`.')\n    if self.attack not in ('px', 'dct'):\n        raise ValueError('The attack type has to be `px` or `dct`.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('`targeted` has to be a Boolean value.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')"
        ]
    },
    {
        "func_name": "_block_order",
        "original": "def _block_order(self, img_size, channels, initial_size=2, stride=1):\n    \"\"\"\n        Defines a block order, starting with top-left (initial_size x initial_size) submatrix\n        expanding by stride rows and columns whenever exhausted\n        randomized within the block and across channels.\n        e.g. (initial_size=2, stride=1)\n        [1, 3, 6]\n        [2, 4, 9]\n        [5, 7, 8]\n\n        :param img_size: image size (i.e., width or height).\n        :param channels: the number of channels.\n        :param initial size: initial size for submatrix.\n        :param stride: stride size for expansion.\n\n        :return order: An array holding the block order of DCT attacks.\n        \"\"\"\n    order = np.zeros((channels, img_size, img_size)).astype(ART_NUMPY_DTYPE)\n    total_elems = channels * initial_size * initial_size\n    perm = np.random.permutation(total_elems)\n    order[:, :initial_size, :initial_size] = perm.reshape((channels, initial_size, initial_size))\n    for i in range(initial_size, img_size, stride):\n        num_elems = channels * (2 * stride * i + stride * stride)\n        perm = np.random.permutation(num_elems) + total_elems\n        num_first = channels * stride * (stride + i)\n        order[:, :i + stride, i:i + stride] = perm[:num_first].reshape((channels, -1, stride))\n        order[:, i:i + stride, :i] = perm[num_first:].reshape((channels, stride, -1))\n        total_elems += num_elems\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
        "mutated": [
            "def _block_order(self, img_size, channels, initial_size=2, stride=1):\n    if False:\n        i = 10\n    '\\n        Defines a block order, starting with top-left (initial_size x initial_size) submatrix\\n        expanding by stride rows and columns whenever exhausted\\n        randomized within the block and across channels.\\n        e.g. (initial_size=2, stride=1)\\n        [1, 3, 6]\\n        [2, 4, 9]\\n        [5, 7, 8]\\n\\n        :param img_size: image size (i.e., width or height).\\n        :param channels: the number of channels.\\n        :param initial size: initial size for submatrix.\\n        :param stride: stride size for expansion.\\n\\n        :return order: An array holding the block order of DCT attacks.\\n        '\n    order = np.zeros((channels, img_size, img_size)).astype(ART_NUMPY_DTYPE)\n    total_elems = channels * initial_size * initial_size\n    perm = np.random.permutation(total_elems)\n    order[:, :initial_size, :initial_size] = perm.reshape((channels, initial_size, initial_size))\n    for i in range(initial_size, img_size, stride):\n        num_elems = channels * (2 * stride * i + stride * stride)\n        perm = np.random.permutation(num_elems) + total_elems\n        num_first = channels * stride * (stride + i)\n        order[:, :i + stride, i:i + stride] = perm[:num_first].reshape((channels, -1, stride))\n        order[:, i:i + stride, :i] = perm[num_first:].reshape((channels, stride, -1))\n        total_elems += num_elems\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
            "def _block_order(self, img_size, channels, initial_size=2, stride=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Defines a block order, starting with top-left (initial_size x initial_size) submatrix\\n        expanding by stride rows and columns whenever exhausted\\n        randomized within the block and across channels.\\n        e.g. (initial_size=2, stride=1)\\n        [1, 3, 6]\\n        [2, 4, 9]\\n        [5, 7, 8]\\n\\n        :param img_size: image size (i.e., width or height).\\n        :param channels: the number of channels.\\n        :param initial size: initial size for submatrix.\\n        :param stride: stride size for expansion.\\n\\n        :return order: An array holding the block order of DCT attacks.\\n        '\n    order = np.zeros((channels, img_size, img_size)).astype(ART_NUMPY_DTYPE)\n    total_elems = channels * initial_size * initial_size\n    perm = np.random.permutation(total_elems)\n    order[:, :initial_size, :initial_size] = perm.reshape((channels, initial_size, initial_size))\n    for i in range(initial_size, img_size, stride):\n        num_elems = channels * (2 * stride * i + stride * stride)\n        perm = np.random.permutation(num_elems) + total_elems\n        num_first = channels * stride * (stride + i)\n        order[:, :i + stride, i:i + stride] = perm[:num_first].reshape((channels, -1, stride))\n        order[:, i:i + stride, :i] = perm[num_first:].reshape((channels, stride, -1))\n        total_elems += num_elems\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
            "def _block_order(self, img_size, channels, initial_size=2, stride=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Defines a block order, starting with top-left (initial_size x initial_size) submatrix\\n        expanding by stride rows and columns whenever exhausted\\n        randomized within the block and across channels.\\n        e.g. (initial_size=2, stride=1)\\n        [1, 3, 6]\\n        [2, 4, 9]\\n        [5, 7, 8]\\n\\n        :param img_size: image size (i.e., width or height).\\n        :param channels: the number of channels.\\n        :param initial size: initial size for submatrix.\\n        :param stride: stride size for expansion.\\n\\n        :return order: An array holding the block order of DCT attacks.\\n        '\n    order = np.zeros((channels, img_size, img_size)).astype(ART_NUMPY_DTYPE)\n    total_elems = channels * initial_size * initial_size\n    perm = np.random.permutation(total_elems)\n    order[:, :initial_size, :initial_size] = perm.reshape((channels, initial_size, initial_size))\n    for i in range(initial_size, img_size, stride):\n        num_elems = channels * (2 * stride * i + stride * stride)\n        perm = np.random.permutation(num_elems) + total_elems\n        num_first = channels * stride * (stride + i)\n        order[:, :i + stride, i:i + stride] = perm[:num_first].reshape((channels, -1, stride))\n        order[:, i:i + stride, :i] = perm[num_first:].reshape((channels, stride, -1))\n        total_elems += num_elems\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
            "def _block_order(self, img_size, channels, initial_size=2, stride=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Defines a block order, starting with top-left (initial_size x initial_size) submatrix\\n        expanding by stride rows and columns whenever exhausted\\n        randomized within the block and across channels.\\n        e.g. (initial_size=2, stride=1)\\n        [1, 3, 6]\\n        [2, 4, 9]\\n        [5, 7, 8]\\n\\n        :param img_size: image size (i.e., width or height).\\n        :param channels: the number of channels.\\n        :param initial size: initial size for submatrix.\\n        :param stride: stride size for expansion.\\n\\n        :return order: An array holding the block order of DCT attacks.\\n        '\n    order = np.zeros((channels, img_size, img_size)).astype(ART_NUMPY_DTYPE)\n    total_elems = channels * initial_size * initial_size\n    perm = np.random.permutation(total_elems)\n    order[:, :initial_size, :initial_size] = perm.reshape((channels, initial_size, initial_size))\n    for i in range(initial_size, img_size, stride):\n        num_elems = channels * (2 * stride * i + stride * stride)\n        perm = np.random.permutation(num_elems) + total_elems\n        num_first = channels * stride * (stride + i)\n        order[:, :i + stride, i:i + stride] = perm[:num_first].reshape((channels, -1, stride))\n        order[:, i:i + stride, :i] = perm[num_first:].reshape((channels, stride, -1))\n        total_elems += num_elems\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
            "def _block_order(self, img_size, channels, initial_size=2, stride=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Defines a block order, starting with top-left (initial_size x initial_size) submatrix\\n        expanding by stride rows and columns whenever exhausted\\n        randomized within the block and across channels.\\n        e.g. (initial_size=2, stride=1)\\n        [1, 3, 6]\\n        [2, 4, 9]\\n        [5, 7, 8]\\n\\n        :param img_size: image size (i.e., width or height).\\n        :param channels: the number of channels.\\n        :param initial size: initial size for submatrix.\\n        :param stride: stride size for expansion.\\n\\n        :return order: An array holding the block order of DCT attacks.\\n        '\n    order = np.zeros((channels, img_size, img_size)).astype(ART_NUMPY_DTYPE)\n    total_elems = channels * initial_size * initial_size\n    perm = np.random.permutation(total_elems)\n    order[:, :initial_size, :initial_size] = perm.reshape((channels, initial_size, initial_size))\n    for i in range(initial_size, img_size, stride):\n        num_elems = channels * (2 * stride * i + stride * stride)\n        perm = np.random.permutation(num_elems) + total_elems\n        num_first = channels * stride * (stride + i)\n        order[:, :i + stride, i:i + stride] = perm[:num_first].reshape((channels, -1, stride))\n        order[:, i:i + stride, :i] = perm[num_first:].reshape((channels, stride, -1))\n        total_elems += num_elems\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()"
        ]
    },
    {
        "func_name": "_block_idct",
        "original": "def _block_idct(self, x, block_size=8, masked=False, ratio=0.5):\n    \"\"\"\n        Applies IDCT to each block of size block_size.\n\n        :param x: An array with the inputs to be attacked.\n        :param block_size: block size for DCT attacks.\n        :param masked: use the mask.\n        :param ratio: Ratio of the lowest frequency directions in order to make the adversarial perturbation in the low\n                      frequency space.\n\n        :return var_z: An array holding the order of DCT attacks.\n        \"\"\"\n    if not self.estimator.channels_first:\n        x = x.transpose(0, 3, 1, 2)\n    var_z = np.zeros(x.shape).astype(ART_NUMPY_DTYPE)\n    num_blocks = int(x.shape[2] / block_size)\n    mask = np.zeros((x.shape[0], x.shape[1], block_size, block_size))\n    if not isinstance(ratio, float):\n        for i in range(x.shape[0]):\n            mask[i, :, :int(block_size * ratio[i]), :int(block_size * ratio[i])] = 1\n    else:\n        mask[:, :, :int(block_size * ratio), :int(block_size * ratio)] = 1\n    for i in range(num_blocks):\n        for j in range(num_blocks):\n            submat = x[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size]\n            if masked:\n                submat = submat * mask\n            var_z[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size] = idct(idct(submat, axis=3, norm='ortho'), axis=2, norm='ortho')\n    if self.estimator.channels_first:\n        return var_z\n    return var_z.transpose((0, 2, 3, 1))",
        "mutated": [
            "def _block_idct(self, x, block_size=8, masked=False, ratio=0.5):\n    if False:\n        i = 10\n    '\\n        Applies IDCT to each block of size block_size.\\n\\n        :param x: An array with the inputs to be attacked.\\n        :param block_size: block size for DCT attacks.\\n        :param masked: use the mask.\\n        :param ratio: Ratio of the lowest frequency directions in order to make the adversarial perturbation in the low\\n                      frequency space.\\n\\n        :return var_z: An array holding the order of DCT attacks.\\n        '\n    if not self.estimator.channels_first:\n        x = x.transpose(0, 3, 1, 2)\n    var_z = np.zeros(x.shape).astype(ART_NUMPY_DTYPE)\n    num_blocks = int(x.shape[2] / block_size)\n    mask = np.zeros((x.shape[0], x.shape[1], block_size, block_size))\n    if not isinstance(ratio, float):\n        for i in range(x.shape[0]):\n            mask[i, :, :int(block_size * ratio[i]), :int(block_size * ratio[i])] = 1\n    else:\n        mask[:, :, :int(block_size * ratio), :int(block_size * ratio)] = 1\n    for i in range(num_blocks):\n        for j in range(num_blocks):\n            submat = x[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size]\n            if masked:\n                submat = submat * mask\n            var_z[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size] = idct(idct(submat, axis=3, norm='ortho'), axis=2, norm='ortho')\n    if self.estimator.channels_first:\n        return var_z\n    return var_z.transpose((0, 2, 3, 1))",
            "def _block_idct(self, x, block_size=8, masked=False, ratio=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Applies IDCT to each block of size block_size.\\n\\n        :param x: An array with the inputs to be attacked.\\n        :param block_size: block size for DCT attacks.\\n        :param masked: use the mask.\\n        :param ratio: Ratio of the lowest frequency directions in order to make the adversarial perturbation in the low\\n                      frequency space.\\n\\n        :return var_z: An array holding the order of DCT attacks.\\n        '\n    if not self.estimator.channels_first:\n        x = x.transpose(0, 3, 1, 2)\n    var_z = np.zeros(x.shape).astype(ART_NUMPY_DTYPE)\n    num_blocks = int(x.shape[2] / block_size)\n    mask = np.zeros((x.shape[0], x.shape[1], block_size, block_size))\n    if not isinstance(ratio, float):\n        for i in range(x.shape[0]):\n            mask[i, :, :int(block_size * ratio[i]), :int(block_size * ratio[i])] = 1\n    else:\n        mask[:, :, :int(block_size * ratio), :int(block_size * ratio)] = 1\n    for i in range(num_blocks):\n        for j in range(num_blocks):\n            submat = x[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size]\n            if masked:\n                submat = submat * mask\n            var_z[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size] = idct(idct(submat, axis=3, norm='ortho'), axis=2, norm='ortho')\n    if self.estimator.channels_first:\n        return var_z\n    return var_z.transpose((0, 2, 3, 1))",
            "def _block_idct(self, x, block_size=8, masked=False, ratio=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Applies IDCT to each block of size block_size.\\n\\n        :param x: An array with the inputs to be attacked.\\n        :param block_size: block size for DCT attacks.\\n        :param masked: use the mask.\\n        :param ratio: Ratio of the lowest frequency directions in order to make the adversarial perturbation in the low\\n                      frequency space.\\n\\n        :return var_z: An array holding the order of DCT attacks.\\n        '\n    if not self.estimator.channels_first:\n        x = x.transpose(0, 3, 1, 2)\n    var_z = np.zeros(x.shape).astype(ART_NUMPY_DTYPE)\n    num_blocks = int(x.shape[2] / block_size)\n    mask = np.zeros((x.shape[0], x.shape[1], block_size, block_size))\n    if not isinstance(ratio, float):\n        for i in range(x.shape[0]):\n            mask[i, :, :int(block_size * ratio[i]), :int(block_size * ratio[i])] = 1\n    else:\n        mask[:, :, :int(block_size * ratio), :int(block_size * ratio)] = 1\n    for i in range(num_blocks):\n        for j in range(num_blocks):\n            submat = x[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size]\n            if masked:\n                submat = submat * mask\n            var_z[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size] = idct(idct(submat, axis=3, norm='ortho'), axis=2, norm='ortho')\n    if self.estimator.channels_first:\n        return var_z\n    return var_z.transpose((0, 2, 3, 1))",
            "def _block_idct(self, x, block_size=8, masked=False, ratio=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Applies IDCT to each block of size block_size.\\n\\n        :param x: An array with the inputs to be attacked.\\n        :param block_size: block size for DCT attacks.\\n        :param masked: use the mask.\\n        :param ratio: Ratio of the lowest frequency directions in order to make the adversarial perturbation in the low\\n                      frequency space.\\n\\n        :return var_z: An array holding the order of DCT attacks.\\n        '\n    if not self.estimator.channels_first:\n        x = x.transpose(0, 3, 1, 2)\n    var_z = np.zeros(x.shape).astype(ART_NUMPY_DTYPE)\n    num_blocks = int(x.shape[2] / block_size)\n    mask = np.zeros((x.shape[0], x.shape[1], block_size, block_size))\n    if not isinstance(ratio, float):\n        for i in range(x.shape[0]):\n            mask[i, :, :int(block_size * ratio[i]), :int(block_size * ratio[i])] = 1\n    else:\n        mask[:, :, :int(block_size * ratio), :int(block_size * ratio)] = 1\n    for i in range(num_blocks):\n        for j in range(num_blocks):\n            submat = x[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size]\n            if masked:\n                submat = submat * mask\n            var_z[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size] = idct(idct(submat, axis=3, norm='ortho'), axis=2, norm='ortho')\n    if self.estimator.channels_first:\n        return var_z\n    return var_z.transpose((0, 2, 3, 1))",
            "def _block_idct(self, x, block_size=8, masked=False, ratio=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Applies IDCT to each block of size block_size.\\n\\n        :param x: An array with the inputs to be attacked.\\n        :param block_size: block size for DCT attacks.\\n        :param masked: use the mask.\\n        :param ratio: Ratio of the lowest frequency directions in order to make the adversarial perturbation in the low\\n                      frequency space.\\n\\n        :return var_z: An array holding the order of DCT attacks.\\n        '\n    if not self.estimator.channels_first:\n        x = x.transpose(0, 3, 1, 2)\n    var_z = np.zeros(x.shape).astype(ART_NUMPY_DTYPE)\n    num_blocks = int(x.shape[2] / block_size)\n    mask = np.zeros((x.shape[0], x.shape[1], block_size, block_size))\n    if not isinstance(ratio, float):\n        for i in range(x.shape[0]):\n            mask[i, :, :int(block_size * ratio[i]), :int(block_size * ratio[i])] = 1\n    else:\n        mask[:, :, :int(block_size * ratio), :int(block_size * ratio)] = 1\n    for i in range(num_blocks):\n        for j in range(num_blocks):\n            submat = x[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size]\n            if masked:\n                submat = submat * mask\n            var_z[:, :, i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size] = idct(idct(submat, axis=3, norm='ortho'), axis=2, norm='ortho')\n    if self.estimator.channels_first:\n        return var_z\n    return var_z.transpose((0, 2, 3, 1))"
        ]
    },
    {
        "func_name": "diagonal_order",
        "original": "def diagonal_order(self, image_size, channels):\n    \"\"\"\n        Defines a diagonal order for pixel attacks.\n        order is fixed across diagonals but are randomized across channels and within the diagonal\n        e.g.\n        [1, 2, 5]\n        [3, 4, 8]\n        [6, 7, 9]\n\n        :param image_size: image size (i.e., width or height)\n        :param channels: the number of channels\n\n        :return order: An array holding the diagonal order of pixel attacks.\n        \"\"\"\n    x = np.arange(0, image_size).cumsum()\n    order = np.zeros((image_size, image_size)).astype(ART_NUMPY_DTYPE)\n    for i in range(image_size):\n        order[i, :image_size - i] = i + x[i:]\n    for i in range(1, image_size):\n        reverse = order[image_size - i - 1].take([i for i in range(i - 1, -1, -1)])\n        order[i, image_size - i:] = image_size * image_size - 1 - reverse\n    if channels > 1:\n        order_2d = order\n        order = np.zeros((channels, image_size, image_size))\n        for i in range(channels):\n            order[i, :, :] = 3 * order_2d + i\n    elif channels == 1:\n        order = np.expand_dims(order, axis=0)\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
        "mutated": [
            "def diagonal_order(self, image_size, channels):\n    if False:\n        i = 10\n    '\\n        Defines a diagonal order for pixel attacks.\\n        order is fixed across diagonals but are randomized across channels and within the diagonal\\n        e.g.\\n        [1, 2, 5]\\n        [3, 4, 8]\\n        [6, 7, 9]\\n\\n        :param image_size: image size (i.e., width or height)\\n        :param channels: the number of channels\\n\\n        :return order: An array holding the diagonal order of pixel attacks.\\n        '\n    x = np.arange(0, image_size).cumsum()\n    order = np.zeros((image_size, image_size)).astype(ART_NUMPY_DTYPE)\n    for i in range(image_size):\n        order[i, :image_size - i] = i + x[i:]\n    for i in range(1, image_size):\n        reverse = order[image_size - i - 1].take([i for i in range(i - 1, -1, -1)])\n        order[i, image_size - i:] = image_size * image_size - 1 - reverse\n    if channels > 1:\n        order_2d = order\n        order = np.zeros((channels, image_size, image_size))\n        for i in range(channels):\n            order[i, :, :] = 3 * order_2d + i\n    elif channels == 1:\n        order = np.expand_dims(order, axis=0)\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
            "def diagonal_order(self, image_size, channels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Defines a diagonal order for pixel attacks.\\n        order is fixed across diagonals but are randomized across channels and within the diagonal\\n        e.g.\\n        [1, 2, 5]\\n        [3, 4, 8]\\n        [6, 7, 9]\\n\\n        :param image_size: image size (i.e., width or height)\\n        :param channels: the number of channels\\n\\n        :return order: An array holding the diagonal order of pixel attacks.\\n        '\n    x = np.arange(0, image_size).cumsum()\n    order = np.zeros((image_size, image_size)).astype(ART_NUMPY_DTYPE)\n    for i in range(image_size):\n        order[i, :image_size - i] = i + x[i:]\n    for i in range(1, image_size):\n        reverse = order[image_size - i - 1].take([i for i in range(i - 1, -1, -1)])\n        order[i, image_size - i:] = image_size * image_size - 1 - reverse\n    if channels > 1:\n        order_2d = order\n        order = np.zeros((channels, image_size, image_size))\n        for i in range(channels):\n            order[i, :, :] = 3 * order_2d + i\n    elif channels == 1:\n        order = np.expand_dims(order, axis=0)\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
            "def diagonal_order(self, image_size, channels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Defines a diagonal order for pixel attacks.\\n        order is fixed across diagonals but are randomized across channels and within the diagonal\\n        e.g.\\n        [1, 2, 5]\\n        [3, 4, 8]\\n        [6, 7, 9]\\n\\n        :param image_size: image size (i.e., width or height)\\n        :param channels: the number of channels\\n\\n        :return order: An array holding the diagonal order of pixel attacks.\\n        '\n    x = np.arange(0, image_size).cumsum()\n    order = np.zeros((image_size, image_size)).astype(ART_NUMPY_DTYPE)\n    for i in range(image_size):\n        order[i, :image_size - i] = i + x[i:]\n    for i in range(1, image_size):\n        reverse = order[image_size - i - 1].take([i for i in range(i - 1, -1, -1)])\n        order[i, image_size - i:] = image_size * image_size - 1 - reverse\n    if channels > 1:\n        order_2d = order\n        order = np.zeros((channels, image_size, image_size))\n        for i in range(channels):\n            order[i, :, :] = 3 * order_2d + i\n    elif channels == 1:\n        order = np.expand_dims(order, axis=0)\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
            "def diagonal_order(self, image_size, channels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Defines a diagonal order for pixel attacks.\\n        order is fixed across diagonals but are randomized across channels and within the diagonal\\n        e.g.\\n        [1, 2, 5]\\n        [3, 4, 8]\\n        [6, 7, 9]\\n\\n        :param image_size: image size (i.e., width or height)\\n        :param channels: the number of channels\\n\\n        :return order: An array holding the diagonal order of pixel attacks.\\n        '\n    x = np.arange(0, image_size).cumsum()\n    order = np.zeros((image_size, image_size)).astype(ART_NUMPY_DTYPE)\n    for i in range(image_size):\n        order[i, :image_size - i] = i + x[i:]\n    for i in range(1, image_size):\n        reverse = order[image_size - i - 1].take([i for i in range(i - 1, -1, -1)])\n        order[i, image_size - i:] = image_size * image_size - 1 - reverse\n    if channels > 1:\n        order_2d = order\n        order = np.zeros((channels, image_size, image_size))\n        for i in range(channels):\n            order[i, :, :] = 3 * order_2d + i\n    elif channels == 1:\n        order = np.expand_dims(order, axis=0)\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()",
            "def diagonal_order(self, image_size, channels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Defines a diagonal order for pixel attacks.\\n        order is fixed across diagonals but are randomized across channels and within the diagonal\\n        e.g.\\n        [1, 2, 5]\\n        [3, 4, 8]\\n        [6, 7, 9]\\n\\n        :param image_size: image size (i.e., width or height)\\n        :param channels: the number of channels\\n\\n        :return order: An array holding the diagonal order of pixel attacks.\\n        '\n    x = np.arange(0, image_size).cumsum()\n    order = np.zeros((image_size, image_size)).astype(ART_NUMPY_DTYPE)\n    for i in range(image_size):\n        order[i, :image_size - i] = i + x[i:]\n    for i in range(1, image_size):\n        reverse = order[image_size - i - 1].take([i for i in range(i - 1, -1, -1)])\n        order[i, image_size - i:] = image_size * image_size - 1 - reverse\n    if channels > 1:\n        order_2d = order\n        order = np.zeros((channels, image_size, image_size))\n        for i in range(channels):\n            order[i, :, :] = 3 * order_2d + i\n    elif channels == 1:\n        order = np.expand_dims(order, axis=0)\n    if self.estimator.channels_first:\n        return order.reshape(1, -1).squeeze().argsort()\n    return order.transpose((1, 2, 0)).reshape(1, -1).squeeze().argsort()"
        ]
    }
]