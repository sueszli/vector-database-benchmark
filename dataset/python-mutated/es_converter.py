from typing import Dict, Optional, List, Union
from tqdm import tqdm
from haystack.schema import Document
from haystack.document_stores.base import BaseDocumentStore
from haystack.document_stores.filter_utils import LogicalFilterClause
from haystack.nodes.preprocessor.preprocessor import PreProcessor
from haystack.lazy_imports import LazyImport
with LazyImport("Run 'pip install farm-haystack[elasticsearch]'") as es_import:
    from elasticsearch.helpers import scan

def open_search_index_to_document_store(document_store: BaseDocumentStore, original_index_name: str, original_content_field: str, original_name_field: Optional[str]=None, included_metadata_fields: Optional[List[str]]=None, excluded_metadata_fields: Optional[List[str]]=None, store_original_ids: bool=True, index: Optional[str]=None, preprocessor: Optional[PreProcessor]=None, id_hash_keys: Optional[List[str]]=None, batch_size: int=10000, host: Union[str, List[str]]='localhost', port: Union[int, List[int]]=9200, username: str='admin', password: str='admin', api_key_id: Optional[str]=None, api_key: Optional[str]=None, aws4auth=None, scheme: str='https', ca_certs: Optional[str]=None, verify_certs: bool=False, timeout: int=30, use_system_proxy: bool=False) -> BaseDocumentStore:
    if False:
        i = 10
        return i + 15
    '\n    This function provides brownfield support of existing OpenSearch indexes by converting each of the records in\n    the provided index to haystack `Document` objects and writing them to the specified `DocumentStore`. It can be used\n    on a regular basis in order to add new records of the OpenSearch index to the `DocumentStore`.\n\n    :param document_store: The haystack `DocumentStore` to write the converted `Document` objects to.\n    :param original_index_name: OpenSearch index containing the records to be converted.\n    :param original_content_field: OpenSearch field containing the text to be put in the `content` field of the\n        resulting haystack `Document` objects.\n    :param original_name_field: Optional OpenSearch field containing the title of the Document.\n    :param included_metadata_fields: List of OpenSearch fields that shall be stored in the `meta` field of the\n        resulting haystack `Document` objects. If `included_metadata_fields` and `excluded_metadata_fields` are `None`,\n        all the fields found in the OpenSearch records will be kept as metadata. You can specify only one of the\n        `included_metadata_fields` and `excluded_metadata_fields` parameters.\n    :param excluded_metadata_fields: List of OpenSearch fields that shall be excluded from the `meta` field of the\n        resulting haystack `Document` objects. If `included_metadata_fields` and `excluded_metadata_fields` are `None`,\n        all the fields found in the OpenSearch records will be kept as metadata. You can specify only one of the\n        `included_metadata_fields` and `excluded_metadata_fields` parameters.\n    :param store_original_ids: Whether to store the ID a record had in the original OpenSearch index at the\n        `"_original_es_id"` metadata field of the resulting haystack `Document` objects. This should be set to `True`\n        if you want to continuously update the `DocumentStore` with new records inside your OpenSearch index. If this\n        parameter was set to `False` on the first call of `open_search_index_to_document_store`,\n        all the indexed Documents in the `DocumentStore` will be overwritten in the second call.\n    :param index: Name of index in `document_store` to use to store the resulting haystack `Document` objects.\n    :param preprocessor: Optional PreProcessor that will be applied on the content field of the original OpenSearch\n        record.\n    :param id_hash_keys: Generate the document id from a custom list of strings that refer to the document\'s\n        attributes. If you want to ensure you don\'t have duplicate documents in your DocumentStore but texts are\n        not unique, you can modify the metadata and pass e.g. `"meta"` to this field (e.g. [`"content"`, `"meta"`]).\n        In this case the id will be generated by using the content and the defined metadata.\n    :param batch_size: Number of records to process at once.\n    :param host: URL(s) of OpenSearch nodes.\n    :param port: Ports(s) of OpenSearch nodes.\n    :param username: Username (standard authentication via http_auth).\n    :param password: Password (standard authentication via http_auth).\n    :param api_key_id: ID of the API key (alternative authentication mode to the above http_auth).\n    :param api_key: Secret value of the API key (alternative authentication mode to the above http_auth).\n    :param aws4auth: Authentication for usage with AWS OpenSearch\n        (can be generated with the requests-aws4auth package).\n    :param scheme: `"https"` or `"http"`, protocol used to connect to your OpenSearch instance.\n    :param ca_certs: Root certificates for SSL: it is a path to certificate authority (CA) certs on disk.\n        You can use certifi package with `certifi.where()` to find where the CA certs file is located in your machine.\n    :param verify_certs: Whether to be strict about ca certificates.\n    :param timeout: Number of seconds after which an OpenSearch request times out.\n    :param use_system_proxy: Whether to use system proxy.\n    '
    return elasticsearch_index_to_document_store(document_store=document_store, original_index_name=original_index_name, original_content_field=original_content_field, original_name_field=original_name_field, included_metadata_fields=included_metadata_fields, excluded_metadata_fields=excluded_metadata_fields, store_original_ids=store_original_ids, index=index, preprocessor=preprocessor, id_hash_keys=id_hash_keys, batch_size=batch_size, host=host, port=port, username=username, password=password, api_key_id=api_key_id, api_key=api_key, aws4auth=aws4auth, scheme=scheme, ca_certs=ca_certs, verify_certs=verify_certs, timeout=timeout, use_system_proxy=use_system_proxy)

def elasticsearch_index_to_document_store(document_store: BaseDocumentStore, original_index_name: str, original_content_field: str, original_name_field: Optional[str]=None, included_metadata_fields: Optional[List[str]]=None, excluded_metadata_fields: Optional[List[str]]=None, store_original_ids: bool=True, index: Optional[str]=None, preprocessor: Optional[PreProcessor]=None, id_hash_keys: Optional[List[str]]=None, batch_size: int=10000, host: Union[str, List[str]]='localhost', port: Union[int, List[int]]=9200, username: str='', password: str='', api_key_id: Optional[str]=None, api_key: Optional[str]=None, aws4auth=None, scheme: str='http', ca_certs: Optional[str]=None, verify_certs: bool=True, timeout: int=30, use_system_proxy: bool=False) -> BaseDocumentStore:
    if False:
        return 10
    '\n    This function provides brownfield support of existing Elasticsearch indexes by converting each of the records in\n    the provided index to haystack `Document` objects and writing them to the specified `DocumentStore`. It can be used\n    on a regular basis in order to add new records of the Elasticsearch index to the `DocumentStore`.\n\n    :param document_store: The haystack `DocumentStore` to write the converted `Document` objects to.\n    :param original_index_name: Elasticsearch index containing the records to be converted.\n    :param original_content_field: Elasticsearch field containing the text to be put in the `content` field of the\n        resulting haystack `Document` objects.\n    :param original_name_field: Optional Elasticsearch field containing the title of the Document.\n    :param included_metadata_fields: List of Elasticsearch fields that shall be stored in the `meta` field of the\n        resulting haystack `Document` objects. If `included_metadata_fields` and `excluded_metadata_fields` are `None`,\n        all the fields found in the Elasticsearch records will be kept as metadata. You can specify only one of the\n        `included_metadata_fields` and `excluded_metadata_fields` parameters.\n    :param excluded_metadata_fields: List of Elasticsearch fields that shall be excluded from the `meta` field of the\n        resulting haystack `Document` objects. If `included_metadata_fields` and `excluded_metadata_fields` are `None`,\n        all the fields found in the Elasticsearch records will be kept as metadata. You can specify only one of the\n        `included_metadata_fields` and `excluded_metadata_fields` parameters.\n    :param store_original_ids: Whether to store the ID a record had in the original Elasticsearch index at the\n        `"_original_es_id"` metadata field of the resulting haystack `Document` objects. This should be set to `True`\n        if you want to continuously update the `DocumentStore` with new records inside your Elasticsearch index. If this\n        parameter was set to `False` on the first call of `elasticsearch_index_to_document_store`,\n        all the indexed Documents in the `DocumentStore` will be overwritten in the second call.\n    :param index: Name of index in `document_store` to use to store the resulting haystack `Document` objects.\n    :param preprocessor: Optional PreProcessor that will be applied on the content field of the original Elasticsearch\n        record.\n    :param id_hash_keys: Generate the document id from a custom list of strings that refer to the document\'s\n        attributes. If you want to ensure you don\'t have duplicate documents in your DocumentStore but texts are\n        not unique, you can modify the metadata and pass e.g. `"meta"` to this field (e.g. [`"content"`, `"meta"`]).\n        In this case the id will be generated by using the content and the defined metadata.\n    :param batch_size: Number of records to process at once.\n    :param host: URL(s) of Elasticsearch nodes.\n    :param port: Ports(s) of Elasticsearch nodes.\n    :param username: Username (standard authentication via http_auth).\n    :param password: Password (standard authentication via http_auth).\n    :param api_key_id: ID of the API key (alternative authentication mode to the above http_auth).\n    :param api_key: Secret value of the API key (alternative authentication mode to the above http_auth).\n    :param aws4auth: Authentication for usage with AWS Elasticsearch\n        (can be generated with the requests-aws4auth package).\n    :param scheme: `"https"` or `"http"`, protocol used to connect to your Elasticsearch instance.\n    :param ca_certs: Root certificates for SSL: it is a path to certificate authority (CA) certs on disk.\n        You can use certifi package with `certifi.where()` to find where the CA certs file is located in your machine.\n    :param verify_certs: Whether to be strict about ca certificates.\n    :param timeout: Number of seconds after which an Elasticsearch request times out.\n    :param use_system_proxy: Whether to use system proxy.\n    '
    es_import.check()
    from haystack.document_stores.elasticsearch import ElasticsearchDocumentStore
    es_client = ElasticsearchDocumentStore._init_elastic_client(host=host, port=port, username=username, password=password, api_key=api_key, api_key_id=api_key_id, aws4auth=aws4auth, scheme=scheme, ca_certs=ca_certs, verify_certs=verify_certs, timeout=timeout, use_system_proxy=use_system_proxy)
    existing_ids = [doc.meta['_original_es_id'] for doc in document_store.get_all_documents_generator(index=index) if '_original_es_id' in doc.meta]
    query: Dict[str, Dict] = {'query': {'bool': {'must': [{'match_all': {}}]}}}
    if existing_ids:
        filters = LogicalFilterClause.parse({'_id': {'$nin': existing_ids}}).convert_to_elasticsearch()
        query['query']['bool']['filter'] = filters
    records = scan(client=es_client, query=query, index=original_index_name)
    number_of_records = es_client.count(index=original_index_name, body=query)['count']
    haystack_documents: List[Document] = []
    for (idx, record) in enumerate(tqdm(records, total=number_of_records, desc='Converting ES Records')):
        if (idx + 1) % batch_size == 0:
            document_store.write_documents(haystack_documents, index=index)
            haystack_documents = []
        content = record['_source'].pop(original_content_field, '')
        if content:
            meta = {}
            if original_name_field is not None and original_name_field in record['_source']:
                meta['name'] = record['_source'].pop(original_name_field)
            if included_metadata_fields is not None:
                for metadata_field in included_metadata_fields:
                    if metadata_field in record['_source']:
                        meta[metadata_field] = record['_source'][metadata_field]
            else:
                if excluded_metadata_fields is not None:
                    for metadata_field in excluded_metadata_fields:
                        record['_source'].pop(metadata_field, None)
                meta.update(record['_source'])
            if store_original_ids:
                meta['_original_es_id'] = record['_id']
            record_doc = Document(content=content, meta=meta, id_hash_keys=id_hash_keys)
            preprocessed_docs = [record_doc]
            if preprocessor is not None:
                preprocessed_docs = preprocessor.process(record_doc, id_hash_keys=id_hash_keys)
            haystack_documents.extend(preprocessed_docs)
    if haystack_documents:
        document_store.write_documents(haystack_documents, index=index)
    return document_store