[
    {
        "func_name": "__new__",
        "original": "def __new__(cls, minutes_late_by_key_str: Mapping[str, Optional[float]]):\n    return super(FreshnessPolicySensorCursor, cls).__new__(cls, minutes_late_by_key_str=check.mapping_param(minutes_late_by_key_str, 'minutes_late_by_key_str', key_type=str))",
        "mutated": [
            "def __new__(cls, minutes_late_by_key_str: Mapping[str, Optional[float]]):\n    if False:\n        i = 10\n    return super(FreshnessPolicySensorCursor, cls).__new__(cls, minutes_late_by_key_str=check.mapping_param(minutes_late_by_key_str, 'minutes_late_by_key_str', key_type=str))",
            "def __new__(cls, minutes_late_by_key_str: Mapping[str, Optional[float]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return super(FreshnessPolicySensorCursor, cls).__new__(cls, minutes_late_by_key_str=check.mapping_param(minutes_late_by_key_str, 'minutes_late_by_key_str', key_type=str))",
            "def __new__(cls, minutes_late_by_key_str: Mapping[str, Optional[float]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return super(FreshnessPolicySensorCursor, cls).__new__(cls, minutes_late_by_key_str=check.mapping_param(minutes_late_by_key_str, 'minutes_late_by_key_str', key_type=str))",
            "def __new__(cls, minutes_late_by_key_str: Mapping[str, Optional[float]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return super(FreshnessPolicySensorCursor, cls).__new__(cls, minutes_late_by_key_str=check.mapping_param(minutes_late_by_key_str, 'minutes_late_by_key_str', key_type=str))",
            "def __new__(cls, minutes_late_by_key_str: Mapping[str, Optional[float]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return super(FreshnessPolicySensorCursor, cls).__new__(cls, minutes_late_by_key_str=check.mapping_param(minutes_late_by_key_str, 'minutes_late_by_key_str', key_type=str))"
        ]
    },
    {
        "func_name": "is_valid",
        "original": "@staticmethod\ndef is_valid(json_str: str) -> bool:\n    try:\n        deserialize_value(json_str, FreshnessPolicySensorCursor)\n        return True\n    except (JSONDecodeError, DeserializationError):\n        return False",
        "mutated": [
            "@staticmethod\ndef is_valid(json_str: str) -> bool:\n    if False:\n        i = 10\n    try:\n        deserialize_value(json_str, FreshnessPolicySensorCursor)\n        return True\n    except (JSONDecodeError, DeserializationError):\n        return False",
            "@staticmethod\ndef is_valid(json_str: str) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        deserialize_value(json_str, FreshnessPolicySensorCursor)\n        return True\n    except (JSONDecodeError, DeserializationError):\n        return False",
            "@staticmethod\ndef is_valid(json_str: str) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        deserialize_value(json_str, FreshnessPolicySensorCursor)\n        return True\n    except (JSONDecodeError, DeserializationError):\n        return False",
            "@staticmethod\ndef is_valid(json_str: str) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        deserialize_value(json_str, FreshnessPolicySensorCursor)\n        return True\n    except (JSONDecodeError, DeserializationError):\n        return False",
            "@staticmethod\ndef is_valid(json_str: str) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        deserialize_value(json_str, FreshnessPolicySensorCursor)\n        return True\n    except (JSONDecodeError, DeserializationError):\n        return False"
        ]
    },
    {
        "func_name": "from_dict",
        "original": "@staticmethod\ndef from_dict(minutes_late_by_key: Mapping[AssetKey, Optional[float]]) -> 'FreshnessPolicySensorCursor':\n    return FreshnessPolicySensorCursor(minutes_late_by_key_str={k.to_user_string(): v for (k, v) in minutes_late_by_key.items()})",
        "mutated": [
            "@staticmethod\ndef from_dict(minutes_late_by_key: Mapping[AssetKey, Optional[float]]) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n    return FreshnessPolicySensorCursor(minutes_late_by_key_str={k.to_user_string(): v for (k, v) in minutes_late_by_key.items()})",
            "@staticmethod\ndef from_dict(minutes_late_by_key: Mapping[AssetKey, Optional[float]]) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return FreshnessPolicySensorCursor(minutes_late_by_key_str={k.to_user_string(): v for (k, v) in minutes_late_by_key.items()})",
            "@staticmethod\ndef from_dict(minutes_late_by_key: Mapping[AssetKey, Optional[float]]) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return FreshnessPolicySensorCursor(minutes_late_by_key_str={k.to_user_string(): v for (k, v) in minutes_late_by_key.items()})",
            "@staticmethod\ndef from_dict(minutes_late_by_key: Mapping[AssetKey, Optional[float]]) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return FreshnessPolicySensorCursor(minutes_late_by_key_str={k.to_user_string(): v for (k, v) in minutes_late_by_key.items()})",
            "@staticmethod\ndef from_dict(minutes_late_by_key: Mapping[AssetKey, Optional[float]]) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return FreshnessPolicySensorCursor(minutes_late_by_key_str={k.to_user_string(): v for (k, v) in minutes_late_by_key.items()})"
        ]
    },
    {
        "func_name": "minutes_late_by_key",
        "original": "@property\ndef minutes_late_by_key(self) -> Mapping[AssetKey, Optional[float]]:\n    return {AssetKey.from_user_string(k): v for (k, v) in self.minutes_late_by_key_str.items()}",
        "mutated": [
            "@property\ndef minutes_late_by_key(self) -> Mapping[AssetKey, Optional[float]]:\n    if False:\n        i = 10\n    return {AssetKey.from_user_string(k): v for (k, v) in self.minutes_late_by_key_str.items()}",
            "@property\ndef minutes_late_by_key(self) -> Mapping[AssetKey, Optional[float]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return {AssetKey.from_user_string(k): v for (k, v) in self.minutes_late_by_key_str.items()}",
            "@property\ndef minutes_late_by_key(self) -> Mapping[AssetKey, Optional[float]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return {AssetKey.from_user_string(k): v for (k, v) in self.minutes_late_by_key_str.items()}",
            "@property\ndef minutes_late_by_key(self) -> Mapping[AssetKey, Optional[float]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return {AssetKey.from_user_string(k): v for (k, v) in self.minutes_late_by_key_str.items()}",
            "@property\ndef minutes_late_by_key(self) -> Mapping[AssetKey, Optional[float]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return {AssetKey.from_user_string(k): v for (k, v) in self.minutes_late_by_key_str.items()}"
        ]
    },
    {
        "func_name": "to_json",
        "original": "def to_json(self) -> str:\n    return serialize_value(cast(NamedTuple, self))",
        "mutated": [
            "def to_json(self) -> str:\n    if False:\n        i = 10\n    return serialize_value(cast(NamedTuple, self))",
            "def to_json(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return serialize_value(cast(NamedTuple, self))",
            "def to_json(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return serialize_value(cast(NamedTuple, self))",
            "def to_json(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return serialize_value(cast(NamedTuple, self))",
            "def to_json(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return serialize_value(cast(NamedTuple, self))"
        ]
    },
    {
        "func_name": "from_json",
        "original": "@staticmethod\ndef from_json(json_str: str) -> 'FreshnessPolicySensorCursor':\n    return deserialize_value(json_str, FreshnessPolicySensorCursor)",
        "mutated": [
            "@staticmethod\ndef from_json(json_str: str) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n    return deserialize_value(json_str, FreshnessPolicySensorCursor)",
            "@staticmethod\ndef from_json(json_str: str) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return deserialize_value(json_str, FreshnessPolicySensorCursor)",
            "@staticmethod\ndef from_json(json_str: str) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return deserialize_value(json_str, FreshnessPolicySensorCursor)",
            "@staticmethod\ndef from_json(json_str: str) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return deserialize_value(json_str, FreshnessPolicySensorCursor)",
            "@staticmethod\ndef from_json(json_str: str) -> 'FreshnessPolicySensorCursor':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return deserialize_value(json_str, FreshnessPolicySensorCursor)"
        ]
    },
    {
        "func_name": "__new__",
        "original": "def __new__(cls, sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float], instance: DagsterInstance, resources: Optional[Resources]=None):\n    minutes_overdue = check.opt_numeric_param(minutes_overdue, 'minutes_overdue')\n    previous_minutes_overdue = check.opt_numeric_param(previous_minutes_overdue, 'previous_minutes_overdue')\n    return super(FreshnessPolicySensorContext, cls).__new__(cls, sensor_name=check.str_param(sensor_name, 'sensor_name'), asset_key=check.inst_param(asset_key, 'asset_key', AssetKey), freshness_policy=check.inst_param(freshness_policy, 'FreshnessPolicy', FreshnessPolicy), minutes_overdue=float(minutes_overdue) if minutes_overdue is not None else None, previous_minutes_overdue=float(previous_minutes_overdue) if previous_minutes_overdue is not None else None, instance=check.inst_param(instance, 'instance', DagsterInstance), resources=resources or ScopedResourcesBuilder.build_empty())",
        "mutated": [
            "def __new__(cls, sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float], instance: DagsterInstance, resources: Optional[Resources]=None):\n    if False:\n        i = 10\n    minutes_overdue = check.opt_numeric_param(minutes_overdue, 'minutes_overdue')\n    previous_minutes_overdue = check.opt_numeric_param(previous_minutes_overdue, 'previous_minutes_overdue')\n    return super(FreshnessPolicySensorContext, cls).__new__(cls, sensor_name=check.str_param(sensor_name, 'sensor_name'), asset_key=check.inst_param(asset_key, 'asset_key', AssetKey), freshness_policy=check.inst_param(freshness_policy, 'FreshnessPolicy', FreshnessPolicy), minutes_overdue=float(minutes_overdue) if minutes_overdue is not None else None, previous_minutes_overdue=float(previous_minutes_overdue) if previous_minutes_overdue is not None else None, instance=check.inst_param(instance, 'instance', DagsterInstance), resources=resources or ScopedResourcesBuilder.build_empty())",
            "def __new__(cls, sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float], instance: DagsterInstance, resources: Optional[Resources]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    minutes_overdue = check.opt_numeric_param(minutes_overdue, 'minutes_overdue')\n    previous_minutes_overdue = check.opt_numeric_param(previous_minutes_overdue, 'previous_minutes_overdue')\n    return super(FreshnessPolicySensorContext, cls).__new__(cls, sensor_name=check.str_param(sensor_name, 'sensor_name'), asset_key=check.inst_param(asset_key, 'asset_key', AssetKey), freshness_policy=check.inst_param(freshness_policy, 'FreshnessPolicy', FreshnessPolicy), minutes_overdue=float(minutes_overdue) if minutes_overdue is not None else None, previous_minutes_overdue=float(previous_minutes_overdue) if previous_minutes_overdue is not None else None, instance=check.inst_param(instance, 'instance', DagsterInstance), resources=resources or ScopedResourcesBuilder.build_empty())",
            "def __new__(cls, sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float], instance: DagsterInstance, resources: Optional[Resources]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    minutes_overdue = check.opt_numeric_param(minutes_overdue, 'minutes_overdue')\n    previous_minutes_overdue = check.opt_numeric_param(previous_minutes_overdue, 'previous_minutes_overdue')\n    return super(FreshnessPolicySensorContext, cls).__new__(cls, sensor_name=check.str_param(sensor_name, 'sensor_name'), asset_key=check.inst_param(asset_key, 'asset_key', AssetKey), freshness_policy=check.inst_param(freshness_policy, 'FreshnessPolicy', FreshnessPolicy), minutes_overdue=float(minutes_overdue) if minutes_overdue is not None else None, previous_minutes_overdue=float(previous_minutes_overdue) if previous_minutes_overdue is not None else None, instance=check.inst_param(instance, 'instance', DagsterInstance), resources=resources or ScopedResourcesBuilder.build_empty())",
            "def __new__(cls, sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float], instance: DagsterInstance, resources: Optional[Resources]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    minutes_overdue = check.opt_numeric_param(minutes_overdue, 'minutes_overdue')\n    previous_minutes_overdue = check.opt_numeric_param(previous_minutes_overdue, 'previous_minutes_overdue')\n    return super(FreshnessPolicySensorContext, cls).__new__(cls, sensor_name=check.str_param(sensor_name, 'sensor_name'), asset_key=check.inst_param(asset_key, 'asset_key', AssetKey), freshness_policy=check.inst_param(freshness_policy, 'FreshnessPolicy', FreshnessPolicy), minutes_overdue=float(minutes_overdue) if minutes_overdue is not None else None, previous_minutes_overdue=float(previous_minutes_overdue) if previous_minutes_overdue is not None else None, instance=check.inst_param(instance, 'instance', DagsterInstance), resources=resources or ScopedResourcesBuilder.build_empty())",
            "def __new__(cls, sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float], instance: DagsterInstance, resources: Optional[Resources]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    minutes_overdue = check.opt_numeric_param(minutes_overdue, 'minutes_overdue')\n    previous_minutes_overdue = check.opt_numeric_param(previous_minutes_overdue, 'previous_minutes_overdue')\n    return super(FreshnessPolicySensorContext, cls).__new__(cls, sensor_name=check.str_param(sensor_name, 'sensor_name'), asset_key=check.inst_param(asset_key, 'asset_key', AssetKey), freshness_policy=check.inst_param(freshness_policy, 'FreshnessPolicy', FreshnessPolicy), minutes_overdue=float(minutes_overdue) if minutes_overdue is not None else None, previous_minutes_overdue=float(previous_minutes_overdue) if previous_minutes_overdue is not None else None, instance=check.inst_param(instance, 'instance', DagsterInstance), resources=resources or ScopedResourcesBuilder.build_empty())"
        ]
    },
    {
        "func_name": "build_freshness_policy_sensor_context",
        "original": "@experimental\ndef build_freshness_policy_sensor_context(sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float]=None, instance: Optional[DagsterInstance]=None, resources: Optional[Resources]=None) -> FreshnessPolicySensorContext:\n    \"\"\"Builds freshness policy sensor context from provided parameters.\n\n    This function can be used to provide the context argument when directly invoking a function\n    decorated with `@freshness_policy_sensor`, such as when writing unit tests.\n\n    Args:\n        sensor_name (str): The name of the sensor the context is being constructed for.\n        asset_key (AssetKey): The AssetKey for the monitored asset\n        freshness_policy (FreshnessPolicy): The FreshnessPolicy for the monitored asset\n        minutes_overdue (Optional[float]): How overdue the monitored asset currently is\n        previous_minutes_overdue (Optional[float]): How overdue the monitored asset was on the\n            previous tick.\n        instance (DagsterInstance): The dagster instance configured for the context.\n\n    Examples:\n        .. code-block:: python\n\n            context = build_freshness_policy_sensor_context(\n                sensor_name=\"freshness_policy_sensor_to_invoke\",\n                asset_key=AssetKey(\"some_asset\"),\n                freshness_policy=FreshnessPolicy(maximum_lag_minutes=30)<\n                minutes_overdue=10.0,\n            )\n            freshness_policy_sensor_to_invoke(context)\n    \"\"\"\n    return FreshnessPolicySensorContext(sensor_name=sensor_name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_overdue, previous_minutes_overdue=previous_minutes_overdue, instance=instance or DagsterInstance.ephemeral(), resources=resources)",
        "mutated": [
            "@experimental\ndef build_freshness_policy_sensor_context(sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float]=None, instance: Optional[DagsterInstance]=None, resources: Optional[Resources]=None) -> FreshnessPolicySensorContext:\n    if False:\n        i = 10\n    'Builds freshness policy sensor context from provided parameters.\\n\\n    This function can be used to provide the context argument when directly invoking a function\\n    decorated with `@freshness_policy_sensor`, such as when writing unit tests.\\n\\n    Args:\\n        sensor_name (str): The name of the sensor the context is being constructed for.\\n        asset_key (AssetKey): The AssetKey for the monitored asset\\n        freshness_policy (FreshnessPolicy): The FreshnessPolicy for the monitored asset\\n        minutes_overdue (Optional[float]): How overdue the monitored asset currently is\\n        previous_minutes_overdue (Optional[float]): How overdue the monitored asset was on the\\n            previous tick.\\n        instance (DagsterInstance): The dagster instance configured for the context.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            context = build_freshness_policy_sensor_context(\\n                sensor_name=\"freshness_policy_sensor_to_invoke\",\\n                asset_key=AssetKey(\"some_asset\"),\\n                freshness_policy=FreshnessPolicy(maximum_lag_minutes=30)<\\n                minutes_overdue=10.0,\\n            )\\n            freshness_policy_sensor_to_invoke(context)\\n    '\n    return FreshnessPolicySensorContext(sensor_name=sensor_name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_overdue, previous_minutes_overdue=previous_minutes_overdue, instance=instance or DagsterInstance.ephemeral(), resources=resources)",
            "@experimental\ndef build_freshness_policy_sensor_context(sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float]=None, instance: Optional[DagsterInstance]=None, resources: Optional[Resources]=None) -> FreshnessPolicySensorContext:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Builds freshness policy sensor context from provided parameters.\\n\\n    This function can be used to provide the context argument when directly invoking a function\\n    decorated with `@freshness_policy_sensor`, such as when writing unit tests.\\n\\n    Args:\\n        sensor_name (str): The name of the sensor the context is being constructed for.\\n        asset_key (AssetKey): The AssetKey for the monitored asset\\n        freshness_policy (FreshnessPolicy): The FreshnessPolicy for the monitored asset\\n        minutes_overdue (Optional[float]): How overdue the monitored asset currently is\\n        previous_minutes_overdue (Optional[float]): How overdue the monitored asset was on the\\n            previous tick.\\n        instance (DagsterInstance): The dagster instance configured for the context.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            context = build_freshness_policy_sensor_context(\\n                sensor_name=\"freshness_policy_sensor_to_invoke\",\\n                asset_key=AssetKey(\"some_asset\"),\\n                freshness_policy=FreshnessPolicy(maximum_lag_minutes=30)<\\n                minutes_overdue=10.0,\\n            )\\n            freshness_policy_sensor_to_invoke(context)\\n    '\n    return FreshnessPolicySensorContext(sensor_name=sensor_name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_overdue, previous_minutes_overdue=previous_minutes_overdue, instance=instance or DagsterInstance.ephemeral(), resources=resources)",
            "@experimental\ndef build_freshness_policy_sensor_context(sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float]=None, instance: Optional[DagsterInstance]=None, resources: Optional[Resources]=None) -> FreshnessPolicySensorContext:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Builds freshness policy sensor context from provided parameters.\\n\\n    This function can be used to provide the context argument when directly invoking a function\\n    decorated with `@freshness_policy_sensor`, such as when writing unit tests.\\n\\n    Args:\\n        sensor_name (str): The name of the sensor the context is being constructed for.\\n        asset_key (AssetKey): The AssetKey for the monitored asset\\n        freshness_policy (FreshnessPolicy): The FreshnessPolicy for the monitored asset\\n        minutes_overdue (Optional[float]): How overdue the monitored asset currently is\\n        previous_minutes_overdue (Optional[float]): How overdue the monitored asset was on the\\n            previous tick.\\n        instance (DagsterInstance): The dagster instance configured for the context.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            context = build_freshness_policy_sensor_context(\\n                sensor_name=\"freshness_policy_sensor_to_invoke\",\\n                asset_key=AssetKey(\"some_asset\"),\\n                freshness_policy=FreshnessPolicy(maximum_lag_minutes=30)<\\n                minutes_overdue=10.0,\\n            )\\n            freshness_policy_sensor_to_invoke(context)\\n    '\n    return FreshnessPolicySensorContext(sensor_name=sensor_name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_overdue, previous_minutes_overdue=previous_minutes_overdue, instance=instance or DagsterInstance.ephemeral(), resources=resources)",
            "@experimental\ndef build_freshness_policy_sensor_context(sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float]=None, instance: Optional[DagsterInstance]=None, resources: Optional[Resources]=None) -> FreshnessPolicySensorContext:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Builds freshness policy sensor context from provided parameters.\\n\\n    This function can be used to provide the context argument when directly invoking a function\\n    decorated with `@freshness_policy_sensor`, such as when writing unit tests.\\n\\n    Args:\\n        sensor_name (str): The name of the sensor the context is being constructed for.\\n        asset_key (AssetKey): The AssetKey for the monitored asset\\n        freshness_policy (FreshnessPolicy): The FreshnessPolicy for the monitored asset\\n        minutes_overdue (Optional[float]): How overdue the monitored asset currently is\\n        previous_minutes_overdue (Optional[float]): How overdue the monitored asset was on the\\n            previous tick.\\n        instance (DagsterInstance): The dagster instance configured for the context.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            context = build_freshness_policy_sensor_context(\\n                sensor_name=\"freshness_policy_sensor_to_invoke\",\\n                asset_key=AssetKey(\"some_asset\"),\\n                freshness_policy=FreshnessPolicy(maximum_lag_minutes=30)<\\n                minutes_overdue=10.0,\\n            )\\n            freshness_policy_sensor_to_invoke(context)\\n    '\n    return FreshnessPolicySensorContext(sensor_name=sensor_name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_overdue, previous_minutes_overdue=previous_minutes_overdue, instance=instance or DagsterInstance.ephemeral(), resources=resources)",
            "@experimental\ndef build_freshness_policy_sensor_context(sensor_name: str, asset_key: AssetKey, freshness_policy: FreshnessPolicy, minutes_overdue: Optional[float], previous_minutes_overdue: Optional[float]=None, instance: Optional[DagsterInstance]=None, resources: Optional[Resources]=None) -> FreshnessPolicySensorContext:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Builds freshness policy sensor context from provided parameters.\\n\\n    This function can be used to provide the context argument when directly invoking a function\\n    decorated with `@freshness_policy_sensor`, such as when writing unit tests.\\n\\n    Args:\\n        sensor_name (str): The name of the sensor the context is being constructed for.\\n        asset_key (AssetKey): The AssetKey for the monitored asset\\n        freshness_policy (FreshnessPolicy): The FreshnessPolicy for the monitored asset\\n        minutes_overdue (Optional[float]): How overdue the monitored asset currently is\\n        previous_minutes_overdue (Optional[float]): How overdue the monitored asset was on the\\n            previous tick.\\n        instance (DagsterInstance): The dagster instance configured for the context.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            context = build_freshness_policy_sensor_context(\\n                sensor_name=\"freshness_policy_sensor_to_invoke\",\\n                asset_key=AssetKey(\"some_asset\"),\\n                freshness_policy=FreshnessPolicy(maximum_lag_minutes=30)<\\n                minutes_overdue=10.0,\\n            )\\n            freshness_policy_sensor_to_invoke(context)\\n    '\n    return FreshnessPolicySensorContext(sensor_name=sensor_name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_overdue, previous_minutes_overdue=previous_minutes_overdue, instance=instance or DagsterInstance.ephemeral(), resources=resources)"
        ]
    },
    {
        "func_name": "_wrapped_fn",
        "original": "def _wrapped_fn(context: SensorEvaluationContext):\n    from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n    if context.repository_def is None:\n        raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n    if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n        new_cursor = FreshnessPolicySensorCursor({})\n        context.update_cursor(new_cursor.to_json())\n        yield SkipReason(f'Initializing {name}.')\n        return\n    evaluation_time = pendulum.now('UTC')\n    asset_graph = context.repository_def.asset_graph\n    instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n    data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n    monitored_keys = asset_selection.resolve(asset_graph)\n    previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n    minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n    for asset_key in monitored_keys:\n        freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n        if freshness_policy is None:\n            continue\n        result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n        minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n        resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n        context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n        freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n        with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n            context_param = {context_param_name: freshness_context} if context_param_name else {}\n            result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n        if result is not None:\n            raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n    context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())",
        "mutated": [
            "def _wrapped_fn(context: SensorEvaluationContext):\n    if False:\n        i = 10\n    from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n    if context.repository_def is None:\n        raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n    if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n        new_cursor = FreshnessPolicySensorCursor({})\n        context.update_cursor(new_cursor.to_json())\n        yield SkipReason(f'Initializing {name}.')\n        return\n    evaluation_time = pendulum.now('UTC')\n    asset_graph = context.repository_def.asset_graph\n    instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n    data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n    monitored_keys = asset_selection.resolve(asset_graph)\n    previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n    minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n    for asset_key in monitored_keys:\n        freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n        if freshness_policy is None:\n            continue\n        result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n        minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n        resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n        context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n        freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n        with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n            context_param = {context_param_name: freshness_context} if context_param_name else {}\n            result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n        if result is not None:\n            raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n    context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())",
            "def _wrapped_fn(context: SensorEvaluationContext):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n    if context.repository_def is None:\n        raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n    if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n        new_cursor = FreshnessPolicySensorCursor({})\n        context.update_cursor(new_cursor.to_json())\n        yield SkipReason(f'Initializing {name}.')\n        return\n    evaluation_time = pendulum.now('UTC')\n    asset_graph = context.repository_def.asset_graph\n    instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n    data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n    monitored_keys = asset_selection.resolve(asset_graph)\n    previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n    minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n    for asset_key in monitored_keys:\n        freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n        if freshness_policy is None:\n            continue\n        result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n        minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n        resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n        context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n        freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n        with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n            context_param = {context_param_name: freshness_context} if context_param_name else {}\n            result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n        if result is not None:\n            raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n    context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())",
            "def _wrapped_fn(context: SensorEvaluationContext):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n    if context.repository_def is None:\n        raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n    if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n        new_cursor = FreshnessPolicySensorCursor({})\n        context.update_cursor(new_cursor.to_json())\n        yield SkipReason(f'Initializing {name}.')\n        return\n    evaluation_time = pendulum.now('UTC')\n    asset_graph = context.repository_def.asset_graph\n    instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n    data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n    monitored_keys = asset_selection.resolve(asset_graph)\n    previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n    minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n    for asset_key in monitored_keys:\n        freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n        if freshness_policy is None:\n            continue\n        result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n        minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n        resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n        context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n        freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n        with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n            context_param = {context_param_name: freshness_context} if context_param_name else {}\n            result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n        if result is not None:\n            raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n    context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())",
            "def _wrapped_fn(context: SensorEvaluationContext):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n    if context.repository_def is None:\n        raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n    if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n        new_cursor = FreshnessPolicySensorCursor({})\n        context.update_cursor(new_cursor.to_json())\n        yield SkipReason(f'Initializing {name}.')\n        return\n    evaluation_time = pendulum.now('UTC')\n    asset_graph = context.repository_def.asset_graph\n    instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n    data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n    monitored_keys = asset_selection.resolve(asset_graph)\n    previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n    minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n    for asset_key in monitored_keys:\n        freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n        if freshness_policy is None:\n            continue\n        result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n        minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n        resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n        context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n        freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n        with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n            context_param = {context_param_name: freshness_context} if context_param_name else {}\n            result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n        if result is not None:\n            raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n    context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())",
            "def _wrapped_fn(context: SensorEvaluationContext):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n    if context.repository_def is None:\n        raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n    if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n        new_cursor = FreshnessPolicySensorCursor({})\n        context.update_cursor(new_cursor.to_json())\n        yield SkipReason(f'Initializing {name}.')\n        return\n    evaluation_time = pendulum.now('UTC')\n    asset_graph = context.repository_def.asset_graph\n    instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n    data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n    monitored_keys = asset_selection.resolve(asset_graph)\n    previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n    minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n    for asset_key in monitored_keys:\n        freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n        if freshness_policy is None:\n            continue\n        result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n        minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n        resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n        context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n        freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n        with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n            context_param = {context_param_name: freshness_context} if context_param_name else {}\n            result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n        if result is not None:\n            raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n    context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, name: str, asset_selection: AssetSelection, freshness_policy_sensor_fn: Callable[..., None], minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None):\n    check.str_param(name, 'name')\n    check.inst_param(asset_selection, 'asset_selection', AssetSelection)\n    check.opt_int_param(minimum_interval_seconds, 'minimum_interval_seconds')\n    check.opt_str_param(description, 'description')\n    check.inst_param(default_status, 'default_status', DefaultSensorStatus)\n    self._freshness_policy_sensor_fn = check.callable_param(freshness_policy_sensor_fn, 'freshness_policy_sensor_fn')\n    resource_arg_names: Set[str] = {arg.name for arg in get_resource_args(freshness_policy_sensor_fn)}\n    combined_required_resource_keys = check.opt_set_param(required_resource_keys, 'required_resource_keys', of_type=str) | resource_arg_names\n\n    def _wrapped_fn(context: SensorEvaluationContext):\n        from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n        if context.repository_def is None:\n            raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n        if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n            new_cursor = FreshnessPolicySensorCursor({})\n            context.update_cursor(new_cursor.to_json())\n            yield SkipReason(f'Initializing {name}.')\n            return\n        evaluation_time = pendulum.now('UTC')\n        asset_graph = context.repository_def.asset_graph\n        instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n        data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n        monitored_keys = asset_selection.resolve(asset_graph)\n        previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n        minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n        for asset_key in monitored_keys:\n            freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n            if freshness_policy is None:\n                continue\n            result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n            minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n            resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n            context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n            freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n            with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n                context_param = {context_param_name: freshness_context} if context_param_name else {}\n                result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n            if result is not None:\n                raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n        context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())\n    super(FreshnessPolicySensorDefinition, self).__init__(name=name, evaluation_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status, required_resource_keys=combined_required_resource_keys)",
        "mutated": [
            "def __init__(self, name: str, asset_selection: AssetSelection, freshness_policy_sensor_fn: Callable[..., None], minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None):\n    if False:\n        i = 10\n    check.str_param(name, 'name')\n    check.inst_param(asset_selection, 'asset_selection', AssetSelection)\n    check.opt_int_param(minimum_interval_seconds, 'minimum_interval_seconds')\n    check.opt_str_param(description, 'description')\n    check.inst_param(default_status, 'default_status', DefaultSensorStatus)\n    self._freshness_policy_sensor_fn = check.callable_param(freshness_policy_sensor_fn, 'freshness_policy_sensor_fn')\n    resource_arg_names: Set[str] = {arg.name for arg in get_resource_args(freshness_policy_sensor_fn)}\n    combined_required_resource_keys = check.opt_set_param(required_resource_keys, 'required_resource_keys', of_type=str) | resource_arg_names\n\n    def _wrapped_fn(context: SensorEvaluationContext):\n        from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n        if context.repository_def is None:\n            raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n        if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n            new_cursor = FreshnessPolicySensorCursor({})\n            context.update_cursor(new_cursor.to_json())\n            yield SkipReason(f'Initializing {name}.')\n            return\n        evaluation_time = pendulum.now('UTC')\n        asset_graph = context.repository_def.asset_graph\n        instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n        data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n        monitored_keys = asset_selection.resolve(asset_graph)\n        previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n        minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n        for asset_key in monitored_keys:\n            freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n            if freshness_policy is None:\n                continue\n            result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n            minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n            resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n            context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n            freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n            with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n                context_param = {context_param_name: freshness_context} if context_param_name else {}\n                result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n            if result is not None:\n                raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n        context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())\n    super(FreshnessPolicySensorDefinition, self).__init__(name=name, evaluation_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status, required_resource_keys=combined_required_resource_keys)",
            "def __init__(self, name: str, asset_selection: AssetSelection, freshness_policy_sensor_fn: Callable[..., None], minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    check.str_param(name, 'name')\n    check.inst_param(asset_selection, 'asset_selection', AssetSelection)\n    check.opt_int_param(minimum_interval_seconds, 'minimum_interval_seconds')\n    check.opt_str_param(description, 'description')\n    check.inst_param(default_status, 'default_status', DefaultSensorStatus)\n    self._freshness_policy_sensor_fn = check.callable_param(freshness_policy_sensor_fn, 'freshness_policy_sensor_fn')\n    resource_arg_names: Set[str] = {arg.name for arg in get_resource_args(freshness_policy_sensor_fn)}\n    combined_required_resource_keys = check.opt_set_param(required_resource_keys, 'required_resource_keys', of_type=str) | resource_arg_names\n\n    def _wrapped_fn(context: SensorEvaluationContext):\n        from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n        if context.repository_def is None:\n            raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n        if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n            new_cursor = FreshnessPolicySensorCursor({})\n            context.update_cursor(new_cursor.to_json())\n            yield SkipReason(f'Initializing {name}.')\n            return\n        evaluation_time = pendulum.now('UTC')\n        asset_graph = context.repository_def.asset_graph\n        instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n        data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n        monitored_keys = asset_selection.resolve(asset_graph)\n        previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n        minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n        for asset_key in monitored_keys:\n            freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n            if freshness_policy is None:\n                continue\n            result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n            minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n            resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n            context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n            freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n            with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n                context_param = {context_param_name: freshness_context} if context_param_name else {}\n                result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n            if result is not None:\n                raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n        context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())\n    super(FreshnessPolicySensorDefinition, self).__init__(name=name, evaluation_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status, required_resource_keys=combined_required_resource_keys)",
            "def __init__(self, name: str, asset_selection: AssetSelection, freshness_policy_sensor_fn: Callable[..., None], minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    check.str_param(name, 'name')\n    check.inst_param(asset_selection, 'asset_selection', AssetSelection)\n    check.opt_int_param(minimum_interval_seconds, 'minimum_interval_seconds')\n    check.opt_str_param(description, 'description')\n    check.inst_param(default_status, 'default_status', DefaultSensorStatus)\n    self._freshness_policy_sensor_fn = check.callable_param(freshness_policy_sensor_fn, 'freshness_policy_sensor_fn')\n    resource_arg_names: Set[str] = {arg.name for arg in get_resource_args(freshness_policy_sensor_fn)}\n    combined_required_resource_keys = check.opt_set_param(required_resource_keys, 'required_resource_keys', of_type=str) | resource_arg_names\n\n    def _wrapped_fn(context: SensorEvaluationContext):\n        from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n        if context.repository_def is None:\n            raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n        if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n            new_cursor = FreshnessPolicySensorCursor({})\n            context.update_cursor(new_cursor.to_json())\n            yield SkipReason(f'Initializing {name}.')\n            return\n        evaluation_time = pendulum.now('UTC')\n        asset_graph = context.repository_def.asset_graph\n        instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n        data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n        monitored_keys = asset_selection.resolve(asset_graph)\n        previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n        minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n        for asset_key in monitored_keys:\n            freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n            if freshness_policy is None:\n                continue\n            result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n            minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n            resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n            context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n            freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n            with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n                context_param = {context_param_name: freshness_context} if context_param_name else {}\n                result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n            if result is not None:\n                raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n        context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())\n    super(FreshnessPolicySensorDefinition, self).__init__(name=name, evaluation_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status, required_resource_keys=combined_required_resource_keys)",
            "def __init__(self, name: str, asset_selection: AssetSelection, freshness_policy_sensor_fn: Callable[..., None], minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    check.str_param(name, 'name')\n    check.inst_param(asset_selection, 'asset_selection', AssetSelection)\n    check.opt_int_param(minimum_interval_seconds, 'minimum_interval_seconds')\n    check.opt_str_param(description, 'description')\n    check.inst_param(default_status, 'default_status', DefaultSensorStatus)\n    self._freshness_policy_sensor_fn = check.callable_param(freshness_policy_sensor_fn, 'freshness_policy_sensor_fn')\n    resource_arg_names: Set[str] = {arg.name for arg in get_resource_args(freshness_policy_sensor_fn)}\n    combined_required_resource_keys = check.opt_set_param(required_resource_keys, 'required_resource_keys', of_type=str) | resource_arg_names\n\n    def _wrapped_fn(context: SensorEvaluationContext):\n        from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n        if context.repository_def is None:\n            raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n        if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n            new_cursor = FreshnessPolicySensorCursor({})\n            context.update_cursor(new_cursor.to_json())\n            yield SkipReason(f'Initializing {name}.')\n            return\n        evaluation_time = pendulum.now('UTC')\n        asset_graph = context.repository_def.asset_graph\n        instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n        data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n        monitored_keys = asset_selection.resolve(asset_graph)\n        previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n        minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n        for asset_key in monitored_keys:\n            freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n            if freshness_policy is None:\n                continue\n            result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n            minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n            resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n            context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n            freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n            with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n                context_param = {context_param_name: freshness_context} if context_param_name else {}\n                result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n            if result is not None:\n                raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n        context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())\n    super(FreshnessPolicySensorDefinition, self).__init__(name=name, evaluation_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status, required_resource_keys=combined_required_resource_keys)",
            "def __init__(self, name: str, asset_selection: AssetSelection, freshness_policy_sensor_fn: Callable[..., None], minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    check.str_param(name, 'name')\n    check.inst_param(asset_selection, 'asset_selection', AssetSelection)\n    check.opt_int_param(minimum_interval_seconds, 'minimum_interval_seconds')\n    check.opt_str_param(description, 'description')\n    check.inst_param(default_status, 'default_status', DefaultSensorStatus)\n    self._freshness_policy_sensor_fn = check.callable_param(freshness_policy_sensor_fn, 'freshness_policy_sensor_fn')\n    resource_arg_names: Set[str] = {arg.name for arg in get_resource_args(freshness_policy_sensor_fn)}\n    combined_required_resource_keys = check.opt_set_param(required_resource_keys, 'required_resource_keys', of_type=str) | resource_arg_names\n\n    def _wrapped_fn(context: SensorEvaluationContext):\n        from dagster._utils.caching_instance_queryer import CachingInstanceQueryer\n        if context.repository_def is None:\n            raise DagsterInvalidInvocationError('The `repository_def` property on the `SensorEvaluationContext` passed into a `FreshnessPolicySensorDefinition` must not be None.')\n        if context.cursor is None or not FreshnessPolicySensorCursor.is_valid(context.cursor):\n            new_cursor = FreshnessPolicySensorCursor({})\n            context.update_cursor(new_cursor.to_json())\n            yield SkipReason(f'Initializing {name}.')\n            return\n        evaluation_time = pendulum.now('UTC')\n        asset_graph = context.repository_def.asset_graph\n        instance_queryer = CachingInstanceQueryer(context.instance, asset_graph, evaluation_time)\n        data_time_resolver = CachingDataTimeResolver(instance_queryer=instance_queryer)\n        monitored_keys = asset_selection.resolve(asset_graph)\n        previous_minutes_late_by_key = FreshnessPolicySensorCursor.from_json(context.cursor).minutes_late_by_key\n        minutes_late_by_key: Dict[AssetKey, Optional[float]] = {}\n        for asset_key in monitored_keys:\n            freshness_policy = asset_graph.freshness_policies_by_key.get(asset_key)\n            if freshness_policy is None:\n                continue\n            result = data_time_resolver.get_minutes_overdue(evaluation_time=evaluation_time, asset_key=asset_key)\n            minutes_late_by_key[asset_key] = result.overdue_minutes if result else None\n            resource_args_populated = validate_and_get_resource_dict(context.resources, name, resource_arg_names)\n            context_param_name = get_context_param_name(freshness_policy_sensor_fn)\n            freshness_context = FreshnessPolicySensorContext(sensor_name=name, asset_key=asset_key, freshness_policy=freshness_policy, minutes_overdue=minutes_late_by_key[asset_key], previous_minutes_overdue=previous_minutes_late_by_key.get(asset_key), instance=context.instance, resources=context.resources)\n            with user_code_error_boundary(FreshnessPolicySensorExecutionError, lambda : f'Error occurred during the execution of sensor \"{name}\".'):\n                context_param = {context_param_name: freshness_context} if context_param_name else {}\n                result = freshness_policy_sensor_fn(**context_param, **resource_args_populated)\n            if result is not None:\n                raise DagsterInvalidDefinitionError('Functions decorated by `@freshness_policy_sensor` may not return or yield a value.')\n        context.update_cursor(FreshnessPolicySensorCursor.from_dict(minutes_late_by_key).to_json())\n    super(FreshnessPolicySensorDefinition, self).__init__(name=name, evaluation_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status, required_resource_keys=combined_required_resource_keys)"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, *args, **kwargs) -> None:\n    context_param_name = get_context_param_name(self._freshness_policy_sensor_fn)\n    sensor_context = get_sensor_context_from_args_or_kwargs(self._freshness_policy_sensor_fn, args, kwargs, context_type=FreshnessPolicySensorContext)\n    context_param = {context_param_name: sensor_context} if context_param_name and sensor_context else {}\n    resources = validate_and_get_resource_dict(sensor_context.resources if sensor_context else ScopedResourcesBuilder.build_empty(), self._name, self._required_resource_keys)\n    return self._freshness_policy_sensor_fn(**context_param, **resources)",
        "mutated": [
            "def __call__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n    context_param_name = get_context_param_name(self._freshness_policy_sensor_fn)\n    sensor_context = get_sensor_context_from_args_or_kwargs(self._freshness_policy_sensor_fn, args, kwargs, context_type=FreshnessPolicySensorContext)\n    context_param = {context_param_name: sensor_context} if context_param_name and sensor_context else {}\n    resources = validate_and_get_resource_dict(sensor_context.resources if sensor_context else ScopedResourcesBuilder.build_empty(), self._name, self._required_resource_keys)\n    return self._freshness_policy_sensor_fn(**context_param, **resources)",
            "def __call__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    context_param_name = get_context_param_name(self._freshness_policy_sensor_fn)\n    sensor_context = get_sensor_context_from_args_or_kwargs(self._freshness_policy_sensor_fn, args, kwargs, context_type=FreshnessPolicySensorContext)\n    context_param = {context_param_name: sensor_context} if context_param_name and sensor_context else {}\n    resources = validate_and_get_resource_dict(sensor_context.resources if sensor_context else ScopedResourcesBuilder.build_empty(), self._name, self._required_resource_keys)\n    return self._freshness_policy_sensor_fn(**context_param, **resources)",
            "def __call__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    context_param_name = get_context_param_name(self._freshness_policy_sensor_fn)\n    sensor_context = get_sensor_context_from_args_or_kwargs(self._freshness_policy_sensor_fn, args, kwargs, context_type=FreshnessPolicySensorContext)\n    context_param = {context_param_name: sensor_context} if context_param_name and sensor_context else {}\n    resources = validate_and_get_resource_dict(sensor_context.resources if sensor_context else ScopedResourcesBuilder.build_empty(), self._name, self._required_resource_keys)\n    return self._freshness_policy_sensor_fn(**context_param, **resources)",
            "def __call__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    context_param_name = get_context_param_name(self._freshness_policy_sensor_fn)\n    sensor_context = get_sensor_context_from_args_or_kwargs(self._freshness_policy_sensor_fn, args, kwargs, context_type=FreshnessPolicySensorContext)\n    context_param = {context_param_name: sensor_context} if context_param_name and sensor_context else {}\n    resources = validate_and_get_resource_dict(sensor_context.resources if sensor_context else ScopedResourcesBuilder.build_empty(), self._name, self._required_resource_keys)\n    return self._freshness_policy_sensor_fn(**context_param, **resources)",
            "def __call__(self, *args, **kwargs) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    context_param_name = get_context_param_name(self._freshness_policy_sensor_fn)\n    sensor_context = get_sensor_context_from_args_or_kwargs(self._freshness_policy_sensor_fn, args, kwargs, context_type=FreshnessPolicySensorContext)\n    context_param = {context_param_name: sensor_context} if context_param_name and sensor_context else {}\n    resources = validate_and_get_resource_dict(sensor_context.resources if sensor_context else ScopedResourcesBuilder.build_empty(), self._name, self._required_resource_keys)\n    return self._freshness_policy_sensor_fn(**context_param, **resources)"
        ]
    },
    {
        "func_name": "sensor_type",
        "original": "@property\ndef sensor_type(self) -> SensorType:\n    return SensorType.FRESHNESS_POLICY",
        "mutated": [
            "@property\ndef sensor_type(self) -> SensorType:\n    if False:\n        i = 10\n    return SensorType.FRESHNESS_POLICY",
            "@property\ndef sensor_type(self) -> SensorType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return SensorType.FRESHNESS_POLICY",
            "@property\ndef sensor_type(self) -> SensorType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return SensorType.FRESHNESS_POLICY",
            "@property\ndef sensor_type(self) -> SensorType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return SensorType.FRESHNESS_POLICY",
            "@property\ndef sensor_type(self) -> SensorType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return SensorType.FRESHNESS_POLICY"
        ]
    },
    {
        "func_name": "inner",
        "original": "def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)",
        "mutated": [
            "def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n    if False:\n        i = 10\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)",
            "def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)",
            "def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)",
            "def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)",
            "def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)"
        ]
    },
    {
        "func_name": "freshness_policy_sensor",
        "original": "@experimental\ndef freshness_policy_sensor(asset_selection: AssetSelection, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED) -> Callable[[Callable[..., None]], FreshnessPolicySensorDefinition]:\n    \"\"\"Define a sensor that reacts to the status of a given set of asset freshness policies, where the\n    decorated function will be evaluated on every tick for each asset in the selection that has a\n    FreshnessPolicy defined.\n\n    Note: returning or yielding a value from the annotated function will result in an error.\n\n    Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\n\n    Args:\n        asset_selection (AssetSelection): The asset selection monitored by the sensor.\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated function.\n        freshness_policy_sensor_fn (Callable[[FreshnessPolicySensorContext], None]): The core\n            evaluation function for the sensor. Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\n            between sensor evaluations.\n        description (Optional[str]): A human-readable description of the sensor.\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\n            status can be overridden from the Dagster UI or via the GraphQL API.\n    \"\"\"\n\n    def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)\n    return inner",
        "mutated": [
            "@experimental\ndef freshness_policy_sensor(asset_selection: AssetSelection, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED) -> Callable[[Callable[..., None]], FreshnessPolicySensorDefinition]:\n    if False:\n        i = 10\n    'Define a sensor that reacts to the status of a given set of asset freshness policies, where the\\n    decorated function will be evaluated on every tick for each asset in the selection that has a\\n    FreshnessPolicy defined.\\n\\n    Note: returning or yielding a value from the annotated function will result in an error.\\n\\n    Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n\\n    Args:\\n        asset_selection (AssetSelection): The asset selection monitored by the sensor.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated function.\\n        freshness_policy_sensor_fn (Callable[[FreshnessPolicySensorContext], None]): The core\\n            evaluation function for the sensor. Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n    '\n\n    def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)\n    return inner",
            "@experimental\ndef freshness_policy_sensor(asset_selection: AssetSelection, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED) -> Callable[[Callable[..., None]], FreshnessPolicySensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Define a sensor that reacts to the status of a given set of asset freshness policies, where the\\n    decorated function will be evaluated on every tick for each asset in the selection that has a\\n    FreshnessPolicy defined.\\n\\n    Note: returning or yielding a value from the annotated function will result in an error.\\n\\n    Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n\\n    Args:\\n        asset_selection (AssetSelection): The asset selection monitored by the sensor.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated function.\\n        freshness_policy_sensor_fn (Callable[[FreshnessPolicySensorContext], None]): The core\\n            evaluation function for the sensor. Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n    '\n\n    def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)\n    return inner",
            "@experimental\ndef freshness_policy_sensor(asset_selection: AssetSelection, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED) -> Callable[[Callable[..., None]], FreshnessPolicySensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Define a sensor that reacts to the status of a given set of asset freshness policies, where the\\n    decorated function will be evaluated on every tick for each asset in the selection that has a\\n    FreshnessPolicy defined.\\n\\n    Note: returning or yielding a value from the annotated function will result in an error.\\n\\n    Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n\\n    Args:\\n        asset_selection (AssetSelection): The asset selection monitored by the sensor.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated function.\\n        freshness_policy_sensor_fn (Callable[[FreshnessPolicySensorContext], None]): The core\\n            evaluation function for the sensor. Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n    '\n\n    def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)\n    return inner",
            "@experimental\ndef freshness_policy_sensor(asset_selection: AssetSelection, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED) -> Callable[[Callable[..., None]], FreshnessPolicySensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Define a sensor that reacts to the status of a given set of asset freshness policies, where the\\n    decorated function will be evaluated on every tick for each asset in the selection that has a\\n    FreshnessPolicy defined.\\n\\n    Note: returning or yielding a value from the annotated function will result in an error.\\n\\n    Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n\\n    Args:\\n        asset_selection (AssetSelection): The asset selection monitored by the sensor.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated function.\\n        freshness_policy_sensor_fn (Callable[[FreshnessPolicySensorContext], None]): The core\\n            evaluation function for the sensor. Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n    '\n\n    def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)\n    return inner",
            "@experimental\ndef freshness_policy_sensor(asset_selection: AssetSelection, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED) -> Callable[[Callable[..., None]], FreshnessPolicySensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Define a sensor that reacts to the status of a given set of asset freshness policies, where the\\n    decorated function will be evaluated on every tick for each asset in the selection that has a\\n    FreshnessPolicy defined.\\n\\n    Note: returning or yielding a value from the annotated function will result in an error.\\n\\n    Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n\\n    Args:\\n        asset_selection (AssetSelection): The asset selection monitored by the sensor.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated function.\\n        freshness_policy_sensor_fn (Callable[[FreshnessPolicySensorContext], None]): The core\\n            evaluation function for the sensor. Takes a :py:class:`~dagster.FreshnessPolicySensorContext`.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n    '\n\n    def inner(fn: Callable[..., None]) -> FreshnessPolicySensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        return FreshnessPolicySensorDefinition(name=sensor_name, freshness_policy_sensor_fn=fn, asset_selection=asset_selection, minimum_interval_seconds=minimum_interval_seconds, description=description, default_status=default_status)\n    return inner"
        ]
    }
]