[
    {
        "func_name": "__init__",
        "original": "def __init__(self, engine=ChartConstants().chartfactory_default_engine):\n    self.DUMP_PATH = 'output_data/' + datetime.date.today().strftime('%Y%m%d') + ' '\n    self.DEFAULT_PLOT_ENGINE = engine\n    self.chart = Chart(engine=self.DEFAULT_PLOT_ENGINE)\n    return",
        "mutated": [
            "def __init__(self, engine=ChartConstants().chartfactory_default_engine):\n    if False:\n        i = 10\n    self.DUMP_PATH = 'output_data/' + datetime.date.today().strftime('%Y%m%d') + ' '\n    self.DEFAULT_PLOT_ENGINE = engine\n    self.chart = Chart(engine=self.DEFAULT_PLOT_ENGINE)\n    return",
            "def __init__(self, engine=ChartConstants().chartfactory_default_engine):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.DUMP_PATH = 'output_data/' + datetime.date.today().strftime('%Y%m%d') + ' '\n    self.DEFAULT_PLOT_ENGINE = engine\n    self.chart = Chart(engine=self.DEFAULT_PLOT_ENGINE)\n    return",
            "def __init__(self, engine=ChartConstants().chartfactory_default_engine):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.DUMP_PATH = 'output_data/' + datetime.date.today().strftime('%Y%m%d') + ' '\n    self.DEFAULT_PLOT_ENGINE = engine\n    self.chart = Chart(engine=self.DEFAULT_PLOT_ENGINE)\n    return",
            "def __init__(self, engine=ChartConstants().chartfactory_default_engine):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.DUMP_PATH = 'output_data/' + datetime.date.today().strftime('%Y%m%d') + ' '\n    self.DEFAULT_PLOT_ENGINE = engine\n    self.chart = Chart(engine=self.DEFAULT_PLOT_ENGINE)\n    return",
            "def __init__(self, engine=ChartConstants().chartfactory_default_engine):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.DUMP_PATH = 'output_data/' + datetime.date.today().strftime('%Y%m%d') + ' '\n    self.DEFAULT_PLOT_ENGINE = engine\n    self.chart = Chart(engine=self.DEFAULT_PLOT_ENGINE)\n    return"
        ]
    },
    {
        "func_name": "run_strategy_returns_stats",
        "original": "def run_strategy_returns_stats(self, trading_model, index=None, engine='finmarketpy'):\n    \"\"\"Plots useful statistics for the trading strategy using various backends\n\n        Parameters\n        ----------\n        trading_model : TradingModel\n            defining trading strategy\n\n        engine : str\n            'pyfolio' - use PyFolio as a backend\n            'finmarketpy' - use finmarketpy as a backend\n\n        index: DataFrame\n            define strategy by a time series\n\n        \"\"\"\n    if index is None:\n        pnl = trading_model.strategy_pnl()\n    else:\n        pnl = index\n    tz = Timezone()\n    calculations = Calculations()\n    if engine == 'pyfolio':\n        try:\n            pnl = tz.localize_index_as_UTC(pnl)\n        except:\n            pass\n        try:\n            import matplotlib\n            import matplotlib.pyplot as plt\n            matplotlib.rcdefaults()\n            plt.style.use(ChartConstants().chartfactory_style_sheet['chartpy-pyfolio'])\n        except:\n            pass\n        pnl = calculations.calculate_returns(pnl)\n        pnl = pnl.dropna()\n        pnl = pnl[pnl.columns[0]]\n        fig = pf.create_returns_tear_sheet(pnl, return_fig=True)\n        try:\n            plt.savefig(trading_model.DUMP_PATH + 'stats.png')\n        except:\n            pass\n        plt.show()\n    elif engine == 'finmarketpy':\n        from chartpy import Canvas, Chart\n        old_scale_factor = trading_model.SCALE_FACTOR\n        trading_model.SCALE_FACTOR = 0.75\n        pnl = trading_model.plot_strategy_pnl(silent_plot=True)\n        individual = trading_model.plot_strategy_group_pnl_trades(silent_plot=True)\n        pnl_comp = trading_model.plot_strategy_group_benchmark_pnl(silent_plot=True)\n        ir_comp = trading_model.plot_strategy_group_benchmark_pnl_ir(silent_plot=True)\n        leverage = trading_model.plot_strategy_leverage(silent_plot=True)\n        ind_lev = trading_model.plot_strategy_group_leverage(silent_plot=True)\n        canvas = Canvas([[pnl, individual], [pnl_comp, ir_comp], [leverage, ind_lev]])\n        canvas.generate_canvas(page_title=trading_model.FINAL_STRATEGY + ' Return Statistics', silent_display=False, canvas_plotter='plain', output_filename=trading_model.FINAL_STRATEGY + '.html', render_pdf=False)\n        trading_model.SCALE_FACTOR = old_scale_factor",
        "mutated": [
            "def run_strategy_returns_stats(self, trading_model, index=None, engine='finmarketpy'):\n    if False:\n        i = 10\n    \"Plots useful statistics for the trading strategy using various backends\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy\\n\\n        engine : str\\n            'pyfolio' - use PyFolio as a backend\\n            'finmarketpy' - use finmarketpy as a backend\\n\\n        index: DataFrame\\n            define strategy by a time series\\n\\n        \"\n    if index is None:\n        pnl = trading_model.strategy_pnl()\n    else:\n        pnl = index\n    tz = Timezone()\n    calculations = Calculations()\n    if engine == 'pyfolio':\n        try:\n            pnl = tz.localize_index_as_UTC(pnl)\n        except:\n            pass\n        try:\n            import matplotlib\n            import matplotlib.pyplot as plt\n            matplotlib.rcdefaults()\n            plt.style.use(ChartConstants().chartfactory_style_sheet['chartpy-pyfolio'])\n        except:\n            pass\n        pnl = calculations.calculate_returns(pnl)\n        pnl = pnl.dropna()\n        pnl = pnl[pnl.columns[0]]\n        fig = pf.create_returns_tear_sheet(pnl, return_fig=True)\n        try:\n            plt.savefig(trading_model.DUMP_PATH + 'stats.png')\n        except:\n            pass\n        plt.show()\n    elif engine == 'finmarketpy':\n        from chartpy import Canvas, Chart\n        old_scale_factor = trading_model.SCALE_FACTOR\n        trading_model.SCALE_FACTOR = 0.75\n        pnl = trading_model.plot_strategy_pnl(silent_plot=True)\n        individual = trading_model.plot_strategy_group_pnl_trades(silent_plot=True)\n        pnl_comp = trading_model.plot_strategy_group_benchmark_pnl(silent_plot=True)\n        ir_comp = trading_model.plot_strategy_group_benchmark_pnl_ir(silent_plot=True)\n        leverage = trading_model.plot_strategy_leverage(silent_plot=True)\n        ind_lev = trading_model.plot_strategy_group_leverage(silent_plot=True)\n        canvas = Canvas([[pnl, individual], [pnl_comp, ir_comp], [leverage, ind_lev]])\n        canvas.generate_canvas(page_title=trading_model.FINAL_STRATEGY + ' Return Statistics', silent_display=False, canvas_plotter='plain', output_filename=trading_model.FINAL_STRATEGY + '.html', render_pdf=False)\n        trading_model.SCALE_FACTOR = old_scale_factor",
            "def run_strategy_returns_stats(self, trading_model, index=None, engine='finmarketpy'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Plots useful statistics for the trading strategy using various backends\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy\\n\\n        engine : str\\n            'pyfolio' - use PyFolio as a backend\\n            'finmarketpy' - use finmarketpy as a backend\\n\\n        index: DataFrame\\n            define strategy by a time series\\n\\n        \"\n    if index is None:\n        pnl = trading_model.strategy_pnl()\n    else:\n        pnl = index\n    tz = Timezone()\n    calculations = Calculations()\n    if engine == 'pyfolio':\n        try:\n            pnl = tz.localize_index_as_UTC(pnl)\n        except:\n            pass\n        try:\n            import matplotlib\n            import matplotlib.pyplot as plt\n            matplotlib.rcdefaults()\n            plt.style.use(ChartConstants().chartfactory_style_sheet['chartpy-pyfolio'])\n        except:\n            pass\n        pnl = calculations.calculate_returns(pnl)\n        pnl = pnl.dropna()\n        pnl = pnl[pnl.columns[0]]\n        fig = pf.create_returns_tear_sheet(pnl, return_fig=True)\n        try:\n            plt.savefig(trading_model.DUMP_PATH + 'stats.png')\n        except:\n            pass\n        plt.show()\n    elif engine == 'finmarketpy':\n        from chartpy import Canvas, Chart\n        old_scale_factor = trading_model.SCALE_FACTOR\n        trading_model.SCALE_FACTOR = 0.75\n        pnl = trading_model.plot_strategy_pnl(silent_plot=True)\n        individual = trading_model.plot_strategy_group_pnl_trades(silent_plot=True)\n        pnl_comp = trading_model.plot_strategy_group_benchmark_pnl(silent_plot=True)\n        ir_comp = trading_model.plot_strategy_group_benchmark_pnl_ir(silent_plot=True)\n        leverage = trading_model.plot_strategy_leverage(silent_plot=True)\n        ind_lev = trading_model.plot_strategy_group_leverage(silent_plot=True)\n        canvas = Canvas([[pnl, individual], [pnl_comp, ir_comp], [leverage, ind_lev]])\n        canvas.generate_canvas(page_title=trading_model.FINAL_STRATEGY + ' Return Statistics', silent_display=False, canvas_plotter='plain', output_filename=trading_model.FINAL_STRATEGY + '.html', render_pdf=False)\n        trading_model.SCALE_FACTOR = old_scale_factor",
            "def run_strategy_returns_stats(self, trading_model, index=None, engine='finmarketpy'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Plots useful statistics for the trading strategy using various backends\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy\\n\\n        engine : str\\n            'pyfolio' - use PyFolio as a backend\\n            'finmarketpy' - use finmarketpy as a backend\\n\\n        index: DataFrame\\n            define strategy by a time series\\n\\n        \"\n    if index is None:\n        pnl = trading_model.strategy_pnl()\n    else:\n        pnl = index\n    tz = Timezone()\n    calculations = Calculations()\n    if engine == 'pyfolio':\n        try:\n            pnl = tz.localize_index_as_UTC(pnl)\n        except:\n            pass\n        try:\n            import matplotlib\n            import matplotlib.pyplot as plt\n            matplotlib.rcdefaults()\n            plt.style.use(ChartConstants().chartfactory_style_sheet['chartpy-pyfolio'])\n        except:\n            pass\n        pnl = calculations.calculate_returns(pnl)\n        pnl = pnl.dropna()\n        pnl = pnl[pnl.columns[0]]\n        fig = pf.create_returns_tear_sheet(pnl, return_fig=True)\n        try:\n            plt.savefig(trading_model.DUMP_PATH + 'stats.png')\n        except:\n            pass\n        plt.show()\n    elif engine == 'finmarketpy':\n        from chartpy import Canvas, Chart\n        old_scale_factor = trading_model.SCALE_FACTOR\n        trading_model.SCALE_FACTOR = 0.75\n        pnl = trading_model.plot_strategy_pnl(silent_plot=True)\n        individual = trading_model.plot_strategy_group_pnl_trades(silent_plot=True)\n        pnl_comp = trading_model.plot_strategy_group_benchmark_pnl(silent_plot=True)\n        ir_comp = trading_model.plot_strategy_group_benchmark_pnl_ir(silent_plot=True)\n        leverage = trading_model.plot_strategy_leverage(silent_plot=True)\n        ind_lev = trading_model.plot_strategy_group_leverage(silent_plot=True)\n        canvas = Canvas([[pnl, individual], [pnl_comp, ir_comp], [leverage, ind_lev]])\n        canvas.generate_canvas(page_title=trading_model.FINAL_STRATEGY + ' Return Statistics', silent_display=False, canvas_plotter='plain', output_filename=trading_model.FINAL_STRATEGY + '.html', render_pdf=False)\n        trading_model.SCALE_FACTOR = old_scale_factor",
            "def run_strategy_returns_stats(self, trading_model, index=None, engine='finmarketpy'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Plots useful statistics for the trading strategy using various backends\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy\\n\\n        engine : str\\n            'pyfolio' - use PyFolio as a backend\\n            'finmarketpy' - use finmarketpy as a backend\\n\\n        index: DataFrame\\n            define strategy by a time series\\n\\n        \"\n    if index is None:\n        pnl = trading_model.strategy_pnl()\n    else:\n        pnl = index\n    tz = Timezone()\n    calculations = Calculations()\n    if engine == 'pyfolio':\n        try:\n            pnl = tz.localize_index_as_UTC(pnl)\n        except:\n            pass\n        try:\n            import matplotlib\n            import matplotlib.pyplot as plt\n            matplotlib.rcdefaults()\n            plt.style.use(ChartConstants().chartfactory_style_sheet['chartpy-pyfolio'])\n        except:\n            pass\n        pnl = calculations.calculate_returns(pnl)\n        pnl = pnl.dropna()\n        pnl = pnl[pnl.columns[0]]\n        fig = pf.create_returns_tear_sheet(pnl, return_fig=True)\n        try:\n            plt.savefig(trading_model.DUMP_PATH + 'stats.png')\n        except:\n            pass\n        plt.show()\n    elif engine == 'finmarketpy':\n        from chartpy import Canvas, Chart\n        old_scale_factor = trading_model.SCALE_FACTOR\n        trading_model.SCALE_FACTOR = 0.75\n        pnl = trading_model.plot_strategy_pnl(silent_plot=True)\n        individual = trading_model.plot_strategy_group_pnl_trades(silent_plot=True)\n        pnl_comp = trading_model.plot_strategy_group_benchmark_pnl(silent_plot=True)\n        ir_comp = trading_model.plot_strategy_group_benchmark_pnl_ir(silent_plot=True)\n        leverage = trading_model.plot_strategy_leverage(silent_plot=True)\n        ind_lev = trading_model.plot_strategy_group_leverage(silent_plot=True)\n        canvas = Canvas([[pnl, individual], [pnl_comp, ir_comp], [leverage, ind_lev]])\n        canvas.generate_canvas(page_title=trading_model.FINAL_STRATEGY + ' Return Statistics', silent_display=False, canvas_plotter='plain', output_filename=trading_model.FINAL_STRATEGY + '.html', render_pdf=False)\n        trading_model.SCALE_FACTOR = old_scale_factor",
            "def run_strategy_returns_stats(self, trading_model, index=None, engine='finmarketpy'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Plots useful statistics for the trading strategy using various backends\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy\\n\\n        engine : str\\n            'pyfolio' - use PyFolio as a backend\\n            'finmarketpy' - use finmarketpy as a backend\\n\\n        index: DataFrame\\n            define strategy by a time series\\n\\n        \"\n    if index is None:\n        pnl = trading_model.strategy_pnl()\n    else:\n        pnl = index\n    tz = Timezone()\n    calculations = Calculations()\n    if engine == 'pyfolio':\n        try:\n            pnl = tz.localize_index_as_UTC(pnl)\n        except:\n            pass\n        try:\n            import matplotlib\n            import matplotlib.pyplot as plt\n            matplotlib.rcdefaults()\n            plt.style.use(ChartConstants().chartfactory_style_sheet['chartpy-pyfolio'])\n        except:\n            pass\n        pnl = calculations.calculate_returns(pnl)\n        pnl = pnl.dropna()\n        pnl = pnl[pnl.columns[0]]\n        fig = pf.create_returns_tear_sheet(pnl, return_fig=True)\n        try:\n            plt.savefig(trading_model.DUMP_PATH + 'stats.png')\n        except:\n            pass\n        plt.show()\n    elif engine == 'finmarketpy':\n        from chartpy import Canvas, Chart\n        old_scale_factor = trading_model.SCALE_FACTOR\n        trading_model.SCALE_FACTOR = 0.75\n        pnl = trading_model.plot_strategy_pnl(silent_plot=True)\n        individual = trading_model.plot_strategy_group_pnl_trades(silent_plot=True)\n        pnl_comp = trading_model.plot_strategy_group_benchmark_pnl(silent_plot=True)\n        ir_comp = trading_model.plot_strategy_group_benchmark_pnl_ir(silent_plot=True)\n        leverage = trading_model.plot_strategy_leverage(silent_plot=True)\n        ind_lev = trading_model.plot_strategy_group_leverage(silent_plot=True)\n        canvas = Canvas([[pnl, individual], [pnl_comp, ir_comp], [leverage, ind_lev]])\n        canvas.generate_canvas(page_title=trading_model.FINAL_STRATEGY + ' Return Statistics', silent_display=False, canvas_plotter='plain', output_filename=trading_model.FINAL_STRATEGY + '.html', render_pdf=False)\n        trading_model.SCALE_FACTOR = old_scale_factor"
        ]
    },
    {
        "func_name": "run_excel_trade_report",
        "original": "def run_excel_trade_report(self, trading_model, excel_file='model.xlsx'):\n    \"\"\"\n        run_excel_trade_report - Creates an Excel spreadsheet with model returns and latest trades\n\n        Parameters\n        ----------\n        trading_model : TradingModel\n            defining trading strategy (can be a list)\n\n        \"\"\"\n    trading_model_list = trading_model\n    if not isinstance(trading_model_list, list):\n        trading_model_list = [trading_model]\n    writer = pandas.ExcelWriter(excel_file, engine='xlsxwriter')\n    for tm in trading_model_list:\n        strategy_name = tm.FINAL_STRATEGY\n        returns = tm.strategy_group_benchmark_pnl()\n        returns.to_excel(writer, sheet_name=strategy_name + ' rets', engine='xlsxwriter')\n        self.save_positions_trades(tm, tm.strategy_signal(), tm.strategy_trade(), 'pos', 'trades', writer)\n        if hasattr(tm, '_strategy_signal_notional'):\n            signal_notional = tm.strategy_signal_notional()\n            trading_notional = tm.strategy_signal_notional()\n            if signal_notional is not None and trading_notional is not None:\n                self.save_positions_trades(tm, signal_notional, trading_notional, 'pos - Not', 'trades - Not', writer)\n        if hasattr(tm, '_strategy_signal_contracts'):\n            signal_contracts = tm.strategy_signal_contracts()\n            trade_contracts = tm.strategy_trade_contracts()\n            if signal_contracts is not None and trade_contracts is not None:\n                self.save_positions_trades(tm, signal_contracts, trade_contracts, 'pos - Cont', 'trades - Cont', writer)\n    writer.save()\n    writer.close()",
        "mutated": [
            "def run_excel_trade_report(self, trading_model, excel_file='model.xlsx'):\n    if False:\n        i = 10\n    '\\n        run_excel_trade_report - Creates an Excel spreadsheet with model returns and latest trades\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy (can be a list)\\n\\n        '\n    trading_model_list = trading_model\n    if not isinstance(trading_model_list, list):\n        trading_model_list = [trading_model]\n    writer = pandas.ExcelWriter(excel_file, engine='xlsxwriter')\n    for tm in trading_model_list:\n        strategy_name = tm.FINAL_STRATEGY\n        returns = tm.strategy_group_benchmark_pnl()\n        returns.to_excel(writer, sheet_name=strategy_name + ' rets', engine='xlsxwriter')\n        self.save_positions_trades(tm, tm.strategy_signal(), tm.strategy_trade(), 'pos', 'trades', writer)\n        if hasattr(tm, '_strategy_signal_notional'):\n            signal_notional = tm.strategy_signal_notional()\n            trading_notional = tm.strategy_signal_notional()\n            if signal_notional is not None and trading_notional is not None:\n                self.save_positions_trades(tm, signal_notional, trading_notional, 'pos - Not', 'trades - Not', writer)\n        if hasattr(tm, '_strategy_signal_contracts'):\n            signal_contracts = tm.strategy_signal_contracts()\n            trade_contracts = tm.strategy_trade_contracts()\n            if signal_contracts is not None and trade_contracts is not None:\n                self.save_positions_trades(tm, signal_contracts, trade_contracts, 'pos - Cont', 'trades - Cont', writer)\n    writer.save()\n    writer.close()",
            "def run_excel_trade_report(self, trading_model, excel_file='model.xlsx'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        run_excel_trade_report - Creates an Excel spreadsheet with model returns and latest trades\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy (can be a list)\\n\\n        '\n    trading_model_list = trading_model\n    if not isinstance(trading_model_list, list):\n        trading_model_list = [trading_model]\n    writer = pandas.ExcelWriter(excel_file, engine='xlsxwriter')\n    for tm in trading_model_list:\n        strategy_name = tm.FINAL_STRATEGY\n        returns = tm.strategy_group_benchmark_pnl()\n        returns.to_excel(writer, sheet_name=strategy_name + ' rets', engine='xlsxwriter')\n        self.save_positions_trades(tm, tm.strategy_signal(), tm.strategy_trade(), 'pos', 'trades', writer)\n        if hasattr(tm, '_strategy_signal_notional'):\n            signal_notional = tm.strategy_signal_notional()\n            trading_notional = tm.strategy_signal_notional()\n            if signal_notional is not None and trading_notional is not None:\n                self.save_positions_trades(tm, signal_notional, trading_notional, 'pos - Not', 'trades - Not', writer)\n        if hasattr(tm, '_strategy_signal_contracts'):\n            signal_contracts = tm.strategy_signal_contracts()\n            trade_contracts = tm.strategy_trade_contracts()\n            if signal_contracts is not None and trade_contracts is not None:\n                self.save_positions_trades(tm, signal_contracts, trade_contracts, 'pos - Cont', 'trades - Cont', writer)\n    writer.save()\n    writer.close()",
            "def run_excel_trade_report(self, trading_model, excel_file='model.xlsx'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        run_excel_trade_report - Creates an Excel spreadsheet with model returns and latest trades\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy (can be a list)\\n\\n        '\n    trading_model_list = trading_model\n    if not isinstance(trading_model_list, list):\n        trading_model_list = [trading_model]\n    writer = pandas.ExcelWriter(excel_file, engine='xlsxwriter')\n    for tm in trading_model_list:\n        strategy_name = tm.FINAL_STRATEGY\n        returns = tm.strategy_group_benchmark_pnl()\n        returns.to_excel(writer, sheet_name=strategy_name + ' rets', engine='xlsxwriter')\n        self.save_positions_trades(tm, tm.strategy_signal(), tm.strategy_trade(), 'pos', 'trades', writer)\n        if hasattr(tm, '_strategy_signal_notional'):\n            signal_notional = tm.strategy_signal_notional()\n            trading_notional = tm.strategy_signal_notional()\n            if signal_notional is not None and trading_notional is not None:\n                self.save_positions_trades(tm, signal_notional, trading_notional, 'pos - Not', 'trades - Not', writer)\n        if hasattr(tm, '_strategy_signal_contracts'):\n            signal_contracts = tm.strategy_signal_contracts()\n            trade_contracts = tm.strategy_trade_contracts()\n            if signal_contracts is not None and trade_contracts is not None:\n                self.save_positions_trades(tm, signal_contracts, trade_contracts, 'pos - Cont', 'trades - Cont', writer)\n    writer.save()\n    writer.close()",
            "def run_excel_trade_report(self, trading_model, excel_file='model.xlsx'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        run_excel_trade_report - Creates an Excel spreadsheet with model returns and latest trades\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy (can be a list)\\n\\n        '\n    trading_model_list = trading_model\n    if not isinstance(trading_model_list, list):\n        trading_model_list = [trading_model]\n    writer = pandas.ExcelWriter(excel_file, engine='xlsxwriter')\n    for tm in trading_model_list:\n        strategy_name = tm.FINAL_STRATEGY\n        returns = tm.strategy_group_benchmark_pnl()\n        returns.to_excel(writer, sheet_name=strategy_name + ' rets', engine='xlsxwriter')\n        self.save_positions_trades(tm, tm.strategy_signal(), tm.strategy_trade(), 'pos', 'trades', writer)\n        if hasattr(tm, '_strategy_signal_notional'):\n            signal_notional = tm.strategy_signal_notional()\n            trading_notional = tm.strategy_signal_notional()\n            if signal_notional is not None and trading_notional is not None:\n                self.save_positions_trades(tm, signal_notional, trading_notional, 'pos - Not', 'trades - Not', writer)\n        if hasattr(tm, '_strategy_signal_contracts'):\n            signal_contracts = tm.strategy_signal_contracts()\n            trade_contracts = tm.strategy_trade_contracts()\n            if signal_contracts is not None and trade_contracts is not None:\n                self.save_positions_trades(tm, signal_contracts, trade_contracts, 'pos - Cont', 'trades - Cont', writer)\n    writer.save()\n    writer.close()",
            "def run_excel_trade_report(self, trading_model, excel_file='model.xlsx'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        run_excel_trade_report - Creates an Excel spreadsheet with model returns and latest trades\\n\\n        Parameters\\n        ----------\\n        trading_model : TradingModel\\n            defining trading strategy (can be a list)\\n\\n        '\n    trading_model_list = trading_model\n    if not isinstance(trading_model_list, list):\n        trading_model_list = [trading_model]\n    writer = pandas.ExcelWriter(excel_file, engine='xlsxwriter')\n    for tm in trading_model_list:\n        strategy_name = tm.FINAL_STRATEGY\n        returns = tm.strategy_group_benchmark_pnl()\n        returns.to_excel(writer, sheet_name=strategy_name + ' rets', engine='xlsxwriter')\n        self.save_positions_trades(tm, tm.strategy_signal(), tm.strategy_trade(), 'pos', 'trades', writer)\n        if hasattr(tm, '_strategy_signal_notional'):\n            signal_notional = tm.strategy_signal_notional()\n            trading_notional = tm.strategy_signal_notional()\n            if signal_notional is not None and trading_notional is not None:\n                self.save_positions_trades(tm, signal_notional, trading_notional, 'pos - Not', 'trades - Not', writer)\n        if hasattr(tm, '_strategy_signal_contracts'):\n            signal_contracts = tm.strategy_signal_contracts()\n            trade_contracts = tm.strategy_trade_contracts()\n            if signal_contracts is not None and trade_contracts is not None:\n                self.save_positions_trades(tm, signal_contracts, trade_contracts, 'pos - Cont', 'trades - Cont', writer)\n    writer.save()\n    writer.close()"
        ]
    },
    {
        "func_name": "save_positions_trades",
        "original": "def save_positions_trades(self, tm, signals, trades, signal_caption, trade_caption, writer):\n    signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' hist ' + signal_caption, engine='xlsxwriter')\n    if hasattr(tm, 'STRIP'):\n        strip = tm.STRIP\n    else:\n        strip = ''\n    recent_signals = tm._grab_signals(signals, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_trades = tm._grab_signals(trades, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + signal_caption, engine='xlsxwriter')\n    recent_trades.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + trade_caption, engine='xlsxwriter')",
        "mutated": [
            "def save_positions_trades(self, tm, signals, trades, signal_caption, trade_caption, writer):\n    if False:\n        i = 10\n    signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' hist ' + signal_caption, engine='xlsxwriter')\n    if hasattr(tm, 'STRIP'):\n        strip = tm.STRIP\n    else:\n        strip = ''\n    recent_signals = tm._grab_signals(signals, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_trades = tm._grab_signals(trades, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + signal_caption, engine='xlsxwriter')\n    recent_trades.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + trade_caption, engine='xlsxwriter')",
            "def save_positions_trades(self, tm, signals, trades, signal_caption, trade_caption, writer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' hist ' + signal_caption, engine='xlsxwriter')\n    if hasattr(tm, 'STRIP'):\n        strip = tm.STRIP\n    else:\n        strip = ''\n    recent_signals = tm._grab_signals(signals, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_trades = tm._grab_signals(trades, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + signal_caption, engine='xlsxwriter')\n    recent_trades.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + trade_caption, engine='xlsxwriter')",
            "def save_positions_trades(self, tm, signals, trades, signal_caption, trade_caption, writer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' hist ' + signal_caption, engine='xlsxwriter')\n    if hasattr(tm, 'STRIP'):\n        strip = tm.STRIP\n    else:\n        strip = ''\n    recent_signals = tm._grab_signals(signals, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_trades = tm._grab_signals(trades, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + signal_caption, engine='xlsxwriter')\n    recent_trades.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + trade_caption, engine='xlsxwriter')",
            "def save_positions_trades(self, tm, signals, trades, signal_caption, trade_caption, writer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' hist ' + signal_caption, engine='xlsxwriter')\n    if hasattr(tm, 'STRIP'):\n        strip = tm.STRIP\n    else:\n        strip = ''\n    recent_signals = tm._grab_signals(signals, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_trades = tm._grab_signals(trades, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + signal_caption, engine='xlsxwriter')\n    recent_trades.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + trade_caption, engine='xlsxwriter')",
            "def save_positions_trades(self, tm, signals, trades, signal_caption, trade_caption, writer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' hist ' + signal_caption, engine='xlsxwriter')\n    if hasattr(tm, 'STRIP'):\n        strip = tm.STRIP\n    else:\n        strip = ''\n    recent_signals = tm._grab_signals(signals, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_trades = tm._grab_signals(trades, date=[-1, -2, -5, -10, -20], strip=strip)\n    recent_signals.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + signal_caption, engine='xlsxwriter')\n    recent_trades.to_excel(writer, sheet_name=tm.FINAL_STRATEGY + ' ' + trade_caption, engine='xlsxwriter')"
        ]
    },
    {
        "func_name": "run_tc_shock",
        "original": "def run_tc_shock(self, strategy, tc=None, run_in_parallel=False, reload_market_data=True):\n    if tc is None:\n        tc = [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]\n    parameter_list = [{'spot_tc_bp': x} for x in tc]\n    pretty_portfolio_names = [str(x) + 'bp' for x in tc]\n    parameter_type = 'TC analysis'\n    return self.run_arbitrary_sensitivity(strategy, parameter_list=parameter_list, pretty_portfolio_names=pretty_portfolio_names, parameter_type=parameter_type, run_in_parallel=run_in_parallel, reload_market_data=reload_market_data)",
        "mutated": [
            "def run_tc_shock(self, strategy, tc=None, run_in_parallel=False, reload_market_data=True):\n    if False:\n        i = 10\n    if tc is None:\n        tc = [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]\n    parameter_list = [{'spot_tc_bp': x} for x in tc]\n    pretty_portfolio_names = [str(x) + 'bp' for x in tc]\n    parameter_type = 'TC analysis'\n    return self.run_arbitrary_sensitivity(strategy, parameter_list=parameter_list, pretty_portfolio_names=pretty_portfolio_names, parameter_type=parameter_type, run_in_parallel=run_in_parallel, reload_market_data=reload_market_data)",
            "def run_tc_shock(self, strategy, tc=None, run_in_parallel=False, reload_market_data=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if tc is None:\n        tc = [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]\n    parameter_list = [{'spot_tc_bp': x} for x in tc]\n    pretty_portfolio_names = [str(x) + 'bp' for x in tc]\n    parameter_type = 'TC analysis'\n    return self.run_arbitrary_sensitivity(strategy, parameter_list=parameter_list, pretty_portfolio_names=pretty_portfolio_names, parameter_type=parameter_type, run_in_parallel=run_in_parallel, reload_market_data=reload_market_data)",
            "def run_tc_shock(self, strategy, tc=None, run_in_parallel=False, reload_market_data=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if tc is None:\n        tc = [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]\n    parameter_list = [{'spot_tc_bp': x} for x in tc]\n    pretty_portfolio_names = [str(x) + 'bp' for x in tc]\n    parameter_type = 'TC analysis'\n    return self.run_arbitrary_sensitivity(strategy, parameter_list=parameter_list, pretty_portfolio_names=pretty_portfolio_names, parameter_type=parameter_type, run_in_parallel=run_in_parallel, reload_market_data=reload_market_data)",
            "def run_tc_shock(self, strategy, tc=None, run_in_parallel=False, reload_market_data=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if tc is None:\n        tc = [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]\n    parameter_list = [{'spot_tc_bp': x} for x in tc]\n    pretty_portfolio_names = [str(x) + 'bp' for x in tc]\n    parameter_type = 'TC analysis'\n    return self.run_arbitrary_sensitivity(strategy, parameter_list=parameter_list, pretty_portfolio_names=pretty_portfolio_names, parameter_type=parameter_type, run_in_parallel=run_in_parallel, reload_market_data=reload_market_data)",
            "def run_tc_shock(self, strategy, tc=None, run_in_parallel=False, reload_market_data=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if tc is None:\n        tc = [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]\n    parameter_list = [{'spot_tc_bp': x} for x in tc]\n    pretty_portfolio_names = [str(x) + 'bp' for x in tc]\n    parameter_type = 'TC analysis'\n    return self.run_arbitrary_sensitivity(strategy, parameter_list=parameter_list, pretty_portfolio_names=pretty_portfolio_names, parameter_type=parameter_type, run_in_parallel=run_in_parallel, reload_market_data=reload_market_data)"
        ]
    },
    {
        "func_name": "run_arbitrary_sensitivity",
        "original": "def run_arbitrary_sensitivity(self, trading_model, parameter_list=None, pretty_portfolio_names=None, parameter_type=None, run_in_parallel=False, reload_market_data=True, plot=True):\n    if not reload_market_data:\n        (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model)\n    port_list = []\n    ret_stats_list = []\n    if market_constants.backtest_thread_no[market_constants.generic_plat] > 1 and run_in_parallel:\n        swim_pool = SwimPool(multiprocessing_library=market_constants.multiprocessing_library)\n        pool = swim_pool.create_pool(thread_technique=market_constants.backtest_thread_technique, thread_no=market_constants.backtest_thread_no[market_constants.generic_plat])\n        mult_results = []\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            mult_results.append(pool.apply_async(self._run_strategy, args=(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])))\n        for p in mult_results:\n            (port, ret_stats) = p.get()\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n        try:\n            swim_pool.close_pool(pool)\n        except:\n            pass\n    else:\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            (port, ret_stats) = self._run_strategy(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n    port_list = Calculations().join(port_list, how='outer')\n    trading_model.br = trading_model.load_parameters()\n    style = Style()\n    ir = [t.inforatio()[0] for t in ret_stats_list]\n    rets = [t.ann_returns()[0] for t in ret_stats_list]\n    pretty_portfolio_names = [str(p) for p in pretty_portfolio_names]\n    style.resample = 'B'\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    if plot:\n        self.chart.plot(port_list, chart_type='line', style=style)\n    style = Style()\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    summary_ir = pandas.DataFrame(index=pretty_portfolio_names, data=ir, columns=['IR'])\n    if plot:\n        self.chart.plot(summary_ir, chart_type='bar', style=style)\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.html'\n    summary_rets = pandas.DataFrame(index=pretty_portfolio_names, data=rets, columns=['Rets (%)']) * 100\n    if plot:\n        self.chart.plot(summary_rets, chart_type='bar', style=style)\n    return (port_list, summary_ir, summary_rets)",
        "mutated": [
            "def run_arbitrary_sensitivity(self, trading_model, parameter_list=None, pretty_portfolio_names=None, parameter_type=None, run_in_parallel=False, reload_market_data=True, plot=True):\n    if False:\n        i = 10\n    if not reload_market_data:\n        (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model)\n    port_list = []\n    ret_stats_list = []\n    if market_constants.backtest_thread_no[market_constants.generic_plat] > 1 and run_in_parallel:\n        swim_pool = SwimPool(multiprocessing_library=market_constants.multiprocessing_library)\n        pool = swim_pool.create_pool(thread_technique=market_constants.backtest_thread_technique, thread_no=market_constants.backtest_thread_no[market_constants.generic_plat])\n        mult_results = []\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            mult_results.append(pool.apply_async(self._run_strategy, args=(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])))\n        for p in mult_results:\n            (port, ret_stats) = p.get()\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n        try:\n            swim_pool.close_pool(pool)\n        except:\n            pass\n    else:\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            (port, ret_stats) = self._run_strategy(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n    port_list = Calculations().join(port_list, how='outer')\n    trading_model.br = trading_model.load_parameters()\n    style = Style()\n    ir = [t.inforatio()[0] for t in ret_stats_list]\n    rets = [t.ann_returns()[0] for t in ret_stats_list]\n    pretty_portfolio_names = [str(p) for p in pretty_portfolio_names]\n    style.resample = 'B'\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    if plot:\n        self.chart.plot(port_list, chart_type='line', style=style)\n    style = Style()\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    summary_ir = pandas.DataFrame(index=pretty_portfolio_names, data=ir, columns=['IR'])\n    if plot:\n        self.chart.plot(summary_ir, chart_type='bar', style=style)\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.html'\n    summary_rets = pandas.DataFrame(index=pretty_portfolio_names, data=rets, columns=['Rets (%)']) * 100\n    if plot:\n        self.chart.plot(summary_rets, chart_type='bar', style=style)\n    return (port_list, summary_ir, summary_rets)",
            "def run_arbitrary_sensitivity(self, trading_model, parameter_list=None, pretty_portfolio_names=None, parameter_type=None, run_in_parallel=False, reload_market_data=True, plot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not reload_market_data:\n        (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model)\n    port_list = []\n    ret_stats_list = []\n    if market_constants.backtest_thread_no[market_constants.generic_plat] > 1 and run_in_parallel:\n        swim_pool = SwimPool(multiprocessing_library=market_constants.multiprocessing_library)\n        pool = swim_pool.create_pool(thread_technique=market_constants.backtest_thread_technique, thread_no=market_constants.backtest_thread_no[market_constants.generic_plat])\n        mult_results = []\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            mult_results.append(pool.apply_async(self._run_strategy, args=(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])))\n        for p in mult_results:\n            (port, ret_stats) = p.get()\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n        try:\n            swim_pool.close_pool(pool)\n        except:\n            pass\n    else:\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            (port, ret_stats) = self._run_strategy(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n    port_list = Calculations().join(port_list, how='outer')\n    trading_model.br = trading_model.load_parameters()\n    style = Style()\n    ir = [t.inforatio()[0] for t in ret_stats_list]\n    rets = [t.ann_returns()[0] for t in ret_stats_list]\n    pretty_portfolio_names = [str(p) for p in pretty_portfolio_names]\n    style.resample = 'B'\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    if plot:\n        self.chart.plot(port_list, chart_type='line', style=style)\n    style = Style()\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    summary_ir = pandas.DataFrame(index=pretty_portfolio_names, data=ir, columns=['IR'])\n    if plot:\n        self.chart.plot(summary_ir, chart_type='bar', style=style)\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.html'\n    summary_rets = pandas.DataFrame(index=pretty_portfolio_names, data=rets, columns=['Rets (%)']) * 100\n    if plot:\n        self.chart.plot(summary_rets, chart_type='bar', style=style)\n    return (port_list, summary_ir, summary_rets)",
            "def run_arbitrary_sensitivity(self, trading_model, parameter_list=None, pretty_portfolio_names=None, parameter_type=None, run_in_parallel=False, reload_market_data=True, plot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not reload_market_data:\n        (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model)\n    port_list = []\n    ret_stats_list = []\n    if market_constants.backtest_thread_no[market_constants.generic_plat] > 1 and run_in_parallel:\n        swim_pool = SwimPool(multiprocessing_library=market_constants.multiprocessing_library)\n        pool = swim_pool.create_pool(thread_technique=market_constants.backtest_thread_technique, thread_no=market_constants.backtest_thread_no[market_constants.generic_plat])\n        mult_results = []\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            mult_results.append(pool.apply_async(self._run_strategy, args=(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])))\n        for p in mult_results:\n            (port, ret_stats) = p.get()\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n        try:\n            swim_pool.close_pool(pool)\n        except:\n            pass\n    else:\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            (port, ret_stats) = self._run_strategy(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n    port_list = Calculations().join(port_list, how='outer')\n    trading_model.br = trading_model.load_parameters()\n    style = Style()\n    ir = [t.inforatio()[0] for t in ret_stats_list]\n    rets = [t.ann_returns()[0] for t in ret_stats_list]\n    pretty_portfolio_names = [str(p) for p in pretty_portfolio_names]\n    style.resample = 'B'\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    if plot:\n        self.chart.plot(port_list, chart_type='line', style=style)\n    style = Style()\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    summary_ir = pandas.DataFrame(index=pretty_portfolio_names, data=ir, columns=['IR'])\n    if plot:\n        self.chart.plot(summary_ir, chart_type='bar', style=style)\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.html'\n    summary_rets = pandas.DataFrame(index=pretty_portfolio_names, data=rets, columns=['Rets (%)']) * 100\n    if plot:\n        self.chart.plot(summary_rets, chart_type='bar', style=style)\n    return (port_list, summary_ir, summary_rets)",
            "def run_arbitrary_sensitivity(self, trading_model, parameter_list=None, pretty_portfolio_names=None, parameter_type=None, run_in_parallel=False, reload_market_data=True, plot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not reload_market_data:\n        (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model)\n    port_list = []\n    ret_stats_list = []\n    if market_constants.backtest_thread_no[market_constants.generic_plat] > 1 and run_in_parallel:\n        swim_pool = SwimPool(multiprocessing_library=market_constants.multiprocessing_library)\n        pool = swim_pool.create_pool(thread_technique=market_constants.backtest_thread_technique, thread_no=market_constants.backtest_thread_no[market_constants.generic_plat])\n        mult_results = []\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            mult_results.append(pool.apply_async(self._run_strategy, args=(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])))\n        for p in mult_results:\n            (port, ret_stats) = p.get()\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n        try:\n            swim_pool.close_pool(pool)\n        except:\n            pass\n    else:\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            (port, ret_stats) = self._run_strategy(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n    port_list = Calculations().join(port_list, how='outer')\n    trading_model.br = trading_model.load_parameters()\n    style = Style()\n    ir = [t.inforatio()[0] for t in ret_stats_list]\n    rets = [t.ann_returns()[0] for t in ret_stats_list]\n    pretty_portfolio_names = [str(p) for p in pretty_portfolio_names]\n    style.resample = 'B'\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    if plot:\n        self.chart.plot(port_list, chart_type='line', style=style)\n    style = Style()\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    summary_ir = pandas.DataFrame(index=pretty_portfolio_names, data=ir, columns=['IR'])\n    if plot:\n        self.chart.plot(summary_ir, chart_type='bar', style=style)\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.html'\n    summary_rets = pandas.DataFrame(index=pretty_portfolio_names, data=rets, columns=['Rets (%)']) * 100\n    if plot:\n        self.chart.plot(summary_rets, chart_type='bar', style=style)\n    return (port_list, summary_ir, summary_rets)",
            "def run_arbitrary_sensitivity(self, trading_model, parameter_list=None, pretty_portfolio_names=None, parameter_type=None, run_in_parallel=False, reload_market_data=True, plot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not reload_market_data:\n        (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model)\n    port_list = []\n    ret_stats_list = []\n    if market_constants.backtest_thread_no[market_constants.generic_plat] > 1 and run_in_parallel:\n        swim_pool = SwimPool(multiprocessing_library=market_constants.multiprocessing_library)\n        pool = swim_pool.create_pool(thread_technique=market_constants.backtest_thread_technique, thread_no=market_constants.backtest_thread_no[market_constants.generic_plat])\n        mult_results = []\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            mult_results.append(pool.apply_async(self._run_strategy, args=(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])))\n        for p in mult_results:\n            (port, ret_stats) = p.get()\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n        try:\n            swim_pool.close_pool(pool)\n        except:\n            pass\n    else:\n        for i in range(0, len(parameter_list)):\n            br = copy.copy(trading_model.load_parameters())\n            current_parameter = parameter_list[i]\n            for k in current_parameter.keys():\n                setattr(br, k, current_parameter[k])\n                setattr(br.tech_params, k, current_parameter[k])\n            if reload_market_data:\n                (asset_df, spot_df, spot_df2, basket_dict, contract_value_df) = self._load_assets(trading_model, br=br)\n            (port, ret_stats) = self._run_strategy(trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_names[i])\n            port_list.append(port)\n            ret_stats_list.append(ret_stats)\n    port_list = Calculations().join(port_list, how='outer')\n    trading_model.br = trading_model.load_parameters()\n    style = Style()\n    ir = [t.inforatio()[0] for t in ret_stats_list]\n    rets = [t.ann_returns()[0] for t in ret_stats_list]\n    pretty_portfolio_names = [str(p) for p in pretty_portfolio_names]\n    style.resample = 'B'\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + '.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    if plot:\n        self.chart.plot(port_list, chart_type='line', style=style)\n    style = Style()\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' IR.html'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.title = trading_model.FINAL_STRATEGY + ' ' + parameter_type\n    summary_ir = pandas.DataFrame(index=pretty_portfolio_names, data=ir, columns=['IR'])\n    if plot:\n        self.chart.plot(summary_ir, chart_type='bar', style=style)\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' ' + parameter_type + ' Rets.html'\n    summary_rets = pandas.DataFrame(index=pretty_portfolio_names, data=rets, columns=['Rets (%)']) * 100\n    if plot:\n        self.chart.plot(summary_rets, chart_type='bar', style=style)\n    return (port_list, summary_ir, summary_rets)"
        ]
    },
    {
        "func_name": "_load_assets",
        "original": "def _load_assets(self, trading_model, br):\n    assets = trading_model.load_assets(br=br)\n    asset_df = assets[0]\n    spot_df = assets[1]\n    spot_df2 = assets[2]\n    basket_dict = assets[3]\n    if len(assets) == 5:\n        contract_value_df = assets[4]\n    contract_value_df = None\n    return (asset_df, spot_df, spot_df2, basket_dict, contract_value_df)",
        "mutated": [
            "def _load_assets(self, trading_model, br):\n    if False:\n        i = 10\n    assets = trading_model.load_assets(br=br)\n    asset_df = assets[0]\n    spot_df = assets[1]\n    spot_df2 = assets[2]\n    basket_dict = assets[3]\n    if len(assets) == 5:\n        contract_value_df = assets[4]\n    contract_value_df = None\n    return (asset_df, spot_df, spot_df2, basket_dict, contract_value_df)",
            "def _load_assets(self, trading_model, br):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assets = trading_model.load_assets(br=br)\n    asset_df = assets[0]\n    spot_df = assets[1]\n    spot_df2 = assets[2]\n    basket_dict = assets[3]\n    if len(assets) == 5:\n        contract_value_df = assets[4]\n    contract_value_df = None\n    return (asset_df, spot_df, spot_df2, basket_dict, contract_value_df)",
            "def _load_assets(self, trading_model, br):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assets = trading_model.load_assets(br=br)\n    asset_df = assets[0]\n    spot_df = assets[1]\n    spot_df2 = assets[2]\n    basket_dict = assets[3]\n    if len(assets) == 5:\n        contract_value_df = assets[4]\n    contract_value_df = None\n    return (asset_df, spot_df, spot_df2, basket_dict, contract_value_df)",
            "def _load_assets(self, trading_model, br):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assets = trading_model.load_assets(br=br)\n    asset_df = assets[0]\n    spot_df = assets[1]\n    spot_df2 = assets[2]\n    basket_dict = assets[3]\n    if len(assets) == 5:\n        contract_value_df = assets[4]\n    contract_value_df = None\n    return (asset_df, spot_df, spot_df2, basket_dict, contract_value_df)",
            "def _load_assets(self, trading_model, br):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assets = trading_model.load_assets(br=br)\n    asset_df = assets[0]\n    spot_df = assets[1]\n    spot_df2 = assets[2]\n    basket_dict = assets[3]\n    if len(assets) == 5:\n        contract_value_df = assets[4]\n    contract_value_df = None\n    return (asset_df, spot_df, spot_df2, basket_dict, contract_value_df)"
        ]
    },
    {
        "func_name": "_run_strategy",
        "original": "def _run_strategy(self, trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_name):\n    logger = LoggerManager().getLogger(__name__)\n    logger.info('Calculating... ' + str(pretty_portfolio_name))\n    signal_df = trading_model.construct_signal(spot_df, spot_df2, br.tech_params, br, run_in_parallel=False)\n    backtest = Backtest()\n    backtest.calculate_trading_PnL(br, asset_df, signal_df, contract_value_df, False)\n    ret_stats = backtest.portfolio_pnl_ret_stats()\n    stats = str(backtest.portfolio_pnl_desc()[0])\n    port = backtest.portfolio_cum().resample('B').mean()\n    port.columns = [str(pretty_portfolio_name) + ' ' + stats]\n    return (port, ret_stats)",
        "mutated": [
            "def _run_strategy(self, trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_name):\n    if False:\n        i = 10\n    logger = LoggerManager().getLogger(__name__)\n    logger.info('Calculating... ' + str(pretty_portfolio_name))\n    signal_df = trading_model.construct_signal(spot_df, spot_df2, br.tech_params, br, run_in_parallel=False)\n    backtest = Backtest()\n    backtest.calculate_trading_PnL(br, asset_df, signal_df, contract_value_df, False)\n    ret_stats = backtest.portfolio_pnl_ret_stats()\n    stats = str(backtest.portfolio_pnl_desc()[0])\n    port = backtest.portfolio_cum().resample('B').mean()\n    port.columns = [str(pretty_portfolio_name) + ' ' + stats]\n    return (port, ret_stats)",
            "def _run_strategy(self, trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    logger = LoggerManager().getLogger(__name__)\n    logger.info('Calculating... ' + str(pretty_portfolio_name))\n    signal_df = trading_model.construct_signal(spot_df, spot_df2, br.tech_params, br, run_in_parallel=False)\n    backtest = Backtest()\n    backtest.calculate_trading_PnL(br, asset_df, signal_df, contract_value_df, False)\n    ret_stats = backtest.portfolio_pnl_ret_stats()\n    stats = str(backtest.portfolio_pnl_desc()[0])\n    port = backtest.portfolio_cum().resample('B').mean()\n    port.columns = [str(pretty_portfolio_name) + ' ' + stats]\n    return (port, ret_stats)",
            "def _run_strategy(self, trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    logger = LoggerManager().getLogger(__name__)\n    logger.info('Calculating... ' + str(pretty_portfolio_name))\n    signal_df = trading_model.construct_signal(spot_df, spot_df2, br.tech_params, br, run_in_parallel=False)\n    backtest = Backtest()\n    backtest.calculate_trading_PnL(br, asset_df, signal_df, contract_value_df, False)\n    ret_stats = backtest.portfolio_pnl_ret_stats()\n    stats = str(backtest.portfolio_pnl_desc()[0])\n    port = backtest.portfolio_cum().resample('B').mean()\n    port.columns = [str(pretty_portfolio_name) + ' ' + stats]\n    return (port, ret_stats)",
            "def _run_strategy(self, trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    logger = LoggerManager().getLogger(__name__)\n    logger.info('Calculating... ' + str(pretty_portfolio_name))\n    signal_df = trading_model.construct_signal(spot_df, spot_df2, br.tech_params, br, run_in_parallel=False)\n    backtest = Backtest()\n    backtest.calculate_trading_PnL(br, asset_df, signal_df, contract_value_df, False)\n    ret_stats = backtest.portfolio_pnl_ret_stats()\n    stats = str(backtest.portfolio_pnl_desc()[0])\n    port = backtest.portfolio_cum().resample('B').mean()\n    port.columns = [str(pretty_portfolio_name) + ' ' + stats]\n    return (port, ret_stats)",
            "def _run_strategy(self, trading_model, asset_df, spot_df, spot_df2, br, contract_value_df, pretty_portfolio_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    logger = LoggerManager().getLogger(__name__)\n    logger.info('Calculating... ' + str(pretty_portfolio_name))\n    signal_df = trading_model.construct_signal(spot_df, spot_df2, br.tech_params, br, run_in_parallel=False)\n    backtest = Backtest()\n    backtest.calculate_trading_PnL(br, asset_df, signal_df, contract_value_df, False)\n    ret_stats = backtest.portfolio_pnl_ret_stats()\n    stats = str(backtest.portfolio_pnl_desc()[0])\n    port = backtest.portfolio_cum().resample('B').mean()\n    port.columns = [str(pretty_portfolio_name) + ' ' + stats]\n    return (port, ret_stats)"
        ]
    },
    {
        "func_name": "run_arbitrary_sensitivity_separately",
        "original": "def run_arbitrary_sensitivity_separately(self, trading_model, parameter_list=None, pretty_portfolio_names=None, strip=None):\n    final_strategy = trading_model.FINAL_STRATEGY\n    for i in range(0, len(parameter_list)):\n        br = trading_model.fill_backtest_request()\n        current_parameter = parameter_list[i]\n        for k in current_parameter.keys():\n            setattr(br, k, current_parameter[k])\n        trading_model.FINAL_STRATEGY = final_strategy + ' ' + pretty_portfolio_names[i]\n        self.logger.info('Calculating... ' + pretty_portfolio_names[i])\n        trading_model.br = br\n        trading_model.construct_strategy(br=br)\n        trading_model.plot_strategy_pnl()\n        trading_model.plot_strategy_leverage()\n        trading_model.plot_strategy_group_benchmark_pnl(strip=strip)\n    trading_model.br = trading_model.fill_backtest_request()\n    trading_model.FINAL_STRATEGY = final_strategy",
        "mutated": [
            "def run_arbitrary_sensitivity_separately(self, trading_model, parameter_list=None, pretty_portfolio_names=None, strip=None):\n    if False:\n        i = 10\n    final_strategy = trading_model.FINAL_STRATEGY\n    for i in range(0, len(parameter_list)):\n        br = trading_model.fill_backtest_request()\n        current_parameter = parameter_list[i]\n        for k in current_parameter.keys():\n            setattr(br, k, current_parameter[k])\n        trading_model.FINAL_STRATEGY = final_strategy + ' ' + pretty_portfolio_names[i]\n        self.logger.info('Calculating... ' + pretty_portfolio_names[i])\n        trading_model.br = br\n        trading_model.construct_strategy(br=br)\n        trading_model.plot_strategy_pnl()\n        trading_model.plot_strategy_leverage()\n        trading_model.plot_strategy_group_benchmark_pnl(strip=strip)\n    trading_model.br = trading_model.fill_backtest_request()\n    trading_model.FINAL_STRATEGY = final_strategy",
            "def run_arbitrary_sensitivity_separately(self, trading_model, parameter_list=None, pretty_portfolio_names=None, strip=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    final_strategy = trading_model.FINAL_STRATEGY\n    for i in range(0, len(parameter_list)):\n        br = trading_model.fill_backtest_request()\n        current_parameter = parameter_list[i]\n        for k in current_parameter.keys():\n            setattr(br, k, current_parameter[k])\n        trading_model.FINAL_STRATEGY = final_strategy + ' ' + pretty_portfolio_names[i]\n        self.logger.info('Calculating... ' + pretty_portfolio_names[i])\n        trading_model.br = br\n        trading_model.construct_strategy(br=br)\n        trading_model.plot_strategy_pnl()\n        trading_model.plot_strategy_leverage()\n        trading_model.plot_strategy_group_benchmark_pnl(strip=strip)\n    trading_model.br = trading_model.fill_backtest_request()\n    trading_model.FINAL_STRATEGY = final_strategy",
            "def run_arbitrary_sensitivity_separately(self, trading_model, parameter_list=None, pretty_portfolio_names=None, strip=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    final_strategy = trading_model.FINAL_STRATEGY\n    for i in range(0, len(parameter_list)):\n        br = trading_model.fill_backtest_request()\n        current_parameter = parameter_list[i]\n        for k in current_parameter.keys():\n            setattr(br, k, current_parameter[k])\n        trading_model.FINAL_STRATEGY = final_strategy + ' ' + pretty_portfolio_names[i]\n        self.logger.info('Calculating... ' + pretty_portfolio_names[i])\n        trading_model.br = br\n        trading_model.construct_strategy(br=br)\n        trading_model.plot_strategy_pnl()\n        trading_model.plot_strategy_leverage()\n        trading_model.plot_strategy_group_benchmark_pnl(strip=strip)\n    trading_model.br = trading_model.fill_backtest_request()\n    trading_model.FINAL_STRATEGY = final_strategy",
            "def run_arbitrary_sensitivity_separately(self, trading_model, parameter_list=None, pretty_portfolio_names=None, strip=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    final_strategy = trading_model.FINAL_STRATEGY\n    for i in range(0, len(parameter_list)):\n        br = trading_model.fill_backtest_request()\n        current_parameter = parameter_list[i]\n        for k in current_parameter.keys():\n            setattr(br, k, current_parameter[k])\n        trading_model.FINAL_STRATEGY = final_strategy + ' ' + pretty_portfolio_names[i]\n        self.logger.info('Calculating... ' + pretty_portfolio_names[i])\n        trading_model.br = br\n        trading_model.construct_strategy(br=br)\n        trading_model.plot_strategy_pnl()\n        trading_model.plot_strategy_leverage()\n        trading_model.plot_strategy_group_benchmark_pnl(strip=strip)\n    trading_model.br = trading_model.fill_backtest_request()\n    trading_model.FINAL_STRATEGY = final_strategy",
            "def run_arbitrary_sensitivity_separately(self, trading_model, parameter_list=None, pretty_portfolio_names=None, strip=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    final_strategy = trading_model.FINAL_STRATEGY\n    for i in range(0, len(parameter_list)):\n        br = trading_model.fill_backtest_request()\n        current_parameter = parameter_list[i]\n        for k in current_parameter.keys():\n            setattr(br, k, current_parameter[k])\n        trading_model.FINAL_STRATEGY = final_strategy + ' ' + pretty_portfolio_names[i]\n        self.logger.info('Calculating... ' + pretty_portfolio_names[i])\n        trading_model.br = br\n        trading_model.construct_strategy(br=br)\n        trading_model.plot_strategy_pnl()\n        trading_model.plot_strategy_leverage()\n        trading_model.plot_strategy_group_benchmark_pnl(strip=strip)\n    trading_model.br = trading_model.fill_backtest_request()\n    trading_model.FINAL_STRATEGY = final_strategy"
        ]
    },
    {
        "func_name": "run_day_of_month_analysis",
        "original": "def run_day_of_month_analysis(self, trading_model, resample_freq='B'):\n    from finmarketpy.economics.seasonality import Seasonality\n    logger = LoggerManager().getLogger(__name__)\n    calculations = Calculations()\n    seas = Seasonality()\n    trading_model.construct_strategy()\n    pnl = trading_model.strategy_pnl()\n    pnl = pnl.resample('B').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    bus_day = seas.bus_day_of_month_seasonality(rets, add_average=True, resample_freq=resample_freq)\n    pnl = pnl.resample('BM').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    month = seas.monthly_seasonality(rets)\n    logger.info('About to plot seasonality...')\n    style = Style()\n    style.color = 'Blues'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.html'\n    style.title = trading_model.FINAL_STRATEGY + ' day of month seasonality'\n    style.display_legend = False\n    style.color_2_series = [bus_day.columns[-1]]\n    style.color_2 = ['red']\n    style.linewidth_2 = 4\n    style.linewidth_2_series = [bus_day.columns[-1]]\n    style.y_axis_2_series = [bus_day.columns[-1]]\n    self.chart.plot(bus_day, chart_type='line', style=style)\n    style = Style()\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.html'\n    style.title = trading_model.FINAL_STRATEGY + ' month of year seasonality'\n    self.chart.plot(month, chart_type='line', style=style)\n    return month",
        "mutated": [
            "def run_day_of_month_analysis(self, trading_model, resample_freq='B'):\n    if False:\n        i = 10\n    from finmarketpy.economics.seasonality import Seasonality\n    logger = LoggerManager().getLogger(__name__)\n    calculations = Calculations()\n    seas = Seasonality()\n    trading_model.construct_strategy()\n    pnl = trading_model.strategy_pnl()\n    pnl = pnl.resample('B').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    bus_day = seas.bus_day_of_month_seasonality(rets, add_average=True, resample_freq=resample_freq)\n    pnl = pnl.resample('BM').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    month = seas.monthly_seasonality(rets)\n    logger.info('About to plot seasonality...')\n    style = Style()\n    style.color = 'Blues'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.html'\n    style.title = trading_model.FINAL_STRATEGY + ' day of month seasonality'\n    style.display_legend = False\n    style.color_2_series = [bus_day.columns[-1]]\n    style.color_2 = ['red']\n    style.linewidth_2 = 4\n    style.linewidth_2_series = [bus_day.columns[-1]]\n    style.y_axis_2_series = [bus_day.columns[-1]]\n    self.chart.plot(bus_day, chart_type='line', style=style)\n    style = Style()\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.html'\n    style.title = trading_model.FINAL_STRATEGY + ' month of year seasonality'\n    self.chart.plot(month, chart_type='line', style=style)\n    return month",
            "def run_day_of_month_analysis(self, trading_model, resample_freq='B'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from finmarketpy.economics.seasonality import Seasonality\n    logger = LoggerManager().getLogger(__name__)\n    calculations = Calculations()\n    seas = Seasonality()\n    trading_model.construct_strategy()\n    pnl = trading_model.strategy_pnl()\n    pnl = pnl.resample('B').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    bus_day = seas.bus_day_of_month_seasonality(rets, add_average=True, resample_freq=resample_freq)\n    pnl = pnl.resample('BM').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    month = seas.monthly_seasonality(rets)\n    logger.info('About to plot seasonality...')\n    style = Style()\n    style.color = 'Blues'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.html'\n    style.title = trading_model.FINAL_STRATEGY + ' day of month seasonality'\n    style.display_legend = False\n    style.color_2_series = [bus_day.columns[-1]]\n    style.color_2 = ['red']\n    style.linewidth_2 = 4\n    style.linewidth_2_series = [bus_day.columns[-1]]\n    style.y_axis_2_series = [bus_day.columns[-1]]\n    self.chart.plot(bus_day, chart_type='line', style=style)\n    style = Style()\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.html'\n    style.title = trading_model.FINAL_STRATEGY + ' month of year seasonality'\n    self.chart.plot(month, chart_type='line', style=style)\n    return month",
            "def run_day_of_month_analysis(self, trading_model, resample_freq='B'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from finmarketpy.economics.seasonality import Seasonality\n    logger = LoggerManager().getLogger(__name__)\n    calculations = Calculations()\n    seas = Seasonality()\n    trading_model.construct_strategy()\n    pnl = trading_model.strategy_pnl()\n    pnl = pnl.resample('B').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    bus_day = seas.bus_day_of_month_seasonality(rets, add_average=True, resample_freq=resample_freq)\n    pnl = pnl.resample('BM').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    month = seas.monthly_seasonality(rets)\n    logger.info('About to plot seasonality...')\n    style = Style()\n    style.color = 'Blues'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.html'\n    style.title = trading_model.FINAL_STRATEGY + ' day of month seasonality'\n    style.display_legend = False\n    style.color_2_series = [bus_day.columns[-1]]\n    style.color_2 = ['red']\n    style.linewidth_2 = 4\n    style.linewidth_2_series = [bus_day.columns[-1]]\n    style.y_axis_2_series = [bus_day.columns[-1]]\n    self.chart.plot(bus_day, chart_type='line', style=style)\n    style = Style()\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.html'\n    style.title = trading_model.FINAL_STRATEGY + ' month of year seasonality'\n    self.chart.plot(month, chart_type='line', style=style)\n    return month",
            "def run_day_of_month_analysis(self, trading_model, resample_freq='B'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from finmarketpy.economics.seasonality import Seasonality\n    logger = LoggerManager().getLogger(__name__)\n    calculations = Calculations()\n    seas = Seasonality()\n    trading_model.construct_strategy()\n    pnl = trading_model.strategy_pnl()\n    pnl = pnl.resample('B').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    bus_day = seas.bus_day_of_month_seasonality(rets, add_average=True, resample_freq=resample_freq)\n    pnl = pnl.resample('BM').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    month = seas.monthly_seasonality(rets)\n    logger.info('About to plot seasonality...')\n    style = Style()\n    style.color = 'Blues'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.html'\n    style.title = trading_model.FINAL_STRATEGY + ' day of month seasonality'\n    style.display_legend = False\n    style.color_2_series = [bus_day.columns[-1]]\n    style.color_2 = ['red']\n    style.linewidth_2 = 4\n    style.linewidth_2_series = [bus_day.columns[-1]]\n    style.y_axis_2_series = [bus_day.columns[-1]]\n    self.chart.plot(bus_day, chart_type='line', style=style)\n    style = Style()\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.html'\n    style.title = trading_model.FINAL_STRATEGY + ' month of year seasonality'\n    self.chart.plot(month, chart_type='line', style=style)\n    return month",
            "def run_day_of_month_analysis(self, trading_model, resample_freq='B'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from finmarketpy.economics.seasonality import Seasonality\n    logger = LoggerManager().getLogger(__name__)\n    calculations = Calculations()\n    seas = Seasonality()\n    trading_model.construct_strategy()\n    pnl = trading_model.strategy_pnl()\n    pnl = pnl.resample('B').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    bus_day = seas.bus_day_of_month_seasonality(rets, add_average=True, resample_freq=resample_freq)\n    pnl = pnl.resample('BM').mean()\n    rets = calculations.calculate_returns(pnl).tz_localize(None)\n    month = seas.monthly_seasonality(rets)\n    logger.info('About to plot seasonality...')\n    style = Style()\n    style.color = 'Blues'\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality day of month.html'\n    style.title = trading_model.FINAL_STRATEGY + ' day of month seasonality'\n    style.display_legend = False\n    style.color_2_series = [bus_day.columns[-1]]\n    style.color_2 = ['red']\n    style.linewidth_2 = 4\n    style.linewidth_2_series = [bus_day.columns[-1]]\n    style.y_axis_2_series = [bus_day.columns[-1]]\n    self.chart.plot(bus_day, chart_type='line', style=style)\n    style = Style()\n    style.scale_factor = trading_model.SCALE_FACTOR\n    style.file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.png'\n    style.html_file_output = self.DUMP_PATH + trading_model.FINAL_STRATEGY + ' seasonality month of year.html'\n    style.title = trading_model.FINAL_STRATEGY + ' month of year seasonality'\n    self.chart.plot(month, chart_type='line', style=style)\n    return month"
        ]
    }
]