[
    {
        "func_name": "interpolate",
        "original": "def interpolate(x, y, x_new, axis=-1, out=None):\n    \"\"\"Return interpolated data using Akima's method.\n\n    This Python implementation is inspired by the Matlab(r) code by\n    N. Shamsundar. It lacks certain capabilities of the C implementation\n    such as the output array argument and interpolation along an axis of a\n    multidimensional data array.\n\n    Parameters\n    ----------\n    x : array like\n        1D array of monotonically increasing real values.\n    y : array like\n        N-D array of real values. y's length along the interpolation\n        axis must be equal to the length of x.\n    x_new : array like\n        New independent variables.\n    axis : int\n        Specifies axis of y along which to interpolate. Interpolation\n        defaults to last axis of y.\n    out : array\n        Optional array to receive results. Dimension at axis must equal\n        length of x.\n\n    Examples\n    --------\n    >>> interpolate([0, 1, 2], [0, 0, 1], [0.5, 1.5])\n    array([-0.125,  0.375])\n    >>> x = numpy.sort(numpy.random.random(10) * 10)\n    >>> y = numpy.random.normal(0.0, 0.1, size=len(x))\n    >>> z = interpolate(x, y, x)\n    >>> numpy.allclose(y, z)\n    True\n    >>> x = x[:10]\n    >>> y = numpy.reshape(y, (10, -1))\n    >>> z = numpy.reshape(y, (10, -1))\n    >>> interpolate(x, y, x, axis=0, out=z)\n    >>> numpy.allclose(y, z)\n    True\n\n    \"\"\"\n    x = numpy.array(x, dtype=numpy.float64, copy=True)\n    y = numpy.array(y, dtype=numpy.float64, copy=True)\n    xi = numpy.array(x_new, dtype=numpy.float64, copy=True)\n    if axis != -1 or out is not None or y.ndim != 1:\n        raise NotImplementedError('implemented in C extension module')\n    if x.ndim != 1 or xi.ndim != 1:\n        raise ValueError('x-arrays must be one dimensional')\n    n = len(x)\n    if n < 2:\n        raise ValueError('array too small')\n    if n != y.shape[axis]:\n        raise ValueError('size of x-array must match data shape')\n    dx = numpy.diff(x)\n    if any(dx <= 0.0):\n        raise ValueError('x-axis not valid')\n    if any(xi < x[0]) or any(xi > x[-1]):\n        raise ValueError('interpolation x-axis out of bounds')\n    m = numpy.diff(y) / dx\n    mm = 2.0 * m[0] - m[1]\n    mmm = 2.0 * mm - m[0]\n    mp = 2.0 * m[n - 2] - m[n - 3]\n    mpp = 2.0 * mp - m[n - 2]\n    m1 = numpy.concatenate(([mmm], [mm], m, [mp], [mpp]))\n    dm = numpy.abs(numpy.diff(m1))\n    f1 = dm[2:n + 2]\n    f2 = dm[0:n]\n    f12 = f1 + f2\n    ids = numpy.nonzero(f12 > 1e-09 * numpy.max(f12))[0]\n    b = m1[1:n + 1]\n    b[ids] = (f1[ids] * m1[ids + 1] + f2[ids] * m1[ids + 2]) / f12[ids]\n    c = (3.0 * m - 2.0 * b[0:n - 1] - b[1:n]) / dx\n    d = (b[0:n - 1] + b[1:n] - 2.0 * m) / dx ** 2\n    bins = numpy.digitize(xi, x)\n    bins = numpy.minimum(bins, n - 1) - 1\n    bb = bins[0:len(xi)]\n    wj = xi - x[bb]\n    return ((wj * d[bb] + c[bb]) * wj + b[bb]) * wj + y[bb]",
        "mutated": [
            "def interpolate(x, y, x_new, axis=-1, out=None):\n    if False:\n        i = 10\n    \"Return interpolated data using Akima's method.\\n\\n    This Python implementation is inspired by the Matlab(r) code by\\n    N. Shamsundar. It lacks certain capabilities of the C implementation\\n    such as the output array argument and interpolation along an axis of a\\n    multidimensional data array.\\n\\n    Parameters\\n    ----------\\n    x : array like\\n        1D array of monotonically increasing real values.\\n    y : array like\\n        N-D array of real values. y's length along the interpolation\\n        axis must be equal to the length of x.\\n    x_new : array like\\n        New independent variables.\\n    axis : int\\n        Specifies axis of y along which to interpolate. Interpolation\\n        defaults to last axis of y.\\n    out : array\\n        Optional array to receive results. Dimension at axis must equal\\n        length of x.\\n\\n    Examples\\n    --------\\n    >>> interpolate([0, 1, 2], [0, 0, 1], [0.5, 1.5])\\n    array([-0.125,  0.375])\\n    >>> x = numpy.sort(numpy.random.random(10) * 10)\\n    >>> y = numpy.random.normal(0.0, 0.1, size=len(x))\\n    >>> z = interpolate(x, y, x)\\n    >>> numpy.allclose(y, z)\\n    True\\n    >>> x = x[:10]\\n    >>> y = numpy.reshape(y, (10, -1))\\n    >>> z = numpy.reshape(y, (10, -1))\\n    >>> interpolate(x, y, x, axis=0, out=z)\\n    >>> numpy.allclose(y, z)\\n    True\\n\\n    \"\n    x = numpy.array(x, dtype=numpy.float64, copy=True)\n    y = numpy.array(y, dtype=numpy.float64, copy=True)\n    xi = numpy.array(x_new, dtype=numpy.float64, copy=True)\n    if axis != -1 or out is not None or y.ndim != 1:\n        raise NotImplementedError('implemented in C extension module')\n    if x.ndim != 1 or xi.ndim != 1:\n        raise ValueError('x-arrays must be one dimensional')\n    n = len(x)\n    if n < 2:\n        raise ValueError('array too small')\n    if n != y.shape[axis]:\n        raise ValueError('size of x-array must match data shape')\n    dx = numpy.diff(x)\n    if any(dx <= 0.0):\n        raise ValueError('x-axis not valid')\n    if any(xi < x[0]) or any(xi > x[-1]):\n        raise ValueError('interpolation x-axis out of bounds')\n    m = numpy.diff(y) / dx\n    mm = 2.0 * m[0] - m[1]\n    mmm = 2.0 * mm - m[0]\n    mp = 2.0 * m[n - 2] - m[n - 3]\n    mpp = 2.0 * mp - m[n - 2]\n    m1 = numpy.concatenate(([mmm], [mm], m, [mp], [mpp]))\n    dm = numpy.abs(numpy.diff(m1))\n    f1 = dm[2:n + 2]\n    f2 = dm[0:n]\n    f12 = f1 + f2\n    ids = numpy.nonzero(f12 > 1e-09 * numpy.max(f12))[0]\n    b = m1[1:n + 1]\n    b[ids] = (f1[ids] * m1[ids + 1] + f2[ids] * m1[ids + 2]) / f12[ids]\n    c = (3.0 * m - 2.0 * b[0:n - 1] - b[1:n]) / dx\n    d = (b[0:n - 1] + b[1:n] - 2.0 * m) / dx ** 2\n    bins = numpy.digitize(xi, x)\n    bins = numpy.minimum(bins, n - 1) - 1\n    bb = bins[0:len(xi)]\n    wj = xi - x[bb]\n    return ((wj * d[bb] + c[bb]) * wj + b[bb]) * wj + y[bb]",
            "def interpolate(x, y, x_new, axis=-1, out=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return interpolated data using Akima's method.\\n\\n    This Python implementation is inspired by the Matlab(r) code by\\n    N. Shamsundar. It lacks certain capabilities of the C implementation\\n    such as the output array argument and interpolation along an axis of a\\n    multidimensional data array.\\n\\n    Parameters\\n    ----------\\n    x : array like\\n        1D array of monotonically increasing real values.\\n    y : array like\\n        N-D array of real values. y's length along the interpolation\\n        axis must be equal to the length of x.\\n    x_new : array like\\n        New independent variables.\\n    axis : int\\n        Specifies axis of y along which to interpolate. Interpolation\\n        defaults to last axis of y.\\n    out : array\\n        Optional array to receive results. Dimension at axis must equal\\n        length of x.\\n\\n    Examples\\n    --------\\n    >>> interpolate([0, 1, 2], [0, 0, 1], [0.5, 1.5])\\n    array([-0.125,  0.375])\\n    >>> x = numpy.sort(numpy.random.random(10) * 10)\\n    >>> y = numpy.random.normal(0.0, 0.1, size=len(x))\\n    >>> z = interpolate(x, y, x)\\n    >>> numpy.allclose(y, z)\\n    True\\n    >>> x = x[:10]\\n    >>> y = numpy.reshape(y, (10, -1))\\n    >>> z = numpy.reshape(y, (10, -1))\\n    >>> interpolate(x, y, x, axis=0, out=z)\\n    >>> numpy.allclose(y, z)\\n    True\\n\\n    \"\n    x = numpy.array(x, dtype=numpy.float64, copy=True)\n    y = numpy.array(y, dtype=numpy.float64, copy=True)\n    xi = numpy.array(x_new, dtype=numpy.float64, copy=True)\n    if axis != -1 or out is not None or y.ndim != 1:\n        raise NotImplementedError('implemented in C extension module')\n    if x.ndim != 1 or xi.ndim != 1:\n        raise ValueError('x-arrays must be one dimensional')\n    n = len(x)\n    if n < 2:\n        raise ValueError('array too small')\n    if n != y.shape[axis]:\n        raise ValueError('size of x-array must match data shape')\n    dx = numpy.diff(x)\n    if any(dx <= 0.0):\n        raise ValueError('x-axis not valid')\n    if any(xi < x[0]) or any(xi > x[-1]):\n        raise ValueError('interpolation x-axis out of bounds')\n    m = numpy.diff(y) / dx\n    mm = 2.0 * m[0] - m[1]\n    mmm = 2.0 * mm - m[0]\n    mp = 2.0 * m[n - 2] - m[n - 3]\n    mpp = 2.0 * mp - m[n - 2]\n    m1 = numpy.concatenate(([mmm], [mm], m, [mp], [mpp]))\n    dm = numpy.abs(numpy.diff(m1))\n    f1 = dm[2:n + 2]\n    f2 = dm[0:n]\n    f12 = f1 + f2\n    ids = numpy.nonzero(f12 > 1e-09 * numpy.max(f12))[0]\n    b = m1[1:n + 1]\n    b[ids] = (f1[ids] * m1[ids + 1] + f2[ids] * m1[ids + 2]) / f12[ids]\n    c = (3.0 * m - 2.0 * b[0:n - 1] - b[1:n]) / dx\n    d = (b[0:n - 1] + b[1:n] - 2.0 * m) / dx ** 2\n    bins = numpy.digitize(xi, x)\n    bins = numpy.minimum(bins, n - 1) - 1\n    bb = bins[0:len(xi)]\n    wj = xi - x[bb]\n    return ((wj * d[bb] + c[bb]) * wj + b[bb]) * wj + y[bb]",
            "def interpolate(x, y, x_new, axis=-1, out=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return interpolated data using Akima's method.\\n\\n    This Python implementation is inspired by the Matlab(r) code by\\n    N. Shamsundar. It lacks certain capabilities of the C implementation\\n    such as the output array argument and interpolation along an axis of a\\n    multidimensional data array.\\n\\n    Parameters\\n    ----------\\n    x : array like\\n        1D array of monotonically increasing real values.\\n    y : array like\\n        N-D array of real values. y's length along the interpolation\\n        axis must be equal to the length of x.\\n    x_new : array like\\n        New independent variables.\\n    axis : int\\n        Specifies axis of y along which to interpolate. Interpolation\\n        defaults to last axis of y.\\n    out : array\\n        Optional array to receive results. Dimension at axis must equal\\n        length of x.\\n\\n    Examples\\n    --------\\n    >>> interpolate([0, 1, 2], [0, 0, 1], [0.5, 1.5])\\n    array([-0.125,  0.375])\\n    >>> x = numpy.sort(numpy.random.random(10) * 10)\\n    >>> y = numpy.random.normal(0.0, 0.1, size=len(x))\\n    >>> z = interpolate(x, y, x)\\n    >>> numpy.allclose(y, z)\\n    True\\n    >>> x = x[:10]\\n    >>> y = numpy.reshape(y, (10, -1))\\n    >>> z = numpy.reshape(y, (10, -1))\\n    >>> interpolate(x, y, x, axis=0, out=z)\\n    >>> numpy.allclose(y, z)\\n    True\\n\\n    \"\n    x = numpy.array(x, dtype=numpy.float64, copy=True)\n    y = numpy.array(y, dtype=numpy.float64, copy=True)\n    xi = numpy.array(x_new, dtype=numpy.float64, copy=True)\n    if axis != -1 or out is not None or y.ndim != 1:\n        raise NotImplementedError('implemented in C extension module')\n    if x.ndim != 1 or xi.ndim != 1:\n        raise ValueError('x-arrays must be one dimensional')\n    n = len(x)\n    if n < 2:\n        raise ValueError('array too small')\n    if n != y.shape[axis]:\n        raise ValueError('size of x-array must match data shape')\n    dx = numpy.diff(x)\n    if any(dx <= 0.0):\n        raise ValueError('x-axis not valid')\n    if any(xi < x[0]) or any(xi > x[-1]):\n        raise ValueError('interpolation x-axis out of bounds')\n    m = numpy.diff(y) / dx\n    mm = 2.0 * m[0] - m[1]\n    mmm = 2.0 * mm - m[0]\n    mp = 2.0 * m[n - 2] - m[n - 3]\n    mpp = 2.0 * mp - m[n - 2]\n    m1 = numpy.concatenate(([mmm], [mm], m, [mp], [mpp]))\n    dm = numpy.abs(numpy.diff(m1))\n    f1 = dm[2:n + 2]\n    f2 = dm[0:n]\n    f12 = f1 + f2\n    ids = numpy.nonzero(f12 > 1e-09 * numpy.max(f12))[0]\n    b = m1[1:n + 1]\n    b[ids] = (f1[ids] * m1[ids + 1] + f2[ids] * m1[ids + 2]) / f12[ids]\n    c = (3.0 * m - 2.0 * b[0:n - 1] - b[1:n]) / dx\n    d = (b[0:n - 1] + b[1:n] - 2.0 * m) / dx ** 2\n    bins = numpy.digitize(xi, x)\n    bins = numpy.minimum(bins, n - 1) - 1\n    bb = bins[0:len(xi)]\n    wj = xi - x[bb]\n    return ((wj * d[bb] + c[bb]) * wj + b[bb]) * wj + y[bb]",
            "def interpolate(x, y, x_new, axis=-1, out=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return interpolated data using Akima's method.\\n\\n    This Python implementation is inspired by the Matlab(r) code by\\n    N. Shamsundar. It lacks certain capabilities of the C implementation\\n    such as the output array argument and interpolation along an axis of a\\n    multidimensional data array.\\n\\n    Parameters\\n    ----------\\n    x : array like\\n        1D array of monotonically increasing real values.\\n    y : array like\\n        N-D array of real values. y's length along the interpolation\\n        axis must be equal to the length of x.\\n    x_new : array like\\n        New independent variables.\\n    axis : int\\n        Specifies axis of y along which to interpolate. Interpolation\\n        defaults to last axis of y.\\n    out : array\\n        Optional array to receive results. Dimension at axis must equal\\n        length of x.\\n\\n    Examples\\n    --------\\n    >>> interpolate([0, 1, 2], [0, 0, 1], [0.5, 1.5])\\n    array([-0.125,  0.375])\\n    >>> x = numpy.sort(numpy.random.random(10) * 10)\\n    >>> y = numpy.random.normal(0.0, 0.1, size=len(x))\\n    >>> z = interpolate(x, y, x)\\n    >>> numpy.allclose(y, z)\\n    True\\n    >>> x = x[:10]\\n    >>> y = numpy.reshape(y, (10, -1))\\n    >>> z = numpy.reshape(y, (10, -1))\\n    >>> interpolate(x, y, x, axis=0, out=z)\\n    >>> numpy.allclose(y, z)\\n    True\\n\\n    \"\n    x = numpy.array(x, dtype=numpy.float64, copy=True)\n    y = numpy.array(y, dtype=numpy.float64, copy=True)\n    xi = numpy.array(x_new, dtype=numpy.float64, copy=True)\n    if axis != -1 or out is not None or y.ndim != 1:\n        raise NotImplementedError('implemented in C extension module')\n    if x.ndim != 1 or xi.ndim != 1:\n        raise ValueError('x-arrays must be one dimensional')\n    n = len(x)\n    if n < 2:\n        raise ValueError('array too small')\n    if n != y.shape[axis]:\n        raise ValueError('size of x-array must match data shape')\n    dx = numpy.diff(x)\n    if any(dx <= 0.0):\n        raise ValueError('x-axis not valid')\n    if any(xi < x[0]) or any(xi > x[-1]):\n        raise ValueError('interpolation x-axis out of bounds')\n    m = numpy.diff(y) / dx\n    mm = 2.0 * m[0] - m[1]\n    mmm = 2.0 * mm - m[0]\n    mp = 2.0 * m[n - 2] - m[n - 3]\n    mpp = 2.0 * mp - m[n - 2]\n    m1 = numpy.concatenate(([mmm], [mm], m, [mp], [mpp]))\n    dm = numpy.abs(numpy.diff(m1))\n    f1 = dm[2:n + 2]\n    f2 = dm[0:n]\n    f12 = f1 + f2\n    ids = numpy.nonzero(f12 > 1e-09 * numpy.max(f12))[0]\n    b = m1[1:n + 1]\n    b[ids] = (f1[ids] * m1[ids + 1] + f2[ids] * m1[ids + 2]) / f12[ids]\n    c = (3.0 * m - 2.0 * b[0:n - 1] - b[1:n]) / dx\n    d = (b[0:n - 1] + b[1:n] - 2.0 * m) / dx ** 2\n    bins = numpy.digitize(xi, x)\n    bins = numpy.minimum(bins, n - 1) - 1\n    bb = bins[0:len(xi)]\n    wj = xi - x[bb]\n    return ((wj * d[bb] + c[bb]) * wj + b[bb]) * wj + y[bb]",
            "def interpolate(x, y, x_new, axis=-1, out=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return interpolated data using Akima's method.\\n\\n    This Python implementation is inspired by the Matlab(r) code by\\n    N. Shamsundar. It lacks certain capabilities of the C implementation\\n    such as the output array argument and interpolation along an axis of a\\n    multidimensional data array.\\n\\n    Parameters\\n    ----------\\n    x : array like\\n        1D array of monotonically increasing real values.\\n    y : array like\\n        N-D array of real values. y's length along the interpolation\\n        axis must be equal to the length of x.\\n    x_new : array like\\n        New independent variables.\\n    axis : int\\n        Specifies axis of y along which to interpolate. Interpolation\\n        defaults to last axis of y.\\n    out : array\\n        Optional array to receive results. Dimension at axis must equal\\n        length of x.\\n\\n    Examples\\n    --------\\n    >>> interpolate([0, 1, 2], [0, 0, 1], [0.5, 1.5])\\n    array([-0.125,  0.375])\\n    >>> x = numpy.sort(numpy.random.random(10) * 10)\\n    >>> y = numpy.random.normal(0.0, 0.1, size=len(x))\\n    >>> z = interpolate(x, y, x)\\n    >>> numpy.allclose(y, z)\\n    True\\n    >>> x = x[:10]\\n    >>> y = numpy.reshape(y, (10, -1))\\n    >>> z = numpy.reshape(y, (10, -1))\\n    >>> interpolate(x, y, x, axis=0, out=z)\\n    >>> numpy.allclose(y, z)\\n    True\\n\\n    \"\n    x = numpy.array(x, dtype=numpy.float64, copy=True)\n    y = numpy.array(y, dtype=numpy.float64, copy=True)\n    xi = numpy.array(x_new, dtype=numpy.float64, copy=True)\n    if axis != -1 or out is not None or y.ndim != 1:\n        raise NotImplementedError('implemented in C extension module')\n    if x.ndim != 1 or xi.ndim != 1:\n        raise ValueError('x-arrays must be one dimensional')\n    n = len(x)\n    if n < 2:\n        raise ValueError('array too small')\n    if n != y.shape[axis]:\n        raise ValueError('size of x-array must match data shape')\n    dx = numpy.diff(x)\n    if any(dx <= 0.0):\n        raise ValueError('x-axis not valid')\n    if any(xi < x[0]) or any(xi > x[-1]):\n        raise ValueError('interpolation x-axis out of bounds')\n    m = numpy.diff(y) / dx\n    mm = 2.0 * m[0] - m[1]\n    mmm = 2.0 * mm - m[0]\n    mp = 2.0 * m[n - 2] - m[n - 3]\n    mpp = 2.0 * mp - m[n - 2]\n    m1 = numpy.concatenate(([mmm], [mm], m, [mp], [mpp]))\n    dm = numpy.abs(numpy.diff(m1))\n    f1 = dm[2:n + 2]\n    f2 = dm[0:n]\n    f12 = f1 + f2\n    ids = numpy.nonzero(f12 > 1e-09 * numpy.max(f12))[0]\n    b = m1[1:n + 1]\n    b[ids] = (f1[ids] * m1[ids + 1] + f2[ids] * m1[ids + 2]) / f12[ids]\n    c = (3.0 * m - 2.0 * b[0:n - 1] - b[1:n]) / dx\n    d = (b[0:n - 1] + b[1:n] - 2.0 * m) / dx ** 2\n    bins = numpy.digitize(xi, x)\n    bins = numpy.minimum(bins, n - 1) - 1\n    bb = bins[0:len(xi)]\n    wj = xi - x[bb]\n    return ((wj * d[bb] + c[bb]) * wj + b[bb]) * wj + y[bb]"
        ]
    }
]