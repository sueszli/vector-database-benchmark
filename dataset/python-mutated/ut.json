[
    {
        "func_name": "put",
        "original": "@ratelimit()\n@requires_auth('item')\n@pre_event\ndef put(resource, payload=None, **lookup):\n    \"\"\"\n    Default function for handling PUT requests, it has decorators for\n    rate limiting, authentication and for raising pre-request events.\n    After the decorators are applied forwards to call to :func:`put_internal`\n\n    .. versionchanged:: 0.5\n       Split into put() and put_internal().\n    \"\"\"\n    return put_internal(resource, payload, concurrency_check=True, skip_validation=False, **lookup)",
        "mutated": [
            "@ratelimit()\n@requires_auth('item')\n@pre_event\ndef put(resource, payload=None, **lookup):\n    if False:\n        i = 10\n    '\\n    Default function for handling PUT requests, it has decorators for\\n    rate limiting, authentication and for raising pre-request events.\\n    After the decorators are applied forwards to call to :func:`put_internal`\\n\\n    .. versionchanged:: 0.5\\n       Split into put() and put_internal().\\n    '\n    return put_internal(resource, payload, concurrency_check=True, skip_validation=False, **lookup)",
            "@ratelimit()\n@requires_auth('item')\n@pre_event\ndef put(resource, payload=None, **lookup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Default function for handling PUT requests, it has decorators for\\n    rate limiting, authentication and for raising pre-request events.\\n    After the decorators are applied forwards to call to :func:`put_internal`\\n\\n    .. versionchanged:: 0.5\\n       Split into put() and put_internal().\\n    '\n    return put_internal(resource, payload, concurrency_check=True, skip_validation=False, **lookup)",
            "@ratelimit()\n@requires_auth('item')\n@pre_event\ndef put(resource, payload=None, **lookup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Default function for handling PUT requests, it has decorators for\\n    rate limiting, authentication and for raising pre-request events.\\n    After the decorators are applied forwards to call to :func:`put_internal`\\n\\n    .. versionchanged:: 0.5\\n       Split into put() and put_internal().\\n    '\n    return put_internal(resource, payload, concurrency_check=True, skip_validation=False, **lookup)",
            "@ratelimit()\n@requires_auth('item')\n@pre_event\ndef put(resource, payload=None, **lookup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Default function for handling PUT requests, it has decorators for\\n    rate limiting, authentication and for raising pre-request events.\\n    After the decorators are applied forwards to call to :func:`put_internal`\\n\\n    .. versionchanged:: 0.5\\n       Split into put() and put_internal().\\n    '\n    return put_internal(resource, payload, concurrency_check=True, skip_validation=False, **lookup)",
            "@ratelimit()\n@requires_auth('item')\n@pre_event\ndef put(resource, payload=None, **lookup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Default function for handling PUT requests, it has decorators for\\n    rate limiting, authentication and for raising pre-request events.\\n    After the decorators are applied forwards to call to :func:`put_internal`\\n\\n    .. versionchanged:: 0.5\\n       Split into put() and put_internal().\\n    '\n    return put_internal(resource, payload, concurrency_check=True, skip_validation=False, **lookup)"
        ]
    },
    {
        "func_name": "put_internal",
        "original": "def put_internal(resource, payload=None, concurrency_check=False, skip_validation=False, **lookup):\n    \"\"\"Intended for internal put calls, this method is not rate limited,\n    authentication is not checked, pre-request events are not raised, and\n    concurrency checking is optional. Performs a document replacement.\n    Updates are first validated against the resource schema. If validation\n    passes, the document is replaced and an OK status update is returned.\n    If validation fails a set of validation issues is returned.\n\n    :param resource: the name of the resource to which the document belongs.\n    :param payload: alternative payload. When calling put() from your own code\n                    you can provide an alternative payload. This can be useful,\n                    for example, when you have a callback function hooked to a\n                    certain endpoint, and want to perform additional put()\n                    callsfrom there.\n\n                    Please be advised that in order to successfully use this\n                    option, a request context must be available.\n    :param concurrency_check: concurrency check switch (bool)\n    :param skip_validation: skip payload validation before write (bool)\n    :param **lookup: document lookup query.\n\n    .. versionchanged:: 0.6\n       Create document if it does not exist. Closes #634.\n       Allow restoring soft deleted documents via PUT\n\n    .. versionchanged:: 0.5\n       Back to resolving default values after validation as now the validator\n       can properly validate dependency even when some have default values. See\n       #353.\n       Original put() has been split into put() and put_internal().\n       You can now pass a pre-defined custom payload to the funcion.\n       ETAG is now stored with the document (#369).\n       Catching all HTTPExceptions and returning them to the caller, allowing\n       for eventual flask.abort() invocations in callback functions to go\n       through. Fixes #395.\n\n    .. versionchanged:: 0.4\n       Allow abort() to be invoked by callback functions.\n       Resolve default values before validation is performed. See #353.\n       Raise 'on_replace' instead of 'on_insert'. The callback function gets\n       the document (as opposed to a list of just 1 document) as an argument.\n       Support for document versioning.\n       Raise `on_replaced` after the document has been replaced\n\n    .. versionchanged:: 0.3\n       Support for media fields.\n       When IF_MATCH is disabled, no etag is included in the payload.\n       Support for new validation format introduced with Cerberus v0.5.\n\n    .. versionchanged:: 0.2\n       Use the new STATUS setting.\n       Use the new ISSUES setting.\n       Raise pre_<method> event.\n       explicitly resolve default values instead of letting them be resolved\n       by common.parse. This avoids a validation error when a read-only field\n       also has a default value.\n\n    .. versionchanged:: 0.1.1\n       auth.request_auth_value is now used to store the auth_field value.\n       Item-identifier wrapper stripped from both request and response payload.\n\n    .. versionadded:: 0.1.0\n    \"\"\"\n    resource_def = app.config['DOMAIN'][resource]\n    schema = resource_def['schema']\n    validator = app.validator(schema, resource=resource, allow_unknown=resource_def['allow_unknown'])\n    if payload is None:\n        payload = payload_()\n    original = get_document(resource, concurrency_check, check_auth_value=False, force_auth_field_projection=True, **lookup)\n    if not original:\n        if config.UPSERT_ON_PUT:\n            id = lookup[resource_def['id_field']]\n            if schema[resource_def['id_field']].get('type', '') == 'objectid':\n                id = str(id)\n            payload[resource_def['id_field']] = id\n            return post_internal(resource, payl=payload)\n        abort(404)\n    (auth_field, request_auth_value) = auth_field_and_value(resource)\n    if auth_field and original.get(auth_field) != request_auth_value:\n        abort(403)\n    last_modified = None\n    etag = None\n    issues = {}\n    object_id = original[resource_def['id_field']]\n    response = {}\n    if config.BANDWIDTH_SAVER is True:\n        embedded_fields = []\n    else:\n        req = parse_request(resource)\n        embedded_fields = resolve_embedded_fields(resource, req)\n    try:\n        document = parse(payload, resource)\n        resolve_sub_resource_path(document, resource)\n        if skip_validation:\n            validation = True\n        else:\n            validation = validator.validate_replace(document, object_id, original)\n            document = validator.document\n        if validation:\n            late_versioning_catch(original, resource)\n            last_modified = utcnow()\n            document[config.LAST_UPDATED] = last_modified\n            document[config.DATE_CREATED] = original[config.DATE_CREATED]\n            if resource_def['soft_delete'] is True:\n                document[config.DELETED] = False\n            if resource_def['id_field'] not in document:\n                document[resource_def['id_field']] = object_id\n            resolve_user_restricted_access(document, resource)\n            store_media_files(document, resource, original)\n            resolve_document_version(document, resource, 'PUT', original)\n            getattr(app, 'on_replace')(resource, document, original)\n            getattr(app, 'on_replace_%s' % resource)(document, original)\n            resolve_document_etag(document, resource)\n            try:\n                app.data.replace(resource, object_id, document, original)\n            except app.data.OriginalChangedError:\n                if concurrency_check:\n                    abort(412, description=\"Client and server etags don't match\")\n            oplog_push(resource, document, 'PUT')\n            insert_versioning_documents(resource, document)\n            getattr(app, 'on_replaced')(resource, document, original)\n            getattr(app, 'on_replaced_%s' % resource)(document, original)\n            build_response_document(document, resource, embedded_fields, document)\n            response = document\n            if config.IF_MATCH:\n                etag = response[config.ETAG]\n        else:\n            issues = validator.errors\n    except DocumentError as e:\n        issues['validator exception'] = str(e)\n    except exceptions.HTTPException as e:\n        raise e\n    except Exception as e:\n        app.logger.exception(e)\n        abort(400, description=debug_error_message('An exception occurred: %s' % e))\n    if issues:\n        response[config.ISSUES] = issues\n        response[config.STATUS] = config.STATUS_ERR\n        status = config.VALIDATION_ERROR_STATUS\n    else:\n        response[config.STATUS] = config.STATUS_OK\n        status = 200\n    response = marshal_write_response(response, resource)\n    return (response, last_modified, etag, status)",
        "mutated": [
            "def put_internal(resource, payload=None, concurrency_check=False, skip_validation=False, **lookup):\n    if False:\n        i = 10\n    \"Intended for internal put calls, this method is not rate limited,\\n    authentication is not checked, pre-request events are not raised, and\\n    concurrency checking is optional. Performs a document replacement.\\n    Updates are first validated against the resource schema. If validation\\n    passes, the document is replaced and an OK status update is returned.\\n    If validation fails a set of validation issues is returned.\\n\\n    :param resource: the name of the resource to which the document belongs.\\n    :param payload: alternative payload. When calling put() from your own code\\n                    you can provide an alternative payload. This can be useful,\\n                    for example, when you have a callback function hooked to a\\n                    certain endpoint, and want to perform additional put()\\n                    callsfrom there.\\n\\n                    Please be advised that in order to successfully use this\\n                    option, a request context must be available.\\n    :param concurrency_check: concurrency check switch (bool)\\n    :param skip_validation: skip payload validation before write (bool)\\n    :param **lookup: document lookup query.\\n\\n    .. versionchanged:: 0.6\\n       Create document if it does not exist. Closes #634.\\n       Allow restoring soft deleted documents via PUT\\n\\n    .. versionchanged:: 0.5\\n       Back to resolving default values after validation as now the validator\\n       can properly validate dependency even when some have default values. See\\n       #353.\\n       Original put() has been split into put() and put_internal().\\n       You can now pass a pre-defined custom payload to the funcion.\\n       ETAG is now stored with the document (#369).\\n       Catching all HTTPExceptions and returning them to the caller, allowing\\n       for eventual flask.abort() invocations in callback functions to go\\n       through. Fixes #395.\\n\\n    .. versionchanged:: 0.4\\n       Allow abort() to be invoked by callback functions.\\n       Resolve default values before validation is performed. See #353.\\n       Raise 'on_replace' instead of 'on_insert'. The callback function gets\\n       the document (as opposed to a list of just 1 document) as an argument.\\n       Support for document versioning.\\n       Raise `on_replaced` after the document has been replaced\\n\\n    .. versionchanged:: 0.3\\n       Support for media fields.\\n       When IF_MATCH is disabled, no etag is included in the payload.\\n       Support for new validation format introduced with Cerberus v0.5.\\n\\n    .. versionchanged:: 0.2\\n       Use the new STATUS setting.\\n       Use the new ISSUES setting.\\n       Raise pre_<method> event.\\n       explicitly resolve default values instead of letting them be resolved\\n       by common.parse. This avoids a validation error when a read-only field\\n       also has a default value.\\n\\n    .. versionchanged:: 0.1.1\\n       auth.request_auth_value is now used to store the auth_field value.\\n       Item-identifier wrapper stripped from both request and response payload.\\n\\n    .. versionadded:: 0.1.0\\n    \"\n    resource_def = app.config['DOMAIN'][resource]\n    schema = resource_def['schema']\n    validator = app.validator(schema, resource=resource, allow_unknown=resource_def['allow_unknown'])\n    if payload is None:\n        payload = payload_()\n    original = get_document(resource, concurrency_check, check_auth_value=False, force_auth_field_projection=True, **lookup)\n    if not original:\n        if config.UPSERT_ON_PUT:\n            id = lookup[resource_def['id_field']]\n            if schema[resource_def['id_field']].get('type', '') == 'objectid':\n                id = str(id)\n            payload[resource_def['id_field']] = id\n            return post_internal(resource, payl=payload)\n        abort(404)\n    (auth_field, request_auth_value) = auth_field_and_value(resource)\n    if auth_field and original.get(auth_field) != request_auth_value:\n        abort(403)\n    last_modified = None\n    etag = None\n    issues = {}\n    object_id = original[resource_def['id_field']]\n    response = {}\n    if config.BANDWIDTH_SAVER is True:\n        embedded_fields = []\n    else:\n        req = parse_request(resource)\n        embedded_fields = resolve_embedded_fields(resource, req)\n    try:\n        document = parse(payload, resource)\n        resolve_sub_resource_path(document, resource)\n        if skip_validation:\n            validation = True\n        else:\n            validation = validator.validate_replace(document, object_id, original)\n            document = validator.document\n        if validation:\n            late_versioning_catch(original, resource)\n            last_modified = utcnow()\n            document[config.LAST_UPDATED] = last_modified\n            document[config.DATE_CREATED] = original[config.DATE_CREATED]\n            if resource_def['soft_delete'] is True:\n                document[config.DELETED] = False\n            if resource_def['id_field'] not in document:\n                document[resource_def['id_field']] = object_id\n            resolve_user_restricted_access(document, resource)\n            store_media_files(document, resource, original)\n            resolve_document_version(document, resource, 'PUT', original)\n            getattr(app, 'on_replace')(resource, document, original)\n            getattr(app, 'on_replace_%s' % resource)(document, original)\n            resolve_document_etag(document, resource)\n            try:\n                app.data.replace(resource, object_id, document, original)\n            except app.data.OriginalChangedError:\n                if concurrency_check:\n                    abort(412, description=\"Client and server etags don't match\")\n            oplog_push(resource, document, 'PUT')\n            insert_versioning_documents(resource, document)\n            getattr(app, 'on_replaced')(resource, document, original)\n            getattr(app, 'on_replaced_%s' % resource)(document, original)\n            build_response_document(document, resource, embedded_fields, document)\n            response = document\n            if config.IF_MATCH:\n                etag = response[config.ETAG]\n        else:\n            issues = validator.errors\n    except DocumentError as e:\n        issues['validator exception'] = str(e)\n    except exceptions.HTTPException as e:\n        raise e\n    except Exception as e:\n        app.logger.exception(e)\n        abort(400, description=debug_error_message('An exception occurred: %s' % e))\n    if issues:\n        response[config.ISSUES] = issues\n        response[config.STATUS] = config.STATUS_ERR\n        status = config.VALIDATION_ERROR_STATUS\n    else:\n        response[config.STATUS] = config.STATUS_OK\n        status = 200\n    response = marshal_write_response(response, resource)\n    return (response, last_modified, etag, status)",
            "def put_internal(resource, payload=None, concurrency_check=False, skip_validation=False, **lookup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Intended for internal put calls, this method is not rate limited,\\n    authentication is not checked, pre-request events are not raised, and\\n    concurrency checking is optional. Performs a document replacement.\\n    Updates are first validated against the resource schema. If validation\\n    passes, the document is replaced and an OK status update is returned.\\n    If validation fails a set of validation issues is returned.\\n\\n    :param resource: the name of the resource to which the document belongs.\\n    :param payload: alternative payload. When calling put() from your own code\\n                    you can provide an alternative payload. This can be useful,\\n                    for example, when you have a callback function hooked to a\\n                    certain endpoint, and want to perform additional put()\\n                    callsfrom there.\\n\\n                    Please be advised that in order to successfully use this\\n                    option, a request context must be available.\\n    :param concurrency_check: concurrency check switch (bool)\\n    :param skip_validation: skip payload validation before write (bool)\\n    :param **lookup: document lookup query.\\n\\n    .. versionchanged:: 0.6\\n       Create document if it does not exist. Closes #634.\\n       Allow restoring soft deleted documents via PUT\\n\\n    .. versionchanged:: 0.5\\n       Back to resolving default values after validation as now the validator\\n       can properly validate dependency even when some have default values. See\\n       #353.\\n       Original put() has been split into put() and put_internal().\\n       You can now pass a pre-defined custom payload to the funcion.\\n       ETAG is now stored with the document (#369).\\n       Catching all HTTPExceptions and returning them to the caller, allowing\\n       for eventual flask.abort() invocations in callback functions to go\\n       through. Fixes #395.\\n\\n    .. versionchanged:: 0.4\\n       Allow abort() to be invoked by callback functions.\\n       Resolve default values before validation is performed. See #353.\\n       Raise 'on_replace' instead of 'on_insert'. The callback function gets\\n       the document (as opposed to a list of just 1 document) as an argument.\\n       Support for document versioning.\\n       Raise `on_replaced` after the document has been replaced\\n\\n    .. versionchanged:: 0.3\\n       Support for media fields.\\n       When IF_MATCH is disabled, no etag is included in the payload.\\n       Support for new validation format introduced with Cerberus v0.5.\\n\\n    .. versionchanged:: 0.2\\n       Use the new STATUS setting.\\n       Use the new ISSUES setting.\\n       Raise pre_<method> event.\\n       explicitly resolve default values instead of letting them be resolved\\n       by common.parse. This avoids a validation error when a read-only field\\n       also has a default value.\\n\\n    .. versionchanged:: 0.1.1\\n       auth.request_auth_value is now used to store the auth_field value.\\n       Item-identifier wrapper stripped from both request and response payload.\\n\\n    .. versionadded:: 0.1.0\\n    \"\n    resource_def = app.config['DOMAIN'][resource]\n    schema = resource_def['schema']\n    validator = app.validator(schema, resource=resource, allow_unknown=resource_def['allow_unknown'])\n    if payload is None:\n        payload = payload_()\n    original = get_document(resource, concurrency_check, check_auth_value=False, force_auth_field_projection=True, **lookup)\n    if not original:\n        if config.UPSERT_ON_PUT:\n            id = lookup[resource_def['id_field']]\n            if schema[resource_def['id_field']].get('type', '') == 'objectid':\n                id = str(id)\n            payload[resource_def['id_field']] = id\n            return post_internal(resource, payl=payload)\n        abort(404)\n    (auth_field, request_auth_value) = auth_field_and_value(resource)\n    if auth_field and original.get(auth_field) != request_auth_value:\n        abort(403)\n    last_modified = None\n    etag = None\n    issues = {}\n    object_id = original[resource_def['id_field']]\n    response = {}\n    if config.BANDWIDTH_SAVER is True:\n        embedded_fields = []\n    else:\n        req = parse_request(resource)\n        embedded_fields = resolve_embedded_fields(resource, req)\n    try:\n        document = parse(payload, resource)\n        resolve_sub_resource_path(document, resource)\n        if skip_validation:\n            validation = True\n        else:\n            validation = validator.validate_replace(document, object_id, original)\n            document = validator.document\n        if validation:\n            late_versioning_catch(original, resource)\n            last_modified = utcnow()\n            document[config.LAST_UPDATED] = last_modified\n            document[config.DATE_CREATED] = original[config.DATE_CREATED]\n            if resource_def['soft_delete'] is True:\n                document[config.DELETED] = False\n            if resource_def['id_field'] not in document:\n                document[resource_def['id_field']] = object_id\n            resolve_user_restricted_access(document, resource)\n            store_media_files(document, resource, original)\n            resolve_document_version(document, resource, 'PUT', original)\n            getattr(app, 'on_replace')(resource, document, original)\n            getattr(app, 'on_replace_%s' % resource)(document, original)\n            resolve_document_etag(document, resource)\n            try:\n                app.data.replace(resource, object_id, document, original)\n            except app.data.OriginalChangedError:\n                if concurrency_check:\n                    abort(412, description=\"Client and server etags don't match\")\n            oplog_push(resource, document, 'PUT')\n            insert_versioning_documents(resource, document)\n            getattr(app, 'on_replaced')(resource, document, original)\n            getattr(app, 'on_replaced_%s' % resource)(document, original)\n            build_response_document(document, resource, embedded_fields, document)\n            response = document\n            if config.IF_MATCH:\n                etag = response[config.ETAG]\n        else:\n            issues = validator.errors\n    except DocumentError as e:\n        issues['validator exception'] = str(e)\n    except exceptions.HTTPException as e:\n        raise e\n    except Exception as e:\n        app.logger.exception(e)\n        abort(400, description=debug_error_message('An exception occurred: %s' % e))\n    if issues:\n        response[config.ISSUES] = issues\n        response[config.STATUS] = config.STATUS_ERR\n        status = config.VALIDATION_ERROR_STATUS\n    else:\n        response[config.STATUS] = config.STATUS_OK\n        status = 200\n    response = marshal_write_response(response, resource)\n    return (response, last_modified, etag, status)",
            "def put_internal(resource, payload=None, concurrency_check=False, skip_validation=False, **lookup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Intended for internal put calls, this method is not rate limited,\\n    authentication is not checked, pre-request events are not raised, and\\n    concurrency checking is optional. Performs a document replacement.\\n    Updates are first validated against the resource schema. If validation\\n    passes, the document is replaced and an OK status update is returned.\\n    If validation fails a set of validation issues is returned.\\n\\n    :param resource: the name of the resource to which the document belongs.\\n    :param payload: alternative payload. When calling put() from your own code\\n                    you can provide an alternative payload. This can be useful,\\n                    for example, when you have a callback function hooked to a\\n                    certain endpoint, and want to perform additional put()\\n                    callsfrom there.\\n\\n                    Please be advised that in order to successfully use this\\n                    option, a request context must be available.\\n    :param concurrency_check: concurrency check switch (bool)\\n    :param skip_validation: skip payload validation before write (bool)\\n    :param **lookup: document lookup query.\\n\\n    .. versionchanged:: 0.6\\n       Create document if it does not exist. Closes #634.\\n       Allow restoring soft deleted documents via PUT\\n\\n    .. versionchanged:: 0.5\\n       Back to resolving default values after validation as now the validator\\n       can properly validate dependency even when some have default values. See\\n       #353.\\n       Original put() has been split into put() and put_internal().\\n       You can now pass a pre-defined custom payload to the funcion.\\n       ETAG is now stored with the document (#369).\\n       Catching all HTTPExceptions and returning them to the caller, allowing\\n       for eventual flask.abort() invocations in callback functions to go\\n       through. Fixes #395.\\n\\n    .. versionchanged:: 0.4\\n       Allow abort() to be invoked by callback functions.\\n       Resolve default values before validation is performed. See #353.\\n       Raise 'on_replace' instead of 'on_insert'. The callback function gets\\n       the document (as opposed to a list of just 1 document) as an argument.\\n       Support for document versioning.\\n       Raise `on_replaced` after the document has been replaced\\n\\n    .. versionchanged:: 0.3\\n       Support for media fields.\\n       When IF_MATCH is disabled, no etag is included in the payload.\\n       Support for new validation format introduced with Cerberus v0.5.\\n\\n    .. versionchanged:: 0.2\\n       Use the new STATUS setting.\\n       Use the new ISSUES setting.\\n       Raise pre_<method> event.\\n       explicitly resolve default values instead of letting them be resolved\\n       by common.parse. This avoids a validation error when a read-only field\\n       also has a default value.\\n\\n    .. versionchanged:: 0.1.1\\n       auth.request_auth_value is now used to store the auth_field value.\\n       Item-identifier wrapper stripped from both request and response payload.\\n\\n    .. versionadded:: 0.1.0\\n    \"\n    resource_def = app.config['DOMAIN'][resource]\n    schema = resource_def['schema']\n    validator = app.validator(schema, resource=resource, allow_unknown=resource_def['allow_unknown'])\n    if payload is None:\n        payload = payload_()\n    original = get_document(resource, concurrency_check, check_auth_value=False, force_auth_field_projection=True, **lookup)\n    if not original:\n        if config.UPSERT_ON_PUT:\n            id = lookup[resource_def['id_field']]\n            if schema[resource_def['id_field']].get('type', '') == 'objectid':\n                id = str(id)\n            payload[resource_def['id_field']] = id\n            return post_internal(resource, payl=payload)\n        abort(404)\n    (auth_field, request_auth_value) = auth_field_and_value(resource)\n    if auth_field and original.get(auth_field) != request_auth_value:\n        abort(403)\n    last_modified = None\n    etag = None\n    issues = {}\n    object_id = original[resource_def['id_field']]\n    response = {}\n    if config.BANDWIDTH_SAVER is True:\n        embedded_fields = []\n    else:\n        req = parse_request(resource)\n        embedded_fields = resolve_embedded_fields(resource, req)\n    try:\n        document = parse(payload, resource)\n        resolve_sub_resource_path(document, resource)\n        if skip_validation:\n            validation = True\n        else:\n            validation = validator.validate_replace(document, object_id, original)\n            document = validator.document\n        if validation:\n            late_versioning_catch(original, resource)\n            last_modified = utcnow()\n            document[config.LAST_UPDATED] = last_modified\n            document[config.DATE_CREATED] = original[config.DATE_CREATED]\n            if resource_def['soft_delete'] is True:\n                document[config.DELETED] = False\n            if resource_def['id_field'] not in document:\n                document[resource_def['id_field']] = object_id\n            resolve_user_restricted_access(document, resource)\n            store_media_files(document, resource, original)\n            resolve_document_version(document, resource, 'PUT', original)\n            getattr(app, 'on_replace')(resource, document, original)\n            getattr(app, 'on_replace_%s' % resource)(document, original)\n            resolve_document_etag(document, resource)\n            try:\n                app.data.replace(resource, object_id, document, original)\n            except app.data.OriginalChangedError:\n                if concurrency_check:\n                    abort(412, description=\"Client and server etags don't match\")\n            oplog_push(resource, document, 'PUT')\n            insert_versioning_documents(resource, document)\n            getattr(app, 'on_replaced')(resource, document, original)\n            getattr(app, 'on_replaced_%s' % resource)(document, original)\n            build_response_document(document, resource, embedded_fields, document)\n            response = document\n            if config.IF_MATCH:\n                etag = response[config.ETAG]\n        else:\n            issues = validator.errors\n    except DocumentError as e:\n        issues['validator exception'] = str(e)\n    except exceptions.HTTPException as e:\n        raise e\n    except Exception as e:\n        app.logger.exception(e)\n        abort(400, description=debug_error_message('An exception occurred: %s' % e))\n    if issues:\n        response[config.ISSUES] = issues\n        response[config.STATUS] = config.STATUS_ERR\n        status = config.VALIDATION_ERROR_STATUS\n    else:\n        response[config.STATUS] = config.STATUS_OK\n        status = 200\n    response = marshal_write_response(response, resource)\n    return (response, last_modified, etag, status)",
            "def put_internal(resource, payload=None, concurrency_check=False, skip_validation=False, **lookup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Intended for internal put calls, this method is not rate limited,\\n    authentication is not checked, pre-request events are not raised, and\\n    concurrency checking is optional. Performs a document replacement.\\n    Updates are first validated against the resource schema. If validation\\n    passes, the document is replaced and an OK status update is returned.\\n    If validation fails a set of validation issues is returned.\\n\\n    :param resource: the name of the resource to which the document belongs.\\n    :param payload: alternative payload. When calling put() from your own code\\n                    you can provide an alternative payload. This can be useful,\\n                    for example, when you have a callback function hooked to a\\n                    certain endpoint, and want to perform additional put()\\n                    callsfrom there.\\n\\n                    Please be advised that in order to successfully use this\\n                    option, a request context must be available.\\n    :param concurrency_check: concurrency check switch (bool)\\n    :param skip_validation: skip payload validation before write (bool)\\n    :param **lookup: document lookup query.\\n\\n    .. versionchanged:: 0.6\\n       Create document if it does not exist. Closes #634.\\n       Allow restoring soft deleted documents via PUT\\n\\n    .. versionchanged:: 0.5\\n       Back to resolving default values after validation as now the validator\\n       can properly validate dependency even when some have default values. See\\n       #353.\\n       Original put() has been split into put() and put_internal().\\n       You can now pass a pre-defined custom payload to the funcion.\\n       ETAG is now stored with the document (#369).\\n       Catching all HTTPExceptions and returning them to the caller, allowing\\n       for eventual flask.abort() invocations in callback functions to go\\n       through. Fixes #395.\\n\\n    .. versionchanged:: 0.4\\n       Allow abort() to be invoked by callback functions.\\n       Resolve default values before validation is performed. See #353.\\n       Raise 'on_replace' instead of 'on_insert'. The callback function gets\\n       the document (as opposed to a list of just 1 document) as an argument.\\n       Support for document versioning.\\n       Raise `on_replaced` after the document has been replaced\\n\\n    .. versionchanged:: 0.3\\n       Support for media fields.\\n       When IF_MATCH is disabled, no etag is included in the payload.\\n       Support for new validation format introduced with Cerberus v0.5.\\n\\n    .. versionchanged:: 0.2\\n       Use the new STATUS setting.\\n       Use the new ISSUES setting.\\n       Raise pre_<method> event.\\n       explicitly resolve default values instead of letting them be resolved\\n       by common.parse. This avoids a validation error when a read-only field\\n       also has a default value.\\n\\n    .. versionchanged:: 0.1.1\\n       auth.request_auth_value is now used to store the auth_field value.\\n       Item-identifier wrapper stripped from both request and response payload.\\n\\n    .. versionadded:: 0.1.0\\n    \"\n    resource_def = app.config['DOMAIN'][resource]\n    schema = resource_def['schema']\n    validator = app.validator(schema, resource=resource, allow_unknown=resource_def['allow_unknown'])\n    if payload is None:\n        payload = payload_()\n    original = get_document(resource, concurrency_check, check_auth_value=False, force_auth_field_projection=True, **lookup)\n    if not original:\n        if config.UPSERT_ON_PUT:\n            id = lookup[resource_def['id_field']]\n            if schema[resource_def['id_field']].get('type', '') == 'objectid':\n                id = str(id)\n            payload[resource_def['id_field']] = id\n            return post_internal(resource, payl=payload)\n        abort(404)\n    (auth_field, request_auth_value) = auth_field_and_value(resource)\n    if auth_field and original.get(auth_field) != request_auth_value:\n        abort(403)\n    last_modified = None\n    etag = None\n    issues = {}\n    object_id = original[resource_def['id_field']]\n    response = {}\n    if config.BANDWIDTH_SAVER is True:\n        embedded_fields = []\n    else:\n        req = parse_request(resource)\n        embedded_fields = resolve_embedded_fields(resource, req)\n    try:\n        document = parse(payload, resource)\n        resolve_sub_resource_path(document, resource)\n        if skip_validation:\n            validation = True\n        else:\n            validation = validator.validate_replace(document, object_id, original)\n            document = validator.document\n        if validation:\n            late_versioning_catch(original, resource)\n            last_modified = utcnow()\n            document[config.LAST_UPDATED] = last_modified\n            document[config.DATE_CREATED] = original[config.DATE_CREATED]\n            if resource_def['soft_delete'] is True:\n                document[config.DELETED] = False\n            if resource_def['id_field'] not in document:\n                document[resource_def['id_field']] = object_id\n            resolve_user_restricted_access(document, resource)\n            store_media_files(document, resource, original)\n            resolve_document_version(document, resource, 'PUT', original)\n            getattr(app, 'on_replace')(resource, document, original)\n            getattr(app, 'on_replace_%s' % resource)(document, original)\n            resolve_document_etag(document, resource)\n            try:\n                app.data.replace(resource, object_id, document, original)\n            except app.data.OriginalChangedError:\n                if concurrency_check:\n                    abort(412, description=\"Client and server etags don't match\")\n            oplog_push(resource, document, 'PUT')\n            insert_versioning_documents(resource, document)\n            getattr(app, 'on_replaced')(resource, document, original)\n            getattr(app, 'on_replaced_%s' % resource)(document, original)\n            build_response_document(document, resource, embedded_fields, document)\n            response = document\n            if config.IF_MATCH:\n                etag = response[config.ETAG]\n        else:\n            issues = validator.errors\n    except DocumentError as e:\n        issues['validator exception'] = str(e)\n    except exceptions.HTTPException as e:\n        raise e\n    except Exception as e:\n        app.logger.exception(e)\n        abort(400, description=debug_error_message('An exception occurred: %s' % e))\n    if issues:\n        response[config.ISSUES] = issues\n        response[config.STATUS] = config.STATUS_ERR\n        status = config.VALIDATION_ERROR_STATUS\n    else:\n        response[config.STATUS] = config.STATUS_OK\n        status = 200\n    response = marshal_write_response(response, resource)\n    return (response, last_modified, etag, status)",
            "def put_internal(resource, payload=None, concurrency_check=False, skip_validation=False, **lookup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Intended for internal put calls, this method is not rate limited,\\n    authentication is not checked, pre-request events are not raised, and\\n    concurrency checking is optional. Performs a document replacement.\\n    Updates are first validated against the resource schema. If validation\\n    passes, the document is replaced and an OK status update is returned.\\n    If validation fails a set of validation issues is returned.\\n\\n    :param resource: the name of the resource to which the document belongs.\\n    :param payload: alternative payload. When calling put() from your own code\\n                    you can provide an alternative payload. This can be useful,\\n                    for example, when you have a callback function hooked to a\\n                    certain endpoint, and want to perform additional put()\\n                    callsfrom there.\\n\\n                    Please be advised that in order to successfully use this\\n                    option, a request context must be available.\\n    :param concurrency_check: concurrency check switch (bool)\\n    :param skip_validation: skip payload validation before write (bool)\\n    :param **lookup: document lookup query.\\n\\n    .. versionchanged:: 0.6\\n       Create document if it does not exist. Closes #634.\\n       Allow restoring soft deleted documents via PUT\\n\\n    .. versionchanged:: 0.5\\n       Back to resolving default values after validation as now the validator\\n       can properly validate dependency even when some have default values. See\\n       #353.\\n       Original put() has been split into put() and put_internal().\\n       You can now pass a pre-defined custom payload to the funcion.\\n       ETAG is now stored with the document (#369).\\n       Catching all HTTPExceptions and returning them to the caller, allowing\\n       for eventual flask.abort() invocations in callback functions to go\\n       through. Fixes #395.\\n\\n    .. versionchanged:: 0.4\\n       Allow abort() to be invoked by callback functions.\\n       Resolve default values before validation is performed. See #353.\\n       Raise 'on_replace' instead of 'on_insert'. The callback function gets\\n       the document (as opposed to a list of just 1 document) as an argument.\\n       Support for document versioning.\\n       Raise `on_replaced` after the document has been replaced\\n\\n    .. versionchanged:: 0.3\\n       Support for media fields.\\n       When IF_MATCH is disabled, no etag is included in the payload.\\n       Support for new validation format introduced with Cerberus v0.5.\\n\\n    .. versionchanged:: 0.2\\n       Use the new STATUS setting.\\n       Use the new ISSUES setting.\\n       Raise pre_<method> event.\\n       explicitly resolve default values instead of letting them be resolved\\n       by common.parse. This avoids a validation error when a read-only field\\n       also has a default value.\\n\\n    .. versionchanged:: 0.1.1\\n       auth.request_auth_value is now used to store the auth_field value.\\n       Item-identifier wrapper stripped from both request and response payload.\\n\\n    .. versionadded:: 0.1.0\\n    \"\n    resource_def = app.config['DOMAIN'][resource]\n    schema = resource_def['schema']\n    validator = app.validator(schema, resource=resource, allow_unknown=resource_def['allow_unknown'])\n    if payload is None:\n        payload = payload_()\n    original = get_document(resource, concurrency_check, check_auth_value=False, force_auth_field_projection=True, **lookup)\n    if not original:\n        if config.UPSERT_ON_PUT:\n            id = lookup[resource_def['id_field']]\n            if schema[resource_def['id_field']].get('type', '') == 'objectid':\n                id = str(id)\n            payload[resource_def['id_field']] = id\n            return post_internal(resource, payl=payload)\n        abort(404)\n    (auth_field, request_auth_value) = auth_field_and_value(resource)\n    if auth_field and original.get(auth_field) != request_auth_value:\n        abort(403)\n    last_modified = None\n    etag = None\n    issues = {}\n    object_id = original[resource_def['id_field']]\n    response = {}\n    if config.BANDWIDTH_SAVER is True:\n        embedded_fields = []\n    else:\n        req = parse_request(resource)\n        embedded_fields = resolve_embedded_fields(resource, req)\n    try:\n        document = parse(payload, resource)\n        resolve_sub_resource_path(document, resource)\n        if skip_validation:\n            validation = True\n        else:\n            validation = validator.validate_replace(document, object_id, original)\n            document = validator.document\n        if validation:\n            late_versioning_catch(original, resource)\n            last_modified = utcnow()\n            document[config.LAST_UPDATED] = last_modified\n            document[config.DATE_CREATED] = original[config.DATE_CREATED]\n            if resource_def['soft_delete'] is True:\n                document[config.DELETED] = False\n            if resource_def['id_field'] not in document:\n                document[resource_def['id_field']] = object_id\n            resolve_user_restricted_access(document, resource)\n            store_media_files(document, resource, original)\n            resolve_document_version(document, resource, 'PUT', original)\n            getattr(app, 'on_replace')(resource, document, original)\n            getattr(app, 'on_replace_%s' % resource)(document, original)\n            resolve_document_etag(document, resource)\n            try:\n                app.data.replace(resource, object_id, document, original)\n            except app.data.OriginalChangedError:\n                if concurrency_check:\n                    abort(412, description=\"Client and server etags don't match\")\n            oplog_push(resource, document, 'PUT')\n            insert_versioning_documents(resource, document)\n            getattr(app, 'on_replaced')(resource, document, original)\n            getattr(app, 'on_replaced_%s' % resource)(document, original)\n            build_response_document(document, resource, embedded_fields, document)\n            response = document\n            if config.IF_MATCH:\n                etag = response[config.ETAG]\n        else:\n            issues = validator.errors\n    except DocumentError as e:\n        issues['validator exception'] = str(e)\n    except exceptions.HTTPException as e:\n        raise e\n    except Exception as e:\n        app.logger.exception(e)\n        abort(400, description=debug_error_message('An exception occurred: %s' % e))\n    if issues:\n        response[config.ISSUES] = issues\n        response[config.STATUS] = config.STATUS_ERR\n        status = config.VALIDATION_ERROR_STATUS\n    else:\n        response[config.STATUS] = config.STATUS_OK\n        status = 200\n    response = marshal_write_response(response, resource)\n    return (response, last_modified, etag, status)"
        ]
    }
]