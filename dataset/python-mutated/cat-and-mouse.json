[
    {
        "func_name": "parents",
        "original": "def parents(m, c, t):\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
        "mutated": [
            "def parents(m, c, t):\n    if False:\n        i = 10\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)"
        ]
    },
    {
        "func_name": "catMouseGame",
        "original": "def catMouseGame(self, graph):\n    \"\"\"\n        :type graph: List[List[int]]\n        :rtype: int\n        \"\"\"\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q.append((HOLE, i, CAT, MOUSE))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE]",
        "mutated": [
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q.append((HOLE, i, CAT, MOUSE))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE]",
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q.append((HOLE, i, CAT, MOUSE))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE]",
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q.append((HOLE, i, CAT, MOUSE))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE]",
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q.append((HOLE, i, CAT, MOUSE))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE]",
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q.append((HOLE, i, CAT, MOUSE))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE]"
        ]
    },
    {
        "func_name": "parents",
        "original": "def parents(m, c, t):\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
        "mutated": [
            "def parents(m, c, t):\n    if False:\n        i = 10\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if t == CAT:\n        for nm in graph[m]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c]:\n            if nc != HOLE:\n                yield (m, nc, MOUSE ^ CAT ^ t)"
        ]
    },
    {
        "func_name": "catMouseGame",
        "original": "def catMouseGame(self, graph):\n    \"\"\"\n        :type graph: List[List[int]]\n        :rtype: int\n        \"\"\"\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    color = collections.defaultdict(int)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    q1 = collections.deque()\n    q2 = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q1.append((HOLE, i, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q2.append((i, i, t))\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    while q2:\n        (i, j, t) = q2.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == MOUSE:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE]",
        "mutated": [
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    color = collections.defaultdict(int)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    q1 = collections.deque()\n    q2 = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q1.append((HOLE, i, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q2.append((i, i, t))\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    while q2:\n        (i, j, t) = q2.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == MOUSE:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE]",
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    color = collections.defaultdict(int)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    q1 = collections.deque()\n    q2 = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q1.append((HOLE, i, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q2.append((i, i, t))\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    while q2:\n        (i, j, t) = q2.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == MOUSE:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE]",
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    color = collections.defaultdict(int)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    q1 = collections.deque()\n    q2 = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q1.append((HOLE, i, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q2.append((i, i, t))\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    while q2:\n        (i, j, t) = q2.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == MOUSE:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE]",
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    color = collections.defaultdict(int)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    q1 = collections.deque()\n    q2 = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q1.append((HOLE, i, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q2.append((i, i, t))\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    while q2:\n        (i, j, t) = q2.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == MOUSE:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE]",
            "def catMouseGame(self, graph):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        '\n    (HOLE, MOUSE_START, CAT_START) = range(3)\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c]:\n                if nc != HOLE:\n                    yield (m, nc, MOUSE ^ CAT ^ t)\n    color = collections.defaultdict(int)\n    degree = {}\n    ignore = set(graph[HOLE])\n    for m in xrange(len(graph)):\n        for c in xrange(len(graph)):\n            degree[m, c, MOUSE] = len(graph[m])\n            degree[m, c, CAT] = len(graph[c]) - (c in ignore)\n    q1 = collections.deque()\n    q2 = collections.deque()\n    for i in xrange(len(graph)):\n        if i == HOLE:\n            continue\n        color[HOLE, i, CAT] = MOUSE\n        q1.append((HOLE, i, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q2.append((i, i, t))\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    while q2:\n        (i, j, t) = q2.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == MOUSE:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = CAT\n                q2.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE]"
        ]
    }
]