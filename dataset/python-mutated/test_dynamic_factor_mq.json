[
    {
        "func_name": "test_default",
        "original": "def test_default():\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=1, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 5:7], np.eye(2))\n    assert_allclose(mod['design', 2:, 7:9], np.eye(2))\n    assert_allclose(mod['design', 2:, 9:11], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 11:13], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 13:15], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 15:17], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:5, :4], np.eye(4))\n    assert_allclose(mod['transition', 9:17, 7:15], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 12)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 5:7, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 7:9, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design'], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 11.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[49.0, 0.0, 0.0, 0.0, 0.0], [0.0, 12.0, 0.0, 0.0, 0.0], [0.0, 0.0, 13.0, 0.0, 0.0], [0.0, 0.0, 0.0, 14.0, 0.0], [0.0, 0.0, 0.0, 0.0, 15.0]])\n    assert_allclose(mod['state_cov'], desired)",
        "mutated": [
            "def test_default():\n    if False:\n        i = 10\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=1, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 5:7], np.eye(2))\n    assert_allclose(mod['design', 2:, 7:9], np.eye(2))\n    assert_allclose(mod['design', 2:, 9:11], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 11:13], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 13:15], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 15:17], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:5, :4], np.eye(4))\n    assert_allclose(mod['transition', 9:17, 7:15], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 12)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 5:7, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 7:9, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design'], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 11.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[49.0, 0.0, 0.0, 0.0, 0.0], [0.0, 12.0, 0.0, 0.0, 0.0], [0.0, 0.0, 13.0, 0.0, 0.0], [0.0, 0.0, 0.0, 14.0, 0.0], [0.0, 0.0, 0.0, 0.0, 15.0]])\n    assert_allclose(mod['state_cov'], desired)",
            "def test_default():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=1, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 5:7], np.eye(2))\n    assert_allclose(mod['design', 2:, 7:9], np.eye(2))\n    assert_allclose(mod['design', 2:, 9:11], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 11:13], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 13:15], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 15:17], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:5, :4], np.eye(4))\n    assert_allclose(mod['transition', 9:17, 7:15], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 12)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 5:7, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 7:9, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design'], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 11.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[49.0, 0.0, 0.0, 0.0, 0.0], [0.0, 12.0, 0.0, 0.0, 0.0], [0.0, 0.0, 13.0, 0.0, 0.0], [0.0, 0.0, 0.0, 14.0, 0.0], [0.0, 0.0, 0.0, 0.0, 15.0]])\n    assert_allclose(mod['state_cov'], desired)",
            "def test_default():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=1, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 5:7], np.eye(2))\n    assert_allclose(mod['design', 2:, 7:9], np.eye(2))\n    assert_allclose(mod['design', 2:, 9:11], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 11:13], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 13:15], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 15:17], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:5, :4], np.eye(4))\n    assert_allclose(mod['transition', 9:17, 7:15], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 12)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 5:7, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 7:9, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design'], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 11.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[49.0, 0.0, 0.0, 0.0, 0.0], [0.0, 12.0, 0.0, 0.0, 0.0], [0.0, 0.0, 13.0, 0.0, 0.0], [0.0, 0.0, 0.0, 14.0, 0.0], [0.0, 0.0, 0.0, 0.0, 15.0]])\n    assert_allclose(mod['state_cov'], desired)",
            "def test_default():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=1, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 5:7], np.eye(2))\n    assert_allclose(mod['design', 2:, 7:9], np.eye(2))\n    assert_allclose(mod['design', 2:, 9:11], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 11:13], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 13:15], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 15:17], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:5, :4], np.eye(4))\n    assert_allclose(mod['transition', 9:17, 7:15], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 12)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 5:7, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 7:9, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design'], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 11.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[49.0, 0.0, 0.0, 0.0, 0.0], [0.0, 12.0, 0.0, 0.0, 0.0], [0.0, 0.0, 13.0, 0.0, 0.0], [0.0, 0.0, 0.0, 14.0, 0.0], [0.0, 0.0, 0.0, 0.0, 15.0]])\n    assert_allclose(mod['state_cov'], desired)",
            "def test_default():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=1, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 5:7], np.eye(2))\n    assert_allclose(mod['design', 2:, 7:9], np.eye(2))\n    assert_allclose(mod['design', 2:, 9:11], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 11:13], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 13:15], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 15:17], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:5, :4], np.eye(4))\n    assert_allclose(mod['transition', 9:17, 7:15], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 12)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 5:7, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 7:9, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design'], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 11.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[49.0, 0.0, 0.0, 0.0, 0.0], [0.0, 12.0, 0.0, 0.0, 0.0], [0.0, 0.0, 13.0, 0.0, 0.0], [0.0, 0.0, 0.0, 14.0, 0.0], [0.0, 0.0, 0.0, 0.0, 15.0]])\n    assert_allclose(mod['state_cov'], desired)"
        ]
    },
    {
        "func_name": "test_k_factors_gt1",
        "original": "def test_k_factors_gt1():\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 1}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L1.0->1', 'L1.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 10:12], np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:10, :8], np.eye(8))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 16)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 10:12, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0]])\n    assert_allclose(mod['design', :, :10], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 10:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [12, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :10, :10], desired)\n    assert_allclose(mod['transition', :10, 10:], 0)\n    assert_allclose(mod['transition', 10:, :10], 0)\n    desired = np.array([[17, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 18, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 19, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 20, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 10:, 10:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[14.0, 0], [15.0, 16.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 21, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 22, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 23, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 24]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
        "mutated": [
            "def test_k_factors_gt1():\n    if False:\n        i = 10\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 1}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L1.0->1', 'L1.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 10:12], np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:10, :8], np.eye(8))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 16)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 10:12, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0]])\n    assert_allclose(mod['design', :, :10], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 10:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [12, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :10, :10], desired)\n    assert_allclose(mod['transition', :10, 10:], 0)\n    assert_allclose(mod['transition', 10:, :10], 0)\n    desired = np.array([[17, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 18, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 19, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 20, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 10:, 10:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[14.0, 0], [15.0, 16.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 21, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 22, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 23, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 24]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 1}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L1.0->1', 'L1.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 10:12], np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:10, :8], np.eye(8))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 16)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 10:12, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0]])\n    assert_allclose(mod['design', :, :10], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 10:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [12, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :10, :10], desired)\n    assert_allclose(mod['transition', :10, 10:], 0)\n    assert_allclose(mod['transition', 10:, :10], 0)\n    desired = np.array([[17, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 18, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 19, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 20, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 10:, 10:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[14.0, 0], [15.0, 16.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 21, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 22, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 23, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 24]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 1}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L1.0->1', 'L1.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 10:12], np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:10, :8], np.eye(8))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 16)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 10:12, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0]])\n    assert_allclose(mod['design', :, :10], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 10:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [12, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :10, :10], desired)\n    assert_allclose(mod['transition', :10, 10:], 0)\n    assert_allclose(mod['transition', 10:, :10], 0)\n    desired = np.array([[17, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 18, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 19, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 20, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 10:, 10:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[14.0, 0], [15.0, 16.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 21, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 22, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 23, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 24]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 1}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L1.0->1', 'L1.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 10:12], np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:10, :8], np.eye(8))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 16)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 10:12, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0]])\n    assert_allclose(mod['design', :, :10], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 10:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [12, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :10, :10], desired)\n    assert_allclose(mod['transition', :10, 10:], 0)\n    assert_allclose(mod['transition', 10:, :10], 0)\n    desired = np.array([[17, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 18, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 19, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 20, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 10:, 10:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[14.0, 0], [15.0, 16.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 21, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 22, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 23, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 24]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 1}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 5 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L1.0->1', 'L1.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 10:12], np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:10, :8], np.eye(8))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 16)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 10:12, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0]])\n    assert_allclose(mod['design', :, :10], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 10:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [12, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :10, :10], desired)\n    assert_allclose(mod['transition', :10, 10:], 0)\n    assert_allclose(mod['transition', 10:, :10], 0)\n    desired = np.array([[17, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 18, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 19, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 20, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 10:, 10:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[14.0, 0], [15.0, 16.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 21, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 22, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 23, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 24]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)"
        ]
    },
    {
        "func_name": "test_factor_order_gt1",
        "original": "def test_factor_order_gt1():\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=6, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0', 'L5.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'L2.0->0', 'L3.0->0', 'L4.0->0', 'L5.0->0', 'L6.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 6:8], np.eye(2))\n    assert_allclose(mod['design', 2:, 8:10], np.eye(2))\n    assert_allclose(mod['design', 2:, 10:12], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:6, :5], np.eye(5))\n    assert_allclose(mod['transition', 10:18, 8:16], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 13)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 6:8, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 8:10, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0]])\n    assert_allclose(mod['design', :, :6], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 6:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 7.0, 8.0, 9.0, 10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 14, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 16, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[144, 0.0, 0.0, 0.0, 0.0], [0.0, 17.0, 0.0, 0.0, 0.0], [0.0, 0.0, 18.0, 0.0, 0.0], [0.0, 0.0, 0.0, 19.0, 0.0], [0.0, 0.0, 0.0, 0.0, 20.0]])\n    assert_allclose(mod['state_cov'], desired)",
        "mutated": [
            "def test_factor_order_gt1():\n    if False:\n        i = 10\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=6, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0', 'L5.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'L2.0->0', 'L3.0->0', 'L4.0->0', 'L5.0->0', 'L6.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 6:8], np.eye(2))\n    assert_allclose(mod['design', 2:, 8:10], np.eye(2))\n    assert_allclose(mod['design', 2:, 10:12], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:6, :5], np.eye(5))\n    assert_allclose(mod['transition', 10:18, 8:16], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 13)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 6:8, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 8:10, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0]])\n    assert_allclose(mod['design', :, :6], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 6:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 7.0, 8.0, 9.0, 10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 14, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 16, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[144, 0.0, 0.0, 0.0, 0.0], [0.0, 17.0, 0.0, 0.0, 0.0], [0.0, 0.0, 18.0, 0.0, 0.0], [0.0, 0.0, 0.0, 19.0, 0.0], [0.0, 0.0, 0.0, 0.0, 20.0]])\n    assert_allclose(mod['state_cov'], desired)",
            "def test_factor_order_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=6, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0', 'L5.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'L2.0->0', 'L3.0->0', 'L4.0->0', 'L5.0->0', 'L6.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 6:8], np.eye(2))\n    assert_allclose(mod['design', 2:, 8:10], np.eye(2))\n    assert_allclose(mod['design', 2:, 10:12], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:6, :5], np.eye(5))\n    assert_allclose(mod['transition', 10:18, 8:16], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 13)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 6:8, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 8:10, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0]])\n    assert_allclose(mod['design', :, :6], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 6:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 7.0, 8.0, 9.0, 10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 14, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 16, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[144, 0.0, 0.0, 0.0, 0.0], [0.0, 17.0, 0.0, 0.0, 0.0], [0.0, 0.0, 18.0, 0.0, 0.0], [0.0, 0.0, 0.0, 19.0, 0.0], [0.0, 0.0, 0.0, 0.0, 20.0]])\n    assert_allclose(mod['state_cov'], desired)",
            "def test_factor_order_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=6, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0', 'L5.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'L2.0->0', 'L3.0->0', 'L4.0->0', 'L5.0->0', 'L6.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 6:8], np.eye(2))\n    assert_allclose(mod['design', 2:, 8:10], np.eye(2))\n    assert_allclose(mod['design', 2:, 10:12], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:6, :5], np.eye(5))\n    assert_allclose(mod['transition', 10:18, 8:16], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 13)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 6:8, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 8:10, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0]])\n    assert_allclose(mod['design', :, :6], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 6:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 7.0, 8.0, 9.0, 10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 14, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 16, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[144, 0.0, 0.0, 0.0, 0.0], [0.0, 17.0, 0.0, 0.0, 0.0], [0.0, 0.0, 18.0, 0.0, 0.0], [0.0, 0.0, 0.0, 19.0, 0.0], [0.0, 0.0, 0.0, 0.0, 20.0]])\n    assert_allclose(mod['state_cov'], desired)",
            "def test_factor_order_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=6, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0', 'L5.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'L2.0->0', 'L3.0->0', 'L4.0->0', 'L5.0->0', 'L6.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 6:8], np.eye(2))\n    assert_allclose(mod['design', 2:, 8:10], np.eye(2))\n    assert_allclose(mod['design', 2:, 10:12], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:6, :5], np.eye(5))\n    assert_allclose(mod['transition', 10:18, 8:16], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 13)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 6:8, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 8:10, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0]])\n    assert_allclose(mod['design', :, :6], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 6:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 7.0, 8.0, 9.0, 10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 14, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 16, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[144, 0.0, 0.0, 0.0, 0.0], [0.0, 17.0, 0.0, 0.0, 0.0], [0.0, 0.0, 18.0, 0.0, 0.0], [0.0, 0.0, 0.0, 19.0, 0.0], [0.0, 0.0, 0.0, 0.0, 20.0]])\n    assert_allclose(mod['state_cov'], desired)",
            "def test_factor_order_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=1, factor_orders=6, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 1 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', 'L1.0', 'L2.0', 'L3.0', 'L4.0', 'L5.0'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.0->M1', 'loading.0->Q0', 'loading.0->Q1', 'L1.0->0', 'L2.0->0', 'L3.0->0', 'L4.0->0', 'L5.0->0', 'L6.0->0', 'fb(0).cov.chol[1,1]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 6:8], np.eye(2))\n    assert_allclose(mod['design', 2:, 8:10], np.eye(2))\n    assert_allclose(mod['design', 2:, 10:12], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 12:14], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 1:6, :5], np.eye(5))\n    assert_allclose(mod['transition', 10:18, 8:16], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 13)\n    assert_allclose(mod['selection', 0, 0], np.eye(1))\n    assert_allclose(mod['selection', 6:8, 1:3], np.eye(2))\n    assert_allclose(mod['selection', 8:10, 3:5], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 5)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 8.0, 12, 8.0, 4.0, 0.0], [5.0, 10, 15, 10, 5.0, 0.0]])\n    assert_allclose(mod['design', :, :6], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 6:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[6.0, 7.0, 8.0, 9.0, 10, 11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 14, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 16, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0, 0]])\n    assert_allclose(mod['transition'], desired)\n    assert_allclose(np.sum(mod['selection']), 5)\n    desired = np.array([[144, 0.0, 0.0, 0.0, 0.0], [0.0, 17.0, 0.0, 0.0, 0.0], [0.0, 0.0, 18.0, 0.0, 0.0], [0.0, 0.0, 0.0, 19.0, 0.0], [0.0, 0.0, 0.0, 0.0, 20.0]])\n    assert_allclose(mod['state_cov'], desired)"
        ]
    },
    {
        "func_name": "test_k_factors_gt1_factor_order_gt1",
        "original": "def test_k_factors_gt1_factor_order_gt1():\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 22:24], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 16:24, 14:22], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 14:16, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[37, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 38, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 40, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 41, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 42, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 43, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 44]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
        "mutated": [
            "def test_k_factors_gt1_factor_order_gt1():\n    if False:\n        i = 10\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 22:24], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 16:24, 14:22], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 14:16, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[37, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 38, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 40, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 41, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 42, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 43, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 44]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1_factor_order_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 22:24], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 16:24, 14:22], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 14:16, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[37, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 38, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 40, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 41, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 42, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 43, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 44]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1_factor_order_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 22:24], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 16:24, 14:22], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 14:16, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[37, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 38, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 40, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 41, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 42, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 43, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 44]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1_factor_order_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 22:24], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 16:24, 14:22], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 14:16, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[37, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 38, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 40, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 41, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 42, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 43, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 44]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1_factor_order_gt1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=True)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_M.M0', 'eps_M.M1', 'eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'L1.eps_M.M0', 'L1.eps_M.M1', 'L1.eps_Q.Q0', 'L1.eps_Q.Q1', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', :2, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 22:24], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 20)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 16:24, 14:22], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(mod['selection', 14:16, 4:6], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 6)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[37, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 38, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 40, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 6)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 41, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 42, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 43, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 44]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)"
        ]
    },
    {
        "func_name": "test_k_factors_gt1_factor_order_gt1_no_idiosyncratic_ar1",
        "original": "def test_k_factors_gt1_factor_order_gt1_no_idiosyncratic_ar1():\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=False)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 18)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 4)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], np.diag([37, 38, 0, 0]))\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 4)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0], [0.0, 0.0, 0.0, 40]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
        "mutated": [
            "def test_k_factors_gt1_factor_order_gt1_no_idiosyncratic_ar1():\n    if False:\n        i = 10\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=False)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 18)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 4)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], np.diag([37, 38, 0, 0]))\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 4)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0], [0.0, 0.0, 0.0, 40]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1_factor_order_gt1_no_idiosyncratic_ar1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=False)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 18)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 4)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], np.diag([37, 38, 0, 0]))\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 4)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0], [0.0, 0.0, 0.0, 40]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1_factor_order_gt1_no_idiosyncratic_ar1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=False)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 18)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 4)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], np.diag([37, 38, 0, 0]))\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 4)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0], [0.0, 0.0, 0.0, 40]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1_factor_order_gt1_no_idiosyncratic_ar1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=False)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 18)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 4)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], np.diag([37, 38, 0, 0]))\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 4)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0], [0.0, 0.0, 0.0, 40]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)",
            "def test_k_factors_gt1_factor_order_gt1_no_idiosyncratic_ar1():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    index_M = pd.period_range(start='2000', periods=12, freq='M')\n    index_Q = pd.period_range(start='2000', periods=4, freq='Q')\n    dta_M = pd.DataFrame(np.zeros((12, 2)), index=index_M, columns=['M0', 'M1'])\n    dta_Q = pd.DataFrame(np.zeros((4, 2)), index=index_Q, columns=['Q0', 'Q1'])\n    dta_M.iloc[0] = 1.0\n    dta_Q.iloc[1] = 1.0\n    mod = dynamic_factor_mq.DynamicFactorMQ(dta_M, endog_quarterly=dta_Q, factors=2, factor_orders={('0', '1'): 6}, idiosyncratic_ar1=False)\n    assert_equal(mod.k_endog, 2 + 2)\n    assert_equal(mod.k_states, 6 * 2 + 2 * 5)\n    assert_equal(mod.ssm.k_posdef, 2 + 2)\n    assert_equal(mod.endog_names, ['M0', 'M1', 'Q0', 'Q1'])\n    desired = ['0', '1', 'L1.0', 'L1.1', 'L2.0', 'L2.1', 'L3.0', 'L3.1', 'L4.0', 'L4.1', 'L5.0', 'L5.1'] + ['eps_Q.Q0', 'eps_Q.Q1'] + ['L1.eps_Q.Q0', 'L1.eps_Q.Q1'] + ['L2.eps_Q.Q0', 'L2.eps_Q.Q1'] + ['L3.eps_Q.Q0', 'L3.eps_Q.Q1'] + ['L4.eps_Q.Q0', 'L4.eps_Q.Q1']\n    assert_equal(mod.state_names, desired)\n    desired = ['loading.0->M0', 'loading.1->M0', 'loading.0->M1', 'loading.1->M1', 'loading.0->Q0', 'loading.1->Q0', 'loading.0->Q1', 'loading.1->Q1', 'L1.0->0', 'L1.1->0', 'L2.0->0', 'L2.1->0', 'L3.0->0', 'L3.1->0', 'L4.0->0', 'L4.1->0', 'L5.0->0', 'L5.1->0', 'L6.0->0', 'L6.1->0', 'L1.0->1', 'L1.1->1', 'L2.0->1', 'L2.1->1', 'L3.0->1', 'L3.1->1', 'L4.0->1', 'L4.1->1', 'L5.0->1', 'L5.1->1', 'L6.0->1', 'L6.1->1', 'fb(0).cov.chol[1,1]', 'fb(0).cov.chol[2,1]', 'fb(0).cov.chol[2,2]', 'sigma2.M0', 'sigma2.M1', 'sigma2.Q0', 'sigma2.Q1']\n    assert_equal(mod.param_names, desired)\n    assert_allclose(mod['obs_intercept'], 0)\n    assert_allclose(mod['design', 2:, 12:14], np.eye(2))\n    assert_allclose(mod['design', 2:, 14:16], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 16:18], 3 * np.eye(2))\n    assert_allclose(mod['design', 2:, 18:20], 2 * np.eye(2))\n    assert_allclose(mod['design', 2:, 20:22], np.eye(2))\n    assert_allclose(np.sum(mod['design']), 18)\n    assert_allclose(mod['obs_cov'], 0)\n    assert_allclose(mod['state_intercept'], 0)\n    assert_allclose(mod['transition', 2:12, :10], np.eye(10))\n    assert_allclose(mod['transition', 14:22, 12:20], np.eye(2 * 4))\n    assert_allclose(np.sum(mod['transition']), 18)\n    assert_allclose(mod['selection', :2, :2], np.eye(2))\n    assert_allclose(mod['selection', 12:14, 2:4], np.eye(2))\n    assert_allclose(np.sum(mod['selection']), 4)\n    assert_allclose(mod['state_cov'], 0)\n    mod.update(np.arange(mod.k_params) + 2)\n    assert_allclose(mod['obs_intercept'], 0)\n    desired = np.array([[2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [6.0, 7.0, 12, 14, 18, 21, 12, 14, 6.0, 7.0, 0.0, 0.0], [8.0, 9.0, 16, 18, 24, 27, 16, 18, 8.0, 9.0, 0.0, 0.0]])\n    assert_allclose(mod['design', :, :12], desired)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 2.0, 0.0, 1.0]])\n    assert_allclose(mod['design', :, 12:], desired)\n    assert_allclose(mod['obs_cov'], np.diag([37, 38, 0, 0]))\n    assert_allclose(mod['state_intercept'], 0)\n    desired = np.array([[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', :12, :12], desired)\n    assert_allclose(mod['transition', :12, 12:], 0)\n    assert_allclose(mod['transition', 12:, :12], 0)\n    desired = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]])\n    assert_allclose(mod['transition', 12:, 12:], desired)\n    assert_allclose(np.sum(mod['selection']), 4)\n    L = np.array([[34.0, 0], [35.0, 36.0]])\n    desired = np.array([[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 39, 0.0], [0.0, 0.0, 0.0, 40]])\n    desired[:2, :2] = np.dot(L, L.T)\n    assert_allclose(mod['state_cov'], desired)"
        ]
    },
    {
        "func_name": "test_invalid_model_specification",
        "original": "def test_invalid_model_specification():\n    dta = np.zeros((10, 2))\n    dta[0] = 1.0\n    dta_pd = pd.DataFrame(dta)\n    dta_period_W = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='W'))\n    dta_date_W = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='W'))\n    dta_period_M = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='M'))\n    dta_date_M = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='M'))\n    dta_period_Q = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='Q'))\n    msg = 'The model must contain at least one factor.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=0)\n    msg = '`factors` argument must an integer number of factors, a list of global factor names, or a dictionary, mapping observed variables to factors.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=True)\n    msg = '`factor_orders` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_orders=True)\n    msg = '`factor_multiplicities` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_multiplicities=True)\n    msg = f'Number of factors \\\\({dta.shape[1] + 1}\\\\) cannot be greater than'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=dta.shape[1] + 1)\n    factor_orders = {('a', 'b'): 1, 'b': 2}\n    msg = 'Each factor can be assigned to at most one block of factors in `factor_orders`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=['a', 'b'], factor_orders=factor_orders)\n    msg = 'If `endog_quarterly` is specified, then `endog` must contain only monthly variables, and so `k_endog_monthly` cannot be specified since it will be inferred from the shape of `endog`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, k_endog_monthly=2, endog_quarterly=dta)\n    msg = 'Invalid value passed for `standardize`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, standardize='a')\n    msg = 'If a `factors` dictionary is provided, then it must include entries for each observed variable.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a']})\n    msg = 'Each observed variable must be mapped to at least one factor in the `factors` dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a'], 'y2': []})\n    msg = 'Constant variable\\\\(s\\\\) found in observed variables, but constants cannot be included in this model.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta * 0)\n    msg = 'Given monthly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, endog_quarterly=dta)\n    msg = 'Given quarterly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta)\n    msg = 'Given monthly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_pd, endog_quarterly=dta_period_Q)\n    msg = 'Given quarterly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_pd)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_pd)\n    msg = 'Index of given monthly dataset has a non-monthly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_W, endog_quarterly=dta_period_Q)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_W, endog_quarterly=dta_period_Q)\n    msg = 'Index of given quarterly dataset has a non-quarterly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_period_W)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_date_W)",
        "mutated": [
            "def test_invalid_model_specification():\n    if False:\n        i = 10\n    dta = np.zeros((10, 2))\n    dta[0] = 1.0\n    dta_pd = pd.DataFrame(dta)\n    dta_period_W = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='W'))\n    dta_date_W = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='W'))\n    dta_period_M = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='M'))\n    dta_date_M = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='M'))\n    dta_period_Q = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='Q'))\n    msg = 'The model must contain at least one factor.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=0)\n    msg = '`factors` argument must an integer number of factors, a list of global factor names, or a dictionary, mapping observed variables to factors.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=True)\n    msg = '`factor_orders` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_orders=True)\n    msg = '`factor_multiplicities` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_multiplicities=True)\n    msg = f'Number of factors \\\\({dta.shape[1] + 1}\\\\) cannot be greater than'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=dta.shape[1] + 1)\n    factor_orders = {('a', 'b'): 1, 'b': 2}\n    msg = 'Each factor can be assigned to at most one block of factors in `factor_orders`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=['a', 'b'], factor_orders=factor_orders)\n    msg = 'If `endog_quarterly` is specified, then `endog` must contain only monthly variables, and so `k_endog_monthly` cannot be specified since it will be inferred from the shape of `endog`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, k_endog_monthly=2, endog_quarterly=dta)\n    msg = 'Invalid value passed for `standardize`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, standardize='a')\n    msg = 'If a `factors` dictionary is provided, then it must include entries for each observed variable.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a']})\n    msg = 'Each observed variable must be mapped to at least one factor in the `factors` dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a'], 'y2': []})\n    msg = 'Constant variable\\\\(s\\\\) found in observed variables, but constants cannot be included in this model.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta * 0)\n    msg = 'Given monthly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, endog_quarterly=dta)\n    msg = 'Given quarterly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta)\n    msg = 'Given monthly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_pd, endog_quarterly=dta_period_Q)\n    msg = 'Given quarterly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_pd)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_pd)\n    msg = 'Index of given monthly dataset has a non-monthly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_W, endog_quarterly=dta_period_Q)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_W, endog_quarterly=dta_period_Q)\n    msg = 'Index of given quarterly dataset has a non-quarterly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_period_W)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_date_W)",
            "def test_invalid_model_specification():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dta = np.zeros((10, 2))\n    dta[0] = 1.0\n    dta_pd = pd.DataFrame(dta)\n    dta_period_W = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='W'))\n    dta_date_W = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='W'))\n    dta_period_M = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='M'))\n    dta_date_M = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='M'))\n    dta_period_Q = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='Q'))\n    msg = 'The model must contain at least one factor.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=0)\n    msg = '`factors` argument must an integer number of factors, a list of global factor names, or a dictionary, mapping observed variables to factors.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=True)\n    msg = '`factor_orders` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_orders=True)\n    msg = '`factor_multiplicities` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_multiplicities=True)\n    msg = f'Number of factors \\\\({dta.shape[1] + 1}\\\\) cannot be greater than'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=dta.shape[1] + 1)\n    factor_orders = {('a', 'b'): 1, 'b': 2}\n    msg = 'Each factor can be assigned to at most one block of factors in `factor_orders`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=['a', 'b'], factor_orders=factor_orders)\n    msg = 'If `endog_quarterly` is specified, then `endog` must contain only monthly variables, and so `k_endog_monthly` cannot be specified since it will be inferred from the shape of `endog`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, k_endog_monthly=2, endog_quarterly=dta)\n    msg = 'Invalid value passed for `standardize`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, standardize='a')\n    msg = 'If a `factors` dictionary is provided, then it must include entries for each observed variable.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a']})\n    msg = 'Each observed variable must be mapped to at least one factor in the `factors` dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a'], 'y2': []})\n    msg = 'Constant variable\\\\(s\\\\) found in observed variables, but constants cannot be included in this model.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta * 0)\n    msg = 'Given monthly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, endog_quarterly=dta)\n    msg = 'Given quarterly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta)\n    msg = 'Given monthly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_pd, endog_quarterly=dta_period_Q)\n    msg = 'Given quarterly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_pd)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_pd)\n    msg = 'Index of given monthly dataset has a non-monthly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_W, endog_quarterly=dta_period_Q)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_W, endog_quarterly=dta_period_Q)\n    msg = 'Index of given quarterly dataset has a non-quarterly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_period_W)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_date_W)",
            "def test_invalid_model_specification():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dta = np.zeros((10, 2))\n    dta[0] = 1.0\n    dta_pd = pd.DataFrame(dta)\n    dta_period_W = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='W'))\n    dta_date_W = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='W'))\n    dta_period_M = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='M'))\n    dta_date_M = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='M'))\n    dta_period_Q = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='Q'))\n    msg = 'The model must contain at least one factor.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=0)\n    msg = '`factors` argument must an integer number of factors, a list of global factor names, or a dictionary, mapping observed variables to factors.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=True)\n    msg = '`factor_orders` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_orders=True)\n    msg = '`factor_multiplicities` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_multiplicities=True)\n    msg = f'Number of factors \\\\({dta.shape[1] + 1}\\\\) cannot be greater than'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=dta.shape[1] + 1)\n    factor_orders = {('a', 'b'): 1, 'b': 2}\n    msg = 'Each factor can be assigned to at most one block of factors in `factor_orders`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=['a', 'b'], factor_orders=factor_orders)\n    msg = 'If `endog_quarterly` is specified, then `endog` must contain only monthly variables, and so `k_endog_monthly` cannot be specified since it will be inferred from the shape of `endog`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, k_endog_monthly=2, endog_quarterly=dta)\n    msg = 'Invalid value passed for `standardize`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, standardize='a')\n    msg = 'If a `factors` dictionary is provided, then it must include entries for each observed variable.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a']})\n    msg = 'Each observed variable must be mapped to at least one factor in the `factors` dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a'], 'y2': []})\n    msg = 'Constant variable\\\\(s\\\\) found in observed variables, but constants cannot be included in this model.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta * 0)\n    msg = 'Given monthly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, endog_quarterly=dta)\n    msg = 'Given quarterly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta)\n    msg = 'Given monthly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_pd, endog_quarterly=dta_period_Q)\n    msg = 'Given quarterly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_pd)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_pd)\n    msg = 'Index of given monthly dataset has a non-monthly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_W, endog_quarterly=dta_period_Q)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_W, endog_quarterly=dta_period_Q)\n    msg = 'Index of given quarterly dataset has a non-quarterly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_period_W)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_date_W)",
            "def test_invalid_model_specification():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dta = np.zeros((10, 2))\n    dta[0] = 1.0\n    dta_pd = pd.DataFrame(dta)\n    dta_period_W = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='W'))\n    dta_date_W = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='W'))\n    dta_period_M = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='M'))\n    dta_date_M = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='M'))\n    dta_period_Q = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='Q'))\n    msg = 'The model must contain at least one factor.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=0)\n    msg = '`factors` argument must an integer number of factors, a list of global factor names, or a dictionary, mapping observed variables to factors.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=True)\n    msg = '`factor_orders` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_orders=True)\n    msg = '`factor_multiplicities` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_multiplicities=True)\n    msg = f'Number of factors \\\\({dta.shape[1] + 1}\\\\) cannot be greater than'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=dta.shape[1] + 1)\n    factor_orders = {('a', 'b'): 1, 'b': 2}\n    msg = 'Each factor can be assigned to at most one block of factors in `factor_orders`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=['a', 'b'], factor_orders=factor_orders)\n    msg = 'If `endog_quarterly` is specified, then `endog` must contain only monthly variables, and so `k_endog_monthly` cannot be specified since it will be inferred from the shape of `endog`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, k_endog_monthly=2, endog_quarterly=dta)\n    msg = 'Invalid value passed for `standardize`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, standardize='a')\n    msg = 'If a `factors` dictionary is provided, then it must include entries for each observed variable.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a']})\n    msg = 'Each observed variable must be mapped to at least one factor in the `factors` dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a'], 'y2': []})\n    msg = 'Constant variable\\\\(s\\\\) found in observed variables, but constants cannot be included in this model.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta * 0)\n    msg = 'Given monthly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, endog_quarterly=dta)\n    msg = 'Given quarterly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta)\n    msg = 'Given monthly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_pd, endog_quarterly=dta_period_Q)\n    msg = 'Given quarterly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_pd)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_pd)\n    msg = 'Index of given monthly dataset has a non-monthly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_W, endog_quarterly=dta_period_Q)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_W, endog_quarterly=dta_period_Q)\n    msg = 'Index of given quarterly dataset has a non-quarterly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_period_W)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_date_W)",
            "def test_invalid_model_specification():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dta = np.zeros((10, 2))\n    dta[0] = 1.0\n    dta_pd = pd.DataFrame(dta)\n    dta_period_W = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='W'))\n    dta_date_W = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='W'))\n    dta_period_M = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='M'))\n    dta_date_M = pd.DataFrame(dta, index=pd.date_range(start='2000', periods=10, freq='M'))\n    dta_period_Q = pd.DataFrame(dta, index=pd.period_range(start='2000', periods=10, freq='Q'))\n    msg = 'The model must contain at least one factor.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=0)\n    msg = '`factors` argument must an integer number of factors, a list of global factor names, or a dictionary, mapping observed variables to factors.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=True)\n    msg = '`factor_orders` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_orders=True)\n    msg = '`factor_multiplicities` argument must either be an integer or a dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factor_multiplicities=True)\n    msg = f'Number of factors \\\\({dta.shape[1] + 1}\\\\) cannot be greater than'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=dta.shape[1] + 1)\n    factor_orders = {('a', 'b'): 1, 'b': 2}\n    msg = 'Each factor can be assigned to at most one block of factors in `factor_orders`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors=['a', 'b'], factor_orders=factor_orders)\n    msg = 'If `endog_quarterly` is specified, then `endog` must contain only monthly variables, and so `k_endog_monthly` cannot be specified since it will be inferred from the shape of `endog`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, k_endog_monthly=2, endog_quarterly=dta)\n    msg = 'Invalid value passed for `standardize`.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, standardize='a')\n    msg = 'If a `factors` dictionary is provided, then it must include entries for each observed variable.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a']})\n    msg = 'Each observed variable must be mapped to at least one factor in the `factors` dictionary.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, factors={'y1': ['a'], 'y2': []})\n    msg = 'Constant variable\\\\(s\\\\) found in observed variables, but constants cannot be included in this model.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta * 0)\n    msg = 'Given monthly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta, endog_quarterly=dta)\n    msg = 'Given quarterly dataset is not a Pandas object.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta)\n    msg = 'Given monthly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_pd, endog_quarterly=dta_period_Q)\n    msg = 'Given quarterly dataset has an index with non-date values.'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_pd)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_pd)\n    msg = 'Index of given monthly dataset has a non-monthly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_W, endog_quarterly=dta_period_Q)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_W, endog_quarterly=dta_period_Q)\n    msg = 'Index of given quarterly dataset has a non-quarterly frequency'\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_period_M, endog_quarterly=dta_period_W)\n    with pytest.raises(ValueError, match=msg):\n        dynamic_factor_mq.DynamicFactorMQ(dta_date_M, endog_quarterly=dta_date_W)"
        ]
    },
    {
        "func_name": "test_date_indexes",
        "original": "@pytest.mark.parametrize('freq_Q', ['Q', 'Q-DEC', 'Q-JAN', 'QS', 'QS-DEC', 'QS-APR'])\n@pytest.mark.parametrize('freq_M', ['M', 'MS'])\ndef test_date_indexes(reset_randomstate, freq_M, freq_Q):\n    nobs_M = 10\n    dates_M = pd.date_range(start='2000', periods=nobs_M, freq=freq_M)\n    periods_M = pd.period_range(start='2000', periods=nobs_M, freq='M')\n    dta_M = np.random.normal(size=(nobs_M, 2))\n    endog_period_M = pd.DataFrame(dta_M.copy(), index=periods_M)\n    endog_date_M = pd.DataFrame(dta_M.copy(), index=dates_M)\n    nobs_Q = 3\n    dates_Q = pd.date_range(start='2000', periods=nobs_Q, freq=freq_Q)\n    periods_Q = pd.period_range(start='2000', periods=nobs_Q, freq='Q')\n    dta_Q = np.random.normal(size=(nobs_Q, 2))\n    endog_period_Q = pd.DataFrame(dta_Q.copy(), index=periods_Q)\n    endog_date_Q = pd.DataFrame(dta_Q.copy(), index=dates_Q)\n    mod_base = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_period_Q)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_period_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)",
        "mutated": [
            "@pytest.mark.parametrize('freq_Q', ['Q', 'Q-DEC', 'Q-JAN', 'QS', 'QS-DEC', 'QS-APR'])\n@pytest.mark.parametrize('freq_M', ['M', 'MS'])\ndef test_date_indexes(reset_randomstate, freq_M, freq_Q):\n    if False:\n        i = 10\n    nobs_M = 10\n    dates_M = pd.date_range(start='2000', periods=nobs_M, freq=freq_M)\n    periods_M = pd.period_range(start='2000', periods=nobs_M, freq='M')\n    dta_M = np.random.normal(size=(nobs_M, 2))\n    endog_period_M = pd.DataFrame(dta_M.copy(), index=periods_M)\n    endog_date_M = pd.DataFrame(dta_M.copy(), index=dates_M)\n    nobs_Q = 3\n    dates_Q = pd.date_range(start='2000', periods=nobs_Q, freq=freq_Q)\n    periods_Q = pd.period_range(start='2000', periods=nobs_Q, freq='Q')\n    dta_Q = np.random.normal(size=(nobs_Q, 2))\n    endog_period_Q = pd.DataFrame(dta_Q.copy(), index=periods_Q)\n    endog_date_Q = pd.DataFrame(dta_Q.copy(), index=dates_Q)\n    mod_base = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_period_Q)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_period_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)",
            "@pytest.mark.parametrize('freq_Q', ['Q', 'Q-DEC', 'Q-JAN', 'QS', 'QS-DEC', 'QS-APR'])\n@pytest.mark.parametrize('freq_M', ['M', 'MS'])\ndef test_date_indexes(reset_randomstate, freq_M, freq_Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nobs_M = 10\n    dates_M = pd.date_range(start='2000', periods=nobs_M, freq=freq_M)\n    periods_M = pd.period_range(start='2000', periods=nobs_M, freq='M')\n    dta_M = np.random.normal(size=(nobs_M, 2))\n    endog_period_M = pd.DataFrame(dta_M.copy(), index=periods_M)\n    endog_date_M = pd.DataFrame(dta_M.copy(), index=dates_M)\n    nobs_Q = 3\n    dates_Q = pd.date_range(start='2000', periods=nobs_Q, freq=freq_Q)\n    periods_Q = pd.period_range(start='2000', periods=nobs_Q, freq='Q')\n    dta_Q = np.random.normal(size=(nobs_Q, 2))\n    endog_period_Q = pd.DataFrame(dta_Q.copy(), index=periods_Q)\n    endog_date_Q = pd.DataFrame(dta_Q.copy(), index=dates_Q)\n    mod_base = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_period_Q)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_period_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)",
            "@pytest.mark.parametrize('freq_Q', ['Q', 'Q-DEC', 'Q-JAN', 'QS', 'QS-DEC', 'QS-APR'])\n@pytest.mark.parametrize('freq_M', ['M', 'MS'])\ndef test_date_indexes(reset_randomstate, freq_M, freq_Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nobs_M = 10\n    dates_M = pd.date_range(start='2000', periods=nobs_M, freq=freq_M)\n    periods_M = pd.period_range(start='2000', periods=nobs_M, freq='M')\n    dta_M = np.random.normal(size=(nobs_M, 2))\n    endog_period_M = pd.DataFrame(dta_M.copy(), index=periods_M)\n    endog_date_M = pd.DataFrame(dta_M.copy(), index=dates_M)\n    nobs_Q = 3\n    dates_Q = pd.date_range(start='2000', periods=nobs_Q, freq=freq_Q)\n    periods_Q = pd.period_range(start='2000', periods=nobs_Q, freq='Q')\n    dta_Q = np.random.normal(size=(nobs_Q, 2))\n    endog_period_Q = pd.DataFrame(dta_Q.copy(), index=periods_Q)\n    endog_date_Q = pd.DataFrame(dta_Q.copy(), index=dates_Q)\n    mod_base = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_period_Q)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_period_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)",
            "@pytest.mark.parametrize('freq_Q', ['Q', 'Q-DEC', 'Q-JAN', 'QS', 'QS-DEC', 'QS-APR'])\n@pytest.mark.parametrize('freq_M', ['M', 'MS'])\ndef test_date_indexes(reset_randomstate, freq_M, freq_Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nobs_M = 10\n    dates_M = pd.date_range(start='2000', periods=nobs_M, freq=freq_M)\n    periods_M = pd.period_range(start='2000', periods=nobs_M, freq='M')\n    dta_M = np.random.normal(size=(nobs_M, 2))\n    endog_period_M = pd.DataFrame(dta_M.copy(), index=periods_M)\n    endog_date_M = pd.DataFrame(dta_M.copy(), index=dates_M)\n    nobs_Q = 3\n    dates_Q = pd.date_range(start='2000', periods=nobs_Q, freq=freq_Q)\n    periods_Q = pd.period_range(start='2000', periods=nobs_Q, freq='Q')\n    dta_Q = np.random.normal(size=(nobs_Q, 2))\n    endog_period_Q = pd.DataFrame(dta_Q.copy(), index=periods_Q)\n    endog_date_Q = pd.DataFrame(dta_Q.copy(), index=dates_Q)\n    mod_base = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_period_Q)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_period_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)",
            "@pytest.mark.parametrize('freq_Q', ['Q', 'Q-DEC', 'Q-JAN', 'QS', 'QS-DEC', 'QS-APR'])\n@pytest.mark.parametrize('freq_M', ['M', 'MS'])\ndef test_date_indexes(reset_randomstate, freq_M, freq_Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nobs_M = 10\n    dates_M = pd.date_range(start='2000', periods=nobs_M, freq=freq_M)\n    periods_M = pd.period_range(start='2000', periods=nobs_M, freq='M')\n    dta_M = np.random.normal(size=(nobs_M, 2))\n    endog_period_M = pd.DataFrame(dta_M.copy(), index=periods_M)\n    endog_date_M = pd.DataFrame(dta_M.copy(), index=dates_M)\n    nobs_Q = 3\n    dates_Q = pd.date_range(start='2000', periods=nobs_Q, freq=freq_Q)\n    periods_Q = pd.period_range(start='2000', periods=nobs_Q, freq='Q')\n    dta_Q = np.random.normal(size=(nobs_Q, 2))\n    endog_period_Q = pd.DataFrame(dta_Q.copy(), index=periods_Q)\n    endog_date_Q = pd.DataFrame(dta_Q.copy(), index=dates_Q)\n    mod_base = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_period_Q)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_date_M, endog_quarterly=endog_period_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_period_M, endog_quarterly=endog_date_Q)\n    assert_(mod._index.equals(mod_base._index))\n    assert_allclose(mod.endog, mod_base.endog)"
        ]
    },
    {
        "func_name": "gen_dfm_data",
        "original": "def gen_dfm_data(k_endog=2, nobs=1000):\n    if k_endog > 10:\n        raise ValueError('Only allows for k_endog <= 10')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0] * k_endog], index=ix)\n    mod = dynamic_factor.DynamicFactor(faux, k_factors=1, factor_order=1)\n    loadings = [0.5, -0.9, 0.2, 0.7, -0.1, -0.1, 0.4, 0.4, 0.8, 0.8][:k_endog]\n    phi = 0.5\n    sigma2 = 1.0\n    idio_ar1 = [0] * k_endog\n    idio_var = [1.0, 0.2, 1.5, 0.8, 0.8, 1.4, 0.1, 0.2, 0.4, 0.5][:k_endog]\n    params = np.r_[loadings, idio_var, phi]\n    endog = mod.simulate(params, nobs)\n    return (endog, loadings, phi, sigma2, idio_ar1, idio_var)",
        "mutated": [
            "def gen_dfm_data(k_endog=2, nobs=1000):\n    if False:\n        i = 10\n    if k_endog > 10:\n        raise ValueError('Only allows for k_endog <= 10')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0] * k_endog], index=ix)\n    mod = dynamic_factor.DynamicFactor(faux, k_factors=1, factor_order=1)\n    loadings = [0.5, -0.9, 0.2, 0.7, -0.1, -0.1, 0.4, 0.4, 0.8, 0.8][:k_endog]\n    phi = 0.5\n    sigma2 = 1.0\n    idio_ar1 = [0] * k_endog\n    idio_var = [1.0, 0.2, 1.5, 0.8, 0.8, 1.4, 0.1, 0.2, 0.4, 0.5][:k_endog]\n    params = np.r_[loadings, idio_var, phi]\n    endog = mod.simulate(params, nobs)\n    return (endog, loadings, phi, sigma2, idio_ar1, idio_var)",
            "def gen_dfm_data(k_endog=2, nobs=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if k_endog > 10:\n        raise ValueError('Only allows for k_endog <= 10')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0] * k_endog], index=ix)\n    mod = dynamic_factor.DynamicFactor(faux, k_factors=1, factor_order=1)\n    loadings = [0.5, -0.9, 0.2, 0.7, -0.1, -0.1, 0.4, 0.4, 0.8, 0.8][:k_endog]\n    phi = 0.5\n    sigma2 = 1.0\n    idio_ar1 = [0] * k_endog\n    idio_var = [1.0, 0.2, 1.5, 0.8, 0.8, 1.4, 0.1, 0.2, 0.4, 0.5][:k_endog]\n    params = np.r_[loadings, idio_var, phi]\n    endog = mod.simulate(params, nobs)\n    return (endog, loadings, phi, sigma2, idio_ar1, idio_var)",
            "def gen_dfm_data(k_endog=2, nobs=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if k_endog > 10:\n        raise ValueError('Only allows for k_endog <= 10')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0] * k_endog], index=ix)\n    mod = dynamic_factor.DynamicFactor(faux, k_factors=1, factor_order=1)\n    loadings = [0.5, -0.9, 0.2, 0.7, -0.1, -0.1, 0.4, 0.4, 0.8, 0.8][:k_endog]\n    phi = 0.5\n    sigma2 = 1.0\n    idio_ar1 = [0] * k_endog\n    idio_var = [1.0, 0.2, 1.5, 0.8, 0.8, 1.4, 0.1, 0.2, 0.4, 0.5][:k_endog]\n    params = np.r_[loadings, idio_var, phi]\n    endog = mod.simulate(params, nobs)\n    return (endog, loadings, phi, sigma2, idio_ar1, idio_var)",
            "def gen_dfm_data(k_endog=2, nobs=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if k_endog > 10:\n        raise ValueError('Only allows for k_endog <= 10')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0] * k_endog], index=ix)\n    mod = dynamic_factor.DynamicFactor(faux, k_factors=1, factor_order=1)\n    loadings = [0.5, -0.9, 0.2, 0.7, -0.1, -0.1, 0.4, 0.4, 0.8, 0.8][:k_endog]\n    phi = 0.5\n    sigma2 = 1.0\n    idio_ar1 = [0] * k_endog\n    idio_var = [1.0, 0.2, 1.5, 0.8, 0.8, 1.4, 0.1, 0.2, 0.4, 0.5][:k_endog]\n    params = np.r_[loadings, idio_var, phi]\n    endog = mod.simulate(params, nobs)\n    return (endog, loadings, phi, sigma2, idio_ar1, idio_var)",
            "def gen_dfm_data(k_endog=2, nobs=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if k_endog > 10:\n        raise ValueError('Only allows for k_endog <= 10')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0] * k_endog], index=ix)\n    mod = dynamic_factor.DynamicFactor(faux, k_factors=1, factor_order=1)\n    loadings = [0.5, -0.9, 0.2, 0.7, -0.1, -0.1, 0.4, 0.4, 0.8, 0.8][:k_endog]\n    phi = 0.5\n    sigma2 = 1.0\n    idio_ar1 = [0] * k_endog\n    idio_var = [1.0, 0.2, 1.5, 0.8, 0.8, 1.4, 0.1, 0.2, 0.4, 0.5][:k_endog]\n    params = np.r_[loadings, idio_var, phi]\n    endog = mod.simulate(params, nobs)\n    return (endog, loadings, phi, sigma2, idio_ar1, idio_var)"
        ]
    },
    {
        "func_name": "test_results_factors",
        "original": "def test_results_factors(reset_randomstate):\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factors=['global'], factor_multiplicities=2, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    assert_allclose(res_dfm.factors.smoothed, res_dfm.states.smoothed[['global.1', 'global.2']])\n    assert_allclose(res_dfm.factors.smoothed_cov.values, res_dfm.states.smoothed_cov.values, atol=1e-12)",
        "mutated": [
            "def test_results_factors(reset_randomstate):\n    if False:\n        i = 10\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factors=['global'], factor_multiplicities=2, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    assert_allclose(res_dfm.factors.smoothed, res_dfm.states.smoothed[['global.1', 'global.2']])\n    assert_allclose(res_dfm.factors.smoothed_cov.values, res_dfm.states.smoothed_cov.values, atol=1e-12)",
            "def test_results_factors(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factors=['global'], factor_multiplicities=2, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    assert_allclose(res_dfm.factors.smoothed, res_dfm.states.smoothed[['global.1', 'global.2']])\n    assert_allclose(res_dfm.factors.smoothed_cov.values, res_dfm.states.smoothed_cov.values, atol=1e-12)",
            "def test_results_factors(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factors=['global'], factor_multiplicities=2, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    assert_allclose(res_dfm.factors.smoothed, res_dfm.states.smoothed[['global.1', 'global.2']])\n    assert_allclose(res_dfm.factors.smoothed_cov.values, res_dfm.states.smoothed_cov.values, atol=1e-12)",
            "def test_results_factors(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factors=['global'], factor_multiplicities=2, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    assert_allclose(res_dfm.factors.smoothed, res_dfm.states.smoothed[['global.1', 'global.2']])\n    assert_allclose(res_dfm.factors.smoothed_cov.values, res_dfm.states.smoothed_cov.values, atol=1e-12)",
            "def test_results_factors(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factors=['global'], factor_multiplicities=2, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    assert_allclose(res_dfm.factors.smoothed, res_dfm.states.smoothed[['global.1', 'global.2']])\n    assert_allclose(res_dfm.factors.smoothed_cov.values, res_dfm.states.smoothed_cov.values, atol=1e-12)"
        ]
    },
    {
        "func_name": "test_coefficient_of_determination",
        "original": "def test_coefficient_of_determination(reset_randomstate, close_figures):\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=3, nobs=1000)\n    endog.iloc[0, 10:20] = np.nan\n    endog.iloc[2, 15:25] = np.nan\n    factors = {0: ['global', 'block'], 1: ['global', 'block'], 2: ['global']}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=factors, standardize=False, idiosyncratic_ar1=False)\n    res = mod.smooth(mod.start_params)\n    factors = res.factors.smoothed\n    actual = res.get_coefficients_of_determination(method='individual')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='joint')\n    desired = pd.Series(np.zeros(3), index=[0, 1, 2])\n    for i in range(3):\n        y = endog.iloc[:, i]\n        if i == 2:\n            X = add_constant(factors.iloc[:, 0])\n        else:\n            X = add_constant(factors)\n        mod_ols = OLS(y, X, missing='drop')\n        res_ols = mod_ols.fit()\n        desired.iloc[i] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='cumulative')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, :j + 1])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    factors = res.factors.filtered\n    actual = res.get_coefficients_of_determination(method='individual', which='filtered')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_allclose(actual, desired)\n    try:\n        import matplotlib.pyplot as plt\n        try:\n            from pandas.plotting import register_matplotlib_converters\n            register_matplotlib_converters()\n        except ImportError:\n            pass\n        fig1 = plt.figure()\n        res.plot_coefficients_of_determination(method='individual', fig=fig1)\n        fig2 = plt.figure()\n        res.plot_coefficients_of_determination(method='joint', fig=fig2)\n        fig3 = plt.figure()\n        res.plot_coefficients_of_determination(method='cumulative', fig=fig3)\n        fig4 = plt.figure()\n        res.plot_coefficients_of_determination(which='filtered', fig=fig4)\n    except ImportError:\n        pass",
        "mutated": [
            "def test_coefficient_of_determination(reset_randomstate, close_figures):\n    if False:\n        i = 10\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=3, nobs=1000)\n    endog.iloc[0, 10:20] = np.nan\n    endog.iloc[2, 15:25] = np.nan\n    factors = {0: ['global', 'block'], 1: ['global', 'block'], 2: ['global']}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=factors, standardize=False, idiosyncratic_ar1=False)\n    res = mod.smooth(mod.start_params)\n    factors = res.factors.smoothed\n    actual = res.get_coefficients_of_determination(method='individual')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='joint')\n    desired = pd.Series(np.zeros(3), index=[0, 1, 2])\n    for i in range(3):\n        y = endog.iloc[:, i]\n        if i == 2:\n            X = add_constant(factors.iloc[:, 0])\n        else:\n            X = add_constant(factors)\n        mod_ols = OLS(y, X, missing='drop')\n        res_ols = mod_ols.fit()\n        desired.iloc[i] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='cumulative')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, :j + 1])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    factors = res.factors.filtered\n    actual = res.get_coefficients_of_determination(method='individual', which='filtered')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_allclose(actual, desired)\n    try:\n        import matplotlib.pyplot as plt\n        try:\n            from pandas.plotting import register_matplotlib_converters\n            register_matplotlib_converters()\n        except ImportError:\n            pass\n        fig1 = plt.figure()\n        res.plot_coefficients_of_determination(method='individual', fig=fig1)\n        fig2 = plt.figure()\n        res.plot_coefficients_of_determination(method='joint', fig=fig2)\n        fig3 = plt.figure()\n        res.plot_coefficients_of_determination(method='cumulative', fig=fig3)\n        fig4 = plt.figure()\n        res.plot_coefficients_of_determination(which='filtered', fig=fig4)\n    except ImportError:\n        pass",
            "def test_coefficient_of_determination(reset_randomstate, close_figures):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=3, nobs=1000)\n    endog.iloc[0, 10:20] = np.nan\n    endog.iloc[2, 15:25] = np.nan\n    factors = {0: ['global', 'block'], 1: ['global', 'block'], 2: ['global']}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=factors, standardize=False, idiosyncratic_ar1=False)\n    res = mod.smooth(mod.start_params)\n    factors = res.factors.smoothed\n    actual = res.get_coefficients_of_determination(method='individual')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='joint')\n    desired = pd.Series(np.zeros(3), index=[0, 1, 2])\n    for i in range(3):\n        y = endog.iloc[:, i]\n        if i == 2:\n            X = add_constant(factors.iloc[:, 0])\n        else:\n            X = add_constant(factors)\n        mod_ols = OLS(y, X, missing='drop')\n        res_ols = mod_ols.fit()\n        desired.iloc[i] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='cumulative')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, :j + 1])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    factors = res.factors.filtered\n    actual = res.get_coefficients_of_determination(method='individual', which='filtered')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_allclose(actual, desired)\n    try:\n        import matplotlib.pyplot as plt\n        try:\n            from pandas.plotting import register_matplotlib_converters\n            register_matplotlib_converters()\n        except ImportError:\n            pass\n        fig1 = plt.figure()\n        res.plot_coefficients_of_determination(method='individual', fig=fig1)\n        fig2 = plt.figure()\n        res.plot_coefficients_of_determination(method='joint', fig=fig2)\n        fig3 = plt.figure()\n        res.plot_coefficients_of_determination(method='cumulative', fig=fig3)\n        fig4 = plt.figure()\n        res.plot_coefficients_of_determination(which='filtered', fig=fig4)\n    except ImportError:\n        pass",
            "def test_coefficient_of_determination(reset_randomstate, close_figures):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=3, nobs=1000)\n    endog.iloc[0, 10:20] = np.nan\n    endog.iloc[2, 15:25] = np.nan\n    factors = {0: ['global', 'block'], 1: ['global', 'block'], 2: ['global']}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=factors, standardize=False, idiosyncratic_ar1=False)\n    res = mod.smooth(mod.start_params)\n    factors = res.factors.smoothed\n    actual = res.get_coefficients_of_determination(method='individual')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='joint')\n    desired = pd.Series(np.zeros(3), index=[0, 1, 2])\n    for i in range(3):\n        y = endog.iloc[:, i]\n        if i == 2:\n            X = add_constant(factors.iloc[:, 0])\n        else:\n            X = add_constant(factors)\n        mod_ols = OLS(y, X, missing='drop')\n        res_ols = mod_ols.fit()\n        desired.iloc[i] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='cumulative')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, :j + 1])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    factors = res.factors.filtered\n    actual = res.get_coefficients_of_determination(method='individual', which='filtered')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_allclose(actual, desired)\n    try:\n        import matplotlib.pyplot as plt\n        try:\n            from pandas.plotting import register_matplotlib_converters\n            register_matplotlib_converters()\n        except ImportError:\n            pass\n        fig1 = plt.figure()\n        res.plot_coefficients_of_determination(method='individual', fig=fig1)\n        fig2 = plt.figure()\n        res.plot_coefficients_of_determination(method='joint', fig=fig2)\n        fig3 = plt.figure()\n        res.plot_coefficients_of_determination(method='cumulative', fig=fig3)\n        fig4 = plt.figure()\n        res.plot_coefficients_of_determination(which='filtered', fig=fig4)\n    except ImportError:\n        pass",
            "def test_coefficient_of_determination(reset_randomstate, close_figures):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=3, nobs=1000)\n    endog.iloc[0, 10:20] = np.nan\n    endog.iloc[2, 15:25] = np.nan\n    factors = {0: ['global', 'block'], 1: ['global', 'block'], 2: ['global']}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=factors, standardize=False, idiosyncratic_ar1=False)\n    res = mod.smooth(mod.start_params)\n    factors = res.factors.smoothed\n    actual = res.get_coefficients_of_determination(method='individual')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='joint')\n    desired = pd.Series(np.zeros(3), index=[0, 1, 2])\n    for i in range(3):\n        y = endog.iloc[:, i]\n        if i == 2:\n            X = add_constant(factors.iloc[:, 0])\n        else:\n            X = add_constant(factors)\n        mod_ols = OLS(y, X, missing='drop')\n        res_ols = mod_ols.fit()\n        desired.iloc[i] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='cumulative')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, :j + 1])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    factors = res.factors.filtered\n    actual = res.get_coefficients_of_determination(method='individual', which='filtered')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_allclose(actual, desired)\n    try:\n        import matplotlib.pyplot as plt\n        try:\n            from pandas.plotting import register_matplotlib_converters\n            register_matplotlib_converters()\n        except ImportError:\n            pass\n        fig1 = plt.figure()\n        res.plot_coefficients_of_determination(method='individual', fig=fig1)\n        fig2 = plt.figure()\n        res.plot_coefficients_of_determination(method='joint', fig=fig2)\n        fig3 = plt.figure()\n        res.plot_coefficients_of_determination(method='cumulative', fig=fig3)\n        fig4 = plt.figure()\n        res.plot_coefficients_of_determination(which='filtered', fig=fig4)\n    except ImportError:\n        pass",
            "def test_coefficient_of_determination(reset_randomstate, close_figures):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=3, nobs=1000)\n    endog.iloc[0, 10:20] = np.nan\n    endog.iloc[2, 15:25] = np.nan\n    factors = {0: ['global', 'block'], 1: ['global', 'block'], 2: ['global']}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=factors, standardize=False, idiosyncratic_ar1=False)\n    res = mod.smooth(mod.start_params)\n    factors = res.factors.smoothed\n    actual = res.get_coefficients_of_determination(method='individual')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='joint')\n    desired = pd.Series(np.zeros(3), index=[0, 1, 2])\n    for i in range(3):\n        y = endog.iloc[:, i]\n        if i == 2:\n            X = add_constant(factors.iloc[:, 0])\n        else:\n            X = add_constant(factors)\n        mod_ols = OLS(y, X, missing='drop')\n        res_ols = mod_ols.fit()\n        desired.iloc[i] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_allclose(actual, desired)\n    actual = res.get_coefficients_of_determination(method='cumulative')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, :j + 1])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_(actual.index.equals(desired.index))\n    assert_(actual.columns.equals(desired.columns))\n    assert_allclose(actual, desired)\n    factors = res.factors.filtered\n    actual = res.get_coefficients_of_determination(method='individual', which='filtered')\n    desired = pd.DataFrame(np.zeros((3, 2)), index=[0, 1, 2], columns=['global', 'block'])\n    for i in range(3):\n        for j in range(2):\n            if i == 2 and j == 1:\n                desired.iloc[i, j] = np.nan\n            else:\n                y = endog.iloc[:, i]\n                X = add_constant(factors.iloc[:, j])\n                mod_ols = OLS(y, X, missing='drop')\n                res_ols = mod_ols.fit()\n                desired.iloc[i, j] = res_ols.rsquared\n    assert_allclose(actual, desired)\n    try:\n        import matplotlib.pyplot as plt\n        try:\n            from pandas.plotting import register_matplotlib_converters\n            register_matplotlib_converters()\n        except ImportError:\n            pass\n        fig1 = plt.figure()\n        res.plot_coefficients_of_determination(method='individual', fig=fig1)\n        fig2 = plt.figure()\n        res.plot_coefficients_of_determination(method='joint', fig=fig2)\n        fig3 = plt.figure()\n        res.plot_coefficients_of_determination(method='cumulative', fig=fig3)\n        fig4 = plt.figure()\n        res.plot_coefficients_of_determination(which='filtered', fig=fig4)\n    except ImportError:\n        pass"
        ]
    },
    {
        "func_name": "test_quasi_newton_fitting",
        "original": "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_quasi_newton_fitting(reset_randomstate):\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    x = mod_dfm_ar1.start_params\n    y = mod_dfm_ar1.untransform_params(x)\n    z = mod_dfm_ar1.transform_params(y)\n    assert_allclose(x, z)\n    res_lbfgs = mod_dfm.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm.fit(start_params, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)\n    res_lbfgs = mod_dfm_ar1.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm_ar1.fit(params_lbfgs, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)",
        "mutated": [
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_quasi_newton_fitting(reset_randomstate):\n    if False:\n        i = 10\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    x = mod_dfm_ar1.start_params\n    y = mod_dfm_ar1.untransform_params(x)\n    z = mod_dfm_ar1.transform_params(y)\n    assert_allclose(x, z)\n    res_lbfgs = mod_dfm.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm.fit(start_params, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)\n    res_lbfgs = mod_dfm_ar1.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm_ar1.fit(params_lbfgs, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)",
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_quasi_newton_fitting(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    x = mod_dfm_ar1.start_params\n    y = mod_dfm_ar1.untransform_params(x)\n    z = mod_dfm_ar1.transform_params(y)\n    assert_allclose(x, z)\n    res_lbfgs = mod_dfm.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm.fit(start_params, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)\n    res_lbfgs = mod_dfm_ar1.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm_ar1.fit(params_lbfgs, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)",
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_quasi_newton_fitting(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    x = mod_dfm_ar1.start_params\n    y = mod_dfm_ar1.untransform_params(x)\n    z = mod_dfm_ar1.transform_params(y)\n    assert_allclose(x, z)\n    res_lbfgs = mod_dfm.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm.fit(start_params, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)\n    res_lbfgs = mod_dfm_ar1.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm_ar1.fit(params_lbfgs, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)",
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_quasi_newton_fitting(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    x = mod_dfm_ar1.start_params\n    y = mod_dfm_ar1.untransform_params(x)\n    z = mod_dfm_ar1.transform_params(y)\n    assert_allclose(x, z)\n    res_lbfgs = mod_dfm.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm.fit(start_params, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)\n    res_lbfgs = mod_dfm_ar1.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm_ar1.fit(params_lbfgs, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)",
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_quasi_newton_fitting(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=2, nobs=1000)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    x = mod_dfm_ar1.start_params\n    y = mod_dfm_ar1.untransform_params(x)\n    z = mod_dfm_ar1.transform_params(y)\n    assert_allclose(x, z)\n    res_lbfgs = mod_dfm.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm.fit(start_params, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)\n    res_lbfgs = mod_dfm_ar1.fit(method='lbfgs')\n    params_lbfgs = res_lbfgs.params.copy()\n    start_params = params_lbfgs.copy()\n    start_params['L1.0->0'] += 0.01\n    start_params['fb(0).cov.chol[1,1]'] += 0.01\n    res_em = mod_dfm_ar1.fit(params_lbfgs, em_initialization=False)\n    params_em = res_em.params.copy()\n    assert_allclose(res_lbfgs.llf, res_em.llf, atol=0.05, rtol=1e-05)\n    assert_allclose(params_lbfgs, params_em, atol=0.05, rtol=1e-05)"
        ]
    },
    {
        "func_name": "test_summary",
        "original": "def test_summary(reset_randomstate):\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    res_dfm_ar1 = mod_dfm_ar1.smooth(mod_dfm_ar1.start_params)\n    mod_dfm.summary()\n    assert_equal(str(mod_dfm), str(mod_dfm.summary()))\n    res_dfm.summary()\n    mod_dfm_ar1.summary()\n    res_dfm_ar1.summary()",
        "mutated": [
            "def test_summary(reset_randomstate):\n    if False:\n        i = 10\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    res_dfm_ar1 = mod_dfm_ar1.smooth(mod_dfm_ar1.start_params)\n    mod_dfm.summary()\n    assert_equal(str(mod_dfm), str(mod_dfm.summary()))\n    res_dfm.summary()\n    mod_dfm_ar1.summary()\n    res_dfm_ar1.summary()",
            "def test_summary(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    res_dfm_ar1 = mod_dfm_ar1.smooth(mod_dfm_ar1.start_params)\n    mod_dfm.summary()\n    assert_equal(str(mod_dfm), str(mod_dfm.summary()))\n    res_dfm.summary()\n    mod_dfm_ar1.summary()\n    res_dfm_ar1.summary()",
            "def test_summary(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    res_dfm_ar1 = mod_dfm_ar1.smooth(mod_dfm_ar1.start_params)\n    mod_dfm.summary()\n    assert_equal(str(mod_dfm), str(mod_dfm.summary()))\n    res_dfm.summary()\n    mod_dfm_ar1.summary()\n    res_dfm_ar1.summary()",
            "def test_summary(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    res_dfm_ar1 = mod_dfm_ar1.smooth(mod_dfm_ar1.start_params)\n    mod_dfm.summary()\n    assert_equal(str(mod_dfm), str(mod_dfm.summary()))\n    res_dfm.summary()\n    mod_dfm_ar1.summary()\n    res_dfm_ar1.summary()",
            "def test_summary(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    res_dfm = mod_dfm.smooth(mod_dfm.start_params)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    res_dfm_ar1 = mod_dfm_ar1.smooth(mod_dfm_ar1.start_params)\n    mod_dfm.summary()\n    assert_equal(str(mod_dfm), str(mod_dfm.summary()))\n    res_dfm.summary()\n    mod_dfm_ar1.summary()\n    res_dfm_ar1.summary()"
        ]
    },
    {
        "func_name": "test_append_extend_apply",
        "original": "def test_append_extend_apply(reset_randomstate):\n    (endog, loadings, phi, sigma2, _, idio_var) = gen_dfm_data(k_endog=10, nobs=100)\n    endog1 = endog.iloc[:-10]\n    endog2 = endog.iloc[-10:]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog1, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = np.r_[loadings, phi, sigma2, idio_var]\n    res = mod.smooth(params)\n    msg = 'Cannot append data of a different dimension to a model.'\n    with pytest.raises(ValueError, match=msg):\n        res.append(endog2.iloc[:, :3])\n    with pytest.raises(ValueError, match=msg):\n        res.extend(endog2.iloc[:, :3])\n    mod.initialize_known([0.1], [[1.0]])\n    res2 = mod.smooth(params)\n    assert_allclose(res.filter_results.initial_state, 0)\n    assert_allclose(res.filter_results.initial_state_cov, 4 / 3.0)\n    assert_allclose(res2.filter_results.initial_state, 0.1)\n    assert_allclose(res2.filter_results.initial_state_cov, 1.0)\n    res3 = res2.append(endog2, copy_initialization=False)\n    assert_allclose(res3.filter_results.initial_state, 0)\n    assert_allclose(res3.filter_results.initial_state_cov, 4 / 3.0)\n    res4 = res2.append(endog2, copy_initialization=True)\n    assert_allclose(res4.filter_results.initial_state, 0.1)\n    assert_allclose(res4.filter_results.initial_state_cov, 1.0)\n    res5 = res2.apply(endog, copy_initialization=False)\n    assert_allclose(res5.filter_results.initial_state, 0)\n    assert_allclose(res5.filter_results.initial_state_cov, 4 / 3.0)\n    res6 = res2.apply(endog, copy_initialization=True)\n    assert_allclose(res6.filter_results.initial_state, 0.1)\n    assert_allclose(res6.filter_results.initial_state_cov, 1.0)",
        "mutated": [
            "def test_append_extend_apply(reset_randomstate):\n    if False:\n        i = 10\n    (endog, loadings, phi, sigma2, _, idio_var) = gen_dfm_data(k_endog=10, nobs=100)\n    endog1 = endog.iloc[:-10]\n    endog2 = endog.iloc[-10:]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog1, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = np.r_[loadings, phi, sigma2, idio_var]\n    res = mod.smooth(params)\n    msg = 'Cannot append data of a different dimension to a model.'\n    with pytest.raises(ValueError, match=msg):\n        res.append(endog2.iloc[:, :3])\n    with pytest.raises(ValueError, match=msg):\n        res.extend(endog2.iloc[:, :3])\n    mod.initialize_known([0.1], [[1.0]])\n    res2 = mod.smooth(params)\n    assert_allclose(res.filter_results.initial_state, 0)\n    assert_allclose(res.filter_results.initial_state_cov, 4 / 3.0)\n    assert_allclose(res2.filter_results.initial_state, 0.1)\n    assert_allclose(res2.filter_results.initial_state_cov, 1.0)\n    res3 = res2.append(endog2, copy_initialization=False)\n    assert_allclose(res3.filter_results.initial_state, 0)\n    assert_allclose(res3.filter_results.initial_state_cov, 4 / 3.0)\n    res4 = res2.append(endog2, copy_initialization=True)\n    assert_allclose(res4.filter_results.initial_state, 0.1)\n    assert_allclose(res4.filter_results.initial_state_cov, 1.0)\n    res5 = res2.apply(endog, copy_initialization=False)\n    assert_allclose(res5.filter_results.initial_state, 0)\n    assert_allclose(res5.filter_results.initial_state_cov, 4 / 3.0)\n    res6 = res2.apply(endog, copy_initialization=True)\n    assert_allclose(res6.filter_results.initial_state, 0.1)\n    assert_allclose(res6.filter_results.initial_state_cov, 1.0)",
            "def test_append_extend_apply(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog, loadings, phi, sigma2, _, idio_var) = gen_dfm_data(k_endog=10, nobs=100)\n    endog1 = endog.iloc[:-10]\n    endog2 = endog.iloc[-10:]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog1, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = np.r_[loadings, phi, sigma2, idio_var]\n    res = mod.smooth(params)\n    msg = 'Cannot append data of a different dimension to a model.'\n    with pytest.raises(ValueError, match=msg):\n        res.append(endog2.iloc[:, :3])\n    with pytest.raises(ValueError, match=msg):\n        res.extend(endog2.iloc[:, :3])\n    mod.initialize_known([0.1], [[1.0]])\n    res2 = mod.smooth(params)\n    assert_allclose(res.filter_results.initial_state, 0)\n    assert_allclose(res.filter_results.initial_state_cov, 4 / 3.0)\n    assert_allclose(res2.filter_results.initial_state, 0.1)\n    assert_allclose(res2.filter_results.initial_state_cov, 1.0)\n    res3 = res2.append(endog2, copy_initialization=False)\n    assert_allclose(res3.filter_results.initial_state, 0)\n    assert_allclose(res3.filter_results.initial_state_cov, 4 / 3.0)\n    res4 = res2.append(endog2, copy_initialization=True)\n    assert_allclose(res4.filter_results.initial_state, 0.1)\n    assert_allclose(res4.filter_results.initial_state_cov, 1.0)\n    res5 = res2.apply(endog, copy_initialization=False)\n    assert_allclose(res5.filter_results.initial_state, 0)\n    assert_allclose(res5.filter_results.initial_state_cov, 4 / 3.0)\n    res6 = res2.apply(endog, copy_initialization=True)\n    assert_allclose(res6.filter_results.initial_state, 0.1)\n    assert_allclose(res6.filter_results.initial_state_cov, 1.0)",
            "def test_append_extend_apply(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog, loadings, phi, sigma2, _, idio_var) = gen_dfm_data(k_endog=10, nobs=100)\n    endog1 = endog.iloc[:-10]\n    endog2 = endog.iloc[-10:]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog1, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = np.r_[loadings, phi, sigma2, idio_var]\n    res = mod.smooth(params)\n    msg = 'Cannot append data of a different dimension to a model.'\n    with pytest.raises(ValueError, match=msg):\n        res.append(endog2.iloc[:, :3])\n    with pytest.raises(ValueError, match=msg):\n        res.extend(endog2.iloc[:, :3])\n    mod.initialize_known([0.1], [[1.0]])\n    res2 = mod.smooth(params)\n    assert_allclose(res.filter_results.initial_state, 0)\n    assert_allclose(res.filter_results.initial_state_cov, 4 / 3.0)\n    assert_allclose(res2.filter_results.initial_state, 0.1)\n    assert_allclose(res2.filter_results.initial_state_cov, 1.0)\n    res3 = res2.append(endog2, copy_initialization=False)\n    assert_allclose(res3.filter_results.initial_state, 0)\n    assert_allclose(res3.filter_results.initial_state_cov, 4 / 3.0)\n    res4 = res2.append(endog2, copy_initialization=True)\n    assert_allclose(res4.filter_results.initial_state, 0.1)\n    assert_allclose(res4.filter_results.initial_state_cov, 1.0)\n    res5 = res2.apply(endog, copy_initialization=False)\n    assert_allclose(res5.filter_results.initial_state, 0)\n    assert_allclose(res5.filter_results.initial_state_cov, 4 / 3.0)\n    res6 = res2.apply(endog, copy_initialization=True)\n    assert_allclose(res6.filter_results.initial_state, 0.1)\n    assert_allclose(res6.filter_results.initial_state_cov, 1.0)",
            "def test_append_extend_apply(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog, loadings, phi, sigma2, _, idio_var) = gen_dfm_data(k_endog=10, nobs=100)\n    endog1 = endog.iloc[:-10]\n    endog2 = endog.iloc[-10:]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog1, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = np.r_[loadings, phi, sigma2, idio_var]\n    res = mod.smooth(params)\n    msg = 'Cannot append data of a different dimension to a model.'\n    with pytest.raises(ValueError, match=msg):\n        res.append(endog2.iloc[:, :3])\n    with pytest.raises(ValueError, match=msg):\n        res.extend(endog2.iloc[:, :3])\n    mod.initialize_known([0.1], [[1.0]])\n    res2 = mod.smooth(params)\n    assert_allclose(res.filter_results.initial_state, 0)\n    assert_allclose(res.filter_results.initial_state_cov, 4 / 3.0)\n    assert_allclose(res2.filter_results.initial_state, 0.1)\n    assert_allclose(res2.filter_results.initial_state_cov, 1.0)\n    res3 = res2.append(endog2, copy_initialization=False)\n    assert_allclose(res3.filter_results.initial_state, 0)\n    assert_allclose(res3.filter_results.initial_state_cov, 4 / 3.0)\n    res4 = res2.append(endog2, copy_initialization=True)\n    assert_allclose(res4.filter_results.initial_state, 0.1)\n    assert_allclose(res4.filter_results.initial_state_cov, 1.0)\n    res5 = res2.apply(endog, copy_initialization=False)\n    assert_allclose(res5.filter_results.initial_state, 0)\n    assert_allclose(res5.filter_results.initial_state_cov, 4 / 3.0)\n    res6 = res2.apply(endog, copy_initialization=True)\n    assert_allclose(res6.filter_results.initial_state, 0.1)\n    assert_allclose(res6.filter_results.initial_state_cov, 1.0)",
            "def test_append_extend_apply(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog, loadings, phi, sigma2, _, idio_var) = gen_dfm_data(k_endog=10, nobs=100)\n    endog1 = endog.iloc[:-10]\n    endog2 = endog.iloc[-10:]\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog1, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = np.r_[loadings, phi, sigma2, idio_var]\n    res = mod.smooth(params)\n    msg = 'Cannot append data of a different dimension to a model.'\n    with pytest.raises(ValueError, match=msg):\n        res.append(endog2.iloc[:, :3])\n    with pytest.raises(ValueError, match=msg):\n        res.extend(endog2.iloc[:, :3])\n    mod.initialize_known([0.1], [[1.0]])\n    res2 = mod.smooth(params)\n    assert_allclose(res.filter_results.initial_state, 0)\n    assert_allclose(res.filter_results.initial_state_cov, 4 / 3.0)\n    assert_allclose(res2.filter_results.initial_state, 0.1)\n    assert_allclose(res2.filter_results.initial_state_cov, 1.0)\n    res3 = res2.append(endog2, copy_initialization=False)\n    assert_allclose(res3.filter_results.initial_state, 0)\n    assert_allclose(res3.filter_results.initial_state_cov, 4 / 3.0)\n    res4 = res2.append(endog2, copy_initialization=True)\n    assert_allclose(res4.filter_results.initial_state, 0.1)\n    assert_allclose(res4.filter_results.initial_state_cov, 1.0)\n    res5 = res2.apply(endog, copy_initialization=False)\n    assert_allclose(res5.filter_results.initial_state, 0)\n    assert_allclose(res5.filter_results.initial_state_cov, 4 / 3.0)\n    res6 = res2.apply(endog, copy_initialization=True)\n    assert_allclose(res6.filter_results.initial_state, 0.1)\n    assert_allclose(res6.filter_results.initial_state_cov, 1.0)"
        ]
    },
    {
        "func_name": "test_news_monthly",
        "original": "def test_news_monthly(reset_randomstate):\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    endog_pre = endog.iloc[:-1].copy()\n    endog_pre.iloc[-1, 0] *= 1.2\n    endog_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog, start=endog.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
        "mutated": [
            "def test_news_monthly(reset_randomstate):\n    if False:\n        i = 10\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    endog_pre = endog.iloc[:-1].copy()\n    endog_pre.iloc[-1, 0] *= 1.2\n    endog_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog, start=endog.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "def test_news_monthly(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    endog_pre = endog.iloc[:-1].copy()\n    endog_pre.iloc[-1, 0] *= 1.2\n    endog_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog, start=endog.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "def test_news_monthly(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    endog_pre = endog.iloc[:-1].copy()\n    endog_pre.iloc[-1, 0] *= 1.2\n    endog_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog, start=endog.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "def test_news_monthly(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    endog_pre = endog.iloc[:-1].copy()\n    endog_pre.iloc[-1, 0] *= 1.2\n    endog_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog, start=endog.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "def test_news_monthly(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog, _, _, _, _, _) = gen_dfm_data(k_endog=10, nobs=100)\n    endog_pre = endog.iloc[:-1].copy()\n    endog_pre.iloc[-1, 0] *= 1.2\n    endog_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog, start=endog.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)"
        ]
    },
    {
        "func_name": "test_news_MQ",
        "original": "def test_news_MQ(reset_randomstate):\n    (endog_M, endog_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(100, k=2, idiosyncratic_ar1=False)\n    endog_M_pre = endog_M.iloc[:-1].copy()\n    endog_M_pre.iloc[-1, 0] *= 1.2\n    endog_M_pre.iloc[-1, 1] = np.nan\n    endog_Q_pre = endog_Q.iloc[:-1].copy()\n    endog_Q_pre.iloc[-1, 0] *= 1.2\n    endog_Q_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_pre, endog_quarterly=endog_Q_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog_M, endog_quarterly=endog_Q)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog_M.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog_M, endog_quarterly=endog_Q, start=endog_M.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
        "mutated": [
            "def test_news_MQ(reset_randomstate):\n    if False:\n        i = 10\n    (endog_M, endog_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(100, k=2, idiosyncratic_ar1=False)\n    endog_M_pre = endog_M.iloc[:-1].copy()\n    endog_M_pre.iloc[-1, 0] *= 1.2\n    endog_M_pre.iloc[-1, 1] = np.nan\n    endog_Q_pre = endog_Q.iloc[:-1].copy()\n    endog_Q_pre.iloc[-1, 0] *= 1.2\n    endog_Q_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_pre, endog_quarterly=endog_Q_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog_M, endog_quarterly=endog_Q)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog_M.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog_M, endog_quarterly=endog_Q, start=endog_M.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "def test_news_MQ(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog_M, endog_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(100, k=2, idiosyncratic_ar1=False)\n    endog_M_pre = endog_M.iloc[:-1].copy()\n    endog_M_pre.iloc[-1, 0] *= 1.2\n    endog_M_pre.iloc[-1, 1] = np.nan\n    endog_Q_pre = endog_Q.iloc[:-1].copy()\n    endog_Q_pre.iloc[-1, 0] *= 1.2\n    endog_Q_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_pre, endog_quarterly=endog_Q_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog_M, endog_quarterly=endog_Q)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog_M.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog_M, endog_quarterly=endog_Q, start=endog_M.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "def test_news_MQ(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog_M, endog_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(100, k=2, idiosyncratic_ar1=False)\n    endog_M_pre = endog_M.iloc[:-1].copy()\n    endog_M_pre.iloc[-1, 0] *= 1.2\n    endog_M_pre.iloc[-1, 1] = np.nan\n    endog_Q_pre = endog_Q.iloc[:-1].copy()\n    endog_Q_pre.iloc[-1, 0] *= 1.2\n    endog_Q_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_pre, endog_quarterly=endog_Q_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog_M, endog_quarterly=endog_Q)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog_M.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog_M, endog_quarterly=endog_Q, start=endog_M.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "def test_news_MQ(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog_M, endog_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(100, k=2, idiosyncratic_ar1=False)\n    endog_M_pre = endog_M.iloc[:-1].copy()\n    endog_M_pre.iloc[-1, 0] *= 1.2\n    endog_M_pre.iloc[-1, 1] = np.nan\n    endog_Q_pre = endog_Q.iloc[:-1].copy()\n    endog_Q_pre.iloc[-1, 0] *= 1.2\n    endog_Q_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_pre, endog_quarterly=endog_Q_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog_M, endog_quarterly=endog_Q)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog_M.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog_M, endog_quarterly=endog_Q, start=endog_M.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "def test_news_MQ(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog_M, endog_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(100, k=2, idiosyncratic_ar1=False)\n    endog_M_pre = endog_M.iloc[:-1].copy()\n    endog_M_pre.iloc[-1, 0] *= 1.2\n    endog_M_pre.iloc[-1, 1] = np.nan\n    endog_Q_pre = endog_Q.iloc[:-1].copy()\n    endog_Q_pre.iloc[-1, 0] *= 1.2\n    endog_Q_pre.iloc[-1, 1] = np.nan\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_pre, endog_quarterly=endog_Q_pre, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    params = mod.start_params\n    res = mod.smooth(params)\n    mod2 = mod.clone(endog_M, endog_quarterly=endog_Q)\n    res2 = mod2.smooth(params)\n    desired = res2.news(res, start=endog_M.index[-1], periods=1, comparison_type='previous')\n    actual = res.news(endog_M, endog_quarterly=endog_Q, start=endog_M.index[-1], periods=1, comparison_type='updated')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(actual, attr)\n        x = getattr(desired, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)"
        ]
    },
    {
        "func_name": "test_ar6_no_quarterly",
        "original": "def test_ar6_no_quarterly(reset_randomstate):\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(6, 0, 0))\n    params = np.r_[0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 1.0]\n    endog = mod.simulate(params, 100)\n    mod_ar = sarimax.SARIMAX(endog, order=(6, 0, 0))\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=6, standardize=False, idiosyncratic_ar1=False)\n    llf_ar = mod_ar.loglike(params)\n    llf_dfm = mod_dfm.loglike(np.r_[1, params, 0.0])\n    assert_allclose(llf_dfm, llf_ar)\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual = res_dfm.params\n        actual[-2] *= actual[0]\n        actual[0] = 1\n        assert_allclose(res_dfm.params[1:-1], params, atol=0.01)",
        "mutated": [
            "def test_ar6_no_quarterly(reset_randomstate):\n    if False:\n        i = 10\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(6, 0, 0))\n    params = np.r_[0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 1.0]\n    endog = mod.simulate(params, 100)\n    mod_ar = sarimax.SARIMAX(endog, order=(6, 0, 0))\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=6, standardize=False, idiosyncratic_ar1=False)\n    llf_ar = mod_ar.loglike(params)\n    llf_dfm = mod_dfm.loglike(np.r_[1, params, 0.0])\n    assert_allclose(llf_dfm, llf_ar)\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual = res_dfm.params\n        actual[-2] *= actual[0]\n        actual[0] = 1\n        assert_allclose(res_dfm.params[1:-1], params, atol=0.01)",
            "def test_ar6_no_quarterly(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(6, 0, 0))\n    params = np.r_[0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 1.0]\n    endog = mod.simulate(params, 100)\n    mod_ar = sarimax.SARIMAX(endog, order=(6, 0, 0))\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=6, standardize=False, idiosyncratic_ar1=False)\n    llf_ar = mod_ar.loglike(params)\n    llf_dfm = mod_dfm.loglike(np.r_[1, params, 0.0])\n    assert_allclose(llf_dfm, llf_ar)\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual = res_dfm.params\n        actual[-2] *= actual[0]\n        actual[0] = 1\n        assert_allclose(res_dfm.params[1:-1], params, atol=0.01)",
            "def test_ar6_no_quarterly(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(6, 0, 0))\n    params = np.r_[0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 1.0]\n    endog = mod.simulate(params, 100)\n    mod_ar = sarimax.SARIMAX(endog, order=(6, 0, 0))\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=6, standardize=False, idiosyncratic_ar1=False)\n    llf_ar = mod_ar.loglike(params)\n    llf_dfm = mod_dfm.loglike(np.r_[1, params, 0.0])\n    assert_allclose(llf_dfm, llf_ar)\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual = res_dfm.params\n        actual[-2] *= actual[0]\n        actual[0] = 1\n        assert_allclose(res_dfm.params[1:-1], params, atol=0.01)",
            "def test_ar6_no_quarterly(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(6, 0, 0))\n    params = np.r_[0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 1.0]\n    endog = mod.simulate(params, 100)\n    mod_ar = sarimax.SARIMAX(endog, order=(6, 0, 0))\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=6, standardize=False, idiosyncratic_ar1=False)\n    llf_ar = mod_ar.loglike(params)\n    llf_dfm = mod_dfm.loglike(np.r_[1, params, 0.0])\n    assert_allclose(llf_dfm, llf_ar)\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual = res_dfm.params\n        actual[-2] *= actual[0]\n        actual[0] = 1\n        assert_allclose(res_dfm.params[1:-1], params, atol=0.01)",
            "def test_ar6_no_quarterly(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(6, 0, 0))\n    params = np.r_[0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 1.0]\n    endog = mod.simulate(params, 100)\n    mod_ar = sarimax.SARIMAX(endog, order=(6, 0, 0))\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=6, standardize=False, idiosyncratic_ar1=False)\n    llf_ar = mod_ar.loglike(params)\n    llf_dfm = mod_dfm.loglike(np.r_[1, params, 0.0])\n    assert_allclose(llf_dfm, llf_ar)\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual = res_dfm.params\n        actual[-2] *= actual[0]\n        actual[0] = 1\n        assert_allclose(res_dfm.params[1:-1], params, atol=0.01)"
        ]
    },
    {
        "func_name": "test_idiosyncratic_ar1_False",
        "original": "def test_idiosyncratic_ar1_False(reset_randomstate):\n    (endog, loadings, phi, sigma2, idio_ar1, idio_var) = gen_dfm_data(k_endog=10, nobs=1000)\n    mod_base = dynamic_factor.DynamicFactor(endog, k_factors=1, factor_order=1)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    params = np.r_[loadings, idio_var, phi]\n    params_dfm = np.r_[loadings, phi, sigma2, idio_var]\n    params_dfm_ar1 = np.r_[loadings, phi, sigma2, idio_ar1, idio_var]\n    llf_base = mod_base.loglike(params)\n    llf_dfm = mod_dfm.loglike(params_dfm)\n    llf_dfm_ar1 = mod_dfm_ar1.loglike(params_dfm_ar1)\n    assert_allclose(llf_dfm_ar1, llf_dfm)\n    assert_allclose(llf_dfm, llf_base)\n    assert_allclose(llf_dfm_ar1, llf_base)\n    res0_dfm = mod_dfm.smooth(params_dfm)\n    res0_dfm_ar1 = mod_dfm_ar1.smooth(params_dfm_ar1)\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance, res0_dfm_ar1.smoothed_state[1:])\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance_cov, res0_dfm_ar1.smoothed_state_cov[1:, 1:, :])\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual_dfm = res_dfm.params.copy()\n        scalar = actual_dfm[0] / params_dfm[0]\n        actual_dfm[11] *= scalar\n        actual_dfm[:10] /= scalar\n        assert_allclose(actual_dfm, params_dfm, atol=0.1)\n        res_dfm_ar1 = mod_dfm_ar1.fit()\n        actual_dfm_ar1 = res_dfm_ar1.params.copy()\n        scalar = actual_dfm_ar1[0] / params_dfm[0]\n        actual_dfm_ar1[11] *= scalar\n        actual_dfm_ar1[:10] /= scalar\n        assert_allclose(actual_dfm_ar1, params_dfm_ar1, atol=0.1)\n        desired = np.r_[actual_dfm_ar1[:12], actual_dfm_ar1[-10:]]\n        assert_allclose(actual_dfm, desired, atol=0.1)",
        "mutated": [
            "def test_idiosyncratic_ar1_False(reset_randomstate):\n    if False:\n        i = 10\n    (endog, loadings, phi, sigma2, idio_ar1, idio_var) = gen_dfm_data(k_endog=10, nobs=1000)\n    mod_base = dynamic_factor.DynamicFactor(endog, k_factors=1, factor_order=1)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    params = np.r_[loadings, idio_var, phi]\n    params_dfm = np.r_[loadings, phi, sigma2, idio_var]\n    params_dfm_ar1 = np.r_[loadings, phi, sigma2, idio_ar1, idio_var]\n    llf_base = mod_base.loglike(params)\n    llf_dfm = mod_dfm.loglike(params_dfm)\n    llf_dfm_ar1 = mod_dfm_ar1.loglike(params_dfm_ar1)\n    assert_allclose(llf_dfm_ar1, llf_dfm)\n    assert_allclose(llf_dfm, llf_base)\n    assert_allclose(llf_dfm_ar1, llf_base)\n    res0_dfm = mod_dfm.smooth(params_dfm)\n    res0_dfm_ar1 = mod_dfm_ar1.smooth(params_dfm_ar1)\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance, res0_dfm_ar1.smoothed_state[1:])\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance_cov, res0_dfm_ar1.smoothed_state_cov[1:, 1:, :])\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual_dfm = res_dfm.params.copy()\n        scalar = actual_dfm[0] / params_dfm[0]\n        actual_dfm[11] *= scalar\n        actual_dfm[:10] /= scalar\n        assert_allclose(actual_dfm, params_dfm, atol=0.1)\n        res_dfm_ar1 = mod_dfm_ar1.fit()\n        actual_dfm_ar1 = res_dfm_ar1.params.copy()\n        scalar = actual_dfm_ar1[0] / params_dfm[0]\n        actual_dfm_ar1[11] *= scalar\n        actual_dfm_ar1[:10] /= scalar\n        assert_allclose(actual_dfm_ar1, params_dfm_ar1, atol=0.1)\n        desired = np.r_[actual_dfm_ar1[:12], actual_dfm_ar1[-10:]]\n        assert_allclose(actual_dfm, desired, atol=0.1)",
            "def test_idiosyncratic_ar1_False(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog, loadings, phi, sigma2, idio_ar1, idio_var) = gen_dfm_data(k_endog=10, nobs=1000)\n    mod_base = dynamic_factor.DynamicFactor(endog, k_factors=1, factor_order=1)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    params = np.r_[loadings, idio_var, phi]\n    params_dfm = np.r_[loadings, phi, sigma2, idio_var]\n    params_dfm_ar1 = np.r_[loadings, phi, sigma2, idio_ar1, idio_var]\n    llf_base = mod_base.loglike(params)\n    llf_dfm = mod_dfm.loglike(params_dfm)\n    llf_dfm_ar1 = mod_dfm_ar1.loglike(params_dfm_ar1)\n    assert_allclose(llf_dfm_ar1, llf_dfm)\n    assert_allclose(llf_dfm, llf_base)\n    assert_allclose(llf_dfm_ar1, llf_base)\n    res0_dfm = mod_dfm.smooth(params_dfm)\n    res0_dfm_ar1 = mod_dfm_ar1.smooth(params_dfm_ar1)\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance, res0_dfm_ar1.smoothed_state[1:])\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance_cov, res0_dfm_ar1.smoothed_state_cov[1:, 1:, :])\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual_dfm = res_dfm.params.copy()\n        scalar = actual_dfm[0] / params_dfm[0]\n        actual_dfm[11] *= scalar\n        actual_dfm[:10] /= scalar\n        assert_allclose(actual_dfm, params_dfm, atol=0.1)\n        res_dfm_ar1 = mod_dfm_ar1.fit()\n        actual_dfm_ar1 = res_dfm_ar1.params.copy()\n        scalar = actual_dfm_ar1[0] / params_dfm[0]\n        actual_dfm_ar1[11] *= scalar\n        actual_dfm_ar1[:10] /= scalar\n        assert_allclose(actual_dfm_ar1, params_dfm_ar1, atol=0.1)\n        desired = np.r_[actual_dfm_ar1[:12], actual_dfm_ar1[-10:]]\n        assert_allclose(actual_dfm, desired, atol=0.1)",
            "def test_idiosyncratic_ar1_False(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog, loadings, phi, sigma2, idio_ar1, idio_var) = gen_dfm_data(k_endog=10, nobs=1000)\n    mod_base = dynamic_factor.DynamicFactor(endog, k_factors=1, factor_order=1)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    params = np.r_[loadings, idio_var, phi]\n    params_dfm = np.r_[loadings, phi, sigma2, idio_var]\n    params_dfm_ar1 = np.r_[loadings, phi, sigma2, idio_ar1, idio_var]\n    llf_base = mod_base.loglike(params)\n    llf_dfm = mod_dfm.loglike(params_dfm)\n    llf_dfm_ar1 = mod_dfm_ar1.loglike(params_dfm_ar1)\n    assert_allclose(llf_dfm_ar1, llf_dfm)\n    assert_allclose(llf_dfm, llf_base)\n    assert_allclose(llf_dfm_ar1, llf_base)\n    res0_dfm = mod_dfm.smooth(params_dfm)\n    res0_dfm_ar1 = mod_dfm_ar1.smooth(params_dfm_ar1)\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance, res0_dfm_ar1.smoothed_state[1:])\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance_cov, res0_dfm_ar1.smoothed_state_cov[1:, 1:, :])\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual_dfm = res_dfm.params.copy()\n        scalar = actual_dfm[0] / params_dfm[0]\n        actual_dfm[11] *= scalar\n        actual_dfm[:10] /= scalar\n        assert_allclose(actual_dfm, params_dfm, atol=0.1)\n        res_dfm_ar1 = mod_dfm_ar1.fit()\n        actual_dfm_ar1 = res_dfm_ar1.params.copy()\n        scalar = actual_dfm_ar1[0] / params_dfm[0]\n        actual_dfm_ar1[11] *= scalar\n        actual_dfm_ar1[:10] /= scalar\n        assert_allclose(actual_dfm_ar1, params_dfm_ar1, atol=0.1)\n        desired = np.r_[actual_dfm_ar1[:12], actual_dfm_ar1[-10:]]\n        assert_allclose(actual_dfm, desired, atol=0.1)",
            "def test_idiosyncratic_ar1_False(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog, loadings, phi, sigma2, idio_ar1, idio_var) = gen_dfm_data(k_endog=10, nobs=1000)\n    mod_base = dynamic_factor.DynamicFactor(endog, k_factors=1, factor_order=1)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    params = np.r_[loadings, idio_var, phi]\n    params_dfm = np.r_[loadings, phi, sigma2, idio_var]\n    params_dfm_ar1 = np.r_[loadings, phi, sigma2, idio_ar1, idio_var]\n    llf_base = mod_base.loglike(params)\n    llf_dfm = mod_dfm.loglike(params_dfm)\n    llf_dfm_ar1 = mod_dfm_ar1.loglike(params_dfm_ar1)\n    assert_allclose(llf_dfm_ar1, llf_dfm)\n    assert_allclose(llf_dfm, llf_base)\n    assert_allclose(llf_dfm_ar1, llf_base)\n    res0_dfm = mod_dfm.smooth(params_dfm)\n    res0_dfm_ar1 = mod_dfm_ar1.smooth(params_dfm_ar1)\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance, res0_dfm_ar1.smoothed_state[1:])\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance_cov, res0_dfm_ar1.smoothed_state_cov[1:, 1:, :])\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual_dfm = res_dfm.params.copy()\n        scalar = actual_dfm[0] / params_dfm[0]\n        actual_dfm[11] *= scalar\n        actual_dfm[:10] /= scalar\n        assert_allclose(actual_dfm, params_dfm, atol=0.1)\n        res_dfm_ar1 = mod_dfm_ar1.fit()\n        actual_dfm_ar1 = res_dfm_ar1.params.copy()\n        scalar = actual_dfm_ar1[0] / params_dfm[0]\n        actual_dfm_ar1[11] *= scalar\n        actual_dfm_ar1[:10] /= scalar\n        assert_allclose(actual_dfm_ar1, params_dfm_ar1, atol=0.1)\n        desired = np.r_[actual_dfm_ar1[:12], actual_dfm_ar1[-10:]]\n        assert_allclose(actual_dfm, desired, atol=0.1)",
            "def test_idiosyncratic_ar1_False(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog, loadings, phi, sigma2, idio_ar1, idio_var) = gen_dfm_data(k_endog=10, nobs=1000)\n    mod_base = dynamic_factor.DynamicFactor(endog, k_factors=1, factor_order=1)\n    mod_dfm = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=False)\n    mod_dfm_ar1 = dynamic_factor_mq.DynamicFactorMQ(endog, factor_orders=1, standardize=False, idiosyncratic_ar1=True)\n    params = np.r_[loadings, idio_var, phi]\n    params_dfm = np.r_[loadings, phi, sigma2, idio_var]\n    params_dfm_ar1 = np.r_[loadings, phi, sigma2, idio_ar1, idio_var]\n    llf_base = mod_base.loglike(params)\n    llf_dfm = mod_dfm.loglike(params_dfm)\n    llf_dfm_ar1 = mod_dfm_ar1.loglike(params_dfm_ar1)\n    assert_allclose(llf_dfm_ar1, llf_dfm)\n    assert_allclose(llf_dfm, llf_base)\n    assert_allclose(llf_dfm_ar1, llf_base)\n    res0_dfm = mod_dfm.smooth(params_dfm)\n    res0_dfm_ar1 = mod_dfm_ar1.smooth(params_dfm_ar1)\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance, res0_dfm_ar1.smoothed_state[1:])\n    assert_allclose(res0_dfm.smoothed_measurement_disturbance_cov, res0_dfm_ar1.smoothed_state_cov[1:, 1:, :])\n    if not SKIP_MONTE_CARLO_TESTS:\n        res_dfm = mod_dfm.fit()\n        actual_dfm = res_dfm.params.copy()\n        scalar = actual_dfm[0] / params_dfm[0]\n        actual_dfm[11] *= scalar\n        actual_dfm[:10] /= scalar\n        assert_allclose(actual_dfm, params_dfm, atol=0.1)\n        res_dfm_ar1 = mod_dfm_ar1.fit()\n        actual_dfm_ar1 = res_dfm_ar1.params.copy()\n        scalar = actual_dfm_ar1[0] / params_dfm[0]\n        actual_dfm_ar1[11] *= scalar\n        actual_dfm_ar1[:10] /= scalar\n        assert_allclose(actual_dfm_ar1, params_dfm_ar1, atol=0.1)\n        desired = np.r_[actual_dfm_ar1[:12], actual_dfm_ar1[-10:]]\n        assert_allclose(actual_dfm, desired, atol=0.1)"
        ]
    },
    {
        "func_name": "test_invalid_standardize_1d",
        "original": "def test_invalid_standardize_1d():\n    endog = np.zeros(100) + 10\n    endog_pd = pd.Series(endog, name='y1')\n    options = [([], 10), (10, []), ([], []), ([1, 2], [1.0]), ([1], [1, 2.0])]\n    msg = 'Invalid value passed for `standardize`: each element must be shaped'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y1']), pd.Series(10, index=['y1'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y']), pd.Series(10, index=['y'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog_pd, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)",
        "mutated": [
            "def test_invalid_standardize_1d():\n    if False:\n        i = 10\n    endog = np.zeros(100) + 10\n    endog_pd = pd.Series(endog, name='y1')\n    options = [([], 10), (10, []), ([], []), ([1, 2], [1.0]), ([1], [1, 2.0])]\n    msg = 'Invalid value passed for `standardize`: each element must be shaped'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y1']), pd.Series(10, index=['y1'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y']), pd.Series(10, index=['y'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog_pd, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)",
            "def test_invalid_standardize_1d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.zeros(100) + 10\n    endog_pd = pd.Series(endog, name='y1')\n    options = [([], 10), (10, []), ([], []), ([1, 2], [1.0]), ([1], [1, 2.0])]\n    msg = 'Invalid value passed for `standardize`: each element must be shaped'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y1']), pd.Series(10, index=['y1'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y']), pd.Series(10, index=['y'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog_pd, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)",
            "def test_invalid_standardize_1d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.zeros(100) + 10\n    endog_pd = pd.Series(endog, name='y1')\n    options = [([], 10), (10, []), ([], []), ([1, 2], [1.0]), ([1], [1, 2.0])]\n    msg = 'Invalid value passed for `standardize`: each element must be shaped'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y1']), pd.Series(10, index=['y1'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y']), pd.Series(10, index=['y'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog_pd, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)",
            "def test_invalid_standardize_1d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.zeros(100) + 10\n    endog_pd = pd.Series(endog, name='y1')\n    options = [([], 10), (10, []), ([], []), ([1, 2], [1.0]), ([1], [1, 2.0])]\n    msg = 'Invalid value passed for `standardize`: each element must be shaped'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y1']), pd.Series(10, index=['y1'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y']), pd.Series(10, index=['y'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog_pd, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)",
            "def test_invalid_standardize_1d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.zeros(100) + 10\n    endog_pd = pd.Series(endog, name='y1')\n    options = [([], 10), (10, []), ([], []), ([1, 2], [1.0]), ([1], [1, 2.0])]\n    msg = 'Invalid value passed for `standardize`: each element must be shaped'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y1']), pd.Series(10, index=['y1'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    options = [(pd.Series(10), pd.Series(10)), (pd.Series(10, index=['y']), pd.Series(10, index=['y1'])), (pd.Series(10, index=['y']), pd.Series(10, index=['y'])), (pd.Series([10], index=['y']), pd.Series([10, 1], index=['y1', 'y2']))]\n    msg = 'Invalid value passed for `standardize`: if a Pandas Series, must have index'\n    for standardize in options:\n        with pytest.raises(ValueError, match=msg):\n            dynamic_factor_mq.DynamicFactorMQ(endog_pd, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)"
        ]
    },
    {
        "func_name": "test_simulate_standardized_1d",
        "original": "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [(10, 10), ([10], [10]), (np.array(10), np.array(10)), (pd.Series([10], index=['y']), pd.Series([10], index=['y']))])\ndef test_simulate_standardized_1d(standardize, use_pandas):\n    endog = np.zeros(100) + 10\n    if use_pandas:\n        endog = pd.Series(endog, name='y')\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    phi = 0.5\n    params = [lambda1, phi, 0.0, 0]\n    res = mod.smooth(params)\n    mean = np.atleast_1d(standardize[0])[0]\n    std = np.atleast_1d(standardize[1])[0]\n    desired = phi ** np.arange(10) * lambda1 * std + mean\n    desired_nd = desired[:, None] if use_pandas else desired[:, None, None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10,))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 1) if use_pandas else (10, 1, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 2) if use_pandas else (10, 1, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
        "mutated": [
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [(10, 10), ([10], [10]), (np.array(10), np.array(10)), (pd.Series([10], index=['y']), pd.Series([10], index=['y']))])\ndef test_simulate_standardized_1d(standardize, use_pandas):\n    if False:\n        i = 10\n    endog = np.zeros(100) + 10\n    if use_pandas:\n        endog = pd.Series(endog, name='y')\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    phi = 0.5\n    params = [lambda1, phi, 0.0, 0]\n    res = mod.smooth(params)\n    mean = np.atleast_1d(standardize[0])[0]\n    std = np.atleast_1d(standardize[1])[0]\n    desired = phi ** np.arange(10) * lambda1 * std + mean\n    desired_nd = desired[:, None] if use_pandas else desired[:, None, None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10,))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 1) if use_pandas else (10, 1, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 2) if use_pandas else (10, 1, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [(10, 10), ([10], [10]), (np.array(10), np.array(10)), (pd.Series([10], index=['y']), pd.Series([10], index=['y']))])\ndef test_simulate_standardized_1d(standardize, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.zeros(100) + 10\n    if use_pandas:\n        endog = pd.Series(endog, name='y')\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    phi = 0.5\n    params = [lambda1, phi, 0.0, 0]\n    res = mod.smooth(params)\n    mean = np.atleast_1d(standardize[0])[0]\n    std = np.atleast_1d(standardize[1])[0]\n    desired = phi ** np.arange(10) * lambda1 * std + mean\n    desired_nd = desired[:, None] if use_pandas else desired[:, None, None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10,))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 1) if use_pandas else (10, 1, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 2) if use_pandas else (10, 1, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [(10, 10), ([10], [10]), (np.array(10), np.array(10)), (pd.Series([10], index=['y']), pd.Series([10], index=['y']))])\ndef test_simulate_standardized_1d(standardize, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.zeros(100) + 10\n    if use_pandas:\n        endog = pd.Series(endog, name='y')\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    phi = 0.5\n    params = [lambda1, phi, 0.0, 0]\n    res = mod.smooth(params)\n    mean = np.atleast_1d(standardize[0])[0]\n    std = np.atleast_1d(standardize[1])[0]\n    desired = phi ** np.arange(10) * lambda1 * std + mean\n    desired_nd = desired[:, None] if use_pandas else desired[:, None, None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10,))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 1) if use_pandas else (10, 1, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 2) if use_pandas else (10, 1, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [(10, 10), ([10], [10]), (np.array(10), np.array(10)), (pd.Series([10], index=['y']), pd.Series([10], index=['y']))])\ndef test_simulate_standardized_1d(standardize, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.zeros(100) + 10\n    if use_pandas:\n        endog = pd.Series(endog, name='y')\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    phi = 0.5\n    params = [lambda1, phi, 0.0, 0]\n    res = mod.smooth(params)\n    mean = np.atleast_1d(standardize[0])[0]\n    std = np.atleast_1d(standardize[1])[0]\n    desired = phi ** np.arange(10) * lambda1 * std + mean\n    desired_nd = desired[:, None] if use_pandas else desired[:, None, None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10,))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 1) if use_pandas else (10, 1, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 2) if use_pandas else (10, 1, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [(10, 10), ([10], [10]), (np.array(10), np.array(10)), (pd.Series([10], index=['y']), pd.Series([10], index=['y']))])\ndef test_simulate_standardized_1d(standardize, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.zeros(100) + 10\n    if use_pandas:\n        endog = pd.Series(endog, name='y')\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    phi = 0.5\n    params = [lambda1, phi, 0.0, 0]\n    res = mod.smooth(params)\n    mean = np.atleast_1d(standardize[0])[0]\n    std = np.atleast_1d(standardize[1])[0]\n    desired = phi ** np.arange(10) * lambda1 * std + mean\n    desired_nd = desired[:, None] if use_pandas else desired[:, None, None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10,))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 1) if use_pandas else (10, 1, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 2) if use_pandas else (10, 1, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))"
        ]
    },
    {
        "func_name": "test_simulate_standardized_2d",
        "original": "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [([10, -4], [10.0, 10.0]), (np.array([10, -4]), np.array([10, 10])), (pd.Series([10, -4], index=['y1', 'y2']), pd.Series([10, 10], index=['y1', 'y2']))])\ndef test_simulate_standardized_2d(standardize, use_pandas):\n    endog = np.zeros((100, 2)) + [10, -4]\n    if use_pandas:\n        endog = pd.DataFrame(endog, columns=['y1', 'y2'])\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    lambda2 = 0.5\n    phi = 0.5\n    params = [lambda1, lambda2, phi, 0.0, 0, 0.0]\n    res = mod.smooth(params)\n    means = np.atleast_1d(standardize[0])\n    stds = np.atleast_1d(standardize[1])\n    desired = np.c_[phi ** np.arange(10) * lambda1 * stds[0] + means[0], phi ** np.arange(10) * lambda2 * stds[1] + means[1]]\n    desired_nd = desired if use_pandas else desired[..., None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10, 2))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 2) if use_pandas else (10, 2, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 4) if use_pandas else (10, 2, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
        "mutated": [
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [([10, -4], [10.0, 10.0]), (np.array([10, -4]), np.array([10, 10])), (pd.Series([10, -4], index=['y1', 'y2']), pd.Series([10, 10], index=['y1', 'y2']))])\ndef test_simulate_standardized_2d(standardize, use_pandas):\n    if False:\n        i = 10\n    endog = np.zeros((100, 2)) + [10, -4]\n    if use_pandas:\n        endog = pd.DataFrame(endog, columns=['y1', 'y2'])\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    lambda2 = 0.5\n    phi = 0.5\n    params = [lambda1, lambda2, phi, 0.0, 0, 0.0]\n    res = mod.smooth(params)\n    means = np.atleast_1d(standardize[0])\n    stds = np.atleast_1d(standardize[1])\n    desired = np.c_[phi ** np.arange(10) * lambda1 * stds[0] + means[0], phi ** np.arange(10) * lambda2 * stds[1] + means[1]]\n    desired_nd = desired if use_pandas else desired[..., None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10, 2))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 2) if use_pandas else (10, 2, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 4) if use_pandas else (10, 2, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [([10, -4], [10.0, 10.0]), (np.array([10, -4]), np.array([10, 10])), (pd.Series([10, -4], index=['y1', 'y2']), pd.Series([10, 10], index=['y1', 'y2']))])\ndef test_simulate_standardized_2d(standardize, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    endog = np.zeros((100, 2)) + [10, -4]\n    if use_pandas:\n        endog = pd.DataFrame(endog, columns=['y1', 'y2'])\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    lambda2 = 0.5\n    phi = 0.5\n    params = [lambda1, lambda2, phi, 0.0, 0, 0.0]\n    res = mod.smooth(params)\n    means = np.atleast_1d(standardize[0])\n    stds = np.atleast_1d(standardize[1])\n    desired = np.c_[phi ** np.arange(10) * lambda1 * stds[0] + means[0], phi ** np.arange(10) * lambda2 * stds[1] + means[1]]\n    desired_nd = desired if use_pandas else desired[..., None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10, 2))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 2) if use_pandas else (10, 2, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 4) if use_pandas else (10, 2, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [([10, -4], [10.0, 10.0]), (np.array([10, -4]), np.array([10, 10])), (pd.Series([10, -4], index=['y1', 'y2']), pd.Series([10, 10], index=['y1', 'y2']))])\ndef test_simulate_standardized_2d(standardize, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    endog = np.zeros((100, 2)) + [10, -4]\n    if use_pandas:\n        endog = pd.DataFrame(endog, columns=['y1', 'y2'])\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    lambda2 = 0.5\n    phi = 0.5\n    params = [lambda1, lambda2, phi, 0.0, 0, 0.0]\n    res = mod.smooth(params)\n    means = np.atleast_1d(standardize[0])\n    stds = np.atleast_1d(standardize[1])\n    desired = np.c_[phi ** np.arange(10) * lambda1 * stds[0] + means[0], phi ** np.arange(10) * lambda2 * stds[1] + means[1]]\n    desired_nd = desired if use_pandas else desired[..., None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10, 2))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 2) if use_pandas else (10, 2, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 4) if use_pandas else (10, 2, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [([10, -4], [10.0, 10.0]), (np.array([10, -4]), np.array([10, 10])), (pd.Series([10, -4], index=['y1', 'y2']), pd.Series([10, 10], index=['y1', 'y2']))])\ndef test_simulate_standardized_2d(standardize, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    endog = np.zeros((100, 2)) + [10, -4]\n    if use_pandas:\n        endog = pd.DataFrame(endog, columns=['y1', 'y2'])\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    lambda2 = 0.5\n    phi = 0.5\n    params = [lambda1, lambda2, phi, 0.0, 0, 0.0]\n    res = mod.smooth(params)\n    means = np.atleast_1d(standardize[0])\n    stds = np.atleast_1d(standardize[1])\n    desired = np.c_[phi ** np.arange(10) * lambda1 * stds[0] + means[0], phi ** np.arange(10) * lambda2 * stds[1] + means[1]]\n    desired_nd = desired if use_pandas else desired[..., None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10, 2))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 2) if use_pandas else (10, 2, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 4) if use_pandas else (10, 2, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('standardize', [([10, -4], [10.0, 10.0]), (np.array([10, -4]), np.array([10, 10])), (pd.Series([10, -4], index=['y1', 'y2']), pd.Series([10, 10], index=['y1', 'y2']))])\ndef test_simulate_standardized_2d(standardize, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    endog = np.zeros((100, 2)) + [10, -4]\n    if use_pandas:\n        endog = pd.DataFrame(endog, columns=['y1', 'y2'])\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_orders=1, idiosyncratic_ar1=False, standardize=standardize)\n    lambda1 = 2.0\n    lambda2 = 0.5\n    phi = 0.5\n    params = [lambda1, lambda2, phi, 0.0, 0, 0.0]\n    res = mod.smooth(params)\n    means = np.atleast_1d(standardize[0])\n    stds = np.atleast_1d(standardize[1])\n    desired = np.c_[phi ** np.arange(10) * lambda1 * stds[0] + means[0], phi ** np.arange(10) * lambda2 * stds[1] + means[1]]\n    desired_nd = desired if use_pandas else desired[..., None]\n    actual = res.simulate(10, initial_state=[1.0])\n    assert_equal(actual.shape, (10, 2))\n    assert_allclose(actual, desired)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=1)\n    desired_shape = (10, 2) if use_pandas else (10, 2, 1)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, desired_nd)\n    actual = res.simulate(10, initial_state=[1.0], repetitions=2)\n    desired_shape = (10, 4) if use_pandas else (10, 2, 2)\n    assert_equal(actual.shape, desired_shape)\n    assert_allclose(actual, np.repeat(desired_nd, 2, axis=-1))"
        ]
    },
    {
        "func_name": "check_standardized_results",
        "original": "def check_standardized_results(res1, res2, check_diagnostics=True):\n    mod1 = res1.model\n    mod2 = res2.model\n    tmp = (1 - res1.filter_results.missing.T) * np.array(mod1._endog_std)[None, :] ** 2\n    mask = res1.filter_results.missing.T.astype(bool)\n    tmp[mask] = 1.0\n    llf_obs_diff = -0.5 * np.log(tmp).sum(axis=1)\n    assert_allclose(res1.llf_obs + llf_obs_diff, res2.llf_obs)\n    assert_allclose(res1.mae, res2.mae)\n    assert_allclose(res1.mse, res2.mse)\n    assert_allclose(res1.sse, res2.sse)\n    std = np.array(mod1._endog_std)\n    mean = np.array(mod1._endog_mean)\n    if mod1.k_endog > 1:\n        std = std[None, :]\n        mean = mean[None, :]\n    if mod1.k_endog == 1:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs,))\n    else:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs, mod1.k_endog))\n    actual = np.array(res1.fittedvalues) * std + mean\n    assert_allclose(actual, res2.fittedvalues)\n    actual = np.array(res1.resid) * std\n    assert_allclose(actual, res2.resid)\n    if check_diagnostics:\n        actual = res1.test_normality(method='jarquebera')\n        desired = res2.test_normality(method='jarquebera')\n        assert_allclose(actual, desired)\n        actual = res1.test_heteroskedasticity(method='breakvar')\n        desired = res2.test_heteroskedasticity(method='breakvar')\n        assert_allclose(actual, desired)\n        lags = min(10, res1.nobs_effective // 5)\n        actual = res1.test_serial_correlation(method='ljungbox', lags=lags)\n        desired = res2.test_serial_correlation(method='ljungbox', lags=lags)\n        assert_allclose(actual, desired)\n    start = res1.nobs // 10\n    dynamic = res1.nobs // 10\n    end = res1.nobs + 10\n    predict_actual = res1.predict()\n    forecast_actual = res1.forecast(10)\n    predict_dynamic_forecast_actual = res1.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_actual = res1.get_prediction()\n    get_forecast_actual = res1.get_forecast(10)\n    get_predict_dynamic_forecast_actual = res1.get_prediction(start=start, end=end, dynamic=dynamic)\n    predict_desired = res2.predict()\n    forecast_desired = res2.forecast(10)\n    predict_dynamic_forecast_desired = res2.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_desired = res2.get_prediction()\n    get_forecast_desired = res2.get_forecast(10)\n    get_predict_dynamic_forecast_desired = res2.get_prediction(start=start, end=end, dynamic=dynamic)\n    assert_allclose(predict_actual, predict_desired)\n    assert_allclose(forecast_actual, forecast_desired)\n    assert_allclose(predict_dynamic_forecast_actual, predict_dynamic_forecast_desired)\n    for i in range(mod1.k_endog):\n        assert_allclose(get_predict_actual.summary_frame(endog=i), get_predict_desired.summary_frame(endog=i))\n        assert_allclose(get_forecast_actual.summary_frame(endog=i), get_forecast_desired.summary_frame(endog=i))\n        assert_allclose(get_predict_dynamic_forecast_actual.summary_frame(endog=i), get_predict_dynamic_forecast_desired.summary_frame(endog=i))\n    np.random.seed(1234)\n    nsimulations = 100\n    initial_state = np.random.multivariate_normal(res1.filter_results.initial_state, res1.filter_results.initial_state_cov)\n    raw_measurement_shocks = np.random.multivariate_normal(np.zeros(mod1.k_endog), np.eye(mod1.k_endog), size=nsimulations)\n    state_shocks = np.random.multivariate_normal(np.zeros(mod1.ssm.k_posdef), mod1['state_cov'], size=nsimulations)\n    L1 = np.diag(mod1['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks1 = (L1 @ raw_measurement_shocks.T).T\n    L2 = np.diag(mod2['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks2 = (L2 @ raw_measurement_shocks.T).T\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks)\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks)\n    assert_allclose(sim_actual, sim_desired)\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks, anchor='end')\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks, anchor='end')\n    assert_allclose(sim_actual, sim_desired)\n    irfs_actual = res1.impulse_responses(10)\n    irfs_desired = res2.impulse_responses(10)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    assert_allclose(irfs_actual, irfs_desired)",
        "mutated": [
            "def check_standardized_results(res1, res2, check_diagnostics=True):\n    if False:\n        i = 10\n    mod1 = res1.model\n    mod2 = res2.model\n    tmp = (1 - res1.filter_results.missing.T) * np.array(mod1._endog_std)[None, :] ** 2\n    mask = res1.filter_results.missing.T.astype(bool)\n    tmp[mask] = 1.0\n    llf_obs_diff = -0.5 * np.log(tmp).sum(axis=1)\n    assert_allclose(res1.llf_obs + llf_obs_diff, res2.llf_obs)\n    assert_allclose(res1.mae, res2.mae)\n    assert_allclose(res1.mse, res2.mse)\n    assert_allclose(res1.sse, res2.sse)\n    std = np.array(mod1._endog_std)\n    mean = np.array(mod1._endog_mean)\n    if mod1.k_endog > 1:\n        std = std[None, :]\n        mean = mean[None, :]\n    if mod1.k_endog == 1:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs,))\n    else:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs, mod1.k_endog))\n    actual = np.array(res1.fittedvalues) * std + mean\n    assert_allclose(actual, res2.fittedvalues)\n    actual = np.array(res1.resid) * std\n    assert_allclose(actual, res2.resid)\n    if check_diagnostics:\n        actual = res1.test_normality(method='jarquebera')\n        desired = res2.test_normality(method='jarquebera')\n        assert_allclose(actual, desired)\n        actual = res1.test_heteroskedasticity(method='breakvar')\n        desired = res2.test_heteroskedasticity(method='breakvar')\n        assert_allclose(actual, desired)\n        lags = min(10, res1.nobs_effective // 5)\n        actual = res1.test_serial_correlation(method='ljungbox', lags=lags)\n        desired = res2.test_serial_correlation(method='ljungbox', lags=lags)\n        assert_allclose(actual, desired)\n    start = res1.nobs // 10\n    dynamic = res1.nobs // 10\n    end = res1.nobs + 10\n    predict_actual = res1.predict()\n    forecast_actual = res1.forecast(10)\n    predict_dynamic_forecast_actual = res1.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_actual = res1.get_prediction()\n    get_forecast_actual = res1.get_forecast(10)\n    get_predict_dynamic_forecast_actual = res1.get_prediction(start=start, end=end, dynamic=dynamic)\n    predict_desired = res2.predict()\n    forecast_desired = res2.forecast(10)\n    predict_dynamic_forecast_desired = res2.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_desired = res2.get_prediction()\n    get_forecast_desired = res2.get_forecast(10)\n    get_predict_dynamic_forecast_desired = res2.get_prediction(start=start, end=end, dynamic=dynamic)\n    assert_allclose(predict_actual, predict_desired)\n    assert_allclose(forecast_actual, forecast_desired)\n    assert_allclose(predict_dynamic_forecast_actual, predict_dynamic_forecast_desired)\n    for i in range(mod1.k_endog):\n        assert_allclose(get_predict_actual.summary_frame(endog=i), get_predict_desired.summary_frame(endog=i))\n        assert_allclose(get_forecast_actual.summary_frame(endog=i), get_forecast_desired.summary_frame(endog=i))\n        assert_allclose(get_predict_dynamic_forecast_actual.summary_frame(endog=i), get_predict_dynamic_forecast_desired.summary_frame(endog=i))\n    np.random.seed(1234)\n    nsimulations = 100\n    initial_state = np.random.multivariate_normal(res1.filter_results.initial_state, res1.filter_results.initial_state_cov)\n    raw_measurement_shocks = np.random.multivariate_normal(np.zeros(mod1.k_endog), np.eye(mod1.k_endog), size=nsimulations)\n    state_shocks = np.random.multivariate_normal(np.zeros(mod1.ssm.k_posdef), mod1['state_cov'], size=nsimulations)\n    L1 = np.diag(mod1['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks1 = (L1 @ raw_measurement_shocks.T).T\n    L2 = np.diag(mod2['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks2 = (L2 @ raw_measurement_shocks.T).T\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks)\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks)\n    assert_allclose(sim_actual, sim_desired)\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks, anchor='end')\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks, anchor='end')\n    assert_allclose(sim_actual, sim_desired)\n    irfs_actual = res1.impulse_responses(10)\n    irfs_desired = res2.impulse_responses(10)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    assert_allclose(irfs_actual, irfs_desired)",
            "def check_standardized_results(res1, res2, check_diagnostics=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mod1 = res1.model\n    mod2 = res2.model\n    tmp = (1 - res1.filter_results.missing.T) * np.array(mod1._endog_std)[None, :] ** 2\n    mask = res1.filter_results.missing.T.astype(bool)\n    tmp[mask] = 1.0\n    llf_obs_diff = -0.5 * np.log(tmp).sum(axis=1)\n    assert_allclose(res1.llf_obs + llf_obs_diff, res2.llf_obs)\n    assert_allclose(res1.mae, res2.mae)\n    assert_allclose(res1.mse, res2.mse)\n    assert_allclose(res1.sse, res2.sse)\n    std = np.array(mod1._endog_std)\n    mean = np.array(mod1._endog_mean)\n    if mod1.k_endog > 1:\n        std = std[None, :]\n        mean = mean[None, :]\n    if mod1.k_endog == 1:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs,))\n    else:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs, mod1.k_endog))\n    actual = np.array(res1.fittedvalues) * std + mean\n    assert_allclose(actual, res2.fittedvalues)\n    actual = np.array(res1.resid) * std\n    assert_allclose(actual, res2.resid)\n    if check_diagnostics:\n        actual = res1.test_normality(method='jarquebera')\n        desired = res2.test_normality(method='jarquebera')\n        assert_allclose(actual, desired)\n        actual = res1.test_heteroskedasticity(method='breakvar')\n        desired = res2.test_heteroskedasticity(method='breakvar')\n        assert_allclose(actual, desired)\n        lags = min(10, res1.nobs_effective // 5)\n        actual = res1.test_serial_correlation(method='ljungbox', lags=lags)\n        desired = res2.test_serial_correlation(method='ljungbox', lags=lags)\n        assert_allclose(actual, desired)\n    start = res1.nobs // 10\n    dynamic = res1.nobs // 10\n    end = res1.nobs + 10\n    predict_actual = res1.predict()\n    forecast_actual = res1.forecast(10)\n    predict_dynamic_forecast_actual = res1.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_actual = res1.get_prediction()\n    get_forecast_actual = res1.get_forecast(10)\n    get_predict_dynamic_forecast_actual = res1.get_prediction(start=start, end=end, dynamic=dynamic)\n    predict_desired = res2.predict()\n    forecast_desired = res2.forecast(10)\n    predict_dynamic_forecast_desired = res2.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_desired = res2.get_prediction()\n    get_forecast_desired = res2.get_forecast(10)\n    get_predict_dynamic_forecast_desired = res2.get_prediction(start=start, end=end, dynamic=dynamic)\n    assert_allclose(predict_actual, predict_desired)\n    assert_allclose(forecast_actual, forecast_desired)\n    assert_allclose(predict_dynamic_forecast_actual, predict_dynamic_forecast_desired)\n    for i in range(mod1.k_endog):\n        assert_allclose(get_predict_actual.summary_frame(endog=i), get_predict_desired.summary_frame(endog=i))\n        assert_allclose(get_forecast_actual.summary_frame(endog=i), get_forecast_desired.summary_frame(endog=i))\n        assert_allclose(get_predict_dynamic_forecast_actual.summary_frame(endog=i), get_predict_dynamic_forecast_desired.summary_frame(endog=i))\n    np.random.seed(1234)\n    nsimulations = 100\n    initial_state = np.random.multivariate_normal(res1.filter_results.initial_state, res1.filter_results.initial_state_cov)\n    raw_measurement_shocks = np.random.multivariate_normal(np.zeros(mod1.k_endog), np.eye(mod1.k_endog), size=nsimulations)\n    state_shocks = np.random.multivariate_normal(np.zeros(mod1.ssm.k_posdef), mod1['state_cov'], size=nsimulations)\n    L1 = np.diag(mod1['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks1 = (L1 @ raw_measurement_shocks.T).T\n    L2 = np.diag(mod2['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks2 = (L2 @ raw_measurement_shocks.T).T\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks)\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks)\n    assert_allclose(sim_actual, sim_desired)\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks, anchor='end')\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks, anchor='end')\n    assert_allclose(sim_actual, sim_desired)\n    irfs_actual = res1.impulse_responses(10)\n    irfs_desired = res2.impulse_responses(10)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    assert_allclose(irfs_actual, irfs_desired)",
            "def check_standardized_results(res1, res2, check_diagnostics=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mod1 = res1.model\n    mod2 = res2.model\n    tmp = (1 - res1.filter_results.missing.T) * np.array(mod1._endog_std)[None, :] ** 2\n    mask = res1.filter_results.missing.T.astype(bool)\n    tmp[mask] = 1.0\n    llf_obs_diff = -0.5 * np.log(tmp).sum(axis=1)\n    assert_allclose(res1.llf_obs + llf_obs_diff, res2.llf_obs)\n    assert_allclose(res1.mae, res2.mae)\n    assert_allclose(res1.mse, res2.mse)\n    assert_allclose(res1.sse, res2.sse)\n    std = np.array(mod1._endog_std)\n    mean = np.array(mod1._endog_mean)\n    if mod1.k_endog > 1:\n        std = std[None, :]\n        mean = mean[None, :]\n    if mod1.k_endog == 1:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs,))\n    else:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs, mod1.k_endog))\n    actual = np.array(res1.fittedvalues) * std + mean\n    assert_allclose(actual, res2.fittedvalues)\n    actual = np.array(res1.resid) * std\n    assert_allclose(actual, res2.resid)\n    if check_diagnostics:\n        actual = res1.test_normality(method='jarquebera')\n        desired = res2.test_normality(method='jarquebera')\n        assert_allclose(actual, desired)\n        actual = res1.test_heteroskedasticity(method='breakvar')\n        desired = res2.test_heteroskedasticity(method='breakvar')\n        assert_allclose(actual, desired)\n        lags = min(10, res1.nobs_effective // 5)\n        actual = res1.test_serial_correlation(method='ljungbox', lags=lags)\n        desired = res2.test_serial_correlation(method='ljungbox', lags=lags)\n        assert_allclose(actual, desired)\n    start = res1.nobs // 10\n    dynamic = res1.nobs // 10\n    end = res1.nobs + 10\n    predict_actual = res1.predict()\n    forecast_actual = res1.forecast(10)\n    predict_dynamic_forecast_actual = res1.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_actual = res1.get_prediction()\n    get_forecast_actual = res1.get_forecast(10)\n    get_predict_dynamic_forecast_actual = res1.get_prediction(start=start, end=end, dynamic=dynamic)\n    predict_desired = res2.predict()\n    forecast_desired = res2.forecast(10)\n    predict_dynamic_forecast_desired = res2.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_desired = res2.get_prediction()\n    get_forecast_desired = res2.get_forecast(10)\n    get_predict_dynamic_forecast_desired = res2.get_prediction(start=start, end=end, dynamic=dynamic)\n    assert_allclose(predict_actual, predict_desired)\n    assert_allclose(forecast_actual, forecast_desired)\n    assert_allclose(predict_dynamic_forecast_actual, predict_dynamic_forecast_desired)\n    for i in range(mod1.k_endog):\n        assert_allclose(get_predict_actual.summary_frame(endog=i), get_predict_desired.summary_frame(endog=i))\n        assert_allclose(get_forecast_actual.summary_frame(endog=i), get_forecast_desired.summary_frame(endog=i))\n        assert_allclose(get_predict_dynamic_forecast_actual.summary_frame(endog=i), get_predict_dynamic_forecast_desired.summary_frame(endog=i))\n    np.random.seed(1234)\n    nsimulations = 100\n    initial_state = np.random.multivariate_normal(res1.filter_results.initial_state, res1.filter_results.initial_state_cov)\n    raw_measurement_shocks = np.random.multivariate_normal(np.zeros(mod1.k_endog), np.eye(mod1.k_endog), size=nsimulations)\n    state_shocks = np.random.multivariate_normal(np.zeros(mod1.ssm.k_posdef), mod1['state_cov'], size=nsimulations)\n    L1 = np.diag(mod1['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks1 = (L1 @ raw_measurement_shocks.T).T\n    L2 = np.diag(mod2['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks2 = (L2 @ raw_measurement_shocks.T).T\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks)\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks)\n    assert_allclose(sim_actual, sim_desired)\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks, anchor='end')\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks, anchor='end')\n    assert_allclose(sim_actual, sim_desired)\n    irfs_actual = res1.impulse_responses(10)\n    irfs_desired = res2.impulse_responses(10)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    assert_allclose(irfs_actual, irfs_desired)",
            "def check_standardized_results(res1, res2, check_diagnostics=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mod1 = res1.model\n    mod2 = res2.model\n    tmp = (1 - res1.filter_results.missing.T) * np.array(mod1._endog_std)[None, :] ** 2\n    mask = res1.filter_results.missing.T.astype(bool)\n    tmp[mask] = 1.0\n    llf_obs_diff = -0.5 * np.log(tmp).sum(axis=1)\n    assert_allclose(res1.llf_obs + llf_obs_diff, res2.llf_obs)\n    assert_allclose(res1.mae, res2.mae)\n    assert_allclose(res1.mse, res2.mse)\n    assert_allclose(res1.sse, res2.sse)\n    std = np.array(mod1._endog_std)\n    mean = np.array(mod1._endog_mean)\n    if mod1.k_endog > 1:\n        std = std[None, :]\n        mean = mean[None, :]\n    if mod1.k_endog == 1:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs,))\n    else:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs, mod1.k_endog))\n    actual = np.array(res1.fittedvalues) * std + mean\n    assert_allclose(actual, res2.fittedvalues)\n    actual = np.array(res1.resid) * std\n    assert_allclose(actual, res2.resid)\n    if check_diagnostics:\n        actual = res1.test_normality(method='jarquebera')\n        desired = res2.test_normality(method='jarquebera')\n        assert_allclose(actual, desired)\n        actual = res1.test_heteroskedasticity(method='breakvar')\n        desired = res2.test_heteroskedasticity(method='breakvar')\n        assert_allclose(actual, desired)\n        lags = min(10, res1.nobs_effective // 5)\n        actual = res1.test_serial_correlation(method='ljungbox', lags=lags)\n        desired = res2.test_serial_correlation(method='ljungbox', lags=lags)\n        assert_allclose(actual, desired)\n    start = res1.nobs // 10\n    dynamic = res1.nobs // 10\n    end = res1.nobs + 10\n    predict_actual = res1.predict()\n    forecast_actual = res1.forecast(10)\n    predict_dynamic_forecast_actual = res1.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_actual = res1.get_prediction()\n    get_forecast_actual = res1.get_forecast(10)\n    get_predict_dynamic_forecast_actual = res1.get_prediction(start=start, end=end, dynamic=dynamic)\n    predict_desired = res2.predict()\n    forecast_desired = res2.forecast(10)\n    predict_dynamic_forecast_desired = res2.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_desired = res2.get_prediction()\n    get_forecast_desired = res2.get_forecast(10)\n    get_predict_dynamic_forecast_desired = res2.get_prediction(start=start, end=end, dynamic=dynamic)\n    assert_allclose(predict_actual, predict_desired)\n    assert_allclose(forecast_actual, forecast_desired)\n    assert_allclose(predict_dynamic_forecast_actual, predict_dynamic_forecast_desired)\n    for i in range(mod1.k_endog):\n        assert_allclose(get_predict_actual.summary_frame(endog=i), get_predict_desired.summary_frame(endog=i))\n        assert_allclose(get_forecast_actual.summary_frame(endog=i), get_forecast_desired.summary_frame(endog=i))\n        assert_allclose(get_predict_dynamic_forecast_actual.summary_frame(endog=i), get_predict_dynamic_forecast_desired.summary_frame(endog=i))\n    np.random.seed(1234)\n    nsimulations = 100\n    initial_state = np.random.multivariate_normal(res1.filter_results.initial_state, res1.filter_results.initial_state_cov)\n    raw_measurement_shocks = np.random.multivariate_normal(np.zeros(mod1.k_endog), np.eye(mod1.k_endog), size=nsimulations)\n    state_shocks = np.random.multivariate_normal(np.zeros(mod1.ssm.k_posdef), mod1['state_cov'], size=nsimulations)\n    L1 = np.diag(mod1['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks1 = (L1 @ raw_measurement_shocks.T).T\n    L2 = np.diag(mod2['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks2 = (L2 @ raw_measurement_shocks.T).T\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks)\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks)\n    assert_allclose(sim_actual, sim_desired)\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks, anchor='end')\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks, anchor='end')\n    assert_allclose(sim_actual, sim_desired)\n    irfs_actual = res1.impulse_responses(10)\n    irfs_desired = res2.impulse_responses(10)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    assert_allclose(irfs_actual, irfs_desired)",
            "def check_standardized_results(res1, res2, check_diagnostics=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mod1 = res1.model\n    mod2 = res2.model\n    tmp = (1 - res1.filter_results.missing.T) * np.array(mod1._endog_std)[None, :] ** 2\n    mask = res1.filter_results.missing.T.astype(bool)\n    tmp[mask] = 1.0\n    llf_obs_diff = -0.5 * np.log(tmp).sum(axis=1)\n    assert_allclose(res1.llf_obs + llf_obs_diff, res2.llf_obs)\n    assert_allclose(res1.mae, res2.mae)\n    assert_allclose(res1.mse, res2.mse)\n    assert_allclose(res1.sse, res2.sse)\n    std = np.array(mod1._endog_std)\n    mean = np.array(mod1._endog_mean)\n    if mod1.k_endog > 1:\n        std = std[None, :]\n        mean = mean[None, :]\n    if mod1.k_endog == 1:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs,))\n    else:\n        assert_allclose(res1.fittedvalues.shape, (mod1.nobs, mod1.k_endog))\n    actual = np.array(res1.fittedvalues) * std + mean\n    assert_allclose(actual, res2.fittedvalues)\n    actual = np.array(res1.resid) * std\n    assert_allclose(actual, res2.resid)\n    if check_diagnostics:\n        actual = res1.test_normality(method='jarquebera')\n        desired = res2.test_normality(method='jarquebera')\n        assert_allclose(actual, desired)\n        actual = res1.test_heteroskedasticity(method='breakvar')\n        desired = res2.test_heteroskedasticity(method='breakvar')\n        assert_allclose(actual, desired)\n        lags = min(10, res1.nobs_effective // 5)\n        actual = res1.test_serial_correlation(method='ljungbox', lags=lags)\n        desired = res2.test_serial_correlation(method='ljungbox', lags=lags)\n        assert_allclose(actual, desired)\n    start = res1.nobs // 10\n    dynamic = res1.nobs // 10\n    end = res1.nobs + 10\n    predict_actual = res1.predict()\n    forecast_actual = res1.forecast(10)\n    predict_dynamic_forecast_actual = res1.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_actual = res1.get_prediction()\n    get_forecast_actual = res1.get_forecast(10)\n    get_predict_dynamic_forecast_actual = res1.get_prediction(start=start, end=end, dynamic=dynamic)\n    predict_desired = res2.predict()\n    forecast_desired = res2.forecast(10)\n    predict_dynamic_forecast_desired = res2.predict(start=start, end=end, dynamic=dynamic)\n    get_predict_desired = res2.get_prediction()\n    get_forecast_desired = res2.get_forecast(10)\n    get_predict_dynamic_forecast_desired = res2.get_prediction(start=start, end=end, dynamic=dynamic)\n    assert_allclose(predict_actual, predict_desired)\n    assert_allclose(forecast_actual, forecast_desired)\n    assert_allclose(predict_dynamic_forecast_actual, predict_dynamic_forecast_desired)\n    for i in range(mod1.k_endog):\n        assert_allclose(get_predict_actual.summary_frame(endog=i), get_predict_desired.summary_frame(endog=i))\n        assert_allclose(get_forecast_actual.summary_frame(endog=i), get_forecast_desired.summary_frame(endog=i))\n        assert_allclose(get_predict_dynamic_forecast_actual.summary_frame(endog=i), get_predict_dynamic_forecast_desired.summary_frame(endog=i))\n    np.random.seed(1234)\n    nsimulations = 100\n    initial_state = np.random.multivariate_normal(res1.filter_results.initial_state, res1.filter_results.initial_state_cov)\n    raw_measurement_shocks = np.random.multivariate_normal(np.zeros(mod1.k_endog), np.eye(mod1.k_endog), size=nsimulations)\n    state_shocks = np.random.multivariate_normal(np.zeros(mod1.ssm.k_posdef), mod1['state_cov'], size=nsimulations)\n    L1 = np.diag(mod1['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks1 = (L1 @ raw_measurement_shocks.T).T\n    L2 = np.diag(mod2['obs_cov'].diagonal() ** 0.5)\n    measurement_shocks2 = (L2 @ raw_measurement_shocks.T).T\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks)\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks)\n    assert_allclose(sim_actual, sim_desired)\n    sim_actual = res1.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks1, state_shocks=state_shocks, anchor='end')\n    sim_desired = res2.simulate(nsimulations=nsimulations, initial_state=initial_state, measurement_shocks=measurement_shocks2, state_shocks=state_shocks, anchor='end')\n    assert_allclose(sim_actual, sim_desired)\n    irfs_actual = res1.impulse_responses(10)\n    irfs_desired = res2.impulse_responses(10)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True)\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True)\n    assert_allclose(irfs_actual, irfs_desired)\n    irfs_actual = res1.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    irfs_desired = res2.impulse_responses(10, orthogonalized=True, cumulative=True, anchor='end')\n    assert_allclose(irfs_actual, irfs_desired)"
        ]
    },
    {
        "func_name": "check_identical_models",
        "original": "def check_identical_models(mod1, mod2, check_nobs=True):\n    if check_nobs:\n        assert_equal(mod2.nobs, mod1.nobs)\n    assert_equal(mod2.k_endog, mod1.k_endog)\n    assert_equal(mod2.k_endog_M, mod1.k_endog_M)\n    assert_equal(mod2.k_endog_Q, mod1.k_endog_Q)\n    assert_equal(mod2.k_states, mod1.k_states)\n    assert_equal(mod2.ssm.k_posdef, mod1.ssm.k_posdef)\n    assert_allclose(mod2._endog_mean, mod1._endog_mean)\n    assert_allclose(mod2._endog_std, mod1._endog_std)\n    assert_allclose(mod2.standardize, mod1.standardize)\n    assert_equal(mod2.factors, mod1.factors)\n    assert_equal(mod2.factor_orders, mod1.factor_orders)\n    assert_equal(mod2.factor_multiplicities, mod1.factor_multiplicities)\n    assert_equal(mod2.idiosyncratic_ar1, mod1.idiosyncratic_ar1)\n    assert_equal(mod2.init_t0, mod1.init_t0)\n    assert_equal(mod2.obs_cov_diag, mod1.obs_cov_diag)\n    assert_allclose(mod2.endog_factor_map, mod1.endog_factor_map)\n    assert_allclose(mod2.factor_block_orders, mod1.factor_block_orders)\n    assert_equal(mod2.endog_names, mod1.endog_names)\n    assert_equal(mod2.factor_names, mod1.factor_names)\n    assert_equal(mod2.k_factors, mod1.k_factors)\n    assert_equal(mod2.k_factor_blocks, mod1.k_factor_blocks)\n    assert_equal(mod2.max_factor_order, mod1.max_factor_order)",
        "mutated": [
            "def check_identical_models(mod1, mod2, check_nobs=True):\n    if False:\n        i = 10\n    if check_nobs:\n        assert_equal(mod2.nobs, mod1.nobs)\n    assert_equal(mod2.k_endog, mod1.k_endog)\n    assert_equal(mod2.k_endog_M, mod1.k_endog_M)\n    assert_equal(mod2.k_endog_Q, mod1.k_endog_Q)\n    assert_equal(mod2.k_states, mod1.k_states)\n    assert_equal(mod2.ssm.k_posdef, mod1.ssm.k_posdef)\n    assert_allclose(mod2._endog_mean, mod1._endog_mean)\n    assert_allclose(mod2._endog_std, mod1._endog_std)\n    assert_allclose(mod2.standardize, mod1.standardize)\n    assert_equal(mod2.factors, mod1.factors)\n    assert_equal(mod2.factor_orders, mod1.factor_orders)\n    assert_equal(mod2.factor_multiplicities, mod1.factor_multiplicities)\n    assert_equal(mod2.idiosyncratic_ar1, mod1.idiosyncratic_ar1)\n    assert_equal(mod2.init_t0, mod1.init_t0)\n    assert_equal(mod2.obs_cov_diag, mod1.obs_cov_diag)\n    assert_allclose(mod2.endog_factor_map, mod1.endog_factor_map)\n    assert_allclose(mod2.factor_block_orders, mod1.factor_block_orders)\n    assert_equal(mod2.endog_names, mod1.endog_names)\n    assert_equal(mod2.factor_names, mod1.factor_names)\n    assert_equal(mod2.k_factors, mod1.k_factors)\n    assert_equal(mod2.k_factor_blocks, mod1.k_factor_blocks)\n    assert_equal(mod2.max_factor_order, mod1.max_factor_order)",
            "def check_identical_models(mod1, mod2, check_nobs=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if check_nobs:\n        assert_equal(mod2.nobs, mod1.nobs)\n    assert_equal(mod2.k_endog, mod1.k_endog)\n    assert_equal(mod2.k_endog_M, mod1.k_endog_M)\n    assert_equal(mod2.k_endog_Q, mod1.k_endog_Q)\n    assert_equal(mod2.k_states, mod1.k_states)\n    assert_equal(mod2.ssm.k_posdef, mod1.ssm.k_posdef)\n    assert_allclose(mod2._endog_mean, mod1._endog_mean)\n    assert_allclose(mod2._endog_std, mod1._endog_std)\n    assert_allclose(mod2.standardize, mod1.standardize)\n    assert_equal(mod2.factors, mod1.factors)\n    assert_equal(mod2.factor_orders, mod1.factor_orders)\n    assert_equal(mod2.factor_multiplicities, mod1.factor_multiplicities)\n    assert_equal(mod2.idiosyncratic_ar1, mod1.idiosyncratic_ar1)\n    assert_equal(mod2.init_t0, mod1.init_t0)\n    assert_equal(mod2.obs_cov_diag, mod1.obs_cov_diag)\n    assert_allclose(mod2.endog_factor_map, mod1.endog_factor_map)\n    assert_allclose(mod2.factor_block_orders, mod1.factor_block_orders)\n    assert_equal(mod2.endog_names, mod1.endog_names)\n    assert_equal(mod2.factor_names, mod1.factor_names)\n    assert_equal(mod2.k_factors, mod1.k_factors)\n    assert_equal(mod2.k_factor_blocks, mod1.k_factor_blocks)\n    assert_equal(mod2.max_factor_order, mod1.max_factor_order)",
            "def check_identical_models(mod1, mod2, check_nobs=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if check_nobs:\n        assert_equal(mod2.nobs, mod1.nobs)\n    assert_equal(mod2.k_endog, mod1.k_endog)\n    assert_equal(mod2.k_endog_M, mod1.k_endog_M)\n    assert_equal(mod2.k_endog_Q, mod1.k_endog_Q)\n    assert_equal(mod2.k_states, mod1.k_states)\n    assert_equal(mod2.ssm.k_posdef, mod1.ssm.k_posdef)\n    assert_allclose(mod2._endog_mean, mod1._endog_mean)\n    assert_allclose(mod2._endog_std, mod1._endog_std)\n    assert_allclose(mod2.standardize, mod1.standardize)\n    assert_equal(mod2.factors, mod1.factors)\n    assert_equal(mod2.factor_orders, mod1.factor_orders)\n    assert_equal(mod2.factor_multiplicities, mod1.factor_multiplicities)\n    assert_equal(mod2.idiosyncratic_ar1, mod1.idiosyncratic_ar1)\n    assert_equal(mod2.init_t0, mod1.init_t0)\n    assert_equal(mod2.obs_cov_diag, mod1.obs_cov_diag)\n    assert_allclose(mod2.endog_factor_map, mod1.endog_factor_map)\n    assert_allclose(mod2.factor_block_orders, mod1.factor_block_orders)\n    assert_equal(mod2.endog_names, mod1.endog_names)\n    assert_equal(mod2.factor_names, mod1.factor_names)\n    assert_equal(mod2.k_factors, mod1.k_factors)\n    assert_equal(mod2.k_factor_blocks, mod1.k_factor_blocks)\n    assert_equal(mod2.max_factor_order, mod1.max_factor_order)",
            "def check_identical_models(mod1, mod2, check_nobs=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if check_nobs:\n        assert_equal(mod2.nobs, mod1.nobs)\n    assert_equal(mod2.k_endog, mod1.k_endog)\n    assert_equal(mod2.k_endog_M, mod1.k_endog_M)\n    assert_equal(mod2.k_endog_Q, mod1.k_endog_Q)\n    assert_equal(mod2.k_states, mod1.k_states)\n    assert_equal(mod2.ssm.k_posdef, mod1.ssm.k_posdef)\n    assert_allclose(mod2._endog_mean, mod1._endog_mean)\n    assert_allclose(mod2._endog_std, mod1._endog_std)\n    assert_allclose(mod2.standardize, mod1.standardize)\n    assert_equal(mod2.factors, mod1.factors)\n    assert_equal(mod2.factor_orders, mod1.factor_orders)\n    assert_equal(mod2.factor_multiplicities, mod1.factor_multiplicities)\n    assert_equal(mod2.idiosyncratic_ar1, mod1.idiosyncratic_ar1)\n    assert_equal(mod2.init_t0, mod1.init_t0)\n    assert_equal(mod2.obs_cov_diag, mod1.obs_cov_diag)\n    assert_allclose(mod2.endog_factor_map, mod1.endog_factor_map)\n    assert_allclose(mod2.factor_block_orders, mod1.factor_block_orders)\n    assert_equal(mod2.endog_names, mod1.endog_names)\n    assert_equal(mod2.factor_names, mod1.factor_names)\n    assert_equal(mod2.k_factors, mod1.k_factors)\n    assert_equal(mod2.k_factor_blocks, mod1.k_factor_blocks)\n    assert_equal(mod2.max_factor_order, mod1.max_factor_order)",
            "def check_identical_models(mod1, mod2, check_nobs=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if check_nobs:\n        assert_equal(mod2.nobs, mod1.nobs)\n    assert_equal(mod2.k_endog, mod1.k_endog)\n    assert_equal(mod2.k_endog_M, mod1.k_endog_M)\n    assert_equal(mod2.k_endog_Q, mod1.k_endog_Q)\n    assert_equal(mod2.k_states, mod1.k_states)\n    assert_equal(mod2.ssm.k_posdef, mod1.ssm.k_posdef)\n    assert_allclose(mod2._endog_mean, mod1._endog_mean)\n    assert_allclose(mod2._endog_std, mod1._endog_std)\n    assert_allclose(mod2.standardize, mod1.standardize)\n    assert_equal(mod2.factors, mod1.factors)\n    assert_equal(mod2.factor_orders, mod1.factor_orders)\n    assert_equal(mod2.factor_multiplicities, mod1.factor_multiplicities)\n    assert_equal(mod2.idiosyncratic_ar1, mod1.idiosyncratic_ar1)\n    assert_equal(mod2.init_t0, mod1.init_t0)\n    assert_equal(mod2.obs_cov_diag, mod1.obs_cov_diag)\n    assert_allclose(mod2.endog_factor_map, mod1.endog_factor_map)\n    assert_allclose(mod2.factor_block_orders, mod1.factor_block_orders)\n    assert_equal(mod2.endog_names, mod1.endog_names)\n    assert_equal(mod2.factor_names, mod1.factor_names)\n    assert_equal(mod2.k_factors, mod1.k_factors)\n    assert_equal(mod2.k_factor_blocks, mod1.k_factor_blocks)\n    assert_equal(mod2.max_factor_order, mod1.max_factor_order)"
        ]
    },
    {
        "func_name": "check_append",
        "original": "def check_append(res1, res2, endog_M2, endog_Q2):\n    res1_append = res1.append(endog_M2, endog_quarterly=endog_Q2)\n    mod1_append = res1_append.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_append, check_nobs=False)\n    assert_equal(mod1_append.nobs, mod1.nobs + len(endog_M2))\n    assert_allclose(mod1_append.endog[:mod1.nobs], mod1.endog)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.llf_obs[:mod1.nobs], res1.llf_obs)\n    assert_allclose(res1_append.filter_results.forecasts[:, :mod1.nobs], res1.filter_results.forecasts)\n    assert_allclose(res1_append.filter_results.forecasts_error[:, :mod1.nobs], res1.filter_results.forecasts_error)\n    assert_allclose(res1_append.filter_results.initial_state, res1.filter_results.initial_state)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.filter_results.filtered_state[:, :mod1.nobs], res1.filter_results.filtered_state)\n    assert_allclose(res1_append.filter_results.filtered_state_cov[..., :mod1.nobs], res1.filter_results.filtered_state_cov)\n    res2_append = res2.append(endog_M2, endog_quarterly=endog_Q2)\n    mod2_append = res2_append.model\n    mod2 = res2.model\n    mod2_append.update(res2_append.params)\n    mod2_append['obs_intercept'] = mod2['obs_intercept']\n    mod2_append['design'] = mod2['design']\n    mod2_append['obs_cov'] = mod2['obs_cov']\n    mod2_append.update = lambda params, **kwargs: params\n    res2_append = mod2_append.smooth(res2_append.params)\n    check_identical_models(mod2, mod2_append, check_nobs=False)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.llf_obs[:mod2.nobs], res2.llf_obs)\n    assert_allclose(res2_append.filter_results.forecasts[:, :mod2.nobs], res2.filter_results.forecasts)\n    assert_allclose(res2_append.filter_results.forecasts_error[:, :mod2.nobs], res2.filter_results.forecasts_error)\n    assert_allclose(res2_append.filter_results.initial_state, res2.filter_results.initial_state)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.filter_results.filtered_state[:, :mod2.nobs], res2.filter_results.filtered_state)\n    assert_allclose(res2_append.filter_results.filtered_state_cov[..., :mod2.nobs], res2.filter_results.filtered_state_cov)\n    check_standardized_results(res1_append, res2_append)",
        "mutated": [
            "def check_append(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n    res1_append = res1.append(endog_M2, endog_quarterly=endog_Q2)\n    mod1_append = res1_append.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_append, check_nobs=False)\n    assert_equal(mod1_append.nobs, mod1.nobs + len(endog_M2))\n    assert_allclose(mod1_append.endog[:mod1.nobs], mod1.endog)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.llf_obs[:mod1.nobs], res1.llf_obs)\n    assert_allclose(res1_append.filter_results.forecasts[:, :mod1.nobs], res1.filter_results.forecasts)\n    assert_allclose(res1_append.filter_results.forecasts_error[:, :mod1.nobs], res1.filter_results.forecasts_error)\n    assert_allclose(res1_append.filter_results.initial_state, res1.filter_results.initial_state)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.filter_results.filtered_state[:, :mod1.nobs], res1.filter_results.filtered_state)\n    assert_allclose(res1_append.filter_results.filtered_state_cov[..., :mod1.nobs], res1.filter_results.filtered_state_cov)\n    res2_append = res2.append(endog_M2, endog_quarterly=endog_Q2)\n    mod2_append = res2_append.model\n    mod2 = res2.model\n    mod2_append.update(res2_append.params)\n    mod2_append['obs_intercept'] = mod2['obs_intercept']\n    mod2_append['design'] = mod2['design']\n    mod2_append['obs_cov'] = mod2['obs_cov']\n    mod2_append.update = lambda params, **kwargs: params\n    res2_append = mod2_append.smooth(res2_append.params)\n    check_identical_models(mod2, mod2_append, check_nobs=False)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.llf_obs[:mod2.nobs], res2.llf_obs)\n    assert_allclose(res2_append.filter_results.forecasts[:, :mod2.nobs], res2.filter_results.forecasts)\n    assert_allclose(res2_append.filter_results.forecasts_error[:, :mod2.nobs], res2.filter_results.forecasts_error)\n    assert_allclose(res2_append.filter_results.initial_state, res2.filter_results.initial_state)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.filter_results.filtered_state[:, :mod2.nobs], res2.filter_results.filtered_state)\n    assert_allclose(res2_append.filter_results.filtered_state_cov[..., :mod2.nobs], res2.filter_results.filtered_state_cov)\n    check_standardized_results(res1_append, res2_append)",
            "def check_append(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res1_append = res1.append(endog_M2, endog_quarterly=endog_Q2)\n    mod1_append = res1_append.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_append, check_nobs=False)\n    assert_equal(mod1_append.nobs, mod1.nobs + len(endog_M2))\n    assert_allclose(mod1_append.endog[:mod1.nobs], mod1.endog)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.llf_obs[:mod1.nobs], res1.llf_obs)\n    assert_allclose(res1_append.filter_results.forecasts[:, :mod1.nobs], res1.filter_results.forecasts)\n    assert_allclose(res1_append.filter_results.forecasts_error[:, :mod1.nobs], res1.filter_results.forecasts_error)\n    assert_allclose(res1_append.filter_results.initial_state, res1.filter_results.initial_state)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.filter_results.filtered_state[:, :mod1.nobs], res1.filter_results.filtered_state)\n    assert_allclose(res1_append.filter_results.filtered_state_cov[..., :mod1.nobs], res1.filter_results.filtered_state_cov)\n    res2_append = res2.append(endog_M2, endog_quarterly=endog_Q2)\n    mod2_append = res2_append.model\n    mod2 = res2.model\n    mod2_append.update(res2_append.params)\n    mod2_append['obs_intercept'] = mod2['obs_intercept']\n    mod2_append['design'] = mod2['design']\n    mod2_append['obs_cov'] = mod2['obs_cov']\n    mod2_append.update = lambda params, **kwargs: params\n    res2_append = mod2_append.smooth(res2_append.params)\n    check_identical_models(mod2, mod2_append, check_nobs=False)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.llf_obs[:mod2.nobs], res2.llf_obs)\n    assert_allclose(res2_append.filter_results.forecasts[:, :mod2.nobs], res2.filter_results.forecasts)\n    assert_allclose(res2_append.filter_results.forecasts_error[:, :mod2.nobs], res2.filter_results.forecasts_error)\n    assert_allclose(res2_append.filter_results.initial_state, res2.filter_results.initial_state)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.filter_results.filtered_state[:, :mod2.nobs], res2.filter_results.filtered_state)\n    assert_allclose(res2_append.filter_results.filtered_state_cov[..., :mod2.nobs], res2.filter_results.filtered_state_cov)\n    check_standardized_results(res1_append, res2_append)",
            "def check_append(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res1_append = res1.append(endog_M2, endog_quarterly=endog_Q2)\n    mod1_append = res1_append.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_append, check_nobs=False)\n    assert_equal(mod1_append.nobs, mod1.nobs + len(endog_M2))\n    assert_allclose(mod1_append.endog[:mod1.nobs], mod1.endog)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.llf_obs[:mod1.nobs], res1.llf_obs)\n    assert_allclose(res1_append.filter_results.forecasts[:, :mod1.nobs], res1.filter_results.forecasts)\n    assert_allclose(res1_append.filter_results.forecasts_error[:, :mod1.nobs], res1.filter_results.forecasts_error)\n    assert_allclose(res1_append.filter_results.initial_state, res1.filter_results.initial_state)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.filter_results.filtered_state[:, :mod1.nobs], res1.filter_results.filtered_state)\n    assert_allclose(res1_append.filter_results.filtered_state_cov[..., :mod1.nobs], res1.filter_results.filtered_state_cov)\n    res2_append = res2.append(endog_M2, endog_quarterly=endog_Q2)\n    mod2_append = res2_append.model\n    mod2 = res2.model\n    mod2_append.update(res2_append.params)\n    mod2_append['obs_intercept'] = mod2['obs_intercept']\n    mod2_append['design'] = mod2['design']\n    mod2_append['obs_cov'] = mod2['obs_cov']\n    mod2_append.update = lambda params, **kwargs: params\n    res2_append = mod2_append.smooth(res2_append.params)\n    check_identical_models(mod2, mod2_append, check_nobs=False)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.llf_obs[:mod2.nobs], res2.llf_obs)\n    assert_allclose(res2_append.filter_results.forecasts[:, :mod2.nobs], res2.filter_results.forecasts)\n    assert_allclose(res2_append.filter_results.forecasts_error[:, :mod2.nobs], res2.filter_results.forecasts_error)\n    assert_allclose(res2_append.filter_results.initial_state, res2.filter_results.initial_state)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.filter_results.filtered_state[:, :mod2.nobs], res2.filter_results.filtered_state)\n    assert_allclose(res2_append.filter_results.filtered_state_cov[..., :mod2.nobs], res2.filter_results.filtered_state_cov)\n    check_standardized_results(res1_append, res2_append)",
            "def check_append(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res1_append = res1.append(endog_M2, endog_quarterly=endog_Q2)\n    mod1_append = res1_append.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_append, check_nobs=False)\n    assert_equal(mod1_append.nobs, mod1.nobs + len(endog_M2))\n    assert_allclose(mod1_append.endog[:mod1.nobs], mod1.endog)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.llf_obs[:mod1.nobs], res1.llf_obs)\n    assert_allclose(res1_append.filter_results.forecasts[:, :mod1.nobs], res1.filter_results.forecasts)\n    assert_allclose(res1_append.filter_results.forecasts_error[:, :mod1.nobs], res1.filter_results.forecasts_error)\n    assert_allclose(res1_append.filter_results.initial_state, res1.filter_results.initial_state)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.filter_results.filtered_state[:, :mod1.nobs], res1.filter_results.filtered_state)\n    assert_allclose(res1_append.filter_results.filtered_state_cov[..., :mod1.nobs], res1.filter_results.filtered_state_cov)\n    res2_append = res2.append(endog_M2, endog_quarterly=endog_Q2)\n    mod2_append = res2_append.model\n    mod2 = res2.model\n    mod2_append.update(res2_append.params)\n    mod2_append['obs_intercept'] = mod2['obs_intercept']\n    mod2_append['design'] = mod2['design']\n    mod2_append['obs_cov'] = mod2['obs_cov']\n    mod2_append.update = lambda params, **kwargs: params\n    res2_append = mod2_append.smooth(res2_append.params)\n    check_identical_models(mod2, mod2_append, check_nobs=False)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.llf_obs[:mod2.nobs], res2.llf_obs)\n    assert_allclose(res2_append.filter_results.forecasts[:, :mod2.nobs], res2.filter_results.forecasts)\n    assert_allclose(res2_append.filter_results.forecasts_error[:, :mod2.nobs], res2.filter_results.forecasts_error)\n    assert_allclose(res2_append.filter_results.initial_state, res2.filter_results.initial_state)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.filter_results.filtered_state[:, :mod2.nobs], res2.filter_results.filtered_state)\n    assert_allclose(res2_append.filter_results.filtered_state_cov[..., :mod2.nobs], res2.filter_results.filtered_state_cov)\n    check_standardized_results(res1_append, res2_append)",
            "def check_append(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res1_append = res1.append(endog_M2, endog_quarterly=endog_Q2)\n    mod1_append = res1_append.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_append, check_nobs=False)\n    assert_equal(mod1_append.nobs, mod1.nobs + len(endog_M2))\n    assert_allclose(mod1_append.endog[:mod1.nobs], mod1.endog)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.llf_obs[:mod1.nobs], res1.llf_obs)\n    assert_allclose(res1_append.filter_results.forecasts[:, :mod1.nobs], res1.filter_results.forecasts)\n    assert_allclose(res1_append.filter_results.forecasts_error[:, :mod1.nobs], res1.filter_results.forecasts_error)\n    assert_allclose(res1_append.filter_results.initial_state, res1.filter_results.initial_state)\n    assert_allclose(res1_append.filter_results.initial_state_cov, res1.filter_results.initial_state_cov)\n    assert_allclose(res1_append.filter_results.filtered_state[:, :mod1.nobs], res1.filter_results.filtered_state)\n    assert_allclose(res1_append.filter_results.filtered_state_cov[..., :mod1.nobs], res1.filter_results.filtered_state_cov)\n    res2_append = res2.append(endog_M2, endog_quarterly=endog_Q2)\n    mod2_append = res2_append.model\n    mod2 = res2.model\n    mod2_append.update(res2_append.params)\n    mod2_append['obs_intercept'] = mod2['obs_intercept']\n    mod2_append['design'] = mod2['design']\n    mod2_append['obs_cov'] = mod2['obs_cov']\n    mod2_append.update = lambda params, **kwargs: params\n    res2_append = mod2_append.smooth(res2_append.params)\n    check_identical_models(mod2, mod2_append, check_nobs=False)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.llf_obs[:mod2.nobs], res2.llf_obs)\n    assert_allclose(res2_append.filter_results.forecasts[:, :mod2.nobs], res2.filter_results.forecasts)\n    assert_allclose(res2_append.filter_results.forecasts_error[:, :mod2.nobs], res2.filter_results.forecasts_error)\n    assert_allclose(res2_append.filter_results.initial_state, res2.filter_results.initial_state)\n    assert_allclose(res2_append.filter_results.initial_state_cov, res2.filter_results.initial_state_cov)\n    assert_allclose(res2_append.filter_results.filtered_state[:, :mod2.nobs], res2.filter_results.filtered_state)\n    assert_allclose(res2_append.filter_results.filtered_state_cov[..., :mod2.nobs], res2.filter_results.filtered_state_cov)\n    check_standardized_results(res1_append, res2_append)"
        ]
    },
    {
        "func_name": "check_extend",
        "original": "def check_extend(res1, res2, endog_M2, endog_Q2):\n    res1_extend = res1.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod1_extend = res1_extend.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_extend, check_nobs=False)\n    assert_equal(mod1_extend.nobs, len(endog_M2))\n    res2_extend = res2.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod2_extend = res2_extend.model\n    mod2 = res2.model\n    mod2_extend.update(res2_extend.params)\n    mod2_extend['obs_intercept'] = mod2['obs_intercept']\n    mod2_extend['design'] = mod2['design']\n    mod2_extend['obs_cov'] = mod2['obs_cov']\n    mod2_extend.update = lambda params, **kwargs: params\n    res2_extend = mod2_extend.smooth(res2_extend.params)\n    check_identical_models(mod2, mod2_extend, check_nobs=False)\n    check_standardized_results(res1_extend, res2_extend, check_diagnostics=False)",
        "mutated": [
            "def check_extend(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n    res1_extend = res1.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod1_extend = res1_extend.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_extend, check_nobs=False)\n    assert_equal(mod1_extend.nobs, len(endog_M2))\n    res2_extend = res2.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod2_extend = res2_extend.model\n    mod2 = res2.model\n    mod2_extend.update(res2_extend.params)\n    mod2_extend['obs_intercept'] = mod2['obs_intercept']\n    mod2_extend['design'] = mod2['design']\n    mod2_extend['obs_cov'] = mod2['obs_cov']\n    mod2_extend.update = lambda params, **kwargs: params\n    res2_extend = mod2_extend.smooth(res2_extend.params)\n    check_identical_models(mod2, mod2_extend, check_nobs=False)\n    check_standardized_results(res1_extend, res2_extend, check_diagnostics=False)",
            "def check_extend(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res1_extend = res1.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod1_extend = res1_extend.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_extend, check_nobs=False)\n    assert_equal(mod1_extend.nobs, len(endog_M2))\n    res2_extend = res2.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod2_extend = res2_extend.model\n    mod2 = res2.model\n    mod2_extend.update(res2_extend.params)\n    mod2_extend['obs_intercept'] = mod2['obs_intercept']\n    mod2_extend['design'] = mod2['design']\n    mod2_extend['obs_cov'] = mod2['obs_cov']\n    mod2_extend.update = lambda params, **kwargs: params\n    res2_extend = mod2_extend.smooth(res2_extend.params)\n    check_identical_models(mod2, mod2_extend, check_nobs=False)\n    check_standardized_results(res1_extend, res2_extend, check_diagnostics=False)",
            "def check_extend(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res1_extend = res1.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod1_extend = res1_extend.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_extend, check_nobs=False)\n    assert_equal(mod1_extend.nobs, len(endog_M2))\n    res2_extend = res2.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod2_extend = res2_extend.model\n    mod2 = res2.model\n    mod2_extend.update(res2_extend.params)\n    mod2_extend['obs_intercept'] = mod2['obs_intercept']\n    mod2_extend['design'] = mod2['design']\n    mod2_extend['obs_cov'] = mod2['obs_cov']\n    mod2_extend.update = lambda params, **kwargs: params\n    res2_extend = mod2_extend.smooth(res2_extend.params)\n    check_identical_models(mod2, mod2_extend, check_nobs=False)\n    check_standardized_results(res1_extend, res2_extend, check_diagnostics=False)",
            "def check_extend(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res1_extend = res1.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod1_extend = res1_extend.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_extend, check_nobs=False)\n    assert_equal(mod1_extend.nobs, len(endog_M2))\n    res2_extend = res2.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod2_extend = res2_extend.model\n    mod2 = res2.model\n    mod2_extend.update(res2_extend.params)\n    mod2_extend['obs_intercept'] = mod2['obs_intercept']\n    mod2_extend['design'] = mod2['design']\n    mod2_extend['obs_cov'] = mod2['obs_cov']\n    mod2_extend.update = lambda params, **kwargs: params\n    res2_extend = mod2_extend.smooth(res2_extend.params)\n    check_identical_models(mod2, mod2_extend, check_nobs=False)\n    check_standardized_results(res1_extend, res2_extend, check_diagnostics=False)",
            "def check_extend(res1, res2, endog_M2, endog_Q2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res1_extend = res1.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod1_extend = res1_extend.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_extend, check_nobs=False)\n    assert_equal(mod1_extend.nobs, len(endog_M2))\n    res2_extend = res2.extend(endog_M2, endog_quarterly=endog_Q2)\n    mod2_extend = res2_extend.model\n    mod2 = res2.model\n    mod2_extend.update(res2_extend.params)\n    mod2_extend['obs_intercept'] = mod2['obs_intercept']\n    mod2_extend['design'] = mod2['design']\n    mod2_extend['obs_cov'] = mod2['obs_cov']\n    mod2_extend.update = lambda params, **kwargs: params\n    res2_extend = mod2_extend.smooth(res2_extend.params)\n    check_identical_models(mod2, mod2_extend, check_nobs=False)\n    check_standardized_results(res1_extend, res2_extend, check_diagnostics=False)"
        ]
    },
    {
        "func_name": "check_apply",
        "original": "def check_apply(res1, res2, endog_M, endog_Q):\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    mod1_apply = res1_apply.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_apply, check_nobs=False)\n    assert_equal(mod1_apply.nobs, len(endog_M))\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2 = res2.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    check_identical_models(mod2, mod2_apply, check_nobs=False)\n    check_standardized_results(res1_apply, res2_apply, check_diagnostics=False)",
        "mutated": [
            "def check_apply(res1, res2, endog_M, endog_Q):\n    if False:\n        i = 10\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    mod1_apply = res1_apply.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_apply, check_nobs=False)\n    assert_equal(mod1_apply.nobs, len(endog_M))\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2 = res2.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    check_identical_models(mod2, mod2_apply, check_nobs=False)\n    check_standardized_results(res1_apply, res2_apply, check_diagnostics=False)",
            "def check_apply(res1, res2, endog_M, endog_Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    mod1_apply = res1_apply.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_apply, check_nobs=False)\n    assert_equal(mod1_apply.nobs, len(endog_M))\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2 = res2.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    check_identical_models(mod2, mod2_apply, check_nobs=False)\n    check_standardized_results(res1_apply, res2_apply, check_diagnostics=False)",
            "def check_apply(res1, res2, endog_M, endog_Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    mod1_apply = res1_apply.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_apply, check_nobs=False)\n    assert_equal(mod1_apply.nobs, len(endog_M))\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2 = res2.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    check_identical_models(mod2, mod2_apply, check_nobs=False)\n    check_standardized_results(res1_apply, res2_apply, check_diagnostics=False)",
            "def check_apply(res1, res2, endog_M, endog_Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    mod1_apply = res1_apply.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_apply, check_nobs=False)\n    assert_equal(mod1_apply.nobs, len(endog_M))\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2 = res2.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    check_identical_models(mod2, mod2_apply, check_nobs=False)\n    check_standardized_results(res1_apply, res2_apply, check_diagnostics=False)",
            "def check_apply(res1, res2, endog_M, endog_Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    mod1_apply = res1_apply.model\n    mod1 = res1.model\n    check_identical_models(mod1, mod1_apply, check_nobs=False)\n    assert_equal(mod1_apply.nobs, len(endog_M))\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2 = res2.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    check_identical_models(mod2, mod2_apply, check_nobs=False)\n    check_standardized_results(res1_apply, res2_apply, check_diagnostics=False)"
        ]
    },
    {
        "func_name": "test_standardized_monthly",
        "original": "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('k_endog', [1, 2])\n@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_monthly(reset_randomstate, idiosyncratic_ar1, k_endog, use_pandas):\n    nobs = 100\n    k2 = 2\n    (_, _, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    if k_endog == 1:\n        endog = f2.iloc[:, 0]\n        endog_mean = pd.Series([10], index=['f1'])\n        endog_std = pd.Series([1], index=['f1'])\n    else:\n        endog = f2\n        endog_mean = pd.Series([10, -4], index=['f1', 'f2'])\n        endog_std = pd.Series([1, 1], index=['f1', 'f2'])\n    if not use_pandas:\n        endog = endog.values\n        endog_mean = endog_mean.values\n        endog_std = endog_std.values\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = np.array(endog_mean)\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)",
        "mutated": [
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('k_endog', [1, 2])\n@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_monthly(reset_randomstate, idiosyncratic_ar1, k_endog, use_pandas):\n    if False:\n        i = 10\n    nobs = 100\n    k2 = 2\n    (_, _, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    if k_endog == 1:\n        endog = f2.iloc[:, 0]\n        endog_mean = pd.Series([10], index=['f1'])\n        endog_std = pd.Series([1], index=['f1'])\n    else:\n        endog = f2\n        endog_mean = pd.Series([10, -4], index=['f1', 'f2'])\n        endog_std = pd.Series([1, 1], index=['f1', 'f2'])\n    if not use_pandas:\n        endog = endog.values\n        endog_mean = endog_mean.values\n        endog_std = endog_std.values\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = np.array(endog_mean)\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('k_endog', [1, 2])\n@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_monthly(reset_randomstate, idiosyncratic_ar1, k_endog, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nobs = 100\n    k2 = 2\n    (_, _, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    if k_endog == 1:\n        endog = f2.iloc[:, 0]\n        endog_mean = pd.Series([10], index=['f1'])\n        endog_std = pd.Series([1], index=['f1'])\n    else:\n        endog = f2\n        endog_mean = pd.Series([10, -4], index=['f1', 'f2'])\n        endog_std = pd.Series([1, 1], index=['f1', 'f2'])\n    if not use_pandas:\n        endog = endog.values\n        endog_mean = endog_mean.values\n        endog_std = endog_std.values\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = np.array(endog_mean)\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('k_endog', [1, 2])\n@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_monthly(reset_randomstate, idiosyncratic_ar1, k_endog, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nobs = 100\n    k2 = 2\n    (_, _, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    if k_endog == 1:\n        endog = f2.iloc[:, 0]\n        endog_mean = pd.Series([10], index=['f1'])\n        endog_std = pd.Series([1], index=['f1'])\n    else:\n        endog = f2\n        endog_mean = pd.Series([10, -4], index=['f1', 'f2'])\n        endog_std = pd.Series([1, 1], index=['f1', 'f2'])\n    if not use_pandas:\n        endog = endog.values\n        endog_mean = endog_mean.values\n        endog_std = endog_std.values\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = np.array(endog_mean)\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('k_endog', [1, 2])\n@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_monthly(reset_randomstate, idiosyncratic_ar1, k_endog, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nobs = 100\n    k2 = 2\n    (_, _, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    if k_endog == 1:\n        endog = f2.iloc[:, 0]\n        endog_mean = pd.Series([10], index=['f1'])\n        endog_std = pd.Series([1], index=['f1'])\n    else:\n        endog = f2\n        endog_mean = pd.Series([10, -4], index=['f1', 'f2'])\n        endog_std = pd.Series([1, 1], index=['f1', 'f2'])\n    if not use_pandas:\n        endog = endog.values\n        endog_mean = endog_mean.values\n        endog_std = endog_std.values\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = np.array(endog_mean)\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)",
            "@pytest.mark.parametrize('use_pandas', [True, False])\n@pytest.mark.parametrize('k_endog', [1, 2])\n@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_monthly(reset_randomstate, idiosyncratic_ar1, k_endog, use_pandas):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nobs = 100\n    k2 = 2\n    (_, _, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    if k_endog == 1:\n        endog = f2.iloc[:, 0]\n        endog_mean = pd.Series([10], index=['f1'])\n        endog_std = pd.Series([1], index=['f1'])\n    else:\n        endog = f2\n        endog_mean = pd.Series([10, -4], index=['f1', 'f2'])\n        endog_std = pd.Series([1, 1], index=['f1', 'f2'])\n    if not use_pandas:\n        endog = endog.values\n        endog_mean = endog_mean.values\n        endog_std = endog_std.values\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog, factors=1, factor_multiplicities=1, factor_orders=1, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = np.array(endog_mean)\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)"
        ]
    },
    {
        "func_name": "test_standardized_MQ",
        "original": "@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_MQ(reset_randomstate, idiosyncratic_ar1):\n    nobs = 100\n    idiosyncratic_ar1 = False\n    k1 = 2\n    k2 = 2\n    (endog1_M, endog1_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1, sort=True)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1, sort=True)\n    endog_M1 = endog_M.loc[:'1957-12']\n    endog_Q1 = endog_Q.loc[:'1957Q4']\n    endog_M2 = endog_M.loc['1958-01':]\n    endog_Q2 = endog_Q.loc['1958Q1':]\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    endog_mean = pd.Series(np.random.normal(size=len(factors)), index=factors.keys())\n    endog_std = pd.Series(np.abs(np.random.normal(size=len(factors))), index=factors.keys())\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = endog_mean\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)\n    check_append(res1, res2, endog_M2, endog_Q2)\n    check_extend(res1, res2, endog_M2, endog_Q2)\n    check_apply(res1, res2, endog_M, endog_Q)\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    news1 = res1_apply.news(res1, start='1958-01', end='1958-03', comparison_type='previous')\n    news2 = res2_apply.news(res2, start='1958-01', end='1958-03', comparison_type='previous')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(news1, attr)\n        x = getattr(news2, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
        "mutated": [
            "@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_MQ(reset_randomstate, idiosyncratic_ar1):\n    if False:\n        i = 10\n    nobs = 100\n    idiosyncratic_ar1 = False\n    k1 = 2\n    k2 = 2\n    (endog1_M, endog1_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1, sort=True)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1, sort=True)\n    endog_M1 = endog_M.loc[:'1957-12']\n    endog_Q1 = endog_Q.loc[:'1957Q4']\n    endog_M2 = endog_M.loc['1958-01':]\n    endog_Q2 = endog_Q.loc['1958Q1':]\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    endog_mean = pd.Series(np.random.normal(size=len(factors)), index=factors.keys())\n    endog_std = pd.Series(np.abs(np.random.normal(size=len(factors))), index=factors.keys())\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = endog_mean\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)\n    check_append(res1, res2, endog_M2, endog_Q2)\n    check_extend(res1, res2, endog_M2, endog_Q2)\n    check_apply(res1, res2, endog_M, endog_Q)\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    news1 = res1_apply.news(res1, start='1958-01', end='1958-03', comparison_type='previous')\n    news2 = res2_apply.news(res2, start='1958-01', end='1958-03', comparison_type='previous')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(news1, attr)\n        x = getattr(news2, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_MQ(reset_randomstate, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nobs = 100\n    idiosyncratic_ar1 = False\n    k1 = 2\n    k2 = 2\n    (endog1_M, endog1_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1, sort=True)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1, sort=True)\n    endog_M1 = endog_M.loc[:'1957-12']\n    endog_Q1 = endog_Q.loc[:'1957Q4']\n    endog_M2 = endog_M.loc['1958-01':]\n    endog_Q2 = endog_Q.loc['1958Q1':]\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    endog_mean = pd.Series(np.random.normal(size=len(factors)), index=factors.keys())\n    endog_std = pd.Series(np.abs(np.random.normal(size=len(factors))), index=factors.keys())\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = endog_mean\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)\n    check_append(res1, res2, endog_M2, endog_Q2)\n    check_extend(res1, res2, endog_M2, endog_Q2)\n    check_apply(res1, res2, endog_M, endog_Q)\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    news1 = res1_apply.news(res1, start='1958-01', end='1958-03', comparison_type='previous')\n    news2 = res2_apply.news(res2, start='1958-01', end='1958-03', comparison_type='previous')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(news1, attr)\n        x = getattr(news2, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_MQ(reset_randomstate, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nobs = 100\n    idiosyncratic_ar1 = False\n    k1 = 2\n    k2 = 2\n    (endog1_M, endog1_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1, sort=True)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1, sort=True)\n    endog_M1 = endog_M.loc[:'1957-12']\n    endog_Q1 = endog_Q.loc[:'1957Q4']\n    endog_M2 = endog_M.loc['1958-01':]\n    endog_Q2 = endog_Q.loc['1958Q1':]\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    endog_mean = pd.Series(np.random.normal(size=len(factors)), index=factors.keys())\n    endog_std = pd.Series(np.abs(np.random.normal(size=len(factors))), index=factors.keys())\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = endog_mean\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)\n    check_append(res1, res2, endog_M2, endog_Q2)\n    check_extend(res1, res2, endog_M2, endog_Q2)\n    check_apply(res1, res2, endog_M, endog_Q)\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    news1 = res1_apply.news(res1, start='1958-01', end='1958-03', comparison_type='previous')\n    news2 = res2_apply.news(res2, start='1958-01', end='1958-03', comparison_type='previous')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(news1, attr)\n        x = getattr(news2, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_MQ(reset_randomstate, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nobs = 100\n    idiosyncratic_ar1 = False\n    k1 = 2\n    k2 = 2\n    (endog1_M, endog1_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1, sort=True)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1, sort=True)\n    endog_M1 = endog_M.loc[:'1957-12']\n    endog_Q1 = endog_Q.loc[:'1957Q4']\n    endog_M2 = endog_M.loc['1958-01':]\n    endog_Q2 = endog_Q.loc['1958Q1':]\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    endog_mean = pd.Series(np.random.normal(size=len(factors)), index=factors.keys())\n    endog_std = pd.Series(np.abs(np.random.normal(size=len(factors))), index=factors.keys())\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = endog_mean\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)\n    check_append(res1, res2, endog_M2, endog_Q2)\n    check_extend(res1, res2, endog_M2, endog_Q2)\n    check_apply(res1, res2, endog_M, endog_Q)\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    news1 = res1_apply.news(res1, start='1958-01', end='1958-03', comparison_type='previous')\n    news2 = res2_apply.news(res2, start='1958-01', end='1958-03', comparison_type='previous')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(news1, attr)\n        x = getattr(news2, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)",
            "@pytest.mark.parametrize('idiosyncratic_ar1', [True, False])\ndef test_standardized_MQ(reset_randomstate, idiosyncratic_ar1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nobs = 100\n    idiosyncratic_ar1 = False\n    k1 = 2\n    k2 = 2\n    (endog1_M, endog1_Q, f1) = test_dynamic_factor_mq_monte_carlo.gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = test_dynamic_factor_mq_monte_carlo.gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1, sort=True)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1, sort=True)\n    endog_M1 = endog_M.loc[:'1957-12']\n    endog_Q1 = endog_Q.loc[:'1957Q4']\n    endog_M2 = endog_M.loc['1958-01':]\n    endog_Q2 = endog_Q.loc['1958Q1':]\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    endog_mean = pd.Series(np.random.normal(size=len(factors)), index=factors.keys())\n    endog_std = pd.Series(np.abs(np.random.normal(size=len(factors))), index=factors.keys())\n    mod1 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=(endog_mean, endog_std))\n    params = pd.Series(mod1.start_params, index=mod1.param_names)\n    res1 = mod1.smooth(params)\n    mod2 = dynamic_factor_mq.DynamicFactorMQ(endog_M1, endog_quarterly=endog_Q1, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod2.update(params)\n    mod2['obs_intercept'] = endog_mean\n    mod2['design'] *= np.array(endog_std)[:, None]\n    mod2['obs_cov'] *= np.array(endog_std)[:, None] ** 2\n    mod2.update = lambda params, **kwargs: params\n    res2 = mod2.smooth(params)\n    check_standardized_results(res1, res2)\n    check_append(res1, res2, endog_M2, endog_Q2)\n    check_extend(res1, res2, endog_M2, endog_Q2)\n    check_apply(res1, res2, endog_M, endog_Q)\n    res1_apply = res1.apply(endog_M, endog_quarterly=endog_Q)\n    res2_apply = res2.apply(endog_M, endog_quarterly=endog_Q)\n    mod2_apply = res2_apply.model\n    mod2_apply.update(res2_apply.params)\n    mod2_apply['obs_intercept'] = mod2['obs_intercept']\n    mod2_apply['design'] = mod2['design']\n    mod2_apply['obs_cov'] = mod2['obs_cov']\n    mod2_apply.update = lambda params, **kwargs: params\n    res2_apply = mod2_apply.smooth(res2_apply.params)\n    news1 = res1_apply.news(res1, start='1958-01', end='1958-03', comparison_type='previous')\n    news2 = res2_apply.news(res2, start='1958-01', end='1958-03', comparison_type='previous')\n    attributes = ['total_impacts', 'update_impacts', 'revision_impacts', 'news', 'weights', 'update_forecasts', 'update_realized', 'prev_impacted_forecasts', 'post_impacted_forecasts', 'revisions_iloc', 'revisions_ix', 'updates_iloc', 'updates_ix']\n    for attr in attributes:\n        w = getattr(news1, attr)\n        x = getattr(news2, attr)\n        if isinstance(x, pd.Series):\n            assert_series_equal(w, x)\n        else:\n            assert_frame_equal(w, x)"
        ]
    }
]