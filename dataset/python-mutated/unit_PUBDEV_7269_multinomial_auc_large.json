[
    {
        "func_name": "multinomial_auc_prostate_gbm",
        "original": "def multinomial_auc_prostate_gbm():\n    data = h2o.import_file(pyunit_utils.locate('smalldata/logreg/prostate.csv'))\n    response_col = 'GLEASON'\n    data[response_col] = data[response_col].asfactor()\n    predictors = ['RACE', 'AGE', 'PSA', 'DPROS', 'CAPSULE', 'VOL', 'DCAPS']\n    distribution = 'multinomial'\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='WEIGHTED_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data)\n    gbm.show()\n    cm = gbm.confusion_matrix(data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    print(cm)\n    print(h2o_auc_table.as_data_frame())\n    print(h2o_aucpr_table.as_data_frame())\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_weighted_auc = h2o_auc_table[3][8]\n    h2o_ovo_macro_auc = h2o_auc_table[3][30]\n    h2o_ovo_weighted_auc = h2o_auc_table[3][31]\n    h2o_ovr_weighted_aucpr = h2o_aucpr_table[3][8]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    print('default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' ' + str(h2o_default_auc))\n    print('default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' ' + str(h2o_default_aucpr))\n    assert h2o_ovr_weighted_auc == h2o_default_auc, 'default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' != ' + str(h2o_default_auc)\n    assert h2o_ovr_weighted_aucpr == h2o_default_aucpr, 'default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' != ' + str(h2o_default_aucpr)\n    prediction = gbm.predict(data).as_data_frame().iloc[:, 1:]\n    actual = data[response_col].as_data_frame().iloc[:, 0].tolist()\n    sklearn_ovr_macro_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='macro')\n    sklearn_ovr_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='weighted')\n    sklearn_ovo_macro_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='macro')\n    sklearn_ovo_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='weighted')\n    print('sklearn vs. h2o ovr macro:    ' + str(sklearn_ovr_macro_auc) + ' ' + str(h2o_ovr_macro_auc))\n    print('sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' ' + str(h2o_ovr_weighted_auc))\n    print('sklearn vs. h2o ovo macro:    ' + str(sklearn_ovo_macro_auc) + ' ' + str(h2o_ovo_macro_auc))\n    print('sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' ' + str(h2o_ovo_weighted_auc))\n    precision = 1e-07\n    assert abs(h2o_ovr_macro_auc - sklearn_ovr_macro_auc) < precision, 'sklearn vs. h2o ovr macro: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_ovr_macro_auc)\n    assert abs(h2o_ovr_weighted_auc - sklearn_ovr_weighted_auc) < precision, 'sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' != ' + str(h2o_ovr_weighted_auc)\n    assert abs(h2o_ovo_macro_auc - sklearn_ovo_macro_auc) < precision, 'sklearn vs. h2o ovo macro: ' + str(sklearn_ovo_macro_auc) + ' != ' + str(h2o_ovo_macro_auc)\n    assert abs(h2o_ovo_weighted_auc - sklearn_ovo_weighted_auc) < precision, 'sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' != ' + str(h2o_ovo_weighted_auc)\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='MACRO_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_macro_aucpr = h2o_aucpr_table[3][7]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    assert abs(h2o_ovr_macro_auc - h2o_default_auc) < precision, 'default auc vs. h2o ovr macro auc: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_default_auc)\n    assert abs(h2o_ovr_macro_aucpr - h2o_default_aucpr) < precision, 'default aucpr vs. h2o ovr macro aucpr: ' + str(h2o_ovr_macro_aucpr) + ' != ' + str(h2o_default_aucpr)\n    ntrees = 100\n    gbm2 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution, score_each_iteration=True, auc_type='MACRO_OVR', stopping_metric='AUC', stopping_rounds=3)\n    gbm2.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    assert ntrees > gbm2.score_history().shape[0], 'Test early stopping: Training should start early.'\n    perf2 = gbm.model_performance(data, auc_type='WEIGHTED_OVO')\n    perf2_auc = perf2.auc()\n    assert abs(h2o_ovo_weighted_auc - perf2_auc) < precision, 'h2o ovo weighted vs. h2o performance ovo weighted: ' + str(h2o_ovo_weighted_auc) + ' != ' + str(perf2_auc)\n    ntrees = 2\n    gbm3 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution)\n    gbm3.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    perf3 = gbm3.model_performance(train=True, auc_type='WEIGHTED_OVO')\n    perf3_auc = perf3.auc()\n    assert perf3_auc == 'NaN', 'AUC should be \"NaN\" because it is not set in model parameters and test_data is None'\n    print(gbm._model_json['output']['cv_scoring_history'][0]._col_header)\n    assert not 'aucpr' in gbm.cross_validation_metrics_summary()[0], 'The aucpr should not be in cross-validation metrics summary.'\n    assert 'pr_auc' in gbm.cross_validation_metrics_summary()[0], 'The pr_auc should be in cross-validation metrics summary.'",
        "mutated": [
            "def multinomial_auc_prostate_gbm():\n    if False:\n        i = 10\n    data = h2o.import_file(pyunit_utils.locate('smalldata/logreg/prostate.csv'))\n    response_col = 'GLEASON'\n    data[response_col] = data[response_col].asfactor()\n    predictors = ['RACE', 'AGE', 'PSA', 'DPROS', 'CAPSULE', 'VOL', 'DCAPS']\n    distribution = 'multinomial'\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='WEIGHTED_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data)\n    gbm.show()\n    cm = gbm.confusion_matrix(data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    print(cm)\n    print(h2o_auc_table.as_data_frame())\n    print(h2o_aucpr_table.as_data_frame())\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_weighted_auc = h2o_auc_table[3][8]\n    h2o_ovo_macro_auc = h2o_auc_table[3][30]\n    h2o_ovo_weighted_auc = h2o_auc_table[3][31]\n    h2o_ovr_weighted_aucpr = h2o_aucpr_table[3][8]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    print('default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' ' + str(h2o_default_auc))\n    print('default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' ' + str(h2o_default_aucpr))\n    assert h2o_ovr_weighted_auc == h2o_default_auc, 'default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' != ' + str(h2o_default_auc)\n    assert h2o_ovr_weighted_aucpr == h2o_default_aucpr, 'default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' != ' + str(h2o_default_aucpr)\n    prediction = gbm.predict(data).as_data_frame().iloc[:, 1:]\n    actual = data[response_col].as_data_frame().iloc[:, 0].tolist()\n    sklearn_ovr_macro_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='macro')\n    sklearn_ovr_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='weighted')\n    sklearn_ovo_macro_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='macro')\n    sklearn_ovo_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='weighted')\n    print('sklearn vs. h2o ovr macro:    ' + str(sklearn_ovr_macro_auc) + ' ' + str(h2o_ovr_macro_auc))\n    print('sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' ' + str(h2o_ovr_weighted_auc))\n    print('sklearn vs. h2o ovo macro:    ' + str(sklearn_ovo_macro_auc) + ' ' + str(h2o_ovo_macro_auc))\n    print('sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' ' + str(h2o_ovo_weighted_auc))\n    precision = 1e-07\n    assert abs(h2o_ovr_macro_auc - sklearn_ovr_macro_auc) < precision, 'sklearn vs. h2o ovr macro: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_ovr_macro_auc)\n    assert abs(h2o_ovr_weighted_auc - sklearn_ovr_weighted_auc) < precision, 'sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' != ' + str(h2o_ovr_weighted_auc)\n    assert abs(h2o_ovo_macro_auc - sklearn_ovo_macro_auc) < precision, 'sklearn vs. h2o ovo macro: ' + str(sklearn_ovo_macro_auc) + ' != ' + str(h2o_ovo_macro_auc)\n    assert abs(h2o_ovo_weighted_auc - sklearn_ovo_weighted_auc) < precision, 'sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' != ' + str(h2o_ovo_weighted_auc)\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='MACRO_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_macro_aucpr = h2o_aucpr_table[3][7]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    assert abs(h2o_ovr_macro_auc - h2o_default_auc) < precision, 'default auc vs. h2o ovr macro auc: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_default_auc)\n    assert abs(h2o_ovr_macro_aucpr - h2o_default_aucpr) < precision, 'default aucpr vs. h2o ovr macro aucpr: ' + str(h2o_ovr_macro_aucpr) + ' != ' + str(h2o_default_aucpr)\n    ntrees = 100\n    gbm2 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution, score_each_iteration=True, auc_type='MACRO_OVR', stopping_metric='AUC', stopping_rounds=3)\n    gbm2.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    assert ntrees > gbm2.score_history().shape[0], 'Test early stopping: Training should start early.'\n    perf2 = gbm.model_performance(data, auc_type='WEIGHTED_OVO')\n    perf2_auc = perf2.auc()\n    assert abs(h2o_ovo_weighted_auc - perf2_auc) < precision, 'h2o ovo weighted vs. h2o performance ovo weighted: ' + str(h2o_ovo_weighted_auc) + ' != ' + str(perf2_auc)\n    ntrees = 2\n    gbm3 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution)\n    gbm3.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    perf3 = gbm3.model_performance(train=True, auc_type='WEIGHTED_OVO')\n    perf3_auc = perf3.auc()\n    assert perf3_auc == 'NaN', 'AUC should be \"NaN\" because it is not set in model parameters and test_data is None'\n    print(gbm._model_json['output']['cv_scoring_history'][0]._col_header)\n    assert not 'aucpr' in gbm.cross_validation_metrics_summary()[0], 'The aucpr should not be in cross-validation metrics summary.'\n    assert 'pr_auc' in gbm.cross_validation_metrics_summary()[0], 'The pr_auc should be in cross-validation metrics summary.'",
            "def multinomial_auc_prostate_gbm():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data = h2o.import_file(pyunit_utils.locate('smalldata/logreg/prostate.csv'))\n    response_col = 'GLEASON'\n    data[response_col] = data[response_col].asfactor()\n    predictors = ['RACE', 'AGE', 'PSA', 'DPROS', 'CAPSULE', 'VOL', 'DCAPS']\n    distribution = 'multinomial'\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='WEIGHTED_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data)\n    gbm.show()\n    cm = gbm.confusion_matrix(data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    print(cm)\n    print(h2o_auc_table.as_data_frame())\n    print(h2o_aucpr_table.as_data_frame())\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_weighted_auc = h2o_auc_table[3][8]\n    h2o_ovo_macro_auc = h2o_auc_table[3][30]\n    h2o_ovo_weighted_auc = h2o_auc_table[3][31]\n    h2o_ovr_weighted_aucpr = h2o_aucpr_table[3][8]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    print('default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' ' + str(h2o_default_auc))\n    print('default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' ' + str(h2o_default_aucpr))\n    assert h2o_ovr_weighted_auc == h2o_default_auc, 'default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' != ' + str(h2o_default_auc)\n    assert h2o_ovr_weighted_aucpr == h2o_default_aucpr, 'default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' != ' + str(h2o_default_aucpr)\n    prediction = gbm.predict(data).as_data_frame().iloc[:, 1:]\n    actual = data[response_col].as_data_frame().iloc[:, 0].tolist()\n    sklearn_ovr_macro_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='macro')\n    sklearn_ovr_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='weighted')\n    sklearn_ovo_macro_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='macro')\n    sklearn_ovo_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='weighted')\n    print('sklearn vs. h2o ovr macro:    ' + str(sklearn_ovr_macro_auc) + ' ' + str(h2o_ovr_macro_auc))\n    print('sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' ' + str(h2o_ovr_weighted_auc))\n    print('sklearn vs. h2o ovo macro:    ' + str(sklearn_ovo_macro_auc) + ' ' + str(h2o_ovo_macro_auc))\n    print('sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' ' + str(h2o_ovo_weighted_auc))\n    precision = 1e-07\n    assert abs(h2o_ovr_macro_auc - sklearn_ovr_macro_auc) < precision, 'sklearn vs. h2o ovr macro: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_ovr_macro_auc)\n    assert abs(h2o_ovr_weighted_auc - sklearn_ovr_weighted_auc) < precision, 'sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' != ' + str(h2o_ovr_weighted_auc)\n    assert abs(h2o_ovo_macro_auc - sklearn_ovo_macro_auc) < precision, 'sklearn vs. h2o ovo macro: ' + str(sklearn_ovo_macro_auc) + ' != ' + str(h2o_ovo_macro_auc)\n    assert abs(h2o_ovo_weighted_auc - sklearn_ovo_weighted_auc) < precision, 'sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' != ' + str(h2o_ovo_weighted_auc)\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='MACRO_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_macro_aucpr = h2o_aucpr_table[3][7]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    assert abs(h2o_ovr_macro_auc - h2o_default_auc) < precision, 'default auc vs. h2o ovr macro auc: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_default_auc)\n    assert abs(h2o_ovr_macro_aucpr - h2o_default_aucpr) < precision, 'default aucpr vs. h2o ovr macro aucpr: ' + str(h2o_ovr_macro_aucpr) + ' != ' + str(h2o_default_aucpr)\n    ntrees = 100\n    gbm2 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution, score_each_iteration=True, auc_type='MACRO_OVR', stopping_metric='AUC', stopping_rounds=3)\n    gbm2.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    assert ntrees > gbm2.score_history().shape[0], 'Test early stopping: Training should start early.'\n    perf2 = gbm.model_performance(data, auc_type='WEIGHTED_OVO')\n    perf2_auc = perf2.auc()\n    assert abs(h2o_ovo_weighted_auc - perf2_auc) < precision, 'h2o ovo weighted vs. h2o performance ovo weighted: ' + str(h2o_ovo_weighted_auc) + ' != ' + str(perf2_auc)\n    ntrees = 2\n    gbm3 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution)\n    gbm3.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    perf3 = gbm3.model_performance(train=True, auc_type='WEIGHTED_OVO')\n    perf3_auc = perf3.auc()\n    assert perf3_auc == 'NaN', 'AUC should be \"NaN\" because it is not set in model parameters and test_data is None'\n    print(gbm._model_json['output']['cv_scoring_history'][0]._col_header)\n    assert not 'aucpr' in gbm.cross_validation_metrics_summary()[0], 'The aucpr should not be in cross-validation metrics summary.'\n    assert 'pr_auc' in gbm.cross_validation_metrics_summary()[0], 'The pr_auc should be in cross-validation metrics summary.'",
            "def multinomial_auc_prostate_gbm():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data = h2o.import_file(pyunit_utils.locate('smalldata/logreg/prostate.csv'))\n    response_col = 'GLEASON'\n    data[response_col] = data[response_col].asfactor()\n    predictors = ['RACE', 'AGE', 'PSA', 'DPROS', 'CAPSULE', 'VOL', 'DCAPS']\n    distribution = 'multinomial'\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='WEIGHTED_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data)\n    gbm.show()\n    cm = gbm.confusion_matrix(data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    print(cm)\n    print(h2o_auc_table.as_data_frame())\n    print(h2o_aucpr_table.as_data_frame())\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_weighted_auc = h2o_auc_table[3][8]\n    h2o_ovo_macro_auc = h2o_auc_table[3][30]\n    h2o_ovo_weighted_auc = h2o_auc_table[3][31]\n    h2o_ovr_weighted_aucpr = h2o_aucpr_table[3][8]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    print('default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' ' + str(h2o_default_auc))\n    print('default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' ' + str(h2o_default_aucpr))\n    assert h2o_ovr_weighted_auc == h2o_default_auc, 'default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' != ' + str(h2o_default_auc)\n    assert h2o_ovr_weighted_aucpr == h2o_default_aucpr, 'default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' != ' + str(h2o_default_aucpr)\n    prediction = gbm.predict(data).as_data_frame().iloc[:, 1:]\n    actual = data[response_col].as_data_frame().iloc[:, 0].tolist()\n    sklearn_ovr_macro_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='macro')\n    sklearn_ovr_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='weighted')\n    sklearn_ovo_macro_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='macro')\n    sklearn_ovo_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='weighted')\n    print('sklearn vs. h2o ovr macro:    ' + str(sklearn_ovr_macro_auc) + ' ' + str(h2o_ovr_macro_auc))\n    print('sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' ' + str(h2o_ovr_weighted_auc))\n    print('sklearn vs. h2o ovo macro:    ' + str(sklearn_ovo_macro_auc) + ' ' + str(h2o_ovo_macro_auc))\n    print('sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' ' + str(h2o_ovo_weighted_auc))\n    precision = 1e-07\n    assert abs(h2o_ovr_macro_auc - sklearn_ovr_macro_auc) < precision, 'sklearn vs. h2o ovr macro: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_ovr_macro_auc)\n    assert abs(h2o_ovr_weighted_auc - sklearn_ovr_weighted_auc) < precision, 'sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' != ' + str(h2o_ovr_weighted_auc)\n    assert abs(h2o_ovo_macro_auc - sklearn_ovo_macro_auc) < precision, 'sklearn vs. h2o ovo macro: ' + str(sklearn_ovo_macro_auc) + ' != ' + str(h2o_ovo_macro_auc)\n    assert abs(h2o_ovo_weighted_auc - sklearn_ovo_weighted_auc) < precision, 'sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' != ' + str(h2o_ovo_weighted_auc)\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='MACRO_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_macro_aucpr = h2o_aucpr_table[3][7]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    assert abs(h2o_ovr_macro_auc - h2o_default_auc) < precision, 'default auc vs. h2o ovr macro auc: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_default_auc)\n    assert abs(h2o_ovr_macro_aucpr - h2o_default_aucpr) < precision, 'default aucpr vs. h2o ovr macro aucpr: ' + str(h2o_ovr_macro_aucpr) + ' != ' + str(h2o_default_aucpr)\n    ntrees = 100\n    gbm2 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution, score_each_iteration=True, auc_type='MACRO_OVR', stopping_metric='AUC', stopping_rounds=3)\n    gbm2.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    assert ntrees > gbm2.score_history().shape[0], 'Test early stopping: Training should start early.'\n    perf2 = gbm.model_performance(data, auc_type='WEIGHTED_OVO')\n    perf2_auc = perf2.auc()\n    assert abs(h2o_ovo_weighted_auc - perf2_auc) < precision, 'h2o ovo weighted vs. h2o performance ovo weighted: ' + str(h2o_ovo_weighted_auc) + ' != ' + str(perf2_auc)\n    ntrees = 2\n    gbm3 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution)\n    gbm3.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    perf3 = gbm3.model_performance(train=True, auc_type='WEIGHTED_OVO')\n    perf3_auc = perf3.auc()\n    assert perf3_auc == 'NaN', 'AUC should be \"NaN\" because it is not set in model parameters and test_data is None'\n    print(gbm._model_json['output']['cv_scoring_history'][0]._col_header)\n    assert not 'aucpr' in gbm.cross_validation_metrics_summary()[0], 'The aucpr should not be in cross-validation metrics summary.'\n    assert 'pr_auc' in gbm.cross_validation_metrics_summary()[0], 'The pr_auc should be in cross-validation metrics summary.'",
            "def multinomial_auc_prostate_gbm():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data = h2o.import_file(pyunit_utils.locate('smalldata/logreg/prostate.csv'))\n    response_col = 'GLEASON'\n    data[response_col] = data[response_col].asfactor()\n    predictors = ['RACE', 'AGE', 'PSA', 'DPROS', 'CAPSULE', 'VOL', 'DCAPS']\n    distribution = 'multinomial'\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='WEIGHTED_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data)\n    gbm.show()\n    cm = gbm.confusion_matrix(data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    print(cm)\n    print(h2o_auc_table.as_data_frame())\n    print(h2o_aucpr_table.as_data_frame())\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_weighted_auc = h2o_auc_table[3][8]\n    h2o_ovo_macro_auc = h2o_auc_table[3][30]\n    h2o_ovo_weighted_auc = h2o_auc_table[3][31]\n    h2o_ovr_weighted_aucpr = h2o_aucpr_table[3][8]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    print('default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' ' + str(h2o_default_auc))\n    print('default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' ' + str(h2o_default_aucpr))\n    assert h2o_ovr_weighted_auc == h2o_default_auc, 'default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' != ' + str(h2o_default_auc)\n    assert h2o_ovr_weighted_aucpr == h2o_default_aucpr, 'default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' != ' + str(h2o_default_aucpr)\n    prediction = gbm.predict(data).as_data_frame().iloc[:, 1:]\n    actual = data[response_col].as_data_frame().iloc[:, 0].tolist()\n    sklearn_ovr_macro_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='macro')\n    sklearn_ovr_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='weighted')\n    sklearn_ovo_macro_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='macro')\n    sklearn_ovo_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='weighted')\n    print('sklearn vs. h2o ovr macro:    ' + str(sklearn_ovr_macro_auc) + ' ' + str(h2o_ovr_macro_auc))\n    print('sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' ' + str(h2o_ovr_weighted_auc))\n    print('sklearn vs. h2o ovo macro:    ' + str(sklearn_ovo_macro_auc) + ' ' + str(h2o_ovo_macro_auc))\n    print('sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' ' + str(h2o_ovo_weighted_auc))\n    precision = 1e-07\n    assert abs(h2o_ovr_macro_auc - sklearn_ovr_macro_auc) < precision, 'sklearn vs. h2o ovr macro: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_ovr_macro_auc)\n    assert abs(h2o_ovr_weighted_auc - sklearn_ovr_weighted_auc) < precision, 'sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' != ' + str(h2o_ovr_weighted_auc)\n    assert abs(h2o_ovo_macro_auc - sklearn_ovo_macro_auc) < precision, 'sklearn vs. h2o ovo macro: ' + str(sklearn_ovo_macro_auc) + ' != ' + str(h2o_ovo_macro_auc)\n    assert abs(h2o_ovo_weighted_auc - sklearn_ovo_weighted_auc) < precision, 'sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' != ' + str(h2o_ovo_weighted_auc)\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='MACRO_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_macro_aucpr = h2o_aucpr_table[3][7]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    assert abs(h2o_ovr_macro_auc - h2o_default_auc) < precision, 'default auc vs. h2o ovr macro auc: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_default_auc)\n    assert abs(h2o_ovr_macro_aucpr - h2o_default_aucpr) < precision, 'default aucpr vs. h2o ovr macro aucpr: ' + str(h2o_ovr_macro_aucpr) + ' != ' + str(h2o_default_aucpr)\n    ntrees = 100\n    gbm2 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution, score_each_iteration=True, auc_type='MACRO_OVR', stopping_metric='AUC', stopping_rounds=3)\n    gbm2.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    assert ntrees > gbm2.score_history().shape[0], 'Test early stopping: Training should start early.'\n    perf2 = gbm.model_performance(data, auc_type='WEIGHTED_OVO')\n    perf2_auc = perf2.auc()\n    assert abs(h2o_ovo_weighted_auc - perf2_auc) < precision, 'h2o ovo weighted vs. h2o performance ovo weighted: ' + str(h2o_ovo_weighted_auc) + ' != ' + str(perf2_auc)\n    ntrees = 2\n    gbm3 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution)\n    gbm3.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    perf3 = gbm3.model_performance(train=True, auc_type='WEIGHTED_OVO')\n    perf3_auc = perf3.auc()\n    assert perf3_auc == 'NaN', 'AUC should be \"NaN\" because it is not set in model parameters and test_data is None'\n    print(gbm._model_json['output']['cv_scoring_history'][0]._col_header)\n    assert not 'aucpr' in gbm.cross_validation_metrics_summary()[0], 'The aucpr should not be in cross-validation metrics summary.'\n    assert 'pr_auc' in gbm.cross_validation_metrics_summary()[0], 'The pr_auc should be in cross-validation metrics summary.'",
            "def multinomial_auc_prostate_gbm():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data = h2o.import_file(pyunit_utils.locate('smalldata/logreg/prostate.csv'))\n    response_col = 'GLEASON'\n    data[response_col] = data[response_col].asfactor()\n    predictors = ['RACE', 'AGE', 'PSA', 'DPROS', 'CAPSULE', 'VOL', 'DCAPS']\n    distribution = 'multinomial'\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='WEIGHTED_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data)\n    gbm.show()\n    cm = gbm.confusion_matrix(data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    print(cm)\n    print(h2o_auc_table.as_data_frame())\n    print(h2o_aucpr_table.as_data_frame())\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_weighted_auc = h2o_auc_table[3][8]\n    h2o_ovo_macro_auc = h2o_auc_table[3][30]\n    h2o_ovo_weighted_auc = h2o_auc_table[3][31]\n    h2o_ovr_weighted_aucpr = h2o_aucpr_table[3][8]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    print('default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' ' + str(h2o_default_auc))\n    print('default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' ' + str(h2o_default_aucpr))\n    assert h2o_ovr_weighted_auc == h2o_default_auc, 'default vs. table AUC ' + str(h2o_ovr_weighted_auc) + ' != ' + str(h2o_default_auc)\n    assert h2o_ovr_weighted_aucpr == h2o_default_aucpr, 'default vs. table PR AUC ' + str(h2o_ovr_weighted_aucpr) + ' != ' + str(h2o_default_aucpr)\n    prediction = gbm.predict(data).as_data_frame().iloc[:, 1:]\n    actual = data[response_col].as_data_frame().iloc[:, 0].tolist()\n    sklearn_ovr_macro_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='macro')\n    sklearn_ovr_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovr', average='weighted')\n    sklearn_ovo_macro_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='macro')\n    sklearn_ovo_weighted_auc = roc_auc_score(actual, prediction, multi_class='ovo', average='weighted')\n    print('sklearn vs. h2o ovr macro:    ' + str(sklearn_ovr_macro_auc) + ' ' + str(h2o_ovr_macro_auc))\n    print('sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' ' + str(h2o_ovr_weighted_auc))\n    print('sklearn vs. h2o ovo macro:    ' + str(sklearn_ovo_macro_auc) + ' ' + str(h2o_ovo_macro_auc))\n    print('sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' ' + str(h2o_ovo_weighted_auc))\n    precision = 1e-07\n    assert abs(h2o_ovr_macro_auc - sklearn_ovr_macro_auc) < precision, 'sklearn vs. h2o ovr macro: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_ovr_macro_auc)\n    assert abs(h2o_ovr_weighted_auc - sklearn_ovr_weighted_auc) < precision, 'sklearn vs. h2o ovr weighted: ' + str(sklearn_ovr_weighted_auc) + ' != ' + str(h2o_ovr_weighted_auc)\n    assert abs(h2o_ovo_macro_auc - sklearn_ovo_macro_auc) < precision, 'sklearn vs. h2o ovo macro: ' + str(sklearn_ovo_macro_auc) + ' != ' + str(h2o_ovo_macro_auc)\n    assert abs(h2o_ovo_weighted_auc - sklearn_ovo_weighted_auc) < precision, 'sklearn vs. h2o ovo weighted: ' + str(sklearn_ovo_weighted_auc) + ' != ' + str(h2o_ovo_weighted_auc)\n    gbm = H2OGradientBoostingEstimator(ntrees=1, max_depth=2, nfolds=3, distribution=distribution, auc_type='MACRO_OVR')\n    gbm.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    h2o_auc_table = gbm.multinomial_auc_table(train=True)\n    h2o_aucpr_table = gbm.multinomial_aucpr_table(train=True)\n    h2o_ovr_macro_auc = h2o_auc_table[3][7]\n    h2o_ovr_macro_aucpr = h2o_aucpr_table[3][7]\n    h2o_default_auc = gbm.auc()\n    h2o_default_aucpr = gbm.aucpr()\n    assert abs(h2o_ovr_macro_auc - h2o_default_auc) < precision, 'default auc vs. h2o ovr macro auc: ' + str(sklearn_ovr_macro_auc) + ' != ' + str(h2o_default_auc)\n    assert abs(h2o_ovr_macro_aucpr - h2o_default_aucpr) < precision, 'default aucpr vs. h2o ovr macro aucpr: ' + str(h2o_ovr_macro_aucpr) + ' != ' + str(h2o_default_aucpr)\n    ntrees = 100\n    gbm2 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution, score_each_iteration=True, auc_type='MACRO_OVR', stopping_metric='AUC', stopping_rounds=3)\n    gbm2.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    assert ntrees > gbm2.score_history().shape[0], 'Test early stopping: Training should start early.'\n    perf2 = gbm.model_performance(data, auc_type='WEIGHTED_OVO')\n    perf2_auc = perf2.auc()\n    assert abs(h2o_ovo_weighted_auc - perf2_auc) < precision, 'h2o ovo weighted vs. h2o performance ovo weighted: ' + str(h2o_ovo_weighted_auc) + ' != ' + str(perf2_auc)\n    ntrees = 2\n    gbm3 = H2OGradientBoostingEstimator(ntrees=ntrees, max_depth=2, nfolds=3, distribution=distribution)\n    gbm3.train(x=predictors, y=response_col, training_frame=data, validation_frame=data)\n    perf3 = gbm3.model_performance(train=True, auc_type='WEIGHTED_OVO')\n    perf3_auc = perf3.auc()\n    assert perf3_auc == 'NaN', 'AUC should be \"NaN\" because it is not set in model parameters and test_data is None'\n    print(gbm._model_json['output']['cv_scoring_history'][0]._col_header)\n    assert not 'aucpr' in gbm.cross_validation_metrics_summary()[0], 'The aucpr should not be in cross-validation metrics summary.'\n    assert 'pr_auc' in gbm.cross_validation_metrics_summary()[0], 'The pr_auc should be in cross-validation metrics summary.'"
        ]
    }
]