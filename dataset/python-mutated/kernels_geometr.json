[
    {
        "func_name": "get_motion_kernel2d",
        "original": "def get_motion_kernel2d(kernel_size: int, angle: Tensor | float, direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    \"\"\"Return 2D motion blur filter.\n\n    Args:\n        kernel_size: motion kernel width and height. It should be odd and positive.\n        angle: angle of the motion blur in degrees (anti-clockwise rotation).\n        direction: forward/backward direction of the motion blur.\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\n            uniformly (but still angled) motion blur.\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\n\n    Returns:\n        The motion blur kernel of shape :math:`(B, k_\\\\text{size}, k_\\\\text{size})`.\n\n    Examples:\n        >>> get_motion_kernel2d(5, 0., 0.)\n        tensor([[[0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n                 [0.2000, 0.2000, 0.2000, 0.2000, 0.2000],\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]])\n\n        >>> get_motion_kernel2d(3, 215., -0.5)\n        tensor([[[0.0000, 0.0000, 0.1667],\n                 [0.0000, 0.3333, 0.0000],\n                 [0.5000, 0.0000, 0.0000]]])\n    \"\"\"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_2d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 0:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same length. Got {direction} and {angle}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None], [0, 0, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate(kernel, angle, mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2), keepdim=True)\n    return kernel",
        "mutated": [
            "def get_motion_kernel2d(kernel_size: int, angle: Tensor | float, direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n    \"Return 2D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width and height. It should be odd and positive.\\n        angle: angle of the motion blur in degrees (anti-clockwise rotation).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel of shape :math:`(B, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel2d(5, 0., 0.)\\n        tensor([[[0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.2000, 0.2000, 0.2000, 0.2000, 0.2000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]])\\n\\n        >>> get_motion_kernel2d(3, 215., -0.5)\\n        tensor([[[0.0000, 0.0000, 0.1667],\\n                 [0.0000, 0.3333, 0.0000],\\n                 [0.5000, 0.0000, 0.0000]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_2d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 0:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same length. Got {direction} and {angle}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None], [0, 0, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate(kernel, angle, mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2), keepdim=True)\n    return kernel",
            "def get_motion_kernel2d(kernel_size: int, angle: Tensor | float, direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return 2D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width and height. It should be odd and positive.\\n        angle: angle of the motion blur in degrees (anti-clockwise rotation).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel of shape :math:`(B, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel2d(5, 0., 0.)\\n        tensor([[[0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.2000, 0.2000, 0.2000, 0.2000, 0.2000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]])\\n\\n        >>> get_motion_kernel2d(3, 215., -0.5)\\n        tensor([[[0.0000, 0.0000, 0.1667],\\n                 [0.0000, 0.3333, 0.0000],\\n                 [0.5000, 0.0000, 0.0000]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_2d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 0:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same length. Got {direction} and {angle}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None], [0, 0, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate(kernel, angle, mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2), keepdim=True)\n    return kernel",
            "def get_motion_kernel2d(kernel_size: int, angle: Tensor | float, direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return 2D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width and height. It should be odd and positive.\\n        angle: angle of the motion blur in degrees (anti-clockwise rotation).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel of shape :math:`(B, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel2d(5, 0., 0.)\\n        tensor([[[0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.2000, 0.2000, 0.2000, 0.2000, 0.2000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]])\\n\\n        >>> get_motion_kernel2d(3, 215., -0.5)\\n        tensor([[[0.0000, 0.0000, 0.1667],\\n                 [0.0000, 0.3333, 0.0000],\\n                 [0.5000, 0.0000, 0.0000]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_2d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 0:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same length. Got {direction} and {angle}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None], [0, 0, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate(kernel, angle, mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2), keepdim=True)\n    return kernel",
            "def get_motion_kernel2d(kernel_size: int, angle: Tensor | float, direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return 2D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width and height. It should be odd and positive.\\n        angle: angle of the motion blur in degrees (anti-clockwise rotation).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel of shape :math:`(B, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel2d(5, 0., 0.)\\n        tensor([[[0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.2000, 0.2000, 0.2000, 0.2000, 0.2000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]])\\n\\n        >>> get_motion_kernel2d(3, 215., -0.5)\\n        tensor([[[0.0000, 0.0000, 0.1667],\\n                 [0.0000, 0.3333, 0.0000],\\n                 [0.5000, 0.0000, 0.0000]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_2d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 0:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same length. Got {direction} and {angle}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None], [0, 0, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate(kernel, angle, mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2), keepdim=True)\n    return kernel",
            "def get_motion_kernel2d(kernel_size: int, angle: Tensor | float, direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return 2D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width and height. It should be odd and positive.\\n        angle: angle of the motion blur in degrees (anti-clockwise rotation).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel of shape :math:`(B, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel2d(5, 0., 0.)\\n        tensor([[[0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.2000, 0.2000, 0.2000, 0.2000, 0.2000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\\n                 [0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]])\\n\\n        >>> get_motion_kernel2d(3, 215., -0.5)\\n        tensor([[[0.0000, 0.0000, 0.1667],\\n                 [0.0000, 0.3333, 0.0000],\\n                 [0.5000, 0.0000, 0.0000]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_2d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 0:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same length. Got {direction} and {angle}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None], [0, 0, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate(kernel, angle, mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2), keepdim=True)\n    return kernel"
        ]
    },
    {
        "func_name": "get_motion_kernel3d",
        "original": "def get_motion_kernel3d(kernel_size: int, angle: Tensor | tuple[float, float, float], direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    \"\"\"Return 3D motion blur filter.\n\n    Args:\n        kernel_size: motion kernel width, height and depth. It should be odd and positive.\n        angle: Range of yaw (x-axis), pitch (y-axis), roll (z-axis) to select from.\n            If tensor, it must be :math:`(B, 3)`.\n            If tuple, it must be (yaw, pitch, raw).\n        direction: forward/backward direction of the motion blur.\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\n            uniformly (but still angled) motion blur.\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\n\n    Returns:\n        The motion blur kernel with shape :math:`(B, k_\\\\text{size}, k_\\\\text{size}, k_\\\\text{size})`.\n\n    Examples:\n        >>> get_motion_kernel3d(3, (0., 0., 0.), 0.)\n        tensor([[[[0.0000, 0.0000, 0.0000],\n                  [0.0000, 0.0000, 0.0000],\n                  [0.0000, 0.0000, 0.0000]],\n        <BLANKLINE>\n                 [[0.0000, 0.0000, 0.0000],\n                  [0.3333, 0.3333, 0.3333],\n                  [0.0000, 0.0000, 0.0000]],\n        <BLANKLINE>\n                 [[0.0000, 0.0000, 0.0000],\n                  [0.0000, 0.0000, 0.0000],\n                  [0.0000, 0.0000, 0.0000]]]])\n\n        >>> get_motion_kernel3d(3, (90., 90., 0.), -0.5)\n        tensor([[[[0.0000, 0.0000, 0.0000],\n                  [0.0000, 0.0000, 0.0000],\n                  [0.0000, 0.5000, 0.0000]],\n        <BLANKLINE>\n                 [[0.0000, 0.0000, 0.0000],\n                  [0.0000, 0.3333, 0.0000],\n                  [0.0000, 0.0000, 0.0000]],\n        <BLANKLINE>\n                 [[0.0000, 0.1667, 0.0000],\n                  [0.0000, 0.0000, 0.0000],\n                  [0.0000, 0.0000, 0.0000]]]])\n    \"\"\"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_3d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 1:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B', '3'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same batch size. Got {direction.shape} and {angle.shape}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    kernel = zeros((direction.size(0), *kernel_tuple), device=device, dtype=dtype)\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None, None], [0, 0, kernel_size // 2, kernel_size // 2, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate3d(kernel, angle[:, 0], angle[:, 1], angle[:, 2], mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2, 3), keepdim=True)\n    return kernel",
        "mutated": [
            "def get_motion_kernel3d(kernel_size: int, angle: Tensor | tuple[float, float, float], direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n    \"Return 3D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width, height and depth. It should be odd and positive.\\n        angle: Range of yaw (x-axis), pitch (y-axis), roll (z-axis) to select from.\\n            If tensor, it must be :math:`(B, 3)`.\\n            If tuple, it must be (yaw, pitch, raw).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel with shape :math:`(B, k_\\\\text{size}, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel3d(3, (0., 0., 0.), 0.)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.3333, 0.3333, 0.3333],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n\\n        >>> get_motion_kernel3d(3, (90., 90., 0.), -0.5)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.5000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.3333, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.1667, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_3d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 1:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B', '3'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same batch size. Got {direction.shape} and {angle.shape}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    kernel = zeros((direction.size(0), *kernel_tuple), device=device, dtype=dtype)\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None, None], [0, 0, kernel_size // 2, kernel_size // 2, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate3d(kernel, angle[:, 0], angle[:, 1], angle[:, 2], mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2, 3), keepdim=True)\n    return kernel",
            "def get_motion_kernel3d(kernel_size: int, angle: Tensor | tuple[float, float, float], direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return 3D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width, height and depth. It should be odd and positive.\\n        angle: Range of yaw (x-axis), pitch (y-axis), roll (z-axis) to select from.\\n            If tensor, it must be :math:`(B, 3)`.\\n            If tuple, it must be (yaw, pitch, raw).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel with shape :math:`(B, k_\\\\text{size}, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel3d(3, (0., 0., 0.), 0.)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.3333, 0.3333, 0.3333],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n\\n        >>> get_motion_kernel3d(3, (90., 90., 0.), -0.5)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.5000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.3333, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.1667, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_3d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 1:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B', '3'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same batch size. Got {direction.shape} and {angle.shape}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    kernel = zeros((direction.size(0), *kernel_tuple), device=device, dtype=dtype)\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None, None], [0, 0, kernel_size // 2, kernel_size // 2, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate3d(kernel, angle[:, 0], angle[:, 1], angle[:, 2], mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2, 3), keepdim=True)\n    return kernel",
            "def get_motion_kernel3d(kernel_size: int, angle: Tensor | tuple[float, float, float], direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return 3D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width, height and depth. It should be odd and positive.\\n        angle: Range of yaw (x-axis), pitch (y-axis), roll (z-axis) to select from.\\n            If tensor, it must be :math:`(B, 3)`.\\n            If tuple, it must be (yaw, pitch, raw).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel with shape :math:`(B, k_\\\\text{size}, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel3d(3, (0., 0., 0.), 0.)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.3333, 0.3333, 0.3333],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n\\n        >>> get_motion_kernel3d(3, (90., 90., 0.), -0.5)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.5000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.3333, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.1667, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_3d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 1:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B', '3'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same batch size. Got {direction.shape} and {angle.shape}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    kernel = zeros((direction.size(0), *kernel_tuple), device=device, dtype=dtype)\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None, None], [0, 0, kernel_size // 2, kernel_size // 2, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate3d(kernel, angle[:, 0], angle[:, 1], angle[:, 2], mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2, 3), keepdim=True)\n    return kernel",
            "def get_motion_kernel3d(kernel_size: int, angle: Tensor | tuple[float, float, float], direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return 3D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width, height and depth. It should be odd and positive.\\n        angle: Range of yaw (x-axis), pitch (y-axis), roll (z-axis) to select from.\\n            If tensor, it must be :math:`(B, 3)`.\\n            If tuple, it must be (yaw, pitch, raw).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel with shape :math:`(B, k_\\\\text{size}, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel3d(3, (0., 0., 0.), 0.)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.3333, 0.3333, 0.3333],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n\\n        >>> get_motion_kernel3d(3, (90., 90., 0.), -0.5)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.5000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.3333, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.1667, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_3d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 1:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B', '3'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same batch size. Got {direction.shape} and {angle.shape}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    kernel = zeros((direction.size(0), *kernel_tuple), device=device, dtype=dtype)\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None, None], [0, 0, kernel_size // 2, kernel_size // 2, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate3d(kernel, angle[:, 0], angle[:, 1], angle[:, 2], mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2, 3), keepdim=True)\n    return kernel",
            "def get_motion_kernel3d(kernel_size: int, angle: Tensor | tuple[float, float, float], direction: Tensor | float=0.0, mode: str='nearest') -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return 3D motion blur filter.\\n\\n    Args:\\n        kernel_size: motion kernel width, height and depth. It should be odd and positive.\\n        angle: Range of yaw (x-axis), pitch (y-axis), roll (z-axis) to select from.\\n            If tensor, it must be :math:`(B, 3)`.\\n            If tuple, it must be (yaw, pitch, raw).\\n        direction: forward/backward direction of the motion blur.\\n            Lower values towards -1.0 will point the motion blur towards the back (with angle provided via angle),\\n            while higher values towards 1.0 will point the motion blur forward. A value of 0.0 leads to a\\n            uniformly (but still angled) motion blur.\\n        mode: interpolation mode for rotating the kernel. ``'bilinear'`` or ``'nearest'``.\\n\\n    Returns:\\n        The motion blur kernel with shape :math:`(B, k_\\\\text{size}, k_\\\\text{size}, k_\\\\text{size})`.\\n\\n    Examples:\\n        >>> get_motion_kernel3d(3, (0., 0., 0.), 0.)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.3333, 0.3333, 0.3333],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n\\n        >>> get_motion_kernel3d(3, (90., 90., 0.), -0.5)\\n        tensor([[[[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.5000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.3333, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]],\\n        <BLANKLINE>\\n                 [[0.0000, 0.1667, 0.0000],\\n                  [0.0000, 0.0000, 0.0000],\\n                  [0.0000, 0.0000, 0.0000]]]])\\n    \"\n    (device, dtype) = _extract_device_dtype([angle if isinstance(angle, Tensor) else None, direction if isinstance(direction, Tensor) else None])\n    kernel_tuple = _unpack_3d_ks(kernel_size)\n    _check_kernel_size(kernel_size, 2)\n    if not isinstance(angle, Tensor):\n        angle = tensor([angle], device=device, dtype=dtype)\n    if angle.dim() == 1:\n        angle = angle[None]\n    KORNIA_CHECK_SHAPE(angle, ['B', '3'])\n    if not isinstance(direction, Tensor):\n        direction = tensor([direction], device=device, dtype=dtype)\n    if direction.dim() == 0:\n        direction = direction[None]\n    KORNIA_CHECK_SHAPE(direction, ['B'])\n    KORNIA_CHECK(direction.size(0) == angle.size(0), f'direction and angle must have the same batch size. Got {direction.shape} and {angle.shape}.')\n    direction = (torch.clamp(direction, -1.0, 1.0) + 1.0) / 2.0\n    kernel = zeros((direction.size(0), *kernel_tuple), device=device, dtype=dtype)\n    k = stack([direction + (1 - 2 * direction) / (kernel_size - 1) * i for i in range(kernel_size)], -1)\n    kernel = pad(k[:, None, None], [0, 0, kernel_size // 2, kernel_size // 2, kernel_size // 2, kernel_size // 2, 0, 0])\n    expected_shape = torch.Size([direction.size(0), *kernel_tuple])\n    KORNIA_CHECK(kernel.shape == expected_shape, f'Kernel shape should be {expected_shape}. Gotcha {kernel.shape}')\n    kernel = kernel[:, None, ...]\n    kernel = rotate3d(kernel, angle[:, 0], angle[:, 1], angle[:, 2], mode=mode, align_corners=True)\n    kernel = kernel[:, 0]\n    kernel = kernel / kernel.sum(dim=(1, 2, 3), keepdim=True)\n    return kernel"
        ]
    }
]