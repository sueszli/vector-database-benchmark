[
    {
        "func_name": "__init__",
        "original": "def __init__(self, bbox_head, point_roi_extractor, train_cfg, test_cfg, depth_normalizer=70.0, pretrained=None, init_cfg=None):\n    super(PointRCNNRoIHead, self).__init__(bbox_head=bbox_head, train_cfg=train_cfg, test_cfg=test_cfg, pretrained=pretrained, init_cfg=init_cfg)\n    self.depth_normalizer = depth_normalizer\n    if point_roi_extractor is not None:\n        self.point_roi_extractor = build_roi_extractor(point_roi_extractor)\n    self.init_assigner_sampler()",
        "mutated": [
            "def __init__(self, bbox_head, point_roi_extractor, train_cfg, test_cfg, depth_normalizer=70.0, pretrained=None, init_cfg=None):\n    if False:\n        i = 10\n    super(PointRCNNRoIHead, self).__init__(bbox_head=bbox_head, train_cfg=train_cfg, test_cfg=test_cfg, pretrained=pretrained, init_cfg=init_cfg)\n    self.depth_normalizer = depth_normalizer\n    if point_roi_extractor is not None:\n        self.point_roi_extractor = build_roi_extractor(point_roi_extractor)\n    self.init_assigner_sampler()",
            "def __init__(self, bbox_head, point_roi_extractor, train_cfg, test_cfg, depth_normalizer=70.0, pretrained=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(PointRCNNRoIHead, self).__init__(bbox_head=bbox_head, train_cfg=train_cfg, test_cfg=test_cfg, pretrained=pretrained, init_cfg=init_cfg)\n    self.depth_normalizer = depth_normalizer\n    if point_roi_extractor is not None:\n        self.point_roi_extractor = build_roi_extractor(point_roi_extractor)\n    self.init_assigner_sampler()",
            "def __init__(self, bbox_head, point_roi_extractor, train_cfg, test_cfg, depth_normalizer=70.0, pretrained=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(PointRCNNRoIHead, self).__init__(bbox_head=bbox_head, train_cfg=train_cfg, test_cfg=test_cfg, pretrained=pretrained, init_cfg=init_cfg)\n    self.depth_normalizer = depth_normalizer\n    if point_roi_extractor is not None:\n        self.point_roi_extractor = build_roi_extractor(point_roi_extractor)\n    self.init_assigner_sampler()",
            "def __init__(self, bbox_head, point_roi_extractor, train_cfg, test_cfg, depth_normalizer=70.0, pretrained=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(PointRCNNRoIHead, self).__init__(bbox_head=bbox_head, train_cfg=train_cfg, test_cfg=test_cfg, pretrained=pretrained, init_cfg=init_cfg)\n    self.depth_normalizer = depth_normalizer\n    if point_roi_extractor is not None:\n        self.point_roi_extractor = build_roi_extractor(point_roi_extractor)\n    self.init_assigner_sampler()",
            "def __init__(self, bbox_head, point_roi_extractor, train_cfg, test_cfg, depth_normalizer=70.0, pretrained=None, init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(PointRCNNRoIHead, self).__init__(bbox_head=bbox_head, train_cfg=train_cfg, test_cfg=test_cfg, pretrained=pretrained, init_cfg=init_cfg)\n    self.depth_normalizer = depth_normalizer\n    if point_roi_extractor is not None:\n        self.point_roi_extractor = build_roi_extractor(point_roi_extractor)\n    self.init_assigner_sampler()"
        ]
    },
    {
        "func_name": "init_bbox_head",
        "original": "def init_bbox_head(self, bbox_head):\n    \"\"\"Initialize box head.\n\n        Args:\n            bbox_head (dict): Config dict of RoI Head.\n        \"\"\"\n    self.bbox_head = build_head(bbox_head)",
        "mutated": [
            "def init_bbox_head(self, bbox_head):\n    if False:\n        i = 10\n    'Initialize box head.\\n\\n        Args:\\n            bbox_head (dict): Config dict of RoI Head.\\n        '\n    self.bbox_head = build_head(bbox_head)",
            "def init_bbox_head(self, bbox_head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize box head.\\n\\n        Args:\\n            bbox_head (dict): Config dict of RoI Head.\\n        '\n    self.bbox_head = build_head(bbox_head)",
            "def init_bbox_head(self, bbox_head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize box head.\\n\\n        Args:\\n            bbox_head (dict): Config dict of RoI Head.\\n        '\n    self.bbox_head = build_head(bbox_head)",
            "def init_bbox_head(self, bbox_head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize box head.\\n\\n        Args:\\n            bbox_head (dict): Config dict of RoI Head.\\n        '\n    self.bbox_head = build_head(bbox_head)",
            "def init_bbox_head(self, bbox_head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize box head.\\n\\n        Args:\\n            bbox_head (dict): Config dict of RoI Head.\\n        '\n    self.bbox_head = build_head(bbox_head)"
        ]
    },
    {
        "func_name": "init_mask_head",
        "original": "def init_mask_head(self):\n    \"\"\"Initialize maek head.\"\"\"\n    pass",
        "mutated": [
            "def init_mask_head(self):\n    if False:\n        i = 10\n    'Initialize maek head.'\n    pass",
            "def init_mask_head(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize maek head.'\n    pass",
            "def init_mask_head(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize maek head.'\n    pass",
            "def init_mask_head(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize maek head.'\n    pass",
            "def init_mask_head(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize maek head.'\n    pass"
        ]
    },
    {
        "func_name": "init_assigner_sampler",
        "original": "def init_assigner_sampler(self):\n    \"\"\"Initialize assigner and sampler.\"\"\"\n    self.bbox_assigner = None\n    self.bbox_sampler = None\n    if self.train_cfg:\n        if isinstance(self.train_cfg.assigner, dict):\n            self.bbox_assigner = build_assigner(self.train_cfg.assigner)\n        elif isinstance(self.train_cfg.assigner, list):\n            self.bbox_assigner = [build_assigner(res) for res in self.train_cfg.assigner]\n        self.bbox_sampler = build_sampler(self.train_cfg.sampler)",
        "mutated": [
            "def init_assigner_sampler(self):\n    if False:\n        i = 10\n    'Initialize assigner and sampler.'\n    self.bbox_assigner = None\n    self.bbox_sampler = None\n    if self.train_cfg:\n        if isinstance(self.train_cfg.assigner, dict):\n            self.bbox_assigner = build_assigner(self.train_cfg.assigner)\n        elif isinstance(self.train_cfg.assigner, list):\n            self.bbox_assigner = [build_assigner(res) for res in self.train_cfg.assigner]\n        self.bbox_sampler = build_sampler(self.train_cfg.sampler)",
            "def init_assigner_sampler(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize assigner and sampler.'\n    self.bbox_assigner = None\n    self.bbox_sampler = None\n    if self.train_cfg:\n        if isinstance(self.train_cfg.assigner, dict):\n            self.bbox_assigner = build_assigner(self.train_cfg.assigner)\n        elif isinstance(self.train_cfg.assigner, list):\n            self.bbox_assigner = [build_assigner(res) for res in self.train_cfg.assigner]\n        self.bbox_sampler = build_sampler(self.train_cfg.sampler)",
            "def init_assigner_sampler(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize assigner and sampler.'\n    self.bbox_assigner = None\n    self.bbox_sampler = None\n    if self.train_cfg:\n        if isinstance(self.train_cfg.assigner, dict):\n            self.bbox_assigner = build_assigner(self.train_cfg.assigner)\n        elif isinstance(self.train_cfg.assigner, list):\n            self.bbox_assigner = [build_assigner(res) for res in self.train_cfg.assigner]\n        self.bbox_sampler = build_sampler(self.train_cfg.sampler)",
            "def init_assigner_sampler(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize assigner and sampler.'\n    self.bbox_assigner = None\n    self.bbox_sampler = None\n    if self.train_cfg:\n        if isinstance(self.train_cfg.assigner, dict):\n            self.bbox_assigner = build_assigner(self.train_cfg.assigner)\n        elif isinstance(self.train_cfg.assigner, list):\n            self.bbox_assigner = [build_assigner(res) for res in self.train_cfg.assigner]\n        self.bbox_sampler = build_sampler(self.train_cfg.sampler)",
            "def init_assigner_sampler(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize assigner and sampler.'\n    self.bbox_assigner = None\n    self.bbox_sampler = None\n    if self.train_cfg:\n        if isinstance(self.train_cfg.assigner, dict):\n            self.bbox_assigner = build_assigner(self.train_cfg.assigner)\n        elif isinstance(self.train_cfg.assigner, list):\n            self.bbox_assigner = [build_assigner(res) for res in self.train_cfg.assigner]\n        self.bbox_sampler = build_sampler(self.train_cfg.sampler)"
        ]
    },
    {
        "func_name": "forward_train",
        "original": "def forward_train(self, feats_dict, input_metas, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    \"\"\"Training forward function of PointRCNNRoIHead.\n\n        Args:\n            feats_dict (dict): Contains features from the first stage.\n            imput_metas (list[dict]): Meta info of each input.\n            proposal_list (list[dict]): Proposal information from rpn.\n                The dictionary should contain the following keys:\n\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Proposal bboxes\n                - labels_3d (torch.Tensor): Labels of proposals\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]):\n                GT bboxes of each sample. The bboxes are encapsulated\n                by 3D box structures.\n            gt_labels_3d (list[LongTensor]): GT labels of each sample.\n\n        Returns:\n            dict: Losses from RoI RCNN head.\n                - loss_bbox (torch.Tensor): Loss of bboxes\n        \"\"\"\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    sample_results = self._assign_and_sample(proposal_list, gt_bboxes_3d, gt_labels_3d)\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    bbox_results = self._bbox_forward_train(features, points, sample_results)\n    losses = dict()\n    losses.update(bbox_results['loss_bbox'])\n    return losses",
        "mutated": [
            "def forward_train(self, feats_dict, input_metas, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n    'Training forward function of PointRCNNRoIHead.\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            imput_metas (list[dict]): Meta info of each input.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n                The dictionary should contain the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Proposal bboxes\\n                - labels_3d (torch.Tensor): Labels of proposals\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]):\\n                GT bboxes of each sample. The bboxes are encapsulated\\n                by 3D box structures.\\n            gt_labels_3d (list[LongTensor]): GT labels of each sample.\\n\\n        Returns:\\n            dict: Losses from RoI RCNN head.\\n                - loss_bbox (torch.Tensor): Loss of bboxes\\n        '\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    sample_results = self._assign_and_sample(proposal_list, gt_bboxes_3d, gt_labels_3d)\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    bbox_results = self._bbox_forward_train(features, points, sample_results)\n    losses = dict()\n    losses.update(bbox_results['loss_bbox'])\n    return losses",
            "def forward_train(self, feats_dict, input_metas, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Training forward function of PointRCNNRoIHead.\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            imput_metas (list[dict]): Meta info of each input.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n                The dictionary should contain the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Proposal bboxes\\n                - labels_3d (torch.Tensor): Labels of proposals\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]):\\n                GT bboxes of each sample. The bboxes are encapsulated\\n                by 3D box structures.\\n            gt_labels_3d (list[LongTensor]): GT labels of each sample.\\n\\n        Returns:\\n            dict: Losses from RoI RCNN head.\\n                - loss_bbox (torch.Tensor): Loss of bboxes\\n        '\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    sample_results = self._assign_and_sample(proposal_list, gt_bboxes_3d, gt_labels_3d)\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    bbox_results = self._bbox_forward_train(features, points, sample_results)\n    losses = dict()\n    losses.update(bbox_results['loss_bbox'])\n    return losses",
            "def forward_train(self, feats_dict, input_metas, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Training forward function of PointRCNNRoIHead.\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            imput_metas (list[dict]): Meta info of each input.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n                The dictionary should contain the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Proposal bboxes\\n                - labels_3d (torch.Tensor): Labels of proposals\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]):\\n                GT bboxes of each sample. The bboxes are encapsulated\\n                by 3D box structures.\\n            gt_labels_3d (list[LongTensor]): GT labels of each sample.\\n\\n        Returns:\\n            dict: Losses from RoI RCNN head.\\n                - loss_bbox (torch.Tensor): Loss of bboxes\\n        '\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    sample_results = self._assign_and_sample(proposal_list, gt_bboxes_3d, gt_labels_3d)\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    bbox_results = self._bbox_forward_train(features, points, sample_results)\n    losses = dict()\n    losses.update(bbox_results['loss_bbox'])\n    return losses",
            "def forward_train(self, feats_dict, input_metas, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Training forward function of PointRCNNRoIHead.\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            imput_metas (list[dict]): Meta info of each input.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n                The dictionary should contain the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Proposal bboxes\\n                - labels_3d (torch.Tensor): Labels of proposals\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]):\\n                GT bboxes of each sample. The bboxes are encapsulated\\n                by 3D box structures.\\n            gt_labels_3d (list[LongTensor]): GT labels of each sample.\\n\\n        Returns:\\n            dict: Losses from RoI RCNN head.\\n                - loss_bbox (torch.Tensor): Loss of bboxes\\n        '\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    sample_results = self._assign_and_sample(proposal_list, gt_bboxes_3d, gt_labels_3d)\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    bbox_results = self._bbox_forward_train(features, points, sample_results)\n    losses = dict()\n    losses.update(bbox_results['loss_bbox'])\n    return losses",
            "def forward_train(self, feats_dict, input_metas, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Training forward function of PointRCNNRoIHead.\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            imput_metas (list[dict]): Meta info of each input.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n                The dictionary should contain the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Proposal bboxes\\n                - labels_3d (torch.Tensor): Labels of proposals\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]):\\n                GT bboxes of each sample. The bboxes are encapsulated\\n                by 3D box structures.\\n            gt_labels_3d (list[LongTensor]): GT labels of each sample.\\n\\n        Returns:\\n            dict: Losses from RoI RCNN head.\\n                - loss_bbox (torch.Tensor): Loss of bboxes\\n        '\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    sample_results = self._assign_and_sample(proposal_list, gt_bboxes_3d, gt_labels_3d)\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    bbox_results = self._bbox_forward_train(features, points, sample_results)\n    losses = dict()\n    losses.update(bbox_results['loss_bbox'])\n    return losses"
        ]
    },
    {
        "func_name": "simple_test",
        "original": "def simple_test(self, feats_dict, img_metas, proposal_list, **kwargs):\n    \"\"\"Simple testing forward function of PointRCNNRoIHead.\n\n        Note:\n            This function assumes that the batch size is 1\n\n        Args:\n            feats_dict (dict): Contains features from the first stage.\n            img_metas (list[dict]): Meta info of each image.\n            proposal_list (list[dict]): Proposal information from rpn.\n\n        Returns:\n            dict: Bbox results of one frame.\n        \"\"\"\n    rois = bbox3d2roi([res['boxes_3d'].tensor for res in proposal_list])\n    labels_3d = [res['labels_3d'] for res in proposal_list]\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    object_score = bbox_results['cls_score'].sigmoid()\n    bbox_list = self.bbox_head.get_bboxes(rois, object_score, bbox_results['bbox_pred'], labels_3d, img_metas, cfg=self.test_cfg)\n    bbox_results = [bbox3d2result(bboxes, scores, labels) for (bboxes, scores, labels) in bbox_list]\n    return bbox_results",
        "mutated": [
            "def simple_test(self, feats_dict, img_metas, proposal_list, **kwargs):\n    if False:\n        i = 10\n    'Simple testing forward function of PointRCNNRoIHead.\\n\\n        Note:\\n            This function assumes that the batch size is 1\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            img_metas (list[dict]): Meta info of each image.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n\\n        Returns:\\n            dict: Bbox results of one frame.\\n        '\n    rois = bbox3d2roi([res['boxes_3d'].tensor for res in proposal_list])\n    labels_3d = [res['labels_3d'] for res in proposal_list]\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    object_score = bbox_results['cls_score'].sigmoid()\n    bbox_list = self.bbox_head.get_bboxes(rois, object_score, bbox_results['bbox_pred'], labels_3d, img_metas, cfg=self.test_cfg)\n    bbox_results = [bbox3d2result(bboxes, scores, labels) for (bboxes, scores, labels) in bbox_list]\n    return bbox_results",
            "def simple_test(self, feats_dict, img_metas, proposal_list, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Simple testing forward function of PointRCNNRoIHead.\\n\\n        Note:\\n            This function assumes that the batch size is 1\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            img_metas (list[dict]): Meta info of each image.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n\\n        Returns:\\n            dict: Bbox results of one frame.\\n        '\n    rois = bbox3d2roi([res['boxes_3d'].tensor for res in proposal_list])\n    labels_3d = [res['labels_3d'] for res in proposal_list]\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    object_score = bbox_results['cls_score'].sigmoid()\n    bbox_list = self.bbox_head.get_bboxes(rois, object_score, bbox_results['bbox_pred'], labels_3d, img_metas, cfg=self.test_cfg)\n    bbox_results = [bbox3d2result(bboxes, scores, labels) for (bboxes, scores, labels) in bbox_list]\n    return bbox_results",
            "def simple_test(self, feats_dict, img_metas, proposal_list, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Simple testing forward function of PointRCNNRoIHead.\\n\\n        Note:\\n            This function assumes that the batch size is 1\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            img_metas (list[dict]): Meta info of each image.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n\\n        Returns:\\n            dict: Bbox results of one frame.\\n        '\n    rois = bbox3d2roi([res['boxes_3d'].tensor for res in proposal_list])\n    labels_3d = [res['labels_3d'] for res in proposal_list]\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    object_score = bbox_results['cls_score'].sigmoid()\n    bbox_list = self.bbox_head.get_bboxes(rois, object_score, bbox_results['bbox_pred'], labels_3d, img_metas, cfg=self.test_cfg)\n    bbox_results = [bbox3d2result(bboxes, scores, labels) for (bboxes, scores, labels) in bbox_list]\n    return bbox_results",
            "def simple_test(self, feats_dict, img_metas, proposal_list, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Simple testing forward function of PointRCNNRoIHead.\\n\\n        Note:\\n            This function assumes that the batch size is 1\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            img_metas (list[dict]): Meta info of each image.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n\\n        Returns:\\n            dict: Bbox results of one frame.\\n        '\n    rois = bbox3d2roi([res['boxes_3d'].tensor for res in proposal_list])\n    labels_3d = [res['labels_3d'] for res in proposal_list]\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    object_score = bbox_results['cls_score'].sigmoid()\n    bbox_list = self.bbox_head.get_bboxes(rois, object_score, bbox_results['bbox_pred'], labels_3d, img_metas, cfg=self.test_cfg)\n    bbox_results = [bbox3d2result(bboxes, scores, labels) for (bboxes, scores, labels) in bbox_list]\n    return bbox_results",
            "def simple_test(self, feats_dict, img_metas, proposal_list, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Simple testing forward function of PointRCNNRoIHead.\\n\\n        Note:\\n            This function assumes that the batch size is 1\\n\\n        Args:\\n            feats_dict (dict): Contains features from the first stage.\\n            img_metas (list[dict]): Meta info of each image.\\n            proposal_list (list[dict]): Proposal information from rpn.\\n\\n        Returns:\\n            dict: Bbox results of one frame.\\n        '\n    rois = bbox3d2roi([res['boxes_3d'].tensor for res in proposal_list])\n    labels_3d = [res['labels_3d'] for res in proposal_list]\n    features = feats_dict['features']\n    points = feats_dict['points']\n    point_cls_preds = feats_dict['points_cls_preds']\n    sem_scores = point_cls_preds.sigmoid()\n    point_scores = sem_scores.max(-1)[0]\n    features = features.transpose(1, 2).contiguous()\n    point_depths = points.norm(dim=2) / self.depth_normalizer - 0.5\n    features_list = [point_scores.unsqueeze(2), point_depths.unsqueeze(2), features]\n    features = torch.cat(features_list, dim=2)\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    object_score = bbox_results['cls_score'].sigmoid()\n    bbox_list = self.bbox_head.get_bboxes(rois, object_score, bbox_results['bbox_pred'], labels_3d, img_metas, cfg=self.test_cfg)\n    bbox_results = [bbox3d2result(bboxes, scores, labels) for (bboxes, scores, labels) in bbox_list]\n    return bbox_results"
        ]
    },
    {
        "func_name": "_bbox_forward_train",
        "original": "def _bbox_forward_train(self, features, points, sampling_results):\n    \"\"\"Forward training function of roi_extractor and bbox_head.\n\n        Args:\n            features (torch.Tensor): Backbone features with depth and                 semantic features.\n            points (torch.Tensor): Pointcloud.\n            sampling_results (:obj:`SamplingResult`): Sampled results used\n                for training.\n\n        Returns:\n            dict: Forward results including losses and predictions.\n        \"\"\"\n    rois = bbox3d2roi([res.bboxes for res in sampling_results])\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    bbox_targets = self.bbox_head.get_targets(sampling_results, self.train_cfg)\n    loss_bbox = self.bbox_head.loss(bbox_results['cls_score'], bbox_results['bbox_pred'], rois, *bbox_targets)\n    bbox_results.update(loss_bbox=loss_bbox)\n    return bbox_results",
        "mutated": [
            "def _bbox_forward_train(self, features, points, sampling_results):\n    if False:\n        i = 10\n    'Forward training function of roi_extractor and bbox_head.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and                 semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            sampling_results (:obj:`SamplingResult`): Sampled results used\\n                for training.\\n\\n        Returns:\\n            dict: Forward results including losses and predictions.\\n        '\n    rois = bbox3d2roi([res.bboxes for res in sampling_results])\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    bbox_targets = self.bbox_head.get_targets(sampling_results, self.train_cfg)\n    loss_bbox = self.bbox_head.loss(bbox_results['cls_score'], bbox_results['bbox_pred'], rois, *bbox_targets)\n    bbox_results.update(loss_bbox=loss_bbox)\n    return bbox_results",
            "def _bbox_forward_train(self, features, points, sampling_results):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Forward training function of roi_extractor and bbox_head.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and                 semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            sampling_results (:obj:`SamplingResult`): Sampled results used\\n                for training.\\n\\n        Returns:\\n            dict: Forward results including losses and predictions.\\n        '\n    rois = bbox3d2roi([res.bboxes for res in sampling_results])\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    bbox_targets = self.bbox_head.get_targets(sampling_results, self.train_cfg)\n    loss_bbox = self.bbox_head.loss(bbox_results['cls_score'], bbox_results['bbox_pred'], rois, *bbox_targets)\n    bbox_results.update(loss_bbox=loss_bbox)\n    return bbox_results",
            "def _bbox_forward_train(self, features, points, sampling_results):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Forward training function of roi_extractor and bbox_head.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and                 semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            sampling_results (:obj:`SamplingResult`): Sampled results used\\n                for training.\\n\\n        Returns:\\n            dict: Forward results including losses and predictions.\\n        '\n    rois = bbox3d2roi([res.bboxes for res in sampling_results])\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    bbox_targets = self.bbox_head.get_targets(sampling_results, self.train_cfg)\n    loss_bbox = self.bbox_head.loss(bbox_results['cls_score'], bbox_results['bbox_pred'], rois, *bbox_targets)\n    bbox_results.update(loss_bbox=loss_bbox)\n    return bbox_results",
            "def _bbox_forward_train(self, features, points, sampling_results):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Forward training function of roi_extractor and bbox_head.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and                 semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            sampling_results (:obj:`SamplingResult`): Sampled results used\\n                for training.\\n\\n        Returns:\\n            dict: Forward results including losses and predictions.\\n        '\n    rois = bbox3d2roi([res.bboxes for res in sampling_results])\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    bbox_targets = self.bbox_head.get_targets(sampling_results, self.train_cfg)\n    loss_bbox = self.bbox_head.loss(bbox_results['cls_score'], bbox_results['bbox_pred'], rois, *bbox_targets)\n    bbox_results.update(loss_bbox=loss_bbox)\n    return bbox_results",
            "def _bbox_forward_train(self, features, points, sampling_results):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Forward training function of roi_extractor and bbox_head.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and                 semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            sampling_results (:obj:`SamplingResult`): Sampled results used\\n                for training.\\n\\n        Returns:\\n            dict: Forward results including losses and predictions.\\n        '\n    rois = bbox3d2roi([res.bboxes for res in sampling_results])\n    batch_size = features.shape[0]\n    bbox_results = self._bbox_forward(features, points, batch_size, rois)\n    bbox_targets = self.bbox_head.get_targets(sampling_results, self.train_cfg)\n    loss_bbox = self.bbox_head.loss(bbox_results['cls_score'], bbox_results['bbox_pred'], rois, *bbox_targets)\n    bbox_results.update(loss_bbox=loss_bbox)\n    return bbox_results"
        ]
    },
    {
        "func_name": "_bbox_forward",
        "original": "def _bbox_forward(self, features, points, batch_size, rois):\n    \"\"\"Forward function of roi_extractor and bbox_head used in both\n        training and testing.\n\n        Args:\n            features (torch.Tensor): Backbone features with depth and\n                semantic features.\n            points (torch.Tensor): Pointcloud.\n            batch_size (int): Batch size.\n            rois (torch.Tensor): RoI boxes.\n\n        Returns:\n            dict: Contains predictions of bbox_head and\n                features of roi_extractor.\n        \"\"\"\n    pooled_point_feats = self.point_roi_extractor(features, points, batch_size, rois)\n    (cls_score, bbox_pred) = self.bbox_head(pooled_point_feats)\n    bbox_results = dict(cls_score=cls_score, bbox_pred=bbox_pred)\n    return bbox_results",
        "mutated": [
            "def _bbox_forward(self, features, points, batch_size, rois):\n    if False:\n        i = 10\n    'Forward function of roi_extractor and bbox_head used in both\\n        training and testing.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and\\n                semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            batch_size (int): Batch size.\\n            rois (torch.Tensor): RoI boxes.\\n\\n        Returns:\\n            dict: Contains predictions of bbox_head and\\n                features of roi_extractor.\\n        '\n    pooled_point_feats = self.point_roi_extractor(features, points, batch_size, rois)\n    (cls_score, bbox_pred) = self.bbox_head(pooled_point_feats)\n    bbox_results = dict(cls_score=cls_score, bbox_pred=bbox_pred)\n    return bbox_results",
            "def _bbox_forward(self, features, points, batch_size, rois):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Forward function of roi_extractor and bbox_head used in both\\n        training and testing.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and\\n                semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            batch_size (int): Batch size.\\n            rois (torch.Tensor): RoI boxes.\\n\\n        Returns:\\n            dict: Contains predictions of bbox_head and\\n                features of roi_extractor.\\n        '\n    pooled_point_feats = self.point_roi_extractor(features, points, batch_size, rois)\n    (cls_score, bbox_pred) = self.bbox_head(pooled_point_feats)\n    bbox_results = dict(cls_score=cls_score, bbox_pred=bbox_pred)\n    return bbox_results",
            "def _bbox_forward(self, features, points, batch_size, rois):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Forward function of roi_extractor and bbox_head used in both\\n        training and testing.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and\\n                semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            batch_size (int): Batch size.\\n            rois (torch.Tensor): RoI boxes.\\n\\n        Returns:\\n            dict: Contains predictions of bbox_head and\\n                features of roi_extractor.\\n        '\n    pooled_point_feats = self.point_roi_extractor(features, points, batch_size, rois)\n    (cls_score, bbox_pred) = self.bbox_head(pooled_point_feats)\n    bbox_results = dict(cls_score=cls_score, bbox_pred=bbox_pred)\n    return bbox_results",
            "def _bbox_forward(self, features, points, batch_size, rois):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Forward function of roi_extractor and bbox_head used in both\\n        training and testing.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and\\n                semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            batch_size (int): Batch size.\\n            rois (torch.Tensor): RoI boxes.\\n\\n        Returns:\\n            dict: Contains predictions of bbox_head and\\n                features of roi_extractor.\\n        '\n    pooled_point_feats = self.point_roi_extractor(features, points, batch_size, rois)\n    (cls_score, bbox_pred) = self.bbox_head(pooled_point_feats)\n    bbox_results = dict(cls_score=cls_score, bbox_pred=bbox_pred)\n    return bbox_results",
            "def _bbox_forward(self, features, points, batch_size, rois):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Forward function of roi_extractor and bbox_head used in both\\n        training and testing.\\n\\n        Args:\\n            features (torch.Tensor): Backbone features with depth and\\n                semantic features.\\n            points (torch.Tensor): Pointcloud.\\n            batch_size (int): Batch size.\\n            rois (torch.Tensor): RoI boxes.\\n\\n        Returns:\\n            dict: Contains predictions of bbox_head and\\n                features of roi_extractor.\\n        '\n    pooled_point_feats = self.point_roi_extractor(features, points, batch_size, rois)\n    (cls_score, bbox_pred) = self.bbox_head(pooled_point_feats)\n    bbox_results = dict(cls_score=cls_score, bbox_pred=bbox_pred)\n    return bbox_results"
        ]
    },
    {
        "func_name": "_assign_and_sample",
        "original": "@torch.no_grad()\ndef _assign_and_sample(self, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    \"\"\"Assign and sample proposals for training.\n\n        Args:\n            proposal_list (list[dict]): Proposals produced by RPN.\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\n                boxes.\n            gt_labels_3d (list[torch.Tensor]): Ground truth labels\n\n        Returns:\n            list[:obj:`SamplingResult`]: Sampled results of each training\n                sample.\n        \"\"\"\n    sampling_results = []\n    for batch_idx in range(len(proposal_list)):\n        cur_proposal_list = proposal_list[batch_idx]\n        cur_boxes = cur_proposal_list['boxes_3d']\n        cur_labels_3d = cur_proposal_list['labels_3d']\n        cur_gt_bboxes = gt_bboxes_3d[batch_idx].to(cur_boxes.device)\n        cur_gt_labels = gt_labels_3d[batch_idx]\n        batch_num_gts = 0\n        batch_gt_indis = cur_gt_labels.new_full((len(cur_boxes),), 0)\n        batch_max_overlaps = cur_boxes.tensor.new_zeros(len(cur_boxes))\n        batch_gt_labels = cur_gt_labels.new_full((len(cur_boxes),), -1)\n        if isinstance(self.bbox_assigner, list):\n            for (i, assigner) in enumerate(self.bbox_assigner):\n                gt_per_cls = cur_gt_labels == i\n                pred_per_cls = cur_labels_3d == i\n                cur_assign_res = assigner.assign(cur_boxes.tensor[pred_per_cls], cur_gt_bboxes.tensor[gt_per_cls], gt_labels=cur_gt_labels[gt_per_cls])\n                batch_num_gts += cur_assign_res.num_gts\n                gt_inds_arange_pad = gt_per_cls.nonzero(as_tuple=False).view(-1) + 1\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=0)\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=-1)\n                gt_inds_arange_pad += 1\n                batch_gt_indis[pred_per_cls] = gt_inds_arange_pad[cur_assign_res.gt_inds + 1] - 1\n                batch_max_overlaps[pred_per_cls] = cur_assign_res.max_overlaps\n                batch_gt_labels[pred_per_cls] = cur_assign_res.labels\n            assign_result = AssignResult(batch_num_gts, batch_gt_indis, batch_max_overlaps, batch_gt_labels)\n        else:\n            assign_result = self.bbox_assigner.assign(cur_boxes.tensor, cur_gt_bboxes.tensor, gt_labels=cur_gt_labels)\n        sampling_result = self.bbox_sampler.sample(assign_result, cur_boxes.tensor, cur_gt_bboxes.tensor, cur_gt_labels)\n        sampling_results.append(sampling_result)\n    return sampling_results",
        "mutated": [
            "@torch.no_grad()\ndef _assign_and_sample(self, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n    'Assign and sample proposals for training.\\n\\n        Args:\\n            proposal_list (list[dict]): Proposals produced by RPN.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                boxes.\\n            gt_labels_3d (list[torch.Tensor]): Ground truth labels\\n\\n        Returns:\\n            list[:obj:`SamplingResult`]: Sampled results of each training\\n                sample.\\n        '\n    sampling_results = []\n    for batch_idx in range(len(proposal_list)):\n        cur_proposal_list = proposal_list[batch_idx]\n        cur_boxes = cur_proposal_list['boxes_3d']\n        cur_labels_3d = cur_proposal_list['labels_3d']\n        cur_gt_bboxes = gt_bboxes_3d[batch_idx].to(cur_boxes.device)\n        cur_gt_labels = gt_labels_3d[batch_idx]\n        batch_num_gts = 0\n        batch_gt_indis = cur_gt_labels.new_full((len(cur_boxes),), 0)\n        batch_max_overlaps = cur_boxes.tensor.new_zeros(len(cur_boxes))\n        batch_gt_labels = cur_gt_labels.new_full((len(cur_boxes),), -1)\n        if isinstance(self.bbox_assigner, list):\n            for (i, assigner) in enumerate(self.bbox_assigner):\n                gt_per_cls = cur_gt_labels == i\n                pred_per_cls = cur_labels_3d == i\n                cur_assign_res = assigner.assign(cur_boxes.tensor[pred_per_cls], cur_gt_bboxes.tensor[gt_per_cls], gt_labels=cur_gt_labels[gt_per_cls])\n                batch_num_gts += cur_assign_res.num_gts\n                gt_inds_arange_pad = gt_per_cls.nonzero(as_tuple=False).view(-1) + 1\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=0)\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=-1)\n                gt_inds_arange_pad += 1\n                batch_gt_indis[pred_per_cls] = gt_inds_arange_pad[cur_assign_res.gt_inds + 1] - 1\n                batch_max_overlaps[pred_per_cls] = cur_assign_res.max_overlaps\n                batch_gt_labels[pred_per_cls] = cur_assign_res.labels\n            assign_result = AssignResult(batch_num_gts, batch_gt_indis, batch_max_overlaps, batch_gt_labels)\n        else:\n            assign_result = self.bbox_assigner.assign(cur_boxes.tensor, cur_gt_bboxes.tensor, gt_labels=cur_gt_labels)\n        sampling_result = self.bbox_sampler.sample(assign_result, cur_boxes.tensor, cur_gt_bboxes.tensor, cur_gt_labels)\n        sampling_results.append(sampling_result)\n    return sampling_results",
            "@torch.no_grad()\ndef _assign_and_sample(self, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Assign and sample proposals for training.\\n\\n        Args:\\n            proposal_list (list[dict]): Proposals produced by RPN.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                boxes.\\n            gt_labels_3d (list[torch.Tensor]): Ground truth labels\\n\\n        Returns:\\n            list[:obj:`SamplingResult`]: Sampled results of each training\\n                sample.\\n        '\n    sampling_results = []\n    for batch_idx in range(len(proposal_list)):\n        cur_proposal_list = proposal_list[batch_idx]\n        cur_boxes = cur_proposal_list['boxes_3d']\n        cur_labels_3d = cur_proposal_list['labels_3d']\n        cur_gt_bboxes = gt_bboxes_3d[batch_idx].to(cur_boxes.device)\n        cur_gt_labels = gt_labels_3d[batch_idx]\n        batch_num_gts = 0\n        batch_gt_indis = cur_gt_labels.new_full((len(cur_boxes),), 0)\n        batch_max_overlaps = cur_boxes.tensor.new_zeros(len(cur_boxes))\n        batch_gt_labels = cur_gt_labels.new_full((len(cur_boxes),), -1)\n        if isinstance(self.bbox_assigner, list):\n            for (i, assigner) in enumerate(self.bbox_assigner):\n                gt_per_cls = cur_gt_labels == i\n                pred_per_cls = cur_labels_3d == i\n                cur_assign_res = assigner.assign(cur_boxes.tensor[pred_per_cls], cur_gt_bboxes.tensor[gt_per_cls], gt_labels=cur_gt_labels[gt_per_cls])\n                batch_num_gts += cur_assign_res.num_gts\n                gt_inds_arange_pad = gt_per_cls.nonzero(as_tuple=False).view(-1) + 1\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=0)\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=-1)\n                gt_inds_arange_pad += 1\n                batch_gt_indis[pred_per_cls] = gt_inds_arange_pad[cur_assign_res.gt_inds + 1] - 1\n                batch_max_overlaps[pred_per_cls] = cur_assign_res.max_overlaps\n                batch_gt_labels[pred_per_cls] = cur_assign_res.labels\n            assign_result = AssignResult(batch_num_gts, batch_gt_indis, batch_max_overlaps, batch_gt_labels)\n        else:\n            assign_result = self.bbox_assigner.assign(cur_boxes.tensor, cur_gt_bboxes.tensor, gt_labels=cur_gt_labels)\n        sampling_result = self.bbox_sampler.sample(assign_result, cur_boxes.tensor, cur_gt_bboxes.tensor, cur_gt_labels)\n        sampling_results.append(sampling_result)\n    return sampling_results",
            "@torch.no_grad()\ndef _assign_and_sample(self, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Assign and sample proposals for training.\\n\\n        Args:\\n            proposal_list (list[dict]): Proposals produced by RPN.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                boxes.\\n            gt_labels_3d (list[torch.Tensor]): Ground truth labels\\n\\n        Returns:\\n            list[:obj:`SamplingResult`]: Sampled results of each training\\n                sample.\\n        '\n    sampling_results = []\n    for batch_idx in range(len(proposal_list)):\n        cur_proposal_list = proposal_list[batch_idx]\n        cur_boxes = cur_proposal_list['boxes_3d']\n        cur_labels_3d = cur_proposal_list['labels_3d']\n        cur_gt_bboxes = gt_bboxes_3d[batch_idx].to(cur_boxes.device)\n        cur_gt_labels = gt_labels_3d[batch_idx]\n        batch_num_gts = 0\n        batch_gt_indis = cur_gt_labels.new_full((len(cur_boxes),), 0)\n        batch_max_overlaps = cur_boxes.tensor.new_zeros(len(cur_boxes))\n        batch_gt_labels = cur_gt_labels.new_full((len(cur_boxes),), -1)\n        if isinstance(self.bbox_assigner, list):\n            for (i, assigner) in enumerate(self.bbox_assigner):\n                gt_per_cls = cur_gt_labels == i\n                pred_per_cls = cur_labels_3d == i\n                cur_assign_res = assigner.assign(cur_boxes.tensor[pred_per_cls], cur_gt_bboxes.tensor[gt_per_cls], gt_labels=cur_gt_labels[gt_per_cls])\n                batch_num_gts += cur_assign_res.num_gts\n                gt_inds_arange_pad = gt_per_cls.nonzero(as_tuple=False).view(-1) + 1\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=0)\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=-1)\n                gt_inds_arange_pad += 1\n                batch_gt_indis[pred_per_cls] = gt_inds_arange_pad[cur_assign_res.gt_inds + 1] - 1\n                batch_max_overlaps[pred_per_cls] = cur_assign_res.max_overlaps\n                batch_gt_labels[pred_per_cls] = cur_assign_res.labels\n            assign_result = AssignResult(batch_num_gts, batch_gt_indis, batch_max_overlaps, batch_gt_labels)\n        else:\n            assign_result = self.bbox_assigner.assign(cur_boxes.tensor, cur_gt_bboxes.tensor, gt_labels=cur_gt_labels)\n        sampling_result = self.bbox_sampler.sample(assign_result, cur_boxes.tensor, cur_gt_bboxes.tensor, cur_gt_labels)\n        sampling_results.append(sampling_result)\n    return sampling_results",
            "@torch.no_grad()\ndef _assign_and_sample(self, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Assign and sample proposals for training.\\n\\n        Args:\\n            proposal_list (list[dict]): Proposals produced by RPN.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                boxes.\\n            gt_labels_3d (list[torch.Tensor]): Ground truth labels\\n\\n        Returns:\\n            list[:obj:`SamplingResult`]: Sampled results of each training\\n                sample.\\n        '\n    sampling_results = []\n    for batch_idx in range(len(proposal_list)):\n        cur_proposal_list = proposal_list[batch_idx]\n        cur_boxes = cur_proposal_list['boxes_3d']\n        cur_labels_3d = cur_proposal_list['labels_3d']\n        cur_gt_bboxes = gt_bboxes_3d[batch_idx].to(cur_boxes.device)\n        cur_gt_labels = gt_labels_3d[batch_idx]\n        batch_num_gts = 0\n        batch_gt_indis = cur_gt_labels.new_full((len(cur_boxes),), 0)\n        batch_max_overlaps = cur_boxes.tensor.new_zeros(len(cur_boxes))\n        batch_gt_labels = cur_gt_labels.new_full((len(cur_boxes),), -1)\n        if isinstance(self.bbox_assigner, list):\n            for (i, assigner) in enumerate(self.bbox_assigner):\n                gt_per_cls = cur_gt_labels == i\n                pred_per_cls = cur_labels_3d == i\n                cur_assign_res = assigner.assign(cur_boxes.tensor[pred_per_cls], cur_gt_bboxes.tensor[gt_per_cls], gt_labels=cur_gt_labels[gt_per_cls])\n                batch_num_gts += cur_assign_res.num_gts\n                gt_inds_arange_pad = gt_per_cls.nonzero(as_tuple=False).view(-1) + 1\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=0)\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=-1)\n                gt_inds_arange_pad += 1\n                batch_gt_indis[pred_per_cls] = gt_inds_arange_pad[cur_assign_res.gt_inds + 1] - 1\n                batch_max_overlaps[pred_per_cls] = cur_assign_res.max_overlaps\n                batch_gt_labels[pred_per_cls] = cur_assign_res.labels\n            assign_result = AssignResult(batch_num_gts, batch_gt_indis, batch_max_overlaps, batch_gt_labels)\n        else:\n            assign_result = self.bbox_assigner.assign(cur_boxes.tensor, cur_gt_bboxes.tensor, gt_labels=cur_gt_labels)\n        sampling_result = self.bbox_sampler.sample(assign_result, cur_boxes.tensor, cur_gt_bboxes.tensor, cur_gt_labels)\n        sampling_results.append(sampling_result)\n    return sampling_results",
            "@torch.no_grad()\ndef _assign_and_sample(self, proposal_list, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Assign and sample proposals for training.\\n\\n        Args:\\n            proposal_list (list[dict]): Proposals produced by RPN.\\n            gt_bboxes_3d (list[:obj:`BaseInstance3DBoxes`]): Ground truth\\n                boxes.\\n            gt_labels_3d (list[torch.Tensor]): Ground truth labels\\n\\n        Returns:\\n            list[:obj:`SamplingResult`]: Sampled results of each training\\n                sample.\\n        '\n    sampling_results = []\n    for batch_idx in range(len(proposal_list)):\n        cur_proposal_list = proposal_list[batch_idx]\n        cur_boxes = cur_proposal_list['boxes_3d']\n        cur_labels_3d = cur_proposal_list['labels_3d']\n        cur_gt_bboxes = gt_bboxes_3d[batch_idx].to(cur_boxes.device)\n        cur_gt_labels = gt_labels_3d[batch_idx]\n        batch_num_gts = 0\n        batch_gt_indis = cur_gt_labels.new_full((len(cur_boxes),), 0)\n        batch_max_overlaps = cur_boxes.tensor.new_zeros(len(cur_boxes))\n        batch_gt_labels = cur_gt_labels.new_full((len(cur_boxes),), -1)\n        if isinstance(self.bbox_assigner, list):\n            for (i, assigner) in enumerate(self.bbox_assigner):\n                gt_per_cls = cur_gt_labels == i\n                pred_per_cls = cur_labels_3d == i\n                cur_assign_res = assigner.assign(cur_boxes.tensor[pred_per_cls], cur_gt_bboxes.tensor[gt_per_cls], gt_labels=cur_gt_labels[gt_per_cls])\n                batch_num_gts += cur_assign_res.num_gts\n                gt_inds_arange_pad = gt_per_cls.nonzero(as_tuple=False).view(-1) + 1\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=0)\n                gt_inds_arange_pad = F.pad(gt_inds_arange_pad, (1, 0), mode='constant', value=-1)\n                gt_inds_arange_pad += 1\n                batch_gt_indis[pred_per_cls] = gt_inds_arange_pad[cur_assign_res.gt_inds + 1] - 1\n                batch_max_overlaps[pred_per_cls] = cur_assign_res.max_overlaps\n                batch_gt_labels[pred_per_cls] = cur_assign_res.labels\n            assign_result = AssignResult(batch_num_gts, batch_gt_indis, batch_max_overlaps, batch_gt_labels)\n        else:\n            assign_result = self.bbox_assigner.assign(cur_boxes.tensor, cur_gt_bboxes.tensor, gt_labels=cur_gt_labels)\n        sampling_result = self.bbox_sampler.sample(assign_result, cur_boxes.tensor, cur_gt_bboxes.tensor, cur_gt_labels)\n        sampling_results.append(sampling_result)\n    return sampling_results"
        ]
    }
]