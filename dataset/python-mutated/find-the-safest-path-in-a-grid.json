[
    {
        "func_name": "__init__",
        "original": "def __init__(self, n):\n    self.set = range(n)\n    self.rank = [0] * n",
        "mutated": [
            "def __init__(self, n):\n    if False:\n        i = 10\n    self.set = range(n)\n    self.rank = [0] * n",
            "def __init__(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.set = range(n)\n    self.rank = [0] * n",
            "def __init__(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.set = range(n)\n    self.rank = [0] * n",
            "def __init__(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.set = range(n)\n    self.rank = [0] * n",
            "def __init__(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.set = range(n)\n    self.rank = [0] * n"
        ]
    },
    {
        "func_name": "find_set",
        "original": "def find_set(self, x):\n    stk = []\n    while self.set[x] != x:\n        stk.append(x)\n        x = self.set[x]\n    while stk:\n        self.set[stk.pop()] = x\n    return x",
        "mutated": [
            "def find_set(self, x):\n    if False:\n        i = 10\n    stk = []\n    while self.set[x] != x:\n        stk.append(x)\n        x = self.set[x]\n    while stk:\n        self.set[stk.pop()] = x\n    return x",
            "def find_set(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    stk = []\n    while self.set[x] != x:\n        stk.append(x)\n        x = self.set[x]\n    while stk:\n        self.set[stk.pop()] = x\n    return x",
            "def find_set(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    stk = []\n    while self.set[x] != x:\n        stk.append(x)\n        x = self.set[x]\n    while stk:\n        self.set[stk.pop()] = x\n    return x",
            "def find_set(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    stk = []\n    while self.set[x] != x:\n        stk.append(x)\n        x = self.set[x]\n    while stk:\n        self.set[stk.pop()] = x\n    return x",
            "def find_set(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    stk = []\n    while self.set[x] != x:\n        stk.append(x)\n        x = self.set[x]\n    while stk:\n        self.set[stk.pop()] = x\n    return x"
        ]
    },
    {
        "func_name": "union_set",
        "original": "def union_set(self, x, y):\n    (x, y) = (self.find_set(x), self.find_set(y))\n    if x == y:\n        return False\n    if self.rank[x] > self.rank[y]:\n        (x, y) = (y, x)\n    self.set[x] = self.set[y]\n    if self.rank[x] == self.rank[y]:\n        self.rank[y] += 1\n    return True",
        "mutated": [
            "def union_set(self, x, y):\n    if False:\n        i = 10\n    (x, y) = (self.find_set(x), self.find_set(y))\n    if x == y:\n        return False\n    if self.rank[x] > self.rank[y]:\n        (x, y) = (y, x)\n    self.set[x] = self.set[y]\n    if self.rank[x] == self.rank[y]:\n        self.rank[y] += 1\n    return True",
            "def union_set(self, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (x, y) = (self.find_set(x), self.find_set(y))\n    if x == y:\n        return False\n    if self.rank[x] > self.rank[y]:\n        (x, y) = (y, x)\n    self.set[x] = self.set[y]\n    if self.rank[x] == self.rank[y]:\n        self.rank[y] += 1\n    return True",
            "def union_set(self, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (x, y) = (self.find_set(x), self.find_set(y))\n    if x == y:\n        return False\n    if self.rank[x] > self.rank[y]:\n        (x, y) = (y, x)\n    self.set[x] = self.set[y]\n    if self.rank[x] == self.rank[y]:\n        self.rank[y] += 1\n    return True",
            "def union_set(self, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (x, y) = (self.find_set(x), self.find_set(y))\n    if x == y:\n        return False\n    if self.rank[x] > self.rank[y]:\n        (x, y) = (y, x)\n    self.set[x] = self.set[y]\n    if self.rank[x] == self.rank[y]:\n        self.rank[y] += 1\n    return True",
            "def union_set(self, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (x, y) = (self.find_set(x), self.find_set(y))\n    if x == y:\n        return False\n    if self.rank[x] > self.rank[y]:\n        (x, y) = (y, x)\n    self.set[x] = self.set[y]\n    if self.rank[x] == self.rank[y]:\n        self.rank[y] += 1\n    return True"
        ]
    },
    {
        "func_name": "bfs",
        "original": "def bfs():\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
        "mutated": [
            "def bfs():\n    if False:\n        i = 10\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist"
        ]
    },
    {
        "func_name": "maximumSafenessFactor",
        "original": "def maximumSafenessFactor(self, grid):\n    \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n    dist = bfs()\n    buckets = [[] for _ in xrange(len(grid) - 1 + (len(grid[0]) - 1) + 1)]\n    for r in xrange(len(grid)):\n        for c in xrange(len(grid[0])):\n            buckets[dist[r][c]].append((r, c))\n    lookup = [[False] * len(grid[0]) for _ in xrange(len(grid))]\n    uf = UnionFind(len(grid) * len(grid[0]))\n    for d in reversed(xrange(len(buckets))):\n        for (r, c) in buckets[d]:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (lookup[nr][nc] == True)):\n                    continue\n                uf.union_set(nr * len(grid[0]) + nc, r * len(grid[0]) + c)\n            lookup[r][c] = True\n        if uf.find_set(0 * len(grid[0]) + 0) == uf.find_set((len(grid) - 1) * len(grid[0]) + (len(grid[0]) - 1)):\n            break\n    return d",
        "mutated": [
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n    dist = bfs()\n    buckets = [[] for _ in xrange(len(grid) - 1 + (len(grid[0]) - 1) + 1)]\n    for r in xrange(len(grid)):\n        for c in xrange(len(grid[0])):\n            buckets[dist[r][c]].append((r, c))\n    lookup = [[False] * len(grid[0]) for _ in xrange(len(grid))]\n    uf = UnionFind(len(grid) * len(grid[0]))\n    for d in reversed(xrange(len(buckets))):\n        for (r, c) in buckets[d]:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (lookup[nr][nc] == True)):\n                    continue\n                uf.union_set(nr * len(grid[0]) + nc, r * len(grid[0]) + c)\n            lookup[r][c] = True\n        if uf.find_set(0 * len(grid[0]) + 0) == uf.find_set((len(grid) - 1) * len(grid[0]) + (len(grid[0]) - 1)):\n            break\n    return d",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n    dist = bfs()\n    buckets = [[] for _ in xrange(len(grid) - 1 + (len(grid[0]) - 1) + 1)]\n    for r in xrange(len(grid)):\n        for c in xrange(len(grid[0])):\n            buckets[dist[r][c]].append((r, c))\n    lookup = [[False] * len(grid[0]) for _ in xrange(len(grid))]\n    uf = UnionFind(len(grid) * len(grid[0]))\n    for d in reversed(xrange(len(buckets))):\n        for (r, c) in buckets[d]:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (lookup[nr][nc] == True)):\n                    continue\n                uf.union_set(nr * len(grid[0]) + nc, r * len(grid[0]) + c)\n            lookup[r][c] = True\n        if uf.find_set(0 * len(grid[0]) + 0) == uf.find_set((len(grid) - 1) * len(grid[0]) + (len(grid[0]) - 1)):\n            break\n    return d",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n    dist = bfs()\n    buckets = [[] for _ in xrange(len(grid) - 1 + (len(grid[0]) - 1) + 1)]\n    for r in xrange(len(grid)):\n        for c in xrange(len(grid[0])):\n            buckets[dist[r][c]].append((r, c))\n    lookup = [[False] * len(grid[0]) for _ in xrange(len(grid))]\n    uf = UnionFind(len(grid) * len(grid[0]))\n    for d in reversed(xrange(len(buckets))):\n        for (r, c) in buckets[d]:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (lookup[nr][nc] == True)):\n                    continue\n                uf.union_set(nr * len(grid[0]) + nc, r * len(grid[0]) + c)\n            lookup[r][c] = True\n        if uf.find_set(0 * len(grid[0]) + 0) == uf.find_set((len(grid) - 1) * len(grid[0]) + (len(grid[0]) - 1)):\n            break\n    return d",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n    dist = bfs()\n    buckets = [[] for _ in xrange(len(grid) - 1 + (len(grid[0]) - 1) + 1)]\n    for r in xrange(len(grid)):\n        for c in xrange(len(grid[0])):\n            buckets[dist[r][c]].append((r, c))\n    lookup = [[False] * len(grid[0]) for _ in xrange(len(grid))]\n    uf = UnionFind(len(grid) * len(grid[0]))\n    for d in reversed(xrange(len(buckets))):\n        for (r, c) in buckets[d]:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (lookup[nr][nc] == True)):\n                    continue\n                uf.union_set(nr * len(grid[0]) + nc, r * len(grid[0]) + c)\n            lookup[r][c] = True\n        if uf.find_set(0 * len(grid[0]) + 0) == uf.find_set((len(grid) - 1) * len(grid[0]) + (len(grid[0]) - 1)):\n            break\n    return d",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n    dist = bfs()\n    buckets = [[] for _ in xrange(len(grid) - 1 + (len(grid[0]) - 1) + 1)]\n    for r in xrange(len(grid)):\n        for c in xrange(len(grid[0])):\n            buckets[dist[r][c]].append((r, c))\n    lookup = [[False] * len(grid[0]) for _ in xrange(len(grid))]\n    uf = UnionFind(len(grid) * len(grid[0]))\n    for d in reversed(xrange(len(buckets))):\n        for (r, c) in buckets[d]:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (lookup[nr][nc] == True)):\n                    continue\n                uf.union_set(nr * len(grid[0]) + nc, r * len(grid[0]) + c)\n            lookup[r][c] = True\n        if uf.find_set(0 * len(grid[0]) + 0) == uf.find_set((len(grid) - 1) * len(grid[0]) + (len(grid[0]) - 1)):\n            break\n    return d"
        ]
    },
    {
        "func_name": "bfs",
        "original": "def bfs():\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
        "mutated": [
            "def bfs():\n    if False:\n        i = 10\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist"
        ]
    },
    {
        "func_name": "dijkstra",
        "original": "def dijkstra(start, target):\n    max_heap = [(-dist[start[0]][start[1]], start)]\n    dist[start[0]][start[1]] = -1\n    while max_heap:\n        (curr, u) = heapq.heappop(max_heap)\n        curr = -curr\n        if u == target:\n            return curr\n        for (dr, dc) in DIRECTIONS:\n            (nr, nc) = (u[0] + dr, u[1] + dc)\n            if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                continue\n            heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n            dist[nr][nc] = -1\n    return -1",
        "mutated": [
            "def dijkstra(start, target):\n    if False:\n        i = 10\n    max_heap = [(-dist[start[0]][start[1]], start)]\n    dist[start[0]][start[1]] = -1\n    while max_heap:\n        (curr, u) = heapq.heappop(max_heap)\n        curr = -curr\n        if u == target:\n            return curr\n        for (dr, dc) in DIRECTIONS:\n            (nr, nc) = (u[0] + dr, u[1] + dc)\n            if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                continue\n            heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n            dist[nr][nc] = -1\n    return -1",
            "def dijkstra(start, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    max_heap = [(-dist[start[0]][start[1]], start)]\n    dist[start[0]][start[1]] = -1\n    while max_heap:\n        (curr, u) = heapq.heappop(max_heap)\n        curr = -curr\n        if u == target:\n            return curr\n        for (dr, dc) in DIRECTIONS:\n            (nr, nc) = (u[0] + dr, u[1] + dc)\n            if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                continue\n            heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n            dist[nr][nc] = -1\n    return -1",
            "def dijkstra(start, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    max_heap = [(-dist[start[0]][start[1]], start)]\n    dist[start[0]][start[1]] = -1\n    while max_heap:\n        (curr, u) = heapq.heappop(max_heap)\n        curr = -curr\n        if u == target:\n            return curr\n        for (dr, dc) in DIRECTIONS:\n            (nr, nc) = (u[0] + dr, u[1] + dc)\n            if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                continue\n            heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n            dist[nr][nc] = -1\n    return -1",
            "def dijkstra(start, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    max_heap = [(-dist[start[0]][start[1]], start)]\n    dist[start[0]][start[1]] = -1\n    while max_heap:\n        (curr, u) = heapq.heappop(max_heap)\n        curr = -curr\n        if u == target:\n            return curr\n        for (dr, dc) in DIRECTIONS:\n            (nr, nc) = (u[0] + dr, u[1] + dc)\n            if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                continue\n            heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n            dist[nr][nc] = -1\n    return -1",
            "def dijkstra(start, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    max_heap = [(-dist[start[0]][start[1]], start)]\n    dist[start[0]][start[1]] = -1\n    while max_heap:\n        (curr, u) = heapq.heappop(max_heap)\n        curr = -curr\n        if u == target:\n            return curr\n        for (dr, dc) in DIRECTIONS:\n            (nr, nc) = (u[0] + dr, u[1] + dc)\n            if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                continue\n            heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n            dist[nr][nc] = -1\n    return -1"
        ]
    },
    {
        "func_name": "maximumSafenessFactor",
        "original": "def maximumSafenessFactor(self, grid):\n    \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def dijkstra(start, target):\n        max_heap = [(-dist[start[0]][start[1]], start)]\n        dist[start[0]][start[1]] = -1\n        while max_heap:\n            (curr, u) = heapq.heappop(max_heap)\n            curr = -curr\n            if u == target:\n                return curr\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (u[0] + dr, u[1] + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                    continue\n                heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n                dist[nr][nc] = -1\n        return -1\n    dist = bfs()\n    return dijkstra(dist, (0, 0), (len(grid) - 1, len(grid[0]) - 1))",
        "mutated": [
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def dijkstra(start, target):\n        max_heap = [(-dist[start[0]][start[1]], start)]\n        dist[start[0]][start[1]] = -1\n        while max_heap:\n            (curr, u) = heapq.heappop(max_heap)\n            curr = -curr\n            if u == target:\n                return curr\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (u[0] + dr, u[1] + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                    continue\n                heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n                dist[nr][nc] = -1\n        return -1\n    dist = bfs()\n    return dijkstra(dist, (0, 0), (len(grid) - 1, len(grid[0]) - 1))",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def dijkstra(start, target):\n        max_heap = [(-dist[start[0]][start[1]], start)]\n        dist[start[0]][start[1]] = -1\n        while max_heap:\n            (curr, u) = heapq.heappop(max_heap)\n            curr = -curr\n            if u == target:\n                return curr\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (u[0] + dr, u[1] + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                    continue\n                heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n                dist[nr][nc] = -1\n        return -1\n    dist = bfs()\n    return dijkstra(dist, (0, 0), (len(grid) - 1, len(grid[0]) - 1))",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def dijkstra(start, target):\n        max_heap = [(-dist[start[0]][start[1]], start)]\n        dist[start[0]][start[1]] = -1\n        while max_heap:\n            (curr, u) = heapq.heappop(max_heap)\n            curr = -curr\n            if u == target:\n                return curr\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (u[0] + dr, u[1] + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                    continue\n                heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n                dist[nr][nc] = -1\n        return -1\n    dist = bfs()\n    return dijkstra(dist, (0, 0), (len(grid) - 1, len(grid[0]) - 1))",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def dijkstra(start, target):\n        max_heap = [(-dist[start[0]][start[1]], start)]\n        dist[start[0]][start[1]] = -1\n        while max_heap:\n            (curr, u) = heapq.heappop(max_heap)\n            curr = -curr\n            if u == target:\n                return curr\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (u[0] + dr, u[1] + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                    continue\n                heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n                dist[nr][nc] = -1\n        return -1\n    dist = bfs()\n    return dijkstra(dist, (0, 0), (len(grid) - 1, len(grid[0]) - 1))",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def dijkstra(start, target):\n        max_heap = [(-dist[start[0]][start[1]], start)]\n        dist[start[0]][start[1]] = -1\n        while max_heap:\n            (curr, u) = heapq.heappop(max_heap)\n            curr = -curr\n            if u == target:\n                return curr\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (u[0] + dr, u[1] + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] != -1)):\n                    continue\n                heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n                dist[nr][nc] = -1\n        return -1\n    dist = bfs()\n    return dijkstra(dist, (0, 0), (len(grid) - 1, len(grid[0]) - 1))"
        ]
    },
    {
        "func_name": "bfs",
        "original": "def bfs():\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
        "mutated": [
            "def bfs():\n    if False:\n        i = 10\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist",
            "def bfs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n    q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n    d = 0\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                    continue\n                dist[nr][nc] = d + 1\n                new_q.append((nr, nc))\n        q = new_q\n        d += 1\n    return dist"
        ]
    },
    {
        "func_name": "check",
        "original": "def check(x):\n    lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n    q = [(0, 0)]\n    lookup[0][0] = True\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                    continue\n                lookup[nr][nc] = True\n                new_q.append((nr, nc))\n        q = new_q\n    return lookup[-1][-1]",
        "mutated": [
            "def check(x):\n    if False:\n        i = 10\n    lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n    q = [(0, 0)]\n    lookup[0][0] = True\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                    continue\n                lookup[nr][nc] = True\n                new_q.append((nr, nc))\n        q = new_q\n    return lookup[-1][-1]",
            "def check(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n    q = [(0, 0)]\n    lookup[0][0] = True\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                    continue\n                lookup[nr][nc] = True\n                new_q.append((nr, nc))\n        q = new_q\n    return lookup[-1][-1]",
            "def check(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n    q = [(0, 0)]\n    lookup[0][0] = True\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                    continue\n                lookup[nr][nc] = True\n                new_q.append((nr, nc))\n        q = new_q\n    return lookup[-1][-1]",
            "def check(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n    q = [(0, 0)]\n    lookup[0][0] = True\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                    continue\n                lookup[nr][nc] = True\n                new_q.append((nr, nc))\n        q = new_q\n    return lookup[-1][-1]",
            "def check(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n    q = [(0, 0)]\n    lookup[0][0] = True\n    while q:\n        new_q = []\n        for (r, c) in q:\n            for (dr, dc) in DIRECTIONS:\n                (nr, nc) = (r + dr, c + dc)\n                if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                    continue\n                lookup[nr][nc] = True\n                new_q.append((nr, nc))\n        q = new_q\n    return lookup[-1][-1]"
        ]
    },
    {
        "func_name": "maximumSafenessFactor",
        "original": "def maximumSafenessFactor(self, grid):\n    \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def check(x):\n        lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n        q = [(0, 0)]\n        lookup[0][0] = True\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                        continue\n                    lookup[nr][nc] = True\n                    new_q.append((nr, nc))\n            q = new_q\n        return lookup[-1][-1]\n    dist = bfs()\n    (left, right) = (0, dist[0][0])\n    while left <= right:\n        mid = left + (right - left) // 2\n        if not check(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n    return right",
        "mutated": [
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def check(x):\n        lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n        q = [(0, 0)]\n        lookup[0][0] = True\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                        continue\n                    lookup[nr][nc] = True\n                    new_q.append((nr, nc))\n            q = new_q\n        return lookup[-1][-1]\n    dist = bfs()\n    (left, right) = (0, dist[0][0])\n    while left <= right:\n        mid = left + (right - left) // 2\n        if not check(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n    return right",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def check(x):\n        lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n        q = [(0, 0)]\n        lookup[0][0] = True\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                        continue\n                    lookup[nr][nc] = True\n                    new_q.append((nr, nc))\n            q = new_q\n        return lookup[-1][-1]\n    dist = bfs()\n    (left, right) = (0, dist[0][0])\n    while left <= right:\n        mid = left + (right - left) // 2\n        if not check(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n    return right",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def check(x):\n        lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n        q = [(0, 0)]\n        lookup[0][0] = True\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                        continue\n                    lookup[nr][nc] = True\n                    new_q.append((nr, nc))\n            q = new_q\n        return lookup[-1][-1]\n    dist = bfs()\n    (left, right) = (0, dist[0][0])\n    while left <= right:\n        mid = left + (right - left) // 2\n        if not check(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n    return right",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def check(x):\n        lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n        q = [(0, 0)]\n        lookup[0][0] = True\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                        continue\n                    lookup[nr][nc] = True\n                    new_q.append((nr, nc))\n            q = new_q\n        return lookup[-1][-1]\n    dist = bfs()\n    (left, right) = (0, dist[0][0])\n    while left <= right:\n        mid = left + (right - left) // 2\n        if not check(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n    return right",
            "def maximumSafenessFactor(self, grid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        '\n    DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    def bfs():\n        dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n        q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n        d = 0\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] == -1)):\n                        continue\n                    dist[nr][nc] = d + 1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        return dist\n\n    def check(x):\n        lookup = [[False] * len(dist[0]) for _ in xrange(len(dist))]\n        q = [(0, 0)]\n        lookup[0][0] = True\n        while q:\n            new_q = []\n            for (r, c) in q:\n                for (dr, dc) in DIRECTIONS:\n                    (nr, nc) = (r + dr, c + dc)\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and (dist[nr][nc] >= x) and (not lookup[nr][nc])):\n                        continue\n                    lookup[nr][nc] = True\n                    new_q.append((nr, nc))\n            q = new_q\n        return lookup[-1][-1]\n    dist = bfs()\n    (left, right) = (0, dist[0][0])\n    while left <= right:\n        mid = left + (right - left) // 2\n        if not check(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n    return right"
        ]
    }
]