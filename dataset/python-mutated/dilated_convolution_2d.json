[
    {
        "func_name": "dilated_convolution_2d",
        "original": "def dilated_convolution_2d(x, W, b=None, stride=1, pad=0, dilate=1, cover_all=False):\n    \"\"\"Two-dimensional dilated convolution function.\n\n    This is an implementation of two-dimensional dilated convolution\n    in ConvNets.\n    It takes three variables: the input image ``x``, the filter weight ``W``,\n    and the bias vector ``b``.\n\n    .. note::\n       You can also perform dilated convolution by passing ``dilate``\n       argument to :class:`chainer.functions.convolution_2d`.\n       The functionality is the same.\n\n    Notation: here is a notation for dimensionalities.\n\n    - :math:`n` is the batch size.\n    - :math:`c_I` and :math:`c_O` are the number of the input and output,\n      respectively.\n    - :math:`h` and :math:`w` are the height and width of the input image,\n      respectively.\n    - :math:`k_H` and :math:`k_W` are the height and width of the filters,\n      respectively.\n\n    Args:\n        x (:class:`~chainer.Variable` or :ref:`ndarray`):\n            Input variable of shape :math:`(n, c_I, h, w)`.\n        W (:class:`~chainer.Variable` or :ref:`ndarray`):\n            Weight variable of shape :math:`(c_O, c_I, k_H, k_W)`.\n        b (:class:`~chainer.Variable` or :ref:`ndarray`):\n            Bias variable of length :math:`c_O` (optional).\n        stride (int or pair of ints): Stride of filter applications.\n            ``stride=s`` and ``stride=(s, s)`` are equivalent.\n        pad (int or pair of ints): Spatial padding width for input arrays.\n            ``pad=p`` and ``pad=(p, p)`` are equivalent.\n        dilate (int or pair of ints): Dilation factor of filter applications.\n            ``dilate=d`` and ``dilate=(d, d)`` are equivalent.\n        cover_all (bool): If ``True``, all spatial locations are convoluted\n            into some output pixels. It may make the output size larger.\n\n    Returns:\n        ~chainer.Variable: Output variable.\n\n    The two-dimensional dilated convolution function is defined as follows.\n    Then the ``DilatedConvolution2D`` function computes correlations\n    between filters and patches of size :math:`(k_H, k_W)` in ``x``.\n    Patches here are extracted at intervals of the dilation factor.\n    Note that correlation here is equivalent to the inner product between\n    expanded vectors.\n    Patches are extracted at intervals of the dilation factor and at positions\n    shifted by multiples of ``stride`` from the first position ``-pad`` for\n    each spatial axis. The right-most (or bottom-most) patches do not run over\n    the padded spatial size.\n\n    Let :math:`(s_Y, s_X)` be the stride of filter application,\n    :math:`(p_H, p_W)` the spatial padding size, and :math:`(d_Y, d_X)`\n    the dilation factor of filter application. Then, the output size\n    :math:`(h_O, w_O)` is determined by the following equations:\n\n    .. math::\n\n       h_O &= (h + 2p_H - k_H - (k_H - 1) * (d_Y - 1)) / s_Y + 1,\\\\\\\\\n       w_O &= (w + 2p_W - k_W - (k_W - 1) * (d_X - 1)) / s_X + 1.\n\n    If the bias vector is given, then it is added to all spatial locations of\n    the output of convolution.\n\n    \"\"\"\n    return convolution_2d.convolution_2d(x, W, b, stride, pad, cover_all, dilate=dilate)",
        "mutated": [
            "def dilated_convolution_2d(x, W, b=None, stride=1, pad=0, dilate=1, cover_all=False):\n    if False:\n        i = 10\n    'Two-dimensional dilated convolution function.\\n\\n    This is an implementation of two-dimensional dilated convolution\\n    in ConvNets.\\n    It takes three variables: the input image ``x``, the filter weight ``W``,\\n    and the bias vector ``b``.\\n\\n    .. note::\\n       You can also perform dilated convolution by passing ``dilate``\\n       argument to :class:`chainer.functions.convolution_2d`.\\n       The functionality is the same.\\n\\n    Notation: here is a notation for dimensionalities.\\n\\n    - :math:`n` is the batch size.\\n    - :math:`c_I` and :math:`c_O` are the number of the input and output,\\n      respectively.\\n    - :math:`h` and :math:`w` are the height and width of the input image,\\n      respectively.\\n    - :math:`k_H` and :math:`k_W` are the height and width of the filters,\\n      respectively.\\n\\n    Args:\\n        x (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Input variable of shape :math:`(n, c_I, h, w)`.\\n        W (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Weight variable of shape :math:`(c_O, c_I, k_H, k_W)`.\\n        b (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Bias variable of length :math:`c_O` (optional).\\n        stride (int or pair of ints): Stride of filter applications.\\n            ``stride=s`` and ``stride=(s, s)`` are equivalent.\\n        pad (int or pair of ints): Spatial padding width for input arrays.\\n            ``pad=p`` and ``pad=(p, p)`` are equivalent.\\n        dilate (int or pair of ints): Dilation factor of filter applications.\\n            ``dilate=d`` and ``dilate=(d, d)`` are equivalent.\\n        cover_all (bool): If ``True``, all spatial locations are convoluted\\n            into some output pixels. It may make the output size larger.\\n\\n    Returns:\\n        ~chainer.Variable: Output variable.\\n\\n    The two-dimensional dilated convolution function is defined as follows.\\n    Then the ``DilatedConvolution2D`` function computes correlations\\n    between filters and patches of size :math:`(k_H, k_W)` in ``x``.\\n    Patches here are extracted at intervals of the dilation factor.\\n    Note that correlation here is equivalent to the inner product between\\n    expanded vectors.\\n    Patches are extracted at intervals of the dilation factor and at positions\\n    shifted by multiples of ``stride`` from the first position ``-pad`` for\\n    each spatial axis. The right-most (or bottom-most) patches do not run over\\n    the padded spatial size.\\n\\n    Let :math:`(s_Y, s_X)` be the stride of filter application,\\n    :math:`(p_H, p_W)` the spatial padding size, and :math:`(d_Y, d_X)`\\n    the dilation factor of filter application. Then, the output size\\n    :math:`(h_O, w_O)` is determined by the following equations:\\n\\n    .. math::\\n\\n       h_O &= (h + 2p_H - k_H - (k_H - 1) * (d_Y - 1)) / s_Y + 1,\\\\\\\\\\n       w_O &= (w + 2p_W - k_W - (k_W - 1) * (d_X - 1)) / s_X + 1.\\n\\n    If the bias vector is given, then it is added to all spatial locations of\\n    the output of convolution.\\n\\n    '\n    return convolution_2d.convolution_2d(x, W, b, stride, pad, cover_all, dilate=dilate)",
            "def dilated_convolution_2d(x, W, b=None, stride=1, pad=0, dilate=1, cover_all=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Two-dimensional dilated convolution function.\\n\\n    This is an implementation of two-dimensional dilated convolution\\n    in ConvNets.\\n    It takes three variables: the input image ``x``, the filter weight ``W``,\\n    and the bias vector ``b``.\\n\\n    .. note::\\n       You can also perform dilated convolution by passing ``dilate``\\n       argument to :class:`chainer.functions.convolution_2d`.\\n       The functionality is the same.\\n\\n    Notation: here is a notation for dimensionalities.\\n\\n    - :math:`n` is the batch size.\\n    - :math:`c_I` and :math:`c_O` are the number of the input and output,\\n      respectively.\\n    - :math:`h` and :math:`w` are the height and width of the input image,\\n      respectively.\\n    - :math:`k_H` and :math:`k_W` are the height and width of the filters,\\n      respectively.\\n\\n    Args:\\n        x (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Input variable of shape :math:`(n, c_I, h, w)`.\\n        W (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Weight variable of shape :math:`(c_O, c_I, k_H, k_W)`.\\n        b (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Bias variable of length :math:`c_O` (optional).\\n        stride (int or pair of ints): Stride of filter applications.\\n            ``stride=s`` and ``stride=(s, s)`` are equivalent.\\n        pad (int or pair of ints): Spatial padding width for input arrays.\\n            ``pad=p`` and ``pad=(p, p)`` are equivalent.\\n        dilate (int or pair of ints): Dilation factor of filter applications.\\n            ``dilate=d`` and ``dilate=(d, d)`` are equivalent.\\n        cover_all (bool): If ``True``, all spatial locations are convoluted\\n            into some output pixels. It may make the output size larger.\\n\\n    Returns:\\n        ~chainer.Variable: Output variable.\\n\\n    The two-dimensional dilated convolution function is defined as follows.\\n    Then the ``DilatedConvolution2D`` function computes correlations\\n    between filters and patches of size :math:`(k_H, k_W)` in ``x``.\\n    Patches here are extracted at intervals of the dilation factor.\\n    Note that correlation here is equivalent to the inner product between\\n    expanded vectors.\\n    Patches are extracted at intervals of the dilation factor and at positions\\n    shifted by multiples of ``stride`` from the first position ``-pad`` for\\n    each spatial axis. The right-most (or bottom-most) patches do not run over\\n    the padded spatial size.\\n\\n    Let :math:`(s_Y, s_X)` be the stride of filter application,\\n    :math:`(p_H, p_W)` the spatial padding size, and :math:`(d_Y, d_X)`\\n    the dilation factor of filter application. Then, the output size\\n    :math:`(h_O, w_O)` is determined by the following equations:\\n\\n    .. math::\\n\\n       h_O &= (h + 2p_H - k_H - (k_H - 1) * (d_Y - 1)) / s_Y + 1,\\\\\\\\\\n       w_O &= (w + 2p_W - k_W - (k_W - 1) * (d_X - 1)) / s_X + 1.\\n\\n    If the bias vector is given, then it is added to all spatial locations of\\n    the output of convolution.\\n\\n    '\n    return convolution_2d.convolution_2d(x, W, b, stride, pad, cover_all, dilate=dilate)",
            "def dilated_convolution_2d(x, W, b=None, stride=1, pad=0, dilate=1, cover_all=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Two-dimensional dilated convolution function.\\n\\n    This is an implementation of two-dimensional dilated convolution\\n    in ConvNets.\\n    It takes three variables: the input image ``x``, the filter weight ``W``,\\n    and the bias vector ``b``.\\n\\n    .. note::\\n       You can also perform dilated convolution by passing ``dilate``\\n       argument to :class:`chainer.functions.convolution_2d`.\\n       The functionality is the same.\\n\\n    Notation: here is a notation for dimensionalities.\\n\\n    - :math:`n` is the batch size.\\n    - :math:`c_I` and :math:`c_O` are the number of the input and output,\\n      respectively.\\n    - :math:`h` and :math:`w` are the height and width of the input image,\\n      respectively.\\n    - :math:`k_H` and :math:`k_W` are the height and width of the filters,\\n      respectively.\\n\\n    Args:\\n        x (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Input variable of shape :math:`(n, c_I, h, w)`.\\n        W (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Weight variable of shape :math:`(c_O, c_I, k_H, k_W)`.\\n        b (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Bias variable of length :math:`c_O` (optional).\\n        stride (int or pair of ints): Stride of filter applications.\\n            ``stride=s`` and ``stride=(s, s)`` are equivalent.\\n        pad (int or pair of ints): Spatial padding width for input arrays.\\n            ``pad=p`` and ``pad=(p, p)`` are equivalent.\\n        dilate (int or pair of ints): Dilation factor of filter applications.\\n            ``dilate=d`` and ``dilate=(d, d)`` are equivalent.\\n        cover_all (bool): If ``True``, all spatial locations are convoluted\\n            into some output pixels. It may make the output size larger.\\n\\n    Returns:\\n        ~chainer.Variable: Output variable.\\n\\n    The two-dimensional dilated convolution function is defined as follows.\\n    Then the ``DilatedConvolution2D`` function computes correlations\\n    between filters and patches of size :math:`(k_H, k_W)` in ``x``.\\n    Patches here are extracted at intervals of the dilation factor.\\n    Note that correlation here is equivalent to the inner product between\\n    expanded vectors.\\n    Patches are extracted at intervals of the dilation factor and at positions\\n    shifted by multiples of ``stride`` from the first position ``-pad`` for\\n    each spatial axis. The right-most (or bottom-most) patches do not run over\\n    the padded spatial size.\\n\\n    Let :math:`(s_Y, s_X)` be the stride of filter application,\\n    :math:`(p_H, p_W)` the spatial padding size, and :math:`(d_Y, d_X)`\\n    the dilation factor of filter application. Then, the output size\\n    :math:`(h_O, w_O)` is determined by the following equations:\\n\\n    .. math::\\n\\n       h_O &= (h + 2p_H - k_H - (k_H - 1) * (d_Y - 1)) / s_Y + 1,\\\\\\\\\\n       w_O &= (w + 2p_W - k_W - (k_W - 1) * (d_X - 1)) / s_X + 1.\\n\\n    If the bias vector is given, then it is added to all spatial locations of\\n    the output of convolution.\\n\\n    '\n    return convolution_2d.convolution_2d(x, W, b, stride, pad, cover_all, dilate=dilate)",
            "def dilated_convolution_2d(x, W, b=None, stride=1, pad=0, dilate=1, cover_all=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Two-dimensional dilated convolution function.\\n\\n    This is an implementation of two-dimensional dilated convolution\\n    in ConvNets.\\n    It takes three variables: the input image ``x``, the filter weight ``W``,\\n    and the bias vector ``b``.\\n\\n    .. note::\\n       You can also perform dilated convolution by passing ``dilate``\\n       argument to :class:`chainer.functions.convolution_2d`.\\n       The functionality is the same.\\n\\n    Notation: here is a notation for dimensionalities.\\n\\n    - :math:`n` is the batch size.\\n    - :math:`c_I` and :math:`c_O` are the number of the input and output,\\n      respectively.\\n    - :math:`h` and :math:`w` are the height and width of the input image,\\n      respectively.\\n    - :math:`k_H` and :math:`k_W` are the height and width of the filters,\\n      respectively.\\n\\n    Args:\\n        x (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Input variable of shape :math:`(n, c_I, h, w)`.\\n        W (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Weight variable of shape :math:`(c_O, c_I, k_H, k_W)`.\\n        b (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Bias variable of length :math:`c_O` (optional).\\n        stride (int or pair of ints): Stride of filter applications.\\n            ``stride=s`` and ``stride=(s, s)`` are equivalent.\\n        pad (int or pair of ints): Spatial padding width for input arrays.\\n            ``pad=p`` and ``pad=(p, p)`` are equivalent.\\n        dilate (int or pair of ints): Dilation factor of filter applications.\\n            ``dilate=d`` and ``dilate=(d, d)`` are equivalent.\\n        cover_all (bool): If ``True``, all spatial locations are convoluted\\n            into some output pixels. It may make the output size larger.\\n\\n    Returns:\\n        ~chainer.Variable: Output variable.\\n\\n    The two-dimensional dilated convolution function is defined as follows.\\n    Then the ``DilatedConvolution2D`` function computes correlations\\n    between filters and patches of size :math:`(k_H, k_W)` in ``x``.\\n    Patches here are extracted at intervals of the dilation factor.\\n    Note that correlation here is equivalent to the inner product between\\n    expanded vectors.\\n    Patches are extracted at intervals of the dilation factor and at positions\\n    shifted by multiples of ``stride`` from the first position ``-pad`` for\\n    each spatial axis. The right-most (or bottom-most) patches do not run over\\n    the padded spatial size.\\n\\n    Let :math:`(s_Y, s_X)` be the stride of filter application,\\n    :math:`(p_H, p_W)` the spatial padding size, and :math:`(d_Y, d_X)`\\n    the dilation factor of filter application. Then, the output size\\n    :math:`(h_O, w_O)` is determined by the following equations:\\n\\n    .. math::\\n\\n       h_O &= (h + 2p_H - k_H - (k_H - 1) * (d_Y - 1)) / s_Y + 1,\\\\\\\\\\n       w_O &= (w + 2p_W - k_W - (k_W - 1) * (d_X - 1)) / s_X + 1.\\n\\n    If the bias vector is given, then it is added to all spatial locations of\\n    the output of convolution.\\n\\n    '\n    return convolution_2d.convolution_2d(x, W, b, stride, pad, cover_all, dilate=dilate)",
            "def dilated_convolution_2d(x, W, b=None, stride=1, pad=0, dilate=1, cover_all=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Two-dimensional dilated convolution function.\\n\\n    This is an implementation of two-dimensional dilated convolution\\n    in ConvNets.\\n    It takes three variables: the input image ``x``, the filter weight ``W``,\\n    and the bias vector ``b``.\\n\\n    .. note::\\n       You can also perform dilated convolution by passing ``dilate``\\n       argument to :class:`chainer.functions.convolution_2d`.\\n       The functionality is the same.\\n\\n    Notation: here is a notation for dimensionalities.\\n\\n    - :math:`n` is the batch size.\\n    - :math:`c_I` and :math:`c_O` are the number of the input and output,\\n      respectively.\\n    - :math:`h` and :math:`w` are the height and width of the input image,\\n      respectively.\\n    - :math:`k_H` and :math:`k_W` are the height and width of the filters,\\n      respectively.\\n\\n    Args:\\n        x (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Input variable of shape :math:`(n, c_I, h, w)`.\\n        W (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Weight variable of shape :math:`(c_O, c_I, k_H, k_W)`.\\n        b (:class:`~chainer.Variable` or :ref:`ndarray`):\\n            Bias variable of length :math:`c_O` (optional).\\n        stride (int or pair of ints): Stride of filter applications.\\n            ``stride=s`` and ``stride=(s, s)`` are equivalent.\\n        pad (int or pair of ints): Spatial padding width for input arrays.\\n            ``pad=p`` and ``pad=(p, p)`` are equivalent.\\n        dilate (int or pair of ints): Dilation factor of filter applications.\\n            ``dilate=d`` and ``dilate=(d, d)`` are equivalent.\\n        cover_all (bool): If ``True``, all spatial locations are convoluted\\n            into some output pixels. It may make the output size larger.\\n\\n    Returns:\\n        ~chainer.Variable: Output variable.\\n\\n    The two-dimensional dilated convolution function is defined as follows.\\n    Then the ``DilatedConvolution2D`` function computes correlations\\n    between filters and patches of size :math:`(k_H, k_W)` in ``x``.\\n    Patches here are extracted at intervals of the dilation factor.\\n    Note that correlation here is equivalent to the inner product between\\n    expanded vectors.\\n    Patches are extracted at intervals of the dilation factor and at positions\\n    shifted by multiples of ``stride`` from the first position ``-pad`` for\\n    each spatial axis. The right-most (or bottom-most) patches do not run over\\n    the padded spatial size.\\n\\n    Let :math:`(s_Y, s_X)` be the stride of filter application,\\n    :math:`(p_H, p_W)` the spatial padding size, and :math:`(d_Y, d_X)`\\n    the dilation factor of filter application. Then, the output size\\n    :math:`(h_O, w_O)` is determined by the following equations:\\n\\n    .. math::\\n\\n       h_O &= (h + 2p_H - k_H - (k_H - 1) * (d_Y - 1)) / s_Y + 1,\\\\\\\\\\n       w_O &= (w + 2p_W - k_W - (k_W - 1) * (d_X - 1)) / s_X + 1.\\n\\n    If the bias vector is given, then it is added to all spatial locations of\\n    the output of convolution.\\n\\n    '\n    return convolution_2d.convolution_2d(x, W, b, stride, pad, cover_all, dilate=dilate)"
        ]
    }
]