[
    {
        "func_name": "oneway_transfer_error",
        "original": "def oneway_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    \"\"\"Return transfer error in image 2 for correspondences given the homography matrix.\n\n    Args:\n        pts1: correspondences from the left images with shape\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\n        pts2: correspondences from the right images with shape\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\n        H: Homographies with shape :math:`(B, 3, 3)`.\n        squared: if True (default), the squared distance is returned.\n        eps: Small constant for safe sqrt.\n\n    Returns:\n        the computed distance with shape :math:`(B, N)`.\n    \"\"\"\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    pts1_in_2: Tensor = transform_points(H, pts1)\n    error_squared: Tensor = (pts1_in_2 - pts2).pow(2).sum(dim=-1)\n    if squared:\n        return error_squared\n    return (error_squared + eps).sqrt()",
        "mutated": [
            "def oneway_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n    'Return transfer error in image 2 for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    pts1_in_2: Tensor = transform_points(H, pts1)\n    error_squared: Tensor = (pts1_in_2 - pts2).pow(2).sum(dim=-1)\n    if squared:\n        return error_squared\n    return (error_squared + eps).sqrt()",
            "def oneway_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return transfer error in image 2 for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    pts1_in_2: Tensor = transform_points(H, pts1)\n    error_squared: Tensor = (pts1_in_2 - pts2).pow(2).sum(dim=-1)\n    if squared:\n        return error_squared\n    return (error_squared + eps).sqrt()",
            "def oneway_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return transfer error in image 2 for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    pts1_in_2: Tensor = transform_points(H, pts1)\n    error_squared: Tensor = (pts1_in_2 - pts2).pow(2).sum(dim=-1)\n    if squared:\n        return error_squared\n    return (error_squared + eps).sqrt()",
            "def oneway_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return transfer error in image 2 for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    pts1_in_2: Tensor = transform_points(H, pts1)\n    error_squared: Tensor = (pts1_in_2 - pts2).pow(2).sum(dim=-1)\n    if squared:\n        return error_squared\n    return (error_squared + eps).sqrt()",
            "def oneway_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return transfer error in image 2 for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    pts1_in_2: Tensor = transform_points(H, pts1)\n    error_squared: Tensor = (pts1_in_2 - pts2).pow(2).sum(dim=-1)\n    if squared:\n        return error_squared\n    return (error_squared + eps).sqrt()"
        ]
    },
    {
        "func_name": "symmetric_transfer_error",
        "original": "def symmetric_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    \"\"\"Return Symmetric transfer error for correspondences given the homography matrix.\n\n    Args:\n        pts1: correspondences from the left images with shape\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\n        pts2: correspondences from the right images with shape\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\n        H: Homographies with shape :math:`(B, 3, 3)`.\n        squared: if True (default), the squared distance is returned.\n        eps: Small constant for safe sqrt.\n\n    Returns:\n        the computed distance with shape :math:`(B, N)`.\n    \"\"\"\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    max_num = torch.finfo(pts1.dtype).max\n    (H_inv, good_H) = safe_inverse_with_mask(H)\n    there: Tensor = oneway_transfer_error(pts1, pts2, H, True, eps)\n    back: Tensor = oneway_transfer_error(pts2, pts1, H_inv, True, eps)\n    good_H_reshape: Tensor = good_H.view(-1, 1).expand_as(there)\n    out = (there + back) * good_H_reshape.to(there.dtype) + max_num * (~good_H_reshape).to(there.dtype)\n    if squared:\n        return out\n    return (out + eps).sqrt()",
        "mutated": [
            "def symmetric_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n    'Return Symmetric transfer error for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    max_num = torch.finfo(pts1.dtype).max\n    (H_inv, good_H) = safe_inverse_with_mask(H)\n    there: Tensor = oneway_transfer_error(pts1, pts2, H, True, eps)\n    back: Tensor = oneway_transfer_error(pts2, pts1, H_inv, True, eps)\n    good_H_reshape: Tensor = good_H.view(-1, 1).expand_as(there)\n    out = (there + back) * good_H_reshape.to(there.dtype) + max_num * (~good_H_reshape).to(there.dtype)\n    if squared:\n        return out\n    return (out + eps).sqrt()",
            "def symmetric_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return Symmetric transfer error for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    max_num = torch.finfo(pts1.dtype).max\n    (H_inv, good_H) = safe_inverse_with_mask(H)\n    there: Tensor = oneway_transfer_error(pts1, pts2, H, True, eps)\n    back: Tensor = oneway_transfer_error(pts2, pts1, H_inv, True, eps)\n    good_H_reshape: Tensor = good_H.view(-1, 1).expand_as(there)\n    out = (there + back) * good_H_reshape.to(there.dtype) + max_num * (~good_H_reshape).to(there.dtype)\n    if squared:\n        return out\n    return (out + eps).sqrt()",
            "def symmetric_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return Symmetric transfer error for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    max_num = torch.finfo(pts1.dtype).max\n    (H_inv, good_H) = safe_inverse_with_mask(H)\n    there: Tensor = oneway_transfer_error(pts1, pts2, H, True, eps)\n    back: Tensor = oneway_transfer_error(pts2, pts1, H_inv, True, eps)\n    good_H_reshape: Tensor = good_H.view(-1, 1).expand_as(there)\n    out = (there + back) * good_H_reshape.to(there.dtype) + max_num * (~good_H_reshape).to(there.dtype)\n    if squared:\n        return out\n    return (out + eps).sqrt()",
            "def symmetric_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return Symmetric transfer error for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    max_num = torch.finfo(pts1.dtype).max\n    (H_inv, good_H) = safe_inverse_with_mask(H)\n    there: Tensor = oneway_transfer_error(pts1, pts2, H, True, eps)\n    back: Tensor = oneway_transfer_error(pts2, pts1, H_inv, True, eps)\n    good_H_reshape: Tensor = good_H.view(-1, 1).expand_as(there)\n    out = (there + back) * good_H_reshape.to(there.dtype) + max_num * (~good_H_reshape).to(there.dtype)\n    if squared:\n        return out\n    return (out + eps).sqrt()",
            "def symmetric_transfer_error(pts1: Tensor, pts2: Tensor, H: Tensor, squared: bool=True, eps: float=1e-08) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return Symmetric transfer error for correspondences given the homography matrix.\\n\\n    Args:\\n        pts1: correspondences from the left images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        pts2: correspondences from the right images with shape\\n          (B, N, 2 or 3). If they are homogeneous, converted automatically.\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default), the squared distance is returned.\\n        eps: Small constant for safe sqrt.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    if pts1.size(-1) == 3:\n        pts1 = convert_points_from_homogeneous(pts1)\n    if pts2.size(-1) == 3:\n        pts2 = convert_points_from_homogeneous(pts2)\n    max_num = torch.finfo(pts1.dtype).max\n    (H_inv, good_H) = safe_inverse_with_mask(H)\n    there: Tensor = oneway_transfer_error(pts1, pts2, H, True, eps)\n    back: Tensor = oneway_transfer_error(pts2, pts1, H_inv, True, eps)\n    good_H_reshape: Tensor = good_H.view(-1, 1).expand_as(there)\n    out = (there + back) * good_H_reshape.to(there.dtype) + max_num * (~good_H_reshape).to(there.dtype)\n    if squared:\n        return out\n    return (out + eps).sqrt()"
        ]
    },
    {
        "func_name": "line_segment_transfer_error_one_way",
        "original": "def line_segment_transfer_error_one_way(ls1: Tensor, ls2: Tensor, H: Tensor, squared: bool=False) -> Tensor:\n    \"\"\"Return transfer error in image 2 for line segment correspondences given the homography matrix.\n\n    Line segment end points are reprojected into image 2, and point-to-line error is calculated w.r.t. line,\n    induced by line segment in image 2. See :cite:`homolines2001` for details.\n\n    Args:\n        ls1: line segment correspondences from the left images with shape\n          (B, N, 2, 2).\n        ls2: line segment correspondences from the right images with shape\n          (B, N, 2, 2).\n        H: Homographies with shape :math:`(B, 3, 3)`.\n        squared: if True (default is False), the squared distance is returned.\n\n    Returns:\n        the computed distance with shape :math:`(B, N)`.\n    \"\"\"\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (B, N) = ls1.shape[:2]\n    (ps1, pe1) = torch.chunk(ls1, dim=2, chunks=2)\n    (ps2, pe2) = torch.chunk(ls2, dim=2, chunks=2)\n    ps2_h = convert_points_to_homogeneous(ps2)\n    pe2_h = convert_points_to_homogeneous(pe2)\n    ln2 = ps2_h.cross(pe2_h, dim=3)\n    ps1_in2 = convert_points_to_homogeneous(transform_points(H, ps1))\n    pe1_in2 = convert_points_to_homogeneous(transform_points(H, pe1))\n    er_st1 = (ln2 @ ps1_in2.transpose(-2, -1)).view(B, N).abs()\n    er_end1 = (ln2 @ pe1_in2.transpose(-2, -1)).view(B, N).abs()\n    error = 0.5 * (er_st1 + er_end1)\n    if squared:\n        error = error ** 2\n    return error",
        "mutated": [
            "def line_segment_transfer_error_one_way(ls1: Tensor, ls2: Tensor, H: Tensor, squared: bool=False) -> Tensor:\n    if False:\n        i = 10\n    'Return transfer error in image 2 for line segment correspondences given the homography matrix.\\n\\n    Line segment end points are reprojected into image 2, and point-to-line error is calculated w.r.t. line,\\n    induced by line segment in image 2. See :cite:`homolines2001` for details.\\n\\n    Args:\\n        ls1: line segment correspondences from the left images with shape\\n          (B, N, 2, 2).\\n        ls2: line segment correspondences from the right images with shape\\n          (B, N, 2, 2).\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default is False), the squared distance is returned.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (B, N) = ls1.shape[:2]\n    (ps1, pe1) = torch.chunk(ls1, dim=2, chunks=2)\n    (ps2, pe2) = torch.chunk(ls2, dim=2, chunks=2)\n    ps2_h = convert_points_to_homogeneous(ps2)\n    pe2_h = convert_points_to_homogeneous(pe2)\n    ln2 = ps2_h.cross(pe2_h, dim=3)\n    ps1_in2 = convert_points_to_homogeneous(transform_points(H, ps1))\n    pe1_in2 = convert_points_to_homogeneous(transform_points(H, pe1))\n    er_st1 = (ln2 @ ps1_in2.transpose(-2, -1)).view(B, N).abs()\n    er_end1 = (ln2 @ pe1_in2.transpose(-2, -1)).view(B, N).abs()\n    error = 0.5 * (er_st1 + er_end1)\n    if squared:\n        error = error ** 2\n    return error",
            "def line_segment_transfer_error_one_way(ls1: Tensor, ls2: Tensor, H: Tensor, squared: bool=False) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return transfer error in image 2 for line segment correspondences given the homography matrix.\\n\\n    Line segment end points are reprojected into image 2, and point-to-line error is calculated w.r.t. line,\\n    induced by line segment in image 2. See :cite:`homolines2001` for details.\\n\\n    Args:\\n        ls1: line segment correspondences from the left images with shape\\n          (B, N, 2, 2).\\n        ls2: line segment correspondences from the right images with shape\\n          (B, N, 2, 2).\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default is False), the squared distance is returned.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (B, N) = ls1.shape[:2]\n    (ps1, pe1) = torch.chunk(ls1, dim=2, chunks=2)\n    (ps2, pe2) = torch.chunk(ls2, dim=2, chunks=2)\n    ps2_h = convert_points_to_homogeneous(ps2)\n    pe2_h = convert_points_to_homogeneous(pe2)\n    ln2 = ps2_h.cross(pe2_h, dim=3)\n    ps1_in2 = convert_points_to_homogeneous(transform_points(H, ps1))\n    pe1_in2 = convert_points_to_homogeneous(transform_points(H, pe1))\n    er_st1 = (ln2 @ ps1_in2.transpose(-2, -1)).view(B, N).abs()\n    er_end1 = (ln2 @ pe1_in2.transpose(-2, -1)).view(B, N).abs()\n    error = 0.5 * (er_st1 + er_end1)\n    if squared:\n        error = error ** 2\n    return error",
            "def line_segment_transfer_error_one_way(ls1: Tensor, ls2: Tensor, H: Tensor, squared: bool=False) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return transfer error in image 2 for line segment correspondences given the homography matrix.\\n\\n    Line segment end points are reprojected into image 2, and point-to-line error is calculated w.r.t. line,\\n    induced by line segment in image 2. See :cite:`homolines2001` for details.\\n\\n    Args:\\n        ls1: line segment correspondences from the left images with shape\\n          (B, N, 2, 2).\\n        ls2: line segment correspondences from the right images with shape\\n          (B, N, 2, 2).\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default is False), the squared distance is returned.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (B, N) = ls1.shape[:2]\n    (ps1, pe1) = torch.chunk(ls1, dim=2, chunks=2)\n    (ps2, pe2) = torch.chunk(ls2, dim=2, chunks=2)\n    ps2_h = convert_points_to_homogeneous(ps2)\n    pe2_h = convert_points_to_homogeneous(pe2)\n    ln2 = ps2_h.cross(pe2_h, dim=3)\n    ps1_in2 = convert_points_to_homogeneous(transform_points(H, ps1))\n    pe1_in2 = convert_points_to_homogeneous(transform_points(H, pe1))\n    er_st1 = (ln2 @ ps1_in2.transpose(-2, -1)).view(B, N).abs()\n    er_end1 = (ln2 @ pe1_in2.transpose(-2, -1)).view(B, N).abs()\n    error = 0.5 * (er_st1 + er_end1)\n    if squared:\n        error = error ** 2\n    return error",
            "def line_segment_transfer_error_one_way(ls1: Tensor, ls2: Tensor, H: Tensor, squared: bool=False) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return transfer error in image 2 for line segment correspondences given the homography matrix.\\n\\n    Line segment end points are reprojected into image 2, and point-to-line error is calculated w.r.t. line,\\n    induced by line segment in image 2. See :cite:`homolines2001` for details.\\n\\n    Args:\\n        ls1: line segment correspondences from the left images with shape\\n          (B, N, 2, 2).\\n        ls2: line segment correspondences from the right images with shape\\n          (B, N, 2, 2).\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default is False), the squared distance is returned.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (B, N) = ls1.shape[:2]\n    (ps1, pe1) = torch.chunk(ls1, dim=2, chunks=2)\n    (ps2, pe2) = torch.chunk(ls2, dim=2, chunks=2)\n    ps2_h = convert_points_to_homogeneous(ps2)\n    pe2_h = convert_points_to_homogeneous(pe2)\n    ln2 = ps2_h.cross(pe2_h, dim=3)\n    ps1_in2 = convert_points_to_homogeneous(transform_points(H, ps1))\n    pe1_in2 = convert_points_to_homogeneous(transform_points(H, pe1))\n    er_st1 = (ln2 @ ps1_in2.transpose(-2, -1)).view(B, N).abs()\n    er_end1 = (ln2 @ pe1_in2.transpose(-2, -1)).view(B, N).abs()\n    error = 0.5 * (er_st1 + er_end1)\n    if squared:\n        error = error ** 2\n    return error",
            "def line_segment_transfer_error_one_way(ls1: Tensor, ls2: Tensor, H: Tensor, squared: bool=False) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return transfer error in image 2 for line segment correspondences given the homography matrix.\\n\\n    Line segment end points are reprojected into image 2, and point-to-line error is calculated w.r.t. line,\\n    induced by line segment in image 2. See :cite:`homolines2001` for details.\\n\\n    Args:\\n        ls1: line segment correspondences from the left images with shape\\n          (B, N, 2, 2).\\n        ls2: line segment correspondences from the right images with shape\\n          (B, N, 2, 2).\\n        H: Homographies with shape :math:`(B, 3, 3)`.\\n        squared: if True (default is False), the squared distance is returned.\\n\\n    Returns:\\n        the computed distance with shape :math:`(B, N)`.\\n    '\n    KORNIA_CHECK_SHAPE(H, ['B', '3', '3'])\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (B, N) = ls1.shape[:2]\n    (ps1, pe1) = torch.chunk(ls1, dim=2, chunks=2)\n    (ps2, pe2) = torch.chunk(ls2, dim=2, chunks=2)\n    ps2_h = convert_points_to_homogeneous(ps2)\n    pe2_h = convert_points_to_homogeneous(pe2)\n    ln2 = ps2_h.cross(pe2_h, dim=3)\n    ps1_in2 = convert_points_to_homogeneous(transform_points(H, ps1))\n    pe1_in2 = convert_points_to_homogeneous(transform_points(H, pe1))\n    er_st1 = (ln2 @ ps1_in2.transpose(-2, -1)).view(B, N).abs()\n    er_end1 = (ln2 @ pe1_in2.transpose(-2, -1)).view(B, N).abs()\n    error = 0.5 * (er_st1 + er_end1)\n    if squared:\n        error = error ** 2\n    return error"
        ]
    },
    {
        "func_name": "find_homography_dlt",
        "original": "def find_homography_dlt(points1: torch.Tensor, points2: torch.Tensor, weights: Optional[torch.Tensor]=None, solver: str='lu') -> torch.Tensor:\n    \"\"\"Compute the homography matrix using the DLT formulation.\n\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Points algorithm.\n\n    Args:\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\n        solver: variants: svd, lu.\n\n\n    Returns:\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\n    \"\"\"\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    if points1.shape[1] < 4:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', 'N', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', 'N', '2'])\n    (device, dtype) = _extract_device_dtype([points1, points2])\n    eps: float = 1e-08\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (x1, y1) = torch.chunk(points1_norm, dim=-1, chunks=2)\n    (x2, y2) = torch.chunk(points2_norm, dim=-1, chunks=2)\n    (ones, zeros) = (torch.ones_like(x1), torch.zeros_like(x1))\n    ax = torch.cat([zeros, zeros, zeros, -x1, -y1, -ones, y2 * x1, y2 * y1, y2], dim=-1)\n    ay = torch.cat([x1, y1, ones, zeros, zeros, zeros, -x2 * x1, -x2 * y1, -x2], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == points1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    if solver == 'svd':\n        try:\n            (_, _, V) = _torch_svd_cast(A)\n        except RuntimeError:\n            warnings.warn('SVD did not converge', RuntimeWarning)\n            return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n        H = V[..., -1].view(-1, 3, 3)\n    elif solver == 'lu':\n        B = torch.ones(A.shape[0], A.shape[1], device=device, dtype=dtype)\n        (sol, _, _) = safe_solve_with_mask(B, A)\n        H = sol.reshape(-1, 3, 3)\n    else:\n        raise NotImplementedError\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
        "mutated": [
            "def find_homography_dlt(points1: torch.Tensor, points2: torch.Tensor, weights: Optional[torch.Tensor]=None, solver: str='lu') -> torch.Tensor:\n    if False:\n        i = 10\n    'Compute the homography matrix using the DLT formulation.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n        solver: variants: svd, lu.\\n\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    if points1.shape[1] < 4:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', 'N', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', 'N', '2'])\n    (device, dtype) = _extract_device_dtype([points1, points2])\n    eps: float = 1e-08\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (x1, y1) = torch.chunk(points1_norm, dim=-1, chunks=2)\n    (x2, y2) = torch.chunk(points2_norm, dim=-1, chunks=2)\n    (ones, zeros) = (torch.ones_like(x1), torch.zeros_like(x1))\n    ax = torch.cat([zeros, zeros, zeros, -x1, -y1, -ones, y2 * x1, y2 * y1, y2], dim=-1)\n    ay = torch.cat([x1, y1, ones, zeros, zeros, zeros, -x2 * x1, -x2 * y1, -x2], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == points1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    if solver == 'svd':\n        try:\n            (_, _, V) = _torch_svd_cast(A)\n        except RuntimeError:\n            warnings.warn('SVD did not converge', RuntimeWarning)\n            return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n        H = V[..., -1].view(-1, 3, 3)\n    elif solver == 'lu':\n        B = torch.ones(A.shape[0], A.shape[1], device=device, dtype=dtype)\n        (sol, _, _) = safe_solve_with_mask(B, A)\n        H = sol.reshape(-1, 3, 3)\n    else:\n        raise NotImplementedError\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
            "def find_homography_dlt(points1: torch.Tensor, points2: torch.Tensor, weights: Optional[torch.Tensor]=None, solver: str='lu') -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the homography matrix using the DLT formulation.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n        solver: variants: svd, lu.\\n\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    if points1.shape[1] < 4:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', 'N', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', 'N', '2'])\n    (device, dtype) = _extract_device_dtype([points1, points2])\n    eps: float = 1e-08\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (x1, y1) = torch.chunk(points1_norm, dim=-1, chunks=2)\n    (x2, y2) = torch.chunk(points2_norm, dim=-1, chunks=2)\n    (ones, zeros) = (torch.ones_like(x1), torch.zeros_like(x1))\n    ax = torch.cat([zeros, zeros, zeros, -x1, -y1, -ones, y2 * x1, y2 * y1, y2], dim=-1)\n    ay = torch.cat([x1, y1, ones, zeros, zeros, zeros, -x2 * x1, -x2 * y1, -x2], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == points1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    if solver == 'svd':\n        try:\n            (_, _, V) = _torch_svd_cast(A)\n        except RuntimeError:\n            warnings.warn('SVD did not converge', RuntimeWarning)\n            return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n        H = V[..., -1].view(-1, 3, 3)\n    elif solver == 'lu':\n        B = torch.ones(A.shape[0], A.shape[1], device=device, dtype=dtype)\n        (sol, _, _) = safe_solve_with_mask(B, A)\n        H = sol.reshape(-1, 3, 3)\n    else:\n        raise NotImplementedError\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
            "def find_homography_dlt(points1: torch.Tensor, points2: torch.Tensor, weights: Optional[torch.Tensor]=None, solver: str='lu') -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the homography matrix using the DLT formulation.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n        solver: variants: svd, lu.\\n\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    if points1.shape[1] < 4:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', 'N', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', 'N', '2'])\n    (device, dtype) = _extract_device_dtype([points1, points2])\n    eps: float = 1e-08\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (x1, y1) = torch.chunk(points1_norm, dim=-1, chunks=2)\n    (x2, y2) = torch.chunk(points2_norm, dim=-1, chunks=2)\n    (ones, zeros) = (torch.ones_like(x1), torch.zeros_like(x1))\n    ax = torch.cat([zeros, zeros, zeros, -x1, -y1, -ones, y2 * x1, y2 * y1, y2], dim=-1)\n    ay = torch.cat([x1, y1, ones, zeros, zeros, zeros, -x2 * x1, -x2 * y1, -x2], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == points1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    if solver == 'svd':\n        try:\n            (_, _, V) = _torch_svd_cast(A)\n        except RuntimeError:\n            warnings.warn('SVD did not converge', RuntimeWarning)\n            return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n        H = V[..., -1].view(-1, 3, 3)\n    elif solver == 'lu':\n        B = torch.ones(A.shape[0], A.shape[1], device=device, dtype=dtype)\n        (sol, _, _) = safe_solve_with_mask(B, A)\n        H = sol.reshape(-1, 3, 3)\n    else:\n        raise NotImplementedError\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
            "def find_homography_dlt(points1: torch.Tensor, points2: torch.Tensor, weights: Optional[torch.Tensor]=None, solver: str='lu') -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the homography matrix using the DLT formulation.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n        solver: variants: svd, lu.\\n\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    if points1.shape[1] < 4:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', 'N', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', 'N', '2'])\n    (device, dtype) = _extract_device_dtype([points1, points2])\n    eps: float = 1e-08\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (x1, y1) = torch.chunk(points1_norm, dim=-1, chunks=2)\n    (x2, y2) = torch.chunk(points2_norm, dim=-1, chunks=2)\n    (ones, zeros) = (torch.ones_like(x1), torch.zeros_like(x1))\n    ax = torch.cat([zeros, zeros, zeros, -x1, -y1, -ones, y2 * x1, y2 * y1, y2], dim=-1)\n    ay = torch.cat([x1, y1, ones, zeros, zeros, zeros, -x2 * x1, -x2 * y1, -x2], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == points1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    if solver == 'svd':\n        try:\n            (_, _, V) = _torch_svd_cast(A)\n        except RuntimeError:\n            warnings.warn('SVD did not converge', RuntimeWarning)\n            return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n        H = V[..., -1].view(-1, 3, 3)\n    elif solver == 'lu':\n        B = torch.ones(A.shape[0], A.shape[1], device=device, dtype=dtype)\n        (sol, _, _) = safe_solve_with_mask(B, A)\n        H = sol.reshape(-1, 3, 3)\n    else:\n        raise NotImplementedError\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
            "def find_homography_dlt(points1: torch.Tensor, points2: torch.Tensor, weights: Optional[torch.Tensor]=None, solver: str='lu') -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the homography matrix using the DLT formulation.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n        solver: variants: svd, lu.\\n\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    if points1.shape[1] < 4:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', 'N', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', 'N', '2'])\n    (device, dtype) = _extract_device_dtype([points1, points2])\n    eps: float = 1e-08\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (x1, y1) = torch.chunk(points1_norm, dim=-1, chunks=2)\n    (x2, y2) = torch.chunk(points2_norm, dim=-1, chunks=2)\n    (ones, zeros) = (torch.ones_like(x1), torch.zeros_like(x1))\n    ax = torch.cat([zeros, zeros, zeros, -x1, -y1, -ones, y2 * x1, y2 * y1, y2], dim=-1)\n    ay = torch.cat([x1, y1, ones, zeros, zeros, zeros, -x2 * x1, -x2 * y1, -x2], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == points1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    if solver == 'svd':\n        try:\n            (_, _, V) = _torch_svd_cast(A)\n        except RuntimeError:\n            warnings.warn('SVD did not converge', RuntimeWarning)\n            return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n        H = V[..., -1].view(-1, 3, 3)\n    elif solver == 'lu':\n        B = torch.ones(A.shape[0], A.shape[1], device=device, dtype=dtype)\n        (sol, _, _) = safe_solve_with_mask(B, A)\n        H = sol.reshape(-1, 3, 3)\n    else:\n        raise NotImplementedError\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm"
        ]
    },
    {
        "func_name": "find_homography_dlt_iterated",
        "original": "def find_homography_dlt_iterated(points1: Tensor, points2: Tensor, weights: Tensor, soft_inl_th: float=3.0, n_iter: int=5) -> Tensor:\n    \"\"\"Compute the homography matrix using the iteratively-reweighted least squares (IRWLS).\n\n    The linear system is solved by using the Reweighted Least Squares Solution for the 4 Points algorithm.\n\n    Args:\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\n          Used for the first iteration of the IRWLS.\n        soft_inl_th: Soft inlier threshold used for weight calculation.\n        n_iter: number of iterations.\n\n    Returns:\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\n    \"\"\"\n    H: Tensor = find_homography_dlt(points1, points2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = symmetric_transfer_error(points1, points2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_dlt(points1, points2, weights_new)\n    return H",
        "mutated": [
            "def find_homography_dlt_iterated(points1: Tensor, points2: Tensor, weights: Tensor, soft_inl_th: float=3.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS).\\n\\n    The linear system is solved by using the Reweighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_dlt(points1, points2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = symmetric_transfer_error(points1, points2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_dlt(points1, points2, weights_new)\n    return H",
            "def find_homography_dlt_iterated(points1: Tensor, points2: Tensor, weights: Tensor, soft_inl_th: float=3.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS).\\n\\n    The linear system is solved by using the Reweighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_dlt(points1, points2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = symmetric_transfer_error(points1, points2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_dlt(points1, points2, weights_new)\n    return H",
            "def find_homography_dlt_iterated(points1: Tensor, points2: Tensor, weights: Tensor, soft_inl_th: float=3.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS).\\n\\n    The linear system is solved by using the Reweighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_dlt(points1, points2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = symmetric_transfer_error(points1, points2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_dlt(points1, points2, weights_new)\n    return H",
            "def find_homography_dlt_iterated(points1: Tensor, points2: Tensor, weights: Tensor, soft_inl_th: float=3.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS).\\n\\n    The linear system is solved by using the Reweighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_dlt(points1, points2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = symmetric_transfer_error(points1, points2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_dlt(points1, points2, weights_new)\n    return H",
            "def find_homography_dlt_iterated(points1: Tensor, points2: Tensor, weights: Tensor, soft_inl_th: float=3.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS).\\n\\n    The linear system is solved by using the Reweighted Least Squares Solution for the 4 Points algorithm.\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, N, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, N, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_dlt(points1, points2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = symmetric_transfer_error(points1, points2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_dlt(points1, points2, weights_new)\n    return H"
        ]
    },
    {
        "func_name": "sample_is_valid_for_homography",
        "original": "def sample_is_valid_for_homography(points1: Tensor, points2: Tensor) -> Tensor:\n    \"\"\"Function, which implements oriented constraint check from :cite:`Marquez-Neila2015`.\n\n    Analogous to https://github.com/opencv/opencv/blob/4.x/modules/calib3d/src/usac/degeneracy.cpp#L88\n\n    Args:\n        points1: A set of points in the first image with a tensor shape :math:`(B, 4, 2)`.\n        points2: A set of points in the second image with a tensor shape :math:`(B, 4, 2)`.\n\n    Returns:\n        Mask with the minimal sample is good for homography estimation:math:`(B, 3, 3)`.\n    \"\"\"\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', '4', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', '4', '2'])\n    device = points1.device\n    idx_perm = torch.tensor([[0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]], dtype=torch.long, device=device)\n    points_src_h = convert_points_to_homogeneous(points1)\n    points_dst_h = convert_points_to_homogeneous(points2)\n    src_perm = points_src_h[:, idx_perm]\n    dst_perm = points_dst_h[:, idx_perm]\n    left_sign = (torch.cross(src_perm[..., 1:2, :], src_perm[..., 2:3, :]) @ src_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    right_sign = (torch.cross(dst_perm[..., 1:2, :], dst_perm[..., 2:3, :]) @ dst_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    sample_is_valid = (left_sign == right_sign).view(-1, 4).min(dim=1)[0]\n    return sample_is_valid",
        "mutated": [
            "def sample_is_valid_for_homography(points1: Tensor, points2: Tensor) -> Tensor:\n    if False:\n        i = 10\n    'Function, which implements oriented constraint check from :cite:`Marquez-Neila2015`.\\n\\n    Analogous to https://github.com/opencv/opencv/blob/4.x/modules/calib3d/src/usac/degeneracy.cpp#L88\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, 4, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, 4, 2)`.\\n\\n    Returns:\\n        Mask with the minimal sample is good for homography estimation:math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', '4', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', '4', '2'])\n    device = points1.device\n    idx_perm = torch.tensor([[0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]], dtype=torch.long, device=device)\n    points_src_h = convert_points_to_homogeneous(points1)\n    points_dst_h = convert_points_to_homogeneous(points2)\n    src_perm = points_src_h[:, idx_perm]\n    dst_perm = points_dst_h[:, idx_perm]\n    left_sign = (torch.cross(src_perm[..., 1:2, :], src_perm[..., 2:3, :]) @ src_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    right_sign = (torch.cross(dst_perm[..., 1:2, :], dst_perm[..., 2:3, :]) @ dst_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    sample_is_valid = (left_sign == right_sign).view(-1, 4).min(dim=1)[0]\n    return sample_is_valid",
            "def sample_is_valid_for_homography(points1: Tensor, points2: Tensor) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Function, which implements oriented constraint check from :cite:`Marquez-Neila2015`.\\n\\n    Analogous to https://github.com/opencv/opencv/blob/4.x/modules/calib3d/src/usac/degeneracy.cpp#L88\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, 4, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, 4, 2)`.\\n\\n    Returns:\\n        Mask with the minimal sample is good for homography estimation:math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', '4', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', '4', '2'])\n    device = points1.device\n    idx_perm = torch.tensor([[0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]], dtype=torch.long, device=device)\n    points_src_h = convert_points_to_homogeneous(points1)\n    points_dst_h = convert_points_to_homogeneous(points2)\n    src_perm = points_src_h[:, idx_perm]\n    dst_perm = points_dst_h[:, idx_perm]\n    left_sign = (torch.cross(src_perm[..., 1:2, :], src_perm[..., 2:3, :]) @ src_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    right_sign = (torch.cross(dst_perm[..., 1:2, :], dst_perm[..., 2:3, :]) @ dst_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    sample_is_valid = (left_sign == right_sign).view(-1, 4).min(dim=1)[0]\n    return sample_is_valid",
            "def sample_is_valid_for_homography(points1: Tensor, points2: Tensor) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Function, which implements oriented constraint check from :cite:`Marquez-Neila2015`.\\n\\n    Analogous to https://github.com/opencv/opencv/blob/4.x/modules/calib3d/src/usac/degeneracy.cpp#L88\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, 4, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, 4, 2)`.\\n\\n    Returns:\\n        Mask with the minimal sample is good for homography estimation:math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', '4', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', '4', '2'])\n    device = points1.device\n    idx_perm = torch.tensor([[0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]], dtype=torch.long, device=device)\n    points_src_h = convert_points_to_homogeneous(points1)\n    points_dst_h = convert_points_to_homogeneous(points2)\n    src_perm = points_src_h[:, idx_perm]\n    dst_perm = points_dst_h[:, idx_perm]\n    left_sign = (torch.cross(src_perm[..., 1:2, :], src_perm[..., 2:3, :]) @ src_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    right_sign = (torch.cross(dst_perm[..., 1:2, :], dst_perm[..., 2:3, :]) @ dst_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    sample_is_valid = (left_sign == right_sign).view(-1, 4).min(dim=1)[0]\n    return sample_is_valid",
            "def sample_is_valid_for_homography(points1: Tensor, points2: Tensor) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Function, which implements oriented constraint check from :cite:`Marquez-Neila2015`.\\n\\n    Analogous to https://github.com/opencv/opencv/blob/4.x/modules/calib3d/src/usac/degeneracy.cpp#L88\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, 4, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, 4, 2)`.\\n\\n    Returns:\\n        Mask with the minimal sample is good for homography estimation:math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', '4', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', '4', '2'])\n    device = points1.device\n    idx_perm = torch.tensor([[0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]], dtype=torch.long, device=device)\n    points_src_h = convert_points_to_homogeneous(points1)\n    points_dst_h = convert_points_to_homogeneous(points2)\n    src_perm = points_src_h[:, idx_perm]\n    dst_perm = points_dst_h[:, idx_perm]\n    left_sign = (torch.cross(src_perm[..., 1:2, :], src_perm[..., 2:3, :]) @ src_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    right_sign = (torch.cross(dst_perm[..., 1:2, :], dst_perm[..., 2:3, :]) @ dst_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    sample_is_valid = (left_sign == right_sign).view(-1, 4).min(dim=1)[0]\n    return sample_is_valid",
            "def sample_is_valid_for_homography(points1: Tensor, points2: Tensor) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Function, which implements oriented constraint check from :cite:`Marquez-Neila2015`.\\n\\n    Analogous to https://github.com/opencv/opencv/blob/4.x/modules/calib3d/src/usac/degeneracy.cpp#L88\\n\\n    Args:\\n        points1: A set of points in the first image with a tensor shape :math:`(B, 4, 2)`.\\n        points2: A set of points in the second image with a tensor shape :math:`(B, 4, 2)`.\\n\\n    Returns:\\n        Mask with the minimal sample is good for homography estimation:math:`(B, 3, 3)`.\\n    '\n    if points1.shape != points2.shape:\n        raise AssertionError(points1.shape)\n    KORNIA_CHECK_SHAPE(points1, ['B', '4', '2'])\n    KORNIA_CHECK_SHAPE(points2, ['B', '4', '2'])\n    device = points1.device\n    idx_perm = torch.tensor([[0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]], dtype=torch.long, device=device)\n    points_src_h = convert_points_to_homogeneous(points1)\n    points_dst_h = convert_points_to_homogeneous(points2)\n    src_perm = points_src_h[:, idx_perm]\n    dst_perm = points_dst_h[:, idx_perm]\n    left_sign = (torch.cross(src_perm[..., 1:2, :], src_perm[..., 2:3, :]) @ src_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    right_sign = (torch.cross(dst_perm[..., 1:2, :], dst_perm[..., 2:3, :]) @ dst_perm[..., 0:1, :].permute(0, 1, 3, 2)).sign()\n    sample_is_valid = (left_sign == right_sign).view(-1, 4).min(dim=1)[0]\n    return sample_is_valid"
        ]
    },
    {
        "func_name": "find_homography_lines_dlt",
        "original": "def find_homography_lines_dlt(ls1: Tensor, ls2: Tensor, weights: Optional[Tensor]=None) -> Tensor:\n    \"\"\"Compute the homography matrix using the DLT formulation for line correspondences.\n\n    See :cite:`homolines2001` for details.\n\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Line correspondences algorithm.\n\n    Args:\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\n\n    Returns:\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\n    \"\"\"\n    if len(ls1.shape) == 3:\n        ls1 = ls1[None]\n    if len(ls2.shape) == 3:\n        ls2 = ls2[None]\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (BS, N) = ls1.shape[:2]\n    (device, dtype) = _extract_device_dtype([ls1, ls2])\n    points1 = ls1.reshape(BS, 2 * N, 2)\n    points2 = ls2.reshape(BS, 2 * N, 2)\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (lst1, le1) = torch.chunk(points1_norm, dim=1, chunks=2)\n    (lst2, le2) = torch.chunk(points2_norm, dim=1, chunks=2)\n    (xs1, ys1) = torch.chunk(lst1, dim=-1, chunks=2)\n    (xs2, ys2) = torch.chunk(lst2, dim=-1, chunks=2)\n    (xe1, ye1) = torch.chunk(le1, dim=-1, chunks=2)\n    (xe2, ye2) = torch.chunk(le2, dim=-1, chunks=2)\n    A = ys2 - ye2\n    B = xe2 - xs2\n    C = xs2 * ye2 - xe2 * ys2\n    eps: float = 1e-08\n    ax = torch.cat([A * xs1, A * ys1, A, B * xs1, B * ys1, B, C * xs1, C * ys1, C], dim=-1)\n    ay = torch.cat([A * xe1, A * ye1, A, B * xe1, B * ye1, B, C * xe1, C * ye1, C], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == ls1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    try:\n        (_, _, V) = torch.svd(A)\n    except RuntimeError:\n        warnings.warn('SVD did not converge', RuntimeWarning)\n        return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n    H = V[..., -1].view(-1, 3, 3)\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
        "mutated": [
            "def find_homography_lines_dlt(ls1: Tensor, ls2: Tensor, weights: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n    'Compute the homography matrix using the DLT formulation for line correspondences.\\n\\n    See :cite:`homolines2001` for details.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Line correspondences algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if len(ls1.shape) == 3:\n        ls1 = ls1[None]\n    if len(ls2.shape) == 3:\n        ls2 = ls2[None]\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (BS, N) = ls1.shape[:2]\n    (device, dtype) = _extract_device_dtype([ls1, ls2])\n    points1 = ls1.reshape(BS, 2 * N, 2)\n    points2 = ls2.reshape(BS, 2 * N, 2)\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (lst1, le1) = torch.chunk(points1_norm, dim=1, chunks=2)\n    (lst2, le2) = torch.chunk(points2_norm, dim=1, chunks=2)\n    (xs1, ys1) = torch.chunk(lst1, dim=-1, chunks=2)\n    (xs2, ys2) = torch.chunk(lst2, dim=-1, chunks=2)\n    (xe1, ye1) = torch.chunk(le1, dim=-1, chunks=2)\n    (xe2, ye2) = torch.chunk(le2, dim=-1, chunks=2)\n    A = ys2 - ye2\n    B = xe2 - xs2\n    C = xs2 * ye2 - xe2 * ys2\n    eps: float = 1e-08\n    ax = torch.cat([A * xs1, A * ys1, A, B * xs1, B * ys1, B, C * xs1, C * ys1, C], dim=-1)\n    ay = torch.cat([A * xe1, A * ye1, A, B * xe1, B * ye1, B, C * xe1, C * ye1, C], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == ls1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    try:\n        (_, _, V) = torch.svd(A)\n    except RuntimeError:\n        warnings.warn('SVD did not converge', RuntimeWarning)\n        return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n    H = V[..., -1].view(-1, 3, 3)\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
            "def find_homography_lines_dlt(ls1: Tensor, ls2: Tensor, weights: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the homography matrix using the DLT formulation for line correspondences.\\n\\n    See :cite:`homolines2001` for details.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Line correspondences algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if len(ls1.shape) == 3:\n        ls1 = ls1[None]\n    if len(ls2.shape) == 3:\n        ls2 = ls2[None]\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (BS, N) = ls1.shape[:2]\n    (device, dtype) = _extract_device_dtype([ls1, ls2])\n    points1 = ls1.reshape(BS, 2 * N, 2)\n    points2 = ls2.reshape(BS, 2 * N, 2)\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (lst1, le1) = torch.chunk(points1_norm, dim=1, chunks=2)\n    (lst2, le2) = torch.chunk(points2_norm, dim=1, chunks=2)\n    (xs1, ys1) = torch.chunk(lst1, dim=-1, chunks=2)\n    (xs2, ys2) = torch.chunk(lst2, dim=-1, chunks=2)\n    (xe1, ye1) = torch.chunk(le1, dim=-1, chunks=2)\n    (xe2, ye2) = torch.chunk(le2, dim=-1, chunks=2)\n    A = ys2 - ye2\n    B = xe2 - xs2\n    C = xs2 * ye2 - xe2 * ys2\n    eps: float = 1e-08\n    ax = torch.cat([A * xs1, A * ys1, A, B * xs1, B * ys1, B, C * xs1, C * ys1, C], dim=-1)\n    ay = torch.cat([A * xe1, A * ye1, A, B * xe1, B * ye1, B, C * xe1, C * ye1, C], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == ls1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    try:\n        (_, _, V) = torch.svd(A)\n    except RuntimeError:\n        warnings.warn('SVD did not converge', RuntimeWarning)\n        return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n    H = V[..., -1].view(-1, 3, 3)\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
            "def find_homography_lines_dlt(ls1: Tensor, ls2: Tensor, weights: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the homography matrix using the DLT formulation for line correspondences.\\n\\n    See :cite:`homolines2001` for details.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Line correspondences algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if len(ls1.shape) == 3:\n        ls1 = ls1[None]\n    if len(ls2.shape) == 3:\n        ls2 = ls2[None]\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (BS, N) = ls1.shape[:2]\n    (device, dtype) = _extract_device_dtype([ls1, ls2])\n    points1 = ls1.reshape(BS, 2 * N, 2)\n    points2 = ls2.reshape(BS, 2 * N, 2)\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (lst1, le1) = torch.chunk(points1_norm, dim=1, chunks=2)\n    (lst2, le2) = torch.chunk(points2_norm, dim=1, chunks=2)\n    (xs1, ys1) = torch.chunk(lst1, dim=-1, chunks=2)\n    (xs2, ys2) = torch.chunk(lst2, dim=-1, chunks=2)\n    (xe1, ye1) = torch.chunk(le1, dim=-1, chunks=2)\n    (xe2, ye2) = torch.chunk(le2, dim=-1, chunks=2)\n    A = ys2 - ye2\n    B = xe2 - xs2\n    C = xs2 * ye2 - xe2 * ys2\n    eps: float = 1e-08\n    ax = torch.cat([A * xs1, A * ys1, A, B * xs1, B * ys1, B, C * xs1, C * ys1, C], dim=-1)\n    ay = torch.cat([A * xe1, A * ye1, A, B * xe1, B * ye1, B, C * xe1, C * ye1, C], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == ls1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    try:\n        (_, _, V) = torch.svd(A)\n    except RuntimeError:\n        warnings.warn('SVD did not converge', RuntimeWarning)\n        return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n    H = V[..., -1].view(-1, 3, 3)\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
            "def find_homography_lines_dlt(ls1: Tensor, ls2: Tensor, weights: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the homography matrix using the DLT formulation for line correspondences.\\n\\n    See :cite:`homolines2001` for details.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Line correspondences algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if len(ls1.shape) == 3:\n        ls1 = ls1[None]\n    if len(ls2.shape) == 3:\n        ls2 = ls2[None]\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (BS, N) = ls1.shape[:2]\n    (device, dtype) = _extract_device_dtype([ls1, ls2])\n    points1 = ls1.reshape(BS, 2 * N, 2)\n    points2 = ls2.reshape(BS, 2 * N, 2)\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (lst1, le1) = torch.chunk(points1_norm, dim=1, chunks=2)\n    (lst2, le2) = torch.chunk(points2_norm, dim=1, chunks=2)\n    (xs1, ys1) = torch.chunk(lst1, dim=-1, chunks=2)\n    (xs2, ys2) = torch.chunk(lst2, dim=-1, chunks=2)\n    (xe1, ye1) = torch.chunk(le1, dim=-1, chunks=2)\n    (xe2, ye2) = torch.chunk(le2, dim=-1, chunks=2)\n    A = ys2 - ye2\n    B = xe2 - xs2\n    C = xs2 * ye2 - xe2 * ys2\n    eps: float = 1e-08\n    ax = torch.cat([A * xs1, A * ys1, A, B * xs1, B * ys1, B, C * xs1, C * ys1, C], dim=-1)\n    ay = torch.cat([A * xe1, A * ye1, A, B * xe1, B * ye1, B, C * xe1, C * ye1, C], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == ls1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    try:\n        (_, _, V) = torch.svd(A)\n    except RuntimeError:\n        warnings.warn('SVD did not converge', RuntimeWarning)\n        return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n    H = V[..., -1].view(-1, 3, 3)\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm",
            "def find_homography_lines_dlt(ls1: Tensor, ls2: Tensor, weights: Optional[Tensor]=None) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the homography matrix using the DLT formulation for line correspondences.\\n\\n    See :cite:`homolines2001` for details.\\n\\n    The linear system is solved by using the Weighted Least Squares Solution for the 4 Line correspondences algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    if len(ls1.shape) == 3:\n        ls1 = ls1[None]\n    if len(ls2.shape) == 3:\n        ls2 = ls2[None]\n    KORNIA_CHECK_SHAPE(ls1, ['B', 'N', '2', '2'])\n    KORNIA_CHECK_SHAPE(ls2, ['B', 'N', '2', '2'])\n    (BS, N) = ls1.shape[:2]\n    (device, dtype) = _extract_device_dtype([ls1, ls2])\n    points1 = ls1.reshape(BS, 2 * N, 2)\n    points2 = ls2.reshape(BS, 2 * N, 2)\n    (points1_norm, transform1) = normalize_points(points1)\n    (points2_norm, transform2) = normalize_points(points2)\n    (lst1, le1) = torch.chunk(points1_norm, dim=1, chunks=2)\n    (lst2, le2) = torch.chunk(points2_norm, dim=1, chunks=2)\n    (xs1, ys1) = torch.chunk(lst1, dim=-1, chunks=2)\n    (xs2, ys2) = torch.chunk(lst2, dim=-1, chunks=2)\n    (xe1, ye1) = torch.chunk(le1, dim=-1, chunks=2)\n    (xe2, ye2) = torch.chunk(le2, dim=-1, chunks=2)\n    A = ys2 - ye2\n    B = xe2 - xs2\n    C = xs2 * ye2 - xe2 * ys2\n    eps: float = 1e-08\n    ax = torch.cat([A * xs1, A * ys1, A, B * xs1, B * ys1, B, C * xs1, C * ys1, C], dim=-1)\n    ay = torch.cat([A * xe1, A * ye1, A, B * xe1, B * ye1, B, C * xe1, C * ye1, C], dim=-1)\n    A = torch.cat((ax, ay), dim=-1).reshape(ax.shape[0], -1, ax.shape[-1])\n    if weights is None:\n        A = A.transpose(-2, -1) @ A\n    else:\n        if not (len(weights.shape) == 2 and weights.shape == ls1.shape[:2]):\n            raise AssertionError(weights.shape)\n        w_diag = torch.diag_embed(weights.unsqueeze(dim=-1).repeat(1, 1, 2).reshape(weights.shape[0], -1))\n        A = A.transpose(-2, -1) @ w_diag @ A\n    try:\n        (_, _, V) = torch.svd(A)\n    except RuntimeError:\n        warnings.warn('SVD did not converge', RuntimeWarning)\n        return torch.empty((points1_norm.size(0), 3, 3), device=device, dtype=dtype)\n    H = V[..., -1].view(-1, 3, 3)\n    H = transform2.inverse() @ (H @ transform1)\n    H_norm = H / (H[..., -1:, -1:] + eps)\n    return H_norm"
        ]
    },
    {
        "func_name": "find_homography_lines_dlt_iterated",
        "original": "def find_homography_lines_dlt_iterated(ls1: Tensor, ls2: Tensor, weights: Tensor, soft_inl_th: float=4.0, n_iter: int=5) -> Tensor:\n    \"\"\"Compute the homography matrix using the iteratively-reweighted least squares (IRWLS) from line segments. The\n    linear system is solved by using the Reweighted Least Squares Solution for the 4 line segments algorithm.\n\n    Args:\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\n          Used for the first iteration of the IRWLS.\n        soft_inl_th: Soft inlier threshold used for weight calculation.\n        n_iter: number of iterations.\n\n    Returns:\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\n    \"\"\"\n    H: Tensor = find_homography_lines_dlt(ls1, ls2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = line_segment_transfer_error_one_way(ls1, ls2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_lines_dlt(ls1, ls2, weights_new)\n    return H",
        "mutated": [
            "def find_homography_lines_dlt_iterated(ls1: Tensor, ls2: Tensor, weights: Tensor, soft_inl_th: float=4.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS) from line segments. The\\n    linear system is solved by using the Reweighted Least Squares Solution for the 4 line segments algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_lines_dlt(ls1, ls2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = line_segment_transfer_error_one_way(ls1, ls2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_lines_dlt(ls1, ls2, weights_new)\n    return H",
            "def find_homography_lines_dlt_iterated(ls1: Tensor, ls2: Tensor, weights: Tensor, soft_inl_th: float=4.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS) from line segments. The\\n    linear system is solved by using the Reweighted Least Squares Solution for the 4 line segments algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_lines_dlt(ls1, ls2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = line_segment_transfer_error_one_way(ls1, ls2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_lines_dlt(ls1, ls2, weights_new)\n    return H",
            "def find_homography_lines_dlt_iterated(ls1: Tensor, ls2: Tensor, weights: Tensor, soft_inl_th: float=4.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS) from line segments. The\\n    linear system is solved by using the Reweighted Least Squares Solution for the 4 line segments algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_lines_dlt(ls1, ls2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = line_segment_transfer_error_one_way(ls1, ls2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_lines_dlt(ls1, ls2, weights_new)\n    return H",
            "def find_homography_lines_dlt_iterated(ls1: Tensor, ls2: Tensor, weights: Tensor, soft_inl_th: float=4.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS) from line segments. The\\n    linear system is solved by using the Reweighted Least Squares Solution for the 4 line segments algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_lines_dlt(ls1, ls2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = line_segment_transfer_error_one_way(ls1, ls2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_lines_dlt(ls1, ls2, weights_new)\n    return H",
            "def find_homography_lines_dlt_iterated(ls1: Tensor, ls2: Tensor, weights: Tensor, soft_inl_th: float=4.0, n_iter: int=5) -> Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the homography matrix using the iteratively-reweighted least squares (IRWLS) from line segments. The\\n    linear system is solved by using the Reweighted Least Squares Solution for the 4 line segments algorithm.\\n\\n    Args:\\n        ls1: A set of line segments in the first image with a tensor shape :math:`(B, N, 2, 2)`.\\n        ls2: A set of line segments in the second image with a tensor shape :math:`(B, N, 2, 2)`.\\n        weights: Tensor containing the weights per point correspondence with a shape of :math:`(B, N)`.\\n          Used for the first iteration of the IRWLS.\\n        soft_inl_th: Soft inlier threshold used for weight calculation.\\n        n_iter: number of iterations.\\n\\n    Returns:\\n        the computed homography matrix with shape :math:`(B, 3, 3)`.\\n    '\n    H: Tensor = find_homography_lines_dlt(ls1, ls2, weights)\n    for _ in range(n_iter - 1):\n        errors: Tensor = line_segment_transfer_error_one_way(ls1, ls2, H, False)\n        weights_new: Tensor = torch.exp(-errors / (2.0 * soft_inl_th ** 2))\n        H = find_homography_lines_dlt(ls1, ls2, weights_new)\n    return H"
        ]
    }
]