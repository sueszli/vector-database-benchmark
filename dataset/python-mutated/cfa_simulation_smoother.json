[
    {
        "func_name": "__init__",
        "original": "def __init__(self, model, cfa_simulation_smoother_classes=None):\n    self.model = model\n    self.prefix_simulation_smoother_map = cfa_simulation_smoother_classes if cfa_simulation_smoother_classes is not None else tools.prefix_cfa_simulation_smoother_map.copy()\n    self._simulation_smoothers = {}\n    self._posterior_mean = None\n    self._posterior_cov_inv_chol = None\n    self._posterior_cov = None\n    self._simulated_state = None",
        "mutated": [
            "def __init__(self, model, cfa_simulation_smoother_classes=None):\n    if False:\n        i = 10\n    self.model = model\n    self.prefix_simulation_smoother_map = cfa_simulation_smoother_classes if cfa_simulation_smoother_classes is not None else tools.prefix_cfa_simulation_smoother_map.copy()\n    self._simulation_smoothers = {}\n    self._posterior_mean = None\n    self._posterior_cov_inv_chol = None\n    self._posterior_cov = None\n    self._simulated_state = None",
            "def __init__(self, model, cfa_simulation_smoother_classes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.model = model\n    self.prefix_simulation_smoother_map = cfa_simulation_smoother_classes if cfa_simulation_smoother_classes is not None else tools.prefix_cfa_simulation_smoother_map.copy()\n    self._simulation_smoothers = {}\n    self._posterior_mean = None\n    self._posterior_cov_inv_chol = None\n    self._posterior_cov = None\n    self._simulated_state = None",
            "def __init__(self, model, cfa_simulation_smoother_classes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.model = model\n    self.prefix_simulation_smoother_map = cfa_simulation_smoother_classes if cfa_simulation_smoother_classes is not None else tools.prefix_cfa_simulation_smoother_map.copy()\n    self._simulation_smoothers = {}\n    self._posterior_mean = None\n    self._posterior_cov_inv_chol = None\n    self._posterior_cov = None\n    self._simulated_state = None",
            "def __init__(self, model, cfa_simulation_smoother_classes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.model = model\n    self.prefix_simulation_smoother_map = cfa_simulation_smoother_classes if cfa_simulation_smoother_classes is not None else tools.prefix_cfa_simulation_smoother_map.copy()\n    self._simulation_smoothers = {}\n    self._posterior_mean = None\n    self._posterior_cov_inv_chol = None\n    self._posterior_cov = None\n    self._simulated_state = None",
            "def __init__(self, model, cfa_simulation_smoother_classes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.model = model\n    self.prefix_simulation_smoother_map = cfa_simulation_smoother_classes if cfa_simulation_smoother_classes is not None else tools.prefix_cfa_simulation_smoother_map.copy()\n    self._simulation_smoothers = {}\n    self._posterior_mean = None\n    self._posterior_cov_inv_chol = None\n    self._posterior_cov = None\n    self._simulated_state = None"
        ]
    },
    {
        "func_name": "_simulation_smoother",
        "original": "@property\ndef _simulation_smoother(self):\n    prefix = self.model.prefix\n    if prefix in self._simulation_smoothers:\n        return self._simulation_smoothers[prefix]\n    return None",
        "mutated": [
            "@property\ndef _simulation_smoother(self):\n    if False:\n        i = 10\n    prefix = self.model.prefix\n    if prefix in self._simulation_smoothers:\n        return self._simulation_smoothers[prefix]\n    return None",
            "@property\ndef _simulation_smoother(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    prefix = self.model.prefix\n    if prefix in self._simulation_smoothers:\n        return self._simulation_smoothers[prefix]\n    return None",
            "@property\ndef _simulation_smoother(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    prefix = self.model.prefix\n    if prefix in self._simulation_smoothers:\n        return self._simulation_smoothers[prefix]\n    return None",
            "@property\ndef _simulation_smoother(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    prefix = self.model.prefix\n    if prefix in self._simulation_smoothers:\n        return self._simulation_smoothers[prefix]\n    return None",
            "@property\ndef _simulation_smoother(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    prefix = self.model.prefix\n    if prefix in self._simulation_smoothers:\n        return self._simulation_smoothers[prefix]\n    return None"
        ]
    },
    {
        "func_name": "posterior_mean",
        "original": "@property\ndef posterior_mean(self):\n    \"\"\"\n        Posterior mean of the states conditional on the data\n\n        Notes\n        -----\n\n        .. math::\n\n            \\\\hat \\\\alpha_t = E[\\\\alpha_t \\\\mid Y^n ]\n\n        This posterior mean is identical to the `smoothed_state` computed by\n        the Kalman smoother.\n        \"\"\"\n    if self._posterior_mean is None:\n        self._posterior_mean = np.array(self._simulation_smoother.posterior_mean, copy=True)\n    return self._posterior_mean",
        "mutated": [
            "@property\ndef posterior_mean(self):\n    if False:\n        i = 10\n    '\\n        Posterior mean of the states conditional on the data\\n\\n        Notes\\n        -----\\n\\n        .. math::\\n\\n            \\\\hat \\\\alpha_t = E[\\\\alpha_t \\\\mid Y^n ]\\n\\n        This posterior mean is identical to the `smoothed_state` computed by\\n        the Kalman smoother.\\n        '\n    if self._posterior_mean is None:\n        self._posterior_mean = np.array(self._simulation_smoother.posterior_mean, copy=True)\n    return self._posterior_mean",
            "@property\ndef posterior_mean(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Posterior mean of the states conditional on the data\\n\\n        Notes\\n        -----\\n\\n        .. math::\\n\\n            \\\\hat \\\\alpha_t = E[\\\\alpha_t \\\\mid Y^n ]\\n\\n        This posterior mean is identical to the `smoothed_state` computed by\\n        the Kalman smoother.\\n        '\n    if self._posterior_mean is None:\n        self._posterior_mean = np.array(self._simulation_smoother.posterior_mean, copy=True)\n    return self._posterior_mean",
            "@property\ndef posterior_mean(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Posterior mean of the states conditional on the data\\n\\n        Notes\\n        -----\\n\\n        .. math::\\n\\n            \\\\hat \\\\alpha_t = E[\\\\alpha_t \\\\mid Y^n ]\\n\\n        This posterior mean is identical to the `smoothed_state` computed by\\n        the Kalman smoother.\\n        '\n    if self._posterior_mean is None:\n        self._posterior_mean = np.array(self._simulation_smoother.posterior_mean, copy=True)\n    return self._posterior_mean",
            "@property\ndef posterior_mean(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Posterior mean of the states conditional on the data\\n\\n        Notes\\n        -----\\n\\n        .. math::\\n\\n            \\\\hat \\\\alpha_t = E[\\\\alpha_t \\\\mid Y^n ]\\n\\n        This posterior mean is identical to the `smoothed_state` computed by\\n        the Kalman smoother.\\n        '\n    if self._posterior_mean is None:\n        self._posterior_mean = np.array(self._simulation_smoother.posterior_mean, copy=True)\n    return self._posterior_mean",
            "@property\ndef posterior_mean(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Posterior mean of the states conditional on the data\\n\\n        Notes\\n        -----\\n\\n        .. math::\\n\\n            \\\\hat \\\\alpha_t = E[\\\\alpha_t \\\\mid Y^n ]\\n\\n        This posterior mean is identical to the `smoothed_state` computed by\\n        the Kalman smoother.\\n        '\n    if self._posterior_mean is None:\n        self._posterior_mean = np.array(self._simulation_smoother.posterior_mean, copy=True)\n    return self._posterior_mean"
        ]
    },
    {
        "func_name": "posterior_cov_inv_chol_sparse",
        "original": "@property\ndef posterior_cov_inv_chol_sparse(self):\n    \"\"\"\n        Sparse Cholesky factor of inverse posterior covariance matrix\n\n        Notes\n        -----\n        This attribute holds in sparse diagonal banded storage the Cholesky\n        factor of the inverse of the posterior covariance matrix. If we denote\n        :math:`P = Var[\\\\alpha \\\\mid Y^n ]`, then the this attribute holds the\n        lower Cholesky factor :math:`L`, defined from :math:`L L' = P^{-1}`.\n        This attribute uses the sparse diagonal banded storage described in the\n        documentation of, for example, the SciPy function\n        `scipy.linalg.solveh_banded`.\n        \"\"\"\n    if self._posterior_cov_inv_chol is None:\n        self._posterior_cov_inv_chol = np.array(self._simulation_smoother.posterior_cov_inv_chol, copy=True)\n    return self._posterior_cov_inv_chol",
        "mutated": [
            "@property\ndef posterior_cov_inv_chol_sparse(self):\n    if False:\n        i = 10\n    \"\\n        Sparse Cholesky factor of inverse posterior covariance matrix\\n\\n        Notes\\n        -----\\n        This attribute holds in sparse diagonal banded storage the Cholesky\\n        factor of the inverse of the posterior covariance matrix. If we denote\\n        :math:`P = Var[\\\\alpha \\\\mid Y^n ]`, then the this attribute holds the\\n        lower Cholesky factor :math:`L`, defined from :math:`L L' = P^{-1}`.\\n        This attribute uses the sparse diagonal banded storage described in the\\n        documentation of, for example, the SciPy function\\n        `scipy.linalg.solveh_banded`.\\n        \"\n    if self._posterior_cov_inv_chol is None:\n        self._posterior_cov_inv_chol = np.array(self._simulation_smoother.posterior_cov_inv_chol, copy=True)\n    return self._posterior_cov_inv_chol",
            "@property\ndef posterior_cov_inv_chol_sparse(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Sparse Cholesky factor of inverse posterior covariance matrix\\n\\n        Notes\\n        -----\\n        This attribute holds in sparse diagonal banded storage the Cholesky\\n        factor of the inverse of the posterior covariance matrix. If we denote\\n        :math:`P = Var[\\\\alpha \\\\mid Y^n ]`, then the this attribute holds the\\n        lower Cholesky factor :math:`L`, defined from :math:`L L' = P^{-1}`.\\n        This attribute uses the sparse diagonal banded storage described in the\\n        documentation of, for example, the SciPy function\\n        `scipy.linalg.solveh_banded`.\\n        \"\n    if self._posterior_cov_inv_chol is None:\n        self._posterior_cov_inv_chol = np.array(self._simulation_smoother.posterior_cov_inv_chol, copy=True)\n    return self._posterior_cov_inv_chol",
            "@property\ndef posterior_cov_inv_chol_sparse(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Sparse Cholesky factor of inverse posterior covariance matrix\\n\\n        Notes\\n        -----\\n        This attribute holds in sparse diagonal banded storage the Cholesky\\n        factor of the inverse of the posterior covariance matrix. If we denote\\n        :math:`P = Var[\\\\alpha \\\\mid Y^n ]`, then the this attribute holds the\\n        lower Cholesky factor :math:`L`, defined from :math:`L L' = P^{-1}`.\\n        This attribute uses the sparse diagonal banded storage described in the\\n        documentation of, for example, the SciPy function\\n        `scipy.linalg.solveh_banded`.\\n        \"\n    if self._posterior_cov_inv_chol is None:\n        self._posterior_cov_inv_chol = np.array(self._simulation_smoother.posterior_cov_inv_chol, copy=True)\n    return self._posterior_cov_inv_chol",
            "@property\ndef posterior_cov_inv_chol_sparse(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Sparse Cholesky factor of inverse posterior covariance matrix\\n\\n        Notes\\n        -----\\n        This attribute holds in sparse diagonal banded storage the Cholesky\\n        factor of the inverse of the posterior covariance matrix. If we denote\\n        :math:`P = Var[\\\\alpha \\\\mid Y^n ]`, then the this attribute holds the\\n        lower Cholesky factor :math:`L`, defined from :math:`L L' = P^{-1}`.\\n        This attribute uses the sparse diagonal banded storage described in the\\n        documentation of, for example, the SciPy function\\n        `scipy.linalg.solveh_banded`.\\n        \"\n    if self._posterior_cov_inv_chol is None:\n        self._posterior_cov_inv_chol = np.array(self._simulation_smoother.posterior_cov_inv_chol, copy=True)\n    return self._posterior_cov_inv_chol",
            "@property\ndef posterior_cov_inv_chol_sparse(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Sparse Cholesky factor of inverse posterior covariance matrix\\n\\n        Notes\\n        -----\\n        This attribute holds in sparse diagonal banded storage the Cholesky\\n        factor of the inverse of the posterior covariance matrix. If we denote\\n        :math:`P = Var[\\\\alpha \\\\mid Y^n ]`, then the this attribute holds the\\n        lower Cholesky factor :math:`L`, defined from :math:`L L' = P^{-1}`.\\n        This attribute uses the sparse diagonal banded storage described in the\\n        documentation of, for example, the SciPy function\\n        `scipy.linalg.solveh_banded`.\\n        \"\n    if self._posterior_cov_inv_chol is None:\n        self._posterior_cov_inv_chol = np.array(self._simulation_smoother.posterior_cov_inv_chol, copy=True)\n    return self._posterior_cov_inv_chol"
        ]
    },
    {
        "func_name": "posterior_cov",
        "original": "@property\ndef posterior_cov(self):\n    \"\"\"\n        Posterior covariance of the states conditional on the data\n\n        Notes\n        -----\n        **Warning**: the matrix computed when accessing this property can be\n        extremely large: it is shaped `(nobs * k_states, nobs * k_states)`. In\n        most cases, it is better to use the `posterior_cov_inv_chol_sparse`\n        property if possible, which holds in sparse diagonal banded storage\n        the Cholesky factor of the inverse of the posterior covariance matrix.\n\n        .. math::\n\n            Var[\\\\alpha \\\\mid Y^n ]\n\n        This posterior covariance matrix is *not* identical to the\n        `smoothed_state_cov` attribute produced by the Kalman smoother, because\n        it additionally contains all cross-covariance terms. Instead,\n        `smoothed_state_cov` contains the `(k_states, k_states)` block\n        diagonal entries of this posterior covariance matrix.\n        \"\"\"\n    if self._posterior_cov is None:\n        from scipy.linalg import cho_solve_banded\n        inv_chol = self.posterior_cov_inv_chol_sparse\n        self._posterior_cov = cho_solve_banded((inv_chol, True), np.eye(inv_chol.shape[1]))\n    return self._posterior_cov",
        "mutated": [
            "@property\ndef posterior_cov(self):\n    if False:\n        i = 10\n    '\\n        Posterior covariance of the states conditional on the data\\n\\n        Notes\\n        -----\\n        **Warning**: the matrix computed when accessing this property can be\\n        extremely large: it is shaped `(nobs * k_states, nobs * k_states)`. In\\n        most cases, it is better to use the `posterior_cov_inv_chol_sparse`\\n        property if possible, which holds in sparse diagonal banded storage\\n        the Cholesky factor of the inverse of the posterior covariance matrix.\\n\\n        .. math::\\n\\n            Var[\\\\alpha \\\\mid Y^n ]\\n\\n        This posterior covariance matrix is *not* identical to the\\n        `smoothed_state_cov` attribute produced by the Kalman smoother, because\\n        it additionally contains all cross-covariance terms. Instead,\\n        `smoothed_state_cov` contains the `(k_states, k_states)` block\\n        diagonal entries of this posterior covariance matrix.\\n        '\n    if self._posterior_cov is None:\n        from scipy.linalg import cho_solve_banded\n        inv_chol = self.posterior_cov_inv_chol_sparse\n        self._posterior_cov = cho_solve_banded((inv_chol, True), np.eye(inv_chol.shape[1]))\n    return self._posterior_cov",
            "@property\ndef posterior_cov(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Posterior covariance of the states conditional on the data\\n\\n        Notes\\n        -----\\n        **Warning**: the matrix computed when accessing this property can be\\n        extremely large: it is shaped `(nobs * k_states, nobs * k_states)`. In\\n        most cases, it is better to use the `posterior_cov_inv_chol_sparse`\\n        property if possible, which holds in sparse diagonal banded storage\\n        the Cholesky factor of the inverse of the posterior covariance matrix.\\n\\n        .. math::\\n\\n            Var[\\\\alpha \\\\mid Y^n ]\\n\\n        This posterior covariance matrix is *not* identical to the\\n        `smoothed_state_cov` attribute produced by the Kalman smoother, because\\n        it additionally contains all cross-covariance terms. Instead,\\n        `smoothed_state_cov` contains the `(k_states, k_states)` block\\n        diagonal entries of this posterior covariance matrix.\\n        '\n    if self._posterior_cov is None:\n        from scipy.linalg import cho_solve_banded\n        inv_chol = self.posterior_cov_inv_chol_sparse\n        self._posterior_cov = cho_solve_banded((inv_chol, True), np.eye(inv_chol.shape[1]))\n    return self._posterior_cov",
            "@property\ndef posterior_cov(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Posterior covariance of the states conditional on the data\\n\\n        Notes\\n        -----\\n        **Warning**: the matrix computed when accessing this property can be\\n        extremely large: it is shaped `(nobs * k_states, nobs * k_states)`. In\\n        most cases, it is better to use the `posterior_cov_inv_chol_sparse`\\n        property if possible, which holds in sparse diagonal banded storage\\n        the Cholesky factor of the inverse of the posterior covariance matrix.\\n\\n        .. math::\\n\\n            Var[\\\\alpha \\\\mid Y^n ]\\n\\n        This posterior covariance matrix is *not* identical to the\\n        `smoothed_state_cov` attribute produced by the Kalman smoother, because\\n        it additionally contains all cross-covariance terms. Instead,\\n        `smoothed_state_cov` contains the `(k_states, k_states)` block\\n        diagonal entries of this posterior covariance matrix.\\n        '\n    if self._posterior_cov is None:\n        from scipy.linalg import cho_solve_banded\n        inv_chol = self.posterior_cov_inv_chol_sparse\n        self._posterior_cov = cho_solve_banded((inv_chol, True), np.eye(inv_chol.shape[1]))\n    return self._posterior_cov",
            "@property\ndef posterior_cov(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Posterior covariance of the states conditional on the data\\n\\n        Notes\\n        -----\\n        **Warning**: the matrix computed when accessing this property can be\\n        extremely large: it is shaped `(nobs * k_states, nobs * k_states)`. In\\n        most cases, it is better to use the `posterior_cov_inv_chol_sparse`\\n        property if possible, which holds in sparse diagonal banded storage\\n        the Cholesky factor of the inverse of the posterior covariance matrix.\\n\\n        .. math::\\n\\n            Var[\\\\alpha \\\\mid Y^n ]\\n\\n        This posterior covariance matrix is *not* identical to the\\n        `smoothed_state_cov` attribute produced by the Kalman smoother, because\\n        it additionally contains all cross-covariance terms. Instead,\\n        `smoothed_state_cov` contains the `(k_states, k_states)` block\\n        diagonal entries of this posterior covariance matrix.\\n        '\n    if self._posterior_cov is None:\n        from scipy.linalg import cho_solve_banded\n        inv_chol = self.posterior_cov_inv_chol_sparse\n        self._posterior_cov = cho_solve_banded((inv_chol, True), np.eye(inv_chol.shape[1]))\n    return self._posterior_cov",
            "@property\ndef posterior_cov(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Posterior covariance of the states conditional on the data\\n\\n        Notes\\n        -----\\n        **Warning**: the matrix computed when accessing this property can be\\n        extremely large: it is shaped `(nobs * k_states, nobs * k_states)`. In\\n        most cases, it is better to use the `posterior_cov_inv_chol_sparse`\\n        property if possible, which holds in sparse diagonal banded storage\\n        the Cholesky factor of the inverse of the posterior covariance matrix.\\n\\n        .. math::\\n\\n            Var[\\\\alpha \\\\mid Y^n ]\\n\\n        This posterior covariance matrix is *not* identical to the\\n        `smoothed_state_cov` attribute produced by the Kalman smoother, because\\n        it additionally contains all cross-covariance terms. Instead,\\n        `smoothed_state_cov` contains the `(k_states, k_states)` block\\n        diagonal entries of this posterior covariance matrix.\\n        '\n    if self._posterior_cov is None:\n        from scipy.linalg import cho_solve_banded\n        inv_chol = self.posterior_cov_inv_chol_sparse\n        self._posterior_cov = cho_solve_banded((inv_chol, True), np.eye(inv_chol.shape[1]))\n    return self._posterior_cov"
        ]
    },
    {
        "func_name": "simulate",
        "original": "def simulate(self, variates=None, update_posterior=True):\n    \"\"\"\n        Perform simulation smoothing (via Cholesky factor algorithm)\n\n        Does not return anything, but populates the object's `simulated_state`\n        attribute, and also makes available the attributes `posterior_mean`,\n        `posterior_cov`, and `posterior_cov_inv_chol_sparse`.\n\n        Parameters\n        ----------\n        variates : array_like, optional\n            Random variates, distributed standard Normal. Usually only\n            specified if results are to be replicated (e.g. to enforce a seed)\n            or for testing. If not specified, random variates are drawn. Must\n            be shaped (nobs, k_states).\n\n        Notes\n        -----\n        The first step in simulating from the joint posterior of the state\n        vector conditional on the data is to compute the two relevant moments\n        of the joint posterior distribution:\n\n        .. math::\n\n            \\\\alpha \\\\mid Y_n \\\\sim N(\\\\hat \\\\alpha, Var(\\\\alpha \\\\mid Y_n))\n\n        Let :math:`L L' = Var(\\\\alpha \\\\mid Y_n)^{-1}`. Then simulation proceeds\n        according to the following steps:\n\n        1. Draw :math:`u \\\\sim N(0, I)`\n        2. Compute :math:`x = \\\\hat \\\\alpha + (L')^{-1} u`\n\n        And then :math:`x` is a draw from the joint posterior of the states.\n        The output of the function is as follows:\n\n        - The simulated draw :math:`x` is held in the `simulated_state`\n          attribute.\n        - The posterior mean :math:`\\\\hat \\\\alpha` is held in the\n          `posterior_mean` attribute.\n        - The (lower triangular) Cholesky factor of the inverse posterior\n          covariance matrix, :math:`L`, is held in sparse diagonal banded\n          storage in the `posterior_cov_inv_chol` attribute.\n        - The posterior covariance matrix :math:`Var(\\\\alpha \\\\mid Y_n)` can be\n          computed on demand by accessing the `posterior_cov` property. Note\n          that this matrix can be extremely large, so care must be taken when\n          accessing this property. In most cases, it will be preferred to make\n          use of the `posterior_cov_inv_chol` attribute rather than the\n          `posterior_cov` attribute.\n\n        \"\"\"\n    (prefix, dtype, create) = self.model._initialize_representation()\n    if variates is not None:\n        tools.validate_matrix_shape('variates', variates.shape, self.model.k_states, self.model.nobs, 1)\n        variates = np.ravel(variates, order='F').astype(dtype)\n    self.model._initialize_state(prefix=prefix)\n    if create or prefix not in self._simulation_smoothers:\n        cls = self.prefix_simulation_smoother_map[prefix]\n        self._simulation_smoothers[prefix] = cls(self.model._statespaces[prefix])\n    sim = self._simulation_smoothers[prefix]\n    if update_posterior:\n        sim.update_sparse_posterior_moments()\n        self._posterior_mean = None\n        self._posterior_cov_inv_chol = None\n        self._posterior_cov = None\n    self.simulated_state = sim.simulate(variates=variates)",
        "mutated": [
            "def simulate(self, variates=None, update_posterior=True):\n    if False:\n        i = 10\n    \"\\n        Perform simulation smoothing (via Cholesky factor algorithm)\\n\\n        Does not return anything, but populates the object's `simulated_state`\\n        attribute, and also makes available the attributes `posterior_mean`,\\n        `posterior_cov`, and `posterior_cov_inv_chol_sparse`.\\n\\n        Parameters\\n        ----------\\n        variates : array_like, optional\\n            Random variates, distributed standard Normal. Usually only\\n            specified if results are to be replicated (e.g. to enforce a seed)\\n            or for testing. If not specified, random variates are drawn. Must\\n            be shaped (nobs, k_states).\\n\\n        Notes\\n        -----\\n        The first step in simulating from the joint posterior of the state\\n        vector conditional on the data is to compute the two relevant moments\\n        of the joint posterior distribution:\\n\\n        .. math::\\n\\n            \\\\alpha \\\\mid Y_n \\\\sim N(\\\\hat \\\\alpha, Var(\\\\alpha \\\\mid Y_n))\\n\\n        Let :math:`L L' = Var(\\\\alpha \\\\mid Y_n)^{-1}`. Then simulation proceeds\\n        according to the following steps:\\n\\n        1. Draw :math:`u \\\\sim N(0, I)`\\n        2. Compute :math:`x = \\\\hat \\\\alpha + (L')^{-1} u`\\n\\n        And then :math:`x` is a draw from the joint posterior of the states.\\n        The output of the function is as follows:\\n\\n        - The simulated draw :math:`x` is held in the `simulated_state`\\n          attribute.\\n        - The posterior mean :math:`\\\\hat \\\\alpha` is held in the\\n          `posterior_mean` attribute.\\n        - The (lower triangular) Cholesky factor of the inverse posterior\\n          covariance matrix, :math:`L`, is held in sparse diagonal banded\\n          storage in the `posterior_cov_inv_chol` attribute.\\n        - The posterior covariance matrix :math:`Var(\\\\alpha \\\\mid Y_n)` can be\\n          computed on demand by accessing the `posterior_cov` property. Note\\n          that this matrix can be extremely large, so care must be taken when\\n          accessing this property. In most cases, it will be preferred to make\\n          use of the `posterior_cov_inv_chol` attribute rather than the\\n          `posterior_cov` attribute.\\n\\n        \"\n    (prefix, dtype, create) = self.model._initialize_representation()\n    if variates is not None:\n        tools.validate_matrix_shape('variates', variates.shape, self.model.k_states, self.model.nobs, 1)\n        variates = np.ravel(variates, order='F').astype(dtype)\n    self.model._initialize_state(prefix=prefix)\n    if create or prefix not in self._simulation_smoothers:\n        cls = self.prefix_simulation_smoother_map[prefix]\n        self._simulation_smoothers[prefix] = cls(self.model._statespaces[prefix])\n    sim = self._simulation_smoothers[prefix]\n    if update_posterior:\n        sim.update_sparse_posterior_moments()\n        self._posterior_mean = None\n        self._posterior_cov_inv_chol = None\n        self._posterior_cov = None\n    self.simulated_state = sim.simulate(variates=variates)",
            "def simulate(self, variates=None, update_posterior=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Perform simulation smoothing (via Cholesky factor algorithm)\\n\\n        Does not return anything, but populates the object's `simulated_state`\\n        attribute, and also makes available the attributes `posterior_mean`,\\n        `posterior_cov`, and `posterior_cov_inv_chol_sparse`.\\n\\n        Parameters\\n        ----------\\n        variates : array_like, optional\\n            Random variates, distributed standard Normal. Usually only\\n            specified if results are to be replicated (e.g. to enforce a seed)\\n            or for testing. If not specified, random variates are drawn. Must\\n            be shaped (nobs, k_states).\\n\\n        Notes\\n        -----\\n        The first step in simulating from the joint posterior of the state\\n        vector conditional on the data is to compute the two relevant moments\\n        of the joint posterior distribution:\\n\\n        .. math::\\n\\n            \\\\alpha \\\\mid Y_n \\\\sim N(\\\\hat \\\\alpha, Var(\\\\alpha \\\\mid Y_n))\\n\\n        Let :math:`L L' = Var(\\\\alpha \\\\mid Y_n)^{-1}`. Then simulation proceeds\\n        according to the following steps:\\n\\n        1. Draw :math:`u \\\\sim N(0, I)`\\n        2. Compute :math:`x = \\\\hat \\\\alpha + (L')^{-1} u`\\n\\n        And then :math:`x` is a draw from the joint posterior of the states.\\n        The output of the function is as follows:\\n\\n        - The simulated draw :math:`x` is held in the `simulated_state`\\n          attribute.\\n        - The posterior mean :math:`\\\\hat \\\\alpha` is held in the\\n          `posterior_mean` attribute.\\n        - The (lower triangular) Cholesky factor of the inverse posterior\\n          covariance matrix, :math:`L`, is held in sparse diagonal banded\\n          storage in the `posterior_cov_inv_chol` attribute.\\n        - The posterior covariance matrix :math:`Var(\\\\alpha \\\\mid Y_n)` can be\\n          computed on demand by accessing the `posterior_cov` property. Note\\n          that this matrix can be extremely large, so care must be taken when\\n          accessing this property. In most cases, it will be preferred to make\\n          use of the `posterior_cov_inv_chol` attribute rather than the\\n          `posterior_cov` attribute.\\n\\n        \"\n    (prefix, dtype, create) = self.model._initialize_representation()\n    if variates is not None:\n        tools.validate_matrix_shape('variates', variates.shape, self.model.k_states, self.model.nobs, 1)\n        variates = np.ravel(variates, order='F').astype(dtype)\n    self.model._initialize_state(prefix=prefix)\n    if create or prefix not in self._simulation_smoothers:\n        cls = self.prefix_simulation_smoother_map[prefix]\n        self._simulation_smoothers[prefix] = cls(self.model._statespaces[prefix])\n    sim = self._simulation_smoothers[prefix]\n    if update_posterior:\n        sim.update_sparse_posterior_moments()\n        self._posterior_mean = None\n        self._posterior_cov_inv_chol = None\n        self._posterior_cov = None\n    self.simulated_state = sim.simulate(variates=variates)",
            "def simulate(self, variates=None, update_posterior=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Perform simulation smoothing (via Cholesky factor algorithm)\\n\\n        Does not return anything, but populates the object's `simulated_state`\\n        attribute, and also makes available the attributes `posterior_mean`,\\n        `posterior_cov`, and `posterior_cov_inv_chol_sparse`.\\n\\n        Parameters\\n        ----------\\n        variates : array_like, optional\\n            Random variates, distributed standard Normal. Usually only\\n            specified if results are to be replicated (e.g. to enforce a seed)\\n            or for testing. If not specified, random variates are drawn. Must\\n            be shaped (nobs, k_states).\\n\\n        Notes\\n        -----\\n        The first step in simulating from the joint posterior of the state\\n        vector conditional on the data is to compute the two relevant moments\\n        of the joint posterior distribution:\\n\\n        .. math::\\n\\n            \\\\alpha \\\\mid Y_n \\\\sim N(\\\\hat \\\\alpha, Var(\\\\alpha \\\\mid Y_n))\\n\\n        Let :math:`L L' = Var(\\\\alpha \\\\mid Y_n)^{-1}`. Then simulation proceeds\\n        according to the following steps:\\n\\n        1. Draw :math:`u \\\\sim N(0, I)`\\n        2. Compute :math:`x = \\\\hat \\\\alpha + (L')^{-1} u`\\n\\n        And then :math:`x` is a draw from the joint posterior of the states.\\n        The output of the function is as follows:\\n\\n        - The simulated draw :math:`x` is held in the `simulated_state`\\n          attribute.\\n        - The posterior mean :math:`\\\\hat \\\\alpha` is held in the\\n          `posterior_mean` attribute.\\n        - The (lower triangular) Cholesky factor of the inverse posterior\\n          covariance matrix, :math:`L`, is held in sparse diagonal banded\\n          storage in the `posterior_cov_inv_chol` attribute.\\n        - The posterior covariance matrix :math:`Var(\\\\alpha \\\\mid Y_n)` can be\\n          computed on demand by accessing the `posterior_cov` property. Note\\n          that this matrix can be extremely large, so care must be taken when\\n          accessing this property. In most cases, it will be preferred to make\\n          use of the `posterior_cov_inv_chol` attribute rather than the\\n          `posterior_cov` attribute.\\n\\n        \"\n    (prefix, dtype, create) = self.model._initialize_representation()\n    if variates is not None:\n        tools.validate_matrix_shape('variates', variates.shape, self.model.k_states, self.model.nobs, 1)\n        variates = np.ravel(variates, order='F').astype(dtype)\n    self.model._initialize_state(prefix=prefix)\n    if create or prefix not in self._simulation_smoothers:\n        cls = self.prefix_simulation_smoother_map[prefix]\n        self._simulation_smoothers[prefix] = cls(self.model._statespaces[prefix])\n    sim = self._simulation_smoothers[prefix]\n    if update_posterior:\n        sim.update_sparse_posterior_moments()\n        self._posterior_mean = None\n        self._posterior_cov_inv_chol = None\n        self._posterior_cov = None\n    self.simulated_state = sim.simulate(variates=variates)",
            "def simulate(self, variates=None, update_posterior=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Perform simulation smoothing (via Cholesky factor algorithm)\\n\\n        Does not return anything, but populates the object's `simulated_state`\\n        attribute, and also makes available the attributes `posterior_mean`,\\n        `posterior_cov`, and `posterior_cov_inv_chol_sparse`.\\n\\n        Parameters\\n        ----------\\n        variates : array_like, optional\\n            Random variates, distributed standard Normal. Usually only\\n            specified if results are to be replicated (e.g. to enforce a seed)\\n            or for testing. If not specified, random variates are drawn. Must\\n            be shaped (nobs, k_states).\\n\\n        Notes\\n        -----\\n        The first step in simulating from the joint posterior of the state\\n        vector conditional on the data is to compute the two relevant moments\\n        of the joint posterior distribution:\\n\\n        .. math::\\n\\n            \\\\alpha \\\\mid Y_n \\\\sim N(\\\\hat \\\\alpha, Var(\\\\alpha \\\\mid Y_n))\\n\\n        Let :math:`L L' = Var(\\\\alpha \\\\mid Y_n)^{-1}`. Then simulation proceeds\\n        according to the following steps:\\n\\n        1. Draw :math:`u \\\\sim N(0, I)`\\n        2. Compute :math:`x = \\\\hat \\\\alpha + (L')^{-1} u`\\n\\n        And then :math:`x` is a draw from the joint posterior of the states.\\n        The output of the function is as follows:\\n\\n        - The simulated draw :math:`x` is held in the `simulated_state`\\n          attribute.\\n        - The posterior mean :math:`\\\\hat \\\\alpha` is held in the\\n          `posterior_mean` attribute.\\n        - The (lower triangular) Cholesky factor of the inverse posterior\\n          covariance matrix, :math:`L`, is held in sparse diagonal banded\\n          storage in the `posterior_cov_inv_chol` attribute.\\n        - The posterior covariance matrix :math:`Var(\\\\alpha \\\\mid Y_n)` can be\\n          computed on demand by accessing the `posterior_cov` property. Note\\n          that this matrix can be extremely large, so care must be taken when\\n          accessing this property. In most cases, it will be preferred to make\\n          use of the `posterior_cov_inv_chol` attribute rather than the\\n          `posterior_cov` attribute.\\n\\n        \"\n    (prefix, dtype, create) = self.model._initialize_representation()\n    if variates is not None:\n        tools.validate_matrix_shape('variates', variates.shape, self.model.k_states, self.model.nobs, 1)\n        variates = np.ravel(variates, order='F').astype(dtype)\n    self.model._initialize_state(prefix=prefix)\n    if create or prefix not in self._simulation_smoothers:\n        cls = self.prefix_simulation_smoother_map[prefix]\n        self._simulation_smoothers[prefix] = cls(self.model._statespaces[prefix])\n    sim = self._simulation_smoothers[prefix]\n    if update_posterior:\n        sim.update_sparse_posterior_moments()\n        self._posterior_mean = None\n        self._posterior_cov_inv_chol = None\n        self._posterior_cov = None\n    self.simulated_state = sim.simulate(variates=variates)",
            "def simulate(self, variates=None, update_posterior=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Perform simulation smoothing (via Cholesky factor algorithm)\\n\\n        Does not return anything, but populates the object's `simulated_state`\\n        attribute, and also makes available the attributes `posterior_mean`,\\n        `posterior_cov`, and `posterior_cov_inv_chol_sparse`.\\n\\n        Parameters\\n        ----------\\n        variates : array_like, optional\\n            Random variates, distributed standard Normal. Usually only\\n            specified if results are to be replicated (e.g. to enforce a seed)\\n            or for testing. If not specified, random variates are drawn. Must\\n            be shaped (nobs, k_states).\\n\\n        Notes\\n        -----\\n        The first step in simulating from the joint posterior of the state\\n        vector conditional on the data is to compute the two relevant moments\\n        of the joint posterior distribution:\\n\\n        .. math::\\n\\n            \\\\alpha \\\\mid Y_n \\\\sim N(\\\\hat \\\\alpha, Var(\\\\alpha \\\\mid Y_n))\\n\\n        Let :math:`L L' = Var(\\\\alpha \\\\mid Y_n)^{-1}`. Then simulation proceeds\\n        according to the following steps:\\n\\n        1. Draw :math:`u \\\\sim N(0, I)`\\n        2. Compute :math:`x = \\\\hat \\\\alpha + (L')^{-1} u`\\n\\n        And then :math:`x` is a draw from the joint posterior of the states.\\n        The output of the function is as follows:\\n\\n        - The simulated draw :math:`x` is held in the `simulated_state`\\n          attribute.\\n        - The posterior mean :math:`\\\\hat \\\\alpha` is held in the\\n          `posterior_mean` attribute.\\n        - The (lower triangular) Cholesky factor of the inverse posterior\\n          covariance matrix, :math:`L`, is held in sparse diagonal banded\\n          storage in the `posterior_cov_inv_chol` attribute.\\n        - The posterior covariance matrix :math:`Var(\\\\alpha \\\\mid Y_n)` can be\\n          computed on demand by accessing the `posterior_cov` property. Note\\n          that this matrix can be extremely large, so care must be taken when\\n          accessing this property. In most cases, it will be preferred to make\\n          use of the `posterior_cov_inv_chol` attribute rather than the\\n          `posterior_cov` attribute.\\n\\n        \"\n    (prefix, dtype, create) = self.model._initialize_representation()\n    if variates is not None:\n        tools.validate_matrix_shape('variates', variates.shape, self.model.k_states, self.model.nobs, 1)\n        variates = np.ravel(variates, order='F').astype(dtype)\n    self.model._initialize_state(prefix=prefix)\n    if create or prefix not in self._simulation_smoothers:\n        cls = self.prefix_simulation_smoother_map[prefix]\n        self._simulation_smoothers[prefix] = cls(self.model._statespaces[prefix])\n    sim = self._simulation_smoothers[prefix]\n    if update_posterior:\n        sim.update_sparse_posterior_moments()\n        self._posterior_mean = None\n        self._posterior_cov_inv_chol = None\n        self._posterior_cov = None\n    self.simulated_state = sim.simulate(variates=variates)"
        ]
    }
]