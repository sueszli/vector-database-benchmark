[
    {
        "func_name": "common_checks",
        "original": "def common_checks(self, finding):\n    self.assertLessEqual(len(finding.title), 250)\n    self.assertIn(finding.severity, Finding.SEVERITIES)\n    if finding.cwe:\n        self.assertIsInstance(finding.cwe, int)\n    self.assertEqual(True, finding.static_finding)\n    self.assertEqual(False, finding.dynamic_finding)",
        "mutated": [
            "def common_checks(self, finding):\n    if False:\n        i = 10\n    self.assertLessEqual(len(finding.title), 250)\n    self.assertIn(finding.severity, Finding.SEVERITIES)\n    if finding.cwe:\n        self.assertIsInstance(finding.cwe, int)\n    self.assertEqual(True, finding.static_finding)\n    self.assertEqual(False, finding.dynamic_finding)",
            "def common_checks(self, finding):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.assertLessEqual(len(finding.title), 250)\n    self.assertIn(finding.severity, Finding.SEVERITIES)\n    if finding.cwe:\n        self.assertIsInstance(finding.cwe, int)\n    self.assertEqual(True, finding.static_finding)\n    self.assertEqual(False, finding.dynamic_finding)",
            "def common_checks(self, finding):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.assertLessEqual(len(finding.title), 250)\n    self.assertIn(finding.severity, Finding.SEVERITIES)\n    if finding.cwe:\n        self.assertIsInstance(finding.cwe, int)\n    self.assertEqual(True, finding.static_finding)\n    self.assertEqual(False, finding.dynamic_finding)",
            "def common_checks(self, finding):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.assertLessEqual(len(finding.title), 250)\n    self.assertIn(finding.severity, Finding.SEVERITIES)\n    if finding.cwe:\n        self.assertIsInstance(finding.cwe, int)\n    self.assertEqual(True, finding.static_finding)\n    self.assertEqual(False, finding.dynamic_finding)",
            "def common_checks(self, finding):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.assertLessEqual(len(finding.title), 250)\n    self.assertIn(finding.severity, Finding.SEVERITIES)\n    if finding.cwe:\n        self.assertIsInstance(finding.cwe, int)\n    self.assertEqual(True, finding.static_finding)\n    self.assertEqual(False, finding.dynamic_finding)"
        ]
    },
    {
        "func_name": "test_example_report",
        "original": "def test_example_report(self):\n    testfile = open(path.join(get_unit_tests_path() + '/scans/sarif/DefectDojo_django-DefectDojo__2020-12-11_13 42 10__export.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(510, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_example_report(self):\n    if False:\n        i = 10\n    testfile = open(path.join(get_unit_tests_path() + '/scans/sarif/DefectDojo_django-DefectDojo__2020-12-11_13 42 10__export.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(510, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(get_unit_tests_path() + '/scans/sarif/DefectDojo_django-DefectDojo__2020-12-11_13 42 10__export.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(510, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(get_unit_tests_path() + '/scans/sarif/DefectDojo_django-DefectDojo__2020-12-11_13 42 10__export.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(510, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(get_unit_tests_path() + '/scans/sarif/DefectDojo_django-DefectDojo__2020-12-11_13 42 10__export.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(510, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(get_unit_tests_path() + '/scans/sarif/DefectDojo_django-DefectDojo__2020-12-11_13 42 10__export.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(510, len(findings))\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_suppression_report",
        "original": "def test_suppression_report(self):\n    \"\"\"test report file having different suppression definitions\"\"\"\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/suppression_test.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    for finding in findings:\n        if finding.title == 'Suppressed':\n            self.assertEqual(True, finding.false_p)\n            self.assertEqual(False, finding.active)\n        else:\n            self.assertEqual(False, finding.false_p)\n            self.assertEqual(True, finding.active)",
        "mutated": [
            "def test_suppression_report(self):\n    if False:\n        i = 10\n    'test report file having different suppression definitions'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/suppression_test.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    for finding in findings:\n        if finding.title == 'Suppressed':\n            self.assertEqual(True, finding.false_p)\n            self.assertEqual(False, finding.active)\n        else:\n            self.assertEqual(False, finding.false_p)\n            self.assertEqual(True, finding.active)",
            "def test_suppression_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test report file having different suppression definitions'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/suppression_test.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    for finding in findings:\n        if finding.title == 'Suppressed':\n            self.assertEqual(True, finding.false_p)\n            self.assertEqual(False, finding.active)\n        else:\n            self.assertEqual(False, finding.false_p)\n            self.assertEqual(True, finding.active)",
            "def test_suppression_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test report file having different suppression definitions'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/suppression_test.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    for finding in findings:\n        if finding.title == 'Suppressed':\n            self.assertEqual(True, finding.false_p)\n            self.assertEqual(False, finding.active)\n        else:\n            self.assertEqual(False, finding.false_p)\n            self.assertEqual(True, finding.active)",
            "def test_suppression_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test report file having different suppression definitions'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/suppression_test.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    for finding in findings:\n        if finding.title == 'Suppressed':\n            self.assertEqual(True, finding.false_p)\n            self.assertEqual(False, finding.active)\n        else:\n            self.assertEqual(False, finding.false_p)\n            self.assertEqual(True, finding.active)",
            "def test_suppression_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test report file having different suppression definitions'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/suppression_test.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    for finding in findings:\n        if finding.title == 'Suppressed':\n            self.assertEqual(True, finding.false_p)\n            self.assertEqual(False, finding.active)\n        else:\n            self.assertEqual(False, finding.false_p)\n            self.assertEqual(True, finding.active)"
        ]
    },
    {
        "func_name": "test_example2_report",
        "original": "def test_example2_report(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('collections/list.h', item.file_path)\n    self.assertEqual(15, item.line)\n    self.assertEqual('High', item.severity)\n    description = '**Result message:** Variable \"ptr\" was used without being initialized. It was declared [here](0).\\n**Snippet:**\\n```add_core(ptr, offset, val);\\n    return;```\\n**Rule short description:** A variable was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.\\n**Code flow:**\\n1. collections/list.h:L15\\t-\\tint *ptr;\\n\\tVariable `ptr` declared.\\n2. collections/list.h:L15\\t-\\toffset = (y + z) * q + 1;\\n3. collections/list.h:L25\\t-\\tadd_core(ptr, offset, val)\\n\\tUninitialized variable `ptr` passed to method `add_core`.'\n    self.assertEqual(description, item.description)\n    self.assertEqual(datetime.datetime(2016, 7, 16, 14, 19, 1, tzinfo=datetime.timezone.utc), item.date)\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_example2_report(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('collections/list.h', item.file_path)\n    self.assertEqual(15, item.line)\n    self.assertEqual('High', item.severity)\n    description = '**Result message:** Variable \"ptr\" was used without being initialized. It was declared [here](0).\\n**Snippet:**\\n```add_core(ptr, offset, val);\\n    return;```\\n**Rule short description:** A variable was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.\\n**Code flow:**\\n1. collections/list.h:L15\\t-\\tint *ptr;\\n\\tVariable `ptr` declared.\\n2. collections/list.h:L15\\t-\\toffset = (y + z) * q + 1;\\n3. collections/list.h:L25\\t-\\tadd_core(ptr, offset, val)\\n\\tUninitialized variable `ptr` passed to method `add_core`.'\n    self.assertEqual(description, item.description)\n    self.assertEqual(datetime.datetime(2016, 7, 16, 14, 19, 1, tzinfo=datetime.timezone.utc), item.date)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example2_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('collections/list.h', item.file_path)\n    self.assertEqual(15, item.line)\n    self.assertEqual('High', item.severity)\n    description = '**Result message:** Variable \"ptr\" was used without being initialized. It was declared [here](0).\\n**Snippet:**\\n```add_core(ptr, offset, val);\\n    return;```\\n**Rule short description:** A variable was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.\\n**Code flow:**\\n1. collections/list.h:L15\\t-\\tint *ptr;\\n\\tVariable `ptr` declared.\\n2. collections/list.h:L15\\t-\\toffset = (y + z) * q + 1;\\n3. collections/list.h:L25\\t-\\tadd_core(ptr, offset, val)\\n\\tUninitialized variable `ptr` passed to method `add_core`.'\n    self.assertEqual(description, item.description)\n    self.assertEqual(datetime.datetime(2016, 7, 16, 14, 19, 1, tzinfo=datetime.timezone.utc), item.date)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example2_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('collections/list.h', item.file_path)\n    self.assertEqual(15, item.line)\n    self.assertEqual('High', item.severity)\n    description = '**Result message:** Variable \"ptr\" was used without being initialized. It was declared [here](0).\\n**Snippet:**\\n```add_core(ptr, offset, val);\\n    return;```\\n**Rule short description:** A variable was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.\\n**Code flow:**\\n1. collections/list.h:L15\\t-\\tint *ptr;\\n\\tVariable `ptr` declared.\\n2. collections/list.h:L15\\t-\\toffset = (y + z) * q + 1;\\n3. collections/list.h:L25\\t-\\tadd_core(ptr, offset, val)\\n\\tUninitialized variable `ptr` passed to method `add_core`.'\n    self.assertEqual(description, item.description)\n    self.assertEqual(datetime.datetime(2016, 7, 16, 14, 19, 1, tzinfo=datetime.timezone.utc), item.date)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example2_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('collections/list.h', item.file_path)\n    self.assertEqual(15, item.line)\n    self.assertEqual('High', item.severity)\n    description = '**Result message:** Variable \"ptr\" was used without being initialized. It was declared [here](0).\\n**Snippet:**\\n```add_core(ptr, offset, val);\\n    return;```\\n**Rule short description:** A variable was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.\\n**Code flow:**\\n1. collections/list.h:L15\\t-\\tint *ptr;\\n\\tVariable `ptr` declared.\\n2. collections/list.h:L15\\t-\\toffset = (y + z) * q + 1;\\n3. collections/list.h:L25\\t-\\tadd_core(ptr, offset, val)\\n\\tUninitialized variable `ptr` passed to method `add_core`.'\n    self.assertEqual(description, item.description)\n    self.assertEqual(datetime.datetime(2016, 7, 16, 14, 19, 1, tzinfo=datetime.timezone.utc), item.date)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example2_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('collections/list.h', item.file_path)\n    self.assertEqual(15, item.line)\n    self.assertEqual('High', item.severity)\n    description = '**Result message:** Variable \"ptr\" was used without being initialized. It was declared [here](0).\\n**Snippet:**\\n```add_core(ptr, offset, val);\\n    return;```\\n**Rule short description:** A variable was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.\\n**Code flow:**\\n1. collections/list.h:L15\\t-\\tint *ptr;\\n\\tVariable `ptr` declared.\\n2. collections/list.h:L15\\t-\\toffset = (y + z) * q + 1;\\n3. collections/list.h:L25\\t-\\tadd_core(ptr, offset, val)\\n\\tUninitialized variable `ptr` passed to method `add_core`.'\n    self.assertEqual(description, item.description)\n    self.assertEqual(datetime.datetime(2016, 7, 16, 14, 19, 1, tzinfo=datetime.timezone.utc), item.date)\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_example_k1_report",
        "original": "def test_example_k1_report(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(0, len(findings))",
        "mutated": [
            "def test_example_k1_report(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(0, len(findings))",
            "def test_example_k1_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(0, len(findings))",
            "def test_example_k1_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(0, len(findings))",
            "def test_example_k1_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(0, len(findings))",
            "def test_example_k1_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(0, len(findings))"
        ]
    },
    {
        "func_name": "test_example_k2_report",
        "original": "def test_example_k2_report(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k2.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('Variable \"count\" was used without being initialized.', item.title)\n    self.assertEqual('src/collections/list.cpp', item.file_path)\n    self.assertEqual(15, item.line)\n    description = '**Result message:** Variable \"count\" was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.'\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_example_k2_report(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k2.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('Variable \"count\" was used without being initialized.', item.title)\n    self.assertEqual('src/collections/list.cpp', item.file_path)\n    self.assertEqual(15, item.line)\n    description = '**Result message:** Variable \"count\" was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.'\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_k2_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k2.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('Variable \"count\" was used without being initialized.', item.title)\n    self.assertEqual('src/collections/list.cpp', item.file_path)\n    self.assertEqual(15, item.line)\n    description = '**Result message:** Variable \"count\" was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.'\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_k2_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k2.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('Variable \"count\" was used without being initialized.', item.title)\n    self.assertEqual('src/collections/list.cpp', item.file_path)\n    self.assertEqual(15, item.line)\n    description = '**Result message:** Variable \"count\" was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.'\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_k2_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k2.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('Variable \"count\" was used without being initialized.', item.title)\n    self.assertEqual('src/collections/list.cpp', item.file_path)\n    self.assertEqual(15, item.line)\n    description = '**Result message:** Variable \"count\" was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.'\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_k2_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k2.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('Variable \"count\" was used without being initialized.', item.title)\n    self.assertEqual('src/collections/list.cpp', item.file_path)\n    self.assertEqual(15, item.line)\n    description = '**Result message:** Variable \"count\" was used without being initialized.\\n**Rule full description:** A variable was used without being initialized. This can result in runtime errors such as null reference exceptions.'\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_example_k3_report",
        "original": "def test_example_k3_report(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k3.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('The insecure method \"Crypto.Sha1.Encrypt\" should not be used.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_example_k3_report(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k3.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('The insecure method \"Crypto.Sha1.Encrypt\" should not be used.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_k3_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k3.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('The insecure method \"Crypto.Sha1.Encrypt\" should not be used.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_k3_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k3.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('The insecure method \"Crypto.Sha1.Encrypt\" should not be used.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_k3_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k3.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('The insecure method \"Crypto.Sha1.Encrypt\" should not be used.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_k3_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k3.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual('The insecure method \"Crypto.Sha1.Encrypt\" should not be used.', item.title)\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_example_k4_report_mitigation",
        "original": "def test_example_k4_report_mitigation(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k4.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('Variable \"ptr\" was used without being initialized. It was declared [here](0).', finding.title)\n        self.assertEqual('C2001', finding.vuln_id_from_tool)\n        self.assertEqual('collections/list.h', finding.file_path)\n        self.assertEqual('Initialize the variable to null', finding.mitigation)",
        "mutated": [
            "def test_example_k4_report_mitigation(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k4.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('Variable \"ptr\" was used without being initialized. It was declared [here](0).', finding.title)\n        self.assertEqual('C2001', finding.vuln_id_from_tool)\n        self.assertEqual('collections/list.h', finding.file_path)\n        self.assertEqual('Initialize the variable to null', finding.mitigation)",
            "def test_example_k4_report_mitigation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k4.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('Variable \"ptr\" was used without being initialized. It was declared [here](0).', finding.title)\n        self.assertEqual('C2001', finding.vuln_id_from_tool)\n        self.assertEqual('collections/list.h', finding.file_path)\n        self.assertEqual('Initialize the variable to null', finding.mitigation)",
            "def test_example_k4_report_mitigation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k4.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('Variable \"ptr\" was used without being initialized. It was declared [here](0).', finding.title)\n        self.assertEqual('C2001', finding.vuln_id_from_tool)\n        self.assertEqual('collections/list.h', finding.file_path)\n        self.assertEqual('Initialize the variable to null', finding.mitigation)",
            "def test_example_k4_report_mitigation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k4.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('Variable \"ptr\" was used without being initialized. It was declared [here](0).', finding.title)\n        self.assertEqual('C2001', finding.vuln_id_from_tool)\n        self.assertEqual('collections/list.h', finding.file_path)\n        self.assertEqual('Initialize the variable to null', finding.mitigation)",
            "def test_example_k4_report_mitigation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k4.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(1, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('Variable \"ptr\" was used without being initialized. It was declared [here](0).', finding.title)\n        self.assertEqual('C2001', finding.vuln_id_from_tool)\n        self.assertEqual('collections/list.h', finding.file_path)\n        self.assertEqual('Initialize the variable to null', finding.mitigation)"
        ]
    },
    {
        "func_name": "test_example_report_ms",
        "original": "def test_example_report_ms(self):\n    \"\"\"Report file come from Microsoft SARIF sdk on GitHub\"\"\"\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/SuppressionTestCurrent.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    item = findings[0]\n    self.assertEqual('New suppressed result.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_example_report_ms(self):\n    if False:\n        i = 10\n    'Report file come from Microsoft SARIF sdk on GitHub'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/SuppressionTestCurrent.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    item = findings[0]\n    self.assertEqual('New suppressed result.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_ms(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Report file come from Microsoft SARIF sdk on GitHub'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/SuppressionTestCurrent.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    item = findings[0]\n    self.assertEqual('New suppressed result.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_ms(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Report file come from Microsoft SARIF sdk on GitHub'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/SuppressionTestCurrent.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    item = findings[0]\n    self.assertEqual('New suppressed result.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_ms(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Report file come from Microsoft SARIF sdk on GitHub'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/SuppressionTestCurrent.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    item = findings[0]\n    self.assertEqual('New suppressed result.', item.title)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_ms(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Report file come from Microsoft SARIF sdk on GitHub'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/SuppressionTestCurrent.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    item = findings[0]\n    self.assertEqual('New suppressed result.', item.title)\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_example_report_semgrep",
        "original": "def test_example_report_semgrep(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/semgrepowasp-benchmark-sample.sarif'))\n    test = Test()\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, test)\n    self.assertEqual(1768, len(findings))\n    item = findings[0]\n    self.assertEqual('src/main/java/org/owasp/benchmark/testcode/BenchmarkTest02660.java', item.file_path)\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_example_report_semgrep(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/semgrepowasp-benchmark-sample.sarif'))\n    test = Test()\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, test)\n    self.assertEqual(1768, len(findings))\n    item = findings[0]\n    self.assertEqual('src/main/java/org/owasp/benchmark/testcode/BenchmarkTest02660.java', item.file_path)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_semgrep(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/semgrepowasp-benchmark-sample.sarif'))\n    test = Test()\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, test)\n    self.assertEqual(1768, len(findings))\n    item = findings[0]\n    self.assertEqual('src/main/java/org/owasp/benchmark/testcode/BenchmarkTest02660.java', item.file_path)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_semgrep(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/semgrepowasp-benchmark-sample.sarif'))\n    test = Test()\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, test)\n    self.assertEqual(1768, len(findings))\n    item = findings[0]\n    self.assertEqual('src/main/java/org/owasp/benchmark/testcode/BenchmarkTest02660.java', item.file_path)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_semgrep(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/semgrepowasp-benchmark-sample.sarif'))\n    test = Test()\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, test)\n    self.assertEqual(1768, len(findings))\n    item = findings[0]\n    self.assertEqual('src/main/java/org/owasp/benchmark/testcode/BenchmarkTest02660.java', item.file_path)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_semgrep(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/semgrepowasp-benchmark-sample.sarif'))\n    test = Test()\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, test)\n    self.assertEqual(1768, len(findings))\n    item = findings[0]\n    self.assertEqual('src/main/java/org/owasp/benchmark/testcode/BenchmarkTest02660.java', item.file_path)\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_example_report_scanlift_dependency_check",
        "original": "def test_example_report_scanlift_dependency_check(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dependency_check.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(13, len(findings))\n    item = findings[0]\n    self.assertEqual('file:////src/.venv/lib/python3.9/site-packages/tastypie_swagger/static/tastypie_swagger/js/lib/handlebars-1.0.0.js', item.file_path)\n    item = findings[6]\n    self.assertEqual('CVE-2019-11358 - jQuery before 3.4.0, as used in Drupal, Backdrop CMS, and other products, mishandles jQuery.extend(true, {}, ...) because of [...]', item.title)\n    self.assertEqual('High', item.severity)\n    self.assertEqual(1, len(item.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2019-11358', item.unsaved_vulnerability_ids[0])\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_example_report_scanlift_dependency_check(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dependency_check.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(13, len(findings))\n    item = findings[0]\n    self.assertEqual('file:////src/.venv/lib/python3.9/site-packages/tastypie_swagger/static/tastypie_swagger/js/lib/handlebars-1.0.0.js', item.file_path)\n    item = findings[6]\n    self.assertEqual('CVE-2019-11358 - jQuery before 3.4.0, as used in Drupal, Backdrop CMS, and other products, mishandles jQuery.extend(true, {}, ...) because of [...]', item.title)\n    self.assertEqual('High', item.severity)\n    self.assertEqual(1, len(item.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2019-11358', item.unsaved_vulnerability_ids[0])\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_scanlift_dependency_check(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dependency_check.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(13, len(findings))\n    item = findings[0]\n    self.assertEqual('file:////src/.venv/lib/python3.9/site-packages/tastypie_swagger/static/tastypie_swagger/js/lib/handlebars-1.0.0.js', item.file_path)\n    item = findings[6]\n    self.assertEqual('CVE-2019-11358 - jQuery before 3.4.0, as used in Drupal, Backdrop CMS, and other products, mishandles jQuery.extend(true, {}, ...) because of [...]', item.title)\n    self.assertEqual('High', item.severity)\n    self.assertEqual(1, len(item.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2019-11358', item.unsaved_vulnerability_ids[0])\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_scanlift_dependency_check(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dependency_check.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(13, len(findings))\n    item = findings[0]\n    self.assertEqual('file:////src/.venv/lib/python3.9/site-packages/tastypie_swagger/static/tastypie_swagger/js/lib/handlebars-1.0.0.js', item.file_path)\n    item = findings[6]\n    self.assertEqual('CVE-2019-11358 - jQuery before 3.4.0, as used in Drupal, Backdrop CMS, and other products, mishandles jQuery.extend(true, {}, ...) because of [...]', item.title)\n    self.assertEqual('High', item.severity)\n    self.assertEqual(1, len(item.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2019-11358', item.unsaved_vulnerability_ids[0])\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_scanlift_dependency_check(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dependency_check.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(13, len(findings))\n    item = findings[0]\n    self.assertEqual('file:////src/.venv/lib/python3.9/site-packages/tastypie_swagger/static/tastypie_swagger/js/lib/handlebars-1.0.0.js', item.file_path)\n    item = findings[6]\n    self.assertEqual('CVE-2019-11358 - jQuery before 3.4.0, as used in Drupal, Backdrop CMS, and other products, mishandles jQuery.extend(true, {}, ...) because of [...]', item.title)\n    self.assertEqual('High', item.severity)\n    self.assertEqual(1, len(item.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2019-11358', item.unsaved_vulnerability_ids[0])\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_scanlift_dependency_check(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dependency_check.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(13, len(findings))\n    item = findings[0]\n    self.assertEqual('file:////src/.venv/lib/python3.9/site-packages/tastypie_swagger/static/tastypie_swagger/js/lib/handlebars-1.0.0.js', item.file_path)\n    item = findings[6]\n    self.assertEqual('CVE-2019-11358 - jQuery before 3.4.0, as used in Drupal, Backdrop CMS, and other products, mishandles jQuery.extend(true, {}, ...) because of [...]', item.title)\n    self.assertEqual('High', item.severity)\n    self.assertEqual(1, len(item.unsaved_vulnerability_ids))\n    self.assertEqual('CVE-2019-11358', item.unsaved_vulnerability_ids[0])\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_example_report_scanlift_bash",
        "original": "def test_example_report_scanlift_bash(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/bash-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(27, len(findings))\n    item = findings[0]\n    self.assertEqual('file:///home/damien/dd/docker/setEnv.sh', item.file_path)\n    self.assertIsNone(item.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 8, 15, 39, 40, tzinfo=datetime.timezone.utc), item.date)\n    with self.subTest(i=6):\n        finding = findings[6]\n        self.assertEqual('Decimals are not supported. Either use integers only, or use bc or awk to compare.', finding.title)\n        self.assertEqual('Info', finding.severity)\n        self.assertIsNone(finding.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:5b05533780915bfc|scanPrimaryLocationHash:4d655189c485c086', finding.unique_id_from_tool)\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_example_report_scanlift_bash(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/bash-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(27, len(findings))\n    item = findings[0]\n    self.assertEqual('file:///home/damien/dd/docker/setEnv.sh', item.file_path)\n    self.assertIsNone(item.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 8, 15, 39, 40, tzinfo=datetime.timezone.utc), item.date)\n    with self.subTest(i=6):\n        finding = findings[6]\n        self.assertEqual('Decimals are not supported. Either use integers only, or use bc or awk to compare.', finding.title)\n        self.assertEqual('Info', finding.severity)\n        self.assertIsNone(finding.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:5b05533780915bfc|scanPrimaryLocationHash:4d655189c485c086', finding.unique_id_from_tool)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_scanlift_bash(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/bash-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(27, len(findings))\n    item = findings[0]\n    self.assertEqual('file:///home/damien/dd/docker/setEnv.sh', item.file_path)\n    self.assertIsNone(item.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 8, 15, 39, 40, tzinfo=datetime.timezone.utc), item.date)\n    with self.subTest(i=6):\n        finding = findings[6]\n        self.assertEqual('Decimals are not supported. Either use integers only, or use bc or awk to compare.', finding.title)\n        self.assertEqual('Info', finding.severity)\n        self.assertIsNone(finding.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:5b05533780915bfc|scanPrimaryLocationHash:4d655189c485c086', finding.unique_id_from_tool)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_scanlift_bash(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/bash-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(27, len(findings))\n    item = findings[0]\n    self.assertEqual('file:///home/damien/dd/docker/setEnv.sh', item.file_path)\n    self.assertIsNone(item.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 8, 15, 39, 40, tzinfo=datetime.timezone.utc), item.date)\n    with self.subTest(i=6):\n        finding = findings[6]\n        self.assertEqual('Decimals are not supported. Either use integers only, or use bc or awk to compare.', finding.title)\n        self.assertEqual('Info', finding.severity)\n        self.assertIsNone(finding.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:5b05533780915bfc|scanPrimaryLocationHash:4d655189c485c086', finding.unique_id_from_tool)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_scanlift_bash(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/bash-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(27, len(findings))\n    item = findings[0]\n    self.assertEqual('file:///home/damien/dd/docker/setEnv.sh', item.file_path)\n    self.assertIsNone(item.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 8, 15, 39, 40, tzinfo=datetime.timezone.utc), item.date)\n    with self.subTest(i=6):\n        finding = findings[6]\n        self.assertEqual('Decimals are not supported. Either use integers only, or use bc or awk to compare.', finding.title)\n        self.assertEqual('Info', finding.severity)\n        self.assertIsNone(finding.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:5b05533780915bfc|scanPrimaryLocationHash:4d655189c485c086', finding.unique_id_from_tool)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_example_report_scanlift_bash(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/bash-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(27, len(findings))\n    item = findings[0]\n    self.assertEqual('file:///home/damien/dd/docker/setEnv.sh', item.file_path)\n    self.assertIsNone(item.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 8, 15, 39, 40, tzinfo=datetime.timezone.utc), item.date)\n    with self.subTest(i=6):\n        finding = findings[6]\n        self.assertEqual('Decimals are not supported. Either use integers only, or use bc or awk to compare.', finding.title)\n        self.assertEqual('Info', finding.severity)\n        self.assertIsNone(finding.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:5b05533780915bfc|scanPrimaryLocationHash:4d655189c485c086', finding.unique_id_from_tool)\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_example_report_taint_python",
        "original": "def test_example_report_taint_python(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(11, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        item = findings[0]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/veracode/parser.py', item.file_path)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual(datetime.datetime(2021, 3, 8, 15, 46, 16, tzinfo=datetime.timezone.utc), item.date)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)\n    with self.subTest(i=2):\n        item = findings[2]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/qualys_infrascan_webgui/parser.py', item.file_path)\n        self.assertEqual(169, item.line)\n        item = findings[6]\n        self.assertEqual('XML injection with user data from `filename in parser_helper.py:167` is used for parsing XML at `parser_helper.py:23`.', item.title)\n        self.assertEqual('High', item.severity)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)",
        "mutated": [
            "def test_example_report_taint_python(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(11, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        item = findings[0]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/veracode/parser.py', item.file_path)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual(datetime.datetime(2021, 3, 8, 15, 46, 16, tzinfo=datetime.timezone.utc), item.date)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)\n    with self.subTest(i=2):\n        item = findings[2]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/qualys_infrascan_webgui/parser.py', item.file_path)\n        self.assertEqual(169, item.line)\n        item = findings[6]\n        self.assertEqual('XML injection with user data from `filename in parser_helper.py:167` is used for parsing XML at `parser_helper.py:23`.', item.title)\n        self.assertEqual('High', item.severity)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)",
            "def test_example_report_taint_python(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(11, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        item = findings[0]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/veracode/parser.py', item.file_path)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual(datetime.datetime(2021, 3, 8, 15, 46, 16, tzinfo=datetime.timezone.utc), item.date)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)\n    with self.subTest(i=2):\n        item = findings[2]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/qualys_infrascan_webgui/parser.py', item.file_path)\n        self.assertEqual(169, item.line)\n        item = findings[6]\n        self.assertEqual('XML injection with user data from `filename in parser_helper.py:167` is used for parsing XML at `parser_helper.py:23`.', item.title)\n        self.assertEqual('High', item.severity)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)",
            "def test_example_report_taint_python(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(11, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        item = findings[0]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/veracode/parser.py', item.file_path)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual(datetime.datetime(2021, 3, 8, 15, 46, 16, tzinfo=datetime.timezone.utc), item.date)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)\n    with self.subTest(i=2):\n        item = findings[2]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/qualys_infrascan_webgui/parser.py', item.file_path)\n        self.assertEqual(169, item.line)\n        item = findings[6]\n        self.assertEqual('XML injection with user data from `filename in parser_helper.py:167` is used for parsing XML at `parser_helper.py:23`.', item.title)\n        self.assertEqual('High', item.severity)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)",
            "def test_example_report_taint_python(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(11, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        item = findings[0]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/veracode/parser.py', item.file_path)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual(datetime.datetime(2021, 3, 8, 15, 46, 16, tzinfo=datetime.timezone.utc), item.date)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)\n    with self.subTest(i=2):\n        item = findings[2]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/qualys_infrascan_webgui/parser.py', item.file_path)\n        self.assertEqual(169, item.line)\n        item = findings[6]\n        self.assertEqual('XML injection with user data from `filename in parser_helper.py:167` is used for parsing XML at `parser_helper.py:23`.', item.title)\n        self.assertEqual('High', item.severity)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)",
            "def test_example_report_taint_python(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(11, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        item = findings[0]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/veracode/parser.py', item.file_path)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual(datetime.datetime(2021, 3, 8, 15, 46, 16, tzinfo=datetime.timezone.utc), item.date)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)\n    with self.subTest(i=2):\n        item = findings[2]\n        self.assertEqual('file:///home/damien/dd/dojo/tools/qualys_infrascan_webgui/parser.py', item.file_path)\n        self.assertEqual(169, item.line)\n        item = findings[6]\n        self.assertEqual('XML injection with user data from `filename in parser_helper.py:167` is used for parsing XML at `parser_helper.py:23`.', item.title)\n        self.assertEqual('High', item.severity)\n        self.assertIsNone(item.unsaved_vulnerability_ids)\n        self.assertEqual('scanFileHash:4bc9f13947613303|scanPrimaryLocationHash:1a8bbb28fe7380df|scanTagsHash:21de8f8d0eb8d9b2', finding.unique_id_from_tool)"
        ]
    },
    {
        "func_name": "test_njsscan",
        "original": "def test_njsscan(self):\n    \"\"\"Generated with opensecurity/njsscan (https://github.com/ajinabraham/njsscan)\"\"\"\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/njsscan.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(2, len(findings))\n    finding = findings[0]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertIsNone(finding.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(327, finding.cwe)\n    finding = findings[1]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertEqual(235, finding.line)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(798, finding.cwe)\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_njsscan(self):\n    if False:\n        i = 10\n    'Generated with opensecurity/njsscan (https://github.com/ajinabraham/njsscan)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/njsscan.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(2, len(findings))\n    finding = findings[0]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertIsNone(finding.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(327, finding.cwe)\n    finding = findings[1]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertEqual(235, finding.line)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(798, finding.cwe)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_njsscan(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generated with opensecurity/njsscan (https://github.com/ajinabraham/njsscan)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/njsscan.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(2, len(findings))\n    finding = findings[0]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertIsNone(finding.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(327, finding.cwe)\n    finding = findings[1]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertEqual(235, finding.line)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(798, finding.cwe)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_njsscan(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generated with opensecurity/njsscan (https://github.com/ajinabraham/njsscan)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/njsscan.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(2, len(findings))\n    finding = findings[0]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertIsNone(finding.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(327, finding.cwe)\n    finding = findings[1]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertEqual(235, finding.line)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(798, finding.cwe)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_njsscan(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generated with opensecurity/njsscan (https://github.com/ajinabraham/njsscan)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/njsscan.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(2, len(findings))\n    finding = findings[0]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertIsNone(finding.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(327, finding.cwe)\n    finding = findings[1]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertEqual(235, finding.line)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(798, finding.cwe)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_njsscan(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generated with opensecurity/njsscan (https://github.com/ajinabraham/njsscan)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/njsscan.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(2, len(findings))\n    finding = findings[0]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertIsNone(finding.unsaved_vulnerability_ids)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(327, finding.cwe)\n    finding = findings[1]\n    self.assertEqual('file:///src/index.js', finding.file_path)\n    self.assertEqual(235, finding.line)\n    self.assertEqual(datetime.datetime(2021, 3, 23, 0, 10, 48, tzinfo=datetime.timezone.utc), finding.date)\n    self.assertEqual(798, finding.cwe)\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_dockle",
        "original": "def test_dockle(self):\n    \"\"\"Generated with goodwithtech/dockle (https://github.com/goodwithtech/dockle)\"\"\"\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dockle_0_3_15.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('CIS-DI-0010', finding.vuln_id_from_tool)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** Suspicious ENV key found : DD_ADMIN_PASSWORD, Suspicious ENV key found : DD_CELERY_BROKER_PASSWORD, Suspicious ENV key found : DD_DATABASE_PASSWORD\\n**Rule short description:** Do not store credential in ENVIRONMENT vars/files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0010', finding.references)\n    with self.subTest(i=1):\n        finding = findings[1]\n        self.assertEqual('CIS-DI-0005', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** export DOCKER_CONTENT_TRUST=1 before docker pull/build\\n**Rule short description:** Enable Content trust for Docker'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0005', finding.references)\n    with self.subTest(i=2):\n        finding = findings[2]\n        self.assertEqual('CIS-DI-0006', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** not found HEALTHCHECK statement\\n**Rule short description:** Add HEALTHCHECK instruction to the container image'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0006', finding.references)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('CIS-DI-0008', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** setuid file: urwxr-xr-x usr/bin/chfn, setuid file: urwxr-xr-x usr/bin/chsh, setuid file: urwxr-xr-x usr/bin/passwd, setuid file: urwxr-xr-x bin/umount, setuid file: urwxr-xr-x bin/mount, setgid file: grwxr-xr-x usr/bin/wall, setgid file: grwxr-xr-x usr/bin/expiry, setuid file: urwxr-xr-x bin/su, setgid file: grwxr-xr-x sbin/unix_chkpwd, setuid file: urwxr-xr-x usr/bin/gpasswd, setgid file: grwxr-xr-x usr/bin/chage, setuid file: urwxr-xr-x usr/bin/newgrp\\n**Rule short description:** Confirm safety of setuid/setgid files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0008', finding.references)",
        "mutated": [
            "def test_dockle(self):\n    if False:\n        i = 10\n    'Generated with goodwithtech/dockle (https://github.com/goodwithtech/dockle)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dockle_0_3_15.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('CIS-DI-0010', finding.vuln_id_from_tool)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** Suspicious ENV key found : DD_ADMIN_PASSWORD, Suspicious ENV key found : DD_CELERY_BROKER_PASSWORD, Suspicious ENV key found : DD_DATABASE_PASSWORD\\n**Rule short description:** Do not store credential in ENVIRONMENT vars/files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0010', finding.references)\n    with self.subTest(i=1):\n        finding = findings[1]\n        self.assertEqual('CIS-DI-0005', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** export DOCKER_CONTENT_TRUST=1 before docker pull/build\\n**Rule short description:** Enable Content trust for Docker'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0005', finding.references)\n    with self.subTest(i=2):\n        finding = findings[2]\n        self.assertEqual('CIS-DI-0006', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** not found HEALTHCHECK statement\\n**Rule short description:** Add HEALTHCHECK instruction to the container image'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0006', finding.references)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('CIS-DI-0008', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** setuid file: urwxr-xr-x usr/bin/chfn, setuid file: urwxr-xr-x usr/bin/chsh, setuid file: urwxr-xr-x usr/bin/passwd, setuid file: urwxr-xr-x bin/umount, setuid file: urwxr-xr-x bin/mount, setgid file: grwxr-xr-x usr/bin/wall, setgid file: grwxr-xr-x usr/bin/expiry, setuid file: urwxr-xr-x bin/su, setgid file: grwxr-xr-x sbin/unix_chkpwd, setuid file: urwxr-xr-x usr/bin/gpasswd, setgid file: grwxr-xr-x usr/bin/chage, setuid file: urwxr-xr-x usr/bin/newgrp\\n**Rule short description:** Confirm safety of setuid/setgid files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0008', finding.references)",
            "def test_dockle(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generated with goodwithtech/dockle (https://github.com/goodwithtech/dockle)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dockle_0_3_15.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('CIS-DI-0010', finding.vuln_id_from_tool)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** Suspicious ENV key found : DD_ADMIN_PASSWORD, Suspicious ENV key found : DD_CELERY_BROKER_PASSWORD, Suspicious ENV key found : DD_DATABASE_PASSWORD\\n**Rule short description:** Do not store credential in ENVIRONMENT vars/files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0010', finding.references)\n    with self.subTest(i=1):\n        finding = findings[1]\n        self.assertEqual('CIS-DI-0005', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** export DOCKER_CONTENT_TRUST=1 before docker pull/build\\n**Rule short description:** Enable Content trust for Docker'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0005', finding.references)\n    with self.subTest(i=2):\n        finding = findings[2]\n        self.assertEqual('CIS-DI-0006', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** not found HEALTHCHECK statement\\n**Rule short description:** Add HEALTHCHECK instruction to the container image'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0006', finding.references)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('CIS-DI-0008', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** setuid file: urwxr-xr-x usr/bin/chfn, setuid file: urwxr-xr-x usr/bin/chsh, setuid file: urwxr-xr-x usr/bin/passwd, setuid file: urwxr-xr-x bin/umount, setuid file: urwxr-xr-x bin/mount, setgid file: grwxr-xr-x usr/bin/wall, setgid file: grwxr-xr-x usr/bin/expiry, setuid file: urwxr-xr-x bin/su, setgid file: grwxr-xr-x sbin/unix_chkpwd, setuid file: urwxr-xr-x usr/bin/gpasswd, setgid file: grwxr-xr-x usr/bin/chage, setuid file: urwxr-xr-x usr/bin/newgrp\\n**Rule short description:** Confirm safety of setuid/setgid files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0008', finding.references)",
            "def test_dockle(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generated with goodwithtech/dockle (https://github.com/goodwithtech/dockle)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dockle_0_3_15.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('CIS-DI-0010', finding.vuln_id_from_tool)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** Suspicious ENV key found : DD_ADMIN_PASSWORD, Suspicious ENV key found : DD_CELERY_BROKER_PASSWORD, Suspicious ENV key found : DD_DATABASE_PASSWORD\\n**Rule short description:** Do not store credential in ENVIRONMENT vars/files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0010', finding.references)\n    with self.subTest(i=1):\n        finding = findings[1]\n        self.assertEqual('CIS-DI-0005', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** export DOCKER_CONTENT_TRUST=1 before docker pull/build\\n**Rule short description:** Enable Content trust for Docker'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0005', finding.references)\n    with self.subTest(i=2):\n        finding = findings[2]\n        self.assertEqual('CIS-DI-0006', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** not found HEALTHCHECK statement\\n**Rule short description:** Add HEALTHCHECK instruction to the container image'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0006', finding.references)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('CIS-DI-0008', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** setuid file: urwxr-xr-x usr/bin/chfn, setuid file: urwxr-xr-x usr/bin/chsh, setuid file: urwxr-xr-x usr/bin/passwd, setuid file: urwxr-xr-x bin/umount, setuid file: urwxr-xr-x bin/mount, setgid file: grwxr-xr-x usr/bin/wall, setgid file: grwxr-xr-x usr/bin/expiry, setuid file: urwxr-xr-x bin/su, setgid file: grwxr-xr-x sbin/unix_chkpwd, setuid file: urwxr-xr-x usr/bin/gpasswd, setgid file: grwxr-xr-x usr/bin/chage, setuid file: urwxr-xr-x usr/bin/newgrp\\n**Rule short description:** Confirm safety of setuid/setgid files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0008', finding.references)",
            "def test_dockle(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generated with goodwithtech/dockle (https://github.com/goodwithtech/dockle)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dockle_0_3_15.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('CIS-DI-0010', finding.vuln_id_from_tool)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** Suspicious ENV key found : DD_ADMIN_PASSWORD, Suspicious ENV key found : DD_CELERY_BROKER_PASSWORD, Suspicious ENV key found : DD_DATABASE_PASSWORD\\n**Rule short description:** Do not store credential in ENVIRONMENT vars/files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0010', finding.references)\n    with self.subTest(i=1):\n        finding = findings[1]\n        self.assertEqual('CIS-DI-0005', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** export DOCKER_CONTENT_TRUST=1 before docker pull/build\\n**Rule short description:** Enable Content trust for Docker'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0005', finding.references)\n    with self.subTest(i=2):\n        finding = findings[2]\n        self.assertEqual('CIS-DI-0006', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** not found HEALTHCHECK statement\\n**Rule short description:** Add HEALTHCHECK instruction to the container image'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0006', finding.references)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('CIS-DI-0008', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** setuid file: urwxr-xr-x usr/bin/chfn, setuid file: urwxr-xr-x usr/bin/chsh, setuid file: urwxr-xr-x usr/bin/passwd, setuid file: urwxr-xr-x bin/umount, setuid file: urwxr-xr-x bin/mount, setgid file: grwxr-xr-x usr/bin/wall, setgid file: grwxr-xr-x usr/bin/expiry, setuid file: urwxr-xr-x bin/su, setgid file: grwxr-xr-x sbin/unix_chkpwd, setuid file: urwxr-xr-x usr/bin/gpasswd, setgid file: grwxr-xr-x usr/bin/chage, setuid file: urwxr-xr-x usr/bin/newgrp\\n**Rule short description:** Confirm safety of setuid/setgid files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0008', finding.references)",
            "def test_dockle(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generated with goodwithtech/dockle (https://github.com/goodwithtech/dockle)'\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/dockle_0_3_15.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(4, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('CIS-DI-0010', finding.vuln_id_from_tool)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** Suspicious ENV key found : DD_ADMIN_PASSWORD, Suspicious ENV key found : DD_CELERY_BROKER_PASSWORD, Suspicious ENV key found : DD_DATABASE_PASSWORD\\n**Rule short description:** Do not store credential in ENVIRONMENT vars/files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0010', finding.references)\n    with self.subTest(i=1):\n        finding = findings[1]\n        self.assertEqual('CIS-DI-0005', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** export DOCKER_CONTENT_TRUST=1 before docker pull/build\\n**Rule short description:** Enable Content trust for Docker'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0005', finding.references)\n    with self.subTest(i=2):\n        finding = findings[2]\n        self.assertEqual('CIS-DI-0006', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** not found HEALTHCHECK statement\\n**Rule short description:** Add HEALTHCHECK instruction to the container image'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0006', finding.references)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('CIS-DI-0008', finding.vuln_id_from_tool)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** setuid file: urwxr-xr-x usr/bin/chfn, setuid file: urwxr-xr-x usr/bin/chsh, setuid file: urwxr-xr-x usr/bin/passwd, setuid file: urwxr-xr-x bin/umount, setuid file: urwxr-xr-x bin/mount, setgid file: grwxr-xr-x usr/bin/wall, setgid file: grwxr-xr-x usr/bin/expiry, setuid file: urwxr-xr-x bin/su, setgid file: grwxr-xr-x sbin/unix_chkpwd, setuid file: urwxr-xr-x usr/bin/gpasswd, setgid file: grwxr-xr-x usr/bin/chage, setuid file: urwxr-xr-x usr/bin/newgrp\\n**Rule short description:** Confirm safety of setuid/setgid files'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md#CIS-DI-0008', finding.references)"
        ]
    },
    {
        "func_name": "test_mobsfscan",
        "original": "def test_mobsfscan(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/mobsfscan.json'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(9, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_mobsfscan(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/mobsfscan.json'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(9, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_mobsfscan(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/mobsfscan.json'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(9, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_mobsfscan(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/mobsfscan.json'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(9, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_mobsfscan(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/mobsfscan.json'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(9, len(findings))\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_mobsfscan(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/mobsfscan.json'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(9, len(findings))\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_gitleaks",
        "original": "def test_gitleaks(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/gitleaks_7.5.0.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(8, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_1_vuln.json', finding.file_path)\n        self.assertEqual(13, finding.line)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_3_vuln.json', finding.file_path)\n        self.assertEqual(44, finding.line)\n    with self.subTest(i=7):\n        finding = findings[7]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```        self.assertEqual(\"AWS\\\\nAKIAIOSFODNN7EXAMPLE\", first_finding.description)```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/tools/test_gitlab_secret_detection_report_parser.py', finding.file_path)\n        self.assertEqual(37, finding.line)",
        "mutated": [
            "def test_gitleaks(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/gitleaks_7.5.0.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(8, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_1_vuln.json', finding.file_path)\n        self.assertEqual(13, finding.line)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_3_vuln.json', finding.file_path)\n        self.assertEqual(44, finding.line)\n    with self.subTest(i=7):\n        finding = findings[7]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```        self.assertEqual(\"AWS\\\\nAKIAIOSFODNN7EXAMPLE\", first_finding.description)```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/tools/test_gitlab_secret_detection_report_parser.py', finding.file_path)\n        self.assertEqual(37, finding.line)",
            "def test_gitleaks(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/gitleaks_7.5.0.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(8, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_1_vuln.json', finding.file_path)\n        self.assertEqual(13, finding.line)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_3_vuln.json', finding.file_path)\n        self.assertEqual(44, finding.line)\n    with self.subTest(i=7):\n        finding = findings[7]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```        self.assertEqual(\"AWS\\\\nAKIAIOSFODNN7EXAMPLE\", first_finding.description)```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/tools/test_gitlab_secret_detection_report_parser.py', finding.file_path)\n        self.assertEqual(37, finding.line)",
            "def test_gitleaks(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/gitleaks_7.5.0.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(8, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_1_vuln.json', finding.file_path)\n        self.assertEqual(13, finding.line)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_3_vuln.json', finding.file_path)\n        self.assertEqual(44, finding.line)\n    with self.subTest(i=7):\n        finding = findings[7]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```        self.assertEqual(\"AWS\\\\nAKIAIOSFODNN7EXAMPLE\", first_finding.description)```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/tools/test_gitlab_secret_detection_report_parser.py', finding.file_path)\n        self.assertEqual(37, finding.line)",
            "def test_gitleaks(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/gitleaks_7.5.0.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(8, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_1_vuln.json', finding.file_path)\n        self.assertEqual(13, finding.line)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_3_vuln.json', finding.file_path)\n        self.assertEqual(44, finding.line)\n    with self.subTest(i=7):\n        finding = findings[7]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```        self.assertEqual(\"AWS\\\\nAKIAIOSFODNN7EXAMPLE\", first_finding.description)```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/tools/test_gitlab_secret_detection_report_parser.py', finding.file_path)\n        self.assertEqual(37, finding.line)",
            "def test_gitleaks(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/gitleaks_7.5.0.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(8, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_1_vuln.json', finding.file_path)\n        self.assertEqual(13, finding.line)\n    with self.subTest(i=3):\n        finding = findings[3]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```      \"raw_source_code_extract\": \"AKIAIOSFODNN7EXAMPLE\",```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/scans/gitlab_secret_detection_report/gitlab_secret_detection_report_3_vuln.json', finding.file_path)\n        self.assertEqual(44, finding.line)\n    with self.subTest(i=7):\n        finding = findings[7]\n        self.assertEqual('AWS Access Key secret detected', finding.title)\n        self.assertEqual('Medium', finding.severity)\n        description = '**Result message:** AWS Access Key secret detected\\n**Snippet:**\\n```        self.assertEqual(\"AWS\\\\nAKIAIOSFODNN7EXAMPLE\", first_finding.description)```'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('dojo/unittests/tools/test_gitlab_secret_detection_report_parser.py', finding.file_path)\n        self.assertEqual(37, finding.line)"
        ]
    },
    {
        "func_name": "test_flawfinder",
        "original": "def test_flawfinder(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('e6c1ad2b1d96ffc4035ed8df070600566ad240b8ded025dac30620f3fd4aa9fd', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('327fc54b75ab37bbbb31a1b71431aaefa8137ff755acc103685ad5adf88f5dda', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('ad8408027235170e870e7662751a01386beb2d2ed8beb75dd4ba8e4a70e91d65', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
        "mutated": [
            "def test_flawfinder(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('e6c1ad2b1d96ffc4035ed8df070600566ad240b8ded025dac30620f3fd4aa9fd', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('327fc54b75ab37bbbb31a1b71431aaefa8137ff755acc103685ad5adf88f5dda', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('ad8408027235170e870e7662751a01386beb2d2ed8beb75dd4ba8e4a70e91d65', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
            "def test_flawfinder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('e6c1ad2b1d96ffc4035ed8df070600566ad240b8ded025dac30620f3fd4aa9fd', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('327fc54b75ab37bbbb31a1b71431aaefa8137ff755acc103685ad5adf88f5dda', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('ad8408027235170e870e7662751a01386beb2d2ed8beb75dd4ba8e4a70e91d65', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
            "def test_flawfinder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('e6c1ad2b1d96ffc4035ed8df070600566ad240b8ded025dac30620f3fd4aa9fd', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('327fc54b75ab37bbbb31a1b71431aaefa8137ff755acc103685ad5adf88f5dda', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('ad8408027235170e870e7662751a01386beb2d2ed8beb75dd4ba8e4a70e91d65', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
            "def test_flawfinder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('e6c1ad2b1d96ffc4035ed8df070600566ad240b8ded025dac30620f3fd4aa9fd', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('327fc54b75ab37bbbb31a1b71431aaefa8137ff755acc103685ad5adf88f5dda', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('ad8408027235170e870e7662751a01386beb2d2ed8beb75dd4ba8e4a70e91d65', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
            "def test_flawfinder(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('e6c1ad2b1d96ffc4035ed8df070600566ad240b8ded025dac30620f3fd4aa9fd', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('327fc54b75ab37bbbb31a1b71431aaefa8137ff755acc103685ad5adf88f5dda', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('ad8408027235170e870e7662751a01386beb2d2ed8beb75dd4ba8e4a70e91d65', finding.unique_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)"
        ]
    },
    {
        "func_name": "test_flawfinder_interfacev2",
        "original": "def test_flawfinder_interfacev2(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(1, len(tests))\n    findings = tests[0].findings\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
        "mutated": [
            "def test_flawfinder_interfacev2(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(1, len(tests))\n    findings = tests[0].findings\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
            "def test_flawfinder_interfacev2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(1, len(tests))\n    findings = tests[0].findings\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
            "def test_flawfinder_interfacev2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(1, len(tests))\n    findings = tests[0].findings\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
            "def test_flawfinder_interfacev2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(1, len(tests))\n    findings = tests[0].findings\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)",
            "def test_flawfinder_interfacev2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/flawfinder.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(1, len(tests))\n    findings = tests[0].findings\n    self.assertEqual(53, len(findings))\n    for finding in findings:\n        self.common_checks(finding)\n    with self.subTest(i=0):\n        finding = findings[0]\n        self.assertEqual('random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).', finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** random/setstate:This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).\\n**Snippet:**\\n```      is.setstate(std::ios::failbit);```\\n**Rule name:** random/setstate\\n**Rule short description:** This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/tree/param.cc', finding.file_path)\n        self.assertEqual(29, finding.line)\n        self.assertEqual(327, finding.cwe)\n        self.assertEqual('FF1048', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/327.html', finding.references)\n    with self.subTest(i=20):\n        finding = findings[20]\n        self.assertEqual('buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).', finding.title)\n        self.assertEqual('Info', finding.severity)\n        description = '**Result message:** buffer/memcpy:Does not check for buffer overflows when copying to destination (CWE-120).\\n**Snippet:**\\n```    std::memcpy(dptr, dmlc::BeginPtr(buffer_) + buffer_ptr_, size);```\\n**Rule name:** buffer/memcpy\\n**Rule short description:** Does not check for buffer overflows when copying to destination (CWE-120).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/common/io.cc', finding.file_path)\n        self.assertEqual(31, finding.line)\n        self.assertEqual(120, finding.cwe)\n        self.assertEqual('FF1004', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)\n    with self.subTest(i=52):\n        finding = findings[52]\n        self.assertEqual(\"buffer/sscanf:The scanf() family's %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\", finding.title)\n        self.assertEqual('High', finding.severity)\n        description = '**Result message:** buffer/sscanf:The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).\\n**Snippet:**\\n```      if (sscanf(argv[i], \"%[^=]=%s\", name, val) == 2) {```\\n**Rule name:** buffer/sscanf\\n**Rule short description:** The scanf() family\\'s %s operation, without a limit specification, permits buffer overflows (CWE-120, CWE-20).'\n        self.assertEqual(description, finding.description)\n        self.assertEqual('src/cli_main.cc', finding.file_path)\n        self.assertEqual(482, finding.line)\n        self.assertEqual('FF1021', finding.vuln_id_from_tool)\n        self.assertEqual('https://cwe.mitre.org/data/definitions/120.html', finding.references)"
        ]
    },
    {
        "func_name": "test_appendix_k1_double_interfacev2",
        "original": "def test_appendix_k1_double_interfacev2(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1_double.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(2, len(tests))\n    with self.subTest(test=0):\n        test = tests[0]\n        self.assertEqual('CodeScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))\n    with self.subTest(test=1):\n        test = tests[1]\n        self.assertEqual('OtherScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))",
        "mutated": [
            "def test_appendix_k1_double_interfacev2(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1_double.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(2, len(tests))\n    with self.subTest(test=0):\n        test = tests[0]\n        self.assertEqual('CodeScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))\n    with self.subTest(test=1):\n        test = tests[1]\n        self.assertEqual('OtherScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))",
            "def test_appendix_k1_double_interfacev2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1_double.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(2, len(tests))\n    with self.subTest(test=0):\n        test = tests[0]\n        self.assertEqual('CodeScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))\n    with self.subTest(test=1):\n        test = tests[1]\n        self.assertEqual('OtherScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))",
            "def test_appendix_k1_double_interfacev2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1_double.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(2, len(tests))\n    with self.subTest(test=0):\n        test = tests[0]\n        self.assertEqual('CodeScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))\n    with self.subTest(test=1):\n        test = tests[1]\n        self.assertEqual('OtherScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))",
            "def test_appendix_k1_double_interfacev2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1_double.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(2, len(tests))\n    with self.subTest(test=0):\n        test = tests[0]\n        self.assertEqual('CodeScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))\n    with self.subTest(test=1):\n        test = tests[1]\n        self.assertEqual('OtherScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))",
            "def test_appendix_k1_double_interfacev2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/appendix_k1_double.sarif'))\n    parser = SarifParser()\n    tests = parser.get_tests(parser.get_scan_types()[0], testfile)\n    self.assertEqual(2, len(tests))\n    with self.subTest(test=0):\n        test = tests[0]\n        self.assertEqual('CodeScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))\n    with self.subTest(test=1):\n        test = tests[1]\n        self.assertEqual('OtherScanner', test.type)\n        findings = test.findings\n        self.assertEqual(0, len(findings))"
        ]
    },
    {
        "func_name": "test_codeql_snippet_report",
        "original": "def test_codeql_snippet_report(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/codeQL-output.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(72, len(findings))\n    item = findings[7]\n    self.assertEqual('good/mod_user.py', item.file_path)\n    self.assertEqual(33, item.line)\n    self.assertEqual('High', item.severity)\n    description = \"**Result message:** Keyword argument 'request' is not a supported parameter name of [function create](1).\\n**Snippet:**\\n```\\n        response = make_response(redirect('/'))\\n        response = libsession.create(request=request, response=response, username=username)\\n        return response\\n\\n```\\n**Rule name:** py/call/wrong-named-argument\\n**Rule short description:** Wrong name for an argument in a call\\n**Rule full description:** Using a named argument whose name does not correspond to a parameter of the called function or method, will result in a TypeError at runtime.\"\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
        "mutated": [
            "def test_codeql_snippet_report(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/codeQL-output.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(72, len(findings))\n    item = findings[7]\n    self.assertEqual('good/mod_user.py', item.file_path)\n    self.assertEqual(33, item.line)\n    self.assertEqual('High', item.severity)\n    description = \"**Result message:** Keyword argument 'request' is not a supported parameter name of [function create](1).\\n**Snippet:**\\n```\\n        response = make_response(redirect('/'))\\n        response = libsession.create(request=request, response=response, username=username)\\n        return response\\n\\n```\\n**Rule name:** py/call/wrong-named-argument\\n**Rule short description:** Wrong name for an argument in a call\\n**Rule full description:** Using a named argument whose name does not correspond to a parameter of the called function or method, will result in a TypeError at runtime.\"\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_codeql_snippet_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/codeQL-output.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(72, len(findings))\n    item = findings[7]\n    self.assertEqual('good/mod_user.py', item.file_path)\n    self.assertEqual(33, item.line)\n    self.assertEqual('High', item.severity)\n    description = \"**Result message:** Keyword argument 'request' is not a supported parameter name of [function create](1).\\n**Snippet:**\\n```\\n        response = make_response(redirect('/'))\\n        response = libsession.create(request=request, response=response, username=username)\\n        return response\\n\\n```\\n**Rule name:** py/call/wrong-named-argument\\n**Rule short description:** Wrong name for an argument in a call\\n**Rule full description:** Using a named argument whose name does not correspond to a parameter of the called function or method, will result in a TypeError at runtime.\"\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_codeql_snippet_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/codeQL-output.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(72, len(findings))\n    item = findings[7]\n    self.assertEqual('good/mod_user.py', item.file_path)\n    self.assertEqual(33, item.line)\n    self.assertEqual('High', item.severity)\n    description = \"**Result message:** Keyword argument 'request' is not a supported parameter name of [function create](1).\\n**Snippet:**\\n```\\n        response = make_response(redirect('/'))\\n        response = libsession.create(request=request, response=response, username=username)\\n        return response\\n\\n```\\n**Rule name:** py/call/wrong-named-argument\\n**Rule short description:** Wrong name for an argument in a call\\n**Rule full description:** Using a named argument whose name does not correspond to a parameter of the called function or method, will result in a TypeError at runtime.\"\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_codeql_snippet_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/codeQL-output.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(72, len(findings))\n    item = findings[7]\n    self.assertEqual('good/mod_user.py', item.file_path)\n    self.assertEqual(33, item.line)\n    self.assertEqual('High', item.severity)\n    description = \"**Result message:** Keyword argument 'request' is not a supported parameter name of [function create](1).\\n**Snippet:**\\n```\\n        response = make_response(redirect('/'))\\n        response = libsession.create(request=request, response=response, username=username)\\n        return response\\n\\n```\\n**Rule name:** py/call/wrong-named-argument\\n**Rule short description:** Wrong name for an argument in a call\\n**Rule full description:** Using a named argument whose name does not correspond to a parameter of the called function or method, will result in a TypeError at runtime.\"\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)",
            "def test_codeql_snippet_report(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/codeQL-output.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(72, len(findings))\n    item = findings[7]\n    self.assertEqual('good/mod_user.py', item.file_path)\n    self.assertEqual(33, item.line)\n    self.assertEqual('High', item.severity)\n    description = \"**Result message:** Keyword argument 'request' is not a supported parameter name of [function create](1).\\n**Snippet:**\\n```\\n        response = make_response(redirect('/'))\\n        response = libsession.create(request=request, response=response, username=username)\\n        return response\\n\\n```\\n**Rule name:** py/call/wrong-named-argument\\n**Rule short description:** Wrong name for an argument in a call\\n**Rule full description:** Using a named argument whose name does not correspond to a parameter of the called function or method, will result in a TypeError at runtime.\"\n    self.assertEqual(description, item.description)\n    for finding in findings:\n        self.common_checks(finding)"
        ]
    },
    {
        "func_name": "test_severity_cvss_from_grype",
        "original": "def test_severity_cvss_from_grype(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/cxf-3.4.6.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(22, len(findings))\n    item = findings[0]\n    self.assertEqual('Low', item.severity)\n    self.assertEqual(2.1, item.cvssv3_score)\n    item = findings[6]\n    self.assertEqual('High', item.severity)\n    self.assertEqual(7.8, item.cvssv3_score)",
        "mutated": [
            "def test_severity_cvss_from_grype(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/cxf-3.4.6.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(22, len(findings))\n    item = findings[0]\n    self.assertEqual('Low', item.severity)\n    self.assertEqual(2.1, item.cvssv3_score)\n    item = findings[6]\n    self.assertEqual('High', item.severity)\n    self.assertEqual(7.8, item.cvssv3_score)",
            "def test_severity_cvss_from_grype(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/cxf-3.4.6.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(22, len(findings))\n    item = findings[0]\n    self.assertEqual('Low', item.severity)\n    self.assertEqual(2.1, item.cvssv3_score)\n    item = findings[6]\n    self.assertEqual('High', item.severity)\n    self.assertEqual(7.8, item.cvssv3_score)",
            "def test_severity_cvss_from_grype(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/cxf-3.4.6.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(22, len(findings))\n    item = findings[0]\n    self.assertEqual('Low', item.severity)\n    self.assertEqual(2.1, item.cvssv3_score)\n    item = findings[6]\n    self.assertEqual('High', item.severity)\n    self.assertEqual(7.8, item.cvssv3_score)",
            "def test_severity_cvss_from_grype(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/cxf-3.4.6.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(22, len(findings))\n    item = findings[0]\n    self.assertEqual('Low', item.severity)\n    self.assertEqual(2.1, item.cvssv3_score)\n    item = findings[6]\n    self.assertEqual('High', item.severity)\n    self.assertEqual(7.8, item.cvssv3_score)",
            "def test_severity_cvss_from_grype(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/cxf-3.4.6.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertEqual(22, len(findings))\n    item = findings[0]\n    self.assertEqual('Low', item.severity)\n    self.assertEqual(2.1, item.cvssv3_score)\n    item = findings[6]\n    self.assertEqual('High', item.severity)\n    self.assertEqual(7.8, item.cvssv3_score)"
        ]
    },
    {
        "func_name": "test_get_fingerprints_hashes",
        "original": "def test_get_fingerprints_hashes(self):\n    data = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v3': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 3, 'value': '34567900abcde'}}, get_fingerprints_hashes(data['fingerprints']))\n    data2 = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v1': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 2, 'value': '234567900abcd'}}, get_fingerprints_hashes(data2['fingerprints']))",
        "mutated": [
            "def test_get_fingerprints_hashes(self):\n    if False:\n        i = 10\n    data = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v3': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 3, 'value': '34567900abcde'}}, get_fingerprints_hashes(data['fingerprints']))\n    data2 = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v1': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 2, 'value': '234567900abcd'}}, get_fingerprints_hashes(data2['fingerprints']))",
            "def test_get_fingerprints_hashes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v3': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 3, 'value': '34567900abcde'}}, get_fingerprints_hashes(data['fingerprints']))\n    data2 = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v1': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 2, 'value': '234567900abcd'}}, get_fingerprints_hashes(data2['fingerprints']))",
            "def test_get_fingerprints_hashes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v3': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 3, 'value': '34567900abcde'}}, get_fingerprints_hashes(data['fingerprints']))\n    data2 = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v1': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 2, 'value': '234567900abcd'}}, get_fingerprints_hashes(data2['fingerprints']))",
            "def test_get_fingerprints_hashes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v3': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 3, 'value': '34567900abcde'}}, get_fingerprints_hashes(data['fingerprints']))\n    data2 = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v1': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 2, 'value': '234567900abcd'}}, get_fingerprints_hashes(data2['fingerprints']))",
            "def test_get_fingerprints_hashes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v3': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 3, 'value': '34567900abcde'}}, get_fingerprints_hashes(data['fingerprints']))\n    data2 = {'fingerprints': {'stableResultHash/v2': '234567900abcd', 'stableResultHash/v1': '34567900abcde'}}\n    self.assertEqual({'stableResultHash': {'version': 2, 'value': '234567900abcd'}}, get_fingerprints_hashes(data2['fingerprints']))"
        ]
    },
    {
        "func_name": "test_tags_from_result_properties",
        "original": "def test_tags_from_result_properties(self):\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    item = findings[0]\n    self.assertEqual(['Scan'], item.tags)",
        "mutated": [
            "def test_tags_from_result_properties(self):\n    if False:\n        i = 10\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    item = findings[0]\n    self.assertEqual(['Scan'], item.tags)",
            "def test_tags_from_result_properties(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    item = findings[0]\n    self.assertEqual(['Scan'], item.tags)",
            "def test_tags_from_result_properties(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    item = findings[0]\n    self.assertEqual(['Scan'], item.tags)",
            "def test_tags_from_result_properties(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    item = findings[0]\n    self.assertEqual(['Scan'], item.tags)",
            "def test_tags_from_result_properties(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(path.join(path.dirname(__file__), '../scans/sarif/taint-python-report.sarif'))\n    parser = SarifParser()\n    findings = parser.get_findings(testfile, Test())\n    item = findings[0]\n    self.assertEqual(['Scan'], item.tags)"
        ]
    }
]