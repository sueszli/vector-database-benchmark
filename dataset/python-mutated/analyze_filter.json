[
    {
        "func_name": "_match_path_and_rule",
        "original": "def _match_path_and_rule(path: str, rule: str, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns whether a given path matches a given rule.\n\n    Args:\n        path (str): A file path string.\n        rule (str): A rule file path string.\n        patterns (Iterable[str]): An iterable of pattern strings.\n\n    Returns:\n        bool: True if the path matches a rule. Otherwise, False.\n    \"\"\"\n    result = True\n    for (s, fp, rp) in patterns:\n        if match(rp, rule) and match(fp, path):\n            result = s\n    return result",
        "mutated": [
            "def _match_path_and_rule(path: str, rule: str, patterns: Iterable[str]) -> bool:\n    if False:\n        i = 10\n    'Returns whether a given path matches a given rule.\\n\\n    Args:\\n        path (str): A file path string.\\n        rule (str): A rule file path string.\\n        patterns (Iterable[str]): An iterable of pattern strings.\\n\\n    Returns:\\n        bool: True if the path matches a rule. Otherwise, False.\\n    '\n    result = True\n    for (s, fp, rp) in patterns:\n        if match(rp, rule) and match(fp, path):\n            result = s\n    return result",
            "def _match_path_and_rule(path: str, rule: str, patterns: Iterable[str]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns whether a given path matches a given rule.\\n\\n    Args:\\n        path (str): A file path string.\\n        rule (str): A rule file path string.\\n        patterns (Iterable[str]): An iterable of pattern strings.\\n\\n    Returns:\\n        bool: True if the path matches a rule. Otherwise, False.\\n    '\n    result = True\n    for (s, fp, rp) in patterns:\n        if match(rp, rule) and match(fp, path):\n            result = s\n    return result",
            "def _match_path_and_rule(path: str, rule: str, patterns: Iterable[str]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns whether a given path matches a given rule.\\n\\n    Args:\\n        path (str): A file path string.\\n        rule (str): A rule file path string.\\n        patterns (Iterable[str]): An iterable of pattern strings.\\n\\n    Returns:\\n        bool: True if the path matches a rule. Otherwise, False.\\n    '\n    result = True\n    for (s, fp, rp) in patterns:\n        if match(rp, rule) and match(fp, path):\n            result = s\n    return result",
            "def _match_path_and_rule(path: str, rule: str, patterns: Iterable[str]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns whether a given path matches a given rule.\\n\\n    Args:\\n        path (str): A file path string.\\n        rule (str): A rule file path string.\\n        patterns (Iterable[str]): An iterable of pattern strings.\\n\\n    Returns:\\n        bool: True if the path matches a rule. Otherwise, False.\\n    '\n    result = True\n    for (s, fp, rp) in patterns:\n        if match(rp, rule) and match(fp, path):\n            result = s\n    return result",
            "def _match_path_and_rule(path: str, rule: str, patterns: Iterable[str]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns whether a given path matches a given rule.\\n\\n    Args:\\n        path (str): A file path string.\\n        rule (str): A rule file path string.\\n        patterns (Iterable[str]): An iterable of pattern strings.\\n\\n    Returns:\\n        bool: True if the path matches a rule. Otherwise, False.\\n    '\n    result = True\n    for (s, fp, rp) in patterns:\n        if match(rp, rule) and match(fp, path):\n            result = s\n    return result"
        ]
    },
    {
        "func_name": "_parse_pattern",
        "original": "def _parse_pattern(line: str) -> Tuple[str]:\n    \"\"\"Parses a given pattern line.\n\n    Args:\n        line (str): The line string that contains the rule.\n\n    Returns:\n        Tuple[str]: The parsed sign, file pattern, and rule pattern from the\n                    line.\n    \"\"\"\n    sep_char = ':'\n    esc_char = '\\\\'\n    file_pattern = ''\n    rule_pattern = ''\n    seen_separator = False\n    sign = True\n    u_line = line\n    if line:\n        if line[0] == '-':\n            sign = False\n            u_line = line[1:]\n        elif line[0] == '+':\n            u_line = line[1:]\n    i = 0\n    while i < len(u_line):\n        c = u_line[i]\n        i = i + 1\n        if c == sep_char:\n            if seen_separator:\n                raise Exception('Invalid pattern: \"' + line + '\" Contains more than one separator!')\n            seen_separator = True\n            continue\n        elif c == esc_char:\n            next_c = u_line[i] if i < len(u_line) else None\n            if next_c in ['+', '-', esc_char, sep_char]:\n                i = i + 1\n                c = next_c\n        if seen_separator:\n            rule_pattern = rule_pattern + c\n        else:\n            file_pattern = file_pattern + c\n    if not rule_pattern:\n        rule_pattern = '**'\n    return (sign, file_pattern, rule_pattern)",
        "mutated": [
            "def _parse_pattern(line: str) -> Tuple[str]:\n    if False:\n        i = 10\n    'Parses a given pattern line.\\n\\n    Args:\\n        line (str): The line string that contains the rule.\\n\\n    Returns:\\n        Tuple[str]: The parsed sign, file pattern, and rule pattern from the\\n                    line.\\n    '\n    sep_char = ':'\n    esc_char = '\\\\'\n    file_pattern = ''\n    rule_pattern = ''\n    seen_separator = False\n    sign = True\n    u_line = line\n    if line:\n        if line[0] == '-':\n            sign = False\n            u_line = line[1:]\n        elif line[0] == '+':\n            u_line = line[1:]\n    i = 0\n    while i < len(u_line):\n        c = u_line[i]\n        i = i + 1\n        if c == sep_char:\n            if seen_separator:\n                raise Exception('Invalid pattern: \"' + line + '\" Contains more than one separator!')\n            seen_separator = True\n            continue\n        elif c == esc_char:\n            next_c = u_line[i] if i < len(u_line) else None\n            if next_c in ['+', '-', esc_char, sep_char]:\n                i = i + 1\n                c = next_c\n        if seen_separator:\n            rule_pattern = rule_pattern + c\n        else:\n            file_pattern = file_pattern + c\n    if not rule_pattern:\n        rule_pattern = '**'\n    return (sign, file_pattern, rule_pattern)",
            "def _parse_pattern(line: str) -> Tuple[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Parses a given pattern line.\\n\\n    Args:\\n        line (str): The line string that contains the rule.\\n\\n    Returns:\\n        Tuple[str]: The parsed sign, file pattern, and rule pattern from the\\n                    line.\\n    '\n    sep_char = ':'\n    esc_char = '\\\\'\n    file_pattern = ''\n    rule_pattern = ''\n    seen_separator = False\n    sign = True\n    u_line = line\n    if line:\n        if line[0] == '-':\n            sign = False\n            u_line = line[1:]\n        elif line[0] == '+':\n            u_line = line[1:]\n    i = 0\n    while i < len(u_line):\n        c = u_line[i]\n        i = i + 1\n        if c == sep_char:\n            if seen_separator:\n                raise Exception('Invalid pattern: \"' + line + '\" Contains more than one separator!')\n            seen_separator = True\n            continue\n        elif c == esc_char:\n            next_c = u_line[i] if i < len(u_line) else None\n            if next_c in ['+', '-', esc_char, sep_char]:\n                i = i + 1\n                c = next_c\n        if seen_separator:\n            rule_pattern = rule_pattern + c\n        else:\n            file_pattern = file_pattern + c\n    if not rule_pattern:\n        rule_pattern = '**'\n    return (sign, file_pattern, rule_pattern)",
            "def _parse_pattern(line: str) -> Tuple[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Parses a given pattern line.\\n\\n    Args:\\n        line (str): The line string that contains the rule.\\n\\n    Returns:\\n        Tuple[str]: The parsed sign, file pattern, and rule pattern from the\\n                    line.\\n    '\n    sep_char = ':'\n    esc_char = '\\\\'\n    file_pattern = ''\n    rule_pattern = ''\n    seen_separator = False\n    sign = True\n    u_line = line\n    if line:\n        if line[0] == '-':\n            sign = False\n            u_line = line[1:]\n        elif line[0] == '+':\n            u_line = line[1:]\n    i = 0\n    while i < len(u_line):\n        c = u_line[i]\n        i = i + 1\n        if c == sep_char:\n            if seen_separator:\n                raise Exception('Invalid pattern: \"' + line + '\" Contains more than one separator!')\n            seen_separator = True\n            continue\n        elif c == esc_char:\n            next_c = u_line[i] if i < len(u_line) else None\n            if next_c in ['+', '-', esc_char, sep_char]:\n                i = i + 1\n                c = next_c\n        if seen_separator:\n            rule_pattern = rule_pattern + c\n        else:\n            file_pattern = file_pattern + c\n    if not rule_pattern:\n        rule_pattern = '**'\n    return (sign, file_pattern, rule_pattern)",
            "def _parse_pattern(line: str) -> Tuple[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Parses a given pattern line.\\n\\n    Args:\\n        line (str): The line string that contains the rule.\\n\\n    Returns:\\n        Tuple[str]: The parsed sign, file pattern, and rule pattern from the\\n                    line.\\n    '\n    sep_char = ':'\n    esc_char = '\\\\'\n    file_pattern = ''\n    rule_pattern = ''\n    seen_separator = False\n    sign = True\n    u_line = line\n    if line:\n        if line[0] == '-':\n            sign = False\n            u_line = line[1:]\n        elif line[0] == '+':\n            u_line = line[1:]\n    i = 0\n    while i < len(u_line):\n        c = u_line[i]\n        i = i + 1\n        if c == sep_char:\n            if seen_separator:\n                raise Exception('Invalid pattern: \"' + line + '\" Contains more than one separator!')\n            seen_separator = True\n            continue\n        elif c == esc_char:\n            next_c = u_line[i] if i < len(u_line) else None\n            if next_c in ['+', '-', esc_char, sep_char]:\n                i = i + 1\n                c = next_c\n        if seen_separator:\n            rule_pattern = rule_pattern + c\n        else:\n            file_pattern = file_pattern + c\n    if not rule_pattern:\n        rule_pattern = '**'\n    return (sign, file_pattern, rule_pattern)",
            "def _parse_pattern(line: str) -> Tuple[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Parses a given pattern line.\\n\\n    Args:\\n        line (str): The line string that contains the rule.\\n\\n    Returns:\\n        Tuple[str]: The parsed sign, file pattern, and rule pattern from the\\n                    line.\\n    '\n    sep_char = ':'\n    esc_char = '\\\\'\n    file_pattern = ''\n    rule_pattern = ''\n    seen_separator = False\n    sign = True\n    u_line = line\n    if line:\n        if line[0] == '-':\n            sign = False\n            u_line = line[1:]\n        elif line[0] == '+':\n            u_line = line[1:]\n    i = 0\n    while i < len(u_line):\n        c = u_line[i]\n        i = i + 1\n        if c == sep_char:\n            if seen_separator:\n                raise Exception('Invalid pattern: \"' + line + '\" Contains more than one separator!')\n            seen_separator = True\n            continue\n        elif c == esc_char:\n            next_c = u_line[i] if i < len(u_line) else None\n            if next_c in ['+', '-', esc_char, sep_char]:\n                i = i + 1\n                c = next_c\n        if seen_separator:\n            rule_pattern = rule_pattern + c\n        else:\n            file_pattern = file_pattern + c\n    if not rule_pattern:\n        rule_pattern = '**'\n    return (sign, file_pattern, rule_pattern)"
        ]
    },
    {
        "func_name": "filter_sarif",
        "original": "def filter_sarif(input_sarif: PathLike, output_sarif: PathLike, patterns: List[str], split_lines: bool) -> None:\n    \"\"\"Filters a SARIF file with a given set of filter patterns.\n\n    Args:\n        input_sarif (PathLike): Input SARIF file path.\n        output_sarif (PathLike): Output SARIF file path.\n        patterns (PathLike): List of filter pattern strings.\n        split_lines (PathLike): Whether to split lines in individual patterns.\n    \"\"\"\n    if split_lines:\n        tmp = []\n        for p in patterns:\n            tmp = tmp + re.split('\\r?\\n', p)\n        patterns = tmp\n    patterns = [_parse_pattern(p) for p in patterns if p]\n    logging.debug('Given patterns:')\n    for (s, fp, rp) in patterns:\n        logging.debug('files: {file_pattern}    rules: {rule_pattern} ({sign})'.format(file_pattern=fp, rule_pattern=rp, sign='positive' if s else 'negative'))\n    with open(input_sarif, 'r') as f:\n        s = json.load(f)\n    for run in s.get('runs', []):\n        if run.get('results', []):\n            new_results = []\n            for r in run['results']:\n                if r.get('locations', []):\n                    new_locations = []\n                    for l in r['locations']:\n                        uri = l.get('physicalLocation', {}).get('artifactLocation', {}).get('uri', None)\n                        ruleId = r['ruleId']\n                        if uri is None or _match_path_and_rule(uri, ruleId, patterns):\n                            new_locations.append(l)\n                    r['locations'] = new_locations\n                    if new_locations:\n                        new_results.append(r)\n                else:\n                    new_results.append(r)\n            run['results'] = new_results\n    with open(output_sarif, 'w') as f:\n        json.dump(s, f, indent=2)",
        "mutated": [
            "def filter_sarif(input_sarif: PathLike, output_sarif: PathLike, patterns: List[str], split_lines: bool) -> None:\n    if False:\n        i = 10\n    'Filters a SARIF file with a given set of filter patterns.\\n\\n    Args:\\n        input_sarif (PathLike): Input SARIF file path.\\n        output_sarif (PathLike): Output SARIF file path.\\n        patterns (PathLike): List of filter pattern strings.\\n        split_lines (PathLike): Whether to split lines in individual patterns.\\n    '\n    if split_lines:\n        tmp = []\n        for p in patterns:\n            tmp = tmp + re.split('\\r?\\n', p)\n        patterns = tmp\n    patterns = [_parse_pattern(p) for p in patterns if p]\n    logging.debug('Given patterns:')\n    for (s, fp, rp) in patterns:\n        logging.debug('files: {file_pattern}    rules: {rule_pattern} ({sign})'.format(file_pattern=fp, rule_pattern=rp, sign='positive' if s else 'negative'))\n    with open(input_sarif, 'r') as f:\n        s = json.load(f)\n    for run in s.get('runs', []):\n        if run.get('results', []):\n            new_results = []\n            for r in run['results']:\n                if r.get('locations', []):\n                    new_locations = []\n                    for l in r['locations']:\n                        uri = l.get('physicalLocation', {}).get('artifactLocation', {}).get('uri', None)\n                        ruleId = r['ruleId']\n                        if uri is None or _match_path_and_rule(uri, ruleId, patterns):\n                            new_locations.append(l)\n                    r['locations'] = new_locations\n                    if new_locations:\n                        new_results.append(r)\n                else:\n                    new_results.append(r)\n            run['results'] = new_results\n    with open(output_sarif, 'w') as f:\n        json.dump(s, f, indent=2)",
            "def filter_sarif(input_sarif: PathLike, output_sarif: PathLike, patterns: List[str], split_lines: bool) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Filters a SARIF file with a given set of filter patterns.\\n\\n    Args:\\n        input_sarif (PathLike): Input SARIF file path.\\n        output_sarif (PathLike): Output SARIF file path.\\n        patterns (PathLike): List of filter pattern strings.\\n        split_lines (PathLike): Whether to split lines in individual patterns.\\n    '\n    if split_lines:\n        tmp = []\n        for p in patterns:\n            tmp = tmp + re.split('\\r?\\n', p)\n        patterns = tmp\n    patterns = [_parse_pattern(p) for p in patterns if p]\n    logging.debug('Given patterns:')\n    for (s, fp, rp) in patterns:\n        logging.debug('files: {file_pattern}    rules: {rule_pattern} ({sign})'.format(file_pattern=fp, rule_pattern=rp, sign='positive' if s else 'negative'))\n    with open(input_sarif, 'r') as f:\n        s = json.load(f)\n    for run in s.get('runs', []):\n        if run.get('results', []):\n            new_results = []\n            for r in run['results']:\n                if r.get('locations', []):\n                    new_locations = []\n                    for l in r['locations']:\n                        uri = l.get('physicalLocation', {}).get('artifactLocation', {}).get('uri', None)\n                        ruleId = r['ruleId']\n                        if uri is None or _match_path_and_rule(uri, ruleId, patterns):\n                            new_locations.append(l)\n                    r['locations'] = new_locations\n                    if new_locations:\n                        new_results.append(r)\n                else:\n                    new_results.append(r)\n            run['results'] = new_results\n    with open(output_sarif, 'w') as f:\n        json.dump(s, f, indent=2)",
            "def filter_sarif(input_sarif: PathLike, output_sarif: PathLike, patterns: List[str], split_lines: bool) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Filters a SARIF file with a given set of filter patterns.\\n\\n    Args:\\n        input_sarif (PathLike): Input SARIF file path.\\n        output_sarif (PathLike): Output SARIF file path.\\n        patterns (PathLike): List of filter pattern strings.\\n        split_lines (PathLike): Whether to split lines in individual patterns.\\n    '\n    if split_lines:\n        tmp = []\n        for p in patterns:\n            tmp = tmp + re.split('\\r?\\n', p)\n        patterns = tmp\n    patterns = [_parse_pattern(p) for p in patterns if p]\n    logging.debug('Given patterns:')\n    for (s, fp, rp) in patterns:\n        logging.debug('files: {file_pattern}    rules: {rule_pattern} ({sign})'.format(file_pattern=fp, rule_pattern=rp, sign='positive' if s else 'negative'))\n    with open(input_sarif, 'r') as f:\n        s = json.load(f)\n    for run in s.get('runs', []):\n        if run.get('results', []):\n            new_results = []\n            for r in run['results']:\n                if r.get('locations', []):\n                    new_locations = []\n                    for l in r['locations']:\n                        uri = l.get('physicalLocation', {}).get('artifactLocation', {}).get('uri', None)\n                        ruleId = r['ruleId']\n                        if uri is None or _match_path_and_rule(uri, ruleId, patterns):\n                            new_locations.append(l)\n                    r['locations'] = new_locations\n                    if new_locations:\n                        new_results.append(r)\n                else:\n                    new_results.append(r)\n            run['results'] = new_results\n    with open(output_sarif, 'w') as f:\n        json.dump(s, f, indent=2)",
            "def filter_sarif(input_sarif: PathLike, output_sarif: PathLike, patterns: List[str], split_lines: bool) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Filters a SARIF file with a given set of filter patterns.\\n\\n    Args:\\n        input_sarif (PathLike): Input SARIF file path.\\n        output_sarif (PathLike): Output SARIF file path.\\n        patterns (PathLike): List of filter pattern strings.\\n        split_lines (PathLike): Whether to split lines in individual patterns.\\n    '\n    if split_lines:\n        tmp = []\n        for p in patterns:\n            tmp = tmp + re.split('\\r?\\n', p)\n        patterns = tmp\n    patterns = [_parse_pattern(p) for p in patterns if p]\n    logging.debug('Given patterns:')\n    for (s, fp, rp) in patterns:\n        logging.debug('files: {file_pattern}    rules: {rule_pattern} ({sign})'.format(file_pattern=fp, rule_pattern=rp, sign='positive' if s else 'negative'))\n    with open(input_sarif, 'r') as f:\n        s = json.load(f)\n    for run in s.get('runs', []):\n        if run.get('results', []):\n            new_results = []\n            for r in run['results']:\n                if r.get('locations', []):\n                    new_locations = []\n                    for l in r['locations']:\n                        uri = l.get('physicalLocation', {}).get('artifactLocation', {}).get('uri', None)\n                        ruleId = r['ruleId']\n                        if uri is None or _match_path_and_rule(uri, ruleId, patterns):\n                            new_locations.append(l)\n                    r['locations'] = new_locations\n                    if new_locations:\n                        new_results.append(r)\n                else:\n                    new_results.append(r)\n            run['results'] = new_results\n    with open(output_sarif, 'w') as f:\n        json.dump(s, f, indent=2)",
            "def filter_sarif(input_sarif: PathLike, output_sarif: PathLike, patterns: List[str], split_lines: bool) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Filters a SARIF file with a given set of filter patterns.\\n\\n    Args:\\n        input_sarif (PathLike): Input SARIF file path.\\n        output_sarif (PathLike): Output SARIF file path.\\n        patterns (PathLike): List of filter pattern strings.\\n        split_lines (PathLike): Whether to split lines in individual patterns.\\n    '\n    if split_lines:\n        tmp = []\n        for p in patterns:\n            tmp = tmp + re.split('\\r?\\n', p)\n        patterns = tmp\n    patterns = [_parse_pattern(p) for p in patterns if p]\n    logging.debug('Given patterns:')\n    for (s, fp, rp) in patterns:\n        logging.debug('files: {file_pattern}    rules: {rule_pattern} ({sign})'.format(file_pattern=fp, rule_pattern=rp, sign='positive' if s else 'negative'))\n    with open(input_sarif, 'r') as f:\n        s = json.load(f)\n    for run in s.get('runs', []):\n        if run.get('results', []):\n            new_results = []\n            for r in run['results']:\n                if r.get('locations', []):\n                    new_locations = []\n                    for l in r['locations']:\n                        uri = l.get('physicalLocation', {}).get('artifactLocation', {}).get('uri', None)\n                        ruleId = r['ruleId']\n                        if uri is None or _match_path_and_rule(uri, ruleId, patterns):\n                            new_locations.append(l)\n                    r['locations'] = new_locations\n                    if new_locations:\n                        new_results.append(r)\n                else:\n                    new_results.append(r)\n            run['results'] = new_results\n    with open(output_sarif, 'w') as f:\n        json.dump(s, f, indent=2)"
        ]
    }
]