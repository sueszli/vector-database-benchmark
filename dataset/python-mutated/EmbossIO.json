[
    {
        "func_name": "__next__",
        "original": "def __next__(self):\n    \"\"\"Parse the next alignment from the handle.\"\"\"\n    handle = self.handle\n    if self._header is None:\n        line = handle.readline()\n    else:\n        line = self._header\n        self._header = None\n    if not line:\n        raise StopIteration\n    while line.rstrip() != '#=======================================':\n        line = handle.readline()\n        if not line:\n            raise StopIteration\n    length_of_seqs = None\n    number_of_seqs = None\n    ids = []\n    header_dict = {}\n    while line[0] == '#':\n        parts = line[1:].split(':', 1)\n        key = parts[0].lower().strip()\n        if key == 'aligned_sequences':\n            number_of_seqs = int(parts[1].strip())\n            assert len(ids) == 0\n            for i in range(number_of_seqs):\n                line = handle.readline()\n                parts = line[1:].strip().split(':', 1)\n                assert i + 1 == int(parts[0].strip())\n                ids.append(parts[1].strip())\n            assert len(ids) == number_of_seqs\n        if key == 'length':\n            length_of_seqs = int(parts[1].strip())\n        if key == 'identity':\n            header_dict['identity'] = int(parts[1].strip().split('/')[0])\n        if key == 'similarity':\n            header_dict['similarity'] = int(parts[1].strip().split('/')[0])\n        if key == 'gaps':\n            header_dict['gaps'] = int(parts[1].strip().split('/')[0])\n        if key == 'score':\n            header_dict['score'] = float(parts[1].strip())\n        line = handle.readline()\n    if number_of_seqs is None:\n        raise ValueError('Number of sequences missing!')\n    if length_of_seqs is None:\n        raise ValueError('Length of sequences missing!')\n    if self.records_per_alignment is not None and self.records_per_alignment != number_of_seqs:\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (number_of_seqs, self.records_per_alignment))\n    seqs = [''] * len(ids)\n    seq_starts = []\n    index = 0\n    while line:\n        if len(line) > 21:\n            id_start = line[:21].strip().split(None, 1)\n            seq_end = line[21:].strip().split(None, 1)\n            if len(id_start) == 2 and len(seq_end) == 2:\n                (id, start) = id_start\n                (seq, end) = seq_end\n                if start >= end:\n                    if seq.replace('-', '') == '':\n                        start = int(start)\n                        end = int(end)\n                    else:\n                        start = int(start) - 1\n                        end = int(end)\n                else:\n                    assert seq.replace('-', '') != '', repr(line)\n                    start = int(start) - 1\n                    end = int(end)\n                if index < 0 or index >= number_of_seqs:\n                    raise ValueError('Expected index %i in range [0,%i)' % (index, number_of_seqs))\n                assert id == ids[index] or id == ids[index][:len(id)]\n                if len(seq_starts) == index:\n                    seq_starts.append(start)\n                if start >= end:\n                    assert seq.replace('-', '') == '', line\n                elif start - seq_starts[index] != len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r), line says start %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], start, line))\n                seqs[index] += seq\n                if end != seq_starts[index] + len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r, start=%i), file says end %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], seq_starts[index], end, line))\n                index += 1\n                if index >= number_of_seqs:\n                    index = 0\n            else:\n                pass\n        elif line.strip() == '':\n            pass\n        else:\n            raise ValueError(f'Unrecognised EMBOSS pairwise line: {line!r}\\n')\n        line = handle.readline()\n        if line.rstrip() == '#---------------------------------------' or line.rstrip() == '#=======================================':\n            self._header = line\n            break\n    assert index == 0\n    if self.records_per_alignment is not None and self.records_per_alignment != len(ids):\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (len(ids), self.records_per_alignment))\n    records = []\n    for (id, seq) in zip(ids, seqs):\n        if len(seq) != length_of_seqs:\n            raise ValueError('Error parsing alignment - sequences of different length? You could be using an old version of EMBOSS.')\n        records.append(SeqRecord(Seq(seq), id=id, description=id))\n    return MultipleSeqAlignment(records, annotations=header_dict)",
        "mutated": [
            "def __next__(self):\n    if False:\n        i = 10\n    'Parse the next alignment from the handle.'\n    handle = self.handle\n    if self._header is None:\n        line = handle.readline()\n    else:\n        line = self._header\n        self._header = None\n    if not line:\n        raise StopIteration\n    while line.rstrip() != '#=======================================':\n        line = handle.readline()\n        if not line:\n            raise StopIteration\n    length_of_seqs = None\n    number_of_seqs = None\n    ids = []\n    header_dict = {}\n    while line[0] == '#':\n        parts = line[1:].split(':', 1)\n        key = parts[0].lower().strip()\n        if key == 'aligned_sequences':\n            number_of_seqs = int(parts[1].strip())\n            assert len(ids) == 0\n            for i in range(number_of_seqs):\n                line = handle.readline()\n                parts = line[1:].strip().split(':', 1)\n                assert i + 1 == int(parts[0].strip())\n                ids.append(parts[1].strip())\n            assert len(ids) == number_of_seqs\n        if key == 'length':\n            length_of_seqs = int(parts[1].strip())\n        if key == 'identity':\n            header_dict['identity'] = int(parts[1].strip().split('/')[0])\n        if key == 'similarity':\n            header_dict['similarity'] = int(parts[1].strip().split('/')[0])\n        if key == 'gaps':\n            header_dict['gaps'] = int(parts[1].strip().split('/')[0])\n        if key == 'score':\n            header_dict['score'] = float(parts[1].strip())\n        line = handle.readline()\n    if number_of_seqs is None:\n        raise ValueError('Number of sequences missing!')\n    if length_of_seqs is None:\n        raise ValueError('Length of sequences missing!')\n    if self.records_per_alignment is not None and self.records_per_alignment != number_of_seqs:\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (number_of_seqs, self.records_per_alignment))\n    seqs = [''] * len(ids)\n    seq_starts = []\n    index = 0\n    while line:\n        if len(line) > 21:\n            id_start = line[:21].strip().split(None, 1)\n            seq_end = line[21:].strip().split(None, 1)\n            if len(id_start) == 2 and len(seq_end) == 2:\n                (id, start) = id_start\n                (seq, end) = seq_end\n                if start >= end:\n                    if seq.replace('-', '') == '':\n                        start = int(start)\n                        end = int(end)\n                    else:\n                        start = int(start) - 1\n                        end = int(end)\n                else:\n                    assert seq.replace('-', '') != '', repr(line)\n                    start = int(start) - 1\n                    end = int(end)\n                if index < 0 or index >= number_of_seqs:\n                    raise ValueError('Expected index %i in range [0,%i)' % (index, number_of_seqs))\n                assert id == ids[index] or id == ids[index][:len(id)]\n                if len(seq_starts) == index:\n                    seq_starts.append(start)\n                if start >= end:\n                    assert seq.replace('-', '') == '', line\n                elif start - seq_starts[index] != len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r), line says start %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], start, line))\n                seqs[index] += seq\n                if end != seq_starts[index] + len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r, start=%i), file says end %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], seq_starts[index], end, line))\n                index += 1\n                if index >= number_of_seqs:\n                    index = 0\n            else:\n                pass\n        elif line.strip() == '':\n            pass\n        else:\n            raise ValueError(f'Unrecognised EMBOSS pairwise line: {line!r}\\n')\n        line = handle.readline()\n        if line.rstrip() == '#---------------------------------------' or line.rstrip() == '#=======================================':\n            self._header = line\n            break\n    assert index == 0\n    if self.records_per_alignment is not None and self.records_per_alignment != len(ids):\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (len(ids), self.records_per_alignment))\n    records = []\n    for (id, seq) in zip(ids, seqs):\n        if len(seq) != length_of_seqs:\n            raise ValueError('Error parsing alignment - sequences of different length? You could be using an old version of EMBOSS.')\n        records.append(SeqRecord(Seq(seq), id=id, description=id))\n    return MultipleSeqAlignment(records, annotations=header_dict)",
            "def __next__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Parse the next alignment from the handle.'\n    handle = self.handle\n    if self._header is None:\n        line = handle.readline()\n    else:\n        line = self._header\n        self._header = None\n    if not line:\n        raise StopIteration\n    while line.rstrip() != '#=======================================':\n        line = handle.readline()\n        if not line:\n            raise StopIteration\n    length_of_seqs = None\n    number_of_seqs = None\n    ids = []\n    header_dict = {}\n    while line[0] == '#':\n        parts = line[1:].split(':', 1)\n        key = parts[0].lower().strip()\n        if key == 'aligned_sequences':\n            number_of_seqs = int(parts[1].strip())\n            assert len(ids) == 0\n            for i in range(number_of_seqs):\n                line = handle.readline()\n                parts = line[1:].strip().split(':', 1)\n                assert i + 1 == int(parts[0].strip())\n                ids.append(parts[1].strip())\n            assert len(ids) == number_of_seqs\n        if key == 'length':\n            length_of_seqs = int(parts[1].strip())\n        if key == 'identity':\n            header_dict['identity'] = int(parts[1].strip().split('/')[0])\n        if key == 'similarity':\n            header_dict['similarity'] = int(parts[1].strip().split('/')[0])\n        if key == 'gaps':\n            header_dict['gaps'] = int(parts[1].strip().split('/')[0])\n        if key == 'score':\n            header_dict['score'] = float(parts[1].strip())\n        line = handle.readline()\n    if number_of_seqs is None:\n        raise ValueError('Number of sequences missing!')\n    if length_of_seqs is None:\n        raise ValueError('Length of sequences missing!')\n    if self.records_per_alignment is not None and self.records_per_alignment != number_of_seqs:\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (number_of_seqs, self.records_per_alignment))\n    seqs = [''] * len(ids)\n    seq_starts = []\n    index = 0\n    while line:\n        if len(line) > 21:\n            id_start = line[:21].strip().split(None, 1)\n            seq_end = line[21:].strip().split(None, 1)\n            if len(id_start) == 2 and len(seq_end) == 2:\n                (id, start) = id_start\n                (seq, end) = seq_end\n                if start >= end:\n                    if seq.replace('-', '') == '':\n                        start = int(start)\n                        end = int(end)\n                    else:\n                        start = int(start) - 1\n                        end = int(end)\n                else:\n                    assert seq.replace('-', '') != '', repr(line)\n                    start = int(start) - 1\n                    end = int(end)\n                if index < 0 or index >= number_of_seqs:\n                    raise ValueError('Expected index %i in range [0,%i)' % (index, number_of_seqs))\n                assert id == ids[index] or id == ids[index][:len(id)]\n                if len(seq_starts) == index:\n                    seq_starts.append(start)\n                if start >= end:\n                    assert seq.replace('-', '') == '', line\n                elif start - seq_starts[index] != len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r), line says start %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], start, line))\n                seqs[index] += seq\n                if end != seq_starts[index] + len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r, start=%i), file says end %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], seq_starts[index], end, line))\n                index += 1\n                if index >= number_of_seqs:\n                    index = 0\n            else:\n                pass\n        elif line.strip() == '':\n            pass\n        else:\n            raise ValueError(f'Unrecognised EMBOSS pairwise line: {line!r}\\n')\n        line = handle.readline()\n        if line.rstrip() == '#---------------------------------------' or line.rstrip() == '#=======================================':\n            self._header = line\n            break\n    assert index == 0\n    if self.records_per_alignment is not None and self.records_per_alignment != len(ids):\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (len(ids), self.records_per_alignment))\n    records = []\n    for (id, seq) in zip(ids, seqs):\n        if len(seq) != length_of_seqs:\n            raise ValueError('Error parsing alignment - sequences of different length? You could be using an old version of EMBOSS.')\n        records.append(SeqRecord(Seq(seq), id=id, description=id))\n    return MultipleSeqAlignment(records, annotations=header_dict)",
            "def __next__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Parse the next alignment from the handle.'\n    handle = self.handle\n    if self._header is None:\n        line = handle.readline()\n    else:\n        line = self._header\n        self._header = None\n    if not line:\n        raise StopIteration\n    while line.rstrip() != '#=======================================':\n        line = handle.readline()\n        if not line:\n            raise StopIteration\n    length_of_seqs = None\n    number_of_seqs = None\n    ids = []\n    header_dict = {}\n    while line[0] == '#':\n        parts = line[1:].split(':', 1)\n        key = parts[0].lower().strip()\n        if key == 'aligned_sequences':\n            number_of_seqs = int(parts[1].strip())\n            assert len(ids) == 0\n            for i in range(number_of_seqs):\n                line = handle.readline()\n                parts = line[1:].strip().split(':', 1)\n                assert i + 1 == int(parts[0].strip())\n                ids.append(parts[1].strip())\n            assert len(ids) == number_of_seqs\n        if key == 'length':\n            length_of_seqs = int(parts[1].strip())\n        if key == 'identity':\n            header_dict['identity'] = int(parts[1].strip().split('/')[0])\n        if key == 'similarity':\n            header_dict['similarity'] = int(parts[1].strip().split('/')[0])\n        if key == 'gaps':\n            header_dict['gaps'] = int(parts[1].strip().split('/')[0])\n        if key == 'score':\n            header_dict['score'] = float(parts[1].strip())\n        line = handle.readline()\n    if number_of_seqs is None:\n        raise ValueError('Number of sequences missing!')\n    if length_of_seqs is None:\n        raise ValueError('Length of sequences missing!')\n    if self.records_per_alignment is not None and self.records_per_alignment != number_of_seqs:\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (number_of_seqs, self.records_per_alignment))\n    seqs = [''] * len(ids)\n    seq_starts = []\n    index = 0\n    while line:\n        if len(line) > 21:\n            id_start = line[:21].strip().split(None, 1)\n            seq_end = line[21:].strip().split(None, 1)\n            if len(id_start) == 2 and len(seq_end) == 2:\n                (id, start) = id_start\n                (seq, end) = seq_end\n                if start >= end:\n                    if seq.replace('-', '') == '':\n                        start = int(start)\n                        end = int(end)\n                    else:\n                        start = int(start) - 1\n                        end = int(end)\n                else:\n                    assert seq.replace('-', '') != '', repr(line)\n                    start = int(start) - 1\n                    end = int(end)\n                if index < 0 or index >= number_of_seqs:\n                    raise ValueError('Expected index %i in range [0,%i)' % (index, number_of_seqs))\n                assert id == ids[index] or id == ids[index][:len(id)]\n                if len(seq_starts) == index:\n                    seq_starts.append(start)\n                if start >= end:\n                    assert seq.replace('-', '') == '', line\n                elif start - seq_starts[index] != len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r), line says start %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], start, line))\n                seqs[index] += seq\n                if end != seq_starts[index] + len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r, start=%i), file says end %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], seq_starts[index], end, line))\n                index += 1\n                if index >= number_of_seqs:\n                    index = 0\n            else:\n                pass\n        elif line.strip() == '':\n            pass\n        else:\n            raise ValueError(f'Unrecognised EMBOSS pairwise line: {line!r}\\n')\n        line = handle.readline()\n        if line.rstrip() == '#---------------------------------------' or line.rstrip() == '#=======================================':\n            self._header = line\n            break\n    assert index == 0\n    if self.records_per_alignment is not None and self.records_per_alignment != len(ids):\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (len(ids), self.records_per_alignment))\n    records = []\n    for (id, seq) in zip(ids, seqs):\n        if len(seq) != length_of_seqs:\n            raise ValueError('Error parsing alignment - sequences of different length? You could be using an old version of EMBOSS.')\n        records.append(SeqRecord(Seq(seq), id=id, description=id))\n    return MultipleSeqAlignment(records, annotations=header_dict)",
            "def __next__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Parse the next alignment from the handle.'\n    handle = self.handle\n    if self._header is None:\n        line = handle.readline()\n    else:\n        line = self._header\n        self._header = None\n    if not line:\n        raise StopIteration\n    while line.rstrip() != '#=======================================':\n        line = handle.readline()\n        if not line:\n            raise StopIteration\n    length_of_seqs = None\n    number_of_seqs = None\n    ids = []\n    header_dict = {}\n    while line[0] == '#':\n        parts = line[1:].split(':', 1)\n        key = parts[0].lower().strip()\n        if key == 'aligned_sequences':\n            number_of_seqs = int(parts[1].strip())\n            assert len(ids) == 0\n            for i in range(number_of_seqs):\n                line = handle.readline()\n                parts = line[1:].strip().split(':', 1)\n                assert i + 1 == int(parts[0].strip())\n                ids.append(parts[1].strip())\n            assert len(ids) == number_of_seqs\n        if key == 'length':\n            length_of_seqs = int(parts[1].strip())\n        if key == 'identity':\n            header_dict['identity'] = int(parts[1].strip().split('/')[0])\n        if key == 'similarity':\n            header_dict['similarity'] = int(parts[1].strip().split('/')[0])\n        if key == 'gaps':\n            header_dict['gaps'] = int(parts[1].strip().split('/')[0])\n        if key == 'score':\n            header_dict['score'] = float(parts[1].strip())\n        line = handle.readline()\n    if number_of_seqs is None:\n        raise ValueError('Number of sequences missing!')\n    if length_of_seqs is None:\n        raise ValueError('Length of sequences missing!')\n    if self.records_per_alignment is not None and self.records_per_alignment != number_of_seqs:\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (number_of_seqs, self.records_per_alignment))\n    seqs = [''] * len(ids)\n    seq_starts = []\n    index = 0\n    while line:\n        if len(line) > 21:\n            id_start = line[:21].strip().split(None, 1)\n            seq_end = line[21:].strip().split(None, 1)\n            if len(id_start) == 2 and len(seq_end) == 2:\n                (id, start) = id_start\n                (seq, end) = seq_end\n                if start >= end:\n                    if seq.replace('-', '') == '':\n                        start = int(start)\n                        end = int(end)\n                    else:\n                        start = int(start) - 1\n                        end = int(end)\n                else:\n                    assert seq.replace('-', '') != '', repr(line)\n                    start = int(start) - 1\n                    end = int(end)\n                if index < 0 or index >= number_of_seqs:\n                    raise ValueError('Expected index %i in range [0,%i)' % (index, number_of_seqs))\n                assert id == ids[index] or id == ids[index][:len(id)]\n                if len(seq_starts) == index:\n                    seq_starts.append(start)\n                if start >= end:\n                    assert seq.replace('-', '') == '', line\n                elif start - seq_starts[index] != len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r), line says start %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], start, line))\n                seqs[index] += seq\n                if end != seq_starts[index] + len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r, start=%i), file says end %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], seq_starts[index], end, line))\n                index += 1\n                if index >= number_of_seqs:\n                    index = 0\n            else:\n                pass\n        elif line.strip() == '':\n            pass\n        else:\n            raise ValueError(f'Unrecognised EMBOSS pairwise line: {line!r}\\n')\n        line = handle.readline()\n        if line.rstrip() == '#---------------------------------------' or line.rstrip() == '#=======================================':\n            self._header = line\n            break\n    assert index == 0\n    if self.records_per_alignment is not None and self.records_per_alignment != len(ids):\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (len(ids), self.records_per_alignment))\n    records = []\n    for (id, seq) in zip(ids, seqs):\n        if len(seq) != length_of_seqs:\n            raise ValueError('Error parsing alignment - sequences of different length? You could be using an old version of EMBOSS.')\n        records.append(SeqRecord(Seq(seq), id=id, description=id))\n    return MultipleSeqAlignment(records, annotations=header_dict)",
            "def __next__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Parse the next alignment from the handle.'\n    handle = self.handle\n    if self._header is None:\n        line = handle.readline()\n    else:\n        line = self._header\n        self._header = None\n    if not line:\n        raise StopIteration\n    while line.rstrip() != '#=======================================':\n        line = handle.readline()\n        if not line:\n            raise StopIteration\n    length_of_seqs = None\n    number_of_seqs = None\n    ids = []\n    header_dict = {}\n    while line[0] == '#':\n        parts = line[1:].split(':', 1)\n        key = parts[0].lower().strip()\n        if key == 'aligned_sequences':\n            number_of_seqs = int(parts[1].strip())\n            assert len(ids) == 0\n            for i in range(number_of_seqs):\n                line = handle.readline()\n                parts = line[1:].strip().split(':', 1)\n                assert i + 1 == int(parts[0].strip())\n                ids.append(parts[1].strip())\n            assert len(ids) == number_of_seqs\n        if key == 'length':\n            length_of_seqs = int(parts[1].strip())\n        if key == 'identity':\n            header_dict['identity'] = int(parts[1].strip().split('/')[0])\n        if key == 'similarity':\n            header_dict['similarity'] = int(parts[1].strip().split('/')[0])\n        if key == 'gaps':\n            header_dict['gaps'] = int(parts[1].strip().split('/')[0])\n        if key == 'score':\n            header_dict['score'] = float(parts[1].strip())\n        line = handle.readline()\n    if number_of_seqs is None:\n        raise ValueError('Number of sequences missing!')\n    if length_of_seqs is None:\n        raise ValueError('Length of sequences missing!')\n    if self.records_per_alignment is not None and self.records_per_alignment != number_of_seqs:\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (number_of_seqs, self.records_per_alignment))\n    seqs = [''] * len(ids)\n    seq_starts = []\n    index = 0\n    while line:\n        if len(line) > 21:\n            id_start = line[:21].strip().split(None, 1)\n            seq_end = line[21:].strip().split(None, 1)\n            if len(id_start) == 2 and len(seq_end) == 2:\n                (id, start) = id_start\n                (seq, end) = seq_end\n                if start >= end:\n                    if seq.replace('-', '') == '':\n                        start = int(start)\n                        end = int(end)\n                    else:\n                        start = int(start) - 1\n                        end = int(end)\n                else:\n                    assert seq.replace('-', '') != '', repr(line)\n                    start = int(start) - 1\n                    end = int(end)\n                if index < 0 or index >= number_of_seqs:\n                    raise ValueError('Expected index %i in range [0,%i)' % (index, number_of_seqs))\n                assert id == ids[index] or id == ids[index][:len(id)]\n                if len(seq_starts) == index:\n                    seq_starts.append(start)\n                if start >= end:\n                    assert seq.replace('-', '') == '', line\n                elif start - seq_starts[index] != len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r), line says start %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], start, line))\n                seqs[index] += seq\n                if end != seq_starts[index] + len(seqs[index].replace('-', '')):\n                    raise ValueError('Found %i chars so far for sequence %i (%s, %r, start=%i), file says end %i:\\n%s' % (len(seqs[index].replace('-', '')), index, id, seqs[index], seq_starts[index], end, line))\n                index += 1\n                if index >= number_of_seqs:\n                    index = 0\n            else:\n                pass\n        elif line.strip() == '':\n            pass\n        else:\n            raise ValueError(f'Unrecognised EMBOSS pairwise line: {line!r}\\n')\n        line = handle.readline()\n        if line.rstrip() == '#---------------------------------------' or line.rstrip() == '#=======================================':\n            self._header = line\n            break\n    assert index == 0\n    if self.records_per_alignment is not None and self.records_per_alignment != len(ids):\n        raise ValueError('Found %i records in this alignment, told to expect %i' % (len(ids), self.records_per_alignment))\n    records = []\n    for (id, seq) in zip(ids, seqs):\n        if len(seq) != length_of_seqs:\n            raise ValueError('Error parsing alignment - sequences of different length? You could be using an old version of EMBOSS.')\n        records.append(SeqRecord(Seq(seq), id=id, description=id))\n    return MultipleSeqAlignment(records, annotations=header_dict)"
        ]
    }
]