"""gnupg.py
===========
A Python interface to GnuPG.

.. moduleauthor:: Isis Lovecruft <isis@patternsinthevoid.net>
                  see also :attr:`gnupg.__authors__`
.. license:: see :attr:`gnupg.__license__`
.. info:: https://github.com/isislovecruft/python-gnupg
"""
import encodings
import functools
import os
import re
import tempfile
import textwrap
import time
from codecs import open
from . import _trust, _util
from ._meta import GPGBase
from ._parsers import KeyExpirationInterface, _fix_unsafe
from ._util import _is_list_or_tuple, _is_stream, _make_binary_stream, log

class GPG(GPGBase):
    """Python interface for handling interactions with GnuPG, including keyfile
    generation, keyring maintainance, import and export, encryption and
    decryption, sending to and recieving from keyservers, and signing and
    verification.
    """
    _batch_limit = 25

    def __init__(self, binary=None, homedir=None, verbose=False, use_agent=False, keyring=None, secring=None, ignore_homedir_permissions=False, options=None):
        if False:
            i = 10
            return i + 15
        "Initialize a GnuPG process wrapper.\n\n        :param str binary: Name for GnuPG binary executable. If the absolute\n                           path is not given, the environment variable\n                           ``$PATH`` is searched for the executable and\n                           checked that the real uid/gid of the user has\n                           sufficient permissions.\n\n        :param str homedir: Full pathname to directory containing the public\n                            and private keyrings. Default is\n                            `~/.config/python-gnupg`.\n\n        :type ignore_homedir_permissions: :obj:`bool`\n        :param ignore_homedir_permissions: If true, bypass check that homedir\n                                           be writable.\n\n        :type verbose: :obj:`str` or :obj:`int` or :obj:`bool`\n        :param verbose: String or numeric value to pass to GnuPG's\n                        ``--debug-level`` option. See the GnuPG man page for\n                        the list of valid options. If False, debug output is\n                        not generated by the GnuPG binary. If True, defaults\n                        to ``--debug-level basic.``\n\n        :param str keyring: Name of keyring file containing public key data.\n                            If unspecified, defaults to :file:`pubring.gpg` in\n                            the **homedir** directory.\n\n        :param str secring: Name of alternative secret keyring file to use. If\n                            left unspecified, this will default to using\n                            :file:`secring.gpg` in the **homedir** directory,\n                            and create that file if it does not exist.\n\n        :param list options: A list of additional options to pass to the GnuPG\n                             binary.\n\n        :raises: A :exc:`~exceptions.RuntimeError` with explanation message\n                 if there is a problem invoking GnuPG.\n\n        Example:\n\n        >>> import gnupg\n        GnuPG logging disabled...\n        >>> gpg = gnupg.GPG(homedir='doctests')\n        >>> gpg.keyring\n        './doctests/pubring.gpg'\n        >>> gpg.secring\n        './doctests/secring.gpg'\n        >>> gpg.use_agent\n        False\n        >>> gpg.binary\n        '/usr/bin/gpg'\n        "
        super().__init__(binary=binary, home=homedir, keyring=keyring, secring=secring, options=options, verbose=verbose, use_agent=use_agent, ignore_homedir_permissions=ignore_homedir_permissions)
        log.info(textwrap.dedent('\n        Initialised settings:\n        binary: {}\n        binary version: {}\n        homedir: {}\n        ignore_homedir_permissions: {}\n        keyring: {}\n        secring: {}\n        default_preference_list: {}\n        keyserver: {}\n        options: {}\n        verbose: {}\n        use_agent: {}\n        '.format(self.binary, self.binary_version, self.homedir, self.ignore_homedir_permissions, self.keyring, self.secring, self.default_preference_list, self.keyserver, self.options, str(self.verbose), str(self.use_agent))))
        self._batch_dir = os.path.join(self.homedir, 'batch-files')
        self._key_dir = os.path.join(self.homedir, 'generated-keys')
        self.temp_keyring = None
        self.temp_secring = None
        self.create_trustdb()
        self.use_agent = None

    @functools.wraps(_trust._create_trustdb)
    def create_trustdb(self):
        if False:
            while True:
                i = 10
        _trust._create_trustdb(self)
    _create_trustdb = create_trustdb

    @functools.wraps(_trust.fix_trustdb)
    def fix_trustdb(self, trustdb=None):
        if False:
            i = 10
            return i + 15
        _trust.fix_trustdb(self)
    _fix_trustdb = fix_trustdb

    @functools.wraps(_trust.import_ownertrust)
    def import_ownertrust(self, trustdb=None):
        if False:
            for i in range(10):
                print('nop')
        _trust.import_ownertrust(self)
    _import_ownertrust = import_ownertrust

    @functools.wraps(_trust.export_ownertrust)
    def export_ownertrust(self, trustdb=None):
        if False:
            for i in range(10):
                print('nop')
        _trust.export_ownertrust(self)
    _export_ownertrust = export_ownertrust

    def sign(self, data, **kwargs):
        if False:
            i = 10
            return i + 15
        'Create a signature for a message string or file.\n\n        Note that this method is not for signing other keys. (In GnuPG\'s\n        terms, what we all usually call \'keysigning\' is actually termed\n        \'certification\'...) Even though they are cryptographically the same\n        operation, GnuPG differentiates between them, presumedly because these\n        operations are also the same as the decryption operation. If the\n        ``key_usage``s ``C (certification)``, ``S (sign)``, and ``E\n        (encrypt)``, were all the same key, the key would "wear down" through\n        frequent signing usage -- since signing data is usually done often --\n        meaning that the secret portion of the keypair, also used for\n        decryption in this scenario, would have a statistically higher\n        probability of an adversary obtaining an oracle for it (or for a\n        portion of the rounds in the cipher algorithm, depending on the family\n        of cryptanalytic attack used).\n\n        In simpler terms: this function isn\'t for signing your friends\' keys,\n        it\'s for something like signing an email.\n\n        :type data: :obj:`str` or :obj:`file`\n        :param data: A string or file stream to sign.\n        :param str default_key: The key to sign with.\n        :param str passphrase: The passphrase to pipe to stdin.\n        :param bool clearsign: If True, create a cleartext signature.\n        :param bool detach: If True, create a detached signature.\n        :param bool binary: If True, do not ascii armour the output.\n        :param str digest_algo: The hash digest to use. Again, to see which\n            hashes your GnuPG is capable of using, do:\n            :command:`$ gpg --with-colons --list-config digestname`.\n            The default, if unspecified, is ``\'SHA512\'``.\n        '
        if 'default_key' in kwargs:
            log.info("Signing message '{!r}' with keyid: {}".format(data, kwargs['default_key']))
        else:
            log.warn("No 'default_key' given! Using first key on secring.")
        if hasattr(data, 'read'):
            result = self._sign_file(data, **kwargs)
        elif not _is_stream(data):
            stream = _make_binary_stream(data, self._encoding)
            result = self._sign_file(stream, **kwargs)
            stream.close()
        else:
            log.warn(f"Unable to sign message '{data}' with type {type(data)}")
            result = None
        return result

    def verify(self, data):
        if False:
            for i in range(10):
                print('nop')
        'Verify the signature on the contents of the string ``data``.\n\n        >>> gpg = GPG(homedir="doctests")\n        >>> input = gpg.gen_key_input(Passphrase=\'foo\')\n        >>> key = gpg.gen_key(input)\n        >>> assert key\n        >>> sig = gpg.sign(\'hello\',keyid=key.fingerprint,passphrase=\'bar\')\n        >>> assert not sig\n        >>> sig = gpg.sign(\'hello\',keyid=key.fingerprint,passphrase=\'foo\')\n        >>> assert sig\n        >>> verify = gpg.verify(sig.data)\n        >>> assert verify\n\n        '
        f = _make_binary_stream(data, self._encoding)
        result = self.verify_file(f)
        f.close()
        return result

    def verify_file(self, file, sig_file=None):
        if False:
            print('Hello World!')
        'Verify the signature on the contents of a file or file-like\n        object. Can handle embedded signatures as well as detached\n        signatures. If using detached signatures, the file containing the\n        detached signature should be specified as the ``sig_file``.\n\n        :param file file: A file descriptor object.\n\n        :param str sig_file: A file containing the GPG signature data for\n            ``file``. If given, ``file`` is verified via this detached\n            signature. Its type will be checked with :func:`_util._is_file`.\n        '
        result = self._result_map['verify'](self)
        if sig_file is None:
            log.debug('verify_file(): Handling embedded signature')
            args = ['--verify']
            proc = self._open_subprocess(args)
            writer = _util._threaded_copy_data(file, proc.stdin)
            self._collect_output(proc, result, writer, stdin=proc.stdin)
        else:
            if not _util._is_file(sig_file):
                log.debug("verify_file(): '%r' is not a file" % sig_file)
                return result
            log.debug('verify_file(): Handling detached verification')
            sig_fh = None
            try:
                sig_fh = open(sig_file, 'rb')
                args = ['--verify %s -' % sig_fh.name]
                proc = self._open_subprocess(args)
                writer = _util._threaded_copy_data(file, proc.stdin)
                self._collect_output(proc, result, writer, stdin=proc.stdin)
            finally:
                if sig_fh and (not sig_fh.closed):
                    sig_fh.close()
        return result

    def import_keys(self, key_data):
        if False:
            print('Hello World!')
        '\n        Import the key_data into our keyring.\n\n        >>> import shutil\n        >>> shutil.rmtree("doctests")\n        >>> gpg = gnupg.GPG(homedir="doctests")\n        >>> inpt = gpg.gen_key_input()\n        >>> key1 = gpg.gen_key(inpt)\n        >>> print1 = str(key1.fingerprint)\n        >>> pubkey1 = gpg.export_keys(print1)\n        >>> seckey1 = gpg.export_keys(print1,secret=True)\n        >>> key2 = gpg.gen_key(inpt)\n        >>> print2 = key2.fingerprint\n        >>> seckeys = gpg.list_keys(secret=True)\n        >>> pubkeys = gpg.list_keys()\n        >>> assert print1 in seckeys.fingerprints\n        >>> assert print1 in pubkeys.fingerprints\n        >>> str(gpg.delete_keys(print1))\n        \'Must delete secret key first\'\n        >>> str(gpg.delete_keys(print1,secret=True))\n        \'ok\'\n        >>> str(gpg.delete_keys(print1))\n        \'ok\'\n        >>> pubkeys = gpg.list_keys()\n        >>> assert not print1 in pubkeys.fingerprints\n        >>> result = gpg.import_keys(pubkey1)\n        >>> pubkeys = gpg.list_keys()\n        >>> seckeys = gpg.list_keys(secret=True)\n        >>> assert not print1 in seckeys.fingerprints\n        >>> assert print1 in pubkeys.fingerprints\n        >>> result = gpg.import_keys(seckey1)\n        >>> assert result\n        >>> seckeys = gpg.list_keys(secret=True)\n        >>> assert print1 in seckeys.fingerprints\n        '
        result = self._result_map['import'](self)
        log.info('Importing: %r', key_data[:256])
        data = _make_binary_stream(key_data, self._encoding)
        self._handle_io(['--import'], data, result, binary=True)
        data.close()
        return result

    def recv_keys(self, *keyids, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Import keys from a keyserver.\n\n        >>> gpg = gnupg.GPG(homedir="doctests")\n        >>> key = gpg.recv_keys(\'3FF0DB166A7476EA\', keyserver=\'hkp://pgp.mit.edu\')\n        >>> assert key\n\n        :param str keyids: Each ``keyids`` argument should be a string\n             containing a keyid to request.\n        :param str keyserver: The keyserver to request the ``keyids`` from;\n             defaults to `gnupg.GPG.keyserver`.\n        '
        if keyids:
            keys = ' '.join([key for key in keyids])
            return self._recv_keys(keys, **kwargs)
        else:
            log.error('No keyids requested for --recv-keys!')

    def delete_keys(self, fingerprints, secret=False, subkeys=False):
        if False:
            for i in range(10):
                print('nop')
        'Delete a key, or list of keys, from the current keyring.\n\n        The keys must be referred to by their full fingerprints for GnuPG to\n        delete them. If ``secret=True``, the corresponding secret keyring will\n        be deleted from :obj:`.secring`.\n\n        :type fingerprints: :obj:`str` or :obj:`list` or :obj:`tuple`\n        :param fingerprints: A string, or a list/tuple of strings,\n                             representing the fingerprint(s) for the key(s)\n                             to delete.\n\n        :param bool secret: If True, delete the corresponding secret key(s)\n                            also. (default: False)\n\n        :param bool subkeys: If True, delete the secret subkey first, then the\n                             public key. (default: False) Same as:\n                             :command:`$gpg --delete-secret-and-public-key 0x12345678`.\n        '
        which = 'keys'
        if secret:
            which = 'secret-keys'
        if subkeys:
            which = 'secret-and-public-keys'
        if _is_list_or_tuple(fingerprints):
            fingerprints = ' '.join(fingerprints)
        args = ['--batch']
        args.append(f'--delete-{which} {fingerprints}')
        result = self._result_map['delete'](self)
        p = self._open_subprocess(args)
        self._collect_output(p, result, stdin=p.stdin)
        return result

    def export_keys(self, keyids, secret=False, subkeys=False, passphrase=None):
        if False:
            print('Hello World!')
        'Export the indicated ``keyids``.\n\n        :param str keyids: A keyid or fingerprint in any format that GnuPG will\n            accept.\n        :param bool secret: If True, export only the secret key.\n        :param bool subkeys: If True, export the secret subkeys.\n        :param Optional[str] passphrase: if exporting secret keys, use this\n            passphrase to authenticate\n        '
        which = ''
        if subkeys:
            which = '-secret-subkeys'
        elif secret:
            which = '-secret-keys'
        else:
            passphrase = None
        if _is_list_or_tuple(keyids):
            keyids = ' '.join(['%s' % k for k in keyids])
        args = ['--armor', f'--export{which} {keyids}']
        result = self._result_map['export'](self)
        with tempfile.NamedTemporaryFile() as tmp:
            self._handle_io(args, tmp.name, result, passphrase, binary=True)
        log.debug(f'Exported:{os.linesep}{result.fingerprints!r}')
        return result.data.decode(self._encoding, self._decode_errors)

    def list_keys(self, secret=False):
        if False:
            print('Hello World!')
        'List the keys currently in the keyring.\n\n        The GnuPG option \'--show-photos\', according to the GnuPG manual, "does\n        not work with --with-colons", but since we can\'t rely on all versions\n        of GnuPG to explicitly handle this correctly, we should probably\n        include it in the args.\n\n        >>> import shutil\n        >>> shutil.rmtree("doctests")\n        >>> gpg = GPG(homedir="doctests")\n        >>> input = gpg.gen_key_input()\n        >>> result = gpg.gen_key(input)\n        >>> print1 = result.fingerprint\n        >>> result = gpg.gen_key(input)\n        >>> print2 = result.fingerprint\n        >>> pubkeys = gpg.list_keys()\n        >>> assert print1 in pubkeys.fingerprints\n        >>> assert print2 in pubkeys.fingerprints\n        '
        which = 'public-keys'
        if secret:
            which = 'secret-keys'
        args = []
        args.append('--fixed-list-mode')
        args.append('--fingerprint')
        args.append('--with-colons')
        args.append('--list-options no-show-photos')
        args.append('--list-%s' % which)
        p = self._open_subprocess(args)
        result = self._result_map['list'](self)
        self._collect_output(p, result, stdin=p.stdin)
        self._parse_keys(result)
        return result

    def list_packets(self, raw_data):
        if False:
            print('Hello World!')
        'List the packet contents of a file.'
        args = ['--list-packets']
        result = self._result_map['packets'](self)
        self._handle_io(args, _make_binary_stream(raw_data, self._encoding), result)
        return result

    def sign_key(self, keyid, default_key=None, passphrase=None):
        if False:
            while True:
                i = 10
        'sign (an imported) public key - keyid, with default secret key\n\n        >>> import gnupg\n        >>> gpg = gnupg.GPG(homedir="doctests")\n        >>> key_input = gpg.gen_key_input()\n        >>> key = gpg.gen_key(key_input)\n        >>> gpg.sign_key(key[\'fingerprint\'])\n        >>> gpg.list_sigs(key[\'fingerprint\'])\n\n        :param str keyid: key shortID, longID, fingerprint or email_address\n        :param str passphrase: passphrase used when creating the key, leave None otherwise\n\n        :returns: The result giving status of the key signing...\n                    success can be verified by gpg.list_sigs(keyid)\n        '
        args = []
        input_command = ''
        if passphrase:
            passphrase_arg = '--passphrase-fd 0'
            input_command = '%s\n' % passphrase
            args.append(passphrase_arg)
        if default_key:
            args.append(str('--default-key %s' % default_key))
        args.extend(['--command-fd 0', '--sign-key %s' % keyid])
        p = self._open_subprocess(args)
        result = self._result_map['signing'](self)
        confirm_command = '%sy\n' % input_command
        p.stdin.write(confirm_command.encode())
        self._collect_output(p, result, stdin=p.stdin)
        return result

    def list_sigs(self, *keyids):
        if False:
            return 10
        'Get the signatures for each of the ``keyids``.\n\n        >>> import gnupg\n        >>> gpg = gnupg.GPG(homedir="doctests")\n        >>> key_input = gpg.gen_key_input()\n        >>> key = gpg.gen_key(key_input)\n        >>> assert key.fingerprint\n\n        :rtype: dict\n        :returns: res.sigs is a dictionary whose keys are the uids and whose\n                values are a set of signature keyids.\n        '
        return self._process_keys(keyids)

    def check_sigs(self, *keyids):
        if False:
            while True:
                i = 10
        'Validate the signatures for each of the ``keyids``.\n\n        :rtype: dict\n        :returns: res.certs is a dictionary whose keys are the uids and whose\n                values are a set of signature keyids.\n        '
        return self._process_keys(keyids, check_sig=True)

    def _process_keys(self, keyids, check_sig=False):
        if False:
            print('Hello World!')
        if len(keyids) > self._batch_limit:
            raise ValueError('List signatures is limited to %d keyids simultaneously' % self._batch_limit)
        args = ['--with-colons', '--fixed-list-mode']
        arg = '--check-sigs' if check_sig else '--list-sigs'
        if len(keyids):
            arg += ' ' + ' '.join(keyids)
        args.append(arg)
        proc = self._open_subprocess(args)
        result = self._result_map['list'](self)
        self._collect_output(proc, result, stdin=proc.stdin)
        self._parse_keys(result)
        return result

    def _parse_keys(self, result):
        if False:
            for i in range(10):
                print('nop')
        lines = result.data.decode(self._encoding, self._decode_errors).splitlines()
        valid_keywords = 'pub uid sec fpr sub sig rev'.split()
        for line in lines:
            if self.verbose:
                print(line)
            log.debug('%r', line.rstrip())
            if not line:
                break
            L = line.strip().split(':')
            if not L:
                continue
            keyword = L[0]
            if keyword in valid_keywords:
                getattr(result, keyword)(L)

    def expire(self, keyid, expiration_time='1y', passphrase=None, expire_subkeys=True):
        if False:
            while True:
                i = 10
        'Changes GnuPG key expiration by passing in new time period (from now) through\n            subprocess\'s stdin\n\n        >>> import gnupg\n        >>> gpg = gnupg.GPG(homedir="doctests")\n        >>> key_input = gpg.gen_key_input()\n        >>> key = gpg.gen_key(key_input)\n        >>> gpg.expire(key.fingerprint, \'2w\', \'good passphrase\')\n\n        :param str keyid: key shortID, longID, email_address or fingerprint\n        :param str expiration_time: 0 or number of days (d), or weeks (*w) , or months (*m)\n                or years (*y) for when to expire the key, from today.\n        :param str passphrase: passphrase used when creating the key, leave None otherwise\n        :param bool expire_subkeys: to indicate whether the subkeys will also change the\n                expiration time by the same period -- default is True\n\n        :returns: The result giving status of the change in expiration...\n                the new expiration date can be obtained by .list_keys()\n        '
        passphrase = passphrase.encode(self._encoding) if passphrase else passphrase
        try:
            sub_keys_number = len(self.list_sigs(keyid)[0]['subkeys']) if expire_subkeys else 0
        except IndexError:
            sub_keys_number = 0
        expiration_input = KeyExpirationInterface(expiration_time, passphrase).gpg_interactive_input(sub_keys_number)
        args = ['--command-fd 0', '--edit-key %s' % keyid]
        p = self._open_subprocess(args)
        p.stdin.write(expiration_input.encode())
        result = self._result_map['expire'](self)
        p.stdin.write(expiration_input.encode())
        self._collect_output(p, result, stdin=p.stdin)
        return result

    def gen_key(self, input):
        if False:
            print('Hello World!')
        'Generate a GnuPG key through batch file key generation. See\n        :meth:`GPG.gen_key_input()` for creating the control input.\n\n        >>> import gnupg\n        >>> gpg = gnupg.GPG(homedir="doctests")\n        >>> key_input = gpg.gen_key_input()\n        >>> key = gpg.gen_key(key_input)\n        >>> assert key.fingerprint\n\n        :param dict input: A dictionary of parameters and values for the new\n                           key.\n        :returns: The result mapping with details of the new key, which is a\n                  :class:`GenKey <gnupg._parsers.GenKey>` object.\n        '
        args = ['--gen-key --cert-digest-algo SHA512 --batch']
        key = self._result_map['generate'](self)
        f = _make_binary_stream(input, self._encoding)
        self._handle_io(args, f, key, binary=True)
        f.close()
        fpr = str(key.fingerprint)
        if len(fpr) == 20:
            for d in map(lambda x: os.path.dirname(x), [self.temp_keyring, self.temp_secring]):
                if not os.path.exists(d):
                    os.makedirs(d)
            if self.temp_keyring and os.path.isfile(self.temp_keyring):
                prefix = os.path.join(self.temp_keyring, fpr)
                try:
                    os.rename(self.temp_keyring, prefix + '.pubring')
                except OSError as ose:
                    log.error(str(ose))
            if self.temp_secring and os.path.isfile(self.temp_secring):
                prefix = os.path.join(self.temp_secring, fpr)
                try:
                    os.rename(self.temp_secring, prefix + '.secring')
                except OSError as ose:
                    log.error(str(ose))
        log.info('Key created. Fingerprint: %s' % fpr)
        key.keyring = self.temp_keyring
        key.secring = self.temp_secring
        self.temp_keyring = None
        self.temp_secring = None
        return key

    def gen_key_input(self, separate_keyring=False, save_batchfile=False, testing=False, **kwargs):
        if False:
            while True:
                i = 10
        'Generate a batch file for input to :meth:`~gnupg.GPG.gen_key`.\n\n        The GnuPG batch file key generation feature allows unattended key\n        generation by creating a file with special syntax and then providing it\n        to: :command:`gpg --gen-key --batch`. Batch files look like this:\n\n        |  Name-Real: Alice\n        |  Name-Email: alice@inter.net\n        |  Expire-Date: 2014-04-01\n        |  Key-Type: RSA\n        |  Key-Length: 4096\n        |  Key-Usage: cert\n        |  Subkey-Type: RSA\n        |  Subkey-Length: 4096\n        |  Subkey-Usage: encrypt,sign,auth\n        |  Passphrase: sekrit\n        |  %pubring foo.gpg\n        |  %secring sec.gpg\n        |  %commit\n\n        which is what this function creates for you. All of the available,\n        non-control parameters are detailed below (control parameters are the\n        ones which begin with a \'%\'). For example, to generate the batch file\n        example above, use like this:\n\n        >>> import gnupg\n        GnuPG logging disabled...\n        >>> from __future__ import print_function\n        >>> gpg = gnupg.GPG(homedir=\'doctests\')\n        >>> alice = { \'name_real\': \'Alice\',\n        ...     \'name_email\': \'alice@inter.net\',\n        ...     \'expire_date\': \'2014-04-01\',\n        ...     \'key_type\': \'RSA\',\n        ...     \'key_length\': 4096,\n        ...     \'key_usage\': \'\',\n        ...     \'subkey_type\': \'RSA\',\n        ...     \'subkey_length\': 4096,\n        ...     \'subkey_usage\': \'encrypt,sign,auth\',\n        ...     \'passphrase\': \'sekrit\'}\n        >>> alice_input = gpg.gen_key_input(**alice)\n        >>> print(alice_input)\n        Key-Type: RSA\n        Subkey-Type: RSA\n        Subkey-Usage: encrypt,sign,auth\n        Expire-Date: 2014-04-01\n        Passphrase: sekrit\n        Name-Real: Alice\n        Name-Email: alice@inter.net\n        Key-Length: 4096\n        Subkey-Length: 4096\n        %pubring ./doctests/alice.pubring.gpg\n        %secring ./doctests/alice.secring.gpg\n        %commit\n        <BLANKLINE>\n        >>> alice_key = gpg.gen_key(alice_input)\n        >>> assert alice_key is not None\n        >>> assert alice_key.fingerprint is not None\n        >>> message = "no one else can read my sekrit message"\n        >>> encrypted = gpg.encrypt(message, alice_key.fingerprint)\n        >>> assert isinstance(encrypted.data, str)\n\n        :param bool separate_keyring: Specify for the new key to be written to\n            a separate pubring.gpg and secring.gpg. If True,\n            :meth:`~gnupg.GPG.gen_key` will automatically rename the separate\n            keyring and secring to whatever the fingerprint of the generated\n            key ends up being, suffixed with \'.pubring\' and \'.secring\'\n            respectively.\n\n        :param bool save_batchfile: Save a copy of the generated batch file to\n            disk in a file named <name_real>.batch, where <name_real> is the\n            ``name_real`` parameter stripped of punctuation, spaces, and\n            non-ascii characters.\n\n        :param bool testing: Uses a faster, albeit insecure random number\n            generator to create keys. This should only be used for testing\n            purposes, for keys which are going to be created and then soon\n            after destroyed, and never for the generation of actual use keys.\n\n        :param str name_real: The name field of the UID in the generated key.\n        :param str name_comment: The comment in the UID of the generated key.\n\n        :param str name_email: The email in the UID of the generated key.\n            (default: ``$USER`` @ :command:`hostname` ) Remember to use UTF-8\n            encoding for the entirety of the UID. At least one of\n            ``name_real``, ``name_comment``, or ``name_email`` must be\n            provided, or else no user ID is created.\n\n        :param str key_type: One of \'RSA\', \'DSA\', \'ELG-E\', or \'default\'.\n            (default: \'RSA\', if using GnuPG v1.x, otherwise \'default\') Starts\n            a new parameter block by giving the type of the primary key. The\n            algorithm must be capable of signing. This is a required\n            parameter. The algorithm may either be an OpenPGP algorithm number\n            or a string with the algorithm name. The special value ‘default’\n            may be used for algo to create the default key type; in this case\n            a ``key_usage`` should not be given and \'default\' must also be\n            used for ``subkey_type``.\n\n        :param int key_length: The requested length of the generated key in\n            bits. (Default: 4096)\n\n        :param str key_grip: hexstring This is an optional hexidecimal string\n            which is used to generate a CSR or certificate for an already\n            existing key. ``key_length`` will be ignored if this parameter\n            is given.\n\n        :param str key_usage: Space or comma delimited string of key\n            usages. Allowed values are ‘encrypt’, ‘sign’, and ‘auth’. This is\n            used to generate the key flags. Please make sure that the\n            algorithm is capable of this usage. Note that OpenPGP requires\n            that all primary keys are capable of certification, so no matter\n            what usage is given here, the ‘cert’ flag will be on. If no\n            ‘Key-Usage’ is specified and the ‘Key-Type’ is not ‘default’, all\n            allowed usages for that particular algorithm are used; if it is\n            not given but ‘default’ is used the usage will be ‘sign’.\n\n        :param str subkey_type: This generates a secondary key\n            (subkey). Currently only one subkey can be handled. See also\n            ``key_type`` above.\n\n        :param int subkey_length: The length of the secondary subkey in bits.\n\n        :param str subkey_usage: Key usage for a subkey; similar to\n            ``key_usage``.\n\n        :type expire_date: :obj:`int` or :obj:`str`\n        :param expire_date: Can be specified as an iso-date or as\n            <int>[d|w|m|y] Set the expiration date for the key (and the\n            subkey). It may either be entered in ISO date format (2000-08-15)\n            or as number of days, weeks, month or years. The special notation\n            "seconds=N" is also allowed to directly give an Epoch\n            value. Without a letter days are assumed. Note that there is no\n            check done on the overflow of the type used by OpenPGP for\n            timestamps. Thus you better make sure that the given value make\n            sense. Although OpenPGP works with time intervals, GnuPG uses an\n            absolute value internally and thus the last year we can represent\n            is 2105.\n\n        :param str creation_date: Set the creation date of the key as stored\n            in the key information and which is also part of the fingerprint\n            calculation. Either a date like "1986-04-26" or a full timestamp\n            like "19860426T042640" may be used. The time is considered to be\n            UTC. If it is not given the current time is used.\n\n        :param str passphrase: The passphrase for the new key. The default is\n            to not use any passphrase. Note that GnuPG>=2.1.x will not allow\n            you to specify a passphrase for batch key generation -- GnuPG will\n            ignore the **passphrase** parameter, stop, and ask the user for\n            the new passphrase.  However, we can put the command\n            ``%no-protection`` into the batch key generation file to allow a\n            passwordless key to be created, which can then have its passphrase\n            set later with ``--edit-key``.\n\n        :param str preferences: Set the cipher, hash, and compression\n            preference values for this key. This expects the same type of\n            string as the sub-command ‘setpref’ in the --edit-key menu.\n\n        :param str revoker: Should be given as \'algo:fpr\' (case sensitive).\n            Add a designated revoker to the generated key. Algo is the public\n            key algorithm of the designated revoker (i.e. RSA=1, DSA=17, etc.)\n            fpr is the fingerprint of the designated revoker. The optional\n            ‘sensitive’ flag marks the designated revoker as sensitive\n            information. Only v4 keys may be designated revokers.\n\n        :param str keyserver: This is an optional parameter that specifies the\n            preferred keyserver URL for the key.\n\n        :param str handle: This is an optional parameter only used with the\n            status lines ``KEY_CREATED`` and ``KEY_NOT_CREATED``. string may\n            be up to 100 characters and should not contain spaces. It is\n            useful for batch key generation to associate a key parameter block\n            with a status line.\n\n        :rtype: str\n        :returns: A suitable input string for the :meth:`GPG.gen_key` method,\n            the latter of which will create the new keypair.\n\n        See `this GnuPG Manual section`__ for more details.\n\n        __ http://www.gnupg.org/documentation/manuals/gnupg-devel/Unattended-GPG-key-generation.html\n        '
        default_type = False
        parms = {}
        parms.setdefault('Key-Type', 'default')
        log.debug('GnuPG v{} detected: setting default key type to {}.'.format(self.binary_version, parms['Key-Type']))
        parms.setdefault('Key-Length', 4096)
        parms.setdefault('Name-Real', 'Autogenerated Key')
        parms.setdefault('Expire-Date', _util._next_year())
        name_email = kwargs.get('name_email')
        uidemail = _util.create_uid_email(name_email)
        parms.setdefault('Name-Email', uidemail)
        if testing:
            parms.setdefault('Name-Comment', 'insecure!')
        for (key, val) in list(kwargs.items()):
            key = key.replace('_', '-').title()
            if key not in ('Key-Usage', 'Subkey-Usage') and str(val).strip():
                parms[key] = val
        if parms['Key-Type'] == 'default':
            default_type = True
            for field in ('Key-Usage', 'Subkey-Usage'):
                try:
                    parms.pop(field)
                except KeyError:
                    pass
        out = 'Key-Type: %s\n' % parms.pop('Key-Type')
        out += 'Key-Length: %d\n' % parms.pop('Key-Length')
        if 'Subkey-Type' in parms:
            out += 'Subkey-Type: %s\n' % parms.pop('Subkey-Type')
        elif default_type:
            out += 'Subkey-Type: default\n'
        if 'Subkey-Length' in parms:
            out += 'Subkey-Length: %s\n' % parms.pop('Subkey-Length')
        for (key, val) in list(parms.items()):
            out += f'{key}: {val}\n'
        if separate_keyring:
            ring = str(uidemail + '_' + str(int(time.time())))
            self.temp_keyring = os.path.join(self.homedir, ring + '.pubring')
            self.temp_secring = os.path.join(self.homedir, ring + '.secring')
            out += '%%pubring %s\n' % self.temp_keyring
            out += '%%secring %s\n' % self.temp_secring
        if testing:
            out += '%no-protection\n'
            out += '%transient-key\n'
        out += '%commit\n'
        if save_batchfile and parms['Name-Email'] != uidemail:
            asc_uid = encodings.normalize_encoding(parms['Name-Email'])
            filename = _fix_unsafe(asc_uid) + _util._now() + '.batch'
            save_as = os.path.join(self._batch_dir, filename)
            readme = os.path.join(self._batch_dir, 'README')
            if not os.path.exists(self._batch_dir):
                os.makedirs(self._batch_dir)
                if getattr(self.gen_key_input, '__doc__', None) is not None:
                    docs = self.gen_key_input.__doc__
                else:
                    docs = ''
                links = '\n'.join((x.strip() for x in docs.splitlines()[-2:]))
                explain = '\nThis directory was created by python-gnupg, on {}, and\nit contains saved batch files, which can be given to GnuPG to automatically\ngenerate keys. Please see\n{}'.format(_util.now(), links)
                with open(readme, 'a+') as fh:
                    [fh.write(line) for line in explain]
            with open(save_as, 'a+') as batch_file:
                [batch_file.write(line) for line in out]
        return out

    def encrypt(self, data, *recipients, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'Encrypt the message contained in ``data`` to ``recipients``.\n\n        :param str data: The file or bytestream to encrypt.\n\n        :param str recipients: The recipients to encrypt to. Recipients must\n            be specified keyID/fingerprint. Care should be taken in Python2.x\n            to make sure that the given fingerprint is in fact a string and\n            not a unicode object.  Multiple recipients may be specified by\n            doing ``GPG.encrypt(data, fpr1, fpr2, fpr3)`` etc.\n\n        :param str default_key: The keyID/fingerprint of the key to use for\n            signing. If given, ``data`` will be encrypted and signed.\n\n        :param str passphrase: If given, and ``default_key`` is also given,\n            use this passphrase to unlock the secret portion of the\n            ``default_key`` to sign the encrypted ``data``. Otherwise, if\n            ``default_key`` is not given, but ``symmetric=True``, then use\n            this passphrase as the passphrase for symmetric\n            encryption. Signing and symmetric encryption should *not* be\n            combined when sending the ``data`` to other recipients, else the\n            passphrase to the secret key would be shared with them.\n\n        :param bool armor: If True, ascii armor the output; otherwise, the\n            output will be in binary format. (Default: True)\n\n        :param bool encrypt: If True, encrypt the ``data`` using the\n            ``recipients`` public keys. (Default: True)\n\n        :param bool symmetric: If True, encrypt the ``data`` to ``recipients``\n            using a symmetric key. See the ``passphrase`` parameter. Symmetric\n            encryption and public key encryption can be used simultaneously,\n            and will result in a ciphertext which is decryptable with either\n            the symmetric ``passphrase`` or one of the corresponding private\n            keys.\n\n        :param bool always_trust: If True, ignore trust warnings on recipient\n            keys. If False, display trust warnings.  (default: True)\n\n        :param str output: The output file to write to. If not specified, the\n            encrypted output is returned, and thus should be stored as an\n            object in Python. For example:\n\n        >>> import shutil\n        >>> import gnupg\n        >>> if os.path.exists("doctests"):\n        ...     shutil.rmtree("doctests")\n        >>> gpg = gnupg.GPG(homedir="doctests")\n        >>> key_settings = gpg.gen_key_input(key_type=\'RSA\',\n        ...     key_length=1024,\n        ...     key_usage=\'ESCA\',\n        ...     passphrase=\'foo\')\n        >>> key = gpg.gen_key(key_settings)\n        >>> message = "The crow flies at midnight."\n        >>> encrypted = str(gpg.encrypt(message, key.fingerprint))\n        >>> assert encrypted != message\n        >>> assert not encrypted.isspace()\n        >>> decrypted = str(gpg.decrypt(encrypted, passphrase=\'foo\'))\n        >>> assert not decrypted.isspace()\n        >>> decrypted\n        \'The crow flies at midnight.\'\n\n\n        :param bool throw_keyids: If True, make all **recipients** keyids be\n            zero\'d out in packet information. This is the same as using\n            **hidden_recipients** for all **recipients**. (Default: False).\n\n        :param list hidden_recipients: A list of recipients that should have\n            their keyids zero\'d out in packet information.\n\n        :param str cipher_algo: The cipher algorithm to use. To see available\n            algorithms with your version of GnuPG, do:\n            :command:`$ gpg --with-colons --list-config ciphername`.\n            The default ``cipher_algo``, if unspecified, is ``\'AES256\'``.\n\n        :param str digest_algo: The hash digest to use. Again, to see which\n            hashes your GnuPG is capable of using, do:\n            :command:`$ gpg --with-colons --list-config digestname`.\n            The default, if unspecified, is ``\'SHA512\'``.\n\n        :param str compress_algo: The compression algorithm to use. Can be one\n            of ``\'ZLIB\'``, ``\'BZIP2\'``, ``\'ZIP\'``, or ``\'Uncompressed\'``.\n\n        .. seealso:: :meth:`._encrypt`\n        '
        if _is_stream(data):
            stream = data
        else:
            stream = _make_binary_stream(data, self._encoding)
        result = self._encrypt(stream, recipients, **kwargs)
        stream.close()
        return result

    def decrypt(self, message, **kwargs):
        if False:
            while True:
                i = 10
        'Decrypt the contents of a string or file-like object ``message``.\n\n        :type message: file or str or :class:`io.BytesIO`\n        :param message: A string or file-like object to decrypt.\n        :param bool always_trust: Instruct GnuPG to ignore trust checks.\n        :param str passphrase: The passphrase for the secret key used for decryption.\n        :param str output: A filename to write the decrypted output to.\n        '
        stream = _make_binary_stream(message, self._encoding)
        result = self.decrypt_file(stream, **kwargs)
        stream.close()
        return result

    def decrypt_file(self, filename, always_trust=False, passphrase=None, output=None):
        if False:
            return 10
        'Decrypt the contents of a file-like object ``filename`` .\n\n        :param str filename: A file-like object to decrypt.\n        :param bool always_trust: Instruct GnuPG to ignore trust checks.\n        :param str passphrase: The passphrase for the secret key used for decryption.\n        :param str output: A filename to write the decrypted output to.\n        '
        args = ['--decrypt']
        if output:
            if os.path.exists(output):
                os.remove(output)
            args.append('--output %s' % output)
        if always_trust:
            args.append('--always-trust')
        result = self._result_map['crypt'](self)
        self._handle_io(args, filename, result, passphrase, binary=True)
        log.debug('decrypt result: %r', result.data)
        return result

class GPGUtilities:
    """Extra tools for working with GnuPG."""

    def __init__(self, gpg):
        if False:
            print('Hello World!')
        'Initialise extra utility functions.'
        self._gpg = gpg

    def find_key_by_email(self, email, secret=False):
        if False:
            return 10
        "Find user's key based on their email address.\n\n        :param str email: The email address to search for.\n        :param bool secret: If True, search through secret keyring.\n        "
        for key in self.list_keys(secret=secret):
            for uid in key['uids']:
                if re.search(email, uid):
                    return key
        raise LookupError('GnuPG public key for email %s not found!' % email)

    def find_key_by_subkey(self, subkey):
        if False:
            i = 10
            return i + 15
        'Find a key by a fingerprint of one of its subkeys.\n\n        :param str subkey: The fingerprint of the subkey to search for.\n        '
        for key in self.list_keys():
            for sub in key['subkeys']:
                if sub[0] == subkey:
                    return key
        raise LookupError('GnuPG public key for subkey %s not found!' % subkey)

    def send_keys(self, keyserver, *keyids):
        if False:
            i = 10
            return i + 15
        'Send keys to a keyserver.'
        result = self._result_map['list'](self)
        log.debug('send_keys: %r', keyids)
        data = _util._make_binary_stream('', self._encoding)
        args = ['--keyserver', keyserver, '--send-keys']
        args.extend(keyids)
        self._handle_io(args, data, result, binary=True)
        log.debug('send_keys result: %r', result.__dict__)
        data.close()
        return result

    def encrypted_to(self, raw_data):
        if False:
            print('Hello World!')
        'Return the key to which raw_data is encrypted to.'
        result = self._gpg.list_packets(raw_data)
        if not result.key:
            raise LookupError('Content is not encrypted to a GnuPG key!')
        try:
            return self.find_key_by_keyid(result.key)
        except:
            return self.find_key_by_subkey(result.key)

    def is_encrypted_sym(self, raw_data):
        if False:
            for i in range(10):
                print('nop')
        result = self._gpg.list_packets(raw_data)
        return bool(result.need_passphrase_sym)

    def is_encrypted_asym(self, raw_data):
        if False:
            i = 10
            return i + 15
        result = self._gpg.list_packets(raw_data)
        return bool(result.key)

    def is_encrypted(self, raw_data):
        if False:
            return 10
        return self.is_encrypted_asym(raw_data) or self.is_encrypted_sym(raw_data)
if __name__ == '__main__':
    from .test import test_gnupg
    test_gnupg.main()