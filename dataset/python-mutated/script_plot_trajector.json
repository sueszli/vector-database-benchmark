[
    {
        "func_name": "_get_suffix_str",
        "original": "def _get_suffix_str():\n    return ''",
        "mutated": [
            "def _get_suffix_str():\n    if False:\n        i = 10\n    return ''",
            "def _get_suffix_str():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ''",
            "def _get_suffix_str():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ''",
            "def _get_suffix_str():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ''",
            "def _get_suffix_str():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ''"
        ]
    },
    {
        "func_name": "_load_trajectory",
        "original": "def _load_trajectory():\n    base_dir = FLAGS.base_dir\n    config_name = FLAGS.config_name + _get_suffix_str()\n    dir_name = os.path.join(base_dir, FLAGS.type, config_name)\n    logging.info('Waiting for snapshot in directory %s.', dir_name)\n    last_checkpoint = slim.evaluation.wait_for_new_checkpoint(dir_name, None)\n    checkpoint_iter = int(os.path.basename(last_checkpoint).split('-')[1])\n    a = utils.load_variables(os.path.join(dir_name, 'bench_on_' + FLAGS.imset, 'all_locs_at_t_{:d}.pkl'.format(checkpoint_iter)))\n    return a",
        "mutated": [
            "def _load_trajectory():\n    if False:\n        i = 10\n    base_dir = FLAGS.base_dir\n    config_name = FLAGS.config_name + _get_suffix_str()\n    dir_name = os.path.join(base_dir, FLAGS.type, config_name)\n    logging.info('Waiting for snapshot in directory %s.', dir_name)\n    last_checkpoint = slim.evaluation.wait_for_new_checkpoint(dir_name, None)\n    checkpoint_iter = int(os.path.basename(last_checkpoint).split('-')[1])\n    a = utils.load_variables(os.path.join(dir_name, 'bench_on_' + FLAGS.imset, 'all_locs_at_t_{:d}.pkl'.format(checkpoint_iter)))\n    return a",
            "def _load_trajectory():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    base_dir = FLAGS.base_dir\n    config_name = FLAGS.config_name + _get_suffix_str()\n    dir_name = os.path.join(base_dir, FLAGS.type, config_name)\n    logging.info('Waiting for snapshot in directory %s.', dir_name)\n    last_checkpoint = slim.evaluation.wait_for_new_checkpoint(dir_name, None)\n    checkpoint_iter = int(os.path.basename(last_checkpoint).split('-')[1])\n    a = utils.load_variables(os.path.join(dir_name, 'bench_on_' + FLAGS.imset, 'all_locs_at_t_{:d}.pkl'.format(checkpoint_iter)))\n    return a",
            "def _load_trajectory():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    base_dir = FLAGS.base_dir\n    config_name = FLAGS.config_name + _get_suffix_str()\n    dir_name = os.path.join(base_dir, FLAGS.type, config_name)\n    logging.info('Waiting for snapshot in directory %s.', dir_name)\n    last_checkpoint = slim.evaluation.wait_for_new_checkpoint(dir_name, None)\n    checkpoint_iter = int(os.path.basename(last_checkpoint).split('-')[1])\n    a = utils.load_variables(os.path.join(dir_name, 'bench_on_' + FLAGS.imset, 'all_locs_at_t_{:d}.pkl'.format(checkpoint_iter)))\n    return a",
            "def _load_trajectory():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    base_dir = FLAGS.base_dir\n    config_name = FLAGS.config_name + _get_suffix_str()\n    dir_name = os.path.join(base_dir, FLAGS.type, config_name)\n    logging.info('Waiting for snapshot in directory %s.', dir_name)\n    last_checkpoint = slim.evaluation.wait_for_new_checkpoint(dir_name, None)\n    checkpoint_iter = int(os.path.basename(last_checkpoint).split('-')[1])\n    a = utils.load_variables(os.path.join(dir_name, 'bench_on_' + FLAGS.imset, 'all_locs_at_t_{:d}.pkl'.format(checkpoint_iter)))\n    return a",
            "def _load_trajectory():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    base_dir = FLAGS.base_dir\n    config_name = FLAGS.config_name + _get_suffix_str()\n    dir_name = os.path.join(base_dir, FLAGS.type, config_name)\n    logging.info('Waiting for snapshot in directory %s.', dir_name)\n    last_checkpoint = slim.evaluation.wait_for_new_checkpoint(dir_name, None)\n    checkpoint_iter = int(os.path.basename(last_checkpoint).split('-')[1])\n    a = utils.load_variables(os.path.join(dir_name, 'bench_on_' + FLAGS.imset, 'all_locs_at_t_{:d}.pkl'.format(checkpoint_iter)))\n    return a"
        ]
    },
    {
        "func_name": "_compute_hardness",
        "original": "def _compute_hardness():\n    if FLAGS.type == '':\n        args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    else:\n        args = sna.get_args_for_config(FLAGS.type + '.' + FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    R = lambda : nav_env.get_multiplexer_class(args.navtask, 0)\n    R = R()\n    rng_data = [np.random.RandomState(0), np.random.RandomState(0)]\n    h_dists = []\n    gt_dists = []\n    for i in range(250):\n        e = R.sample_env(rng_data)\n        nodes = e.task.nodes\n        init_env_state = e.reset(rng_data)\n        gt_dist_to_goal = [e.episode.dist_to_goal[0][j][s] for (j, s) in enumerate(e.episode.start_node_ids)]\n        for j in range(args.navtask.task_params.batch_size):\n            start_node_id = e.episode.start_node_ids[j]\n            end_node_id = e.episode.goal_node_ids[0][j]\n            h_dist = graph_utils.heuristic_fn_vec(nodes[[start_node_id], :], nodes[[end_node_id], :], n_ori=args.navtask.task_params.n_ori, step_size=args.navtask.task_params.step_size)[0][0]\n            gt_dist = e.episode.dist_to_goal[0][j][start_node_id]\n            h_dists.append(h_dist)\n            gt_dists.append(gt_dist)\n    h_dists = np.array(h_dists)\n    gt_dists = np.array(gt_dists)\n    e = R.sample_env([np.random.RandomState(0), np.random.RandomState(0)])\n    input = e.get_common_data()\n    orig_maps = input['orig_maps'][0, 0, :, :, 0]\n    return (h_dists, gt_dists, orig_maps)",
        "mutated": [
            "def _compute_hardness():\n    if False:\n        i = 10\n    if FLAGS.type == '':\n        args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    else:\n        args = sna.get_args_for_config(FLAGS.type + '.' + FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    R = lambda : nav_env.get_multiplexer_class(args.navtask, 0)\n    R = R()\n    rng_data = [np.random.RandomState(0), np.random.RandomState(0)]\n    h_dists = []\n    gt_dists = []\n    for i in range(250):\n        e = R.sample_env(rng_data)\n        nodes = e.task.nodes\n        init_env_state = e.reset(rng_data)\n        gt_dist_to_goal = [e.episode.dist_to_goal[0][j][s] for (j, s) in enumerate(e.episode.start_node_ids)]\n        for j in range(args.navtask.task_params.batch_size):\n            start_node_id = e.episode.start_node_ids[j]\n            end_node_id = e.episode.goal_node_ids[0][j]\n            h_dist = graph_utils.heuristic_fn_vec(nodes[[start_node_id], :], nodes[[end_node_id], :], n_ori=args.navtask.task_params.n_ori, step_size=args.navtask.task_params.step_size)[0][0]\n            gt_dist = e.episode.dist_to_goal[0][j][start_node_id]\n            h_dists.append(h_dist)\n            gt_dists.append(gt_dist)\n    h_dists = np.array(h_dists)\n    gt_dists = np.array(gt_dists)\n    e = R.sample_env([np.random.RandomState(0), np.random.RandomState(0)])\n    input = e.get_common_data()\n    orig_maps = input['orig_maps'][0, 0, :, :, 0]\n    return (h_dists, gt_dists, orig_maps)",
            "def _compute_hardness():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if FLAGS.type == '':\n        args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    else:\n        args = sna.get_args_for_config(FLAGS.type + '.' + FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    R = lambda : nav_env.get_multiplexer_class(args.navtask, 0)\n    R = R()\n    rng_data = [np.random.RandomState(0), np.random.RandomState(0)]\n    h_dists = []\n    gt_dists = []\n    for i in range(250):\n        e = R.sample_env(rng_data)\n        nodes = e.task.nodes\n        init_env_state = e.reset(rng_data)\n        gt_dist_to_goal = [e.episode.dist_to_goal[0][j][s] for (j, s) in enumerate(e.episode.start_node_ids)]\n        for j in range(args.navtask.task_params.batch_size):\n            start_node_id = e.episode.start_node_ids[j]\n            end_node_id = e.episode.goal_node_ids[0][j]\n            h_dist = graph_utils.heuristic_fn_vec(nodes[[start_node_id], :], nodes[[end_node_id], :], n_ori=args.navtask.task_params.n_ori, step_size=args.navtask.task_params.step_size)[0][0]\n            gt_dist = e.episode.dist_to_goal[0][j][start_node_id]\n            h_dists.append(h_dist)\n            gt_dists.append(gt_dist)\n    h_dists = np.array(h_dists)\n    gt_dists = np.array(gt_dists)\n    e = R.sample_env([np.random.RandomState(0), np.random.RandomState(0)])\n    input = e.get_common_data()\n    orig_maps = input['orig_maps'][0, 0, :, :, 0]\n    return (h_dists, gt_dists, orig_maps)",
            "def _compute_hardness():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if FLAGS.type == '':\n        args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    else:\n        args = sna.get_args_for_config(FLAGS.type + '.' + FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    R = lambda : nav_env.get_multiplexer_class(args.navtask, 0)\n    R = R()\n    rng_data = [np.random.RandomState(0), np.random.RandomState(0)]\n    h_dists = []\n    gt_dists = []\n    for i in range(250):\n        e = R.sample_env(rng_data)\n        nodes = e.task.nodes\n        init_env_state = e.reset(rng_data)\n        gt_dist_to_goal = [e.episode.dist_to_goal[0][j][s] for (j, s) in enumerate(e.episode.start_node_ids)]\n        for j in range(args.navtask.task_params.batch_size):\n            start_node_id = e.episode.start_node_ids[j]\n            end_node_id = e.episode.goal_node_ids[0][j]\n            h_dist = graph_utils.heuristic_fn_vec(nodes[[start_node_id], :], nodes[[end_node_id], :], n_ori=args.navtask.task_params.n_ori, step_size=args.navtask.task_params.step_size)[0][0]\n            gt_dist = e.episode.dist_to_goal[0][j][start_node_id]\n            h_dists.append(h_dist)\n            gt_dists.append(gt_dist)\n    h_dists = np.array(h_dists)\n    gt_dists = np.array(gt_dists)\n    e = R.sample_env([np.random.RandomState(0), np.random.RandomState(0)])\n    input = e.get_common_data()\n    orig_maps = input['orig_maps'][0, 0, :, :, 0]\n    return (h_dists, gt_dists, orig_maps)",
            "def _compute_hardness():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if FLAGS.type == '':\n        args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    else:\n        args = sna.get_args_for_config(FLAGS.type + '.' + FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    R = lambda : nav_env.get_multiplexer_class(args.navtask, 0)\n    R = R()\n    rng_data = [np.random.RandomState(0), np.random.RandomState(0)]\n    h_dists = []\n    gt_dists = []\n    for i in range(250):\n        e = R.sample_env(rng_data)\n        nodes = e.task.nodes\n        init_env_state = e.reset(rng_data)\n        gt_dist_to_goal = [e.episode.dist_to_goal[0][j][s] for (j, s) in enumerate(e.episode.start_node_ids)]\n        for j in range(args.navtask.task_params.batch_size):\n            start_node_id = e.episode.start_node_ids[j]\n            end_node_id = e.episode.goal_node_ids[0][j]\n            h_dist = graph_utils.heuristic_fn_vec(nodes[[start_node_id], :], nodes[[end_node_id], :], n_ori=args.navtask.task_params.n_ori, step_size=args.navtask.task_params.step_size)[0][0]\n            gt_dist = e.episode.dist_to_goal[0][j][start_node_id]\n            h_dists.append(h_dist)\n            gt_dists.append(gt_dist)\n    h_dists = np.array(h_dists)\n    gt_dists = np.array(gt_dists)\n    e = R.sample_env([np.random.RandomState(0), np.random.RandomState(0)])\n    input = e.get_common_data()\n    orig_maps = input['orig_maps'][0, 0, :, :, 0]\n    return (h_dists, gt_dists, orig_maps)",
            "def _compute_hardness():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if FLAGS.type == '':\n        args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    else:\n        args = sna.get_args_for_config(FLAGS.type + '.' + FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    R = lambda : nav_env.get_multiplexer_class(args.navtask, 0)\n    R = R()\n    rng_data = [np.random.RandomState(0), np.random.RandomState(0)]\n    h_dists = []\n    gt_dists = []\n    for i in range(250):\n        e = R.sample_env(rng_data)\n        nodes = e.task.nodes\n        init_env_state = e.reset(rng_data)\n        gt_dist_to_goal = [e.episode.dist_to_goal[0][j][s] for (j, s) in enumerate(e.episode.start_node_ids)]\n        for j in range(args.navtask.task_params.batch_size):\n            start_node_id = e.episode.start_node_ids[j]\n            end_node_id = e.episode.goal_node_ids[0][j]\n            h_dist = graph_utils.heuristic_fn_vec(nodes[[start_node_id], :], nodes[[end_node_id], :], n_ori=args.navtask.task_params.n_ori, step_size=args.navtask.task_params.step_size)[0][0]\n            gt_dist = e.episode.dist_to_goal[0][j][start_node_id]\n            h_dists.append(h_dist)\n            gt_dists.append(gt_dist)\n    h_dists = np.array(h_dists)\n    gt_dists = np.array(gt_dists)\n    e = R.sample_env([np.random.RandomState(0), np.random.RandomState(0)])\n    input = e.get_common_data()\n    orig_maps = input['orig_maps'][0, 0, :, :, 0]\n    return (h_dists, gt_dists, orig_maps)"
        ]
    },
    {
        "func_name": "init_fn",
        "original": "def init_fn():\n    return (fig,)",
        "mutated": [
            "def init_fn():\n    if False:\n        i = 10\n    return (fig,)",
            "def init_fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (fig,)",
            "def init_fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (fig,)",
            "def init_fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (fig,)",
            "def init_fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (fig,)"
        ]
    },
    {
        "func_name": "worker",
        "original": "def worker(j):\n    step_number = j / (samples_per_action + wait_at_action)\n    img = imgs[j]\n    ax = axes[0]\n    ax.clear()\n    ax.set_axis_off()\n    img = img.astype(np.uint8)\n    ax.imshow(img)\n    tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n    plt.setp(tt, color='white')\n    t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n    t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n    t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    ax = axes[-1]\n    if j == 0:\n        locs = dt['all_locs'][i, :num_steps, :]\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n        ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n        locs = dt['all_locs'][i, :1, :]\n        ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n    locs = dt['all_locs'][i, step_number, :]\n    locs = np.expand_dims(locs, axis=0)\n    ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n    tt = ax.set_title('Trajectory in topview', fontsize=14)\n    plt.setp(tt, color='white')\n    return (fig,)",
        "mutated": [
            "def worker(j):\n    if False:\n        i = 10\n    step_number = j / (samples_per_action + wait_at_action)\n    img = imgs[j]\n    ax = axes[0]\n    ax.clear()\n    ax.set_axis_off()\n    img = img.astype(np.uint8)\n    ax.imshow(img)\n    tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n    plt.setp(tt, color='white')\n    t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n    t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n    t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    ax = axes[-1]\n    if j == 0:\n        locs = dt['all_locs'][i, :num_steps, :]\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n        ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n        locs = dt['all_locs'][i, :1, :]\n        ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n    locs = dt['all_locs'][i, step_number, :]\n    locs = np.expand_dims(locs, axis=0)\n    ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n    tt = ax.set_title('Trajectory in topview', fontsize=14)\n    plt.setp(tt, color='white')\n    return (fig,)",
            "def worker(j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    step_number = j / (samples_per_action + wait_at_action)\n    img = imgs[j]\n    ax = axes[0]\n    ax.clear()\n    ax.set_axis_off()\n    img = img.astype(np.uint8)\n    ax.imshow(img)\n    tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n    plt.setp(tt, color='white')\n    t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n    t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n    t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    ax = axes[-1]\n    if j == 0:\n        locs = dt['all_locs'][i, :num_steps, :]\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n        ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n        locs = dt['all_locs'][i, :1, :]\n        ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n    locs = dt['all_locs'][i, step_number, :]\n    locs = np.expand_dims(locs, axis=0)\n    ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n    tt = ax.set_title('Trajectory in topview', fontsize=14)\n    plt.setp(tt, color='white')\n    return (fig,)",
            "def worker(j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    step_number = j / (samples_per_action + wait_at_action)\n    img = imgs[j]\n    ax = axes[0]\n    ax.clear()\n    ax.set_axis_off()\n    img = img.astype(np.uint8)\n    ax.imshow(img)\n    tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n    plt.setp(tt, color='white')\n    t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n    t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n    t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    ax = axes[-1]\n    if j == 0:\n        locs = dt['all_locs'][i, :num_steps, :]\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n        ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n        locs = dt['all_locs'][i, :1, :]\n        ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n    locs = dt['all_locs'][i, step_number, :]\n    locs = np.expand_dims(locs, axis=0)\n    ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n    tt = ax.set_title('Trajectory in topview', fontsize=14)\n    plt.setp(tt, color='white')\n    return (fig,)",
            "def worker(j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    step_number = j / (samples_per_action + wait_at_action)\n    img = imgs[j]\n    ax = axes[0]\n    ax.clear()\n    ax.set_axis_off()\n    img = img.astype(np.uint8)\n    ax.imshow(img)\n    tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n    plt.setp(tt, color='white')\n    t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n    t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n    t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    ax = axes[-1]\n    if j == 0:\n        locs = dt['all_locs'][i, :num_steps, :]\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n        ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n        locs = dt['all_locs'][i, :1, :]\n        ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n    locs = dt['all_locs'][i, step_number, :]\n    locs = np.expand_dims(locs, axis=0)\n    ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n    tt = ax.set_title('Trajectory in topview', fontsize=14)\n    plt.setp(tt, color='white')\n    return (fig,)",
            "def worker(j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    step_number = j / (samples_per_action + wait_at_action)\n    img = imgs[j]\n    ax = axes[0]\n    ax.clear()\n    ax.set_axis_off()\n    img = img.astype(np.uint8)\n    ax.imshow(img)\n    tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n    plt.setp(tt, color='white')\n    t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n    t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n    t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n    t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n    ax = axes[-1]\n    if j == 0:\n        locs = dt['all_locs'][i, :num_steps, :]\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n        ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n        locs = dt['all_locs'][i, :1, :]\n        ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n    locs = dt['all_locs'][i, step_number, :]\n    locs = np.expand_dims(locs, axis=0)\n    ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n    tt = ax.set_title('Trajectory in topview', fontsize=14)\n    plt.setp(tt, color='white')\n    return (fig,)"
        ]
    },
    {
        "func_name": "plot_trajectory_first_person",
        "original": "def plot_trajectory_first_person(dt, orig_maps, out_dir):\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    plt.set_cmap('gray')\n    samples_per_action = 8\n    wait_at_action = 0\n    Writer = animation.writers['mencoder']\n    writer = Writer(fps=3 * (samples_per_action + wait_at_action), metadata=dict(artist='anonymous'), bitrate=1800)\n    args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    navtask_ = copy.deepcopy(args.navtask)\n    navtask_.camera_param.modalities = ['rgb']\n    navtask_.task_params.modalities = ['rgb']\n    sz = 512\n    navtask_.camera_param.height = sz\n    navtask_.camera_param.width = sz\n    navtask_.task_params.img_height = sz\n    navtask_.task_params.img_width = sz\n    R = lambda : nav_env.get_multiplexer_class(navtask_, 0)\n    R = R()\n    b = R.buildings[0]\n    f = [0 for _ in range(wait_at_action)] + [float(_) / samples_per_action for _ in range(samples_per_action)]\n    inds_to_do = []\n    inds_to_do += [1, 4, 10]\n    for i in inds_to_do:\n        fig = plt.figure(figsize=(10, 8))\n        gs = GridSpec(3, 4)\n        gs.update(wspace=0.05, hspace=0.05, left=0.0, top=0.97, right=1.0, bottom=0.0)\n        ax = fig.add_subplot(gs[:, :-1])\n        ax1 = fig.add_subplot(gs[0, -1])\n        ax2 = fig.add_subplot(gs[1, -1])\n        ax3 = fig.add_subplot(gs[2, -1])\n        axes = [ax, ax1, ax2, ax3]\n        for ax in axes:\n            ax.set_axis_off()\n        node_ids = dt['all_node_ids'][i, :, 0] * 1\n        if np.all(node_ids[-4:] == node_ids[-1]):\n            while node_ids[-4] == node_ids[-1]:\n                node_ids = node_ids[:-1]\n        num_steps = np.minimum(FLAGS.num_steps, len(node_ids))\n        xyt = b.to_actual_xyt_vec(b.task.nodes[node_ids])\n        xyt_diff = xyt[1:, :] - xyt[:-1, :]\n        xyt_diff[:, 2] = np.mod(xyt_diff[:, 2], 4)\n        ind = np.where(xyt_diff[:, 2] == 3)[0]\n        xyt_diff[ind, 2] = -1\n        xyt_diff = np.expand_dims(xyt_diff, axis=1)\n        to_cat = [xyt_diff * _ for _ in f]\n        perturbs_all = np.concatenate(to_cat, axis=1)\n        perturbs_all = np.concatenate([perturbs_all, np.zeros_like(perturbs_all[:, :, :1])], axis=2)\n        node_ids_all = np.expand_dims(node_ids, axis=1) * 1\n        node_ids_all = np.concatenate([node_ids_all for _ in f], axis=1)\n        node_ids_all = np.reshape(node_ids_all[:-1, :], -1)\n        perturbs_all = np.reshape(perturbs_all, [-1, 4])\n        imgs = b.render_nodes(b.task.nodes[node_ids_all, :], perturb=perturbs_all)\n        actions = []\n        (_, action_to_nodes) = b.get_feasible_actions(node_ids)\n        for j in range(num_steps - 1):\n            action_to_node = action_to_nodes[j]\n            node_to_action = dict(zip(action_to_node.values(), action_to_node.keys()))\n            actions.append(node_to_action[node_ids[j + 1]])\n\n        def init_fn():\n            return (fig,)\n        gt_dist_to_goal = []\n\n        def worker(j):\n            step_number = j / (samples_per_action + wait_at_action)\n            img = imgs[j]\n            ax = axes[0]\n            ax.clear()\n            ax.set_axis_off()\n            img = img.astype(np.uint8)\n            ax.imshow(img)\n            tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n            plt.setp(tt, color='white')\n            t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n            t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n            t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            ax = axes[-1]\n            if j == 0:\n                locs = dt['all_locs'][i, :num_steps, :]\n                goal_loc = dt['all_goal_locs'][i, :, :]\n                xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n                xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n                xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                ax.set_axis_on()\n                ax.patch.set_facecolor((0.333, 0.333, 0.333))\n                ax.set_xticks([])\n                ax.set_yticks([])\n                ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n                ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n                locs = dt['all_locs'][i, :1, :]\n                ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n                ax.set_xlim([xy1[0], xy2[0]])\n                ax.set_ylim([xy1[1], xy2[1]])\n            locs = dt['all_locs'][i, step_number, :]\n            locs = np.expand_dims(locs, axis=0)\n            ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n            tt = ax.set_title('Trajectory in topview', fontsize=14)\n            plt.setp(tt, color='white')\n            return (fig,)\n        line_ani = animation.FuncAnimation(fig, worker, (num_steps - 1) * (wait_at_action + samples_per_action), interval=500, blit=True, init_func=init_fn)\n        tmp_file_name = 'tmp.mp4'\n        line_ani.save(tmp_file_name, writer=writer, savefig_kwargs={'facecolor': 'black'})\n        out_file_name = os.path.join(out_dir, 'vis_{:04d}.mp4'.format(i))\n        print(out_file_name)\n        if fu.exists(out_file_name):\n            gfile.Remove(out_file_name)\n        gfile.Copy(tmp_file_name, out_file_name)\n        gfile.Remove(tmp_file_name)\n        plt.close(fig)",
        "mutated": [
            "def plot_trajectory_first_person(dt, orig_maps, out_dir):\n    if False:\n        i = 10\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    plt.set_cmap('gray')\n    samples_per_action = 8\n    wait_at_action = 0\n    Writer = animation.writers['mencoder']\n    writer = Writer(fps=3 * (samples_per_action + wait_at_action), metadata=dict(artist='anonymous'), bitrate=1800)\n    args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    navtask_ = copy.deepcopy(args.navtask)\n    navtask_.camera_param.modalities = ['rgb']\n    navtask_.task_params.modalities = ['rgb']\n    sz = 512\n    navtask_.camera_param.height = sz\n    navtask_.camera_param.width = sz\n    navtask_.task_params.img_height = sz\n    navtask_.task_params.img_width = sz\n    R = lambda : nav_env.get_multiplexer_class(navtask_, 0)\n    R = R()\n    b = R.buildings[0]\n    f = [0 for _ in range(wait_at_action)] + [float(_) / samples_per_action for _ in range(samples_per_action)]\n    inds_to_do = []\n    inds_to_do += [1, 4, 10]\n    for i in inds_to_do:\n        fig = plt.figure(figsize=(10, 8))\n        gs = GridSpec(3, 4)\n        gs.update(wspace=0.05, hspace=0.05, left=0.0, top=0.97, right=1.0, bottom=0.0)\n        ax = fig.add_subplot(gs[:, :-1])\n        ax1 = fig.add_subplot(gs[0, -1])\n        ax2 = fig.add_subplot(gs[1, -1])\n        ax3 = fig.add_subplot(gs[2, -1])\n        axes = [ax, ax1, ax2, ax3]\n        for ax in axes:\n            ax.set_axis_off()\n        node_ids = dt['all_node_ids'][i, :, 0] * 1\n        if np.all(node_ids[-4:] == node_ids[-1]):\n            while node_ids[-4] == node_ids[-1]:\n                node_ids = node_ids[:-1]\n        num_steps = np.minimum(FLAGS.num_steps, len(node_ids))\n        xyt = b.to_actual_xyt_vec(b.task.nodes[node_ids])\n        xyt_diff = xyt[1:, :] - xyt[:-1, :]\n        xyt_diff[:, 2] = np.mod(xyt_diff[:, 2], 4)\n        ind = np.where(xyt_diff[:, 2] == 3)[0]\n        xyt_diff[ind, 2] = -1\n        xyt_diff = np.expand_dims(xyt_diff, axis=1)\n        to_cat = [xyt_diff * _ for _ in f]\n        perturbs_all = np.concatenate(to_cat, axis=1)\n        perturbs_all = np.concatenate([perturbs_all, np.zeros_like(perturbs_all[:, :, :1])], axis=2)\n        node_ids_all = np.expand_dims(node_ids, axis=1) * 1\n        node_ids_all = np.concatenate([node_ids_all for _ in f], axis=1)\n        node_ids_all = np.reshape(node_ids_all[:-1, :], -1)\n        perturbs_all = np.reshape(perturbs_all, [-1, 4])\n        imgs = b.render_nodes(b.task.nodes[node_ids_all, :], perturb=perturbs_all)\n        actions = []\n        (_, action_to_nodes) = b.get_feasible_actions(node_ids)\n        for j in range(num_steps - 1):\n            action_to_node = action_to_nodes[j]\n            node_to_action = dict(zip(action_to_node.values(), action_to_node.keys()))\n            actions.append(node_to_action[node_ids[j + 1]])\n\n        def init_fn():\n            return (fig,)\n        gt_dist_to_goal = []\n\n        def worker(j):\n            step_number = j / (samples_per_action + wait_at_action)\n            img = imgs[j]\n            ax = axes[0]\n            ax.clear()\n            ax.set_axis_off()\n            img = img.astype(np.uint8)\n            ax.imshow(img)\n            tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n            plt.setp(tt, color='white')\n            t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n            t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n            t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            ax = axes[-1]\n            if j == 0:\n                locs = dt['all_locs'][i, :num_steps, :]\n                goal_loc = dt['all_goal_locs'][i, :, :]\n                xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n                xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n                xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                ax.set_axis_on()\n                ax.patch.set_facecolor((0.333, 0.333, 0.333))\n                ax.set_xticks([])\n                ax.set_yticks([])\n                ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n                ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n                locs = dt['all_locs'][i, :1, :]\n                ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n                ax.set_xlim([xy1[0], xy2[0]])\n                ax.set_ylim([xy1[1], xy2[1]])\n            locs = dt['all_locs'][i, step_number, :]\n            locs = np.expand_dims(locs, axis=0)\n            ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n            tt = ax.set_title('Trajectory in topview', fontsize=14)\n            plt.setp(tt, color='white')\n            return (fig,)\n        line_ani = animation.FuncAnimation(fig, worker, (num_steps - 1) * (wait_at_action + samples_per_action), interval=500, blit=True, init_func=init_fn)\n        tmp_file_name = 'tmp.mp4'\n        line_ani.save(tmp_file_name, writer=writer, savefig_kwargs={'facecolor': 'black'})\n        out_file_name = os.path.join(out_dir, 'vis_{:04d}.mp4'.format(i))\n        print(out_file_name)\n        if fu.exists(out_file_name):\n            gfile.Remove(out_file_name)\n        gfile.Copy(tmp_file_name, out_file_name)\n        gfile.Remove(tmp_file_name)\n        plt.close(fig)",
            "def plot_trajectory_first_person(dt, orig_maps, out_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    plt.set_cmap('gray')\n    samples_per_action = 8\n    wait_at_action = 0\n    Writer = animation.writers['mencoder']\n    writer = Writer(fps=3 * (samples_per_action + wait_at_action), metadata=dict(artist='anonymous'), bitrate=1800)\n    args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    navtask_ = copy.deepcopy(args.navtask)\n    navtask_.camera_param.modalities = ['rgb']\n    navtask_.task_params.modalities = ['rgb']\n    sz = 512\n    navtask_.camera_param.height = sz\n    navtask_.camera_param.width = sz\n    navtask_.task_params.img_height = sz\n    navtask_.task_params.img_width = sz\n    R = lambda : nav_env.get_multiplexer_class(navtask_, 0)\n    R = R()\n    b = R.buildings[0]\n    f = [0 for _ in range(wait_at_action)] + [float(_) / samples_per_action for _ in range(samples_per_action)]\n    inds_to_do = []\n    inds_to_do += [1, 4, 10]\n    for i in inds_to_do:\n        fig = plt.figure(figsize=(10, 8))\n        gs = GridSpec(3, 4)\n        gs.update(wspace=0.05, hspace=0.05, left=0.0, top=0.97, right=1.0, bottom=0.0)\n        ax = fig.add_subplot(gs[:, :-1])\n        ax1 = fig.add_subplot(gs[0, -1])\n        ax2 = fig.add_subplot(gs[1, -1])\n        ax3 = fig.add_subplot(gs[2, -1])\n        axes = [ax, ax1, ax2, ax3]\n        for ax in axes:\n            ax.set_axis_off()\n        node_ids = dt['all_node_ids'][i, :, 0] * 1\n        if np.all(node_ids[-4:] == node_ids[-1]):\n            while node_ids[-4] == node_ids[-1]:\n                node_ids = node_ids[:-1]\n        num_steps = np.minimum(FLAGS.num_steps, len(node_ids))\n        xyt = b.to_actual_xyt_vec(b.task.nodes[node_ids])\n        xyt_diff = xyt[1:, :] - xyt[:-1, :]\n        xyt_diff[:, 2] = np.mod(xyt_diff[:, 2], 4)\n        ind = np.where(xyt_diff[:, 2] == 3)[0]\n        xyt_diff[ind, 2] = -1\n        xyt_diff = np.expand_dims(xyt_diff, axis=1)\n        to_cat = [xyt_diff * _ for _ in f]\n        perturbs_all = np.concatenate(to_cat, axis=1)\n        perturbs_all = np.concatenate([perturbs_all, np.zeros_like(perturbs_all[:, :, :1])], axis=2)\n        node_ids_all = np.expand_dims(node_ids, axis=1) * 1\n        node_ids_all = np.concatenate([node_ids_all for _ in f], axis=1)\n        node_ids_all = np.reshape(node_ids_all[:-1, :], -1)\n        perturbs_all = np.reshape(perturbs_all, [-1, 4])\n        imgs = b.render_nodes(b.task.nodes[node_ids_all, :], perturb=perturbs_all)\n        actions = []\n        (_, action_to_nodes) = b.get_feasible_actions(node_ids)\n        for j in range(num_steps - 1):\n            action_to_node = action_to_nodes[j]\n            node_to_action = dict(zip(action_to_node.values(), action_to_node.keys()))\n            actions.append(node_to_action[node_ids[j + 1]])\n\n        def init_fn():\n            return (fig,)\n        gt_dist_to_goal = []\n\n        def worker(j):\n            step_number = j / (samples_per_action + wait_at_action)\n            img = imgs[j]\n            ax = axes[0]\n            ax.clear()\n            ax.set_axis_off()\n            img = img.astype(np.uint8)\n            ax.imshow(img)\n            tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n            plt.setp(tt, color='white')\n            t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n            t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n            t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            ax = axes[-1]\n            if j == 0:\n                locs = dt['all_locs'][i, :num_steps, :]\n                goal_loc = dt['all_goal_locs'][i, :, :]\n                xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n                xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n                xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                ax.set_axis_on()\n                ax.patch.set_facecolor((0.333, 0.333, 0.333))\n                ax.set_xticks([])\n                ax.set_yticks([])\n                ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n                ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n                locs = dt['all_locs'][i, :1, :]\n                ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n                ax.set_xlim([xy1[0], xy2[0]])\n                ax.set_ylim([xy1[1], xy2[1]])\n            locs = dt['all_locs'][i, step_number, :]\n            locs = np.expand_dims(locs, axis=0)\n            ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n            tt = ax.set_title('Trajectory in topview', fontsize=14)\n            plt.setp(tt, color='white')\n            return (fig,)\n        line_ani = animation.FuncAnimation(fig, worker, (num_steps - 1) * (wait_at_action + samples_per_action), interval=500, blit=True, init_func=init_fn)\n        tmp_file_name = 'tmp.mp4'\n        line_ani.save(tmp_file_name, writer=writer, savefig_kwargs={'facecolor': 'black'})\n        out_file_name = os.path.join(out_dir, 'vis_{:04d}.mp4'.format(i))\n        print(out_file_name)\n        if fu.exists(out_file_name):\n            gfile.Remove(out_file_name)\n        gfile.Copy(tmp_file_name, out_file_name)\n        gfile.Remove(tmp_file_name)\n        plt.close(fig)",
            "def plot_trajectory_first_person(dt, orig_maps, out_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    plt.set_cmap('gray')\n    samples_per_action = 8\n    wait_at_action = 0\n    Writer = animation.writers['mencoder']\n    writer = Writer(fps=3 * (samples_per_action + wait_at_action), metadata=dict(artist='anonymous'), bitrate=1800)\n    args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    navtask_ = copy.deepcopy(args.navtask)\n    navtask_.camera_param.modalities = ['rgb']\n    navtask_.task_params.modalities = ['rgb']\n    sz = 512\n    navtask_.camera_param.height = sz\n    navtask_.camera_param.width = sz\n    navtask_.task_params.img_height = sz\n    navtask_.task_params.img_width = sz\n    R = lambda : nav_env.get_multiplexer_class(navtask_, 0)\n    R = R()\n    b = R.buildings[0]\n    f = [0 for _ in range(wait_at_action)] + [float(_) / samples_per_action for _ in range(samples_per_action)]\n    inds_to_do = []\n    inds_to_do += [1, 4, 10]\n    for i in inds_to_do:\n        fig = plt.figure(figsize=(10, 8))\n        gs = GridSpec(3, 4)\n        gs.update(wspace=0.05, hspace=0.05, left=0.0, top=0.97, right=1.0, bottom=0.0)\n        ax = fig.add_subplot(gs[:, :-1])\n        ax1 = fig.add_subplot(gs[0, -1])\n        ax2 = fig.add_subplot(gs[1, -1])\n        ax3 = fig.add_subplot(gs[2, -1])\n        axes = [ax, ax1, ax2, ax3]\n        for ax in axes:\n            ax.set_axis_off()\n        node_ids = dt['all_node_ids'][i, :, 0] * 1\n        if np.all(node_ids[-4:] == node_ids[-1]):\n            while node_ids[-4] == node_ids[-1]:\n                node_ids = node_ids[:-1]\n        num_steps = np.minimum(FLAGS.num_steps, len(node_ids))\n        xyt = b.to_actual_xyt_vec(b.task.nodes[node_ids])\n        xyt_diff = xyt[1:, :] - xyt[:-1, :]\n        xyt_diff[:, 2] = np.mod(xyt_diff[:, 2], 4)\n        ind = np.where(xyt_diff[:, 2] == 3)[0]\n        xyt_diff[ind, 2] = -1\n        xyt_diff = np.expand_dims(xyt_diff, axis=1)\n        to_cat = [xyt_diff * _ for _ in f]\n        perturbs_all = np.concatenate(to_cat, axis=1)\n        perturbs_all = np.concatenate([perturbs_all, np.zeros_like(perturbs_all[:, :, :1])], axis=2)\n        node_ids_all = np.expand_dims(node_ids, axis=1) * 1\n        node_ids_all = np.concatenate([node_ids_all for _ in f], axis=1)\n        node_ids_all = np.reshape(node_ids_all[:-1, :], -1)\n        perturbs_all = np.reshape(perturbs_all, [-1, 4])\n        imgs = b.render_nodes(b.task.nodes[node_ids_all, :], perturb=perturbs_all)\n        actions = []\n        (_, action_to_nodes) = b.get_feasible_actions(node_ids)\n        for j in range(num_steps - 1):\n            action_to_node = action_to_nodes[j]\n            node_to_action = dict(zip(action_to_node.values(), action_to_node.keys()))\n            actions.append(node_to_action[node_ids[j + 1]])\n\n        def init_fn():\n            return (fig,)\n        gt_dist_to_goal = []\n\n        def worker(j):\n            step_number = j / (samples_per_action + wait_at_action)\n            img = imgs[j]\n            ax = axes[0]\n            ax.clear()\n            ax.set_axis_off()\n            img = img.astype(np.uint8)\n            ax.imshow(img)\n            tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n            plt.setp(tt, color='white')\n            t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n            t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n            t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            ax = axes[-1]\n            if j == 0:\n                locs = dt['all_locs'][i, :num_steps, :]\n                goal_loc = dt['all_goal_locs'][i, :, :]\n                xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n                xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n                xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                ax.set_axis_on()\n                ax.patch.set_facecolor((0.333, 0.333, 0.333))\n                ax.set_xticks([])\n                ax.set_yticks([])\n                ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n                ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n                locs = dt['all_locs'][i, :1, :]\n                ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n                ax.set_xlim([xy1[0], xy2[0]])\n                ax.set_ylim([xy1[1], xy2[1]])\n            locs = dt['all_locs'][i, step_number, :]\n            locs = np.expand_dims(locs, axis=0)\n            ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n            tt = ax.set_title('Trajectory in topview', fontsize=14)\n            plt.setp(tt, color='white')\n            return (fig,)\n        line_ani = animation.FuncAnimation(fig, worker, (num_steps - 1) * (wait_at_action + samples_per_action), interval=500, blit=True, init_func=init_fn)\n        tmp_file_name = 'tmp.mp4'\n        line_ani.save(tmp_file_name, writer=writer, savefig_kwargs={'facecolor': 'black'})\n        out_file_name = os.path.join(out_dir, 'vis_{:04d}.mp4'.format(i))\n        print(out_file_name)\n        if fu.exists(out_file_name):\n            gfile.Remove(out_file_name)\n        gfile.Copy(tmp_file_name, out_file_name)\n        gfile.Remove(tmp_file_name)\n        plt.close(fig)",
            "def plot_trajectory_first_person(dt, orig_maps, out_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    plt.set_cmap('gray')\n    samples_per_action = 8\n    wait_at_action = 0\n    Writer = animation.writers['mencoder']\n    writer = Writer(fps=3 * (samples_per_action + wait_at_action), metadata=dict(artist='anonymous'), bitrate=1800)\n    args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    navtask_ = copy.deepcopy(args.navtask)\n    navtask_.camera_param.modalities = ['rgb']\n    navtask_.task_params.modalities = ['rgb']\n    sz = 512\n    navtask_.camera_param.height = sz\n    navtask_.camera_param.width = sz\n    navtask_.task_params.img_height = sz\n    navtask_.task_params.img_width = sz\n    R = lambda : nav_env.get_multiplexer_class(navtask_, 0)\n    R = R()\n    b = R.buildings[0]\n    f = [0 for _ in range(wait_at_action)] + [float(_) / samples_per_action for _ in range(samples_per_action)]\n    inds_to_do = []\n    inds_to_do += [1, 4, 10]\n    for i in inds_to_do:\n        fig = plt.figure(figsize=(10, 8))\n        gs = GridSpec(3, 4)\n        gs.update(wspace=0.05, hspace=0.05, left=0.0, top=0.97, right=1.0, bottom=0.0)\n        ax = fig.add_subplot(gs[:, :-1])\n        ax1 = fig.add_subplot(gs[0, -1])\n        ax2 = fig.add_subplot(gs[1, -1])\n        ax3 = fig.add_subplot(gs[2, -1])\n        axes = [ax, ax1, ax2, ax3]\n        for ax in axes:\n            ax.set_axis_off()\n        node_ids = dt['all_node_ids'][i, :, 0] * 1\n        if np.all(node_ids[-4:] == node_ids[-1]):\n            while node_ids[-4] == node_ids[-1]:\n                node_ids = node_ids[:-1]\n        num_steps = np.minimum(FLAGS.num_steps, len(node_ids))\n        xyt = b.to_actual_xyt_vec(b.task.nodes[node_ids])\n        xyt_diff = xyt[1:, :] - xyt[:-1, :]\n        xyt_diff[:, 2] = np.mod(xyt_diff[:, 2], 4)\n        ind = np.where(xyt_diff[:, 2] == 3)[0]\n        xyt_diff[ind, 2] = -1\n        xyt_diff = np.expand_dims(xyt_diff, axis=1)\n        to_cat = [xyt_diff * _ for _ in f]\n        perturbs_all = np.concatenate(to_cat, axis=1)\n        perturbs_all = np.concatenate([perturbs_all, np.zeros_like(perturbs_all[:, :, :1])], axis=2)\n        node_ids_all = np.expand_dims(node_ids, axis=1) * 1\n        node_ids_all = np.concatenate([node_ids_all for _ in f], axis=1)\n        node_ids_all = np.reshape(node_ids_all[:-1, :], -1)\n        perturbs_all = np.reshape(perturbs_all, [-1, 4])\n        imgs = b.render_nodes(b.task.nodes[node_ids_all, :], perturb=perturbs_all)\n        actions = []\n        (_, action_to_nodes) = b.get_feasible_actions(node_ids)\n        for j in range(num_steps - 1):\n            action_to_node = action_to_nodes[j]\n            node_to_action = dict(zip(action_to_node.values(), action_to_node.keys()))\n            actions.append(node_to_action[node_ids[j + 1]])\n\n        def init_fn():\n            return (fig,)\n        gt_dist_to_goal = []\n\n        def worker(j):\n            step_number = j / (samples_per_action + wait_at_action)\n            img = imgs[j]\n            ax = axes[0]\n            ax.clear()\n            ax.set_axis_off()\n            img = img.astype(np.uint8)\n            ax.imshow(img)\n            tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n            plt.setp(tt, color='white')\n            t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n            t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n            t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            ax = axes[-1]\n            if j == 0:\n                locs = dt['all_locs'][i, :num_steps, :]\n                goal_loc = dt['all_goal_locs'][i, :, :]\n                xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n                xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n                xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                ax.set_axis_on()\n                ax.patch.set_facecolor((0.333, 0.333, 0.333))\n                ax.set_xticks([])\n                ax.set_yticks([])\n                ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n                ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n                locs = dt['all_locs'][i, :1, :]\n                ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n                ax.set_xlim([xy1[0], xy2[0]])\n                ax.set_ylim([xy1[1], xy2[1]])\n            locs = dt['all_locs'][i, step_number, :]\n            locs = np.expand_dims(locs, axis=0)\n            ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n            tt = ax.set_title('Trajectory in topview', fontsize=14)\n            plt.setp(tt, color='white')\n            return (fig,)\n        line_ani = animation.FuncAnimation(fig, worker, (num_steps - 1) * (wait_at_action + samples_per_action), interval=500, blit=True, init_func=init_fn)\n        tmp_file_name = 'tmp.mp4'\n        line_ani.save(tmp_file_name, writer=writer, savefig_kwargs={'facecolor': 'black'})\n        out_file_name = os.path.join(out_dir, 'vis_{:04d}.mp4'.format(i))\n        print(out_file_name)\n        if fu.exists(out_file_name):\n            gfile.Remove(out_file_name)\n        gfile.Copy(tmp_file_name, out_file_name)\n        gfile.Remove(tmp_file_name)\n        plt.close(fig)",
            "def plot_trajectory_first_person(dt, orig_maps, out_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    plt.set_cmap('gray')\n    samples_per_action = 8\n    wait_at_action = 0\n    Writer = animation.writers['mencoder']\n    writer = Writer(fps=3 * (samples_per_action + wait_at_action), metadata=dict(artist='anonymous'), bitrate=1800)\n    args = sna.get_args_for_config(FLAGS.config_name + '+bench_' + FLAGS.imset)\n    args.navtask.logdir = None\n    navtask_ = copy.deepcopy(args.navtask)\n    navtask_.camera_param.modalities = ['rgb']\n    navtask_.task_params.modalities = ['rgb']\n    sz = 512\n    navtask_.camera_param.height = sz\n    navtask_.camera_param.width = sz\n    navtask_.task_params.img_height = sz\n    navtask_.task_params.img_width = sz\n    R = lambda : nav_env.get_multiplexer_class(navtask_, 0)\n    R = R()\n    b = R.buildings[0]\n    f = [0 for _ in range(wait_at_action)] + [float(_) / samples_per_action for _ in range(samples_per_action)]\n    inds_to_do = []\n    inds_to_do += [1, 4, 10]\n    for i in inds_to_do:\n        fig = plt.figure(figsize=(10, 8))\n        gs = GridSpec(3, 4)\n        gs.update(wspace=0.05, hspace=0.05, left=0.0, top=0.97, right=1.0, bottom=0.0)\n        ax = fig.add_subplot(gs[:, :-1])\n        ax1 = fig.add_subplot(gs[0, -1])\n        ax2 = fig.add_subplot(gs[1, -1])\n        ax3 = fig.add_subplot(gs[2, -1])\n        axes = [ax, ax1, ax2, ax3]\n        for ax in axes:\n            ax.set_axis_off()\n        node_ids = dt['all_node_ids'][i, :, 0] * 1\n        if np.all(node_ids[-4:] == node_ids[-1]):\n            while node_ids[-4] == node_ids[-1]:\n                node_ids = node_ids[:-1]\n        num_steps = np.minimum(FLAGS.num_steps, len(node_ids))\n        xyt = b.to_actual_xyt_vec(b.task.nodes[node_ids])\n        xyt_diff = xyt[1:, :] - xyt[:-1, :]\n        xyt_diff[:, 2] = np.mod(xyt_diff[:, 2], 4)\n        ind = np.where(xyt_diff[:, 2] == 3)[0]\n        xyt_diff[ind, 2] = -1\n        xyt_diff = np.expand_dims(xyt_diff, axis=1)\n        to_cat = [xyt_diff * _ for _ in f]\n        perturbs_all = np.concatenate(to_cat, axis=1)\n        perturbs_all = np.concatenate([perturbs_all, np.zeros_like(perturbs_all[:, :, :1])], axis=2)\n        node_ids_all = np.expand_dims(node_ids, axis=1) * 1\n        node_ids_all = np.concatenate([node_ids_all for _ in f], axis=1)\n        node_ids_all = np.reshape(node_ids_all[:-1, :], -1)\n        perturbs_all = np.reshape(perturbs_all, [-1, 4])\n        imgs = b.render_nodes(b.task.nodes[node_ids_all, :], perturb=perturbs_all)\n        actions = []\n        (_, action_to_nodes) = b.get_feasible_actions(node_ids)\n        for j in range(num_steps - 1):\n            action_to_node = action_to_nodes[j]\n            node_to_action = dict(zip(action_to_node.values(), action_to_node.keys()))\n            actions.append(node_to_action[node_ids[j + 1]])\n\n        def init_fn():\n            return (fig,)\n        gt_dist_to_goal = []\n\n        def worker(j):\n            step_number = j / (samples_per_action + wait_at_action)\n            img = imgs[j]\n            ax = axes[0]\n            ax.clear()\n            ax.set_axis_off()\n            img = img.astype(np.uint8)\n            ax.imshow(img)\n            tt = ax.set_title('First Person View\\n' + \"Top corners show diagnostics (distance, agents' action) not input to agent.\", fontsize=12)\n            plt.setp(tt, color='white')\n            t = 'Dist to Goal:\\n{:2d} steps'.format(int(dt['all_d_at_t'][i, step_number]))\n            t = ax.text(0.01, 0.99, t, horizontalalignment='left', verticalalignment='top', fontsize=20, color='red', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            action_latex = ['$\\\\odot$ ', '$\\\\curvearrowright$ ', '$\\\\curvearrowleft$ ', '$\\\\Uparrow$ ']\n            t = ax.text(0.99, 0.99, action_latex[actions[step_number]], horizontalalignment='right', verticalalignment='top', fontsize=40, color='green', transform=ax.transAxes, alpha=1.0)\n            t.set_bbox(dict(color='white', alpha=0.85, pad=-0.1))\n            ax = axes[-1]\n            if j == 0:\n                locs = dt['all_locs'][i, :num_steps, :]\n                goal_loc = dt['all_goal_locs'][i, :, :]\n                xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n                xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n                xy1 = (xymax + xymin) / 2.0 - 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                xy2 = (xymax + xymin) / 2.0 + 0.7 * np.maximum(np.max(xymax - xymin), 24)\n                ax.set_axis_on()\n                ax.patch.set_facecolor((0.333, 0.333, 0.333))\n                ax.set_xticks([])\n                ax.set_yticks([])\n                ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0)\n                ax.plot(goal_loc[:, 0], goal_loc[:, 1], 'g*', markersize=12)\n                locs = dt['all_locs'][i, :1, :]\n                ax.plot(locs[:, 0], locs[:, 1], 'b.', markersize=12)\n                ax.set_xlim([xy1[0], xy2[0]])\n                ax.set_ylim([xy1[1], xy2[1]])\n            locs = dt['all_locs'][i, step_number, :]\n            locs = np.expand_dims(locs, axis=0)\n            ax.plot(locs[:, 0], locs[:, 1], 'r.', alpha=1.0, linewidth=0, markersize=4)\n            tt = ax.set_title('Trajectory in topview', fontsize=14)\n            plt.setp(tt, color='white')\n            return (fig,)\n        line_ani = animation.FuncAnimation(fig, worker, (num_steps - 1) * (wait_at_action + samples_per_action), interval=500, blit=True, init_func=init_fn)\n        tmp_file_name = 'tmp.mp4'\n        line_ani.save(tmp_file_name, writer=writer, savefig_kwargs={'facecolor': 'black'})\n        out_file_name = os.path.join(out_dir, 'vis_{:04d}.mp4'.format(i))\n        print(out_file_name)\n        if fu.exists(out_file_name):\n            gfile.Remove(out_file_name)\n        gfile.Copy(tmp_file_name, out_file_name)\n        gfile.Remove(tmp_file_name)\n        plt.close(fig)"
        ]
    },
    {
        "func_name": "plot_trajectory",
        "original": "def plot_trajectory(dt, hardness, orig_maps, out_dir):\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    out_file = os.path.join(out_dir, 'all_locs_at_t.pkl')\n    dt['hardness'] = hardness\n    utils.save_variables(out_file, dt.values(), dt.keys(), overwrite=True)\n    plt.set_cmap('gray')\n    for i in range(4000):\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        locs = np.concatenate((dt['all_locs'][i, :, :], dt['all_locs'][i, :, :]), axis=0)\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        (fig, ax) = utils.tight_imshow_figure(plt, figsize=(6, 6))\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        all_locs = dt['all_locs'][i, :, :] * 1\n        uniq = np.where(np.any(all_locs[1:, :] != all_locs[:-1, :], axis=1))[0] + 1\n        uniq = np.sort(uniq).tolist()\n        uniq.insert(0, 0)\n        uniq = np.array(uniq)\n        all_locs = all_locs[uniq, :]\n        ax.plot(dt['all_locs'][i, 0, 0], dt['all_locs'][i, 0, 1], 'b.', markersize=24)\n        ax.plot(dt['all_goal_locs'][i, 0, 0], dt['all_goal_locs'][i, 0, 1], 'g*', markersize=19)\n        ax.plot(all_locs[:, 0], all_locs[:, 1], 'r', alpha=0.4, linewidth=2)\n        ax.scatter(all_locs[:, 0], all_locs[:, 1], c=5 + np.arange(all_locs.shape[0]) * 1.0 / all_locs.shape[0], cmap='Reds', s=30, linewidth=0)\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0, aspect='equal')\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n        file_name = os.path.join(out_dir, 'trajectory_{:04d}.png'.format(i))\n        print(file_name)\n        with fu.fopen(file_name, 'w') as f:\n            plt.savefig(f)\n        plt.close(fig)",
        "mutated": [
            "def plot_trajectory(dt, hardness, orig_maps, out_dir):\n    if False:\n        i = 10\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    out_file = os.path.join(out_dir, 'all_locs_at_t.pkl')\n    dt['hardness'] = hardness\n    utils.save_variables(out_file, dt.values(), dt.keys(), overwrite=True)\n    plt.set_cmap('gray')\n    for i in range(4000):\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        locs = np.concatenate((dt['all_locs'][i, :, :], dt['all_locs'][i, :, :]), axis=0)\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        (fig, ax) = utils.tight_imshow_figure(plt, figsize=(6, 6))\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        all_locs = dt['all_locs'][i, :, :] * 1\n        uniq = np.where(np.any(all_locs[1:, :] != all_locs[:-1, :], axis=1))[0] + 1\n        uniq = np.sort(uniq).tolist()\n        uniq.insert(0, 0)\n        uniq = np.array(uniq)\n        all_locs = all_locs[uniq, :]\n        ax.plot(dt['all_locs'][i, 0, 0], dt['all_locs'][i, 0, 1], 'b.', markersize=24)\n        ax.plot(dt['all_goal_locs'][i, 0, 0], dt['all_goal_locs'][i, 0, 1], 'g*', markersize=19)\n        ax.plot(all_locs[:, 0], all_locs[:, 1], 'r', alpha=0.4, linewidth=2)\n        ax.scatter(all_locs[:, 0], all_locs[:, 1], c=5 + np.arange(all_locs.shape[0]) * 1.0 / all_locs.shape[0], cmap='Reds', s=30, linewidth=0)\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0, aspect='equal')\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n        file_name = os.path.join(out_dir, 'trajectory_{:04d}.png'.format(i))\n        print(file_name)\n        with fu.fopen(file_name, 'w') as f:\n            plt.savefig(f)\n        plt.close(fig)",
            "def plot_trajectory(dt, hardness, orig_maps, out_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    out_file = os.path.join(out_dir, 'all_locs_at_t.pkl')\n    dt['hardness'] = hardness\n    utils.save_variables(out_file, dt.values(), dt.keys(), overwrite=True)\n    plt.set_cmap('gray')\n    for i in range(4000):\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        locs = np.concatenate((dt['all_locs'][i, :, :], dt['all_locs'][i, :, :]), axis=0)\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        (fig, ax) = utils.tight_imshow_figure(plt, figsize=(6, 6))\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        all_locs = dt['all_locs'][i, :, :] * 1\n        uniq = np.where(np.any(all_locs[1:, :] != all_locs[:-1, :], axis=1))[0] + 1\n        uniq = np.sort(uniq).tolist()\n        uniq.insert(0, 0)\n        uniq = np.array(uniq)\n        all_locs = all_locs[uniq, :]\n        ax.plot(dt['all_locs'][i, 0, 0], dt['all_locs'][i, 0, 1], 'b.', markersize=24)\n        ax.plot(dt['all_goal_locs'][i, 0, 0], dt['all_goal_locs'][i, 0, 1], 'g*', markersize=19)\n        ax.plot(all_locs[:, 0], all_locs[:, 1], 'r', alpha=0.4, linewidth=2)\n        ax.scatter(all_locs[:, 0], all_locs[:, 1], c=5 + np.arange(all_locs.shape[0]) * 1.0 / all_locs.shape[0], cmap='Reds', s=30, linewidth=0)\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0, aspect='equal')\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n        file_name = os.path.join(out_dir, 'trajectory_{:04d}.png'.format(i))\n        print(file_name)\n        with fu.fopen(file_name, 'w') as f:\n            plt.savefig(f)\n        plt.close(fig)",
            "def plot_trajectory(dt, hardness, orig_maps, out_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    out_file = os.path.join(out_dir, 'all_locs_at_t.pkl')\n    dt['hardness'] = hardness\n    utils.save_variables(out_file, dt.values(), dt.keys(), overwrite=True)\n    plt.set_cmap('gray')\n    for i in range(4000):\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        locs = np.concatenate((dt['all_locs'][i, :, :], dt['all_locs'][i, :, :]), axis=0)\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        (fig, ax) = utils.tight_imshow_figure(plt, figsize=(6, 6))\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        all_locs = dt['all_locs'][i, :, :] * 1\n        uniq = np.where(np.any(all_locs[1:, :] != all_locs[:-1, :], axis=1))[0] + 1\n        uniq = np.sort(uniq).tolist()\n        uniq.insert(0, 0)\n        uniq = np.array(uniq)\n        all_locs = all_locs[uniq, :]\n        ax.plot(dt['all_locs'][i, 0, 0], dt['all_locs'][i, 0, 1], 'b.', markersize=24)\n        ax.plot(dt['all_goal_locs'][i, 0, 0], dt['all_goal_locs'][i, 0, 1], 'g*', markersize=19)\n        ax.plot(all_locs[:, 0], all_locs[:, 1], 'r', alpha=0.4, linewidth=2)\n        ax.scatter(all_locs[:, 0], all_locs[:, 1], c=5 + np.arange(all_locs.shape[0]) * 1.0 / all_locs.shape[0], cmap='Reds', s=30, linewidth=0)\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0, aspect='equal')\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n        file_name = os.path.join(out_dir, 'trajectory_{:04d}.png'.format(i))\n        print(file_name)\n        with fu.fopen(file_name, 'w') as f:\n            plt.savefig(f)\n        plt.close(fig)",
            "def plot_trajectory(dt, hardness, orig_maps, out_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    out_file = os.path.join(out_dir, 'all_locs_at_t.pkl')\n    dt['hardness'] = hardness\n    utils.save_variables(out_file, dt.values(), dt.keys(), overwrite=True)\n    plt.set_cmap('gray')\n    for i in range(4000):\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        locs = np.concatenate((dt['all_locs'][i, :, :], dt['all_locs'][i, :, :]), axis=0)\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        (fig, ax) = utils.tight_imshow_figure(plt, figsize=(6, 6))\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        all_locs = dt['all_locs'][i, :, :] * 1\n        uniq = np.where(np.any(all_locs[1:, :] != all_locs[:-1, :], axis=1))[0] + 1\n        uniq = np.sort(uniq).tolist()\n        uniq.insert(0, 0)\n        uniq = np.array(uniq)\n        all_locs = all_locs[uniq, :]\n        ax.plot(dt['all_locs'][i, 0, 0], dt['all_locs'][i, 0, 1], 'b.', markersize=24)\n        ax.plot(dt['all_goal_locs'][i, 0, 0], dt['all_goal_locs'][i, 0, 1], 'g*', markersize=19)\n        ax.plot(all_locs[:, 0], all_locs[:, 1], 'r', alpha=0.4, linewidth=2)\n        ax.scatter(all_locs[:, 0], all_locs[:, 1], c=5 + np.arange(all_locs.shape[0]) * 1.0 / all_locs.shape[0], cmap='Reds', s=30, linewidth=0)\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0, aspect='equal')\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n        file_name = os.path.join(out_dir, 'trajectory_{:04d}.png'.format(i))\n        print(file_name)\n        with fu.fopen(file_name, 'w') as f:\n            plt.savefig(f)\n        plt.close(fig)",
            "def plot_trajectory(dt, hardness, orig_maps, out_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out_dir = os.path.join(out_dir, FLAGS.config_name + _get_suffix_str(), FLAGS.imset)\n    fu.makedirs(out_dir)\n    out_file = os.path.join(out_dir, 'all_locs_at_t.pkl')\n    dt['hardness'] = hardness\n    utils.save_variables(out_file, dt.values(), dt.keys(), overwrite=True)\n    plt.set_cmap('gray')\n    for i in range(4000):\n        goal_loc = dt['all_goal_locs'][i, :, :]\n        locs = np.concatenate((dt['all_locs'][i, :, :], dt['all_locs'][i, :, :]), axis=0)\n        xymin = np.minimum(np.min(goal_loc, axis=0), np.min(locs, axis=0))\n        xymax = np.maximum(np.max(goal_loc, axis=0), np.max(locs, axis=0))\n        xy1 = (xymax + xymin) / 2.0 - 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        xy2 = (xymax + xymin) / 2.0 + 1.0 * np.maximum(np.max(xymax - xymin), 24)\n        (fig, ax) = utils.tight_imshow_figure(plt, figsize=(6, 6))\n        ax.set_axis_on()\n        ax.patch.set_facecolor((0.333, 0.333, 0.333))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        all_locs = dt['all_locs'][i, :, :] * 1\n        uniq = np.where(np.any(all_locs[1:, :] != all_locs[:-1, :], axis=1))[0] + 1\n        uniq = np.sort(uniq).tolist()\n        uniq.insert(0, 0)\n        uniq = np.array(uniq)\n        all_locs = all_locs[uniq, :]\n        ax.plot(dt['all_locs'][i, 0, 0], dt['all_locs'][i, 0, 1], 'b.', markersize=24)\n        ax.plot(dt['all_goal_locs'][i, 0, 0], dt['all_goal_locs'][i, 0, 1], 'g*', markersize=19)\n        ax.plot(all_locs[:, 0], all_locs[:, 1], 'r', alpha=0.4, linewidth=2)\n        ax.scatter(all_locs[:, 0], all_locs[:, 1], c=5 + np.arange(all_locs.shape[0]) * 1.0 / all_locs.shape[0], cmap='Reds', s=30, linewidth=0)\n        ax.imshow(orig_maps, origin='lower', vmin=-1.0, vmax=2.0, aspect='equal')\n        ax.set_xlim([xy1[0], xy2[0]])\n        ax.set_ylim([xy1[1], xy2[1]])\n        file_name = os.path.join(out_dir, 'trajectory_{:04d}.png'.format(i))\n        print(file_name)\n        with fu.fopen(file_name, 'w') as f:\n            plt.savefig(f)\n        plt.close(fig)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(_):\n    a = _load_trajectory()\n    (h_dists, gt_dists, orig_maps) = _compute_hardness()\n    hardness = 1.0 - h_dists * 1.0 / gt_dists\n    if FLAGS.top_view:\n        plot_trajectory(a, hardness, orig_maps, out_dir=FLAGS.out_dir)\n    if FLAGS.first_person:\n        plot_trajectory_first_person(a, orig_maps, out_dir=FLAGS.out_dir)",
        "mutated": [
            "def main(_):\n    if False:\n        i = 10\n    a = _load_trajectory()\n    (h_dists, gt_dists, orig_maps) = _compute_hardness()\n    hardness = 1.0 - h_dists * 1.0 / gt_dists\n    if FLAGS.top_view:\n        plot_trajectory(a, hardness, orig_maps, out_dir=FLAGS.out_dir)\n    if FLAGS.first_person:\n        plot_trajectory_first_person(a, orig_maps, out_dir=FLAGS.out_dir)",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = _load_trajectory()\n    (h_dists, gt_dists, orig_maps) = _compute_hardness()\n    hardness = 1.0 - h_dists * 1.0 / gt_dists\n    if FLAGS.top_view:\n        plot_trajectory(a, hardness, orig_maps, out_dir=FLAGS.out_dir)\n    if FLAGS.first_person:\n        plot_trajectory_first_person(a, orig_maps, out_dir=FLAGS.out_dir)",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = _load_trajectory()\n    (h_dists, gt_dists, orig_maps) = _compute_hardness()\n    hardness = 1.0 - h_dists * 1.0 / gt_dists\n    if FLAGS.top_view:\n        plot_trajectory(a, hardness, orig_maps, out_dir=FLAGS.out_dir)\n    if FLAGS.first_person:\n        plot_trajectory_first_person(a, orig_maps, out_dir=FLAGS.out_dir)",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = _load_trajectory()\n    (h_dists, gt_dists, orig_maps) = _compute_hardness()\n    hardness = 1.0 - h_dists * 1.0 / gt_dists\n    if FLAGS.top_view:\n        plot_trajectory(a, hardness, orig_maps, out_dir=FLAGS.out_dir)\n    if FLAGS.first_person:\n        plot_trajectory_first_person(a, orig_maps, out_dir=FLAGS.out_dir)",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = _load_trajectory()\n    (h_dists, gt_dists, orig_maps) = _compute_hardness()\n    hardness = 1.0 - h_dists * 1.0 / gt_dists\n    if FLAGS.top_view:\n        plot_trajectory(a, hardness, orig_maps, out_dir=FLAGS.out_dir)\n    if FLAGS.first_person:\n        plot_trajectory_first_person(a, orig_maps, out_dir=FLAGS.out_dir)"
        ]
    }
]