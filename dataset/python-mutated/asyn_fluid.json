[
    {
        "func_name": "asyn_fluidc",
        "original": "@not_implemented_for('directed', 'multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef asyn_fluidc(G, k, max_iter=100, seed=None):\n    \"\"\"Returns communities in `G` as detected by Fluid Communities algorithm.\n\n    The asynchronous fluid communities algorithm is described in\n    [1]_. The algorithm is based on the simple idea of fluids interacting\n    in an environment, expanding and pushing each other. Its initialization is\n    random, so found communities may vary on different executions.\n\n    The algorithm proceeds as follows. First each of the initial k communities\n    is initialized in a random vertex in the graph. Then the algorithm iterates\n    over all vertices in a random order, updating the community of each vertex\n    based on its own community and the communities of its neighbours. This\n    process is performed several times until convergence.\n    At all times, each community has a total density of 1, which is equally\n    distributed among the vertices it contains. If a vertex changes of\n    community, vertex densities of affected communities are adjusted\n    immediately. When a complete iteration over all vertices is done, such that\n    no vertex changes the community it belongs to, the algorithm has converged\n    and returns.\n\n    This is the original version of the algorithm described in [1]_.\n    Unfortunately, it does not support weighted graphs yet.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Graph must be simple and undirected.\n\n    k : integer\n        The number of communities to be found.\n\n    max_iter : integer\n        The number of maximum iterations allowed. By default 100.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    communities : iterable\n        Iterable of communities given as sets of nodes.\n\n    Notes\n    -----\n    k variable is not an optional argument.\n\n    References\n    ----------\n    .. [1] Par\u00e9s F., Garcia-Gasulla D. et al. \"Fluid Communities: A\n       Competitive and Highly Scalable Community Detection Algorithm\".\n       [https://arxiv.org/pdf/1703.09307.pdf].\n    \"\"\"\n    if not isinstance(k, int):\n        raise NetworkXError('k must be an integer.')\n    if not k > 0:\n        raise NetworkXError('k must be greater than 0.')\n    if not is_connected(G):\n        raise NetworkXError('Fluid Communities require connected Graphs.')\n    if len(G) < k:\n        raise NetworkXError('k cannot be bigger than the number of nodes.')\n    max_density = 1.0\n    vertices = list(G)\n    seed.shuffle(vertices)\n    communities = {n: i for (i, n) in enumerate(vertices[:k])}\n    density = {}\n    com_to_numvertices = {}\n    for vertex in communities:\n        com_to_numvertices[communities[vertex]] = 1\n        density[communities[vertex]] = max_density\n    iter_count = 0\n    cont = True\n    while cont:\n        cont = False\n        iter_count += 1\n        vertices = list(G)\n        seed.shuffle(vertices)\n        for vertex in vertices:\n            com_counter = Counter()\n            try:\n                com_counter.update({communities[vertex]: density[communities[vertex]]})\n            except KeyError:\n                pass\n            for v in G[vertex]:\n                try:\n                    com_counter.update({communities[v]: density[communities[v]]})\n                except KeyError:\n                    continue\n            new_com = -1\n            if len(com_counter.keys()) > 0:\n                max_freq = max(com_counter.values())\n                best_communities = [com for (com, freq) in com_counter.items() if max_freq - freq < 0.0001]\n                try:\n                    if communities[vertex] in best_communities:\n                        new_com = communities[vertex]\n                except KeyError:\n                    pass\n                if new_com == -1:\n                    cont = True\n                    new_com = seed.choice(best_communities)\n                    try:\n                        com_to_numvertices[communities[vertex]] -= 1\n                        density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n                    except KeyError:\n                        pass\n                    communities[vertex] = new_com\n                    com_to_numvertices[communities[vertex]] += 1\n                    density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n        if iter_count > max_iter:\n            break\n    return iter(groups(communities).values())",
        "mutated": [
            "@not_implemented_for('directed', 'multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef asyn_fluidc(G, k, max_iter=100, seed=None):\n    if False:\n        i = 10\n    'Returns communities in `G` as detected by Fluid Communities algorithm.\\n\\n    The asynchronous fluid communities algorithm is described in\\n    [1]_. The algorithm is based on the simple idea of fluids interacting\\n    in an environment, expanding and pushing each other. Its initialization is\\n    random, so found communities may vary on different executions.\\n\\n    The algorithm proceeds as follows. First each of the initial k communities\\n    is initialized in a random vertex in the graph. Then the algorithm iterates\\n    over all vertices in a random order, updating the community of each vertex\\n    based on its own community and the communities of its neighbours. This\\n    process is performed several times until convergence.\\n    At all times, each community has a total density of 1, which is equally\\n    distributed among the vertices it contains. If a vertex changes of\\n    community, vertex densities of affected communities are adjusted\\n    immediately. When a complete iteration over all vertices is done, such that\\n    no vertex changes the community it belongs to, the algorithm has converged\\n    and returns.\\n\\n    This is the original version of the algorithm described in [1]_.\\n    Unfortunately, it does not support weighted graphs yet.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    k : integer\\n        The number of communities to be found.\\n\\n    max_iter : integer\\n        The number of maximum iterations allowed. By default 100.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    communities : iterable\\n        Iterable of communities given as sets of nodes.\\n\\n    Notes\\n    -----\\n    k variable is not an optional argument.\\n\\n    References\\n    ----------\\n    .. [1] Par\u00e9s F., Garcia-Gasulla D. et al. \"Fluid Communities: A\\n       Competitive and Highly Scalable Community Detection Algorithm\".\\n       [https://arxiv.org/pdf/1703.09307.pdf].\\n    '\n    if not isinstance(k, int):\n        raise NetworkXError('k must be an integer.')\n    if not k > 0:\n        raise NetworkXError('k must be greater than 0.')\n    if not is_connected(G):\n        raise NetworkXError('Fluid Communities require connected Graphs.')\n    if len(G) < k:\n        raise NetworkXError('k cannot be bigger than the number of nodes.')\n    max_density = 1.0\n    vertices = list(G)\n    seed.shuffle(vertices)\n    communities = {n: i for (i, n) in enumerate(vertices[:k])}\n    density = {}\n    com_to_numvertices = {}\n    for vertex in communities:\n        com_to_numvertices[communities[vertex]] = 1\n        density[communities[vertex]] = max_density\n    iter_count = 0\n    cont = True\n    while cont:\n        cont = False\n        iter_count += 1\n        vertices = list(G)\n        seed.shuffle(vertices)\n        for vertex in vertices:\n            com_counter = Counter()\n            try:\n                com_counter.update({communities[vertex]: density[communities[vertex]]})\n            except KeyError:\n                pass\n            for v in G[vertex]:\n                try:\n                    com_counter.update({communities[v]: density[communities[v]]})\n                except KeyError:\n                    continue\n            new_com = -1\n            if len(com_counter.keys()) > 0:\n                max_freq = max(com_counter.values())\n                best_communities = [com for (com, freq) in com_counter.items() if max_freq - freq < 0.0001]\n                try:\n                    if communities[vertex] in best_communities:\n                        new_com = communities[vertex]\n                except KeyError:\n                    pass\n                if new_com == -1:\n                    cont = True\n                    new_com = seed.choice(best_communities)\n                    try:\n                        com_to_numvertices[communities[vertex]] -= 1\n                        density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n                    except KeyError:\n                        pass\n                    communities[vertex] = new_com\n                    com_to_numvertices[communities[vertex]] += 1\n                    density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n        if iter_count > max_iter:\n            break\n    return iter(groups(communities).values())",
            "@not_implemented_for('directed', 'multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef asyn_fluidc(G, k, max_iter=100, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns communities in `G` as detected by Fluid Communities algorithm.\\n\\n    The asynchronous fluid communities algorithm is described in\\n    [1]_. The algorithm is based on the simple idea of fluids interacting\\n    in an environment, expanding and pushing each other. Its initialization is\\n    random, so found communities may vary on different executions.\\n\\n    The algorithm proceeds as follows. First each of the initial k communities\\n    is initialized in a random vertex in the graph. Then the algorithm iterates\\n    over all vertices in a random order, updating the community of each vertex\\n    based on its own community and the communities of its neighbours. This\\n    process is performed several times until convergence.\\n    At all times, each community has a total density of 1, which is equally\\n    distributed among the vertices it contains. If a vertex changes of\\n    community, vertex densities of affected communities are adjusted\\n    immediately. When a complete iteration over all vertices is done, such that\\n    no vertex changes the community it belongs to, the algorithm has converged\\n    and returns.\\n\\n    This is the original version of the algorithm described in [1]_.\\n    Unfortunately, it does not support weighted graphs yet.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    k : integer\\n        The number of communities to be found.\\n\\n    max_iter : integer\\n        The number of maximum iterations allowed. By default 100.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    communities : iterable\\n        Iterable of communities given as sets of nodes.\\n\\n    Notes\\n    -----\\n    k variable is not an optional argument.\\n\\n    References\\n    ----------\\n    .. [1] Par\u00e9s F., Garcia-Gasulla D. et al. \"Fluid Communities: A\\n       Competitive and Highly Scalable Community Detection Algorithm\".\\n       [https://arxiv.org/pdf/1703.09307.pdf].\\n    '\n    if not isinstance(k, int):\n        raise NetworkXError('k must be an integer.')\n    if not k > 0:\n        raise NetworkXError('k must be greater than 0.')\n    if not is_connected(G):\n        raise NetworkXError('Fluid Communities require connected Graphs.')\n    if len(G) < k:\n        raise NetworkXError('k cannot be bigger than the number of nodes.')\n    max_density = 1.0\n    vertices = list(G)\n    seed.shuffle(vertices)\n    communities = {n: i for (i, n) in enumerate(vertices[:k])}\n    density = {}\n    com_to_numvertices = {}\n    for vertex in communities:\n        com_to_numvertices[communities[vertex]] = 1\n        density[communities[vertex]] = max_density\n    iter_count = 0\n    cont = True\n    while cont:\n        cont = False\n        iter_count += 1\n        vertices = list(G)\n        seed.shuffle(vertices)\n        for vertex in vertices:\n            com_counter = Counter()\n            try:\n                com_counter.update({communities[vertex]: density[communities[vertex]]})\n            except KeyError:\n                pass\n            for v in G[vertex]:\n                try:\n                    com_counter.update({communities[v]: density[communities[v]]})\n                except KeyError:\n                    continue\n            new_com = -1\n            if len(com_counter.keys()) > 0:\n                max_freq = max(com_counter.values())\n                best_communities = [com for (com, freq) in com_counter.items() if max_freq - freq < 0.0001]\n                try:\n                    if communities[vertex] in best_communities:\n                        new_com = communities[vertex]\n                except KeyError:\n                    pass\n                if new_com == -1:\n                    cont = True\n                    new_com = seed.choice(best_communities)\n                    try:\n                        com_to_numvertices[communities[vertex]] -= 1\n                        density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n                    except KeyError:\n                        pass\n                    communities[vertex] = new_com\n                    com_to_numvertices[communities[vertex]] += 1\n                    density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n        if iter_count > max_iter:\n            break\n    return iter(groups(communities).values())",
            "@not_implemented_for('directed', 'multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef asyn_fluidc(G, k, max_iter=100, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns communities in `G` as detected by Fluid Communities algorithm.\\n\\n    The asynchronous fluid communities algorithm is described in\\n    [1]_. The algorithm is based on the simple idea of fluids interacting\\n    in an environment, expanding and pushing each other. Its initialization is\\n    random, so found communities may vary on different executions.\\n\\n    The algorithm proceeds as follows. First each of the initial k communities\\n    is initialized in a random vertex in the graph. Then the algorithm iterates\\n    over all vertices in a random order, updating the community of each vertex\\n    based on its own community and the communities of its neighbours. This\\n    process is performed several times until convergence.\\n    At all times, each community has a total density of 1, which is equally\\n    distributed among the vertices it contains. If a vertex changes of\\n    community, vertex densities of affected communities are adjusted\\n    immediately. When a complete iteration over all vertices is done, such that\\n    no vertex changes the community it belongs to, the algorithm has converged\\n    and returns.\\n\\n    This is the original version of the algorithm described in [1]_.\\n    Unfortunately, it does not support weighted graphs yet.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    k : integer\\n        The number of communities to be found.\\n\\n    max_iter : integer\\n        The number of maximum iterations allowed. By default 100.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    communities : iterable\\n        Iterable of communities given as sets of nodes.\\n\\n    Notes\\n    -----\\n    k variable is not an optional argument.\\n\\n    References\\n    ----------\\n    .. [1] Par\u00e9s F., Garcia-Gasulla D. et al. \"Fluid Communities: A\\n       Competitive and Highly Scalable Community Detection Algorithm\".\\n       [https://arxiv.org/pdf/1703.09307.pdf].\\n    '\n    if not isinstance(k, int):\n        raise NetworkXError('k must be an integer.')\n    if not k > 0:\n        raise NetworkXError('k must be greater than 0.')\n    if not is_connected(G):\n        raise NetworkXError('Fluid Communities require connected Graphs.')\n    if len(G) < k:\n        raise NetworkXError('k cannot be bigger than the number of nodes.')\n    max_density = 1.0\n    vertices = list(G)\n    seed.shuffle(vertices)\n    communities = {n: i for (i, n) in enumerate(vertices[:k])}\n    density = {}\n    com_to_numvertices = {}\n    for vertex in communities:\n        com_to_numvertices[communities[vertex]] = 1\n        density[communities[vertex]] = max_density\n    iter_count = 0\n    cont = True\n    while cont:\n        cont = False\n        iter_count += 1\n        vertices = list(G)\n        seed.shuffle(vertices)\n        for vertex in vertices:\n            com_counter = Counter()\n            try:\n                com_counter.update({communities[vertex]: density[communities[vertex]]})\n            except KeyError:\n                pass\n            for v in G[vertex]:\n                try:\n                    com_counter.update({communities[v]: density[communities[v]]})\n                except KeyError:\n                    continue\n            new_com = -1\n            if len(com_counter.keys()) > 0:\n                max_freq = max(com_counter.values())\n                best_communities = [com for (com, freq) in com_counter.items() if max_freq - freq < 0.0001]\n                try:\n                    if communities[vertex] in best_communities:\n                        new_com = communities[vertex]\n                except KeyError:\n                    pass\n                if new_com == -1:\n                    cont = True\n                    new_com = seed.choice(best_communities)\n                    try:\n                        com_to_numvertices[communities[vertex]] -= 1\n                        density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n                    except KeyError:\n                        pass\n                    communities[vertex] = new_com\n                    com_to_numvertices[communities[vertex]] += 1\n                    density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n        if iter_count > max_iter:\n            break\n    return iter(groups(communities).values())",
            "@not_implemented_for('directed', 'multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef asyn_fluidc(G, k, max_iter=100, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns communities in `G` as detected by Fluid Communities algorithm.\\n\\n    The asynchronous fluid communities algorithm is described in\\n    [1]_. The algorithm is based on the simple idea of fluids interacting\\n    in an environment, expanding and pushing each other. Its initialization is\\n    random, so found communities may vary on different executions.\\n\\n    The algorithm proceeds as follows. First each of the initial k communities\\n    is initialized in a random vertex in the graph. Then the algorithm iterates\\n    over all vertices in a random order, updating the community of each vertex\\n    based on its own community and the communities of its neighbours. This\\n    process is performed several times until convergence.\\n    At all times, each community has a total density of 1, which is equally\\n    distributed among the vertices it contains. If a vertex changes of\\n    community, vertex densities of affected communities are adjusted\\n    immediately. When a complete iteration over all vertices is done, such that\\n    no vertex changes the community it belongs to, the algorithm has converged\\n    and returns.\\n\\n    This is the original version of the algorithm described in [1]_.\\n    Unfortunately, it does not support weighted graphs yet.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    k : integer\\n        The number of communities to be found.\\n\\n    max_iter : integer\\n        The number of maximum iterations allowed. By default 100.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    communities : iterable\\n        Iterable of communities given as sets of nodes.\\n\\n    Notes\\n    -----\\n    k variable is not an optional argument.\\n\\n    References\\n    ----------\\n    .. [1] Par\u00e9s F., Garcia-Gasulla D. et al. \"Fluid Communities: A\\n       Competitive and Highly Scalable Community Detection Algorithm\".\\n       [https://arxiv.org/pdf/1703.09307.pdf].\\n    '\n    if not isinstance(k, int):\n        raise NetworkXError('k must be an integer.')\n    if not k > 0:\n        raise NetworkXError('k must be greater than 0.')\n    if not is_connected(G):\n        raise NetworkXError('Fluid Communities require connected Graphs.')\n    if len(G) < k:\n        raise NetworkXError('k cannot be bigger than the number of nodes.')\n    max_density = 1.0\n    vertices = list(G)\n    seed.shuffle(vertices)\n    communities = {n: i for (i, n) in enumerate(vertices[:k])}\n    density = {}\n    com_to_numvertices = {}\n    for vertex in communities:\n        com_to_numvertices[communities[vertex]] = 1\n        density[communities[vertex]] = max_density\n    iter_count = 0\n    cont = True\n    while cont:\n        cont = False\n        iter_count += 1\n        vertices = list(G)\n        seed.shuffle(vertices)\n        for vertex in vertices:\n            com_counter = Counter()\n            try:\n                com_counter.update({communities[vertex]: density[communities[vertex]]})\n            except KeyError:\n                pass\n            for v in G[vertex]:\n                try:\n                    com_counter.update({communities[v]: density[communities[v]]})\n                except KeyError:\n                    continue\n            new_com = -1\n            if len(com_counter.keys()) > 0:\n                max_freq = max(com_counter.values())\n                best_communities = [com for (com, freq) in com_counter.items() if max_freq - freq < 0.0001]\n                try:\n                    if communities[vertex] in best_communities:\n                        new_com = communities[vertex]\n                except KeyError:\n                    pass\n                if new_com == -1:\n                    cont = True\n                    new_com = seed.choice(best_communities)\n                    try:\n                        com_to_numvertices[communities[vertex]] -= 1\n                        density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n                    except KeyError:\n                        pass\n                    communities[vertex] = new_com\n                    com_to_numvertices[communities[vertex]] += 1\n                    density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n        if iter_count > max_iter:\n            break\n    return iter(groups(communities).values())",
            "@not_implemented_for('directed', 'multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef asyn_fluidc(G, k, max_iter=100, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns communities in `G` as detected by Fluid Communities algorithm.\\n\\n    The asynchronous fluid communities algorithm is described in\\n    [1]_. The algorithm is based on the simple idea of fluids interacting\\n    in an environment, expanding and pushing each other. Its initialization is\\n    random, so found communities may vary on different executions.\\n\\n    The algorithm proceeds as follows. First each of the initial k communities\\n    is initialized in a random vertex in the graph. Then the algorithm iterates\\n    over all vertices in a random order, updating the community of each vertex\\n    based on its own community and the communities of its neighbours. This\\n    process is performed several times until convergence.\\n    At all times, each community has a total density of 1, which is equally\\n    distributed among the vertices it contains. If a vertex changes of\\n    community, vertex densities of affected communities are adjusted\\n    immediately. When a complete iteration over all vertices is done, such that\\n    no vertex changes the community it belongs to, the algorithm has converged\\n    and returns.\\n\\n    This is the original version of the algorithm described in [1]_.\\n    Unfortunately, it does not support weighted graphs yet.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Graph must be simple and undirected.\\n\\n    k : integer\\n        The number of communities to be found.\\n\\n    max_iter : integer\\n        The number of maximum iterations allowed. By default 100.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    communities : iterable\\n        Iterable of communities given as sets of nodes.\\n\\n    Notes\\n    -----\\n    k variable is not an optional argument.\\n\\n    References\\n    ----------\\n    .. [1] Par\u00e9s F., Garcia-Gasulla D. et al. \"Fluid Communities: A\\n       Competitive and Highly Scalable Community Detection Algorithm\".\\n       [https://arxiv.org/pdf/1703.09307.pdf].\\n    '\n    if not isinstance(k, int):\n        raise NetworkXError('k must be an integer.')\n    if not k > 0:\n        raise NetworkXError('k must be greater than 0.')\n    if not is_connected(G):\n        raise NetworkXError('Fluid Communities require connected Graphs.')\n    if len(G) < k:\n        raise NetworkXError('k cannot be bigger than the number of nodes.')\n    max_density = 1.0\n    vertices = list(G)\n    seed.shuffle(vertices)\n    communities = {n: i for (i, n) in enumerate(vertices[:k])}\n    density = {}\n    com_to_numvertices = {}\n    for vertex in communities:\n        com_to_numvertices[communities[vertex]] = 1\n        density[communities[vertex]] = max_density\n    iter_count = 0\n    cont = True\n    while cont:\n        cont = False\n        iter_count += 1\n        vertices = list(G)\n        seed.shuffle(vertices)\n        for vertex in vertices:\n            com_counter = Counter()\n            try:\n                com_counter.update({communities[vertex]: density[communities[vertex]]})\n            except KeyError:\n                pass\n            for v in G[vertex]:\n                try:\n                    com_counter.update({communities[v]: density[communities[v]]})\n                except KeyError:\n                    continue\n            new_com = -1\n            if len(com_counter.keys()) > 0:\n                max_freq = max(com_counter.values())\n                best_communities = [com for (com, freq) in com_counter.items() if max_freq - freq < 0.0001]\n                try:\n                    if communities[vertex] in best_communities:\n                        new_com = communities[vertex]\n                except KeyError:\n                    pass\n                if new_com == -1:\n                    cont = True\n                    new_com = seed.choice(best_communities)\n                    try:\n                        com_to_numvertices[communities[vertex]] -= 1\n                        density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n                    except KeyError:\n                        pass\n                    communities[vertex] = new_com\n                    com_to_numvertices[communities[vertex]] += 1\n                    density[communities[vertex]] = max_density / com_to_numvertices[communities[vertex]]\n        if iter_count > max_iter:\n            break\n    return iter(groups(communities).values())"
        ]
    }
]