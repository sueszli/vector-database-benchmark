[
    {
        "func_name": "time_range",
        "original": "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    ...",
        "mutated": [
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "time_range",
        "original": "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True], name: str | None=...) -> Series:\n    ...",
        "mutated": [
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "time_range",
        "original": "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool, name: str | None=...) -> Series | Expr:\n    ...",
        "mutated": [
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef time_range(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "time_range",
        "original": "def time_range(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False, name: str | None=None) -> Series | Expr:\n    \"\"\"\n    Generate a time range.\n\n    Parameters\n    ----------\n    start\n        Lower bound of the time range.\n        If omitted, defaults to `time(0,0,0,0)`.\n    end\n        Upper bound of the time range.\n        If omitted, defaults to `time(23,59,59,999999)`.\n    interval\n        Interval of the range periods, specified as a Python `timedelta` object\n        or using the Polars duration string language (see \"Notes\" section below).\n    closed : {'both', 'left', 'right', 'none'}\n        Define which sides of the range are closed (inclusive).\n    eager\n        Evaluate immediately and return a `Series`.\n        If set to `False` (default), return an expression instead.\n    name\n        Name of the output column.\n\n        .. deprecated:: 0.18.0\n            This argument is deprecated. Use the `alias` method instead.\n\n    Returns\n    -------\n    Expr or Series\n        Column of data type `:class:Time`.\n\n    Notes\n    -----\n    `interval` is created according to the following string language:\n\n    - 1ns   (1 nanosecond)\n    - 1us   (1 microsecond)\n    - 1ms   (1 millisecond)\n    - 1s    (1 second)\n    - 1m    (1 minute)\n    - 1h    (1 hour)\n    - 1d    (1 calendar day)\n    - 1w    (1 calendar week)\n    - 1mo   (1 calendar month)\n    - 1q    (1 calendar quarter)\n    - 1y    (1 calendar year)\n\n    Or combine them:\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\n\n    By \"calendar day\", we mean the corresponding time on the next day (which may\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\n\n    See Also\n    --------\n    time_ranges : Create a column of time ranges.\n\n    Examples\n    --------\n    >>> from datetime import time, timedelta\n    >>> pl.time_range(\n    ...     start=time(14, 0),\n    ...     interval=timedelta(hours=3, minutes=15),\n    ...     eager=True,\n    ... )\n    shape: (4,)\n    Series: 'time' [time]\n    [\n        14:00:00\n        17:15:00\n        20:30:00\n        23:45:00\n    ]\n\n    \"\"\"\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_range(start_pyexpr, end_pyexpr, interval, closed))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
        "mutated": [
            "def time_range(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n    '\\n    Generate a time range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0,0,0,0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23,59,59,999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `:class:Time`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_ranges : Create a column of time ranges.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time, timedelta\\n    >>> pl.time_range(\\n    ...     start=time(14, 0),\\n    ...     interval=timedelta(hours=3, minutes=15),\\n    ...     eager=True,\\n    ... )\\n    shape: (4,)\\n    Series: \\'time\\' [time]\\n    [\\n        14:00:00\\n        17:15:00\\n        20:30:00\\n        23:45:00\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_range(start_pyexpr, end_pyexpr, interval, closed))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def time_range(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate a time range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0,0,0,0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23,59,59,999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `:class:Time`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_ranges : Create a column of time ranges.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time, timedelta\\n    >>> pl.time_range(\\n    ...     start=time(14, 0),\\n    ...     interval=timedelta(hours=3, minutes=15),\\n    ...     eager=True,\\n    ... )\\n    shape: (4,)\\n    Series: \\'time\\' [time]\\n    [\\n        14:00:00\\n        17:15:00\\n        20:30:00\\n        23:45:00\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_range(start_pyexpr, end_pyexpr, interval, closed))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def time_range(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate a time range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0,0,0,0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23,59,59,999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `:class:Time`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_ranges : Create a column of time ranges.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time, timedelta\\n    >>> pl.time_range(\\n    ...     start=time(14, 0),\\n    ...     interval=timedelta(hours=3, minutes=15),\\n    ...     eager=True,\\n    ... )\\n    shape: (4,)\\n    Series: \\'time\\' [time]\\n    [\\n        14:00:00\\n        17:15:00\\n        20:30:00\\n        23:45:00\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_range(start_pyexpr, end_pyexpr, interval, closed))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def time_range(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate a time range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0,0,0,0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23,59,59,999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `:class:Time`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_ranges : Create a column of time ranges.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time, timedelta\\n    >>> pl.time_range(\\n    ...     start=time(14, 0),\\n    ...     interval=timedelta(hours=3, minutes=15),\\n    ...     eager=True,\\n    ... )\\n    shape: (4,)\\n    Series: \\'time\\' [time]\\n    [\\n        14:00:00\\n        17:15:00\\n        20:30:00\\n        23:45:00\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_range(start_pyexpr, end_pyexpr, interval, closed))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def time_range(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate a time range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0,0,0,0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23,59,59,999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `:class:Time`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_ranges : Create a column of time ranges.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time, timedelta\\n    >>> pl.time_range(\\n    ...     start=time(14, 0),\\n    ...     interval=timedelta(hours=3, minutes=15),\\n    ...     eager=True,\\n    ... )\\n    shape: (4,)\\n    Series: \\'time\\' [time]\\n    [\\n        14:00:00\\n        17:15:00\\n        20:30:00\\n        23:45:00\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_range(start_pyexpr, end_pyexpr, interval, closed))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result"
        ]
    },
    {
        "func_name": "time_ranges",
        "original": "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=...) -> Expr:\n    ...",
        "mutated": [
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "time_ranges",
        "original": "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True]) -> Series:\n    ...",
        "mutated": [
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "time_ranges",
        "original": "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool) -> Series | Expr:\n    ...",
        "mutated": [
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef time_ranges(start: time | IntoExprColumn | None=..., end: time | IntoExprColumn | None=..., interval: str | timedelta=..., *, closed: ClosedInterval=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "time_ranges",
        "original": "def time_ranges(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False) -> Series | Expr:\n    \"\"\"\n    Create a column of time ranges.\n\n    Parameters\n    ----------\n    start\n        Lower bound of the time range.\n        If omitted, defaults to `time(0, 0, 0, 0)`.\n    end\n        Upper bound of the time range.\n        If omitted, defaults to `time(23, 59, 59, 999999)`.\n    interval\n        Interval of the range periods, specified as a Python `timedelta` object\n        or using the Polars duration string language (see \"Notes\" section below).\n    closed : {'both', 'left', 'right', 'none'}\n        Define which sides of the range are closed (inclusive).\n    eager\n        Evaluate immediately and return a `Series`.\n        If set to `False` (default), return an expression instead.\n\n    Returns\n    -------\n    Expr or Series\n        Column of data type `List(Time)`.\n\n    Notes\n    -----\n    `interval` is created according to the following string language:\n\n    - 1ns   (1 nanosecond)\n    - 1us   (1 microsecond)\n    - 1ms   (1 millisecond)\n    - 1s    (1 second)\n    - 1m    (1 minute)\n    - 1h    (1 hour)\n    - 1d    (1 calendar day)\n    - 1w    (1 calendar week)\n    - 1mo   (1 calendar month)\n    - 1q    (1 calendar quarter)\n    - 1y    (1 calendar year)\n\n    Or combine them:\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\n\n    By \"calendar day\", we mean the corresponding time on the next day (which may\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\n\n    See Also\n    --------\n    time_range : Generate a single time range.\n\n    Examples\n    --------\n    >>> from datetime import time\n    >>> df = pl.DataFrame(\n    ...     {\n    ...         \"start\": [time(9, 0), time(10, 0)],\n    ...         \"end\": time(11, 0),\n    ...     }\n    ... )\n    >>> df.with_columns(pl.time_ranges(\"start\", \"end\"))\n    shape: (2, 3)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 start    \u2506 end      \u2506 time_range                     \u2502\n    \u2502 ---      \u2506 ---      \u2506 ---                            \u2502\n    \u2502 time     \u2506 time     \u2506 list[time]                     \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 09:00:00 \u2506 11:00:00 \u2506 [09:00:00, 10:00:00, 11:00:00] \u2502\n    \u2502 10:00:00 \u2506 11:00:00 \u2506 [10:00:00, 11:00:00]           \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_ranges(start_pyexpr, end_pyexpr, interval, closed))\n    if eager:\n        return F.select(result).to_series()\n    return result",
        "mutated": [
            "def time_ranges(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n    '\\n    Create a column of time ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0, 0, 0, 0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23, 59, 59, 999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Time)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_range : Generate a single time range.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [time(9, 0), time(10, 0)],\\n    ...         \"end\": time(11, 0),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.time_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start    \u2506 end      \u2506 time_range                     \u2502\\n    \u2502 ---      \u2506 ---      \u2506 ---                            \u2502\\n    \u2502 time     \u2506 time     \u2506 list[time]                     \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 09:00:00 \u2506 11:00:00 \u2506 [09:00:00, 10:00:00, 11:00:00] \u2502\\n    \u2502 10:00:00 \u2506 11:00:00 \u2506 [10:00:00, 11:00:00]           \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_ranges(start_pyexpr, end_pyexpr, interval, closed))\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def time_ranges(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create a column of time ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0, 0, 0, 0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23, 59, 59, 999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Time)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_range : Generate a single time range.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [time(9, 0), time(10, 0)],\\n    ...         \"end\": time(11, 0),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.time_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start    \u2506 end      \u2506 time_range                     \u2502\\n    \u2502 ---      \u2506 ---      \u2506 ---                            \u2502\\n    \u2502 time     \u2506 time     \u2506 list[time]                     \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 09:00:00 \u2506 11:00:00 \u2506 [09:00:00, 10:00:00, 11:00:00] \u2502\\n    \u2502 10:00:00 \u2506 11:00:00 \u2506 [10:00:00, 11:00:00]           \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_ranges(start_pyexpr, end_pyexpr, interval, closed))\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def time_ranges(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create a column of time ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0, 0, 0, 0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23, 59, 59, 999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Time)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_range : Generate a single time range.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [time(9, 0), time(10, 0)],\\n    ...         \"end\": time(11, 0),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.time_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start    \u2506 end      \u2506 time_range                     \u2502\\n    \u2502 ---      \u2506 ---      \u2506 ---                            \u2502\\n    \u2502 time     \u2506 time     \u2506 list[time]                     \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 09:00:00 \u2506 11:00:00 \u2506 [09:00:00, 10:00:00, 11:00:00] \u2502\\n    \u2502 10:00:00 \u2506 11:00:00 \u2506 [10:00:00, 11:00:00]           \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_ranges(start_pyexpr, end_pyexpr, interval, closed))\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def time_ranges(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create a column of time ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0, 0, 0, 0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23, 59, 59, 999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Time)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_range : Generate a single time range.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [time(9, 0), time(10, 0)],\\n    ...         \"end\": time(11, 0),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.time_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start    \u2506 end      \u2506 time_range                     \u2502\\n    \u2502 ---      \u2506 ---      \u2506 ---                            \u2502\\n    \u2502 time     \u2506 time     \u2506 list[time]                     \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 09:00:00 \u2506 11:00:00 \u2506 [09:00:00, 10:00:00, 11:00:00] \u2502\\n    \u2502 10:00:00 \u2506 11:00:00 \u2506 [10:00:00, 11:00:00]           \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_ranges(start_pyexpr, end_pyexpr, interval, closed))\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def time_ranges(start: time | IntoExprColumn | None=None, end: time | IntoExprColumn | None=None, interval: str | timedelta='1h', *, closed: ClosedInterval='both', eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create a column of time ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the time range.\\n        If omitted, defaults to `time(0, 0, 0, 0)`.\\n    end\\n        Upper bound of the time range.\\n        If omitted, defaults to `time(23, 59, 59, 999999)`.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Time)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    See Also\\n    --------\\n    time_range : Generate a single time range.\\n\\n    Examples\\n    --------\\n    >>> from datetime import time\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [time(9, 0), time(10, 0)],\\n    ...         \"end\": time(11, 0),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.time_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start    \u2506 end      \u2506 time_range                     \u2502\\n    \u2502 ---      \u2506 ---      \u2506 ---                            \u2502\\n    \u2502 time     \u2506 time     \u2506 list[time]                     \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 09:00:00 \u2506 11:00:00 \u2506 [09:00:00, 10:00:00, 11:00:00] \u2502\\n    \u2502 10:00:00 \u2506 11:00:00 \u2506 [10:00:00, 11:00:00]           \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    for unit in ('y', 'mo', 'w', 'd'):\n        if unit in interval:\n            raise ValueError(f'invalid interval unit for time_range: found {unit!r}')\n    if start is None:\n        start = time(0, 0, 0)\n    if end is None:\n        end = time(23, 59, 59, 999999)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.time_ranges(start_pyexpr, end_pyexpr, interval, closed))\n    if eager:\n        return F.select(result).to_series()\n    return result"
        ]
    }
]