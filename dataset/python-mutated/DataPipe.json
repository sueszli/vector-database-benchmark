[
    {
        "func_name": "__init__",
        "original": "def __init__(self, TokenCName, TokenSpaceGuidCName, Type, DatumType, SkuInfoList, DefaultValue, MaxDatumSize, UserDefinedDefaultStoresFlag, validateranges, validlists, expressions, CustomAttribute, TokenValue):\n    self.TokenCName = TokenCName\n    self.TokenSpaceGuidCName = TokenSpaceGuidCName\n    self.Type = Type\n    self.DatumType = DatumType\n    self.SkuInfoList = SkuInfoList\n    self.DefaultValue = DefaultValue\n    self.MaxDatumSize = MaxDatumSize\n    self.UserDefinedDefaultStoresFlag = UserDefinedDefaultStoresFlag\n    self.validateranges = validateranges\n    self.validlists = validlists\n    self.expressions = expressions\n    self.CustomAttribute = CustomAttribute\n    self.TokenValue = TokenValue",
        "mutated": [
            "def __init__(self, TokenCName, TokenSpaceGuidCName, Type, DatumType, SkuInfoList, DefaultValue, MaxDatumSize, UserDefinedDefaultStoresFlag, validateranges, validlists, expressions, CustomAttribute, TokenValue):\n    if False:\n        i = 10\n    self.TokenCName = TokenCName\n    self.TokenSpaceGuidCName = TokenSpaceGuidCName\n    self.Type = Type\n    self.DatumType = DatumType\n    self.SkuInfoList = SkuInfoList\n    self.DefaultValue = DefaultValue\n    self.MaxDatumSize = MaxDatumSize\n    self.UserDefinedDefaultStoresFlag = UserDefinedDefaultStoresFlag\n    self.validateranges = validateranges\n    self.validlists = validlists\n    self.expressions = expressions\n    self.CustomAttribute = CustomAttribute\n    self.TokenValue = TokenValue",
            "def __init__(self, TokenCName, TokenSpaceGuidCName, Type, DatumType, SkuInfoList, DefaultValue, MaxDatumSize, UserDefinedDefaultStoresFlag, validateranges, validlists, expressions, CustomAttribute, TokenValue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.TokenCName = TokenCName\n    self.TokenSpaceGuidCName = TokenSpaceGuidCName\n    self.Type = Type\n    self.DatumType = DatumType\n    self.SkuInfoList = SkuInfoList\n    self.DefaultValue = DefaultValue\n    self.MaxDatumSize = MaxDatumSize\n    self.UserDefinedDefaultStoresFlag = UserDefinedDefaultStoresFlag\n    self.validateranges = validateranges\n    self.validlists = validlists\n    self.expressions = expressions\n    self.CustomAttribute = CustomAttribute\n    self.TokenValue = TokenValue",
            "def __init__(self, TokenCName, TokenSpaceGuidCName, Type, DatumType, SkuInfoList, DefaultValue, MaxDatumSize, UserDefinedDefaultStoresFlag, validateranges, validlists, expressions, CustomAttribute, TokenValue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.TokenCName = TokenCName\n    self.TokenSpaceGuidCName = TokenSpaceGuidCName\n    self.Type = Type\n    self.DatumType = DatumType\n    self.SkuInfoList = SkuInfoList\n    self.DefaultValue = DefaultValue\n    self.MaxDatumSize = MaxDatumSize\n    self.UserDefinedDefaultStoresFlag = UserDefinedDefaultStoresFlag\n    self.validateranges = validateranges\n    self.validlists = validlists\n    self.expressions = expressions\n    self.CustomAttribute = CustomAttribute\n    self.TokenValue = TokenValue",
            "def __init__(self, TokenCName, TokenSpaceGuidCName, Type, DatumType, SkuInfoList, DefaultValue, MaxDatumSize, UserDefinedDefaultStoresFlag, validateranges, validlists, expressions, CustomAttribute, TokenValue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.TokenCName = TokenCName\n    self.TokenSpaceGuidCName = TokenSpaceGuidCName\n    self.Type = Type\n    self.DatumType = DatumType\n    self.SkuInfoList = SkuInfoList\n    self.DefaultValue = DefaultValue\n    self.MaxDatumSize = MaxDatumSize\n    self.UserDefinedDefaultStoresFlag = UserDefinedDefaultStoresFlag\n    self.validateranges = validateranges\n    self.validlists = validlists\n    self.expressions = expressions\n    self.CustomAttribute = CustomAttribute\n    self.TokenValue = TokenValue",
            "def __init__(self, TokenCName, TokenSpaceGuidCName, Type, DatumType, SkuInfoList, DefaultValue, MaxDatumSize, UserDefinedDefaultStoresFlag, validateranges, validlists, expressions, CustomAttribute, TokenValue):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.TokenCName = TokenCName\n    self.TokenSpaceGuidCName = TokenSpaceGuidCName\n    self.Type = Type\n    self.DatumType = DatumType\n    self.SkuInfoList = SkuInfoList\n    self.DefaultValue = DefaultValue\n    self.MaxDatumSize = MaxDatumSize\n    self.UserDefinedDefaultStoresFlag = UserDefinedDefaultStoresFlag\n    self.validateranges = validateranges\n    self.validlists = validlists\n    self.expressions = expressions\n    self.CustomAttribute = CustomAttribute\n    self.TokenValue = TokenValue"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, BuildDir=None):\n    self.data_container = {}\n    self.BuildDir = BuildDir\n    self.dump_file = ''",
        "mutated": [
            "def __init__(self, BuildDir=None):\n    if False:\n        i = 10\n    self.data_container = {}\n    self.BuildDir = BuildDir\n    self.dump_file = ''",
            "def __init__(self, BuildDir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.data_container = {}\n    self.BuildDir = BuildDir\n    self.dump_file = ''",
            "def __init__(self, BuildDir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.data_container = {}\n    self.BuildDir = BuildDir\n    self.dump_file = ''",
            "def __init__(self, BuildDir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.data_container = {}\n    self.BuildDir = BuildDir\n    self.dump_file = ''",
            "def __init__(self, BuildDir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.data_container = {}\n    self.BuildDir = BuildDir\n    self.dump_file = ''"
        ]
    },
    {
        "func_name": "Get",
        "original": "def Get(self, key):\n    return self.data_container.get(key)",
        "mutated": [
            "def Get(self, key):\n    if False:\n        i = 10\n    return self.data_container.get(key)",
            "def Get(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.data_container.get(key)",
            "def Get(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.data_container.get(key)",
            "def Get(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.data_container.get(key)",
            "def Get(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.data_container.get(key)"
        ]
    },
    {
        "func_name": "dump",
        "original": "def dump(self, file_path):\n    self.dump_file = file_path\n    with open(file_path, 'wb') as fd:\n        pickle.dump(self.data_container, fd, pickle.HIGHEST_PROTOCOL)",
        "mutated": [
            "def dump(self, file_path):\n    if False:\n        i = 10\n    self.dump_file = file_path\n    with open(file_path, 'wb') as fd:\n        pickle.dump(self.data_container, fd, pickle.HIGHEST_PROTOCOL)",
            "def dump(self, file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.dump_file = file_path\n    with open(file_path, 'wb') as fd:\n        pickle.dump(self.data_container, fd, pickle.HIGHEST_PROTOCOL)",
            "def dump(self, file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.dump_file = file_path\n    with open(file_path, 'wb') as fd:\n        pickle.dump(self.data_container, fd, pickle.HIGHEST_PROTOCOL)",
            "def dump(self, file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.dump_file = file_path\n    with open(file_path, 'wb') as fd:\n        pickle.dump(self.data_container, fd, pickle.HIGHEST_PROTOCOL)",
            "def dump(self, file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.dump_file = file_path\n    with open(file_path, 'wb') as fd:\n        pickle.dump(self.data_container, fd, pickle.HIGHEST_PROTOCOL)"
        ]
    },
    {
        "func_name": "load",
        "original": "def load(self, file_path):\n    with open(file_path, 'rb') as fd:\n        self.data_container = pickle.load(fd)",
        "mutated": [
            "def load(self, file_path):\n    if False:\n        i = 10\n    with open(file_path, 'rb') as fd:\n        self.data_container = pickle.load(fd)",
            "def load(self, file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(file_path, 'rb') as fd:\n        self.data_container = pickle.load(fd)",
            "def load(self, file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(file_path, 'rb') as fd:\n        self.data_container = pickle.load(fd)",
            "def load(self, file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(file_path, 'rb') as fd:\n        self.data_container = pickle.load(fd)",
            "def load(self, file_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(file_path, 'rb') as fd:\n        self.data_container = pickle.load(fd)"
        ]
    },
    {
        "func_name": "DataContainer",
        "original": "@property\ndef DataContainer(self):\n    return self.data_container",
        "mutated": [
            "@property\ndef DataContainer(self):\n    if False:\n        i = 10\n    return self.data_container",
            "@property\ndef DataContainer(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.data_container",
            "@property\ndef DataContainer(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.data_container",
            "@property\ndef DataContainer(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.data_container",
            "@property\ndef DataContainer(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.data_container"
        ]
    },
    {
        "func_name": "DataContainer",
        "original": "@DataContainer.setter\ndef DataContainer(self, data):\n    self.data_container.update(data)",
        "mutated": [
            "@DataContainer.setter\ndef DataContainer(self, data):\n    if False:\n        i = 10\n    self.data_container.update(data)",
            "@DataContainer.setter\ndef DataContainer(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.data_container.update(data)",
            "@DataContainer.setter\ndef DataContainer(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.data_container.update(data)",
            "@DataContainer.setter\ndef DataContainer(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.data_container.update(data)",
            "@DataContainer.setter\ndef DataContainer(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.data_container.update(data)"
        ]
    },
    {
        "func_name": "FillData",
        "original": "def FillData(self, PlatformInfo):\n    self.DataContainer = {'PLA_PCD': [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Pcds.values()]}\n    ModulePcds = {}\n    for m in PlatformInfo.Platform.Modules:\n        module = PlatformInfo.Platform.Modules[m]\n        m_pcds = module.Pcds\n        if m_pcds:\n            ModulePcds[module.Guid] = [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Modules[m].Pcds.values()]\n    self.DataContainer = {'MOL_PCDS': ModulePcds}\n    ModuleLibs = {}\n    libModules = {}\n    for m in PlatformInfo.Platform.Modules:\n        module_obj = BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain]\n        Libs = GetModuleLibInstances(module_obj, PlatformInfo.Platform, BuildDB.BuildObject, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain, PlatformInfo.MetaFile, EdkLogger)\n        for lib in Libs:\n            try:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path].append((m.File, m.Root, module_obj.Arch, m.Path))\n            except:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path] = [(m.File, m.Root, module_obj.Arch, m.Path)]\n        ModuleLibs[m.File, m.Root, module_obj.Arch, m.Path] = [(l.MetaFile.File, l.MetaFile.Root, l.Arch, l.MetaFile.Path) for l in Libs]\n    self.DataContainer = {'DEPS': ModuleLibs}\n    self.DataContainer = {'REFS': libModules}\n    platform_build_opt = PlatformInfo.EdkIIBuildOption\n    ToolDefinition = PlatformInfo.ToolDefinition\n    module_build_opt = {}\n    for m in PlatformInfo.Platform.Modules:\n        (ModuleTypeOptions, PlatformModuleOptions) = PlatformInfo.GetGlobalBuildOptions(BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain])\n        if ModuleTypeOptions or PlatformModuleOptions:\n            module_build_opt.update({(m.File, m.Root): {'ModuleTypeOptions': ModuleTypeOptions, 'PlatformModuleOptions': PlatformModuleOptions}})\n    self.DataContainer = {'PLA_BO': platform_build_opt, 'TOOLDEF': ToolDefinition, 'MOL_BO': module_build_opt}\n    PInfo = {'WorkspaceDir': PlatformInfo.Workspace.WorkspaceDir, 'Target': PlatformInfo.BuildTarget, 'ToolChain': PlatformInfo.Workspace.ToolChain, 'BuildRuleFile': PlatformInfo.BuildRule, 'Arch': PlatformInfo.Arch, 'ArchList': PlatformInfo.Workspace.ArchList, 'ActivePlatform': PlatformInfo.MetaFile}\n    self.DataContainer = {'P_Info': PInfo}\n    self.DataContainer = {'M_Name': PlatformInfo.UniqueBaseName}\n    self.DataContainer = {'ToolChainFamily': PlatformInfo.ToolChainFamily}\n    self.DataContainer = {'BuildRuleFamily': PlatformInfo.BuildRuleFamily}\n    self.DataContainer = {'MixedPcd': GlobalData.MixedPcd}\n    self.DataContainer = {'BuildOptPcd': GlobalData.BuildOptionPcd}\n    self.DataContainer = {'BuildCommand': PlatformInfo.BuildCommand}\n    self.DataContainer = {'AsBuildModuleList': PlatformInfo._AsBuildModuleList}\n    self.DataContainer = {'G_defines': GlobalData.gGlobalDefines}\n    self.DataContainer = {'CL_defines': GlobalData.gCommandLineDefines}\n    self.DataContainer = {'gCommandMaxLength': GlobalData.gCommandMaxLength}\n    self.DataContainer = {'Env_Var': {k: v for (k, v) in os.environ.items()}}\n    self.DataContainer = {'PackageList': [(dec.MetaFile, dec.Arch) for dec in PlatformInfo.PackageList]}\n    self.DataContainer = {'GuidDict': PlatformInfo.Platform._GuidDict}\n    self.DataContainer = {'DatabasePath': GlobalData.gDatabasePath}\n    self.DataContainer = {'FdfParser': True if GlobalData.gFdfParser else False}\n    self.DataContainer = {'LogLevel': EdkLogger.GetLevel()}\n    self.DataContainer = {'UseHashCache': GlobalData.gUseHashCache}\n    self.DataContainer = {'BinCacheSource': GlobalData.gBinCacheSource}\n    self.DataContainer = {'BinCacheDest': GlobalData.gBinCacheDest}\n    self.DataContainer = {'EnableGenfdsMultiThread': GlobalData.gEnableGenfdsMultiThread}\n    self.DataContainer = {'gPlatformFinalPcds': GlobalData.gPlatformFinalPcds}",
        "mutated": [
            "def FillData(self, PlatformInfo):\n    if False:\n        i = 10\n    self.DataContainer = {'PLA_PCD': [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Pcds.values()]}\n    ModulePcds = {}\n    for m in PlatformInfo.Platform.Modules:\n        module = PlatformInfo.Platform.Modules[m]\n        m_pcds = module.Pcds\n        if m_pcds:\n            ModulePcds[module.Guid] = [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Modules[m].Pcds.values()]\n    self.DataContainer = {'MOL_PCDS': ModulePcds}\n    ModuleLibs = {}\n    libModules = {}\n    for m in PlatformInfo.Platform.Modules:\n        module_obj = BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain]\n        Libs = GetModuleLibInstances(module_obj, PlatformInfo.Platform, BuildDB.BuildObject, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain, PlatformInfo.MetaFile, EdkLogger)\n        for lib in Libs:\n            try:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path].append((m.File, m.Root, module_obj.Arch, m.Path))\n            except:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path] = [(m.File, m.Root, module_obj.Arch, m.Path)]\n        ModuleLibs[m.File, m.Root, module_obj.Arch, m.Path] = [(l.MetaFile.File, l.MetaFile.Root, l.Arch, l.MetaFile.Path) for l in Libs]\n    self.DataContainer = {'DEPS': ModuleLibs}\n    self.DataContainer = {'REFS': libModules}\n    platform_build_opt = PlatformInfo.EdkIIBuildOption\n    ToolDefinition = PlatformInfo.ToolDefinition\n    module_build_opt = {}\n    for m in PlatformInfo.Platform.Modules:\n        (ModuleTypeOptions, PlatformModuleOptions) = PlatformInfo.GetGlobalBuildOptions(BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain])\n        if ModuleTypeOptions or PlatformModuleOptions:\n            module_build_opt.update({(m.File, m.Root): {'ModuleTypeOptions': ModuleTypeOptions, 'PlatformModuleOptions': PlatformModuleOptions}})\n    self.DataContainer = {'PLA_BO': platform_build_opt, 'TOOLDEF': ToolDefinition, 'MOL_BO': module_build_opt}\n    PInfo = {'WorkspaceDir': PlatformInfo.Workspace.WorkspaceDir, 'Target': PlatformInfo.BuildTarget, 'ToolChain': PlatformInfo.Workspace.ToolChain, 'BuildRuleFile': PlatformInfo.BuildRule, 'Arch': PlatformInfo.Arch, 'ArchList': PlatformInfo.Workspace.ArchList, 'ActivePlatform': PlatformInfo.MetaFile}\n    self.DataContainer = {'P_Info': PInfo}\n    self.DataContainer = {'M_Name': PlatformInfo.UniqueBaseName}\n    self.DataContainer = {'ToolChainFamily': PlatformInfo.ToolChainFamily}\n    self.DataContainer = {'BuildRuleFamily': PlatformInfo.BuildRuleFamily}\n    self.DataContainer = {'MixedPcd': GlobalData.MixedPcd}\n    self.DataContainer = {'BuildOptPcd': GlobalData.BuildOptionPcd}\n    self.DataContainer = {'BuildCommand': PlatformInfo.BuildCommand}\n    self.DataContainer = {'AsBuildModuleList': PlatformInfo._AsBuildModuleList}\n    self.DataContainer = {'G_defines': GlobalData.gGlobalDefines}\n    self.DataContainer = {'CL_defines': GlobalData.gCommandLineDefines}\n    self.DataContainer = {'gCommandMaxLength': GlobalData.gCommandMaxLength}\n    self.DataContainer = {'Env_Var': {k: v for (k, v) in os.environ.items()}}\n    self.DataContainer = {'PackageList': [(dec.MetaFile, dec.Arch) for dec in PlatformInfo.PackageList]}\n    self.DataContainer = {'GuidDict': PlatformInfo.Platform._GuidDict}\n    self.DataContainer = {'DatabasePath': GlobalData.gDatabasePath}\n    self.DataContainer = {'FdfParser': True if GlobalData.gFdfParser else False}\n    self.DataContainer = {'LogLevel': EdkLogger.GetLevel()}\n    self.DataContainer = {'UseHashCache': GlobalData.gUseHashCache}\n    self.DataContainer = {'BinCacheSource': GlobalData.gBinCacheSource}\n    self.DataContainer = {'BinCacheDest': GlobalData.gBinCacheDest}\n    self.DataContainer = {'EnableGenfdsMultiThread': GlobalData.gEnableGenfdsMultiThread}\n    self.DataContainer = {'gPlatformFinalPcds': GlobalData.gPlatformFinalPcds}",
            "def FillData(self, PlatformInfo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.DataContainer = {'PLA_PCD': [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Pcds.values()]}\n    ModulePcds = {}\n    for m in PlatformInfo.Platform.Modules:\n        module = PlatformInfo.Platform.Modules[m]\n        m_pcds = module.Pcds\n        if m_pcds:\n            ModulePcds[module.Guid] = [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Modules[m].Pcds.values()]\n    self.DataContainer = {'MOL_PCDS': ModulePcds}\n    ModuleLibs = {}\n    libModules = {}\n    for m in PlatformInfo.Platform.Modules:\n        module_obj = BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain]\n        Libs = GetModuleLibInstances(module_obj, PlatformInfo.Platform, BuildDB.BuildObject, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain, PlatformInfo.MetaFile, EdkLogger)\n        for lib in Libs:\n            try:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path].append((m.File, m.Root, module_obj.Arch, m.Path))\n            except:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path] = [(m.File, m.Root, module_obj.Arch, m.Path)]\n        ModuleLibs[m.File, m.Root, module_obj.Arch, m.Path] = [(l.MetaFile.File, l.MetaFile.Root, l.Arch, l.MetaFile.Path) for l in Libs]\n    self.DataContainer = {'DEPS': ModuleLibs}\n    self.DataContainer = {'REFS': libModules}\n    platform_build_opt = PlatformInfo.EdkIIBuildOption\n    ToolDefinition = PlatformInfo.ToolDefinition\n    module_build_opt = {}\n    for m in PlatformInfo.Platform.Modules:\n        (ModuleTypeOptions, PlatformModuleOptions) = PlatformInfo.GetGlobalBuildOptions(BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain])\n        if ModuleTypeOptions or PlatformModuleOptions:\n            module_build_opt.update({(m.File, m.Root): {'ModuleTypeOptions': ModuleTypeOptions, 'PlatformModuleOptions': PlatformModuleOptions}})\n    self.DataContainer = {'PLA_BO': platform_build_opt, 'TOOLDEF': ToolDefinition, 'MOL_BO': module_build_opt}\n    PInfo = {'WorkspaceDir': PlatformInfo.Workspace.WorkspaceDir, 'Target': PlatformInfo.BuildTarget, 'ToolChain': PlatformInfo.Workspace.ToolChain, 'BuildRuleFile': PlatformInfo.BuildRule, 'Arch': PlatformInfo.Arch, 'ArchList': PlatformInfo.Workspace.ArchList, 'ActivePlatform': PlatformInfo.MetaFile}\n    self.DataContainer = {'P_Info': PInfo}\n    self.DataContainer = {'M_Name': PlatformInfo.UniqueBaseName}\n    self.DataContainer = {'ToolChainFamily': PlatformInfo.ToolChainFamily}\n    self.DataContainer = {'BuildRuleFamily': PlatformInfo.BuildRuleFamily}\n    self.DataContainer = {'MixedPcd': GlobalData.MixedPcd}\n    self.DataContainer = {'BuildOptPcd': GlobalData.BuildOptionPcd}\n    self.DataContainer = {'BuildCommand': PlatformInfo.BuildCommand}\n    self.DataContainer = {'AsBuildModuleList': PlatformInfo._AsBuildModuleList}\n    self.DataContainer = {'G_defines': GlobalData.gGlobalDefines}\n    self.DataContainer = {'CL_defines': GlobalData.gCommandLineDefines}\n    self.DataContainer = {'gCommandMaxLength': GlobalData.gCommandMaxLength}\n    self.DataContainer = {'Env_Var': {k: v for (k, v) in os.environ.items()}}\n    self.DataContainer = {'PackageList': [(dec.MetaFile, dec.Arch) for dec in PlatformInfo.PackageList]}\n    self.DataContainer = {'GuidDict': PlatformInfo.Platform._GuidDict}\n    self.DataContainer = {'DatabasePath': GlobalData.gDatabasePath}\n    self.DataContainer = {'FdfParser': True if GlobalData.gFdfParser else False}\n    self.DataContainer = {'LogLevel': EdkLogger.GetLevel()}\n    self.DataContainer = {'UseHashCache': GlobalData.gUseHashCache}\n    self.DataContainer = {'BinCacheSource': GlobalData.gBinCacheSource}\n    self.DataContainer = {'BinCacheDest': GlobalData.gBinCacheDest}\n    self.DataContainer = {'EnableGenfdsMultiThread': GlobalData.gEnableGenfdsMultiThread}\n    self.DataContainer = {'gPlatformFinalPcds': GlobalData.gPlatformFinalPcds}",
            "def FillData(self, PlatformInfo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.DataContainer = {'PLA_PCD': [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Pcds.values()]}\n    ModulePcds = {}\n    for m in PlatformInfo.Platform.Modules:\n        module = PlatformInfo.Platform.Modules[m]\n        m_pcds = module.Pcds\n        if m_pcds:\n            ModulePcds[module.Guid] = [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Modules[m].Pcds.values()]\n    self.DataContainer = {'MOL_PCDS': ModulePcds}\n    ModuleLibs = {}\n    libModules = {}\n    for m in PlatformInfo.Platform.Modules:\n        module_obj = BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain]\n        Libs = GetModuleLibInstances(module_obj, PlatformInfo.Platform, BuildDB.BuildObject, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain, PlatformInfo.MetaFile, EdkLogger)\n        for lib in Libs:\n            try:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path].append((m.File, m.Root, module_obj.Arch, m.Path))\n            except:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path] = [(m.File, m.Root, module_obj.Arch, m.Path)]\n        ModuleLibs[m.File, m.Root, module_obj.Arch, m.Path] = [(l.MetaFile.File, l.MetaFile.Root, l.Arch, l.MetaFile.Path) for l in Libs]\n    self.DataContainer = {'DEPS': ModuleLibs}\n    self.DataContainer = {'REFS': libModules}\n    platform_build_opt = PlatformInfo.EdkIIBuildOption\n    ToolDefinition = PlatformInfo.ToolDefinition\n    module_build_opt = {}\n    for m in PlatformInfo.Platform.Modules:\n        (ModuleTypeOptions, PlatformModuleOptions) = PlatformInfo.GetGlobalBuildOptions(BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain])\n        if ModuleTypeOptions or PlatformModuleOptions:\n            module_build_opt.update({(m.File, m.Root): {'ModuleTypeOptions': ModuleTypeOptions, 'PlatformModuleOptions': PlatformModuleOptions}})\n    self.DataContainer = {'PLA_BO': platform_build_opt, 'TOOLDEF': ToolDefinition, 'MOL_BO': module_build_opt}\n    PInfo = {'WorkspaceDir': PlatformInfo.Workspace.WorkspaceDir, 'Target': PlatformInfo.BuildTarget, 'ToolChain': PlatformInfo.Workspace.ToolChain, 'BuildRuleFile': PlatformInfo.BuildRule, 'Arch': PlatformInfo.Arch, 'ArchList': PlatformInfo.Workspace.ArchList, 'ActivePlatform': PlatformInfo.MetaFile}\n    self.DataContainer = {'P_Info': PInfo}\n    self.DataContainer = {'M_Name': PlatformInfo.UniqueBaseName}\n    self.DataContainer = {'ToolChainFamily': PlatformInfo.ToolChainFamily}\n    self.DataContainer = {'BuildRuleFamily': PlatformInfo.BuildRuleFamily}\n    self.DataContainer = {'MixedPcd': GlobalData.MixedPcd}\n    self.DataContainer = {'BuildOptPcd': GlobalData.BuildOptionPcd}\n    self.DataContainer = {'BuildCommand': PlatformInfo.BuildCommand}\n    self.DataContainer = {'AsBuildModuleList': PlatformInfo._AsBuildModuleList}\n    self.DataContainer = {'G_defines': GlobalData.gGlobalDefines}\n    self.DataContainer = {'CL_defines': GlobalData.gCommandLineDefines}\n    self.DataContainer = {'gCommandMaxLength': GlobalData.gCommandMaxLength}\n    self.DataContainer = {'Env_Var': {k: v for (k, v) in os.environ.items()}}\n    self.DataContainer = {'PackageList': [(dec.MetaFile, dec.Arch) for dec in PlatformInfo.PackageList]}\n    self.DataContainer = {'GuidDict': PlatformInfo.Platform._GuidDict}\n    self.DataContainer = {'DatabasePath': GlobalData.gDatabasePath}\n    self.DataContainer = {'FdfParser': True if GlobalData.gFdfParser else False}\n    self.DataContainer = {'LogLevel': EdkLogger.GetLevel()}\n    self.DataContainer = {'UseHashCache': GlobalData.gUseHashCache}\n    self.DataContainer = {'BinCacheSource': GlobalData.gBinCacheSource}\n    self.DataContainer = {'BinCacheDest': GlobalData.gBinCacheDest}\n    self.DataContainer = {'EnableGenfdsMultiThread': GlobalData.gEnableGenfdsMultiThread}\n    self.DataContainer = {'gPlatformFinalPcds': GlobalData.gPlatformFinalPcds}",
            "def FillData(self, PlatformInfo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.DataContainer = {'PLA_PCD': [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Pcds.values()]}\n    ModulePcds = {}\n    for m in PlatformInfo.Platform.Modules:\n        module = PlatformInfo.Platform.Modules[m]\n        m_pcds = module.Pcds\n        if m_pcds:\n            ModulePcds[module.Guid] = [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Modules[m].Pcds.values()]\n    self.DataContainer = {'MOL_PCDS': ModulePcds}\n    ModuleLibs = {}\n    libModules = {}\n    for m in PlatformInfo.Platform.Modules:\n        module_obj = BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain]\n        Libs = GetModuleLibInstances(module_obj, PlatformInfo.Platform, BuildDB.BuildObject, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain, PlatformInfo.MetaFile, EdkLogger)\n        for lib in Libs:\n            try:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path].append((m.File, m.Root, module_obj.Arch, m.Path))\n            except:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path] = [(m.File, m.Root, module_obj.Arch, m.Path)]\n        ModuleLibs[m.File, m.Root, module_obj.Arch, m.Path] = [(l.MetaFile.File, l.MetaFile.Root, l.Arch, l.MetaFile.Path) for l in Libs]\n    self.DataContainer = {'DEPS': ModuleLibs}\n    self.DataContainer = {'REFS': libModules}\n    platform_build_opt = PlatformInfo.EdkIIBuildOption\n    ToolDefinition = PlatformInfo.ToolDefinition\n    module_build_opt = {}\n    for m in PlatformInfo.Platform.Modules:\n        (ModuleTypeOptions, PlatformModuleOptions) = PlatformInfo.GetGlobalBuildOptions(BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain])\n        if ModuleTypeOptions or PlatformModuleOptions:\n            module_build_opt.update({(m.File, m.Root): {'ModuleTypeOptions': ModuleTypeOptions, 'PlatformModuleOptions': PlatformModuleOptions}})\n    self.DataContainer = {'PLA_BO': platform_build_opt, 'TOOLDEF': ToolDefinition, 'MOL_BO': module_build_opt}\n    PInfo = {'WorkspaceDir': PlatformInfo.Workspace.WorkspaceDir, 'Target': PlatformInfo.BuildTarget, 'ToolChain': PlatformInfo.Workspace.ToolChain, 'BuildRuleFile': PlatformInfo.BuildRule, 'Arch': PlatformInfo.Arch, 'ArchList': PlatformInfo.Workspace.ArchList, 'ActivePlatform': PlatformInfo.MetaFile}\n    self.DataContainer = {'P_Info': PInfo}\n    self.DataContainer = {'M_Name': PlatformInfo.UniqueBaseName}\n    self.DataContainer = {'ToolChainFamily': PlatformInfo.ToolChainFamily}\n    self.DataContainer = {'BuildRuleFamily': PlatformInfo.BuildRuleFamily}\n    self.DataContainer = {'MixedPcd': GlobalData.MixedPcd}\n    self.DataContainer = {'BuildOptPcd': GlobalData.BuildOptionPcd}\n    self.DataContainer = {'BuildCommand': PlatformInfo.BuildCommand}\n    self.DataContainer = {'AsBuildModuleList': PlatformInfo._AsBuildModuleList}\n    self.DataContainer = {'G_defines': GlobalData.gGlobalDefines}\n    self.DataContainer = {'CL_defines': GlobalData.gCommandLineDefines}\n    self.DataContainer = {'gCommandMaxLength': GlobalData.gCommandMaxLength}\n    self.DataContainer = {'Env_Var': {k: v for (k, v) in os.environ.items()}}\n    self.DataContainer = {'PackageList': [(dec.MetaFile, dec.Arch) for dec in PlatformInfo.PackageList]}\n    self.DataContainer = {'GuidDict': PlatformInfo.Platform._GuidDict}\n    self.DataContainer = {'DatabasePath': GlobalData.gDatabasePath}\n    self.DataContainer = {'FdfParser': True if GlobalData.gFdfParser else False}\n    self.DataContainer = {'LogLevel': EdkLogger.GetLevel()}\n    self.DataContainer = {'UseHashCache': GlobalData.gUseHashCache}\n    self.DataContainer = {'BinCacheSource': GlobalData.gBinCacheSource}\n    self.DataContainer = {'BinCacheDest': GlobalData.gBinCacheDest}\n    self.DataContainer = {'EnableGenfdsMultiThread': GlobalData.gEnableGenfdsMultiThread}\n    self.DataContainer = {'gPlatformFinalPcds': GlobalData.gPlatformFinalPcds}",
            "def FillData(self, PlatformInfo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.DataContainer = {'PLA_PCD': [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Pcds.values()]}\n    ModulePcds = {}\n    for m in PlatformInfo.Platform.Modules:\n        module = PlatformInfo.Platform.Modules[m]\n        m_pcds = module.Pcds\n        if m_pcds:\n            ModulePcds[module.Guid] = [PCD_DATA(pcd.TokenCName, pcd.TokenSpaceGuidCName, pcd.Type, pcd.DatumType, pcd.SkuInfoList, pcd.DefaultValue, pcd.MaxDatumSize, pcd.UserDefinedDefaultStoresFlag, pcd.validateranges, pcd.validlists, pcd.expressions, pcd.CustomAttribute, pcd.TokenValue) for pcd in PlatformInfo.Platform.Modules[m].Pcds.values()]\n    self.DataContainer = {'MOL_PCDS': ModulePcds}\n    ModuleLibs = {}\n    libModules = {}\n    for m in PlatformInfo.Platform.Modules:\n        module_obj = BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain]\n        Libs = GetModuleLibInstances(module_obj, PlatformInfo.Platform, BuildDB.BuildObject, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain, PlatformInfo.MetaFile, EdkLogger)\n        for lib in Libs:\n            try:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path].append((m.File, m.Root, module_obj.Arch, m.Path))\n            except:\n                libModules[lib.MetaFile.File, lib.MetaFile.Root, lib.Arch, lib.MetaFile.Path] = [(m.File, m.Root, module_obj.Arch, m.Path)]\n        ModuleLibs[m.File, m.Root, module_obj.Arch, m.Path] = [(l.MetaFile.File, l.MetaFile.Root, l.Arch, l.MetaFile.Path) for l in Libs]\n    self.DataContainer = {'DEPS': ModuleLibs}\n    self.DataContainer = {'REFS': libModules}\n    platform_build_opt = PlatformInfo.EdkIIBuildOption\n    ToolDefinition = PlatformInfo.ToolDefinition\n    module_build_opt = {}\n    for m in PlatformInfo.Platform.Modules:\n        (ModuleTypeOptions, PlatformModuleOptions) = PlatformInfo.GetGlobalBuildOptions(BuildDB.BuildObject[m, PlatformInfo.Arch, PlatformInfo.BuildTarget, PlatformInfo.ToolChain])\n        if ModuleTypeOptions or PlatformModuleOptions:\n            module_build_opt.update({(m.File, m.Root): {'ModuleTypeOptions': ModuleTypeOptions, 'PlatformModuleOptions': PlatformModuleOptions}})\n    self.DataContainer = {'PLA_BO': platform_build_opt, 'TOOLDEF': ToolDefinition, 'MOL_BO': module_build_opt}\n    PInfo = {'WorkspaceDir': PlatformInfo.Workspace.WorkspaceDir, 'Target': PlatformInfo.BuildTarget, 'ToolChain': PlatformInfo.Workspace.ToolChain, 'BuildRuleFile': PlatformInfo.BuildRule, 'Arch': PlatformInfo.Arch, 'ArchList': PlatformInfo.Workspace.ArchList, 'ActivePlatform': PlatformInfo.MetaFile}\n    self.DataContainer = {'P_Info': PInfo}\n    self.DataContainer = {'M_Name': PlatformInfo.UniqueBaseName}\n    self.DataContainer = {'ToolChainFamily': PlatformInfo.ToolChainFamily}\n    self.DataContainer = {'BuildRuleFamily': PlatformInfo.BuildRuleFamily}\n    self.DataContainer = {'MixedPcd': GlobalData.MixedPcd}\n    self.DataContainer = {'BuildOptPcd': GlobalData.BuildOptionPcd}\n    self.DataContainer = {'BuildCommand': PlatformInfo.BuildCommand}\n    self.DataContainer = {'AsBuildModuleList': PlatformInfo._AsBuildModuleList}\n    self.DataContainer = {'G_defines': GlobalData.gGlobalDefines}\n    self.DataContainer = {'CL_defines': GlobalData.gCommandLineDefines}\n    self.DataContainer = {'gCommandMaxLength': GlobalData.gCommandMaxLength}\n    self.DataContainer = {'Env_Var': {k: v for (k, v) in os.environ.items()}}\n    self.DataContainer = {'PackageList': [(dec.MetaFile, dec.Arch) for dec in PlatformInfo.PackageList]}\n    self.DataContainer = {'GuidDict': PlatformInfo.Platform._GuidDict}\n    self.DataContainer = {'DatabasePath': GlobalData.gDatabasePath}\n    self.DataContainer = {'FdfParser': True if GlobalData.gFdfParser else False}\n    self.DataContainer = {'LogLevel': EdkLogger.GetLevel()}\n    self.DataContainer = {'UseHashCache': GlobalData.gUseHashCache}\n    self.DataContainer = {'BinCacheSource': GlobalData.gBinCacheSource}\n    self.DataContainer = {'BinCacheDest': GlobalData.gBinCacheDest}\n    self.DataContainer = {'EnableGenfdsMultiThread': GlobalData.gEnableGenfdsMultiThread}\n    self.DataContainer = {'gPlatformFinalPcds': GlobalData.gPlatformFinalPcds}"
        ]
    }
]