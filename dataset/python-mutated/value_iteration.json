[
    {
        "func_name": "_get_future_states",
        "original": "def _get_future_states(possibilities, state, reach=1.0):\n    \"\"\"Does a lookahead over chance nodes to all next states after (s,a).\n\n  Also works if there are no chance nodes (i.e. base case).\n\n  Arguments:\n    possibilities:  an empty list, that will be filled with (str(next_state),\n      transition probability) pairs for all possible next states\n    state: the state following some s.apply_action(a), can be a chance node\n    reach: chance reach probability of getting to this point from (s,a)\n  Returns: nothing.\n  \"\"\"\n    if not state.is_chance_node() or state.is_terminal():\n        possibilities.append((str(state), reach))\n    else:\n        assert state.is_chance_node()\n        for (outcome, prob) in state.chance_outcomes():\n            next_state = state.child(outcome)\n            _get_future_states(possibilities, next_state, reach * prob)",
        "mutated": [
            "def _get_future_states(possibilities, state, reach=1.0):\n    if False:\n        i = 10\n    'Does a lookahead over chance nodes to all next states after (s,a).\\n\\n  Also works if there are no chance nodes (i.e. base case).\\n\\n  Arguments:\\n    possibilities:  an empty list, that will be filled with (str(next_state),\\n      transition probability) pairs for all possible next states\\n    state: the state following some s.apply_action(a), can be a chance node\\n    reach: chance reach probability of getting to this point from (s,a)\\n  Returns: nothing.\\n  '\n    if not state.is_chance_node() or state.is_terminal():\n        possibilities.append((str(state), reach))\n    else:\n        assert state.is_chance_node()\n        for (outcome, prob) in state.chance_outcomes():\n            next_state = state.child(outcome)\n            _get_future_states(possibilities, next_state, reach * prob)",
            "def _get_future_states(possibilities, state, reach=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Does a lookahead over chance nodes to all next states after (s,a).\\n\\n  Also works if there are no chance nodes (i.e. base case).\\n\\n  Arguments:\\n    possibilities:  an empty list, that will be filled with (str(next_state),\\n      transition probability) pairs for all possible next states\\n    state: the state following some s.apply_action(a), can be a chance node\\n    reach: chance reach probability of getting to this point from (s,a)\\n  Returns: nothing.\\n  '\n    if not state.is_chance_node() or state.is_terminal():\n        possibilities.append((str(state), reach))\n    else:\n        assert state.is_chance_node()\n        for (outcome, prob) in state.chance_outcomes():\n            next_state = state.child(outcome)\n            _get_future_states(possibilities, next_state, reach * prob)",
            "def _get_future_states(possibilities, state, reach=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Does a lookahead over chance nodes to all next states after (s,a).\\n\\n  Also works if there are no chance nodes (i.e. base case).\\n\\n  Arguments:\\n    possibilities:  an empty list, that will be filled with (str(next_state),\\n      transition probability) pairs for all possible next states\\n    state: the state following some s.apply_action(a), can be a chance node\\n    reach: chance reach probability of getting to this point from (s,a)\\n  Returns: nothing.\\n  '\n    if not state.is_chance_node() or state.is_terminal():\n        possibilities.append((str(state), reach))\n    else:\n        assert state.is_chance_node()\n        for (outcome, prob) in state.chance_outcomes():\n            next_state = state.child(outcome)\n            _get_future_states(possibilities, next_state, reach * prob)",
            "def _get_future_states(possibilities, state, reach=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Does a lookahead over chance nodes to all next states after (s,a).\\n\\n  Also works if there are no chance nodes (i.e. base case).\\n\\n  Arguments:\\n    possibilities:  an empty list, that will be filled with (str(next_state),\\n      transition probability) pairs for all possible next states\\n    state: the state following some s.apply_action(a), can be a chance node\\n    reach: chance reach probability of getting to this point from (s,a)\\n  Returns: nothing.\\n  '\n    if not state.is_chance_node() or state.is_terminal():\n        possibilities.append((str(state), reach))\n    else:\n        assert state.is_chance_node()\n        for (outcome, prob) in state.chance_outcomes():\n            next_state = state.child(outcome)\n            _get_future_states(possibilities, next_state, reach * prob)",
            "def _get_future_states(possibilities, state, reach=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Does a lookahead over chance nodes to all next states after (s,a).\\n\\n  Also works if there are no chance nodes (i.e. base case).\\n\\n  Arguments:\\n    possibilities:  an empty list, that will be filled with (str(next_state),\\n      transition probability) pairs for all possible next states\\n    state: the state following some s.apply_action(a), can be a chance node\\n    reach: chance reach probability of getting to this point from (s,a)\\n  Returns: nothing.\\n  '\n    if not state.is_chance_node() or state.is_terminal():\n        possibilities.append((str(state), reach))\n    else:\n        assert state.is_chance_node()\n        for (outcome, prob) in state.chance_outcomes():\n            next_state = state.child(outcome)\n            _get_future_states(possibilities, next_state, reach * prob)"
        ]
    },
    {
        "func_name": "_add_transition",
        "original": "def _add_transition(transitions, key, state):\n    \"\"\"Adds action transitions from given state.\"\"\"\n    if state.is_simultaneous_node():\n        for p0action in state.legal_actions(0):\n            for p1action in state.legal_actions(1):\n                next_state = state.clone()\n                next_state.apply_actions([p0action, p1action])\n                possibilities = []\n                _get_future_states(possibilities, next_state)\n                transitions[key, p0action, p1action] = possibilities\n    else:\n        for action in state.legal_actions():\n            next_state = state.child(action)\n            possibilities = []\n            _get_future_states(possibilities, next_state)\n            transitions[key, action] = possibilities",
        "mutated": [
            "def _add_transition(transitions, key, state):\n    if False:\n        i = 10\n    'Adds action transitions from given state.'\n    if state.is_simultaneous_node():\n        for p0action in state.legal_actions(0):\n            for p1action in state.legal_actions(1):\n                next_state = state.clone()\n                next_state.apply_actions([p0action, p1action])\n                possibilities = []\n                _get_future_states(possibilities, next_state)\n                transitions[key, p0action, p1action] = possibilities\n    else:\n        for action in state.legal_actions():\n            next_state = state.child(action)\n            possibilities = []\n            _get_future_states(possibilities, next_state)\n            transitions[key, action] = possibilities",
            "def _add_transition(transitions, key, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Adds action transitions from given state.'\n    if state.is_simultaneous_node():\n        for p0action in state.legal_actions(0):\n            for p1action in state.legal_actions(1):\n                next_state = state.clone()\n                next_state.apply_actions([p0action, p1action])\n                possibilities = []\n                _get_future_states(possibilities, next_state)\n                transitions[key, p0action, p1action] = possibilities\n    else:\n        for action in state.legal_actions():\n            next_state = state.child(action)\n            possibilities = []\n            _get_future_states(possibilities, next_state)\n            transitions[key, action] = possibilities",
            "def _add_transition(transitions, key, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Adds action transitions from given state.'\n    if state.is_simultaneous_node():\n        for p0action in state.legal_actions(0):\n            for p1action in state.legal_actions(1):\n                next_state = state.clone()\n                next_state.apply_actions([p0action, p1action])\n                possibilities = []\n                _get_future_states(possibilities, next_state)\n                transitions[key, p0action, p1action] = possibilities\n    else:\n        for action in state.legal_actions():\n            next_state = state.child(action)\n            possibilities = []\n            _get_future_states(possibilities, next_state)\n            transitions[key, action] = possibilities",
            "def _add_transition(transitions, key, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Adds action transitions from given state.'\n    if state.is_simultaneous_node():\n        for p0action in state.legal_actions(0):\n            for p1action in state.legal_actions(1):\n                next_state = state.clone()\n                next_state.apply_actions([p0action, p1action])\n                possibilities = []\n                _get_future_states(possibilities, next_state)\n                transitions[key, p0action, p1action] = possibilities\n    else:\n        for action in state.legal_actions():\n            next_state = state.child(action)\n            possibilities = []\n            _get_future_states(possibilities, next_state)\n            transitions[key, action] = possibilities",
            "def _add_transition(transitions, key, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Adds action transitions from given state.'\n    if state.is_simultaneous_node():\n        for p0action in state.legal_actions(0):\n            for p1action in state.legal_actions(1):\n                next_state = state.clone()\n                next_state.apply_actions([p0action, p1action])\n                possibilities = []\n                _get_future_states(possibilities, next_state)\n                transitions[key, p0action, p1action] = possibilities\n    else:\n        for action in state.legal_actions():\n            next_state = state.child(action)\n            possibilities = []\n            _get_future_states(possibilities, next_state)\n            transitions[key, action] = possibilities"
        ]
    },
    {
        "func_name": "_initialize_maps",
        "original": "def _initialize_maps(states, values, transitions):\n    \"\"\"Initialize the value and transition maps.\"\"\"\n    for (key, state) in states.items():\n        if state.is_terminal():\n            values[key] = state.player_return(0)\n        else:\n            values[key] = 0\n            _add_transition(transitions, key, state)",
        "mutated": [
            "def _initialize_maps(states, values, transitions):\n    if False:\n        i = 10\n    'Initialize the value and transition maps.'\n    for (key, state) in states.items():\n        if state.is_terminal():\n            values[key] = state.player_return(0)\n        else:\n            values[key] = 0\n            _add_transition(transitions, key, state)",
            "def _initialize_maps(states, values, transitions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize the value and transition maps.'\n    for (key, state) in states.items():\n        if state.is_terminal():\n            values[key] = state.player_return(0)\n        else:\n            values[key] = 0\n            _add_transition(transitions, key, state)",
            "def _initialize_maps(states, values, transitions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize the value and transition maps.'\n    for (key, state) in states.items():\n        if state.is_terminal():\n            values[key] = state.player_return(0)\n        else:\n            values[key] = 0\n            _add_transition(transitions, key, state)",
            "def _initialize_maps(states, values, transitions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize the value and transition maps.'\n    for (key, state) in states.items():\n        if state.is_terminal():\n            values[key] = state.player_return(0)\n        else:\n            values[key] = 0\n            _add_transition(transitions, key, state)",
            "def _initialize_maps(states, values, transitions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize the value and transition maps.'\n    for (key, state) in states.items():\n        if state.is_terminal():\n            values[key] = state.player_return(0)\n        else:\n            values[key] = 0\n            _add_transition(transitions, key, state)"
        ]
    },
    {
        "func_name": "value_iteration",
        "original": "def value_iteration(game, depth_limit, threshold, cyclic_game=False):\n    \"\"\"Solves for the optimal value function of a game.\n\n  For small games only! Solves the game using value iteration,\n  with the maximum error for the value function less than threshold.\n  This algorithm works for sequential 1-player games or 2-player zero-sum\n  games, with or without chance nodes.\n\n  Arguments:\n    game: The game to analyze, as returned by `load_game`.\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\n      means root-only, etc.\n    threshold: Maximum error for state values..\n    cyclic_game: set to True if the game has cycles (from state A we can get to\n      state B, and from state B we can get back to state A).\n\n  Returns:\n    A `dict` with string keys and float values, mapping string encoding of\n    states to the values of those states.\n  \"\"\"\n    assert game.num_players() in (1, 2), 'Game must be a 1-player or 2-player game'\n    if game.num_players() == 2:\n        assert game.get_type().utility == pyspiel.GameType.Utility.ZERO_SUM, '2-player games must be zero sum games'\n    assert game.get_type().information == pyspiel.GameType.Information.ONE_SHOT or game.get_type().information == pyspiel.GameType.Information.PERFECT_INFORMATION\n    states = get_all_states.get_all_states(game, depth_limit, True, False, to_string=str, stop_if_encountered=cyclic_game)\n    values = {}\n    transitions = {}\n    _initialize_maps(states, values, transitions)\n    error = threshold + 1\n    min_utility = game.min_utility()\n    while error > threshold:\n        error = 0\n        for (key, state) in states.items():\n            if state.is_terminal():\n                continue\n            elif state.is_simultaneous_node():\n                p0_utils = []\n                p1_utils = []\n                row = 0\n                for p0action in state.legal_actions(0):\n                    p0_utils.append([])\n                    p1_utils.append([])\n                    for p1action in state.legal_actions(1):\n                        next_states = transitions[key, p0action, p1action]\n                        joint_q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                        p0_utils[row].append(joint_q_value)\n                        p1_utils[row].append(-joint_q_value)\n                    row += 1\n                stage_game = pyspiel.create_matrix_game(p0_utils, p1_utils)\n                solution = lp_solver.solve_zero_sum_matrix_game(stage_game)\n                value = solution[2]\n            else:\n                player = state.current_player()\n                value = min_utility if player == 0 else -min_utility\n                for action in state.legal_actions():\n                    next_states = transitions[key, action]\n                    q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                    if player == 0:\n                        value = max(value, q_value)\n                    else:\n                        value = min(value, q_value)\n            error = max(abs(values[key] - value), error)\n            values[key] = value\n    return values",
        "mutated": [
            "def value_iteration(game, depth_limit, threshold, cyclic_game=False):\n    if False:\n        i = 10\n    'Solves for the optimal value function of a game.\\n\\n  For small games only! Solves the game using value iteration,\\n  with the maximum error for the value function less than threshold.\\n  This algorithm works for sequential 1-player games or 2-player zero-sum\\n  games, with or without chance nodes.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    threshold: Maximum error for state values..\\n    cyclic_game: set to True if the game has cycles (from state A we can get to\\n      state B, and from state B we can get back to state A).\\n\\n  Returns:\\n    A `dict` with string keys and float values, mapping string encoding of\\n    states to the values of those states.\\n  '\n    assert game.num_players() in (1, 2), 'Game must be a 1-player or 2-player game'\n    if game.num_players() == 2:\n        assert game.get_type().utility == pyspiel.GameType.Utility.ZERO_SUM, '2-player games must be zero sum games'\n    assert game.get_type().information == pyspiel.GameType.Information.ONE_SHOT or game.get_type().information == pyspiel.GameType.Information.PERFECT_INFORMATION\n    states = get_all_states.get_all_states(game, depth_limit, True, False, to_string=str, stop_if_encountered=cyclic_game)\n    values = {}\n    transitions = {}\n    _initialize_maps(states, values, transitions)\n    error = threshold + 1\n    min_utility = game.min_utility()\n    while error > threshold:\n        error = 0\n        for (key, state) in states.items():\n            if state.is_terminal():\n                continue\n            elif state.is_simultaneous_node():\n                p0_utils = []\n                p1_utils = []\n                row = 0\n                for p0action in state.legal_actions(0):\n                    p0_utils.append([])\n                    p1_utils.append([])\n                    for p1action in state.legal_actions(1):\n                        next_states = transitions[key, p0action, p1action]\n                        joint_q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                        p0_utils[row].append(joint_q_value)\n                        p1_utils[row].append(-joint_q_value)\n                    row += 1\n                stage_game = pyspiel.create_matrix_game(p0_utils, p1_utils)\n                solution = lp_solver.solve_zero_sum_matrix_game(stage_game)\n                value = solution[2]\n            else:\n                player = state.current_player()\n                value = min_utility if player == 0 else -min_utility\n                for action in state.legal_actions():\n                    next_states = transitions[key, action]\n                    q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                    if player == 0:\n                        value = max(value, q_value)\n                    else:\n                        value = min(value, q_value)\n            error = max(abs(values[key] - value), error)\n            values[key] = value\n    return values",
            "def value_iteration(game, depth_limit, threshold, cyclic_game=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Solves for the optimal value function of a game.\\n\\n  For small games only! Solves the game using value iteration,\\n  with the maximum error for the value function less than threshold.\\n  This algorithm works for sequential 1-player games or 2-player zero-sum\\n  games, with or without chance nodes.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    threshold: Maximum error for state values..\\n    cyclic_game: set to True if the game has cycles (from state A we can get to\\n      state B, and from state B we can get back to state A).\\n\\n  Returns:\\n    A `dict` with string keys and float values, mapping string encoding of\\n    states to the values of those states.\\n  '\n    assert game.num_players() in (1, 2), 'Game must be a 1-player or 2-player game'\n    if game.num_players() == 2:\n        assert game.get_type().utility == pyspiel.GameType.Utility.ZERO_SUM, '2-player games must be zero sum games'\n    assert game.get_type().information == pyspiel.GameType.Information.ONE_SHOT or game.get_type().information == pyspiel.GameType.Information.PERFECT_INFORMATION\n    states = get_all_states.get_all_states(game, depth_limit, True, False, to_string=str, stop_if_encountered=cyclic_game)\n    values = {}\n    transitions = {}\n    _initialize_maps(states, values, transitions)\n    error = threshold + 1\n    min_utility = game.min_utility()\n    while error > threshold:\n        error = 0\n        for (key, state) in states.items():\n            if state.is_terminal():\n                continue\n            elif state.is_simultaneous_node():\n                p0_utils = []\n                p1_utils = []\n                row = 0\n                for p0action in state.legal_actions(0):\n                    p0_utils.append([])\n                    p1_utils.append([])\n                    for p1action in state.legal_actions(1):\n                        next_states = transitions[key, p0action, p1action]\n                        joint_q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                        p0_utils[row].append(joint_q_value)\n                        p1_utils[row].append(-joint_q_value)\n                    row += 1\n                stage_game = pyspiel.create_matrix_game(p0_utils, p1_utils)\n                solution = lp_solver.solve_zero_sum_matrix_game(stage_game)\n                value = solution[2]\n            else:\n                player = state.current_player()\n                value = min_utility if player == 0 else -min_utility\n                for action in state.legal_actions():\n                    next_states = transitions[key, action]\n                    q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                    if player == 0:\n                        value = max(value, q_value)\n                    else:\n                        value = min(value, q_value)\n            error = max(abs(values[key] - value), error)\n            values[key] = value\n    return values",
            "def value_iteration(game, depth_limit, threshold, cyclic_game=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Solves for the optimal value function of a game.\\n\\n  For small games only! Solves the game using value iteration,\\n  with the maximum error for the value function less than threshold.\\n  This algorithm works for sequential 1-player games or 2-player zero-sum\\n  games, with or without chance nodes.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    threshold: Maximum error for state values..\\n    cyclic_game: set to True if the game has cycles (from state A we can get to\\n      state B, and from state B we can get back to state A).\\n\\n  Returns:\\n    A `dict` with string keys and float values, mapping string encoding of\\n    states to the values of those states.\\n  '\n    assert game.num_players() in (1, 2), 'Game must be a 1-player or 2-player game'\n    if game.num_players() == 2:\n        assert game.get_type().utility == pyspiel.GameType.Utility.ZERO_SUM, '2-player games must be zero sum games'\n    assert game.get_type().information == pyspiel.GameType.Information.ONE_SHOT or game.get_type().information == pyspiel.GameType.Information.PERFECT_INFORMATION\n    states = get_all_states.get_all_states(game, depth_limit, True, False, to_string=str, stop_if_encountered=cyclic_game)\n    values = {}\n    transitions = {}\n    _initialize_maps(states, values, transitions)\n    error = threshold + 1\n    min_utility = game.min_utility()\n    while error > threshold:\n        error = 0\n        for (key, state) in states.items():\n            if state.is_terminal():\n                continue\n            elif state.is_simultaneous_node():\n                p0_utils = []\n                p1_utils = []\n                row = 0\n                for p0action in state.legal_actions(0):\n                    p0_utils.append([])\n                    p1_utils.append([])\n                    for p1action in state.legal_actions(1):\n                        next_states = transitions[key, p0action, p1action]\n                        joint_q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                        p0_utils[row].append(joint_q_value)\n                        p1_utils[row].append(-joint_q_value)\n                    row += 1\n                stage_game = pyspiel.create_matrix_game(p0_utils, p1_utils)\n                solution = lp_solver.solve_zero_sum_matrix_game(stage_game)\n                value = solution[2]\n            else:\n                player = state.current_player()\n                value = min_utility if player == 0 else -min_utility\n                for action in state.legal_actions():\n                    next_states = transitions[key, action]\n                    q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                    if player == 0:\n                        value = max(value, q_value)\n                    else:\n                        value = min(value, q_value)\n            error = max(abs(values[key] - value), error)\n            values[key] = value\n    return values",
            "def value_iteration(game, depth_limit, threshold, cyclic_game=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Solves for the optimal value function of a game.\\n\\n  For small games only! Solves the game using value iteration,\\n  with the maximum error for the value function less than threshold.\\n  This algorithm works for sequential 1-player games or 2-player zero-sum\\n  games, with or without chance nodes.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    threshold: Maximum error for state values..\\n    cyclic_game: set to True if the game has cycles (from state A we can get to\\n      state B, and from state B we can get back to state A).\\n\\n  Returns:\\n    A `dict` with string keys and float values, mapping string encoding of\\n    states to the values of those states.\\n  '\n    assert game.num_players() in (1, 2), 'Game must be a 1-player or 2-player game'\n    if game.num_players() == 2:\n        assert game.get_type().utility == pyspiel.GameType.Utility.ZERO_SUM, '2-player games must be zero sum games'\n    assert game.get_type().information == pyspiel.GameType.Information.ONE_SHOT or game.get_type().information == pyspiel.GameType.Information.PERFECT_INFORMATION\n    states = get_all_states.get_all_states(game, depth_limit, True, False, to_string=str, stop_if_encountered=cyclic_game)\n    values = {}\n    transitions = {}\n    _initialize_maps(states, values, transitions)\n    error = threshold + 1\n    min_utility = game.min_utility()\n    while error > threshold:\n        error = 0\n        for (key, state) in states.items():\n            if state.is_terminal():\n                continue\n            elif state.is_simultaneous_node():\n                p0_utils = []\n                p1_utils = []\n                row = 0\n                for p0action in state.legal_actions(0):\n                    p0_utils.append([])\n                    p1_utils.append([])\n                    for p1action in state.legal_actions(1):\n                        next_states = transitions[key, p0action, p1action]\n                        joint_q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                        p0_utils[row].append(joint_q_value)\n                        p1_utils[row].append(-joint_q_value)\n                    row += 1\n                stage_game = pyspiel.create_matrix_game(p0_utils, p1_utils)\n                solution = lp_solver.solve_zero_sum_matrix_game(stage_game)\n                value = solution[2]\n            else:\n                player = state.current_player()\n                value = min_utility if player == 0 else -min_utility\n                for action in state.legal_actions():\n                    next_states = transitions[key, action]\n                    q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                    if player == 0:\n                        value = max(value, q_value)\n                    else:\n                        value = min(value, q_value)\n            error = max(abs(values[key] - value), error)\n            values[key] = value\n    return values",
            "def value_iteration(game, depth_limit, threshold, cyclic_game=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Solves for the optimal value function of a game.\\n\\n  For small games only! Solves the game using value iteration,\\n  with the maximum error for the value function less than threshold.\\n  This algorithm works for sequential 1-player games or 2-player zero-sum\\n  games, with or without chance nodes.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    threshold: Maximum error for state values..\\n    cyclic_game: set to True if the game has cycles (from state A we can get to\\n      state B, and from state B we can get back to state A).\\n\\n  Returns:\\n    A `dict` with string keys and float values, mapping string encoding of\\n    states to the values of those states.\\n  '\n    assert game.num_players() in (1, 2), 'Game must be a 1-player or 2-player game'\n    if game.num_players() == 2:\n        assert game.get_type().utility == pyspiel.GameType.Utility.ZERO_SUM, '2-player games must be zero sum games'\n    assert game.get_type().information == pyspiel.GameType.Information.ONE_SHOT or game.get_type().information == pyspiel.GameType.Information.PERFECT_INFORMATION\n    states = get_all_states.get_all_states(game, depth_limit, True, False, to_string=str, stop_if_encountered=cyclic_game)\n    values = {}\n    transitions = {}\n    _initialize_maps(states, values, transitions)\n    error = threshold + 1\n    min_utility = game.min_utility()\n    while error > threshold:\n        error = 0\n        for (key, state) in states.items():\n            if state.is_terminal():\n                continue\n            elif state.is_simultaneous_node():\n                p0_utils = []\n                p1_utils = []\n                row = 0\n                for p0action in state.legal_actions(0):\n                    p0_utils.append([])\n                    p1_utils.append([])\n                    for p1action in state.legal_actions(1):\n                        next_states = transitions[key, p0action, p1action]\n                        joint_q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                        p0_utils[row].append(joint_q_value)\n                        p1_utils[row].append(-joint_q_value)\n                    row += 1\n                stage_game = pyspiel.create_matrix_game(p0_utils, p1_utils)\n                solution = lp_solver.solve_zero_sum_matrix_game(stage_game)\n                value = solution[2]\n            else:\n                player = state.current_player()\n                value = min_utility if player == 0 else -min_utility\n                for action in state.legal_actions():\n                    next_states = transitions[key, action]\n                    q_value = sum((p * values[next_state] for (next_state, p) in next_states))\n                    if player == 0:\n                        value = max(value, q_value)\n                    else:\n                        value = min(value, q_value)\n            error = max(abs(values[key] - value), error)\n            values[key] = value\n    return values"
        ]
    }
]