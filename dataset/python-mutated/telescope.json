[
    {
        "func_name": "collapse_repeating_values",
        "original": "def collapse_repeating_values() -> None:\n    if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n        result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n    else:\n        result.extend(collapse_buffer)\n    collapse_buffer.clear()",
        "mutated": [
            "def collapse_repeating_values() -> None:\n    if False:\n        i = 10\n    if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n        result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n    else:\n        result.extend(collapse_buffer)\n    collapse_buffer.clear()",
            "def collapse_repeating_values() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n        result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n    else:\n        result.extend(collapse_buffer)\n    collapse_buffer.clear()",
            "def collapse_repeating_values() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n        result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n    else:\n        result.extend(collapse_buffer)\n    collapse_buffer.clear()",
            "def collapse_repeating_values() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n        result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n    else:\n        result.extend(collapse_buffer)\n    collapse_buffer.clear()",
            "def collapse_repeating_values() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n        result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n    else:\n        result.extend(collapse_buffer)\n    collapse_buffer.clear()"
        ]
    },
    {
        "func_name": "telescope",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef telescope(address=None, count=telescope_lines, to_string=False, reverse=False, frame=False):\n    \"\"\"\n    Recursively dereferences pointers starting at the specified address\n    ($sp by default)\n    \"\"\"\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    if telescope.repeat:\n        address = telescope.last_address + ptrsize\n        telescope.offset += 1\n    else:\n        telescope.offset = 0\n    address = int(address if address else pwndbg.gdblib.regs.sp) & pwndbg.gdblib.arch.ptrmask\n    input_address = address\n    count = max(int(count), 1) & pwndbg.gdblib.arch.ptrmask\n    delimiter = T.delimiter(offset_delimiter)\n    separator = T.separator(offset_separator)\n    if address < pwndbg.gdblib.memory.MMAP_MIN_ADDR and (not pwndbg.gdblib.memory.peek(address)):\n        count = address\n        address = pwndbg.gdblib.regs.sp\n    if reverse:\n        address -= (count - 1) * ptrsize\n    if frame:\n        sp = pwndbg.gdblib.regs.sp\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n        if sp > bp:\n            print('Cannot display stack frame because base pointer is below stack pointer')\n            return\n        for page in pwndbg.gdblib.vmmap.get():\n            if sp in page and bp not in page:\n                print('Cannot display stack frame because base pointer is not on the same page with stack pointer')\n                return\n        address = sp\n        count = int((bp - sp) / ptrsize) + 1\n    if int(address) <= int(count):\n        count -= address\n        count = max(math.ceil(count / ptrsize), 1)\n    reg_values: DefaultDict[int, list[str]] = collections.defaultdict(lambda : [])\n    for reg in pwndbg.gdblib.regs.common:\n        reg_values[pwndbg.gdblib.regs[reg]].append(reg)\n    start = address\n    stop = address + count * ptrsize\n    step = ptrsize\n    regs: dict[int, str] = {}\n    for i in range(start, stop, step):\n        values = list(reg_values[i])\n        for width in range(1, pwndbg.gdblib.arch.ptrsize):\n            values.extend(('%s-%i' % (r, width) for r in reg_values[i + width]))\n        regs[i] = ' '.join(values)\n    if regs:\n        longest_regs = max(map(len, regs.values()))\n    else:\n        longest_regs = 0\n    result = []\n    last = None\n    collapse_buffer: list[str] = []\n    skipped_padding = 2 + len(offset_delimiter) + 4 + len(offset_separator) + 1 + longest_regs + 1 - len(repeating_marker)\n\n    def collapse_repeating_values() -> None:\n        if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n            result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n        else:\n            result.extend(collapse_buffer)\n        collapse_buffer.clear()\n    bp = None\n    if print_framepointer_offset:\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    for (i, addr) in enumerate(range(start, stop, step)):\n        if not pwndbg.gdblib.memory.peek(addr):\n            collapse_repeating_values()\n            result.append('<Could not read memory at %#x>' % addr)\n            break\n        line = T.offset('%02x%s%04x%s' % (i + telescope.offset, delimiter, addr - start + telescope.offset * ptrsize, separator)) + ' '.join((regs_or_frame_offset(addr, bp, regs, longest_regs), pwndbg.chain.format(addr)))\n        if skip_repeating_values:\n            value = pwndbg.gdblib.memory.pvoid(addr)\n            if last == value and addr != input_address:\n                collapse_buffer.append(line)\n                continue\n            collapse_repeating_values()\n            last = value\n        result.append(line)\n    collapse_repeating_values()\n    telescope.offset += i\n    telescope.last_address = addr\n    if not to_string:\n        print('\\n'.join(result))\n    return result",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef telescope(address=None, count=telescope_lines, to_string=False, reverse=False, frame=False):\n    if False:\n        i = 10\n    '\\n    Recursively dereferences pointers starting at the specified address\\n    ($sp by default)\\n    '\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    if telescope.repeat:\n        address = telescope.last_address + ptrsize\n        telescope.offset += 1\n    else:\n        telescope.offset = 0\n    address = int(address if address else pwndbg.gdblib.regs.sp) & pwndbg.gdblib.arch.ptrmask\n    input_address = address\n    count = max(int(count), 1) & pwndbg.gdblib.arch.ptrmask\n    delimiter = T.delimiter(offset_delimiter)\n    separator = T.separator(offset_separator)\n    if address < pwndbg.gdblib.memory.MMAP_MIN_ADDR and (not pwndbg.gdblib.memory.peek(address)):\n        count = address\n        address = pwndbg.gdblib.regs.sp\n    if reverse:\n        address -= (count - 1) * ptrsize\n    if frame:\n        sp = pwndbg.gdblib.regs.sp\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n        if sp > bp:\n            print('Cannot display stack frame because base pointer is below stack pointer')\n            return\n        for page in pwndbg.gdblib.vmmap.get():\n            if sp in page and bp not in page:\n                print('Cannot display stack frame because base pointer is not on the same page with stack pointer')\n                return\n        address = sp\n        count = int((bp - sp) / ptrsize) + 1\n    if int(address) <= int(count):\n        count -= address\n        count = max(math.ceil(count / ptrsize), 1)\n    reg_values: DefaultDict[int, list[str]] = collections.defaultdict(lambda : [])\n    for reg in pwndbg.gdblib.regs.common:\n        reg_values[pwndbg.gdblib.regs[reg]].append(reg)\n    start = address\n    stop = address + count * ptrsize\n    step = ptrsize\n    regs: dict[int, str] = {}\n    for i in range(start, stop, step):\n        values = list(reg_values[i])\n        for width in range(1, pwndbg.gdblib.arch.ptrsize):\n            values.extend(('%s-%i' % (r, width) for r in reg_values[i + width]))\n        regs[i] = ' '.join(values)\n    if regs:\n        longest_regs = max(map(len, regs.values()))\n    else:\n        longest_regs = 0\n    result = []\n    last = None\n    collapse_buffer: list[str] = []\n    skipped_padding = 2 + len(offset_delimiter) + 4 + len(offset_separator) + 1 + longest_regs + 1 - len(repeating_marker)\n\n    def collapse_repeating_values() -> None:\n        if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n            result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n        else:\n            result.extend(collapse_buffer)\n        collapse_buffer.clear()\n    bp = None\n    if print_framepointer_offset:\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    for (i, addr) in enumerate(range(start, stop, step)):\n        if not pwndbg.gdblib.memory.peek(addr):\n            collapse_repeating_values()\n            result.append('<Could not read memory at %#x>' % addr)\n            break\n        line = T.offset('%02x%s%04x%s' % (i + telescope.offset, delimiter, addr - start + telescope.offset * ptrsize, separator)) + ' '.join((regs_or_frame_offset(addr, bp, regs, longest_regs), pwndbg.chain.format(addr)))\n        if skip_repeating_values:\n            value = pwndbg.gdblib.memory.pvoid(addr)\n            if last == value and addr != input_address:\n                collapse_buffer.append(line)\n                continue\n            collapse_repeating_values()\n            last = value\n        result.append(line)\n    collapse_repeating_values()\n    telescope.offset += i\n    telescope.last_address = addr\n    if not to_string:\n        print('\\n'.join(result))\n    return result",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef telescope(address=None, count=telescope_lines, to_string=False, reverse=False, frame=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Recursively dereferences pointers starting at the specified address\\n    ($sp by default)\\n    '\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    if telescope.repeat:\n        address = telescope.last_address + ptrsize\n        telescope.offset += 1\n    else:\n        telescope.offset = 0\n    address = int(address if address else pwndbg.gdblib.regs.sp) & pwndbg.gdblib.arch.ptrmask\n    input_address = address\n    count = max(int(count), 1) & pwndbg.gdblib.arch.ptrmask\n    delimiter = T.delimiter(offset_delimiter)\n    separator = T.separator(offset_separator)\n    if address < pwndbg.gdblib.memory.MMAP_MIN_ADDR and (not pwndbg.gdblib.memory.peek(address)):\n        count = address\n        address = pwndbg.gdblib.regs.sp\n    if reverse:\n        address -= (count - 1) * ptrsize\n    if frame:\n        sp = pwndbg.gdblib.regs.sp\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n        if sp > bp:\n            print('Cannot display stack frame because base pointer is below stack pointer')\n            return\n        for page in pwndbg.gdblib.vmmap.get():\n            if sp in page and bp not in page:\n                print('Cannot display stack frame because base pointer is not on the same page with stack pointer')\n                return\n        address = sp\n        count = int((bp - sp) / ptrsize) + 1\n    if int(address) <= int(count):\n        count -= address\n        count = max(math.ceil(count / ptrsize), 1)\n    reg_values: DefaultDict[int, list[str]] = collections.defaultdict(lambda : [])\n    for reg in pwndbg.gdblib.regs.common:\n        reg_values[pwndbg.gdblib.regs[reg]].append(reg)\n    start = address\n    stop = address + count * ptrsize\n    step = ptrsize\n    regs: dict[int, str] = {}\n    for i in range(start, stop, step):\n        values = list(reg_values[i])\n        for width in range(1, pwndbg.gdblib.arch.ptrsize):\n            values.extend(('%s-%i' % (r, width) for r in reg_values[i + width]))\n        regs[i] = ' '.join(values)\n    if regs:\n        longest_regs = max(map(len, regs.values()))\n    else:\n        longest_regs = 0\n    result = []\n    last = None\n    collapse_buffer: list[str] = []\n    skipped_padding = 2 + len(offset_delimiter) + 4 + len(offset_separator) + 1 + longest_regs + 1 - len(repeating_marker)\n\n    def collapse_repeating_values() -> None:\n        if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n            result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n        else:\n            result.extend(collapse_buffer)\n        collapse_buffer.clear()\n    bp = None\n    if print_framepointer_offset:\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    for (i, addr) in enumerate(range(start, stop, step)):\n        if not pwndbg.gdblib.memory.peek(addr):\n            collapse_repeating_values()\n            result.append('<Could not read memory at %#x>' % addr)\n            break\n        line = T.offset('%02x%s%04x%s' % (i + telescope.offset, delimiter, addr - start + telescope.offset * ptrsize, separator)) + ' '.join((regs_or_frame_offset(addr, bp, regs, longest_regs), pwndbg.chain.format(addr)))\n        if skip_repeating_values:\n            value = pwndbg.gdblib.memory.pvoid(addr)\n            if last == value and addr != input_address:\n                collapse_buffer.append(line)\n                continue\n            collapse_repeating_values()\n            last = value\n        result.append(line)\n    collapse_repeating_values()\n    telescope.offset += i\n    telescope.last_address = addr\n    if not to_string:\n        print('\\n'.join(result))\n    return result",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef telescope(address=None, count=telescope_lines, to_string=False, reverse=False, frame=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Recursively dereferences pointers starting at the specified address\\n    ($sp by default)\\n    '\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    if telescope.repeat:\n        address = telescope.last_address + ptrsize\n        telescope.offset += 1\n    else:\n        telescope.offset = 0\n    address = int(address if address else pwndbg.gdblib.regs.sp) & pwndbg.gdblib.arch.ptrmask\n    input_address = address\n    count = max(int(count), 1) & pwndbg.gdblib.arch.ptrmask\n    delimiter = T.delimiter(offset_delimiter)\n    separator = T.separator(offset_separator)\n    if address < pwndbg.gdblib.memory.MMAP_MIN_ADDR and (not pwndbg.gdblib.memory.peek(address)):\n        count = address\n        address = pwndbg.gdblib.regs.sp\n    if reverse:\n        address -= (count - 1) * ptrsize\n    if frame:\n        sp = pwndbg.gdblib.regs.sp\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n        if sp > bp:\n            print('Cannot display stack frame because base pointer is below stack pointer')\n            return\n        for page in pwndbg.gdblib.vmmap.get():\n            if sp in page and bp not in page:\n                print('Cannot display stack frame because base pointer is not on the same page with stack pointer')\n                return\n        address = sp\n        count = int((bp - sp) / ptrsize) + 1\n    if int(address) <= int(count):\n        count -= address\n        count = max(math.ceil(count / ptrsize), 1)\n    reg_values: DefaultDict[int, list[str]] = collections.defaultdict(lambda : [])\n    for reg in pwndbg.gdblib.regs.common:\n        reg_values[pwndbg.gdblib.regs[reg]].append(reg)\n    start = address\n    stop = address + count * ptrsize\n    step = ptrsize\n    regs: dict[int, str] = {}\n    for i in range(start, stop, step):\n        values = list(reg_values[i])\n        for width in range(1, pwndbg.gdblib.arch.ptrsize):\n            values.extend(('%s-%i' % (r, width) for r in reg_values[i + width]))\n        regs[i] = ' '.join(values)\n    if regs:\n        longest_regs = max(map(len, regs.values()))\n    else:\n        longest_regs = 0\n    result = []\n    last = None\n    collapse_buffer: list[str] = []\n    skipped_padding = 2 + len(offset_delimiter) + 4 + len(offset_separator) + 1 + longest_regs + 1 - len(repeating_marker)\n\n    def collapse_repeating_values() -> None:\n        if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n            result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n        else:\n            result.extend(collapse_buffer)\n        collapse_buffer.clear()\n    bp = None\n    if print_framepointer_offset:\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    for (i, addr) in enumerate(range(start, stop, step)):\n        if not pwndbg.gdblib.memory.peek(addr):\n            collapse_repeating_values()\n            result.append('<Could not read memory at %#x>' % addr)\n            break\n        line = T.offset('%02x%s%04x%s' % (i + telescope.offset, delimiter, addr - start + telescope.offset * ptrsize, separator)) + ' '.join((regs_or_frame_offset(addr, bp, regs, longest_regs), pwndbg.chain.format(addr)))\n        if skip_repeating_values:\n            value = pwndbg.gdblib.memory.pvoid(addr)\n            if last == value and addr != input_address:\n                collapse_buffer.append(line)\n                continue\n            collapse_repeating_values()\n            last = value\n        result.append(line)\n    collapse_repeating_values()\n    telescope.offset += i\n    telescope.last_address = addr\n    if not to_string:\n        print('\\n'.join(result))\n    return result",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef telescope(address=None, count=telescope_lines, to_string=False, reverse=False, frame=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Recursively dereferences pointers starting at the specified address\\n    ($sp by default)\\n    '\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    if telescope.repeat:\n        address = telescope.last_address + ptrsize\n        telescope.offset += 1\n    else:\n        telescope.offset = 0\n    address = int(address if address else pwndbg.gdblib.regs.sp) & pwndbg.gdblib.arch.ptrmask\n    input_address = address\n    count = max(int(count), 1) & pwndbg.gdblib.arch.ptrmask\n    delimiter = T.delimiter(offset_delimiter)\n    separator = T.separator(offset_separator)\n    if address < pwndbg.gdblib.memory.MMAP_MIN_ADDR and (not pwndbg.gdblib.memory.peek(address)):\n        count = address\n        address = pwndbg.gdblib.regs.sp\n    if reverse:\n        address -= (count - 1) * ptrsize\n    if frame:\n        sp = pwndbg.gdblib.regs.sp\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n        if sp > bp:\n            print('Cannot display stack frame because base pointer is below stack pointer')\n            return\n        for page in pwndbg.gdblib.vmmap.get():\n            if sp in page and bp not in page:\n                print('Cannot display stack frame because base pointer is not on the same page with stack pointer')\n                return\n        address = sp\n        count = int((bp - sp) / ptrsize) + 1\n    if int(address) <= int(count):\n        count -= address\n        count = max(math.ceil(count / ptrsize), 1)\n    reg_values: DefaultDict[int, list[str]] = collections.defaultdict(lambda : [])\n    for reg in pwndbg.gdblib.regs.common:\n        reg_values[pwndbg.gdblib.regs[reg]].append(reg)\n    start = address\n    stop = address + count * ptrsize\n    step = ptrsize\n    regs: dict[int, str] = {}\n    for i in range(start, stop, step):\n        values = list(reg_values[i])\n        for width in range(1, pwndbg.gdblib.arch.ptrsize):\n            values.extend(('%s-%i' % (r, width) for r in reg_values[i + width]))\n        regs[i] = ' '.join(values)\n    if regs:\n        longest_regs = max(map(len, regs.values()))\n    else:\n        longest_regs = 0\n    result = []\n    last = None\n    collapse_buffer: list[str] = []\n    skipped_padding = 2 + len(offset_delimiter) + 4 + len(offset_separator) + 1 + longest_regs + 1 - len(repeating_marker)\n\n    def collapse_repeating_values() -> None:\n        if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n            result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n        else:\n            result.extend(collapse_buffer)\n        collapse_buffer.clear()\n    bp = None\n    if print_framepointer_offset:\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    for (i, addr) in enumerate(range(start, stop, step)):\n        if not pwndbg.gdblib.memory.peek(addr):\n            collapse_repeating_values()\n            result.append('<Could not read memory at %#x>' % addr)\n            break\n        line = T.offset('%02x%s%04x%s' % (i + telescope.offset, delimiter, addr - start + telescope.offset * ptrsize, separator)) + ' '.join((regs_or_frame_offset(addr, bp, regs, longest_regs), pwndbg.chain.format(addr)))\n        if skip_repeating_values:\n            value = pwndbg.gdblib.memory.pvoid(addr)\n            if last == value and addr != input_address:\n                collapse_buffer.append(line)\n                continue\n            collapse_repeating_values()\n            last = value\n        result.append(line)\n    collapse_repeating_values()\n    telescope.offset += i\n    telescope.last_address = addr\n    if not to_string:\n        print('\\n'.join(result))\n    return result",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef telescope(address=None, count=telescope_lines, to_string=False, reverse=False, frame=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Recursively dereferences pointers starting at the specified address\\n    ($sp by default)\\n    '\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    if telescope.repeat:\n        address = telescope.last_address + ptrsize\n        telescope.offset += 1\n    else:\n        telescope.offset = 0\n    address = int(address if address else pwndbg.gdblib.regs.sp) & pwndbg.gdblib.arch.ptrmask\n    input_address = address\n    count = max(int(count), 1) & pwndbg.gdblib.arch.ptrmask\n    delimiter = T.delimiter(offset_delimiter)\n    separator = T.separator(offset_separator)\n    if address < pwndbg.gdblib.memory.MMAP_MIN_ADDR and (not pwndbg.gdblib.memory.peek(address)):\n        count = address\n        address = pwndbg.gdblib.regs.sp\n    if reverse:\n        address -= (count - 1) * ptrsize\n    if frame:\n        sp = pwndbg.gdblib.regs.sp\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n        if sp > bp:\n            print('Cannot display stack frame because base pointer is below stack pointer')\n            return\n        for page in pwndbg.gdblib.vmmap.get():\n            if sp in page and bp not in page:\n                print('Cannot display stack frame because base pointer is not on the same page with stack pointer')\n                return\n        address = sp\n        count = int((bp - sp) / ptrsize) + 1\n    if int(address) <= int(count):\n        count -= address\n        count = max(math.ceil(count / ptrsize), 1)\n    reg_values: DefaultDict[int, list[str]] = collections.defaultdict(lambda : [])\n    for reg in pwndbg.gdblib.regs.common:\n        reg_values[pwndbg.gdblib.regs[reg]].append(reg)\n    start = address\n    stop = address + count * ptrsize\n    step = ptrsize\n    regs: dict[int, str] = {}\n    for i in range(start, stop, step):\n        values = list(reg_values[i])\n        for width in range(1, pwndbg.gdblib.arch.ptrsize):\n            values.extend(('%s-%i' % (r, width) for r in reg_values[i + width]))\n        regs[i] = ' '.join(values)\n    if regs:\n        longest_regs = max(map(len, regs.values()))\n    else:\n        longest_regs = 0\n    result = []\n    last = None\n    collapse_buffer: list[str] = []\n    skipped_padding = 2 + len(offset_delimiter) + 4 + len(offset_separator) + 1 + longest_regs + 1 - len(repeating_marker)\n\n    def collapse_repeating_values() -> None:\n        if collapse_buffer and len(collapse_buffer) + 1 >= skip_repeating_values_minimum:\n            result.append(T.repeating_marker('%s%s%i skipped' % (repeating_marker, ' ' * skipped_padding, len(collapse_buffer))))\n        else:\n            result.extend(collapse_buffer)\n        collapse_buffer.clear()\n    bp = None\n    if print_framepointer_offset:\n        bp = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    for (i, addr) in enumerate(range(start, stop, step)):\n        if not pwndbg.gdblib.memory.peek(addr):\n            collapse_repeating_values()\n            result.append('<Could not read memory at %#x>' % addr)\n            break\n        line = T.offset('%02x%s%04x%s' % (i + telescope.offset, delimiter, addr - start + telescope.offset * ptrsize, separator)) + ' '.join((regs_or_frame_offset(addr, bp, regs, longest_regs), pwndbg.chain.format(addr)))\n        if skip_repeating_values:\n            value = pwndbg.gdblib.memory.pvoid(addr)\n            if last == value and addr != input_address:\n                collapse_buffer.append(line)\n                continue\n            collapse_repeating_values()\n            last = value\n        result.append(line)\n    collapse_repeating_values()\n    telescope.offset += i\n    telescope.last_address = addr\n    if not to_string:\n        print('\\n'.join(result))\n    return result"
        ]
    },
    {
        "func_name": "regs_or_frame_offset",
        "original": "def regs_or_frame_offset(addr: int, bp: int | None, regs: dict[int, str], longest_regs: int) -> str:\n    if bp is None or len(regs[addr]) > 1 or (not -4095 <= addr - bp <= 4095):\n        return ' ' + T.register(regs[addr].ljust(longest_regs))\n    else:\n        return ('%+04x' % (addr - bp)).ljust(longest_regs + 1)",
        "mutated": [
            "def regs_or_frame_offset(addr: int, bp: int | None, regs: dict[int, str], longest_regs: int) -> str:\n    if False:\n        i = 10\n    if bp is None or len(regs[addr]) > 1 or (not -4095 <= addr - bp <= 4095):\n        return ' ' + T.register(regs[addr].ljust(longest_regs))\n    else:\n        return ('%+04x' % (addr - bp)).ljust(longest_regs + 1)",
            "def regs_or_frame_offset(addr: int, bp: int | None, regs: dict[int, str], longest_regs: int) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if bp is None or len(regs[addr]) > 1 or (not -4095 <= addr - bp <= 4095):\n        return ' ' + T.register(regs[addr].ljust(longest_regs))\n    else:\n        return ('%+04x' % (addr - bp)).ljust(longest_regs + 1)",
            "def regs_or_frame_offset(addr: int, bp: int | None, regs: dict[int, str], longest_regs: int) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if bp is None or len(regs[addr]) > 1 or (not -4095 <= addr - bp <= 4095):\n        return ' ' + T.register(regs[addr].ljust(longest_regs))\n    else:\n        return ('%+04x' % (addr - bp)).ljust(longest_regs + 1)",
            "def regs_or_frame_offset(addr: int, bp: int | None, regs: dict[int, str], longest_regs: int) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if bp is None or len(regs[addr]) > 1 or (not -4095 <= addr - bp <= 4095):\n        return ' ' + T.register(regs[addr].ljust(longest_regs))\n    else:\n        return ('%+04x' % (addr - bp)).ljust(longest_regs + 1)",
            "def regs_or_frame_offset(addr: int, bp: int | None, regs: dict[int, str], longest_regs: int) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if bp is None or len(regs[addr]) > 1 or (not -4095 <= addr - bp <= 4095):\n        return ' ' + T.register(regs[addr].ljust(longest_regs))\n    else:\n        return ('%+04x' % (addr - bp)).ljust(longest_regs + 1)"
        ]
    },
    {
        "func_name": "stack",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stack(count, offset, frame) -> None:\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=frame)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stack(count, offset, frame) -> None:\n    if False:\n        i = 10\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=frame)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stack(count, offset, frame) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=frame)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stack(count, offset, frame) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=frame)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stack(count, offset, frame) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=frame)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stack(count, offset, frame) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=frame)"
        ]
    },
    {
        "func_name": "stackf",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stackf(count, offset) -> None:\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=True)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stackf(count, offset) -> None:\n    if False:\n        i = 10\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=True)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stackf(count, offset) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=True)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stackf(count, offset) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=True)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stackf(count, offset) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=True)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.STACK)\n@pwndbg.commands.OnlyWhenRunning\ndef stackf(count, offset) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ptrsize = pwndbg.gdblib.typeinfo.ptrsize\n    telescope.repeat = stack.repeat\n    telescope(address=pwndbg.gdblib.regs.sp + offset * ptrsize, count=count, frame=True)"
        ]
    }
]