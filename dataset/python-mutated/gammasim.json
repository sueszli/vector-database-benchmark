[
    {
        "func_name": "gammasimp",
        "original": "def gammasimp(expr):\n    \"\"\"\n    Simplify expressions with gamma functions.\n\n    Explanation\n    ===========\n\n    This function takes as input an expression containing gamma\n    functions or functions that can be rewritten in terms of gamma\n    functions and tries to minimize the number of those functions and\n    reduce the size of their arguments.\n\n    The algorithm works by rewriting all gamma functions as expressions\n    involving rising factorials (Pochhammer symbols) and applies\n    recurrence relations and other transformations applicable to rising\n    factorials, to reduce their arguments, possibly letting the resulting\n    rising factorial to cancel. Rising factorials with the second argument\n    being an integer are expanded into polynomial forms and finally all\n    other rising factorial are rewritten in terms of gamma functions.\n\n    Then the following two steps are performed.\n\n    1. Reduce the number of gammas by applying the reflection theorem\n       gamma(x)*gamma(1-x) == pi/sin(pi*x).\n    2. Reduce the number of gammas by applying the multiplication theorem\n       gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).\n\n    It then reduces the number of prefactors by absorbing them into gammas\n    where possible and expands gammas with rational argument.\n\n    All transformation rules can be found (or were derived from) here:\n\n    .. [1] https://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/\n    .. [2] https://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/\n\n    Examples\n    ========\n\n    >>> from sympy.simplify import gammasimp\n    >>> from sympy import gamma, Symbol\n    >>> from sympy.abc import x\n    >>> n = Symbol('n', integer = True)\n\n    >>> gammasimp(gamma(x)/gamma(x - 3))\n    (x - 3)*(x - 2)*(x - 1)\n    >>> gammasimp(gamma(n + 3))\n    gamma(n + 3)\n\n    \"\"\"\n    expr = expr.rewrite(gamma)\n    f = expr.atoms(Function)\n    gammas = {i for i in f if isinstance(i, gamma)}\n    if not gammas:\n        return expr\n    f -= gammas\n    f = f & expr.as_dummy().atoms(Function)\n    if f:\n        (dum, fun, simp) = zip(*[(Dummy(), fi, fi.func(*[_gammasimp(a, as_comb=False) for a in fi.args])) for fi in ordered(f)])\n        d = expr.xreplace(dict(zip(fun, dum)))\n        return _gammasimp(d, as_comb=False).xreplace(dict(zip(dum, simp)))\n    return _gammasimp(expr, as_comb=False)",
        "mutated": [
            "def gammasimp(expr):\n    if False:\n        i = 10\n    \"\\n    Simplify expressions with gamma functions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing gamma\\n    functions or functions that can be rewritten in terms of gamma\\n    functions and tries to minimize the number of those functions and\\n    reduce the size of their arguments.\\n\\n    The algorithm works by rewriting all gamma functions as expressions\\n    involving rising factorials (Pochhammer symbols) and applies\\n    recurrence relations and other transformations applicable to rising\\n    factorials, to reduce their arguments, possibly letting the resulting\\n    rising factorial to cancel. Rising factorials with the second argument\\n    being an integer are expanded into polynomial forms and finally all\\n    other rising factorial are rewritten in terms of gamma functions.\\n\\n    Then the following two steps are performed.\\n\\n    1. Reduce the number of gammas by applying the reflection theorem\\n       gamma(x)*gamma(1-x) == pi/sin(pi*x).\\n    2. Reduce the number of gammas by applying the multiplication theorem\\n       gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).\\n\\n    It then reduces the number of prefactors by absorbing them into gammas\\n    where possible and expands gammas with rational argument.\\n\\n    All transformation rules can be found (or were derived from) here:\\n\\n    .. [1] https://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/\\n    .. [2] https://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import gammasimp\\n    >>> from sympy import gamma, Symbol\\n    >>> from sympy.abc import x\\n    >>> n = Symbol('n', integer = True)\\n\\n    >>> gammasimp(gamma(x)/gamma(x - 3))\\n    (x - 3)*(x - 2)*(x - 1)\\n    >>> gammasimp(gamma(n + 3))\\n    gamma(n + 3)\\n\\n    \"\n    expr = expr.rewrite(gamma)\n    f = expr.atoms(Function)\n    gammas = {i for i in f if isinstance(i, gamma)}\n    if not gammas:\n        return expr\n    f -= gammas\n    f = f & expr.as_dummy().atoms(Function)\n    if f:\n        (dum, fun, simp) = zip(*[(Dummy(), fi, fi.func(*[_gammasimp(a, as_comb=False) for a in fi.args])) for fi in ordered(f)])\n        d = expr.xreplace(dict(zip(fun, dum)))\n        return _gammasimp(d, as_comb=False).xreplace(dict(zip(dum, simp)))\n    return _gammasimp(expr, as_comb=False)",
            "def gammasimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Simplify expressions with gamma functions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing gamma\\n    functions or functions that can be rewritten in terms of gamma\\n    functions and tries to minimize the number of those functions and\\n    reduce the size of their arguments.\\n\\n    The algorithm works by rewriting all gamma functions as expressions\\n    involving rising factorials (Pochhammer symbols) and applies\\n    recurrence relations and other transformations applicable to rising\\n    factorials, to reduce their arguments, possibly letting the resulting\\n    rising factorial to cancel. Rising factorials with the second argument\\n    being an integer are expanded into polynomial forms and finally all\\n    other rising factorial are rewritten in terms of gamma functions.\\n\\n    Then the following two steps are performed.\\n\\n    1. Reduce the number of gammas by applying the reflection theorem\\n       gamma(x)*gamma(1-x) == pi/sin(pi*x).\\n    2. Reduce the number of gammas by applying the multiplication theorem\\n       gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).\\n\\n    It then reduces the number of prefactors by absorbing them into gammas\\n    where possible and expands gammas with rational argument.\\n\\n    All transformation rules can be found (or were derived from) here:\\n\\n    .. [1] https://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/\\n    .. [2] https://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import gammasimp\\n    >>> from sympy import gamma, Symbol\\n    >>> from sympy.abc import x\\n    >>> n = Symbol('n', integer = True)\\n\\n    >>> gammasimp(gamma(x)/gamma(x - 3))\\n    (x - 3)*(x - 2)*(x - 1)\\n    >>> gammasimp(gamma(n + 3))\\n    gamma(n + 3)\\n\\n    \"\n    expr = expr.rewrite(gamma)\n    f = expr.atoms(Function)\n    gammas = {i for i in f if isinstance(i, gamma)}\n    if not gammas:\n        return expr\n    f -= gammas\n    f = f & expr.as_dummy().atoms(Function)\n    if f:\n        (dum, fun, simp) = zip(*[(Dummy(), fi, fi.func(*[_gammasimp(a, as_comb=False) for a in fi.args])) for fi in ordered(f)])\n        d = expr.xreplace(dict(zip(fun, dum)))\n        return _gammasimp(d, as_comb=False).xreplace(dict(zip(dum, simp)))\n    return _gammasimp(expr, as_comb=False)",
            "def gammasimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Simplify expressions with gamma functions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing gamma\\n    functions or functions that can be rewritten in terms of gamma\\n    functions and tries to minimize the number of those functions and\\n    reduce the size of their arguments.\\n\\n    The algorithm works by rewriting all gamma functions as expressions\\n    involving rising factorials (Pochhammer symbols) and applies\\n    recurrence relations and other transformations applicable to rising\\n    factorials, to reduce their arguments, possibly letting the resulting\\n    rising factorial to cancel. Rising factorials with the second argument\\n    being an integer are expanded into polynomial forms and finally all\\n    other rising factorial are rewritten in terms of gamma functions.\\n\\n    Then the following two steps are performed.\\n\\n    1. Reduce the number of gammas by applying the reflection theorem\\n       gamma(x)*gamma(1-x) == pi/sin(pi*x).\\n    2. Reduce the number of gammas by applying the multiplication theorem\\n       gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).\\n\\n    It then reduces the number of prefactors by absorbing them into gammas\\n    where possible and expands gammas with rational argument.\\n\\n    All transformation rules can be found (or were derived from) here:\\n\\n    .. [1] https://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/\\n    .. [2] https://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import gammasimp\\n    >>> from sympy import gamma, Symbol\\n    >>> from sympy.abc import x\\n    >>> n = Symbol('n', integer = True)\\n\\n    >>> gammasimp(gamma(x)/gamma(x - 3))\\n    (x - 3)*(x - 2)*(x - 1)\\n    >>> gammasimp(gamma(n + 3))\\n    gamma(n + 3)\\n\\n    \"\n    expr = expr.rewrite(gamma)\n    f = expr.atoms(Function)\n    gammas = {i for i in f if isinstance(i, gamma)}\n    if not gammas:\n        return expr\n    f -= gammas\n    f = f & expr.as_dummy().atoms(Function)\n    if f:\n        (dum, fun, simp) = zip(*[(Dummy(), fi, fi.func(*[_gammasimp(a, as_comb=False) for a in fi.args])) for fi in ordered(f)])\n        d = expr.xreplace(dict(zip(fun, dum)))\n        return _gammasimp(d, as_comb=False).xreplace(dict(zip(dum, simp)))\n    return _gammasimp(expr, as_comb=False)",
            "def gammasimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Simplify expressions with gamma functions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing gamma\\n    functions or functions that can be rewritten in terms of gamma\\n    functions and tries to minimize the number of those functions and\\n    reduce the size of their arguments.\\n\\n    The algorithm works by rewriting all gamma functions as expressions\\n    involving rising factorials (Pochhammer symbols) and applies\\n    recurrence relations and other transformations applicable to rising\\n    factorials, to reduce their arguments, possibly letting the resulting\\n    rising factorial to cancel. Rising factorials with the second argument\\n    being an integer are expanded into polynomial forms and finally all\\n    other rising factorial are rewritten in terms of gamma functions.\\n\\n    Then the following two steps are performed.\\n\\n    1. Reduce the number of gammas by applying the reflection theorem\\n       gamma(x)*gamma(1-x) == pi/sin(pi*x).\\n    2. Reduce the number of gammas by applying the multiplication theorem\\n       gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).\\n\\n    It then reduces the number of prefactors by absorbing them into gammas\\n    where possible and expands gammas with rational argument.\\n\\n    All transformation rules can be found (or were derived from) here:\\n\\n    .. [1] https://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/\\n    .. [2] https://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import gammasimp\\n    >>> from sympy import gamma, Symbol\\n    >>> from sympy.abc import x\\n    >>> n = Symbol('n', integer = True)\\n\\n    >>> gammasimp(gamma(x)/gamma(x - 3))\\n    (x - 3)*(x - 2)*(x - 1)\\n    >>> gammasimp(gamma(n + 3))\\n    gamma(n + 3)\\n\\n    \"\n    expr = expr.rewrite(gamma)\n    f = expr.atoms(Function)\n    gammas = {i for i in f if isinstance(i, gamma)}\n    if not gammas:\n        return expr\n    f -= gammas\n    f = f & expr.as_dummy().atoms(Function)\n    if f:\n        (dum, fun, simp) = zip(*[(Dummy(), fi, fi.func(*[_gammasimp(a, as_comb=False) for a in fi.args])) for fi in ordered(f)])\n        d = expr.xreplace(dict(zip(fun, dum)))\n        return _gammasimp(d, as_comb=False).xreplace(dict(zip(dum, simp)))\n    return _gammasimp(expr, as_comb=False)",
            "def gammasimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Simplify expressions with gamma functions.\\n\\n    Explanation\\n    ===========\\n\\n    This function takes as input an expression containing gamma\\n    functions or functions that can be rewritten in terms of gamma\\n    functions and tries to minimize the number of those functions and\\n    reduce the size of their arguments.\\n\\n    The algorithm works by rewriting all gamma functions as expressions\\n    involving rising factorials (Pochhammer symbols) and applies\\n    recurrence relations and other transformations applicable to rising\\n    factorials, to reduce their arguments, possibly letting the resulting\\n    rising factorial to cancel. Rising factorials with the second argument\\n    being an integer are expanded into polynomial forms and finally all\\n    other rising factorial are rewritten in terms of gamma functions.\\n\\n    Then the following two steps are performed.\\n\\n    1. Reduce the number of gammas by applying the reflection theorem\\n       gamma(x)*gamma(1-x) == pi/sin(pi*x).\\n    2. Reduce the number of gammas by applying the multiplication theorem\\n       gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).\\n\\n    It then reduces the number of prefactors by absorbing them into gammas\\n    where possible and expands gammas with rational argument.\\n\\n    All transformation rules can be found (or were derived from) here:\\n\\n    .. [1] https://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/\\n    .. [2] https://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify import gammasimp\\n    >>> from sympy import gamma, Symbol\\n    >>> from sympy.abc import x\\n    >>> n = Symbol('n', integer = True)\\n\\n    >>> gammasimp(gamma(x)/gamma(x - 3))\\n    (x - 3)*(x - 2)*(x - 1)\\n    >>> gammasimp(gamma(n + 3))\\n    gamma(n + 3)\\n\\n    \"\n    expr = expr.rewrite(gamma)\n    f = expr.atoms(Function)\n    gammas = {i for i in f if isinstance(i, gamma)}\n    if not gammas:\n        return expr\n    f -= gammas\n    f = f & expr.as_dummy().atoms(Function)\n    if f:\n        (dum, fun, simp) = zip(*[(Dummy(), fi, fi.func(*[_gammasimp(a, as_comb=False) for a in fi.args])) for fi in ordered(f)])\n        d = expr.xreplace(dict(zip(fun, dum)))\n        return _gammasimp(d, as_comb=False).xreplace(dict(zip(dum, simp)))\n    return _gammasimp(expr, as_comb=False)"
        ]
    },
    {
        "func_name": "gamma_rat",
        "original": "def gamma_rat(x):\n    was = x.count(gamma)\n    xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n    if xx.count(gamma) < was:\n        x = xx\n    return x",
        "mutated": [
            "def gamma_rat(x):\n    if False:\n        i = 10\n    was = x.count(gamma)\n    xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n    if xx.count(gamma) < was:\n        x = xx\n    return x",
            "def gamma_rat(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    was = x.count(gamma)\n    xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n    if xx.count(gamma) < was:\n        x = xx\n    return x",
            "def gamma_rat(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    was = x.count(gamma)\n    xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n    if xx.count(gamma) < was:\n        x = xx\n    return x",
            "def gamma_rat(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    was = x.count(gamma)\n    xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n    if xx.count(gamma) < was:\n        x = xx\n    return x",
            "def gamma_rat(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    was = x.count(gamma)\n    xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n    if xx.count(gamma) < was:\n        x = xx\n    return x"
        ]
    },
    {
        "func_name": "gamma_factor",
        "original": "def gamma_factor(x):\n    if isinstance(x, gamma):\n        return True\n    if x.is_Add or x.is_Mul:\n        return any((gamma_factor(xi) for xi in x.args))\n    if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n        return gamma_factor(x.base)\n    return False",
        "mutated": [
            "def gamma_factor(x):\n    if False:\n        i = 10\n    if isinstance(x, gamma):\n        return True\n    if x.is_Add or x.is_Mul:\n        return any((gamma_factor(xi) for xi in x.args))\n    if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n        return gamma_factor(x.base)\n    return False",
            "def gamma_factor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(x, gamma):\n        return True\n    if x.is_Add or x.is_Mul:\n        return any((gamma_factor(xi) for xi in x.args))\n    if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n        return gamma_factor(x.base)\n    return False",
            "def gamma_factor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(x, gamma):\n        return True\n    if x.is_Add or x.is_Mul:\n        return any((gamma_factor(xi) for xi in x.args))\n    if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n        return gamma_factor(x.base)\n    return False",
            "def gamma_factor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(x, gamma):\n        return True\n    if x.is_Add or x.is_Mul:\n        return any((gamma_factor(xi) for xi in x.args))\n    if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n        return gamma_factor(x.base)\n    return False",
            "def gamma_factor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(x, gamma):\n        return True\n    if x.is_Add or x.is_Mul:\n        return any((gamma_factor(xi) for xi in x.args))\n    if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n        return gamma_factor(x.base)\n    return False"
        ]
    },
    {
        "func_name": "explicate",
        "original": "def explicate(p):\n    if p is S.One:\n        return (None, [])\n    (b, e) = p.as_base_exp()\n    if e.is_Integer:\n        if isinstance(b, gamma):\n            return (True, [b.args[0]] * e)\n        else:\n            return (False, [b] * e)\n    else:\n        return (False, [p])",
        "mutated": [
            "def explicate(p):\n    if False:\n        i = 10\n    if p is S.One:\n        return (None, [])\n    (b, e) = p.as_base_exp()\n    if e.is_Integer:\n        if isinstance(b, gamma):\n            return (True, [b.args[0]] * e)\n        else:\n            return (False, [b] * e)\n    else:\n        return (False, [p])",
            "def explicate(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if p is S.One:\n        return (None, [])\n    (b, e) = p.as_base_exp()\n    if e.is_Integer:\n        if isinstance(b, gamma):\n            return (True, [b.args[0]] * e)\n        else:\n            return (False, [b] * e)\n    else:\n        return (False, [p])",
            "def explicate(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if p is S.One:\n        return (None, [])\n    (b, e) = p.as_base_exp()\n    if e.is_Integer:\n        if isinstance(b, gamma):\n            return (True, [b.args[0]] * e)\n        else:\n            return (False, [b] * e)\n    else:\n        return (False, [p])",
            "def explicate(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if p is S.One:\n        return (None, [])\n    (b, e) = p.as_base_exp()\n    if e.is_Integer:\n        if isinstance(b, gamma):\n            return (True, [b.args[0]] * e)\n        else:\n            return (False, [b] * e)\n    else:\n        return (False, [p])",
            "def explicate(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if p is S.One:\n        return (None, [])\n    (b, e) = p.as_base_exp()\n    if e.is_Integer:\n        if isinstance(b, gamma):\n            return (True, [b.args[0]] * e)\n        else:\n            return (False, [b] * e)\n    else:\n        return (False, [p])"
        ]
    },
    {
        "func_name": "_run",
        "original": "def _run(coeffs):\n    u = list(uniq(coeffs))\n    for i in range(len(u)):\n        dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n        for (one, j) in dj:\n            if one.p == 1 and one.q != 1:\n                n = one.q\n                got = [i]\n                get = list(range(1, n))\n                for (d, j) in dj:\n                    m = n * d\n                    if m.is_Integer and m in get:\n                        get.remove(m)\n                        got.append(j)\n                        if not get:\n                            break\n                else:\n                    continue\n                for (i, j) in enumerate(got):\n                    c = u[j]\n                    coeffs.remove(c)\n                    got[i] = c\n                return (one.q, got[0], got[1:])",
        "mutated": [
            "def _run(coeffs):\n    if False:\n        i = 10\n    u = list(uniq(coeffs))\n    for i in range(len(u)):\n        dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n        for (one, j) in dj:\n            if one.p == 1 and one.q != 1:\n                n = one.q\n                got = [i]\n                get = list(range(1, n))\n                for (d, j) in dj:\n                    m = n * d\n                    if m.is_Integer and m in get:\n                        get.remove(m)\n                        got.append(j)\n                        if not get:\n                            break\n                else:\n                    continue\n                for (i, j) in enumerate(got):\n                    c = u[j]\n                    coeffs.remove(c)\n                    got[i] = c\n                return (one.q, got[0], got[1:])",
            "def _run(coeffs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    u = list(uniq(coeffs))\n    for i in range(len(u)):\n        dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n        for (one, j) in dj:\n            if one.p == 1 and one.q != 1:\n                n = one.q\n                got = [i]\n                get = list(range(1, n))\n                for (d, j) in dj:\n                    m = n * d\n                    if m.is_Integer and m in get:\n                        get.remove(m)\n                        got.append(j)\n                        if not get:\n                            break\n                else:\n                    continue\n                for (i, j) in enumerate(got):\n                    c = u[j]\n                    coeffs.remove(c)\n                    got[i] = c\n                return (one.q, got[0], got[1:])",
            "def _run(coeffs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    u = list(uniq(coeffs))\n    for i in range(len(u)):\n        dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n        for (one, j) in dj:\n            if one.p == 1 and one.q != 1:\n                n = one.q\n                got = [i]\n                get = list(range(1, n))\n                for (d, j) in dj:\n                    m = n * d\n                    if m.is_Integer and m in get:\n                        get.remove(m)\n                        got.append(j)\n                        if not get:\n                            break\n                else:\n                    continue\n                for (i, j) in enumerate(got):\n                    c = u[j]\n                    coeffs.remove(c)\n                    got[i] = c\n                return (one.q, got[0], got[1:])",
            "def _run(coeffs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    u = list(uniq(coeffs))\n    for i in range(len(u)):\n        dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n        for (one, j) in dj:\n            if one.p == 1 and one.q != 1:\n                n = one.q\n                got = [i]\n                get = list(range(1, n))\n                for (d, j) in dj:\n                    m = n * d\n                    if m.is_Integer and m in get:\n                        get.remove(m)\n                        got.append(j)\n                        if not get:\n                            break\n                else:\n                    continue\n                for (i, j) in enumerate(got):\n                    c = u[j]\n                    coeffs.remove(c)\n                    got[i] = c\n                return (one.q, got[0], got[1:])",
            "def _run(coeffs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    u = list(uniq(coeffs))\n    for i in range(len(u)):\n        dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n        for (one, j) in dj:\n            if one.p == 1 and one.q != 1:\n                n = one.q\n                got = [i]\n                get = list(range(1, n))\n                for (d, j) in dj:\n                    m = n * d\n                    if m.is_Integer and m in get:\n                        get.remove(m)\n                        got.append(j)\n                        if not get:\n                            break\n                else:\n                    continue\n                for (i, j) in enumerate(got):\n                    c = u[j]\n                    coeffs.remove(c)\n                    got[i] = c\n                return (one.q, got[0], got[1:])"
        ]
    },
    {
        "func_name": "_mult_thm",
        "original": "def _mult_thm(gammas, numer, denom):\n    rats = {}\n    for g in gammas:\n        (c, resid) = g.as_coeff_Add()\n        rats.setdefault(resid, []).append(c)\n    keys = sorted(rats, key=default_sort_key)\n    for resid in keys:\n        coeffs = sorted(rats[resid])\n        new = []\n        while True:\n            run = _run(coeffs)\n            if run is None:\n                break\n            (n, ui, other) = run\n            for u in other:\n                con = resid + u - 1\n                for k in range(int(u - ui)):\n                    numer.append(con - k)\n            con = n * (resid + ui)\n            numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n            new.append(con)\n        rats[resid] = [resid + c for c in coeffs] + new\n    g = []\n    for resid in keys:\n        g += rats[resid]\n    gammas[:] = g",
        "mutated": [
            "def _mult_thm(gammas, numer, denom):\n    if False:\n        i = 10\n    rats = {}\n    for g in gammas:\n        (c, resid) = g.as_coeff_Add()\n        rats.setdefault(resid, []).append(c)\n    keys = sorted(rats, key=default_sort_key)\n    for resid in keys:\n        coeffs = sorted(rats[resid])\n        new = []\n        while True:\n            run = _run(coeffs)\n            if run is None:\n                break\n            (n, ui, other) = run\n            for u in other:\n                con = resid + u - 1\n                for k in range(int(u - ui)):\n                    numer.append(con - k)\n            con = n * (resid + ui)\n            numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n            new.append(con)\n        rats[resid] = [resid + c for c in coeffs] + new\n    g = []\n    for resid in keys:\n        g += rats[resid]\n    gammas[:] = g",
            "def _mult_thm(gammas, numer, denom):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rats = {}\n    for g in gammas:\n        (c, resid) = g.as_coeff_Add()\n        rats.setdefault(resid, []).append(c)\n    keys = sorted(rats, key=default_sort_key)\n    for resid in keys:\n        coeffs = sorted(rats[resid])\n        new = []\n        while True:\n            run = _run(coeffs)\n            if run is None:\n                break\n            (n, ui, other) = run\n            for u in other:\n                con = resid + u - 1\n                for k in range(int(u - ui)):\n                    numer.append(con - k)\n            con = n * (resid + ui)\n            numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n            new.append(con)\n        rats[resid] = [resid + c for c in coeffs] + new\n    g = []\n    for resid in keys:\n        g += rats[resid]\n    gammas[:] = g",
            "def _mult_thm(gammas, numer, denom):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rats = {}\n    for g in gammas:\n        (c, resid) = g.as_coeff_Add()\n        rats.setdefault(resid, []).append(c)\n    keys = sorted(rats, key=default_sort_key)\n    for resid in keys:\n        coeffs = sorted(rats[resid])\n        new = []\n        while True:\n            run = _run(coeffs)\n            if run is None:\n                break\n            (n, ui, other) = run\n            for u in other:\n                con = resid + u - 1\n                for k in range(int(u - ui)):\n                    numer.append(con - k)\n            con = n * (resid + ui)\n            numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n            new.append(con)\n        rats[resid] = [resid + c for c in coeffs] + new\n    g = []\n    for resid in keys:\n        g += rats[resid]\n    gammas[:] = g",
            "def _mult_thm(gammas, numer, denom):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rats = {}\n    for g in gammas:\n        (c, resid) = g.as_coeff_Add()\n        rats.setdefault(resid, []).append(c)\n    keys = sorted(rats, key=default_sort_key)\n    for resid in keys:\n        coeffs = sorted(rats[resid])\n        new = []\n        while True:\n            run = _run(coeffs)\n            if run is None:\n                break\n            (n, ui, other) = run\n            for u in other:\n                con = resid + u - 1\n                for k in range(int(u - ui)):\n                    numer.append(con - k)\n            con = n * (resid + ui)\n            numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n            new.append(con)\n        rats[resid] = [resid + c for c in coeffs] + new\n    g = []\n    for resid in keys:\n        g += rats[resid]\n    gammas[:] = g",
            "def _mult_thm(gammas, numer, denom):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rats = {}\n    for g in gammas:\n        (c, resid) = g.as_coeff_Add()\n        rats.setdefault(resid, []).append(c)\n    keys = sorted(rats, key=default_sort_key)\n    for resid in keys:\n        coeffs = sorted(rats[resid])\n        new = []\n        while True:\n            run = _run(coeffs)\n            if run is None:\n                break\n            (n, ui, other) = run\n            for u in other:\n                con = resid + u - 1\n                for k in range(int(u - ui)):\n                    numer.append(con - k)\n            con = n * (resid + ui)\n            numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n            new.append(con)\n        rats[resid] = [resid + c for c in coeffs] + new\n    g = []\n    for resid in keys:\n        g += rats[resid]\n    gammas[:] = g"
        ]
    },
    {
        "func_name": "find_fuzzy",
        "original": "def find_fuzzy(l, x):\n    if not l:\n        return\n    (S1, T1) = compute_ST(x)\n    for y in l:\n        (S2, T2) = inv[y]\n        if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n            continue\n        a = len(cancel(x / y).free_symbols)\n        b = len(x.free_symbols)\n        c = len(y.free_symbols)\n        if a == 0 and (b > 0 or c > 0):\n            return y",
        "mutated": [
            "def find_fuzzy(l, x):\n    if False:\n        i = 10\n    if not l:\n        return\n    (S1, T1) = compute_ST(x)\n    for y in l:\n        (S2, T2) = inv[y]\n        if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n            continue\n        a = len(cancel(x / y).free_symbols)\n        b = len(x.free_symbols)\n        c = len(y.free_symbols)\n        if a == 0 and (b > 0 or c > 0):\n            return y",
            "def find_fuzzy(l, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not l:\n        return\n    (S1, T1) = compute_ST(x)\n    for y in l:\n        (S2, T2) = inv[y]\n        if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n            continue\n        a = len(cancel(x / y).free_symbols)\n        b = len(x.free_symbols)\n        c = len(y.free_symbols)\n        if a == 0 and (b > 0 or c > 0):\n            return y",
            "def find_fuzzy(l, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not l:\n        return\n    (S1, T1) = compute_ST(x)\n    for y in l:\n        (S2, T2) = inv[y]\n        if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n            continue\n        a = len(cancel(x / y).free_symbols)\n        b = len(x.free_symbols)\n        c = len(y.free_symbols)\n        if a == 0 and (b > 0 or c > 0):\n            return y",
            "def find_fuzzy(l, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not l:\n        return\n    (S1, T1) = compute_ST(x)\n    for y in l:\n        (S2, T2) = inv[y]\n        if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n            continue\n        a = len(cancel(x / y).free_symbols)\n        b = len(x.free_symbols)\n        c = len(y.free_symbols)\n        if a == 0 and (b > 0 or c > 0):\n            return y",
            "def find_fuzzy(l, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not l:\n        return\n    (S1, T1) = compute_ST(x)\n    for y in l:\n        (S2, T2) = inv[y]\n        if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n            continue\n        a = len(cancel(x / y).free_symbols)\n        b = len(x.free_symbols)\n        c = len(y.free_symbols)\n        if a == 0 and (b > 0 or c > 0):\n            return y"
        ]
    },
    {
        "func_name": "compute_ST",
        "original": "def compute_ST(expr):\n    if expr in inv:\n        return inv[expr]\n    return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))",
        "mutated": [
            "def compute_ST(expr):\n    if False:\n        i = 10\n    if expr in inv:\n        return inv[expr]\n    return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))",
            "def compute_ST(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if expr in inv:\n        return inv[expr]\n    return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))",
            "def compute_ST(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if expr in inv:\n        return inv[expr]\n    return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))",
            "def compute_ST(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if expr in inv:\n        return inv[expr]\n    return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))",
            "def compute_ST(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if expr in inv:\n        return inv[expr]\n    return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))"
        ]
    },
    {
        "func_name": "update_ST",
        "original": "def update_ST(expr):\n    inv[expr] = compute_ST(expr)",
        "mutated": [
            "def update_ST(expr):\n    if False:\n        i = 10\n    inv[expr] = compute_ST(expr)",
            "def update_ST(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    inv[expr] = compute_ST(expr)",
            "def update_ST(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    inv[expr] = compute_ST(expr)",
            "def update_ST(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    inv[expr] = compute_ST(expr)",
            "def update_ST(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    inv[expr] = compute_ST(expr)"
        ]
    },
    {
        "func_name": "rule_gamma",
        "original": "def rule_gamma(expr, level=0):\n    \"\"\" Simplify products of gamma functions further. \"\"\"\n    if expr.is_Atom:\n        return expr\n\n    def gamma_rat(x):\n        was = x.count(gamma)\n        xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n        if xx.count(gamma) < was:\n            x = xx\n        return x\n\n    def gamma_factor(x):\n        if isinstance(x, gamma):\n            return True\n        if x.is_Add or x.is_Mul:\n            return any((gamma_factor(xi) for xi in x.args))\n        if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n            return gamma_factor(x.base)\n        return False\n    if level == 0:\n        expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n        level += 1\n    if not expr.is_Mul:\n        return expr\n    if level == 1:\n        (args, nc) = expr.args_cnc()\n        if not args:\n            return expr\n        if nc:\n            return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n        level += 1\n    if level == 2:\n        (T, F) = sift(expr.args, gamma_factor, binary=True)\n        gamma_ind = Mul(*F)\n        d = Mul(*T)\n        (nd, dd) = d.as_numer_denom()\n        for ipass in range(2):\n            args = list(ordered(Mul.make_args(nd)))\n            for (i, ni) in enumerate(args):\n                if ni.is_Add:\n                    (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                    args[i] = ni\n                    if not dd.has(gamma):\n                        break\n            nd = Mul(*args)\n            if ipass == 0 and (not gamma_factor(nd)):\n                break\n            (nd, dd) = (dd, nd)\n        expr = gamma_ind * nd / dd\n        if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n            return expr\n        level += 1\n    if level == 3:\n        while True:\n            was = expr\n            expr = rule_gamma(expr, 4)\n            if expr == was:\n                return expr\n    numer_gammas = []\n    denom_gammas = []\n    numer_others = []\n    denom_others = []\n\n    def explicate(p):\n        if p is S.One:\n            return (None, [])\n        (b, e) = p.as_base_exp()\n        if e.is_Integer:\n            if isinstance(b, gamma):\n                return (True, [b.args[0]] * e)\n            else:\n                return (False, [b] * e)\n        else:\n            return (False, [p])\n    newargs = list(ordered(expr.args))\n    while newargs:\n        (n, d) = newargs.pop().as_numer_denom()\n        (isg, l) = explicate(n)\n        if isg:\n            numer_gammas.extend(l)\n        elif isg is False:\n            numer_others.extend(l)\n        (isg, l) = explicate(d)\n        if isg:\n            denom_gammas.extend(l)\n        elif isg is False:\n            denom_others.extend(l)\n    if not as_comb:\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g1 = gammas.pop()\n                if g1.is_integer:\n                    new.append(g1)\n                    continue\n                for (i, g2) in enumerate(gammas):\n                    n = g1 + g2 - 1\n                    if not n.is_Integer:\n                        continue\n                    numer.append(S.Pi)\n                    denom.append(sin(S.Pi * g1))\n                    gammas.pop(i)\n                    if n > 0:\n                        for k in range(n):\n                            numer.append(1 - g1 + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            denom.append(-g1 - k)\n                    break\n                else:\n                    new.append(g1)\n            gammas[:] = new\n        for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n            while True:\n                for x in ng:\n                    for y in dg:\n                        n = x - 2 * y\n                        if n.is_Integer:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    break\n                ng.remove(x)\n                dg.remove(y)\n                if n > 0:\n                    for k in range(n):\n                        no.append(2 * y + k)\n                elif n < 0:\n                    for k in range(-n):\n                        do.append(2 * y - 1 - k)\n                ng.append(y + S.Half)\n                no.append(2 ** (2 * y - 1))\n                do.append(sqrt(S.Pi))\n\n        def _run(coeffs):\n            u = list(uniq(coeffs))\n            for i in range(len(u)):\n                dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                for (one, j) in dj:\n                    if one.p == 1 and one.q != 1:\n                        n = one.q\n                        got = [i]\n                        get = list(range(1, n))\n                        for (d, j) in dj:\n                            m = n * d\n                            if m.is_Integer and m in get:\n                                get.remove(m)\n                                got.append(j)\n                                if not get:\n                                    break\n                        else:\n                            continue\n                        for (i, j) in enumerate(got):\n                            c = u[j]\n                            coeffs.remove(c)\n                            got[i] = c\n                        return (one.q, got[0], got[1:])\n\n        def _mult_thm(gammas, numer, denom):\n            rats = {}\n            for g in gammas:\n                (c, resid) = g.as_coeff_Add()\n                rats.setdefault(resid, []).append(c)\n            keys = sorted(rats, key=default_sort_key)\n            for resid in keys:\n                coeffs = sorted(rats[resid])\n                new = []\n                while True:\n                    run = _run(coeffs)\n                    if run is None:\n                        break\n                    (n, ui, other) = run\n                    for u in other:\n                        con = resid + u - 1\n                        for k in range(int(u - ui)):\n                            numer.append(con - k)\n                    con = n * (resid + ui)\n                    numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                    new.append(con)\n                rats[resid] = [resid + c for c in coeffs] + new\n            g = []\n            for resid in keys:\n                g += rats[resid]\n            gammas[:] = g\n        for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            _mult_thm(l, numer, denom)\n    if level >= 2:\n\n        def find_fuzzy(l, x):\n            if not l:\n                return\n            (S1, T1) = compute_ST(x)\n            for y in l:\n                (S2, T2) = inv[y]\n                if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                    continue\n                a = len(cancel(x / y).free_symbols)\n                b = len(x.free_symbols)\n                c = len(y.free_symbols)\n                if a == 0 and (b > 0 or c > 0):\n                    return y\n        inv = {}\n\n        def compute_ST(expr):\n            if expr in inv:\n                return inv[expr]\n            return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n        def update_ST(expr):\n            inv[expr] = compute_ST(expr)\n        for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n            update_ST(expr)\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g = gammas.pop()\n                cont = True\n                while cont:\n                    cont = False\n                    y = find_fuzzy(numer, g)\n                    if y is not None:\n                        numer.remove(y)\n                        if y != g:\n                            numer.append(y / g)\n                            update_ST(y / g)\n                        g += 1\n                        cont = True\n                    y = find_fuzzy(denom, g - 1)\n                    if y is not None:\n                        denom.remove(y)\n                        if y != g - 1:\n                            numer.append((g - 1) / y)\n                            update_ST((g - 1) / y)\n                        g -= 1\n                        cont = True\n                new.append(g)\n            gammas[:] = new\n    return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)",
        "mutated": [
            "def rule_gamma(expr, level=0):\n    if False:\n        i = 10\n    ' Simplify products of gamma functions further. '\n    if expr.is_Atom:\n        return expr\n\n    def gamma_rat(x):\n        was = x.count(gamma)\n        xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n        if xx.count(gamma) < was:\n            x = xx\n        return x\n\n    def gamma_factor(x):\n        if isinstance(x, gamma):\n            return True\n        if x.is_Add or x.is_Mul:\n            return any((gamma_factor(xi) for xi in x.args))\n        if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n            return gamma_factor(x.base)\n        return False\n    if level == 0:\n        expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n        level += 1\n    if not expr.is_Mul:\n        return expr\n    if level == 1:\n        (args, nc) = expr.args_cnc()\n        if not args:\n            return expr\n        if nc:\n            return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n        level += 1\n    if level == 2:\n        (T, F) = sift(expr.args, gamma_factor, binary=True)\n        gamma_ind = Mul(*F)\n        d = Mul(*T)\n        (nd, dd) = d.as_numer_denom()\n        for ipass in range(2):\n            args = list(ordered(Mul.make_args(nd)))\n            for (i, ni) in enumerate(args):\n                if ni.is_Add:\n                    (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                    args[i] = ni\n                    if not dd.has(gamma):\n                        break\n            nd = Mul(*args)\n            if ipass == 0 and (not gamma_factor(nd)):\n                break\n            (nd, dd) = (dd, nd)\n        expr = gamma_ind * nd / dd\n        if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n            return expr\n        level += 1\n    if level == 3:\n        while True:\n            was = expr\n            expr = rule_gamma(expr, 4)\n            if expr == was:\n                return expr\n    numer_gammas = []\n    denom_gammas = []\n    numer_others = []\n    denom_others = []\n\n    def explicate(p):\n        if p is S.One:\n            return (None, [])\n        (b, e) = p.as_base_exp()\n        if e.is_Integer:\n            if isinstance(b, gamma):\n                return (True, [b.args[0]] * e)\n            else:\n                return (False, [b] * e)\n        else:\n            return (False, [p])\n    newargs = list(ordered(expr.args))\n    while newargs:\n        (n, d) = newargs.pop().as_numer_denom()\n        (isg, l) = explicate(n)\n        if isg:\n            numer_gammas.extend(l)\n        elif isg is False:\n            numer_others.extend(l)\n        (isg, l) = explicate(d)\n        if isg:\n            denom_gammas.extend(l)\n        elif isg is False:\n            denom_others.extend(l)\n    if not as_comb:\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g1 = gammas.pop()\n                if g1.is_integer:\n                    new.append(g1)\n                    continue\n                for (i, g2) in enumerate(gammas):\n                    n = g1 + g2 - 1\n                    if not n.is_Integer:\n                        continue\n                    numer.append(S.Pi)\n                    denom.append(sin(S.Pi * g1))\n                    gammas.pop(i)\n                    if n > 0:\n                        for k in range(n):\n                            numer.append(1 - g1 + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            denom.append(-g1 - k)\n                    break\n                else:\n                    new.append(g1)\n            gammas[:] = new\n        for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n            while True:\n                for x in ng:\n                    for y in dg:\n                        n = x - 2 * y\n                        if n.is_Integer:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    break\n                ng.remove(x)\n                dg.remove(y)\n                if n > 0:\n                    for k in range(n):\n                        no.append(2 * y + k)\n                elif n < 0:\n                    for k in range(-n):\n                        do.append(2 * y - 1 - k)\n                ng.append(y + S.Half)\n                no.append(2 ** (2 * y - 1))\n                do.append(sqrt(S.Pi))\n\n        def _run(coeffs):\n            u = list(uniq(coeffs))\n            for i in range(len(u)):\n                dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                for (one, j) in dj:\n                    if one.p == 1 and one.q != 1:\n                        n = one.q\n                        got = [i]\n                        get = list(range(1, n))\n                        for (d, j) in dj:\n                            m = n * d\n                            if m.is_Integer and m in get:\n                                get.remove(m)\n                                got.append(j)\n                                if not get:\n                                    break\n                        else:\n                            continue\n                        for (i, j) in enumerate(got):\n                            c = u[j]\n                            coeffs.remove(c)\n                            got[i] = c\n                        return (one.q, got[0], got[1:])\n\n        def _mult_thm(gammas, numer, denom):\n            rats = {}\n            for g in gammas:\n                (c, resid) = g.as_coeff_Add()\n                rats.setdefault(resid, []).append(c)\n            keys = sorted(rats, key=default_sort_key)\n            for resid in keys:\n                coeffs = sorted(rats[resid])\n                new = []\n                while True:\n                    run = _run(coeffs)\n                    if run is None:\n                        break\n                    (n, ui, other) = run\n                    for u in other:\n                        con = resid + u - 1\n                        for k in range(int(u - ui)):\n                            numer.append(con - k)\n                    con = n * (resid + ui)\n                    numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                    new.append(con)\n                rats[resid] = [resid + c for c in coeffs] + new\n            g = []\n            for resid in keys:\n                g += rats[resid]\n            gammas[:] = g\n        for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            _mult_thm(l, numer, denom)\n    if level >= 2:\n\n        def find_fuzzy(l, x):\n            if not l:\n                return\n            (S1, T1) = compute_ST(x)\n            for y in l:\n                (S2, T2) = inv[y]\n                if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                    continue\n                a = len(cancel(x / y).free_symbols)\n                b = len(x.free_symbols)\n                c = len(y.free_symbols)\n                if a == 0 and (b > 0 or c > 0):\n                    return y\n        inv = {}\n\n        def compute_ST(expr):\n            if expr in inv:\n                return inv[expr]\n            return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n        def update_ST(expr):\n            inv[expr] = compute_ST(expr)\n        for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n            update_ST(expr)\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g = gammas.pop()\n                cont = True\n                while cont:\n                    cont = False\n                    y = find_fuzzy(numer, g)\n                    if y is not None:\n                        numer.remove(y)\n                        if y != g:\n                            numer.append(y / g)\n                            update_ST(y / g)\n                        g += 1\n                        cont = True\n                    y = find_fuzzy(denom, g - 1)\n                    if y is not None:\n                        denom.remove(y)\n                        if y != g - 1:\n                            numer.append((g - 1) / y)\n                            update_ST((g - 1) / y)\n                        g -= 1\n                        cont = True\n                new.append(g)\n            gammas[:] = new\n    return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)",
            "def rule_gamma(expr, level=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Simplify products of gamma functions further. '\n    if expr.is_Atom:\n        return expr\n\n    def gamma_rat(x):\n        was = x.count(gamma)\n        xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n        if xx.count(gamma) < was:\n            x = xx\n        return x\n\n    def gamma_factor(x):\n        if isinstance(x, gamma):\n            return True\n        if x.is_Add or x.is_Mul:\n            return any((gamma_factor(xi) for xi in x.args))\n        if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n            return gamma_factor(x.base)\n        return False\n    if level == 0:\n        expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n        level += 1\n    if not expr.is_Mul:\n        return expr\n    if level == 1:\n        (args, nc) = expr.args_cnc()\n        if not args:\n            return expr\n        if nc:\n            return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n        level += 1\n    if level == 2:\n        (T, F) = sift(expr.args, gamma_factor, binary=True)\n        gamma_ind = Mul(*F)\n        d = Mul(*T)\n        (nd, dd) = d.as_numer_denom()\n        for ipass in range(2):\n            args = list(ordered(Mul.make_args(nd)))\n            for (i, ni) in enumerate(args):\n                if ni.is_Add:\n                    (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                    args[i] = ni\n                    if not dd.has(gamma):\n                        break\n            nd = Mul(*args)\n            if ipass == 0 and (not gamma_factor(nd)):\n                break\n            (nd, dd) = (dd, nd)\n        expr = gamma_ind * nd / dd\n        if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n            return expr\n        level += 1\n    if level == 3:\n        while True:\n            was = expr\n            expr = rule_gamma(expr, 4)\n            if expr == was:\n                return expr\n    numer_gammas = []\n    denom_gammas = []\n    numer_others = []\n    denom_others = []\n\n    def explicate(p):\n        if p is S.One:\n            return (None, [])\n        (b, e) = p.as_base_exp()\n        if e.is_Integer:\n            if isinstance(b, gamma):\n                return (True, [b.args[0]] * e)\n            else:\n                return (False, [b] * e)\n        else:\n            return (False, [p])\n    newargs = list(ordered(expr.args))\n    while newargs:\n        (n, d) = newargs.pop().as_numer_denom()\n        (isg, l) = explicate(n)\n        if isg:\n            numer_gammas.extend(l)\n        elif isg is False:\n            numer_others.extend(l)\n        (isg, l) = explicate(d)\n        if isg:\n            denom_gammas.extend(l)\n        elif isg is False:\n            denom_others.extend(l)\n    if not as_comb:\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g1 = gammas.pop()\n                if g1.is_integer:\n                    new.append(g1)\n                    continue\n                for (i, g2) in enumerate(gammas):\n                    n = g1 + g2 - 1\n                    if not n.is_Integer:\n                        continue\n                    numer.append(S.Pi)\n                    denom.append(sin(S.Pi * g1))\n                    gammas.pop(i)\n                    if n > 0:\n                        for k in range(n):\n                            numer.append(1 - g1 + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            denom.append(-g1 - k)\n                    break\n                else:\n                    new.append(g1)\n            gammas[:] = new\n        for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n            while True:\n                for x in ng:\n                    for y in dg:\n                        n = x - 2 * y\n                        if n.is_Integer:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    break\n                ng.remove(x)\n                dg.remove(y)\n                if n > 0:\n                    for k in range(n):\n                        no.append(2 * y + k)\n                elif n < 0:\n                    for k in range(-n):\n                        do.append(2 * y - 1 - k)\n                ng.append(y + S.Half)\n                no.append(2 ** (2 * y - 1))\n                do.append(sqrt(S.Pi))\n\n        def _run(coeffs):\n            u = list(uniq(coeffs))\n            for i in range(len(u)):\n                dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                for (one, j) in dj:\n                    if one.p == 1 and one.q != 1:\n                        n = one.q\n                        got = [i]\n                        get = list(range(1, n))\n                        for (d, j) in dj:\n                            m = n * d\n                            if m.is_Integer and m in get:\n                                get.remove(m)\n                                got.append(j)\n                                if not get:\n                                    break\n                        else:\n                            continue\n                        for (i, j) in enumerate(got):\n                            c = u[j]\n                            coeffs.remove(c)\n                            got[i] = c\n                        return (one.q, got[0], got[1:])\n\n        def _mult_thm(gammas, numer, denom):\n            rats = {}\n            for g in gammas:\n                (c, resid) = g.as_coeff_Add()\n                rats.setdefault(resid, []).append(c)\n            keys = sorted(rats, key=default_sort_key)\n            for resid in keys:\n                coeffs = sorted(rats[resid])\n                new = []\n                while True:\n                    run = _run(coeffs)\n                    if run is None:\n                        break\n                    (n, ui, other) = run\n                    for u in other:\n                        con = resid + u - 1\n                        for k in range(int(u - ui)):\n                            numer.append(con - k)\n                    con = n * (resid + ui)\n                    numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                    new.append(con)\n                rats[resid] = [resid + c for c in coeffs] + new\n            g = []\n            for resid in keys:\n                g += rats[resid]\n            gammas[:] = g\n        for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            _mult_thm(l, numer, denom)\n    if level >= 2:\n\n        def find_fuzzy(l, x):\n            if not l:\n                return\n            (S1, T1) = compute_ST(x)\n            for y in l:\n                (S2, T2) = inv[y]\n                if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                    continue\n                a = len(cancel(x / y).free_symbols)\n                b = len(x.free_symbols)\n                c = len(y.free_symbols)\n                if a == 0 and (b > 0 or c > 0):\n                    return y\n        inv = {}\n\n        def compute_ST(expr):\n            if expr in inv:\n                return inv[expr]\n            return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n        def update_ST(expr):\n            inv[expr] = compute_ST(expr)\n        for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n            update_ST(expr)\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g = gammas.pop()\n                cont = True\n                while cont:\n                    cont = False\n                    y = find_fuzzy(numer, g)\n                    if y is not None:\n                        numer.remove(y)\n                        if y != g:\n                            numer.append(y / g)\n                            update_ST(y / g)\n                        g += 1\n                        cont = True\n                    y = find_fuzzy(denom, g - 1)\n                    if y is not None:\n                        denom.remove(y)\n                        if y != g - 1:\n                            numer.append((g - 1) / y)\n                            update_ST((g - 1) / y)\n                        g -= 1\n                        cont = True\n                new.append(g)\n            gammas[:] = new\n    return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)",
            "def rule_gamma(expr, level=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Simplify products of gamma functions further. '\n    if expr.is_Atom:\n        return expr\n\n    def gamma_rat(x):\n        was = x.count(gamma)\n        xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n        if xx.count(gamma) < was:\n            x = xx\n        return x\n\n    def gamma_factor(x):\n        if isinstance(x, gamma):\n            return True\n        if x.is_Add or x.is_Mul:\n            return any((gamma_factor(xi) for xi in x.args))\n        if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n            return gamma_factor(x.base)\n        return False\n    if level == 0:\n        expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n        level += 1\n    if not expr.is_Mul:\n        return expr\n    if level == 1:\n        (args, nc) = expr.args_cnc()\n        if not args:\n            return expr\n        if nc:\n            return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n        level += 1\n    if level == 2:\n        (T, F) = sift(expr.args, gamma_factor, binary=True)\n        gamma_ind = Mul(*F)\n        d = Mul(*T)\n        (nd, dd) = d.as_numer_denom()\n        for ipass in range(2):\n            args = list(ordered(Mul.make_args(nd)))\n            for (i, ni) in enumerate(args):\n                if ni.is_Add:\n                    (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                    args[i] = ni\n                    if not dd.has(gamma):\n                        break\n            nd = Mul(*args)\n            if ipass == 0 and (not gamma_factor(nd)):\n                break\n            (nd, dd) = (dd, nd)\n        expr = gamma_ind * nd / dd\n        if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n            return expr\n        level += 1\n    if level == 3:\n        while True:\n            was = expr\n            expr = rule_gamma(expr, 4)\n            if expr == was:\n                return expr\n    numer_gammas = []\n    denom_gammas = []\n    numer_others = []\n    denom_others = []\n\n    def explicate(p):\n        if p is S.One:\n            return (None, [])\n        (b, e) = p.as_base_exp()\n        if e.is_Integer:\n            if isinstance(b, gamma):\n                return (True, [b.args[0]] * e)\n            else:\n                return (False, [b] * e)\n        else:\n            return (False, [p])\n    newargs = list(ordered(expr.args))\n    while newargs:\n        (n, d) = newargs.pop().as_numer_denom()\n        (isg, l) = explicate(n)\n        if isg:\n            numer_gammas.extend(l)\n        elif isg is False:\n            numer_others.extend(l)\n        (isg, l) = explicate(d)\n        if isg:\n            denom_gammas.extend(l)\n        elif isg is False:\n            denom_others.extend(l)\n    if not as_comb:\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g1 = gammas.pop()\n                if g1.is_integer:\n                    new.append(g1)\n                    continue\n                for (i, g2) in enumerate(gammas):\n                    n = g1 + g2 - 1\n                    if not n.is_Integer:\n                        continue\n                    numer.append(S.Pi)\n                    denom.append(sin(S.Pi * g1))\n                    gammas.pop(i)\n                    if n > 0:\n                        for k in range(n):\n                            numer.append(1 - g1 + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            denom.append(-g1 - k)\n                    break\n                else:\n                    new.append(g1)\n            gammas[:] = new\n        for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n            while True:\n                for x in ng:\n                    for y in dg:\n                        n = x - 2 * y\n                        if n.is_Integer:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    break\n                ng.remove(x)\n                dg.remove(y)\n                if n > 0:\n                    for k in range(n):\n                        no.append(2 * y + k)\n                elif n < 0:\n                    for k in range(-n):\n                        do.append(2 * y - 1 - k)\n                ng.append(y + S.Half)\n                no.append(2 ** (2 * y - 1))\n                do.append(sqrt(S.Pi))\n\n        def _run(coeffs):\n            u = list(uniq(coeffs))\n            for i in range(len(u)):\n                dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                for (one, j) in dj:\n                    if one.p == 1 and one.q != 1:\n                        n = one.q\n                        got = [i]\n                        get = list(range(1, n))\n                        for (d, j) in dj:\n                            m = n * d\n                            if m.is_Integer and m in get:\n                                get.remove(m)\n                                got.append(j)\n                                if not get:\n                                    break\n                        else:\n                            continue\n                        for (i, j) in enumerate(got):\n                            c = u[j]\n                            coeffs.remove(c)\n                            got[i] = c\n                        return (one.q, got[0], got[1:])\n\n        def _mult_thm(gammas, numer, denom):\n            rats = {}\n            for g in gammas:\n                (c, resid) = g.as_coeff_Add()\n                rats.setdefault(resid, []).append(c)\n            keys = sorted(rats, key=default_sort_key)\n            for resid in keys:\n                coeffs = sorted(rats[resid])\n                new = []\n                while True:\n                    run = _run(coeffs)\n                    if run is None:\n                        break\n                    (n, ui, other) = run\n                    for u in other:\n                        con = resid + u - 1\n                        for k in range(int(u - ui)):\n                            numer.append(con - k)\n                    con = n * (resid + ui)\n                    numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                    new.append(con)\n                rats[resid] = [resid + c for c in coeffs] + new\n            g = []\n            for resid in keys:\n                g += rats[resid]\n            gammas[:] = g\n        for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            _mult_thm(l, numer, denom)\n    if level >= 2:\n\n        def find_fuzzy(l, x):\n            if not l:\n                return\n            (S1, T1) = compute_ST(x)\n            for y in l:\n                (S2, T2) = inv[y]\n                if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                    continue\n                a = len(cancel(x / y).free_symbols)\n                b = len(x.free_symbols)\n                c = len(y.free_symbols)\n                if a == 0 and (b > 0 or c > 0):\n                    return y\n        inv = {}\n\n        def compute_ST(expr):\n            if expr in inv:\n                return inv[expr]\n            return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n        def update_ST(expr):\n            inv[expr] = compute_ST(expr)\n        for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n            update_ST(expr)\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g = gammas.pop()\n                cont = True\n                while cont:\n                    cont = False\n                    y = find_fuzzy(numer, g)\n                    if y is not None:\n                        numer.remove(y)\n                        if y != g:\n                            numer.append(y / g)\n                            update_ST(y / g)\n                        g += 1\n                        cont = True\n                    y = find_fuzzy(denom, g - 1)\n                    if y is not None:\n                        denom.remove(y)\n                        if y != g - 1:\n                            numer.append((g - 1) / y)\n                            update_ST((g - 1) / y)\n                        g -= 1\n                        cont = True\n                new.append(g)\n            gammas[:] = new\n    return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)",
            "def rule_gamma(expr, level=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Simplify products of gamma functions further. '\n    if expr.is_Atom:\n        return expr\n\n    def gamma_rat(x):\n        was = x.count(gamma)\n        xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n        if xx.count(gamma) < was:\n            x = xx\n        return x\n\n    def gamma_factor(x):\n        if isinstance(x, gamma):\n            return True\n        if x.is_Add or x.is_Mul:\n            return any((gamma_factor(xi) for xi in x.args))\n        if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n            return gamma_factor(x.base)\n        return False\n    if level == 0:\n        expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n        level += 1\n    if not expr.is_Mul:\n        return expr\n    if level == 1:\n        (args, nc) = expr.args_cnc()\n        if not args:\n            return expr\n        if nc:\n            return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n        level += 1\n    if level == 2:\n        (T, F) = sift(expr.args, gamma_factor, binary=True)\n        gamma_ind = Mul(*F)\n        d = Mul(*T)\n        (nd, dd) = d.as_numer_denom()\n        for ipass in range(2):\n            args = list(ordered(Mul.make_args(nd)))\n            for (i, ni) in enumerate(args):\n                if ni.is_Add:\n                    (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                    args[i] = ni\n                    if not dd.has(gamma):\n                        break\n            nd = Mul(*args)\n            if ipass == 0 and (not gamma_factor(nd)):\n                break\n            (nd, dd) = (dd, nd)\n        expr = gamma_ind * nd / dd\n        if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n            return expr\n        level += 1\n    if level == 3:\n        while True:\n            was = expr\n            expr = rule_gamma(expr, 4)\n            if expr == was:\n                return expr\n    numer_gammas = []\n    denom_gammas = []\n    numer_others = []\n    denom_others = []\n\n    def explicate(p):\n        if p is S.One:\n            return (None, [])\n        (b, e) = p.as_base_exp()\n        if e.is_Integer:\n            if isinstance(b, gamma):\n                return (True, [b.args[0]] * e)\n            else:\n                return (False, [b] * e)\n        else:\n            return (False, [p])\n    newargs = list(ordered(expr.args))\n    while newargs:\n        (n, d) = newargs.pop().as_numer_denom()\n        (isg, l) = explicate(n)\n        if isg:\n            numer_gammas.extend(l)\n        elif isg is False:\n            numer_others.extend(l)\n        (isg, l) = explicate(d)\n        if isg:\n            denom_gammas.extend(l)\n        elif isg is False:\n            denom_others.extend(l)\n    if not as_comb:\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g1 = gammas.pop()\n                if g1.is_integer:\n                    new.append(g1)\n                    continue\n                for (i, g2) in enumerate(gammas):\n                    n = g1 + g2 - 1\n                    if not n.is_Integer:\n                        continue\n                    numer.append(S.Pi)\n                    denom.append(sin(S.Pi * g1))\n                    gammas.pop(i)\n                    if n > 0:\n                        for k in range(n):\n                            numer.append(1 - g1 + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            denom.append(-g1 - k)\n                    break\n                else:\n                    new.append(g1)\n            gammas[:] = new\n        for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n            while True:\n                for x in ng:\n                    for y in dg:\n                        n = x - 2 * y\n                        if n.is_Integer:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    break\n                ng.remove(x)\n                dg.remove(y)\n                if n > 0:\n                    for k in range(n):\n                        no.append(2 * y + k)\n                elif n < 0:\n                    for k in range(-n):\n                        do.append(2 * y - 1 - k)\n                ng.append(y + S.Half)\n                no.append(2 ** (2 * y - 1))\n                do.append(sqrt(S.Pi))\n\n        def _run(coeffs):\n            u = list(uniq(coeffs))\n            for i in range(len(u)):\n                dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                for (one, j) in dj:\n                    if one.p == 1 and one.q != 1:\n                        n = one.q\n                        got = [i]\n                        get = list(range(1, n))\n                        for (d, j) in dj:\n                            m = n * d\n                            if m.is_Integer and m in get:\n                                get.remove(m)\n                                got.append(j)\n                                if not get:\n                                    break\n                        else:\n                            continue\n                        for (i, j) in enumerate(got):\n                            c = u[j]\n                            coeffs.remove(c)\n                            got[i] = c\n                        return (one.q, got[0], got[1:])\n\n        def _mult_thm(gammas, numer, denom):\n            rats = {}\n            for g in gammas:\n                (c, resid) = g.as_coeff_Add()\n                rats.setdefault(resid, []).append(c)\n            keys = sorted(rats, key=default_sort_key)\n            for resid in keys:\n                coeffs = sorted(rats[resid])\n                new = []\n                while True:\n                    run = _run(coeffs)\n                    if run is None:\n                        break\n                    (n, ui, other) = run\n                    for u in other:\n                        con = resid + u - 1\n                        for k in range(int(u - ui)):\n                            numer.append(con - k)\n                    con = n * (resid + ui)\n                    numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                    new.append(con)\n                rats[resid] = [resid + c for c in coeffs] + new\n            g = []\n            for resid in keys:\n                g += rats[resid]\n            gammas[:] = g\n        for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            _mult_thm(l, numer, denom)\n    if level >= 2:\n\n        def find_fuzzy(l, x):\n            if not l:\n                return\n            (S1, T1) = compute_ST(x)\n            for y in l:\n                (S2, T2) = inv[y]\n                if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                    continue\n                a = len(cancel(x / y).free_symbols)\n                b = len(x.free_symbols)\n                c = len(y.free_symbols)\n                if a == 0 and (b > 0 or c > 0):\n                    return y\n        inv = {}\n\n        def compute_ST(expr):\n            if expr in inv:\n                return inv[expr]\n            return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n        def update_ST(expr):\n            inv[expr] = compute_ST(expr)\n        for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n            update_ST(expr)\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g = gammas.pop()\n                cont = True\n                while cont:\n                    cont = False\n                    y = find_fuzzy(numer, g)\n                    if y is not None:\n                        numer.remove(y)\n                        if y != g:\n                            numer.append(y / g)\n                            update_ST(y / g)\n                        g += 1\n                        cont = True\n                    y = find_fuzzy(denom, g - 1)\n                    if y is not None:\n                        denom.remove(y)\n                        if y != g - 1:\n                            numer.append((g - 1) / y)\n                            update_ST((g - 1) / y)\n                        g -= 1\n                        cont = True\n                new.append(g)\n            gammas[:] = new\n    return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)",
            "def rule_gamma(expr, level=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Simplify products of gamma functions further. '\n    if expr.is_Atom:\n        return expr\n\n    def gamma_rat(x):\n        was = x.count(gamma)\n        xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n        if xx.count(gamma) < was:\n            x = xx\n        return x\n\n    def gamma_factor(x):\n        if isinstance(x, gamma):\n            return True\n        if x.is_Add or x.is_Mul:\n            return any((gamma_factor(xi) for xi in x.args))\n        if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n            return gamma_factor(x.base)\n        return False\n    if level == 0:\n        expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n        level += 1\n    if not expr.is_Mul:\n        return expr\n    if level == 1:\n        (args, nc) = expr.args_cnc()\n        if not args:\n            return expr\n        if nc:\n            return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n        level += 1\n    if level == 2:\n        (T, F) = sift(expr.args, gamma_factor, binary=True)\n        gamma_ind = Mul(*F)\n        d = Mul(*T)\n        (nd, dd) = d.as_numer_denom()\n        for ipass in range(2):\n            args = list(ordered(Mul.make_args(nd)))\n            for (i, ni) in enumerate(args):\n                if ni.is_Add:\n                    (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                    args[i] = ni\n                    if not dd.has(gamma):\n                        break\n            nd = Mul(*args)\n            if ipass == 0 and (not gamma_factor(nd)):\n                break\n            (nd, dd) = (dd, nd)\n        expr = gamma_ind * nd / dd\n        if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n            return expr\n        level += 1\n    if level == 3:\n        while True:\n            was = expr\n            expr = rule_gamma(expr, 4)\n            if expr == was:\n                return expr\n    numer_gammas = []\n    denom_gammas = []\n    numer_others = []\n    denom_others = []\n\n    def explicate(p):\n        if p is S.One:\n            return (None, [])\n        (b, e) = p.as_base_exp()\n        if e.is_Integer:\n            if isinstance(b, gamma):\n                return (True, [b.args[0]] * e)\n            else:\n                return (False, [b] * e)\n        else:\n            return (False, [p])\n    newargs = list(ordered(expr.args))\n    while newargs:\n        (n, d) = newargs.pop().as_numer_denom()\n        (isg, l) = explicate(n)\n        if isg:\n            numer_gammas.extend(l)\n        elif isg is False:\n            numer_others.extend(l)\n        (isg, l) = explicate(d)\n        if isg:\n            denom_gammas.extend(l)\n        elif isg is False:\n            denom_others.extend(l)\n    if not as_comb:\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g1 = gammas.pop()\n                if g1.is_integer:\n                    new.append(g1)\n                    continue\n                for (i, g2) in enumerate(gammas):\n                    n = g1 + g2 - 1\n                    if not n.is_Integer:\n                        continue\n                    numer.append(S.Pi)\n                    denom.append(sin(S.Pi * g1))\n                    gammas.pop(i)\n                    if n > 0:\n                        for k in range(n):\n                            numer.append(1 - g1 + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            denom.append(-g1 - k)\n                    break\n                else:\n                    new.append(g1)\n            gammas[:] = new\n        for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n            while True:\n                for x in ng:\n                    for y in dg:\n                        n = x - 2 * y\n                        if n.is_Integer:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    break\n                ng.remove(x)\n                dg.remove(y)\n                if n > 0:\n                    for k in range(n):\n                        no.append(2 * y + k)\n                elif n < 0:\n                    for k in range(-n):\n                        do.append(2 * y - 1 - k)\n                ng.append(y + S.Half)\n                no.append(2 ** (2 * y - 1))\n                do.append(sqrt(S.Pi))\n\n        def _run(coeffs):\n            u = list(uniq(coeffs))\n            for i in range(len(u)):\n                dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                for (one, j) in dj:\n                    if one.p == 1 and one.q != 1:\n                        n = one.q\n                        got = [i]\n                        get = list(range(1, n))\n                        for (d, j) in dj:\n                            m = n * d\n                            if m.is_Integer and m in get:\n                                get.remove(m)\n                                got.append(j)\n                                if not get:\n                                    break\n                        else:\n                            continue\n                        for (i, j) in enumerate(got):\n                            c = u[j]\n                            coeffs.remove(c)\n                            got[i] = c\n                        return (one.q, got[0], got[1:])\n\n        def _mult_thm(gammas, numer, denom):\n            rats = {}\n            for g in gammas:\n                (c, resid) = g.as_coeff_Add()\n                rats.setdefault(resid, []).append(c)\n            keys = sorted(rats, key=default_sort_key)\n            for resid in keys:\n                coeffs = sorted(rats[resid])\n                new = []\n                while True:\n                    run = _run(coeffs)\n                    if run is None:\n                        break\n                    (n, ui, other) = run\n                    for u in other:\n                        con = resid + u - 1\n                        for k in range(int(u - ui)):\n                            numer.append(con - k)\n                    con = n * (resid + ui)\n                    numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                    new.append(con)\n                rats[resid] = [resid + c for c in coeffs] + new\n            g = []\n            for resid in keys:\n                g += rats[resid]\n            gammas[:] = g\n        for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            _mult_thm(l, numer, denom)\n    if level >= 2:\n\n        def find_fuzzy(l, x):\n            if not l:\n                return\n            (S1, T1) = compute_ST(x)\n            for y in l:\n                (S2, T2) = inv[y]\n                if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                    continue\n                a = len(cancel(x / y).free_symbols)\n                b = len(x.free_symbols)\n                c = len(y.free_symbols)\n                if a == 0 and (b > 0 or c > 0):\n                    return y\n        inv = {}\n\n        def compute_ST(expr):\n            if expr in inv:\n                return inv[expr]\n            return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n        def update_ST(expr):\n            inv[expr] = compute_ST(expr)\n        for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n            update_ST(expr)\n        for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n            new = []\n            while gammas:\n                g = gammas.pop()\n                cont = True\n                while cont:\n                    cont = False\n                    y = find_fuzzy(numer, g)\n                    if y is not None:\n                        numer.remove(y)\n                        if y != g:\n                            numer.append(y / g)\n                            update_ST(y / g)\n                        g += 1\n                        cont = True\n                    y = find_fuzzy(denom, g - 1)\n                    if y is not None:\n                        denom.remove(y)\n                        if y != g - 1:\n                            numer.append((g - 1) / y)\n                            update_ST((g - 1) / y)\n                        g -= 1\n                        cont = True\n                new.append(g)\n            gammas[:] = new\n    return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)"
        ]
    },
    {
        "func_name": "_gammasimp",
        "original": "def _gammasimp(expr, as_comb):\n    \"\"\"\n    Helper function for gammasimp and combsimp.\n\n    Explanation\n    ===========\n\n    Simplifies expressions written in terms of gamma function. If\n    as_comb is True, it tries to preserve integer arguments. See\n    docstring of gammasimp for more information. This was part of\n    combsimp() in combsimp.py.\n    \"\"\"\n    expr = expr.replace(gamma, lambda n: _rf(1, (n - 1).expand()))\n    if as_comb:\n        expr = expr.replace(_rf, lambda a, b: gamma(b + 1))\n    else:\n        expr = expr.replace(_rf, lambda a, b: gamma(a + b) / gamma(a))\n\n    def rule_gamma(expr, level=0):\n        \"\"\" Simplify products of gamma functions further. \"\"\"\n        if expr.is_Atom:\n            return expr\n\n        def gamma_rat(x):\n            was = x.count(gamma)\n            xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n            if xx.count(gamma) < was:\n                x = xx\n            return x\n\n        def gamma_factor(x):\n            if isinstance(x, gamma):\n                return True\n            if x.is_Add or x.is_Mul:\n                return any((gamma_factor(xi) for xi in x.args))\n            if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n                return gamma_factor(x.base)\n            return False\n        if level == 0:\n            expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n            level += 1\n        if not expr.is_Mul:\n            return expr\n        if level == 1:\n            (args, nc) = expr.args_cnc()\n            if not args:\n                return expr\n            if nc:\n                return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n            level += 1\n        if level == 2:\n            (T, F) = sift(expr.args, gamma_factor, binary=True)\n            gamma_ind = Mul(*F)\n            d = Mul(*T)\n            (nd, dd) = d.as_numer_denom()\n            for ipass in range(2):\n                args = list(ordered(Mul.make_args(nd)))\n                for (i, ni) in enumerate(args):\n                    if ni.is_Add:\n                        (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                        args[i] = ni\n                        if not dd.has(gamma):\n                            break\n                nd = Mul(*args)\n                if ipass == 0 and (not gamma_factor(nd)):\n                    break\n                (nd, dd) = (dd, nd)\n            expr = gamma_ind * nd / dd\n            if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n                return expr\n            level += 1\n        if level == 3:\n            while True:\n                was = expr\n                expr = rule_gamma(expr, 4)\n                if expr == was:\n                    return expr\n        numer_gammas = []\n        denom_gammas = []\n        numer_others = []\n        denom_others = []\n\n        def explicate(p):\n            if p is S.One:\n                return (None, [])\n            (b, e) = p.as_base_exp()\n            if e.is_Integer:\n                if isinstance(b, gamma):\n                    return (True, [b.args[0]] * e)\n                else:\n                    return (False, [b] * e)\n            else:\n                return (False, [p])\n        newargs = list(ordered(expr.args))\n        while newargs:\n            (n, d) = newargs.pop().as_numer_denom()\n            (isg, l) = explicate(n)\n            if isg:\n                numer_gammas.extend(l)\n            elif isg is False:\n                numer_others.extend(l)\n            (isg, l) = explicate(d)\n            if isg:\n                denom_gammas.extend(l)\n            elif isg is False:\n                denom_others.extend(l)\n        if not as_comb:\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g1 = gammas.pop()\n                    if g1.is_integer:\n                        new.append(g1)\n                        continue\n                    for (i, g2) in enumerate(gammas):\n                        n = g1 + g2 - 1\n                        if not n.is_Integer:\n                            continue\n                        numer.append(S.Pi)\n                        denom.append(sin(S.Pi * g1))\n                        gammas.pop(i)\n                        if n > 0:\n                            for k in range(n):\n                                numer.append(1 - g1 + k)\n                        elif n < 0:\n                            for k in range(-n):\n                                denom.append(-g1 - k)\n                        break\n                    else:\n                        new.append(g1)\n                gammas[:] = new\n            for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n                while True:\n                    for x in ng:\n                        for y in dg:\n                            n = x - 2 * y\n                            if n.is_Integer:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        break\n                    ng.remove(x)\n                    dg.remove(y)\n                    if n > 0:\n                        for k in range(n):\n                            no.append(2 * y + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            do.append(2 * y - 1 - k)\n                    ng.append(y + S.Half)\n                    no.append(2 ** (2 * y - 1))\n                    do.append(sqrt(S.Pi))\n\n            def _run(coeffs):\n                u = list(uniq(coeffs))\n                for i in range(len(u)):\n                    dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                    for (one, j) in dj:\n                        if one.p == 1 and one.q != 1:\n                            n = one.q\n                            got = [i]\n                            get = list(range(1, n))\n                            for (d, j) in dj:\n                                m = n * d\n                                if m.is_Integer and m in get:\n                                    get.remove(m)\n                                    got.append(j)\n                                    if not get:\n                                        break\n                            else:\n                                continue\n                            for (i, j) in enumerate(got):\n                                c = u[j]\n                                coeffs.remove(c)\n                                got[i] = c\n                            return (one.q, got[0], got[1:])\n\n            def _mult_thm(gammas, numer, denom):\n                rats = {}\n                for g in gammas:\n                    (c, resid) = g.as_coeff_Add()\n                    rats.setdefault(resid, []).append(c)\n                keys = sorted(rats, key=default_sort_key)\n                for resid in keys:\n                    coeffs = sorted(rats[resid])\n                    new = []\n                    while True:\n                        run = _run(coeffs)\n                        if run is None:\n                            break\n                        (n, ui, other) = run\n                        for u in other:\n                            con = resid + u - 1\n                            for k in range(int(u - ui)):\n                                numer.append(con - k)\n                        con = n * (resid + ui)\n                        numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                        new.append(con)\n                    rats[resid] = [resid + c for c in coeffs] + new\n                g = []\n                for resid in keys:\n                    g += rats[resid]\n                gammas[:] = g\n            for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                _mult_thm(l, numer, denom)\n        if level >= 2:\n\n            def find_fuzzy(l, x):\n                if not l:\n                    return\n                (S1, T1) = compute_ST(x)\n                for y in l:\n                    (S2, T2) = inv[y]\n                    if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                        continue\n                    a = len(cancel(x / y).free_symbols)\n                    b = len(x.free_symbols)\n                    c = len(y.free_symbols)\n                    if a == 0 and (b > 0 or c > 0):\n                        return y\n            inv = {}\n\n            def compute_ST(expr):\n                if expr in inv:\n                    return inv[expr]\n                return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n            def update_ST(expr):\n                inv[expr] = compute_ST(expr)\n            for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n                update_ST(expr)\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g = gammas.pop()\n                    cont = True\n                    while cont:\n                        cont = False\n                        y = find_fuzzy(numer, g)\n                        if y is not None:\n                            numer.remove(y)\n                            if y != g:\n                                numer.append(y / g)\n                                update_ST(y / g)\n                            g += 1\n                            cont = True\n                        y = find_fuzzy(denom, g - 1)\n                        if y is not None:\n                            denom.remove(y)\n                            if y != g - 1:\n                                numer.append((g - 1) / y)\n                                update_ST((g - 1) / y)\n                            g -= 1\n                            cont = True\n                    new.append(g)\n                gammas[:] = new\n        return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)\n    was = factor(expr)\n    expr = rule_gamma(was)\n    if expr != was:\n        expr = factor(expr)\n    expr = expr.replace(gamma, lambda n: expand_func(gamma(n)) if n.is_Rational else gamma(n))\n    return expr",
        "mutated": [
            "def _gammasimp(expr, as_comb):\n    if False:\n        i = 10\n    '\\n    Helper function for gammasimp and combsimp.\\n\\n    Explanation\\n    ===========\\n\\n    Simplifies expressions written in terms of gamma function. If\\n    as_comb is True, it tries to preserve integer arguments. See\\n    docstring of gammasimp for more information. This was part of\\n    combsimp() in combsimp.py.\\n    '\n    expr = expr.replace(gamma, lambda n: _rf(1, (n - 1).expand()))\n    if as_comb:\n        expr = expr.replace(_rf, lambda a, b: gamma(b + 1))\n    else:\n        expr = expr.replace(_rf, lambda a, b: gamma(a + b) / gamma(a))\n\n    def rule_gamma(expr, level=0):\n        \"\"\" Simplify products of gamma functions further. \"\"\"\n        if expr.is_Atom:\n            return expr\n\n        def gamma_rat(x):\n            was = x.count(gamma)\n            xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n            if xx.count(gamma) < was:\n                x = xx\n            return x\n\n        def gamma_factor(x):\n            if isinstance(x, gamma):\n                return True\n            if x.is_Add or x.is_Mul:\n                return any((gamma_factor(xi) for xi in x.args))\n            if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n                return gamma_factor(x.base)\n            return False\n        if level == 0:\n            expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n            level += 1\n        if not expr.is_Mul:\n            return expr\n        if level == 1:\n            (args, nc) = expr.args_cnc()\n            if not args:\n                return expr\n            if nc:\n                return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n            level += 1\n        if level == 2:\n            (T, F) = sift(expr.args, gamma_factor, binary=True)\n            gamma_ind = Mul(*F)\n            d = Mul(*T)\n            (nd, dd) = d.as_numer_denom()\n            for ipass in range(2):\n                args = list(ordered(Mul.make_args(nd)))\n                for (i, ni) in enumerate(args):\n                    if ni.is_Add:\n                        (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                        args[i] = ni\n                        if not dd.has(gamma):\n                            break\n                nd = Mul(*args)\n                if ipass == 0 and (not gamma_factor(nd)):\n                    break\n                (nd, dd) = (dd, nd)\n            expr = gamma_ind * nd / dd\n            if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n                return expr\n            level += 1\n        if level == 3:\n            while True:\n                was = expr\n                expr = rule_gamma(expr, 4)\n                if expr == was:\n                    return expr\n        numer_gammas = []\n        denom_gammas = []\n        numer_others = []\n        denom_others = []\n\n        def explicate(p):\n            if p is S.One:\n                return (None, [])\n            (b, e) = p.as_base_exp()\n            if e.is_Integer:\n                if isinstance(b, gamma):\n                    return (True, [b.args[0]] * e)\n                else:\n                    return (False, [b] * e)\n            else:\n                return (False, [p])\n        newargs = list(ordered(expr.args))\n        while newargs:\n            (n, d) = newargs.pop().as_numer_denom()\n            (isg, l) = explicate(n)\n            if isg:\n                numer_gammas.extend(l)\n            elif isg is False:\n                numer_others.extend(l)\n            (isg, l) = explicate(d)\n            if isg:\n                denom_gammas.extend(l)\n            elif isg is False:\n                denom_others.extend(l)\n        if not as_comb:\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g1 = gammas.pop()\n                    if g1.is_integer:\n                        new.append(g1)\n                        continue\n                    for (i, g2) in enumerate(gammas):\n                        n = g1 + g2 - 1\n                        if not n.is_Integer:\n                            continue\n                        numer.append(S.Pi)\n                        denom.append(sin(S.Pi * g1))\n                        gammas.pop(i)\n                        if n > 0:\n                            for k in range(n):\n                                numer.append(1 - g1 + k)\n                        elif n < 0:\n                            for k in range(-n):\n                                denom.append(-g1 - k)\n                        break\n                    else:\n                        new.append(g1)\n                gammas[:] = new\n            for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n                while True:\n                    for x in ng:\n                        for y in dg:\n                            n = x - 2 * y\n                            if n.is_Integer:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        break\n                    ng.remove(x)\n                    dg.remove(y)\n                    if n > 0:\n                        for k in range(n):\n                            no.append(2 * y + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            do.append(2 * y - 1 - k)\n                    ng.append(y + S.Half)\n                    no.append(2 ** (2 * y - 1))\n                    do.append(sqrt(S.Pi))\n\n            def _run(coeffs):\n                u = list(uniq(coeffs))\n                for i in range(len(u)):\n                    dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                    for (one, j) in dj:\n                        if one.p == 1 and one.q != 1:\n                            n = one.q\n                            got = [i]\n                            get = list(range(1, n))\n                            for (d, j) in dj:\n                                m = n * d\n                                if m.is_Integer and m in get:\n                                    get.remove(m)\n                                    got.append(j)\n                                    if not get:\n                                        break\n                            else:\n                                continue\n                            for (i, j) in enumerate(got):\n                                c = u[j]\n                                coeffs.remove(c)\n                                got[i] = c\n                            return (one.q, got[0], got[1:])\n\n            def _mult_thm(gammas, numer, denom):\n                rats = {}\n                for g in gammas:\n                    (c, resid) = g.as_coeff_Add()\n                    rats.setdefault(resid, []).append(c)\n                keys = sorted(rats, key=default_sort_key)\n                for resid in keys:\n                    coeffs = sorted(rats[resid])\n                    new = []\n                    while True:\n                        run = _run(coeffs)\n                        if run is None:\n                            break\n                        (n, ui, other) = run\n                        for u in other:\n                            con = resid + u - 1\n                            for k in range(int(u - ui)):\n                                numer.append(con - k)\n                        con = n * (resid + ui)\n                        numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                        new.append(con)\n                    rats[resid] = [resid + c for c in coeffs] + new\n                g = []\n                for resid in keys:\n                    g += rats[resid]\n                gammas[:] = g\n            for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                _mult_thm(l, numer, denom)\n        if level >= 2:\n\n            def find_fuzzy(l, x):\n                if not l:\n                    return\n                (S1, T1) = compute_ST(x)\n                for y in l:\n                    (S2, T2) = inv[y]\n                    if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                        continue\n                    a = len(cancel(x / y).free_symbols)\n                    b = len(x.free_symbols)\n                    c = len(y.free_symbols)\n                    if a == 0 and (b > 0 or c > 0):\n                        return y\n            inv = {}\n\n            def compute_ST(expr):\n                if expr in inv:\n                    return inv[expr]\n                return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n            def update_ST(expr):\n                inv[expr] = compute_ST(expr)\n            for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n                update_ST(expr)\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g = gammas.pop()\n                    cont = True\n                    while cont:\n                        cont = False\n                        y = find_fuzzy(numer, g)\n                        if y is not None:\n                            numer.remove(y)\n                            if y != g:\n                                numer.append(y / g)\n                                update_ST(y / g)\n                            g += 1\n                            cont = True\n                        y = find_fuzzy(denom, g - 1)\n                        if y is not None:\n                            denom.remove(y)\n                            if y != g - 1:\n                                numer.append((g - 1) / y)\n                                update_ST((g - 1) / y)\n                            g -= 1\n                            cont = True\n                    new.append(g)\n                gammas[:] = new\n        return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)\n    was = factor(expr)\n    expr = rule_gamma(was)\n    if expr != was:\n        expr = factor(expr)\n    expr = expr.replace(gamma, lambda n: expand_func(gamma(n)) if n.is_Rational else gamma(n))\n    return expr",
            "def _gammasimp(expr, as_comb):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function for gammasimp and combsimp.\\n\\n    Explanation\\n    ===========\\n\\n    Simplifies expressions written in terms of gamma function. If\\n    as_comb is True, it tries to preserve integer arguments. See\\n    docstring of gammasimp for more information. This was part of\\n    combsimp() in combsimp.py.\\n    '\n    expr = expr.replace(gamma, lambda n: _rf(1, (n - 1).expand()))\n    if as_comb:\n        expr = expr.replace(_rf, lambda a, b: gamma(b + 1))\n    else:\n        expr = expr.replace(_rf, lambda a, b: gamma(a + b) / gamma(a))\n\n    def rule_gamma(expr, level=0):\n        \"\"\" Simplify products of gamma functions further. \"\"\"\n        if expr.is_Atom:\n            return expr\n\n        def gamma_rat(x):\n            was = x.count(gamma)\n            xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n            if xx.count(gamma) < was:\n                x = xx\n            return x\n\n        def gamma_factor(x):\n            if isinstance(x, gamma):\n                return True\n            if x.is_Add or x.is_Mul:\n                return any((gamma_factor(xi) for xi in x.args))\n            if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n                return gamma_factor(x.base)\n            return False\n        if level == 0:\n            expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n            level += 1\n        if not expr.is_Mul:\n            return expr\n        if level == 1:\n            (args, nc) = expr.args_cnc()\n            if not args:\n                return expr\n            if nc:\n                return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n            level += 1\n        if level == 2:\n            (T, F) = sift(expr.args, gamma_factor, binary=True)\n            gamma_ind = Mul(*F)\n            d = Mul(*T)\n            (nd, dd) = d.as_numer_denom()\n            for ipass in range(2):\n                args = list(ordered(Mul.make_args(nd)))\n                for (i, ni) in enumerate(args):\n                    if ni.is_Add:\n                        (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                        args[i] = ni\n                        if not dd.has(gamma):\n                            break\n                nd = Mul(*args)\n                if ipass == 0 and (not gamma_factor(nd)):\n                    break\n                (nd, dd) = (dd, nd)\n            expr = gamma_ind * nd / dd\n            if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n                return expr\n            level += 1\n        if level == 3:\n            while True:\n                was = expr\n                expr = rule_gamma(expr, 4)\n                if expr == was:\n                    return expr\n        numer_gammas = []\n        denom_gammas = []\n        numer_others = []\n        denom_others = []\n\n        def explicate(p):\n            if p is S.One:\n                return (None, [])\n            (b, e) = p.as_base_exp()\n            if e.is_Integer:\n                if isinstance(b, gamma):\n                    return (True, [b.args[0]] * e)\n                else:\n                    return (False, [b] * e)\n            else:\n                return (False, [p])\n        newargs = list(ordered(expr.args))\n        while newargs:\n            (n, d) = newargs.pop().as_numer_denom()\n            (isg, l) = explicate(n)\n            if isg:\n                numer_gammas.extend(l)\n            elif isg is False:\n                numer_others.extend(l)\n            (isg, l) = explicate(d)\n            if isg:\n                denom_gammas.extend(l)\n            elif isg is False:\n                denom_others.extend(l)\n        if not as_comb:\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g1 = gammas.pop()\n                    if g1.is_integer:\n                        new.append(g1)\n                        continue\n                    for (i, g2) in enumerate(gammas):\n                        n = g1 + g2 - 1\n                        if not n.is_Integer:\n                            continue\n                        numer.append(S.Pi)\n                        denom.append(sin(S.Pi * g1))\n                        gammas.pop(i)\n                        if n > 0:\n                            for k in range(n):\n                                numer.append(1 - g1 + k)\n                        elif n < 0:\n                            for k in range(-n):\n                                denom.append(-g1 - k)\n                        break\n                    else:\n                        new.append(g1)\n                gammas[:] = new\n            for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n                while True:\n                    for x in ng:\n                        for y in dg:\n                            n = x - 2 * y\n                            if n.is_Integer:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        break\n                    ng.remove(x)\n                    dg.remove(y)\n                    if n > 0:\n                        for k in range(n):\n                            no.append(2 * y + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            do.append(2 * y - 1 - k)\n                    ng.append(y + S.Half)\n                    no.append(2 ** (2 * y - 1))\n                    do.append(sqrt(S.Pi))\n\n            def _run(coeffs):\n                u = list(uniq(coeffs))\n                for i in range(len(u)):\n                    dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                    for (one, j) in dj:\n                        if one.p == 1 and one.q != 1:\n                            n = one.q\n                            got = [i]\n                            get = list(range(1, n))\n                            for (d, j) in dj:\n                                m = n * d\n                                if m.is_Integer and m in get:\n                                    get.remove(m)\n                                    got.append(j)\n                                    if not get:\n                                        break\n                            else:\n                                continue\n                            for (i, j) in enumerate(got):\n                                c = u[j]\n                                coeffs.remove(c)\n                                got[i] = c\n                            return (one.q, got[0], got[1:])\n\n            def _mult_thm(gammas, numer, denom):\n                rats = {}\n                for g in gammas:\n                    (c, resid) = g.as_coeff_Add()\n                    rats.setdefault(resid, []).append(c)\n                keys = sorted(rats, key=default_sort_key)\n                for resid in keys:\n                    coeffs = sorted(rats[resid])\n                    new = []\n                    while True:\n                        run = _run(coeffs)\n                        if run is None:\n                            break\n                        (n, ui, other) = run\n                        for u in other:\n                            con = resid + u - 1\n                            for k in range(int(u - ui)):\n                                numer.append(con - k)\n                        con = n * (resid + ui)\n                        numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                        new.append(con)\n                    rats[resid] = [resid + c for c in coeffs] + new\n                g = []\n                for resid in keys:\n                    g += rats[resid]\n                gammas[:] = g\n            for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                _mult_thm(l, numer, denom)\n        if level >= 2:\n\n            def find_fuzzy(l, x):\n                if not l:\n                    return\n                (S1, T1) = compute_ST(x)\n                for y in l:\n                    (S2, T2) = inv[y]\n                    if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                        continue\n                    a = len(cancel(x / y).free_symbols)\n                    b = len(x.free_symbols)\n                    c = len(y.free_symbols)\n                    if a == 0 and (b > 0 or c > 0):\n                        return y\n            inv = {}\n\n            def compute_ST(expr):\n                if expr in inv:\n                    return inv[expr]\n                return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n            def update_ST(expr):\n                inv[expr] = compute_ST(expr)\n            for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n                update_ST(expr)\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g = gammas.pop()\n                    cont = True\n                    while cont:\n                        cont = False\n                        y = find_fuzzy(numer, g)\n                        if y is not None:\n                            numer.remove(y)\n                            if y != g:\n                                numer.append(y / g)\n                                update_ST(y / g)\n                            g += 1\n                            cont = True\n                        y = find_fuzzy(denom, g - 1)\n                        if y is not None:\n                            denom.remove(y)\n                            if y != g - 1:\n                                numer.append((g - 1) / y)\n                                update_ST((g - 1) / y)\n                            g -= 1\n                            cont = True\n                    new.append(g)\n                gammas[:] = new\n        return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)\n    was = factor(expr)\n    expr = rule_gamma(was)\n    if expr != was:\n        expr = factor(expr)\n    expr = expr.replace(gamma, lambda n: expand_func(gamma(n)) if n.is_Rational else gamma(n))\n    return expr",
            "def _gammasimp(expr, as_comb):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function for gammasimp and combsimp.\\n\\n    Explanation\\n    ===========\\n\\n    Simplifies expressions written in terms of gamma function. If\\n    as_comb is True, it tries to preserve integer arguments. See\\n    docstring of gammasimp for more information. This was part of\\n    combsimp() in combsimp.py.\\n    '\n    expr = expr.replace(gamma, lambda n: _rf(1, (n - 1).expand()))\n    if as_comb:\n        expr = expr.replace(_rf, lambda a, b: gamma(b + 1))\n    else:\n        expr = expr.replace(_rf, lambda a, b: gamma(a + b) / gamma(a))\n\n    def rule_gamma(expr, level=0):\n        \"\"\" Simplify products of gamma functions further. \"\"\"\n        if expr.is_Atom:\n            return expr\n\n        def gamma_rat(x):\n            was = x.count(gamma)\n            xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n            if xx.count(gamma) < was:\n                x = xx\n            return x\n\n        def gamma_factor(x):\n            if isinstance(x, gamma):\n                return True\n            if x.is_Add or x.is_Mul:\n                return any((gamma_factor(xi) for xi in x.args))\n            if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n                return gamma_factor(x.base)\n            return False\n        if level == 0:\n            expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n            level += 1\n        if not expr.is_Mul:\n            return expr\n        if level == 1:\n            (args, nc) = expr.args_cnc()\n            if not args:\n                return expr\n            if nc:\n                return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n            level += 1\n        if level == 2:\n            (T, F) = sift(expr.args, gamma_factor, binary=True)\n            gamma_ind = Mul(*F)\n            d = Mul(*T)\n            (nd, dd) = d.as_numer_denom()\n            for ipass in range(2):\n                args = list(ordered(Mul.make_args(nd)))\n                for (i, ni) in enumerate(args):\n                    if ni.is_Add:\n                        (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                        args[i] = ni\n                        if not dd.has(gamma):\n                            break\n                nd = Mul(*args)\n                if ipass == 0 and (not gamma_factor(nd)):\n                    break\n                (nd, dd) = (dd, nd)\n            expr = gamma_ind * nd / dd\n            if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n                return expr\n            level += 1\n        if level == 3:\n            while True:\n                was = expr\n                expr = rule_gamma(expr, 4)\n                if expr == was:\n                    return expr\n        numer_gammas = []\n        denom_gammas = []\n        numer_others = []\n        denom_others = []\n\n        def explicate(p):\n            if p is S.One:\n                return (None, [])\n            (b, e) = p.as_base_exp()\n            if e.is_Integer:\n                if isinstance(b, gamma):\n                    return (True, [b.args[0]] * e)\n                else:\n                    return (False, [b] * e)\n            else:\n                return (False, [p])\n        newargs = list(ordered(expr.args))\n        while newargs:\n            (n, d) = newargs.pop().as_numer_denom()\n            (isg, l) = explicate(n)\n            if isg:\n                numer_gammas.extend(l)\n            elif isg is False:\n                numer_others.extend(l)\n            (isg, l) = explicate(d)\n            if isg:\n                denom_gammas.extend(l)\n            elif isg is False:\n                denom_others.extend(l)\n        if not as_comb:\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g1 = gammas.pop()\n                    if g1.is_integer:\n                        new.append(g1)\n                        continue\n                    for (i, g2) in enumerate(gammas):\n                        n = g1 + g2 - 1\n                        if not n.is_Integer:\n                            continue\n                        numer.append(S.Pi)\n                        denom.append(sin(S.Pi * g1))\n                        gammas.pop(i)\n                        if n > 0:\n                            for k in range(n):\n                                numer.append(1 - g1 + k)\n                        elif n < 0:\n                            for k in range(-n):\n                                denom.append(-g1 - k)\n                        break\n                    else:\n                        new.append(g1)\n                gammas[:] = new\n            for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n                while True:\n                    for x in ng:\n                        for y in dg:\n                            n = x - 2 * y\n                            if n.is_Integer:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        break\n                    ng.remove(x)\n                    dg.remove(y)\n                    if n > 0:\n                        for k in range(n):\n                            no.append(2 * y + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            do.append(2 * y - 1 - k)\n                    ng.append(y + S.Half)\n                    no.append(2 ** (2 * y - 1))\n                    do.append(sqrt(S.Pi))\n\n            def _run(coeffs):\n                u = list(uniq(coeffs))\n                for i in range(len(u)):\n                    dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                    for (one, j) in dj:\n                        if one.p == 1 and one.q != 1:\n                            n = one.q\n                            got = [i]\n                            get = list(range(1, n))\n                            for (d, j) in dj:\n                                m = n * d\n                                if m.is_Integer and m in get:\n                                    get.remove(m)\n                                    got.append(j)\n                                    if not get:\n                                        break\n                            else:\n                                continue\n                            for (i, j) in enumerate(got):\n                                c = u[j]\n                                coeffs.remove(c)\n                                got[i] = c\n                            return (one.q, got[0], got[1:])\n\n            def _mult_thm(gammas, numer, denom):\n                rats = {}\n                for g in gammas:\n                    (c, resid) = g.as_coeff_Add()\n                    rats.setdefault(resid, []).append(c)\n                keys = sorted(rats, key=default_sort_key)\n                for resid in keys:\n                    coeffs = sorted(rats[resid])\n                    new = []\n                    while True:\n                        run = _run(coeffs)\n                        if run is None:\n                            break\n                        (n, ui, other) = run\n                        for u in other:\n                            con = resid + u - 1\n                            for k in range(int(u - ui)):\n                                numer.append(con - k)\n                        con = n * (resid + ui)\n                        numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                        new.append(con)\n                    rats[resid] = [resid + c for c in coeffs] + new\n                g = []\n                for resid in keys:\n                    g += rats[resid]\n                gammas[:] = g\n            for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                _mult_thm(l, numer, denom)\n        if level >= 2:\n\n            def find_fuzzy(l, x):\n                if not l:\n                    return\n                (S1, T1) = compute_ST(x)\n                for y in l:\n                    (S2, T2) = inv[y]\n                    if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                        continue\n                    a = len(cancel(x / y).free_symbols)\n                    b = len(x.free_symbols)\n                    c = len(y.free_symbols)\n                    if a == 0 and (b > 0 or c > 0):\n                        return y\n            inv = {}\n\n            def compute_ST(expr):\n                if expr in inv:\n                    return inv[expr]\n                return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n            def update_ST(expr):\n                inv[expr] = compute_ST(expr)\n            for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n                update_ST(expr)\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g = gammas.pop()\n                    cont = True\n                    while cont:\n                        cont = False\n                        y = find_fuzzy(numer, g)\n                        if y is not None:\n                            numer.remove(y)\n                            if y != g:\n                                numer.append(y / g)\n                                update_ST(y / g)\n                            g += 1\n                            cont = True\n                        y = find_fuzzy(denom, g - 1)\n                        if y is not None:\n                            denom.remove(y)\n                            if y != g - 1:\n                                numer.append((g - 1) / y)\n                                update_ST((g - 1) / y)\n                            g -= 1\n                            cont = True\n                    new.append(g)\n                gammas[:] = new\n        return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)\n    was = factor(expr)\n    expr = rule_gamma(was)\n    if expr != was:\n        expr = factor(expr)\n    expr = expr.replace(gamma, lambda n: expand_func(gamma(n)) if n.is_Rational else gamma(n))\n    return expr",
            "def _gammasimp(expr, as_comb):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function for gammasimp and combsimp.\\n\\n    Explanation\\n    ===========\\n\\n    Simplifies expressions written in terms of gamma function. If\\n    as_comb is True, it tries to preserve integer arguments. See\\n    docstring of gammasimp for more information. This was part of\\n    combsimp() in combsimp.py.\\n    '\n    expr = expr.replace(gamma, lambda n: _rf(1, (n - 1).expand()))\n    if as_comb:\n        expr = expr.replace(_rf, lambda a, b: gamma(b + 1))\n    else:\n        expr = expr.replace(_rf, lambda a, b: gamma(a + b) / gamma(a))\n\n    def rule_gamma(expr, level=0):\n        \"\"\" Simplify products of gamma functions further. \"\"\"\n        if expr.is_Atom:\n            return expr\n\n        def gamma_rat(x):\n            was = x.count(gamma)\n            xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n            if xx.count(gamma) < was:\n                x = xx\n            return x\n\n        def gamma_factor(x):\n            if isinstance(x, gamma):\n                return True\n            if x.is_Add or x.is_Mul:\n                return any((gamma_factor(xi) for xi in x.args))\n            if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n                return gamma_factor(x.base)\n            return False\n        if level == 0:\n            expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n            level += 1\n        if not expr.is_Mul:\n            return expr\n        if level == 1:\n            (args, nc) = expr.args_cnc()\n            if not args:\n                return expr\n            if nc:\n                return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n            level += 1\n        if level == 2:\n            (T, F) = sift(expr.args, gamma_factor, binary=True)\n            gamma_ind = Mul(*F)\n            d = Mul(*T)\n            (nd, dd) = d.as_numer_denom()\n            for ipass in range(2):\n                args = list(ordered(Mul.make_args(nd)))\n                for (i, ni) in enumerate(args):\n                    if ni.is_Add:\n                        (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                        args[i] = ni\n                        if not dd.has(gamma):\n                            break\n                nd = Mul(*args)\n                if ipass == 0 and (not gamma_factor(nd)):\n                    break\n                (nd, dd) = (dd, nd)\n            expr = gamma_ind * nd / dd\n            if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n                return expr\n            level += 1\n        if level == 3:\n            while True:\n                was = expr\n                expr = rule_gamma(expr, 4)\n                if expr == was:\n                    return expr\n        numer_gammas = []\n        denom_gammas = []\n        numer_others = []\n        denom_others = []\n\n        def explicate(p):\n            if p is S.One:\n                return (None, [])\n            (b, e) = p.as_base_exp()\n            if e.is_Integer:\n                if isinstance(b, gamma):\n                    return (True, [b.args[0]] * e)\n                else:\n                    return (False, [b] * e)\n            else:\n                return (False, [p])\n        newargs = list(ordered(expr.args))\n        while newargs:\n            (n, d) = newargs.pop().as_numer_denom()\n            (isg, l) = explicate(n)\n            if isg:\n                numer_gammas.extend(l)\n            elif isg is False:\n                numer_others.extend(l)\n            (isg, l) = explicate(d)\n            if isg:\n                denom_gammas.extend(l)\n            elif isg is False:\n                denom_others.extend(l)\n        if not as_comb:\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g1 = gammas.pop()\n                    if g1.is_integer:\n                        new.append(g1)\n                        continue\n                    for (i, g2) in enumerate(gammas):\n                        n = g1 + g2 - 1\n                        if not n.is_Integer:\n                            continue\n                        numer.append(S.Pi)\n                        denom.append(sin(S.Pi * g1))\n                        gammas.pop(i)\n                        if n > 0:\n                            for k in range(n):\n                                numer.append(1 - g1 + k)\n                        elif n < 0:\n                            for k in range(-n):\n                                denom.append(-g1 - k)\n                        break\n                    else:\n                        new.append(g1)\n                gammas[:] = new\n            for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n                while True:\n                    for x in ng:\n                        for y in dg:\n                            n = x - 2 * y\n                            if n.is_Integer:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        break\n                    ng.remove(x)\n                    dg.remove(y)\n                    if n > 0:\n                        for k in range(n):\n                            no.append(2 * y + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            do.append(2 * y - 1 - k)\n                    ng.append(y + S.Half)\n                    no.append(2 ** (2 * y - 1))\n                    do.append(sqrt(S.Pi))\n\n            def _run(coeffs):\n                u = list(uniq(coeffs))\n                for i in range(len(u)):\n                    dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                    for (one, j) in dj:\n                        if one.p == 1 and one.q != 1:\n                            n = one.q\n                            got = [i]\n                            get = list(range(1, n))\n                            for (d, j) in dj:\n                                m = n * d\n                                if m.is_Integer and m in get:\n                                    get.remove(m)\n                                    got.append(j)\n                                    if not get:\n                                        break\n                            else:\n                                continue\n                            for (i, j) in enumerate(got):\n                                c = u[j]\n                                coeffs.remove(c)\n                                got[i] = c\n                            return (one.q, got[0], got[1:])\n\n            def _mult_thm(gammas, numer, denom):\n                rats = {}\n                for g in gammas:\n                    (c, resid) = g.as_coeff_Add()\n                    rats.setdefault(resid, []).append(c)\n                keys = sorted(rats, key=default_sort_key)\n                for resid in keys:\n                    coeffs = sorted(rats[resid])\n                    new = []\n                    while True:\n                        run = _run(coeffs)\n                        if run is None:\n                            break\n                        (n, ui, other) = run\n                        for u in other:\n                            con = resid + u - 1\n                            for k in range(int(u - ui)):\n                                numer.append(con - k)\n                        con = n * (resid + ui)\n                        numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                        new.append(con)\n                    rats[resid] = [resid + c for c in coeffs] + new\n                g = []\n                for resid in keys:\n                    g += rats[resid]\n                gammas[:] = g\n            for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                _mult_thm(l, numer, denom)\n        if level >= 2:\n\n            def find_fuzzy(l, x):\n                if not l:\n                    return\n                (S1, T1) = compute_ST(x)\n                for y in l:\n                    (S2, T2) = inv[y]\n                    if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                        continue\n                    a = len(cancel(x / y).free_symbols)\n                    b = len(x.free_symbols)\n                    c = len(y.free_symbols)\n                    if a == 0 and (b > 0 or c > 0):\n                        return y\n            inv = {}\n\n            def compute_ST(expr):\n                if expr in inv:\n                    return inv[expr]\n                return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n            def update_ST(expr):\n                inv[expr] = compute_ST(expr)\n            for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n                update_ST(expr)\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g = gammas.pop()\n                    cont = True\n                    while cont:\n                        cont = False\n                        y = find_fuzzy(numer, g)\n                        if y is not None:\n                            numer.remove(y)\n                            if y != g:\n                                numer.append(y / g)\n                                update_ST(y / g)\n                            g += 1\n                            cont = True\n                        y = find_fuzzy(denom, g - 1)\n                        if y is not None:\n                            denom.remove(y)\n                            if y != g - 1:\n                                numer.append((g - 1) / y)\n                                update_ST((g - 1) / y)\n                            g -= 1\n                            cont = True\n                    new.append(g)\n                gammas[:] = new\n        return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)\n    was = factor(expr)\n    expr = rule_gamma(was)\n    if expr != was:\n        expr = factor(expr)\n    expr = expr.replace(gamma, lambda n: expand_func(gamma(n)) if n.is_Rational else gamma(n))\n    return expr",
            "def _gammasimp(expr, as_comb):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function for gammasimp and combsimp.\\n\\n    Explanation\\n    ===========\\n\\n    Simplifies expressions written in terms of gamma function. If\\n    as_comb is True, it tries to preserve integer arguments. See\\n    docstring of gammasimp for more information. This was part of\\n    combsimp() in combsimp.py.\\n    '\n    expr = expr.replace(gamma, lambda n: _rf(1, (n - 1).expand()))\n    if as_comb:\n        expr = expr.replace(_rf, lambda a, b: gamma(b + 1))\n    else:\n        expr = expr.replace(_rf, lambda a, b: gamma(a + b) / gamma(a))\n\n    def rule_gamma(expr, level=0):\n        \"\"\" Simplify products of gamma functions further. \"\"\"\n        if expr.is_Atom:\n            return expr\n\n        def gamma_rat(x):\n            was = x.count(gamma)\n            xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()).replace(_rf, lambda a, b: gamma(a + b) / gamma(a)))\n            if xx.count(gamma) < was:\n                x = xx\n            return x\n\n        def gamma_factor(x):\n            if isinstance(x, gamma):\n                return True\n            if x.is_Add or x.is_Mul:\n                return any((gamma_factor(xi) for xi in x.args))\n            if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n                return gamma_factor(x.base)\n            return False\n        if level == 0:\n            expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n            level += 1\n        if not expr.is_Mul:\n            return expr\n        if level == 1:\n            (args, nc) = expr.args_cnc()\n            if not args:\n                return expr\n            if nc:\n                return rule_gamma(Mul._from_args(args), level + 1) * Mul._from_args(nc)\n            level += 1\n        if level == 2:\n            (T, F) = sift(expr.args, gamma_factor, binary=True)\n            gamma_ind = Mul(*F)\n            d = Mul(*T)\n            (nd, dd) = d.as_numer_denom()\n            for ipass in range(2):\n                args = list(ordered(Mul.make_args(nd)))\n                for (i, ni) in enumerate(args):\n                    if ni.is_Add:\n                        (ni, dd) = Add(*[rule_gamma(gamma_rat(a / dd), level + 1) for a in ni.args]).as_numer_denom()\n                        args[i] = ni\n                        if not dd.has(gamma):\n                            break\n                nd = Mul(*args)\n                if ipass == 0 and (not gamma_factor(nd)):\n                    break\n                (nd, dd) = (dd, nd)\n            expr = gamma_ind * nd / dd\n            if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n                return expr\n            level += 1\n        if level == 3:\n            while True:\n                was = expr\n                expr = rule_gamma(expr, 4)\n                if expr == was:\n                    return expr\n        numer_gammas = []\n        denom_gammas = []\n        numer_others = []\n        denom_others = []\n\n        def explicate(p):\n            if p is S.One:\n                return (None, [])\n            (b, e) = p.as_base_exp()\n            if e.is_Integer:\n                if isinstance(b, gamma):\n                    return (True, [b.args[0]] * e)\n                else:\n                    return (False, [b] * e)\n            else:\n                return (False, [p])\n        newargs = list(ordered(expr.args))\n        while newargs:\n            (n, d) = newargs.pop().as_numer_denom()\n            (isg, l) = explicate(n)\n            if isg:\n                numer_gammas.extend(l)\n            elif isg is False:\n                numer_others.extend(l)\n            (isg, l) = explicate(d)\n            if isg:\n                denom_gammas.extend(l)\n            elif isg is False:\n                denom_others.extend(l)\n        if not as_comb:\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g1 = gammas.pop()\n                    if g1.is_integer:\n                        new.append(g1)\n                        continue\n                    for (i, g2) in enumerate(gammas):\n                        n = g1 + g2 - 1\n                        if not n.is_Integer:\n                            continue\n                        numer.append(S.Pi)\n                        denom.append(sin(S.Pi * g1))\n                        gammas.pop(i)\n                        if n > 0:\n                            for k in range(n):\n                                numer.append(1 - g1 + k)\n                        elif n < 0:\n                            for k in range(-n):\n                                denom.append(-g1 - k)\n                        break\n                    else:\n                        new.append(g1)\n                gammas[:] = new\n            for (ng, dg, no, do) in [(numer_gammas, denom_gammas, numer_others, denom_others), (denom_gammas, numer_gammas, denom_others, numer_others)]:\n                while True:\n                    for x in ng:\n                        for y in dg:\n                            n = x - 2 * y\n                            if n.is_Integer:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        break\n                    ng.remove(x)\n                    dg.remove(y)\n                    if n > 0:\n                        for k in range(n):\n                            no.append(2 * y + k)\n                    elif n < 0:\n                        for k in range(-n):\n                            do.append(2 * y - 1 - k)\n                    ng.append(y + S.Half)\n                    no.append(2 ** (2 * y - 1))\n                    do.append(sqrt(S.Pi))\n\n            def _run(coeffs):\n                u = list(uniq(coeffs))\n                for i in range(len(u)):\n                    dj = [((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))]\n                    for (one, j) in dj:\n                        if one.p == 1 and one.q != 1:\n                            n = one.q\n                            got = [i]\n                            get = list(range(1, n))\n                            for (d, j) in dj:\n                                m = n * d\n                                if m.is_Integer and m in get:\n                                    get.remove(m)\n                                    got.append(j)\n                                    if not get:\n                                        break\n                            else:\n                                continue\n                            for (i, j) in enumerate(got):\n                                c = u[j]\n                                coeffs.remove(c)\n                                got[i] = c\n                            return (one.q, got[0], got[1:])\n\n            def _mult_thm(gammas, numer, denom):\n                rats = {}\n                for g in gammas:\n                    (c, resid) = g.as_coeff_Add()\n                    rats.setdefault(resid, []).append(c)\n                keys = sorted(rats, key=default_sort_key)\n                for resid in keys:\n                    coeffs = sorted(rats[resid])\n                    new = []\n                    while True:\n                        run = _run(coeffs)\n                        if run is None:\n                            break\n                        (n, ui, other) = run\n                        for u in other:\n                            con = resid + u - 1\n                            for k in range(int(u - ui)):\n                                numer.append(con - k)\n                        con = n * (resid + ui)\n                        numer.append((2 * S.Pi) ** (S(n - 1) / 2) * n ** (S.Half - con))\n                        new.append(con)\n                    rats[resid] = [resid + c for c in coeffs] + new\n                g = []\n                for resid in keys:\n                    g += rats[resid]\n                gammas[:] = g\n            for (l, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                _mult_thm(l, numer, denom)\n        if level >= 2:\n\n            def find_fuzzy(l, x):\n                if not l:\n                    return\n                (S1, T1) = compute_ST(x)\n                for y in l:\n                    (S2, T2) = inv[y]\n                    if T1 != T2 or (not S1.intersection(S2) and (S1 != set() or S2 != set())):\n                        continue\n                    a = len(cancel(x / y).free_symbols)\n                    b = len(x.free_symbols)\n                    c = len(y.free_symbols)\n                    if a == 0 and (b > 0 or c > 0):\n                        return y\n            inv = {}\n\n            def compute_ST(expr):\n                if expr in inv:\n                    return inv[expr]\n                return (expr.free_symbols, expr.atoms(Function).union({e.exp for e in expr.atoms(Pow)}))\n\n            def update_ST(expr):\n                inv[expr] = compute_ST(expr)\n            for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n                update_ST(expr)\n            for (gammas, numer, denom) in [(numer_gammas, numer_others, denom_others), (denom_gammas, denom_others, numer_others)]:\n                new = []\n                while gammas:\n                    g = gammas.pop()\n                    cont = True\n                    while cont:\n                        cont = False\n                        y = find_fuzzy(numer, g)\n                        if y is not None:\n                            numer.remove(y)\n                            if y != g:\n                                numer.append(y / g)\n                                update_ST(y / g)\n                            g += 1\n                            cont = True\n                        y = find_fuzzy(denom, g - 1)\n                        if y is not None:\n                            denom.remove(y)\n                            if y != g - 1:\n                                numer.append((g - 1) / y)\n                                update_ST((g - 1) / y)\n                            g -= 1\n                            cont = True\n                    new.append(g)\n                gammas[:] = new\n        return Mul(*[gamma(g) for g in numer_gammas]) / Mul(*[gamma(g) for g in denom_gammas]) * Mul(*numer_others) / Mul(*denom_others)\n    was = factor(expr)\n    expr = rule_gamma(was)\n    if expr != was:\n        expr = factor(expr)\n    expr = expr.replace(gamma, lambda n: expand_func(gamma(n)) if n.is_Rational else gamma(n))\n    return expr"
        ]
    },
    {
        "func_name": "eval",
        "original": "@classmethod\ndef eval(cls, a, b):\n    if b.is_Integer:\n        if not b:\n            return S.One\n        n = int(b)\n        if n > 0:\n            return Mul(*[a + i for i in range(n)])\n        elif n < 0:\n            return 1 / Mul(*[a - i for i in range(1, -n + 1)])\n    else:\n        if b.is_Add:\n            (c, _b) = b.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(a, _b) * _rf(a + _b, c)\n                elif c < 0:\n                    return _rf(a, _b) / _rf(a + _b + c, -c)\n        if a.is_Add:\n            (c, _a) = a.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(_a, b) * _rf(_a + b, c) / _rf(_a, c)\n                elif c < 0:\n                    return _rf(_a, b) * _rf(_a + c, -c) / _rf(_a + b + c, -c)",
        "mutated": [
            "@classmethod\ndef eval(cls, a, b):\n    if False:\n        i = 10\n    if b.is_Integer:\n        if not b:\n            return S.One\n        n = int(b)\n        if n > 0:\n            return Mul(*[a + i for i in range(n)])\n        elif n < 0:\n            return 1 / Mul(*[a - i for i in range(1, -n + 1)])\n    else:\n        if b.is_Add:\n            (c, _b) = b.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(a, _b) * _rf(a + _b, c)\n                elif c < 0:\n                    return _rf(a, _b) / _rf(a + _b + c, -c)\n        if a.is_Add:\n            (c, _a) = a.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(_a, b) * _rf(_a + b, c) / _rf(_a, c)\n                elif c < 0:\n                    return _rf(_a, b) * _rf(_a + c, -c) / _rf(_a + b + c, -c)",
            "@classmethod\ndef eval(cls, a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if b.is_Integer:\n        if not b:\n            return S.One\n        n = int(b)\n        if n > 0:\n            return Mul(*[a + i for i in range(n)])\n        elif n < 0:\n            return 1 / Mul(*[a - i for i in range(1, -n + 1)])\n    else:\n        if b.is_Add:\n            (c, _b) = b.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(a, _b) * _rf(a + _b, c)\n                elif c < 0:\n                    return _rf(a, _b) / _rf(a + _b + c, -c)\n        if a.is_Add:\n            (c, _a) = a.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(_a, b) * _rf(_a + b, c) / _rf(_a, c)\n                elif c < 0:\n                    return _rf(_a, b) * _rf(_a + c, -c) / _rf(_a + b + c, -c)",
            "@classmethod\ndef eval(cls, a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if b.is_Integer:\n        if not b:\n            return S.One\n        n = int(b)\n        if n > 0:\n            return Mul(*[a + i for i in range(n)])\n        elif n < 0:\n            return 1 / Mul(*[a - i for i in range(1, -n + 1)])\n    else:\n        if b.is_Add:\n            (c, _b) = b.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(a, _b) * _rf(a + _b, c)\n                elif c < 0:\n                    return _rf(a, _b) / _rf(a + _b + c, -c)\n        if a.is_Add:\n            (c, _a) = a.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(_a, b) * _rf(_a + b, c) / _rf(_a, c)\n                elif c < 0:\n                    return _rf(_a, b) * _rf(_a + c, -c) / _rf(_a + b + c, -c)",
            "@classmethod\ndef eval(cls, a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if b.is_Integer:\n        if not b:\n            return S.One\n        n = int(b)\n        if n > 0:\n            return Mul(*[a + i for i in range(n)])\n        elif n < 0:\n            return 1 / Mul(*[a - i for i in range(1, -n + 1)])\n    else:\n        if b.is_Add:\n            (c, _b) = b.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(a, _b) * _rf(a + _b, c)\n                elif c < 0:\n                    return _rf(a, _b) / _rf(a + _b + c, -c)\n        if a.is_Add:\n            (c, _a) = a.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(_a, b) * _rf(_a + b, c) / _rf(_a, c)\n                elif c < 0:\n                    return _rf(_a, b) * _rf(_a + c, -c) / _rf(_a + b + c, -c)",
            "@classmethod\ndef eval(cls, a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if b.is_Integer:\n        if not b:\n            return S.One\n        n = int(b)\n        if n > 0:\n            return Mul(*[a + i for i in range(n)])\n        elif n < 0:\n            return 1 / Mul(*[a - i for i in range(1, -n + 1)])\n    else:\n        if b.is_Add:\n            (c, _b) = b.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(a, _b) * _rf(a + _b, c)\n                elif c < 0:\n                    return _rf(a, _b) / _rf(a + _b + c, -c)\n        if a.is_Add:\n            (c, _a) = a.as_coeff_Add()\n            if c.is_Integer:\n                if c > 0:\n                    return _rf(_a, b) * _rf(_a + b, c) / _rf(_a, c)\n                elif c < 0:\n                    return _rf(_a, b) * _rf(_a + c, -c) / _rf(_a + b + c, -c)"
        ]
    }
]