[
    {
        "func_name": "save_joints",
        "original": "def save_joints():\n    mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n    for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n        img_fn = anno['image']['name'][0, 0][0]\n        train_flag = int(train_flag)\n        if train_flag:\n            img_train_list.append(img_fn)\n            ann_train_list.append([])\n        else:\n            img_test_list.append(img_fn)\n            ann_test_list.append([])\n        head_rect = []\n        if 'x1' in str(anno['annorect'].dtype):\n            head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n        else:\n            head_rect = []\n        if 'annopoints' in str(anno['annorect'].dtype):\n            annopoints = anno['annorect']['annopoints'][0]\n            head_x1s = anno['annorect']['x1'][0]\n            head_y1s = anno['annorect']['y1'][0]\n            head_x2s = anno['annorect']['x2'][0]\n            head_y2s = anno['annorect']['y2'][0]\n            for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                if annopoint.size:\n                    head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                    annopoint = annopoint['point'][0, 0]\n                    j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                    x = [x[0, 0] for x in annopoint['x'][0]]\n                    y = [y[0, 0] for y in annopoint['y'][0]]\n                    joint_pos = {}\n                    for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                        joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                    if 'is_visible' in str(annopoint.dtype):\n                        vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                        vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                    else:\n                        vis = None\n                    if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                        data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                        if train_flag:\n                            ann_train_list[-1].append(data)\n                        else:\n                            ann_test_list[-1].append(data)",
        "mutated": [
            "def save_joints():\n    if False:\n        i = 10\n    mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n    for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n        img_fn = anno['image']['name'][0, 0][0]\n        train_flag = int(train_flag)\n        if train_flag:\n            img_train_list.append(img_fn)\n            ann_train_list.append([])\n        else:\n            img_test_list.append(img_fn)\n            ann_test_list.append([])\n        head_rect = []\n        if 'x1' in str(anno['annorect'].dtype):\n            head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n        else:\n            head_rect = []\n        if 'annopoints' in str(anno['annorect'].dtype):\n            annopoints = anno['annorect']['annopoints'][0]\n            head_x1s = anno['annorect']['x1'][0]\n            head_y1s = anno['annorect']['y1'][0]\n            head_x2s = anno['annorect']['x2'][0]\n            head_y2s = anno['annorect']['y2'][0]\n            for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                if annopoint.size:\n                    head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                    annopoint = annopoint['point'][0, 0]\n                    j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                    x = [x[0, 0] for x in annopoint['x'][0]]\n                    y = [y[0, 0] for y in annopoint['y'][0]]\n                    joint_pos = {}\n                    for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                        joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                    if 'is_visible' in str(annopoint.dtype):\n                        vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                        vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                    else:\n                        vis = None\n                    if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                        data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                        if train_flag:\n                            ann_train_list[-1].append(data)\n                        else:\n                            ann_test_list[-1].append(data)",
            "def save_joints():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n    for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n        img_fn = anno['image']['name'][0, 0][0]\n        train_flag = int(train_flag)\n        if train_flag:\n            img_train_list.append(img_fn)\n            ann_train_list.append([])\n        else:\n            img_test_list.append(img_fn)\n            ann_test_list.append([])\n        head_rect = []\n        if 'x1' in str(anno['annorect'].dtype):\n            head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n        else:\n            head_rect = []\n        if 'annopoints' in str(anno['annorect'].dtype):\n            annopoints = anno['annorect']['annopoints'][0]\n            head_x1s = anno['annorect']['x1'][0]\n            head_y1s = anno['annorect']['y1'][0]\n            head_x2s = anno['annorect']['x2'][0]\n            head_y2s = anno['annorect']['y2'][0]\n            for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                if annopoint.size:\n                    head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                    annopoint = annopoint['point'][0, 0]\n                    j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                    x = [x[0, 0] for x in annopoint['x'][0]]\n                    y = [y[0, 0] for y in annopoint['y'][0]]\n                    joint_pos = {}\n                    for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                        joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                    if 'is_visible' in str(annopoint.dtype):\n                        vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                        vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                    else:\n                        vis = None\n                    if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                        data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                        if train_flag:\n                            ann_train_list[-1].append(data)\n                        else:\n                            ann_test_list[-1].append(data)",
            "def save_joints():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n    for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n        img_fn = anno['image']['name'][0, 0][0]\n        train_flag = int(train_flag)\n        if train_flag:\n            img_train_list.append(img_fn)\n            ann_train_list.append([])\n        else:\n            img_test_list.append(img_fn)\n            ann_test_list.append([])\n        head_rect = []\n        if 'x1' in str(anno['annorect'].dtype):\n            head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n        else:\n            head_rect = []\n        if 'annopoints' in str(anno['annorect'].dtype):\n            annopoints = anno['annorect']['annopoints'][0]\n            head_x1s = anno['annorect']['x1'][0]\n            head_y1s = anno['annorect']['y1'][0]\n            head_x2s = anno['annorect']['x2'][0]\n            head_y2s = anno['annorect']['y2'][0]\n            for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                if annopoint.size:\n                    head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                    annopoint = annopoint['point'][0, 0]\n                    j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                    x = [x[0, 0] for x in annopoint['x'][0]]\n                    y = [y[0, 0] for y in annopoint['y'][0]]\n                    joint_pos = {}\n                    for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                        joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                    if 'is_visible' in str(annopoint.dtype):\n                        vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                        vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                    else:\n                        vis = None\n                    if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                        data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                        if train_flag:\n                            ann_train_list[-1].append(data)\n                        else:\n                            ann_test_list[-1].append(data)",
            "def save_joints():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n    for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n        img_fn = anno['image']['name'][0, 0][0]\n        train_flag = int(train_flag)\n        if train_flag:\n            img_train_list.append(img_fn)\n            ann_train_list.append([])\n        else:\n            img_test_list.append(img_fn)\n            ann_test_list.append([])\n        head_rect = []\n        if 'x1' in str(anno['annorect'].dtype):\n            head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n        else:\n            head_rect = []\n        if 'annopoints' in str(anno['annorect'].dtype):\n            annopoints = anno['annorect']['annopoints'][0]\n            head_x1s = anno['annorect']['x1'][0]\n            head_y1s = anno['annorect']['y1'][0]\n            head_x2s = anno['annorect']['x2'][0]\n            head_y2s = anno['annorect']['y2'][0]\n            for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                if annopoint.size:\n                    head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                    annopoint = annopoint['point'][0, 0]\n                    j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                    x = [x[0, 0] for x in annopoint['x'][0]]\n                    y = [y[0, 0] for y in annopoint['y'][0]]\n                    joint_pos = {}\n                    for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                        joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                    if 'is_visible' in str(annopoint.dtype):\n                        vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                        vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                    else:\n                        vis = None\n                    if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                        data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                        if train_flag:\n                            ann_train_list[-1].append(data)\n                        else:\n                            ann_test_list[-1].append(data)",
            "def save_joints():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n    for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n        img_fn = anno['image']['name'][0, 0][0]\n        train_flag = int(train_flag)\n        if train_flag:\n            img_train_list.append(img_fn)\n            ann_train_list.append([])\n        else:\n            img_test_list.append(img_fn)\n            ann_test_list.append([])\n        head_rect = []\n        if 'x1' in str(anno['annorect'].dtype):\n            head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n        else:\n            head_rect = []\n        if 'annopoints' in str(anno['annorect'].dtype):\n            annopoints = anno['annorect']['annopoints'][0]\n            head_x1s = anno['annorect']['x1'][0]\n            head_y1s = anno['annorect']['y1'][0]\n            head_x2s = anno['annorect']['x2'][0]\n            head_y2s = anno['annorect']['y2'][0]\n            for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                if annopoint.size:\n                    head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                    annopoint = annopoint['point'][0, 0]\n                    j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                    x = [x[0, 0] for x in annopoint['x'][0]]\n                    y = [y[0, 0] for y in annopoint['y'][0]]\n                    joint_pos = {}\n                    for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                        joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                    if 'is_visible' in str(annopoint.dtype):\n                        vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                        vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                    else:\n                        vis = None\n                    if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                        data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                        if train_flag:\n                            ann_train_list[-1].append(data)\n                        else:\n                            ann_test_list[-1].append(data)"
        ]
    },
    {
        "func_name": "load_mpii_pose_dataset",
        "original": "def load_mpii_pose_dataset(path='data', is_16_pos_only=False):\n    \"\"\"Load MPII Human Pose Dataset.\n\n    Parameters\n    -----------\n    path : str\n        The path that the data is downloaded to.\n    is_16_pos_only : boolean\n        If True, only return the peoples contain 16 pose keypoints. (Usually be used for single person pose estimation)\n\n    Returns\n    ----------\n    img_train_list : list of str\n        The image directories of training data.\n    ann_train_list : list of dict\n        The annotations of training data.\n    img_test_list : list of str\n        The image directories of testing data.\n    ann_test_list : list of dict\n        The annotations of testing data.\n\n    Examples\n    --------\n    >>> import pprint\n    >>> import tensorlayer as tl\n    >>> img_train_list, ann_train_list, img_test_list, ann_test_list = tl.files.load_mpii_pose_dataset()\n    >>> image = tl.vis.read_image(img_train_list[0])\n    >>> tl.vis.draw_mpii_pose_to_image(image, ann_train_list[0], 'image.png')\n    >>> pprint.pprint(ann_train_list[0])\n\n    References\n    -----------\n    - `MPII Human Pose Dataset. CVPR 14 <http://human-pose.mpi-inf.mpg.de>`__\n    - `MPII Human Pose Models. CVPR 16 <http://pose.mpi-inf.mpg.de>`__\n    - `MPII Human Shape, Poselet Conditioned Pictorial Structures and etc <http://pose.mpi-inf.mpg.de/#related>`__\n    - `MPII Keyponts and ID <http://human-pose.mpi-inf.mpg.de/#download>`__\n    \"\"\"\n    path = os.path.join(path, 'mpii_human_pose')\n    logging.info('Load or Download MPII Human Pose > {}'.format(path))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1_u12_2.zip'\n    extracted_filename = 'mpii_human_pose_v1_u12_2'\n    if folder_exists(os.path.join(path, extracted_filename)) is False:\n        logging.info('[MPII] (annotation) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1.tar.gz'\n    extracted_filename2 = 'images'\n    if folder_exists(os.path.join(path, extracted_filename2)) is False:\n        logging.info('[MPII] (images) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    import scipy.io as sio\n    logging.info('reading annotations from mat file ...')\n    ann_train_list = []\n    ann_test_list = []\n    img_train_list = []\n    img_test_list = []\n\n    def save_joints():\n        mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n        for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n            img_fn = anno['image']['name'][0, 0][0]\n            train_flag = int(train_flag)\n            if train_flag:\n                img_train_list.append(img_fn)\n                ann_train_list.append([])\n            else:\n                img_test_list.append(img_fn)\n                ann_test_list.append([])\n            head_rect = []\n            if 'x1' in str(anno['annorect'].dtype):\n                head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n            else:\n                head_rect = []\n            if 'annopoints' in str(anno['annorect'].dtype):\n                annopoints = anno['annorect']['annopoints'][0]\n                head_x1s = anno['annorect']['x1'][0]\n                head_y1s = anno['annorect']['y1'][0]\n                head_x2s = anno['annorect']['x2'][0]\n                head_y2s = anno['annorect']['y2'][0]\n                for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                    if annopoint.size:\n                        head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                        annopoint = annopoint['point'][0, 0]\n                        j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                        x = [x[0, 0] for x in annopoint['x'][0]]\n                        y = [y[0, 0] for y in annopoint['y'][0]]\n                        joint_pos = {}\n                        for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                            joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                        if 'is_visible' in str(annopoint.dtype):\n                            vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                            vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                        else:\n                            vis = None\n                        if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                            data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                            if train_flag:\n                                ann_train_list[-1].append(data)\n                            else:\n                                ann_test_list[-1].append(data)\n    save_joints()\n    logging.info('reading images list ...')\n    img_dir = os.path.join(path, extracted_filename2)\n    _img_list = load_file_list(path=os.path.join(path, extracted_filename2), regx='\\\\.jpg', printable=False)\n    for (i, im) in enumerate(img_train_list):\n        if im not in _img_list:\n            print('missing training image {} in {} (remove from img(ann)_train_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    for (i, im) in enumerate(img_test_list):\n        if im not in _img_list:\n            print('missing testing image {} in {} (remove from img(ann)_test_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    n_train_images = len(img_train_list)\n    n_test_images = len(img_test_list)\n    n_images = n_train_images + n_test_images\n    logging.info('n_images: {} n_train_images: {} n_test_images: {}'.format(n_images, n_train_images, n_test_images))\n    n_train_ann = len(ann_train_list)\n    n_test_ann = len(ann_test_list)\n    n_ann = n_train_ann + n_test_ann\n    logging.info('n_ann: {} n_train_ann: {} n_test_ann: {}'.format(n_ann, n_train_ann, n_test_ann))\n    n_train_people = len(sum(ann_train_list, []))\n    n_test_people = len(sum(ann_test_list, []))\n    n_people = n_train_people + n_test_people\n    logging.info('n_people: {} n_train_people: {} n_test_people: {}'.format(n_people, n_train_people, n_test_people))\n    for (i, value) in enumerate(img_train_list):\n        img_train_list[i] = os.path.join(img_dir, value)\n    for (i, value) in enumerate(img_test_list):\n        img_test_list[i] = os.path.join(img_dir, value)\n    return (img_train_list, ann_train_list, img_test_list, ann_test_list)",
        "mutated": [
            "def load_mpii_pose_dataset(path='data', is_16_pos_only=False):\n    if False:\n        i = 10\n    \"Load MPII Human Pose Dataset.\\n\\n    Parameters\\n    -----------\\n    path : str\\n        The path that the data is downloaded to.\\n    is_16_pos_only : boolean\\n        If True, only return the peoples contain 16 pose keypoints. (Usually be used for single person pose estimation)\\n\\n    Returns\\n    ----------\\n    img_train_list : list of str\\n        The image directories of training data.\\n    ann_train_list : list of dict\\n        The annotations of training data.\\n    img_test_list : list of str\\n        The image directories of testing data.\\n    ann_test_list : list of dict\\n        The annotations of testing data.\\n\\n    Examples\\n    --------\\n    >>> import pprint\\n    >>> import tensorlayer as tl\\n    >>> img_train_list, ann_train_list, img_test_list, ann_test_list = tl.files.load_mpii_pose_dataset()\\n    >>> image = tl.vis.read_image(img_train_list[0])\\n    >>> tl.vis.draw_mpii_pose_to_image(image, ann_train_list[0], 'image.png')\\n    >>> pprint.pprint(ann_train_list[0])\\n\\n    References\\n    -----------\\n    - `MPII Human Pose Dataset. CVPR 14 <http://human-pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Pose Models. CVPR 16 <http://pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Shape, Poselet Conditioned Pictorial Structures and etc <http://pose.mpi-inf.mpg.de/#related>`__\\n    - `MPII Keyponts and ID <http://human-pose.mpi-inf.mpg.de/#download>`__\\n    \"\n    path = os.path.join(path, 'mpii_human_pose')\n    logging.info('Load or Download MPII Human Pose > {}'.format(path))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1_u12_2.zip'\n    extracted_filename = 'mpii_human_pose_v1_u12_2'\n    if folder_exists(os.path.join(path, extracted_filename)) is False:\n        logging.info('[MPII] (annotation) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1.tar.gz'\n    extracted_filename2 = 'images'\n    if folder_exists(os.path.join(path, extracted_filename2)) is False:\n        logging.info('[MPII] (images) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    import scipy.io as sio\n    logging.info('reading annotations from mat file ...')\n    ann_train_list = []\n    ann_test_list = []\n    img_train_list = []\n    img_test_list = []\n\n    def save_joints():\n        mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n        for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n            img_fn = anno['image']['name'][0, 0][0]\n            train_flag = int(train_flag)\n            if train_flag:\n                img_train_list.append(img_fn)\n                ann_train_list.append([])\n            else:\n                img_test_list.append(img_fn)\n                ann_test_list.append([])\n            head_rect = []\n            if 'x1' in str(anno['annorect'].dtype):\n                head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n            else:\n                head_rect = []\n            if 'annopoints' in str(anno['annorect'].dtype):\n                annopoints = anno['annorect']['annopoints'][0]\n                head_x1s = anno['annorect']['x1'][0]\n                head_y1s = anno['annorect']['y1'][0]\n                head_x2s = anno['annorect']['x2'][0]\n                head_y2s = anno['annorect']['y2'][0]\n                for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                    if annopoint.size:\n                        head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                        annopoint = annopoint['point'][0, 0]\n                        j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                        x = [x[0, 0] for x in annopoint['x'][0]]\n                        y = [y[0, 0] for y in annopoint['y'][0]]\n                        joint_pos = {}\n                        for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                            joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                        if 'is_visible' in str(annopoint.dtype):\n                            vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                            vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                        else:\n                            vis = None\n                        if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                            data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                            if train_flag:\n                                ann_train_list[-1].append(data)\n                            else:\n                                ann_test_list[-1].append(data)\n    save_joints()\n    logging.info('reading images list ...')\n    img_dir = os.path.join(path, extracted_filename2)\n    _img_list = load_file_list(path=os.path.join(path, extracted_filename2), regx='\\\\.jpg', printable=False)\n    for (i, im) in enumerate(img_train_list):\n        if im not in _img_list:\n            print('missing training image {} in {} (remove from img(ann)_train_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    for (i, im) in enumerate(img_test_list):\n        if im not in _img_list:\n            print('missing testing image {} in {} (remove from img(ann)_test_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    n_train_images = len(img_train_list)\n    n_test_images = len(img_test_list)\n    n_images = n_train_images + n_test_images\n    logging.info('n_images: {} n_train_images: {} n_test_images: {}'.format(n_images, n_train_images, n_test_images))\n    n_train_ann = len(ann_train_list)\n    n_test_ann = len(ann_test_list)\n    n_ann = n_train_ann + n_test_ann\n    logging.info('n_ann: {} n_train_ann: {} n_test_ann: {}'.format(n_ann, n_train_ann, n_test_ann))\n    n_train_people = len(sum(ann_train_list, []))\n    n_test_people = len(sum(ann_test_list, []))\n    n_people = n_train_people + n_test_people\n    logging.info('n_people: {} n_train_people: {} n_test_people: {}'.format(n_people, n_train_people, n_test_people))\n    for (i, value) in enumerate(img_train_list):\n        img_train_list[i] = os.path.join(img_dir, value)\n    for (i, value) in enumerate(img_test_list):\n        img_test_list[i] = os.path.join(img_dir, value)\n    return (img_train_list, ann_train_list, img_test_list, ann_test_list)",
            "def load_mpii_pose_dataset(path='data', is_16_pos_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Load MPII Human Pose Dataset.\\n\\n    Parameters\\n    -----------\\n    path : str\\n        The path that the data is downloaded to.\\n    is_16_pos_only : boolean\\n        If True, only return the peoples contain 16 pose keypoints. (Usually be used for single person pose estimation)\\n\\n    Returns\\n    ----------\\n    img_train_list : list of str\\n        The image directories of training data.\\n    ann_train_list : list of dict\\n        The annotations of training data.\\n    img_test_list : list of str\\n        The image directories of testing data.\\n    ann_test_list : list of dict\\n        The annotations of testing data.\\n\\n    Examples\\n    --------\\n    >>> import pprint\\n    >>> import tensorlayer as tl\\n    >>> img_train_list, ann_train_list, img_test_list, ann_test_list = tl.files.load_mpii_pose_dataset()\\n    >>> image = tl.vis.read_image(img_train_list[0])\\n    >>> tl.vis.draw_mpii_pose_to_image(image, ann_train_list[0], 'image.png')\\n    >>> pprint.pprint(ann_train_list[0])\\n\\n    References\\n    -----------\\n    - `MPII Human Pose Dataset. CVPR 14 <http://human-pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Pose Models. CVPR 16 <http://pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Shape, Poselet Conditioned Pictorial Structures and etc <http://pose.mpi-inf.mpg.de/#related>`__\\n    - `MPII Keyponts and ID <http://human-pose.mpi-inf.mpg.de/#download>`__\\n    \"\n    path = os.path.join(path, 'mpii_human_pose')\n    logging.info('Load or Download MPII Human Pose > {}'.format(path))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1_u12_2.zip'\n    extracted_filename = 'mpii_human_pose_v1_u12_2'\n    if folder_exists(os.path.join(path, extracted_filename)) is False:\n        logging.info('[MPII] (annotation) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1.tar.gz'\n    extracted_filename2 = 'images'\n    if folder_exists(os.path.join(path, extracted_filename2)) is False:\n        logging.info('[MPII] (images) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    import scipy.io as sio\n    logging.info('reading annotations from mat file ...')\n    ann_train_list = []\n    ann_test_list = []\n    img_train_list = []\n    img_test_list = []\n\n    def save_joints():\n        mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n        for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n            img_fn = anno['image']['name'][0, 0][0]\n            train_flag = int(train_flag)\n            if train_flag:\n                img_train_list.append(img_fn)\n                ann_train_list.append([])\n            else:\n                img_test_list.append(img_fn)\n                ann_test_list.append([])\n            head_rect = []\n            if 'x1' in str(anno['annorect'].dtype):\n                head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n            else:\n                head_rect = []\n            if 'annopoints' in str(anno['annorect'].dtype):\n                annopoints = anno['annorect']['annopoints'][0]\n                head_x1s = anno['annorect']['x1'][0]\n                head_y1s = anno['annorect']['y1'][0]\n                head_x2s = anno['annorect']['x2'][0]\n                head_y2s = anno['annorect']['y2'][0]\n                for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                    if annopoint.size:\n                        head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                        annopoint = annopoint['point'][0, 0]\n                        j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                        x = [x[0, 0] for x in annopoint['x'][0]]\n                        y = [y[0, 0] for y in annopoint['y'][0]]\n                        joint_pos = {}\n                        for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                            joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                        if 'is_visible' in str(annopoint.dtype):\n                            vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                            vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                        else:\n                            vis = None\n                        if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                            data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                            if train_flag:\n                                ann_train_list[-1].append(data)\n                            else:\n                                ann_test_list[-1].append(data)\n    save_joints()\n    logging.info('reading images list ...')\n    img_dir = os.path.join(path, extracted_filename2)\n    _img_list = load_file_list(path=os.path.join(path, extracted_filename2), regx='\\\\.jpg', printable=False)\n    for (i, im) in enumerate(img_train_list):\n        if im not in _img_list:\n            print('missing training image {} in {} (remove from img(ann)_train_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    for (i, im) in enumerate(img_test_list):\n        if im not in _img_list:\n            print('missing testing image {} in {} (remove from img(ann)_test_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    n_train_images = len(img_train_list)\n    n_test_images = len(img_test_list)\n    n_images = n_train_images + n_test_images\n    logging.info('n_images: {} n_train_images: {} n_test_images: {}'.format(n_images, n_train_images, n_test_images))\n    n_train_ann = len(ann_train_list)\n    n_test_ann = len(ann_test_list)\n    n_ann = n_train_ann + n_test_ann\n    logging.info('n_ann: {} n_train_ann: {} n_test_ann: {}'.format(n_ann, n_train_ann, n_test_ann))\n    n_train_people = len(sum(ann_train_list, []))\n    n_test_people = len(sum(ann_test_list, []))\n    n_people = n_train_people + n_test_people\n    logging.info('n_people: {} n_train_people: {} n_test_people: {}'.format(n_people, n_train_people, n_test_people))\n    for (i, value) in enumerate(img_train_list):\n        img_train_list[i] = os.path.join(img_dir, value)\n    for (i, value) in enumerate(img_test_list):\n        img_test_list[i] = os.path.join(img_dir, value)\n    return (img_train_list, ann_train_list, img_test_list, ann_test_list)",
            "def load_mpii_pose_dataset(path='data', is_16_pos_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Load MPII Human Pose Dataset.\\n\\n    Parameters\\n    -----------\\n    path : str\\n        The path that the data is downloaded to.\\n    is_16_pos_only : boolean\\n        If True, only return the peoples contain 16 pose keypoints. (Usually be used for single person pose estimation)\\n\\n    Returns\\n    ----------\\n    img_train_list : list of str\\n        The image directories of training data.\\n    ann_train_list : list of dict\\n        The annotations of training data.\\n    img_test_list : list of str\\n        The image directories of testing data.\\n    ann_test_list : list of dict\\n        The annotations of testing data.\\n\\n    Examples\\n    --------\\n    >>> import pprint\\n    >>> import tensorlayer as tl\\n    >>> img_train_list, ann_train_list, img_test_list, ann_test_list = tl.files.load_mpii_pose_dataset()\\n    >>> image = tl.vis.read_image(img_train_list[0])\\n    >>> tl.vis.draw_mpii_pose_to_image(image, ann_train_list[0], 'image.png')\\n    >>> pprint.pprint(ann_train_list[0])\\n\\n    References\\n    -----------\\n    - `MPII Human Pose Dataset. CVPR 14 <http://human-pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Pose Models. CVPR 16 <http://pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Shape, Poselet Conditioned Pictorial Structures and etc <http://pose.mpi-inf.mpg.de/#related>`__\\n    - `MPII Keyponts and ID <http://human-pose.mpi-inf.mpg.de/#download>`__\\n    \"\n    path = os.path.join(path, 'mpii_human_pose')\n    logging.info('Load or Download MPII Human Pose > {}'.format(path))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1_u12_2.zip'\n    extracted_filename = 'mpii_human_pose_v1_u12_2'\n    if folder_exists(os.path.join(path, extracted_filename)) is False:\n        logging.info('[MPII] (annotation) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1.tar.gz'\n    extracted_filename2 = 'images'\n    if folder_exists(os.path.join(path, extracted_filename2)) is False:\n        logging.info('[MPII] (images) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    import scipy.io as sio\n    logging.info('reading annotations from mat file ...')\n    ann_train_list = []\n    ann_test_list = []\n    img_train_list = []\n    img_test_list = []\n\n    def save_joints():\n        mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n        for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n            img_fn = anno['image']['name'][0, 0][0]\n            train_flag = int(train_flag)\n            if train_flag:\n                img_train_list.append(img_fn)\n                ann_train_list.append([])\n            else:\n                img_test_list.append(img_fn)\n                ann_test_list.append([])\n            head_rect = []\n            if 'x1' in str(anno['annorect'].dtype):\n                head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n            else:\n                head_rect = []\n            if 'annopoints' in str(anno['annorect'].dtype):\n                annopoints = anno['annorect']['annopoints'][0]\n                head_x1s = anno['annorect']['x1'][0]\n                head_y1s = anno['annorect']['y1'][0]\n                head_x2s = anno['annorect']['x2'][0]\n                head_y2s = anno['annorect']['y2'][0]\n                for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                    if annopoint.size:\n                        head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                        annopoint = annopoint['point'][0, 0]\n                        j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                        x = [x[0, 0] for x in annopoint['x'][0]]\n                        y = [y[0, 0] for y in annopoint['y'][0]]\n                        joint_pos = {}\n                        for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                            joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                        if 'is_visible' in str(annopoint.dtype):\n                            vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                            vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                        else:\n                            vis = None\n                        if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                            data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                            if train_flag:\n                                ann_train_list[-1].append(data)\n                            else:\n                                ann_test_list[-1].append(data)\n    save_joints()\n    logging.info('reading images list ...')\n    img_dir = os.path.join(path, extracted_filename2)\n    _img_list = load_file_list(path=os.path.join(path, extracted_filename2), regx='\\\\.jpg', printable=False)\n    for (i, im) in enumerate(img_train_list):\n        if im not in _img_list:\n            print('missing training image {} in {} (remove from img(ann)_train_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    for (i, im) in enumerate(img_test_list):\n        if im not in _img_list:\n            print('missing testing image {} in {} (remove from img(ann)_test_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    n_train_images = len(img_train_list)\n    n_test_images = len(img_test_list)\n    n_images = n_train_images + n_test_images\n    logging.info('n_images: {} n_train_images: {} n_test_images: {}'.format(n_images, n_train_images, n_test_images))\n    n_train_ann = len(ann_train_list)\n    n_test_ann = len(ann_test_list)\n    n_ann = n_train_ann + n_test_ann\n    logging.info('n_ann: {} n_train_ann: {} n_test_ann: {}'.format(n_ann, n_train_ann, n_test_ann))\n    n_train_people = len(sum(ann_train_list, []))\n    n_test_people = len(sum(ann_test_list, []))\n    n_people = n_train_people + n_test_people\n    logging.info('n_people: {} n_train_people: {} n_test_people: {}'.format(n_people, n_train_people, n_test_people))\n    for (i, value) in enumerate(img_train_list):\n        img_train_list[i] = os.path.join(img_dir, value)\n    for (i, value) in enumerate(img_test_list):\n        img_test_list[i] = os.path.join(img_dir, value)\n    return (img_train_list, ann_train_list, img_test_list, ann_test_list)",
            "def load_mpii_pose_dataset(path='data', is_16_pos_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Load MPII Human Pose Dataset.\\n\\n    Parameters\\n    -----------\\n    path : str\\n        The path that the data is downloaded to.\\n    is_16_pos_only : boolean\\n        If True, only return the peoples contain 16 pose keypoints. (Usually be used for single person pose estimation)\\n\\n    Returns\\n    ----------\\n    img_train_list : list of str\\n        The image directories of training data.\\n    ann_train_list : list of dict\\n        The annotations of training data.\\n    img_test_list : list of str\\n        The image directories of testing data.\\n    ann_test_list : list of dict\\n        The annotations of testing data.\\n\\n    Examples\\n    --------\\n    >>> import pprint\\n    >>> import tensorlayer as tl\\n    >>> img_train_list, ann_train_list, img_test_list, ann_test_list = tl.files.load_mpii_pose_dataset()\\n    >>> image = tl.vis.read_image(img_train_list[0])\\n    >>> tl.vis.draw_mpii_pose_to_image(image, ann_train_list[0], 'image.png')\\n    >>> pprint.pprint(ann_train_list[0])\\n\\n    References\\n    -----------\\n    - `MPII Human Pose Dataset. CVPR 14 <http://human-pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Pose Models. CVPR 16 <http://pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Shape, Poselet Conditioned Pictorial Structures and etc <http://pose.mpi-inf.mpg.de/#related>`__\\n    - `MPII Keyponts and ID <http://human-pose.mpi-inf.mpg.de/#download>`__\\n    \"\n    path = os.path.join(path, 'mpii_human_pose')\n    logging.info('Load or Download MPII Human Pose > {}'.format(path))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1_u12_2.zip'\n    extracted_filename = 'mpii_human_pose_v1_u12_2'\n    if folder_exists(os.path.join(path, extracted_filename)) is False:\n        logging.info('[MPII] (annotation) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1.tar.gz'\n    extracted_filename2 = 'images'\n    if folder_exists(os.path.join(path, extracted_filename2)) is False:\n        logging.info('[MPII] (images) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    import scipy.io as sio\n    logging.info('reading annotations from mat file ...')\n    ann_train_list = []\n    ann_test_list = []\n    img_train_list = []\n    img_test_list = []\n\n    def save_joints():\n        mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n        for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n            img_fn = anno['image']['name'][0, 0][0]\n            train_flag = int(train_flag)\n            if train_flag:\n                img_train_list.append(img_fn)\n                ann_train_list.append([])\n            else:\n                img_test_list.append(img_fn)\n                ann_test_list.append([])\n            head_rect = []\n            if 'x1' in str(anno['annorect'].dtype):\n                head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n            else:\n                head_rect = []\n            if 'annopoints' in str(anno['annorect'].dtype):\n                annopoints = anno['annorect']['annopoints'][0]\n                head_x1s = anno['annorect']['x1'][0]\n                head_y1s = anno['annorect']['y1'][0]\n                head_x2s = anno['annorect']['x2'][0]\n                head_y2s = anno['annorect']['y2'][0]\n                for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                    if annopoint.size:\n                        head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                        annopoint = annopoint['point'][0, 0]\n                        j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                        x = [x[0, 0] for x in annopoint['x'][0]]\n                        y = [y[0, 0] for y in annopoint['y'][0]]\n                        joint_pos = {}\n                        for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                            joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                        if 'is_visible' in str(annopoint.dtype):\n                            vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                            vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                        else:\n                            vis = None\n                        if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                            data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                            if train_flag:\n                                ann_train_list[-1].append(data)\n                            else:\n                                ann_test_list[-1].append(data)\n    save_joints()\n    logging.info('reading images list ...')\n    img_dir = os.path.join(path, extracted_filename2)\n    _img_list = load_file_list(path=os.path.join(path, extracted_filename2), regx='\\\\.jpg', printable=False)\n    for (i, im) in enumerate(img_train_list):\n        if im not in _img_list:\n            print('missing training image {} in {} (remove from img(ann)_train_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    for (i, im) in enumerate(img_test_list):\n        if im not in _img_list:\n            print('missing testing image {} in {} (remove from img(ann)_test_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    n_train_images = len(img_train_list)\n    n_test_images = len(img_test_list)\n    n_images = n_train_images + n_test_images\n    logging.info('n_images: {} n_train_images: {} n_test_images: {}'.format(n_images, n_train_images, n_test_images))\n    n_train_ann = len(ann_train_list)\n    n_test_ann = len(ann_test_list)\n    n_ann = n_train_ann + n_test_ann\n    logging.info('n_ann: {} n_train_ann: {} n_test_ann: {}'.format(n_ann, n_train_ann, n_test_ann))\n    n_train_people = len(sum(ann_train_list, []))\n    n_test_people = len(sum(ann_test_list, []))\n    n_people = n_train_people + n_test_people\n    logging.info('n_people: {} n_train_people: {} n_test_people: {}'.format(n_people, n_train_people, n_test_people))\n    for (i, value) in enumerate(img_train_list):\n        img_train_list[i] = os.path.join(img_dir, value)\n    for (i, value) in enumerate(img_test_list):\n        img_test_list[i] = os.path.join(img_dir, value)\n    return (img_train_list, ann_train_list, img_test_list, ann_test_list)",
            "def load_mpii_pose_dataset(path='data', is_16_pos_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Load MPII Human Pose Dataset.\\n\\n    Parameters\\n    -----------\\n    path : str\\n        The path that the data is downloaded to.\\n    is_16_pos_only : boolean\\n        If True, only return the peoples contain 16 pose keypoints. (Usually be used for single person pose estimation)\\n\\n    Returns\\n    ----------\\n    img_train_list : list of str\\n        The image directories of training data.\\n    ann_train_list : list of dict\\n        The annotations of training data.\\n    img_test_list : list of str\\n        The image directories of testing data.\\n    ann_test_list : list of dict\\n        The annotations of testing data.\\n\\n    Examples\\n    --------\\n    >>> import pprint\\n    >>> import tensorlayer as tl\\n    >>> img_train_list, ann_train_list, img_test_list, ann_test_list = tl.files.load_mpii_pose_dataset()\\n    >>> image = tl.vis.read_image(img_train_list[0])\\n    >>> tl.vis.draw_mpii_pose_to_image(image, ann_train_list[0], 'image.png')\\n    >>> pprint.pprint(ann_train_list[0])\\n\\n    References\\n    -----------\\n    - `MPII Human Pose Dataset. CVPR 14 <http://human-pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Pose Models. CVPR 16 <http://pose.mpi-inf.mpg.de>`__\\n    - `MPII Human Shape, Poselet Conditioned Pictorial Structures and etc <http://pose.mpi-inf.mpg.de/#related>`__\\n    - `MPII Keyponts and ID <http://human-pose.mpi-inf.mpg.de/#download>`__\\n    \"\n    path = os.path.join(path, 'mpii_human_pose')\n    logging.info('Load or Download MPII Human Pose > {}'.format(path))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1_u12_2.zip'\n    extracted_filename = 'mpii_human_pose_v1_u12_2'\n    if folder_exists(os.path.join(path, extracted_filename)) is False:\n        logging.info('[MPII] (annotation) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    url = 'http://datasets.d2.mpi-inf.mpg.de/andriluka14cvpr/'\n    tar_filename = 'mpii_human_pose_v1.tar.gz'\n    extracted_filename2 = 'images'\n    if folder_exists(os.path.join(path, extracted_filename2)) is False:\n        logging.info('[MPII] (images) {} is nonexistent in {}'.format(extracted_filename, path))\n        maybe_download_and_extract(tar_filename, path, url, extract=True)\n        del_file(os.path.join(path, tar_filename))\n    import scipy.io as sio\n    logging.info('reading annotations from mat file ...')\n    ann_train_list = []\n    ann_test_list = []\n    img_train_list = []\n    img_test_list = []\n\n    def save_joints():\n        mat = sio.loadmat(os.path.join(path, extracted_filename, 'mpii_human_pose_v1_u12_1.mat'))\n        for (_, (anno, train_flag)) in enumerate(zip(mat['RELEASE']['annolist'][0, 0][0], mat['RELEASE']['img_train'][0, 0][0])):\n            img_fn = anno['image']['name'][0, 0][0]\n            train_flag = int(train_flag)\n            if train_flag:\n                img_train_list.append(img_fn)\n                ann_train_list.append([])\n            else:\n                img_test_list.append(img_fn)\n                ann_test_list.append([])\n            head_rect = []\n            if 'x1' in str(anno['annorect'].dtype):\n                head_rect = zip([x1[0, 0] for x1 in anno['annorect']['x1'][0]], [y1[0, 0] for y1 in anno['annorect']['y1'][0]], [x2[0, 0] for x2 in anno['annorect']['x2'][0]], [y2[0, 0] for y2 in anno['annorect']['y2'][0]])\n            else:\n                head_rect = []\n            if 'annopoints' in str(anno['annorect'].dtype):\n                annopoints = anno['annorect']['annopoints'][0]\n                head_x1s = anno['annorect']['x1'][0]\n                head_y1s = anno['annorect']['y1'][0]\n                head_x2s = anno['annorect']['x2'][0]\n                head_y2s = anno['annorect']['y2'][0]\n                for (annopoint, head_x1, head_y1, head_x2, head_y2) in zip(annopoints, head_x1s, head_y1s, head_x2s, head_y2s):\n                    if annopoint.size:\n                        head_rect = [float(head_x1[0, 0]), float(head_y1[0, 0]), float(head_x2[0, 0]), float(head_y2[0, 0])]\n                        annopoint = annopoint['point'][0, 0]\n                        j_id = [str(j_i[0, 0]) for j_i in annopoint['id'][0]]\n                        x = [x[0, 0] for x in annopoint['x'][0]]\n                        y = [y[0, 0] for y in annopoint['y'][0]]\n                        joint_pos = {}\n                        for (_j_id, (_x, _y)) in zip(j_id, zip(x, y)):\n                            joint_pos[int(_j_id)] = [float(_x), float(_y)]\n                        if 'is_visible' in str(annopoint.dtype):\n                            vis = [v[0] if v.size > 0 else [0] for v in annopoint['is_visible'][0]]\n                            vis = dict([(k, int(v[0])) if len(v) > 0 else v for (k, v) in zip(j_id, vis)])\n                        else:\n                            vis = None\n                        if is_16_pos_only == True and len(joint_pos) == 16 or is_16_pos_only == False:\n                            data = {'filename': img_fn, 'train': train_flag, 'head_rect': head_rect, 'is_visible': vis, 'joint_pos': joint_pos}\n                            if train_flag:\n                                ann_train_list[-1].append(data)\n                            else:\n                                ann_test_list[-1].append(data)\n    save_joints()\n    logging.info('reading images list ...')\n    img_dir = os.path.join(path, extracted_filename2)\n    _img_list = load_file_list(path=os.path.join(path, extracted_filename2), regx='\\\\.jpg', printable=False)\n    for (i, im) in enumerate(img_train_list):\n        if im not in _img_list:\n            print('missing training image {} in {} (remove from img(ann)_train_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    for (i, im) in enumerate(img_test_list):\n        if im not in _img_list:\n            print('missing testing image {} in {} (remove from img(ann)_test_list)'.format(im, img_dir))\n            del img_train_list[i]\n            del ann_train_list[i]\n    n_train_images = len(img_train_list)\n    n_test_images = len(img_test_list)\n    n_images = n_train_images + n_test_images\n    logging.info('n_images: {} n_train_images: {} n_test_images: {}'.format(n_images, n_train_images, n_test_images))\n    n_train_ann = len(ann_train_list)\n    n_test_ann = len(ann_test_list)\n    n_ann = n_train_ann + n_test_ann\n    logging.info('n_ann: {} n_train_ann: {} n_test_ann: {}'.format(n_ann, n_train_ann, n_test_ann))\n    n_train_people = len(sum(ann_train_list, []))\n    n_test_people = len(sum(ann_test_list, []))\n    n_people = n_train_people + n_test_people\n    logging.info('n_people: {} n_train_people: {} n_test_people: {}'.format(n_people, n_train_people, n_test_people))\n    for (i, value) in enumerate(img_train_list):\n        img_train_list[i] = os.path.join(img_dir, value)\n    for (i, value) in enumerate(img_test_list):\n        img_test_list[i] = os.path.join(img_dir, value)\n    return (img_train_list, ann_train_list, img_test_list, ann_test_list)"
        ]
    }
]