[
    {
        "func_name": "frozen_member_test",
        "original": "def frozen_member_test():\n    frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n    if frozen_members:\n        return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n    return ''",
        "mutated": [
            "def frozen_member_test():\n    if False:\n        i = 10\n    frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n    if frozen_members:\n        return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n    return ''",
            "def frozen_member_test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n    if frozen_members:\n        return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n    return ''",
            "def frozen_member_test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n    if frozen_members:\n        return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n    return ''",
            "def frozen_member_test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n    if frozen_members:\n        return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n    return ''",
            "def frozen_member_test():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n    if frozen_members:\n        return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n    return ''"
        ]
    },
    {
        "func_name": "immutable",
        "original": "def immutable(members='', name='Immutable', verbose=False):\n    \"\"\"\n    Produces a class that either can be used standalone or as a base class for persistent classes.\n\n    This is a thin wrapper around a named tuple.\n\n    Constructing a type and using it to instantiate objects:\n\n    >>> Point = immutable('x, y', name='Point')\n    >>> p = Point(1, 2)\n    >>> p2 = p.set(x=3)\n    >>> p\n    Point(x=1, y=2)\n    >>> p2\n    Point(x=3, y=2)\n\n    Inheriting from a constructed type. In this case no type name needs to be supplied:\n\n    >>> class PositivePoint(immutable('x, y')):\n    ...     __slots__ = tuple()\n    ...     def __new__(cls, x, y):\n    ...         if x > 0 and y > 0:\n    ...             return super(PositivePoint, cls).__new__(cls, x, y)\n    ...         raise Exception('Coordinates must be positive!')\n    ...\n    >>> p = PositivePoint(1, 2)\n    >>> p.set(x=3)\n    PositivePoint(x=3, y=2)\n    >>> p.set(y=-3)\n    Traceback (most recent call last):\n    Exception: Coordinates must be positive!\n\n    The persistent class also supports the notion of frozen members. The value of a frozen member\n    cannot be updated. For example it could be used to implement an ID that should remain the same\n    over time. A frozen member is denoted by a trailing underscore.\n\n    >>> Point = immutable('x, y, id_', name='Point')\n    >>> p = Point(1, 2, id_=17)\n    >>> p.set(x=3)\n    Point(x=3, y=2, id_=17)\n    >>> p.set(id_=18)\n    Traceback (most recent call last):\n    AttributeError: Cannot set frozen members id_\n    \"\"\"\n    if isinstance(members, str):\n        members = members.replace(',', ' ').split()\n\n    def frozen_member_test():\n        frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n        if frozen_members:\n            return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n        return ''\n    verbose_string = ''\n    if sys.version_info < (3, 7):\n        verbose_string = ', verbose={verbose}'.format(verbose=verbose)\n    quoted_members = ', '.join((\"'%s'\" % m for m in members))\n    template = '\\nclass {class_name}(namedtuple(\\'ImmutableBase\\', [{quoted_members}]{verbose_string})):\\n    __slots__ = tuple()\\n\\n    def __repr__(self):\\n        return super({class_name}, self).__repr__().replace(\\'ImmutableBase\\', self.__class__.__name__)\\n\\n    def set(self, **kwargs):\\n        if not kwargs:\\n            return self\\n\\n        fields_to_modify = set(kwargs.keys())\\n        if not fields_to_modify <= {member_set}:\\n            raise AttributeError(\"\\'%s\\' is not a member\" % \\', \\'.join(fields_to_modify - {member_set}))\\n\\n        {frozen_member_test}\\n\\n        return self.__class__.__new__(self.__class__, *map(kwargs.pop, [{quoted_members}], self))\\n'.format(quoted_members=quoted_members, member_set='set([%s])' % quoted_members if quoted_members else 'set()', frozen_member_test=frozen_member_test(), verbose_string=verbose_string, class_name=name)\n    if verbose:\n        print(template)\n    from collections import namedtuple\n    namespace = dict(namedtuple=namedtuple, __name__='pyrsistent_immutable')\n    try:\n        exec(template, namespace)\n    except SyntaxError as e:\n        raise SyntaxError(str(e) + ':\\n' + template) from e\n    return namespace[name]",
        "mutated": [
            "def immutable(members='', name='Immutable', verbose=False):\n    if False:\n        i = 10\n    \"\\n    Produces a class that either can be used standalone or as a base class for persistent classes.\\n\\n    This is a thin wrapper around a named tuple.\\n\\n    Constructing a type and using it to instantiate objects:\\n\\n    >>> Point = immutable('x, y', name='Point')\\n    >>> p = Point(1, 2)\\n    >>> p2 = p.set(x=3)\\n    >>> p\\n    Point(x=1, y=2)\\n    >>> p2\\n    Point(x=3, y=2)\\n\\n    Inheriting from a constructed type. In this case no type name needs to be supplied:\\n\\n    >>> class PositivePoint(immutable('x, y')):\\n    ...     __slots__ = tuple()\\n    ...     def __new__(cls, x, y):\\n    ...         if x > 0 and y > 0:\\n    ...             return super(PositivePoint, cls).__new__(cls, x, y)\\n    ...         raise Exception('Coordinates must be positive!')\\n    ...\\n    >>> p = PositivePoint(1, 2)\\n    >>> p.set(x=3)\\n    PositivePoint(x=3, y=2)\\n    >>> p.set(y=-3)\\n    Traceback (most recent call last):\\n    Exception: Coordinates must be positive!\\n\\n    The persistent class also supports the notion of frozen members. The value of a frozen member\\n    cannot be updated. For example it could be used to implement an ID that should remain the same\\n    over time. A frozen member is denoted by a trailing underscore.\\n\\n    >>> Point = immutable('x, y, id_', name='Point')\\n    >>> p = Point(1, 2, id_=17)\\n    >>> p.set(x=3)\\n    Point(x=3, y=2, id_=17)\\n    >>> p.set(id_=18)\\n    Traceback (most recent call last):\\n    AttributeError: Cannot set frozen members id_\\n    \"\n    if isinstance(members, str):\n        members = members.replace(',', ' ').split()\n\n    def frozen_member_test():\n        frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n        if frozen_members:\n            return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n        return ''\n    verbose_string = ''\n    if sys.version_info < (3, 7):\n        verbose_string = ', verbose={verbose}'.format(verbose=verbose)\n    quoted_members = ', '.join((\"'%s'\" % m for m in members))\n    template = '\\nclass {class_name}(namedtuple(\\'ImmutableBase\\', [{quoted_members}]{verbose_string})):\\n    __slots__ = tuple()\\n\\n    def __repr__(self):\\n        return super({class_name}, self).__repr__().replace(\\'ImmutableBase\\', self.__class__.__name__)\\n\\n    def set(self, **kwargs):\\n        if not kwargs:\\n            return self\\n\\n        fields_to_modify = set(kwargs.keys())\\n        if not fields_to_modify <= {member_set}:\\n            raise AttributeError(\"\\'%s\\' is not a member\" % \\', \\'.join(fields_to_modify - {member_set}))\\n\\n        {frozen_member_test}\\n\\n        return self.__class__.__new__(self.__class__, *map(kwargs.pop, [{quoted_members}], self))\\n'.format(quoted_members=quoted_members, member_set='set([%s])' % quoted_members if quoted_members else 'set()', frozen_member_test=frozen_member_test(), verbose_string=verbose_string, class_name=name)\n    if verbose:\n        print(template)\n    from collections import namedtuple\n    namespace = dict(namedtuple=namedtuple, __name__='pyrsistent_immutable')\n    try:\n        exec(template, namespace)\n    except SyntaxError as e:\n        raise SyntaxError(str(e) + ':\\n' + template) from e\n    return namespace[name]",
            "def immutable(members='', name='Immutable', verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Produces a class that either can be used standalone or as a base class for persistent classes.\\n\\n    This is a thin wrapper around a named tuple.\\n\\n    Constructing a type and using it to instantiate objects:\\n\\n    >>> Point = immutable('x, y', name='Point')\\n    >>> p = Point(1, 2)\\n    >>> p2 = p.set(x=3)\\n    >>> p\\n    Point(x=1, y=2)\\n    >>> p2\\n    Point(x=3, y=2)\\n\\n    Inheriting from a constructed type. In this case no type name needs to be supplied:\\n\\n    >>> class PositivePoint(immutable('x, y')):\\n    ...     __slots__ = tuple()\\n    ...     def __new__(cls, x, y):\\n    ...         if x > 0 and y > 0:\\n    ...             return super(PositivePoint, cls).__new__(cls, x, y)\\n    ...         raise Exception('Coordinates must be positive!')\\n    ...\\n    >>> p = PositivePoint(1, 2)\\n    >>> p.set(x=3)\\n    PositivePoint(x=3, y=2)\\n    >>> p.set(y=-3)\\n    Traceback (most recent call last):\\n    Exception: Coordinates must be positive!\\n\\n    The persistent class also supports the notion of frozen members. The value of a frozen member\\n    cannot be updated. For example it could be used to implement an ID that should remain the same\\n    over time. A frozen member is denoted by a trailing underscore.\\n\\n    >>> Point = immutable('x, y, id_', name='Point')\\n    >>> p = Point(1, 2, id_=17)\\n    >>> p.set(x=3)\\n    Point(x=3, y=2, id_=17)\\n    >>> p.set(id_=18)\\n    Traceback (most recent call last):\\n    AttributeError: Cannot set frozen members id_\\n    \"\n    if isinstance(members, str):\n        members = members.replace(',', ' ').split()\n\n    def frozen_member_test():\n        frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n        if frozen_members:\n            return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n        return ''\n    verbose_string = ''\n    if sys.version_info < (3, 7):\n        verbose_string = ', verbose={verbose}'.format(verbose=verbose)\n    quoted_members = ', '.join((\"'%s'\" % m for m in members))\n    template = '\\nclass {class_name}(namedtuple(\\'ImmutableBase\\', [{quoted_members}]{verbose_string})):\\n    __slots__ = tuple()\\n\\n    def __repr__(self):\\n        return super({class_name}, self).__repr__().replace(\\'ImmutableBase\\', self.__class__.__name__)\\n\\n    def set(self, **kwargs):\\n        if not kwargs:\\n            return self\\n\\n        fields_to_modify = set(kwargs.keys())\\n        if not fields_to_modify <= {member_set}:\\n            raise AttributeError(\"\\'%s\\' is not a member\" % \\', \\'.join(fields_to_modify - {member_set}))\\n\\n        {frozen_member_test}\\n\\n        return self.__class__.__new__(self.__class__, *map(kwargs.pop, [{quoted_members}], self))\\n'.format(quoted_members=quoted_members, member_set='set([%s])' % quoted_members if quoted_members else 'set()', frozen_member_test=frozen_member_test(), verbose_string=verbose_string, class_name=name)\n    if verbose:\n        print(template)\n    from collections import namedtuple\n    namespace = dict(namedtuple=namedtuple, __name__='pyrsistent_immutable')\n    try:\n        exec(template, namespace)\n    except SyntaxError as e:\n        raise SyntaxError(str(e) + ':\\n' + template) from e\n    return namespace[name]",
            "def immutable(members='', name='Immutable', verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Produces a class that either can be used standalone or as a base class for persistent classes.\\n\\n    This is a thin wrapper around a named tuple.\\n\\n    Constructing a type and using it to instantiate objects:\\n\\n    >>> Point = immutable('x, y', name='Point')\\n    >>> p = Point(1, 2)\\n    >>> p2 = p.set(x=3)\\n    >>> p\\n    Point(x=1, y=2)\\n    >>> p2\\n    Point(x=3, y=2)\\n\\n    Inheriting from a constructed type. In this case no type name needs to be supplied:\\n\\n    >>> class PositivePoint(immutable('x, y')):\\n    ...     __slots__ = tuple()\\n    ...     def __new__(cls, x, y):\\n    ...         if x > 0 and y > 0:\\n    ...             return super(PositivePoint, cls).__new__(cls, x, y)\\n    ...         raise Exception('Coordinates must be positive!')\\n    ...\\n    >>> p = PositivePoint(1, 2)\\n    >>> p.set(x=3)\\n    PositivePoint(x=3, y=2)\\n    >>> p.set(y=-3)\\n    Traceback (most recent call last):\\n    Exception: Coordinates must be positive!\\n\\n    The persistent class also supports the notion of frozen members. The value of a frozen member\\n    cannot be updated. For example it could be used to implement an ID that should remain the same\\n    over time. A frozen member is denoted by a trailing underscore.\\n\\n    >>> Point = immutable('x, y, id_', name='Point')\\n    >>> p = Point(1, 2, id_=17)\\n    >>> p.set(x=3)\\n    Point(x=3, y=2, id_=17)\\n    >>> p.set(id_=18)\\n    Traceback (most recent call last):\\n    AttributeError: Cannot set frozen members id_\\n    \"\n    if isinstance(members, str):\n        members = members.replace(',', ' ').split()\n\n    def frozen_member_test():\n        frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n        if frozen_members:\n            return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n        return ''\n    verbose_string = ''\n    if sys.version_info < (3, 7):\n        verbose_string = ', verbose={verbose}'.format(verbose=verbose)\n    quoted_members = ', '.join((\"'%s'\" % m for m in members))\n    template = '\\nclass {class_name}(namedtuple(\\'ImmutableBase\\', [{quoted_members}]{verbose_string})):\\n    __slots__ = tuple()\\n\\n    def __repr__(self):\\n        return super({class_name}, self).__repr__().replace(\\'ImmutableBase\\', self.__class__.__name__)\\n\\n    def set(self, **kwargs):\\n        if not kwargs:\\n            return self\\n\\n        fields_to_modify = set(kwargs.keys())\\n        if not fields_to_modify <= {member_set}:\\n            raise AttributeError(\"\\'%s\\' is not a member\" % \\', \\'.join(fields_to_modify - {member_set}))\\n\\n        {frozen_member_test}\\n\\n        return self.__class__.__new__(self.__class__, *map(kwargs.pop, [{quoted_members}], self))\\n'.format(quoted_members=quoted_members, member_set='set([%s])' % quoted_members if quoted_members else 'set()', frozen_member_test=frozen_member_test(), verbose_string=verbose_string, class_name=name)\n    if verbose:\n        print(template)\n    from collections import namedtuple\n    namespace = dict(namedtuple=namedtuple, __name__='pyrsistent_immutable')\n    try:\n        exec(template, namespace)\n    except SyntaxError as e:\n        raise SyntaxError(str(e) + ':\\n' + template) from e\n    return namespace[name]",
            "def immutable(members='', name='Immutable', verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Produces a class that either can be used standalone or as a base class for persistent classes.\\n\\n    This is a thin wrapper around a named tuple.\\n\\n    Constructing a type and using it to instantiate objects:\\n\\n    >>> Point = immutable('x, y', name='Point')\\n    >>> p = Point(1, 2)\\n    >>> p2 = p.set(x=3)\\n    >>> p\\n    Point(x=1, y=2)\\n    >>> p2\\n    Point(x=3, y=2)\\n\\n    Inheriting from a constructed type. In this case no type name needs to be supplied:\\n\\n    >>> class PositivePoint(immutable('x, y')):\\n    ...     __slots__ = tuple()\\n    ...     def __new__(cls, x, y):\\n    ...         if x > 0 and y > 0:\\n    ...             return super(PositivePoint, cls).__new__(cls, x, y)\\n    ...         raise Exception('Coordinates must be positive!')\\n    ...\\n    >>> p = PositivePoint(1, 2)\\n    >>> p.set(x=3)\\n    PositivePoint(x=3, y=2)\\n    >>> p.set(y=-3)\\n    Traceback (most recent call last):\\n    Exception: Coordinates must be positive!\\n\\n    The persistent class also supports the notion of frozen members. The value of a frozen member\\n    cannot be updated. For example it could be used to implement an ID that should remain the same\\n    over time. A frozen member is denoted by a trailing underscore.\\n\\n    >>> Point = immutable('x, y, id_', name='Point')\\n    >>> p = Point(1, 2, id_=17)\\n    >>> p.set(x=3)\\n    Point(x=3, y=2, id_=17)\\n    >>> p.set(id_=18)\\n    Traceback (most recent call last):\\n    AttributeError: Cannot set frozen members id_\\n    \"\n    if isinstance(members, str):\n        members = members.replace(',', ' ').split()\n\n    def frozen_member_test():\n        frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n        if frozen_members:\n            return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n        return ''\n    verbose_string = ''\n    if sys.version_info < (3, 7):\n        verbose_string = ', verbose={verbose}'.format(verbose=verbose)\n    quoted_members = ', '.join((\"'%s'\" % m for m in members))\n    template = '\\nclass {class_name}(namedtuple(\\'ImmutableBase\\', [{quoted_members}]{verbose_string})):\\n    __slots__ = tuple()\\n\\n    def __repr__(self):\\n        return super({class_name}, self).__repr__().replace(\\'ImmutableBase\\', self.__class__.__name__)\\n\\n    def set(self, **kwargs):\\n        if not kwargs:\\n            return self\\n\\n        fields_to_modify = set(kwargs.keys())\\n        if not fields_to_modify <= {member_set}:\\n            raise AttributeError(\"\\'%s\\' is not a member\" % \\', \\'.join(fields_to_modify - {member_set}))\\n\\n        {frozen_member_test}\\n\\n        return self.__class__.__new__(self.__class__, *map(kwargs.pop, [{quoted_members}], self))\\n'.format(quoted_members=quoted_members, member_set='set([%s])' % quoted_members if quoted_members else 'set()', frozen_member_test=frozen_member_test(), verbose_string=verbose_string, class_name=name)\n    if verbose:\n        print(template)\n    from collections import namedtuple\n    namespace = dict(namedtuple=namedtuple, __name__='pyrsistent_immutable')\n    try:\n        exec(template, namespace)\n    except SyntaxError as e:\n        raise SyntaxError(str(e) + ':\\n' + template) from e\n    return namespace[name]",
            "def immutable(members='', name='Immutable', verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Produces a class that either can be used standalone or as a base class for persistent classes.\\n\\n    This is a thin wrapper around a named tuple.\\n\\n    Constructing a type and using it to instantiate objects:\\n\\n    >>> Point = immutable('x, y', name='Point')\\n    >>> p = Point(1, 2)\\n    >>> p2 = p.set(x=3)\\n    >>> p\\n    Point(x=1, y=2)\\n    >>> p2\\n    Point(x=3, y=2)\\n\\n    Inheriting from a constructed type. In this case no type name needs to be supplied:\\n\\n    >>> class PositivePoint(immutable('x, y')):\\n    ...     __slots__ = tuple()\\n    ...     def __new__(cls, x, y):\\n    ...         if x > 0 and y > 0:\\n    ...             return super(PositivePoint, cls).__new__(cls, x, y)\\n    ...         raise Exception('Coordinates must be positive!')\\n    ...\\n    >>> p = PositivePoint(1, 2)\\n    >>> p.set(x=3)\\n    PositivePoint(x=3, y=2)\\n    >>> p.set(y=-3)\\n    Traceback (most recent call last):\\n    Exception: Coordinates must be positive!\\n\\n    The persistent class also supports the notion of frozen members. The value of a frozen member\\n    cannot be updated. For example it could be used to implement an ID that should remain the same\\n    over time. A frozen member is denoted by a trailing underscore.\\n\\n    >>> Point = immutable('x, y, id_', name='Point')\\n    >>> p = Point(1, 2, id_=17)\\n    >>> p.set(x=3)\\n    Point(x=3, y=2, id_=17)\\n    >>> p.set(id_=18)\\n    Traceback (most recent call last):\\n    AttributeError: Cannot set frozen members id_\\n    \"\n    if isinstance(members, str):\n        members = members.replace(',', ' ').split()\n\n    def frozen_member_test():\n        frozen_members = [\"'%s'\" % f for f in members if f.endswith('_')]\n        if frozen_members:\n            return \"\\n        frozen_fields = fields_to_modify & set([{frozen_members}])\\n        if frozen_fields:\\n            raise AttributeError('Cannot set frozen members %s' % ', '.join(frozen_fields))\\n            \".format(frozen_members=', '.join(frozen_members))\n        return ''\n    verbose_string = ''\n    if sys.version_info < (3, 7):\n        verbose_string = ', verbose={verbose}'.format(verbose=verbose)\n    quoted_members = ', '.join((\"'%s'\" % m for m in members))\n    template = '\\nclass {class_name}(namedtuple(\\'ImmutableBase\\', [{quoted_members}]{verbose_string})):\\n    __slots__ = tuple()\\n\\n    def __repr__(self):\\n        return super({class_name}, self).__repr__().replace(\\'ImmutableBase\\', self.__class__.__name__)\\n\\n    def set(self, **kwargs):\\n        if not kwargs:\\n            return self\\n\\n        fields_to_modify = set(kwargs.keys())\\n        if not fields_to_modify <= {member_set}:\\n            raise AttributeError(\"\\'%s\\' is not a member\" % \\', \\'.join(fields_to_modify - {member_set}))\\n\\n        {frozen_member_test}\\n\\n        return self.__class__.__new__(self.__class__, *map(kwargs.pop, [{quoted_members}], self))\\n'.format(quoted_members=quoted_members, member_set='set([%s])' % quoted_members if quoted_members else 'set()', frozen_member_test=frozen_member_test(), verbose_string=verbose_string, class_name=name)\n    if verbose:\n        print(template)\n    from collections import namedtuple\n    namespace = dict(namedtuple=namedtuple, __name__='pyrsistent_immutable')\n    try:\n        exec(template, namespace)\n    except SyntaxError as e:\n        raise SyntaxError(str(e) + ':\\n' + template) from e\n    return namespace[name]"
        ]
    }
]