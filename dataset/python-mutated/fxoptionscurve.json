[
    {
        "func_name": "__init__",
        "original": "def __init__(self, market_data_generator=None, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=market_constants.fx_options_trading_tenor, roll_days_before=market_constants.fx_options_roll_days_before, roll_event=market_constants.fx_options_roll_event, construct_via_currency='no', fx_options_tenor_for_interpolation=market_constants.fx_options_tenor_for_interpolation, base_depos_tenor=data_constants.base_depos_tenor, roll_months=market_constants.fx_options_roll_months, cum_index=market_constants.fx_options_cum_index, strike=market_constants.fx_options_index_strike, contract_type=market_constants.fx_options_index_contract_type, premium_output=market_constants.fx_options_index_premium_output, position_multiplier=1, depo_tenor_for_option=market_constants.fx_options_depo_tenor, freeze_implied_vol=market_constants.fx_options_freeze_implied_vol, tot_label='', cal=None, output_calculation_fields=market_constants.output_calculation_fields):\n    \"\"\"Initializes FXForwardsCurve\n\n        Parameters\n        ----------\n        market_data_generator : MarketDataGenerator\n            Used for downloading market data\n\n        fx_vol_surface : FXVolSurface\n            We can specify the FX vol surface beforehand if we want\n\n        fx_options_trading_tenor : str\n            What is primary forward contract being used to trade (default - '1M')\n\n        roll_days_before : int\n            Number of days before roll event to enter into a new forwards contract\n\n        roll_event : str\n            What constitutes a roll event? ('month-end', 'quarter-end', 'year-end', 'expiry')\n\n        cum_index : str\n            In total return index, do we compute in additive or multiplicative way ('add' or 'mult')\n\n        construct_via_currency : str\n            What currency should we construct the forward via? Eg. if we asked for AUDJPY we can construct it via\n            AUDUSD & JPYUSD forwards, as opposed to AUDJPY forwards (default - 'no')\n\n        fx_options_tenor_for_interpolation : str(list)\n            Which forwards should we use for interpolation\n\n        base_depos_tenor : str(list)\n            Which base deposits tenors do we need (this is only necessary if we want to start inferring depos)\n\n        roll_months : int\n            After how many months should we initiate a roll. Typically for trading 1M this should 1, 3M this should be 3\n            etc.\n\n        tot_label : str\n            Postfix for the total returns field\n\n        cal : str\n            Calendar to use for expiry (if None, uses that of FX pair)\n\n        output_calculation_fields : bool\n            Also output additional data should forward expiries etc. alongside total returns indices\n        \"\"\"\n    self._market_data_generator = market_data_generator\n    self._calculations = Calculations()\n    self._calendar = Calendar()\n    self._filter = Filter()\n    self._fx_vol_surface = fx_vol_surface\n    self._enter_trading_dates = enter_trading_dates\n    self._fx_options_trading_tenor = fx_options_trading_tenor\n    self._roll_days_before = roll_days_before\n    self._roll_event = roll_event\n    self._construct_via_currency = construct_via_currency\n    self._fx_options_tenor_for_interpolation = fx_options_tenor_for_interpolation\n    self._base_depos_tenor = base_depos_tenor\n    self._roll_months = roll_months\n    self._cum_index = cum_index\n    self._contact_type = contract_type\n    self._strike = strike\n    self._premium_output = premium_output\n    self._position_multiplier = position_multiplier\n    self._depo_tenor_for_option = depo_tenor_for_option\n    self._freeze_implied_vol = freeze_implied_vol\n    self._tot_label = tot_label\n    self._cal = cal\n    self._output_calculation_fields = output_calculation_fields",
        "mutated": [
            "def __init__(self, market_data_generator=None, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=market_constants.fx_options_trading_tenor, roll_days_before=market_constants.fx_options_roll_days_before, roll_event=market_constants.fx_options_roll_event, construct_via_currency='no', fx_options_tenor_for_interpolation=market_constants.fx_options_tenor_for_interpolation, base_depos_tenor=data_constants.base_depos_tenor, roll_months=market_constants.fx_options_roll_months, cum_index=market_constants.fx_options_cum_index, strike=market_constants.fx_options_index_strike, contract_type=market_constants.fx_options_index_contract_type, premium_output=market_constants.fx_options_index_premium_output, position_multiplier=1, depo_tenor_for_option=market_constants.fx_options_depo_tenor, freeze_implied_vol=market_constants.fx_options_freeze_implied_vol, tot_label='', cal=None, output_calculation_fields=market_constants.output_calculation_fields):\n    if False:\n        i = 10\n    \"Initializes FXForwardsCurve\\n\\n        Parameters\\n        ----------\\n        market_data_generator : MarketDataGenerator\\n            Used for downloading market data\\n\\n        fx_vol_surface : FXVolSurface\\n            We can specify the FX vol surface beforehand if we want\\n\\n        fx_options_trading_tenor : str\\n            What is primary forward contract being used to trade (default - '1M')\\n\\n        roll_days_before : int\\n            Number of days before roll event to enter into a new forwards contract\\n\\n        roll_event : str\\n            What constitutes a roll event? ('month-end', 'quarter-end', 'year-end', 'expiry')\\n\\n        cum_index : str\\n            In total return index, do we compute in additive or multiplicative way ('add' or 'mult')\\n\\n        construct_via_currency : str\\n            What currency should we construct the forward via? Eg. if we asked for AUDJPY we can construct it via\\n            AUDUSD & JPYUSD forwards, as opposed to AUDJPY forwards (default - 'no')\\n\\n        fx_options_tenor_for_interpolation : str(list)\\n            Which forwards should we use for interpolation\\n\\n        base_depos_tenor : str(list)\\n            Which base deposits tenors do we need (this is only necessary if we want to start inferring depos)\\n\\n        roll_months : int\\n            After how many months should we initiate a roll. Typically for trading 1M this should 1, 3M this should be 3\\n            etc.\\n\\n        tot_label : str\\n            Postfix for the total returns field\\n\\n        cal : str\\n            Calendar to use for expiry (if None, uses that of FX pair)\\n\\n        output_calculation_fields : bool\\n            Also output additional data should forward expiries etc. alongside total returns indices\\n        \"\n    self._market_data_generator = market_data_generator\n    self._calculations = Calculations()\n    self._calendar = Calendar()\n    self._filter = Filter()\n    self._fx_vol_surface = fx_vol_surface\n    self._enter_trading_dates = enter_trading_dates\n    self._fx_options_trading_tenor = fx_options_trading_tenor\n    self._roll_days_before = roll_days_before\n    self._roll_event = roll_event\n    self._construct_via_currency = construct_via_currency\n    self._fx_options_tenor_for_interpolation = fx_options_tenor_for_interpolation\n    self._base_depos_tenor = base_depos_tenor\n    self._roll_months = roll_months\n    self._cum_index = cum_index\n    self._contact_type = contract_type\n    self._strike = strike\n    self._premium_output = premium_output\n    self._position_multiplier = position_multiplier\n    self._depo_tenor_for_option = depo_tenor_for_option\n    self._freeze_implied_vol = freeze_implied_vol\n    self._tot_label = tot_label\n    self._cal = cal\n    self._output_calculation_fields = output_calculation_fields",
            "def __init__(self, market_data_generator=None, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=market_constants.fx_options_trading_tenor, roll_days_before=market_constants.fx_options_roll_days_before, roll_event=market_constants.fx_options_roll_event, construct_via_currency='no', fx_options_tenor_for_interpolation=market_constants.fx_options_tenor_for_interpolation, base_depos_tenor=data_constants.base_depos_tenor, roll_months=market_constants.fx_options_roll_months, cum_index=market_constants.fx_options_cum_index, strike=market_constants.fx_options_index_strike, contract_type=market_constants.fx_options_index_contract_type, premium_output=market_constants.fx_options_index_premium_output, position_multiplier=1, depo_tenor_for_option=market_constants.fx_options_depo_tenor, freeze_implied_vol=market_constants.fx_options_freeze_implied_vol, tot_label='', cal=None, output_calculation_fields=market_constants.output_calculation_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Initializes FXForwardsCurve\\n\\n        Parameters\\n        ----------\\n        market_data_generator : MarketDataGenerator\\n            Used for downloading market data\\n\\n        fx_vol_surface : FXVolSurface\\n            We can specify the FX vol surface beforehand if we want\\n\\n        fx_options_trading_tenor : str\\n            What is primary forward contract being used to trade (default - '1M')\\n\\n        roll_days_before : int\\n            Number of days before roll event to enter into a new forwards contract\\n\\n        roll_event : str\\n            What constitutes a roll event? ('month-end', 'quarter-end', 'year-end', 'expiry')\\n\\n        cum_index : str\\n            In total return index, do we compute in additive or multiplicative way ('add' or 'mult')\\n\\n        construct_via_currency : str\\n            What currency should we construct the forward via? Eg. if we asked for AUDJPY we can construct it via\\n            AUDUSD & JPYUSD forwards, as opposed to AUDJPY forwards (default - 'no')\\n\\n        fx_options_tenor_for_interpolation : str(list)\\n            Which forwards should we use for interpolation\\n\\n        base_depos_tenor : str(list)\\n            Which base deposits tenors do we need (this is only necessary if we want to start inferring depos)\\n\\n        roll_months : int\\n            After how many months should we initiate a roll. Typically for trading 1M this should 1, 3M this should be 3\\n            etc.\\n\\n        tot_label : str\\n            Postfix for the total returns field\\n\\n        cal : str\\n            Calendar to use for expiry (if None, uses that of FX pair)\\n\\n        output_calculation_fields : bool\\n            Also output additional data should forward expiries etc. alongside total returns indices\\n        \"\n    self._market_data_generator = market_data_generator\n    self._calculations = Calculations()\n    self._calendar = Calendar()\n    self._filter = Filter()\n    self._fx_vol_surface = fx_vol_surface\n    self._enter_trading_dates = enter_trading_dates\n    self._fx_options_trading_tenor = fx_options_trading_tenor\n    self._roll_days_before = roll_days_before\n    self._roll_event = roll_event\n    self._construct_via_currency = construct_via_currency\n    self._fx_options_tenor_for_interpolation = fx_options_tenor_for_interpolation\n    self._base_depos_tenor = base_depos_tenor\n    self._roll_months = roll_months\n    self._cum_index = cum_index\n    self._contact_type = contract_type\n    self._strike = strike\n    self._premium_output = premium_output\n    self._position_multiplier = position_multiplier\n    self._depo_tenor_for_option = depo_tenor_for_option\n    self._freeze_implied_vol = freeze_implied_vol\n    self._tot_label = tot_label\n    self._cal = cal\n    self._output_calculation_fields = output_calculation_fields",
            "def __init__(self, market_data_generator=None, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=market_constants.fx_options_trading_tenor, roll_days_before=market_constants.fx_options_roll_days_before, roll_event=market_constants.fx_options_roll_event, construct_via_currency='no', fx_options_tenor_for_interpolation=market_constants.fx_options_tenor_for_interpolation, base_depos_tenor=data_constants.base_depos_tenor, roll_months=market_constants.fx_options_roll_months, cum_index=market_constants.fx_options_cum_index, strike=market_constants.fx_options_index_strike, contract_type=market_constants.fx_options_index_contract_type, premium_output=market_constants.fx_options_index_premium_output, position_multiplier=1, depo_tenor_for_option=market_constants.fx_options_depo_tenor, freeze_implied_vol=market_constants.fx_options_freeze_implied_vol, tot_label='', cal=None, output_calculation_fields=market_constants.output_calculation_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Initializes FXForwardsCurve\\n\\n        Parameters\\n        ----------\\n        market_data_generator : MarketDataGenerator\\n            Used for downloading market data\\n\\n        fx_vol_surface : FXVolSurface\\n            We can specify the FX vol surface beforehand if we want\\n\\n        fx_options_trading_tenor : str\\n            What is primary forward contract being used to trade (default - '1M')\\n\\n        roll_days_before : int\\n            Number of days before roll event to enter into a new forwards contract\\n\\n        roll_event : str\\n            What constitutes a roll event? ('month-end', 'quarter-end', 'year-end', 'expiry')\\n\\n        cum_index : str\\n            In total return index, do we compute in additive or multiplicative way ('add' or 'mult')\\n\\n        construct_via_currency : str\\n            What currency should we construct the forward via? Eg. if we asked for AUDJPY we can construct it via\\n            AUDUSD & JPYUSD forwards, as opposed to AUDJPY forwards (default - 'no')\\n\\n        fx_options_tenor_for_interpolation : str(list)\\n            Which forwards should we use for interpolation\\n\\n        base_depos_tenor : str(list)\\n            Which base deposits tenors do we need (this is only necessary if we want to start inferring depos)\\n\\n        roll_months : int\\n            After how many months should we initiate a roll. Typically for trading 1M this should 1, 3M this should be 3\\n            etc.\\n\\n        tot_label : str\\n            Postfix for the total returns field\\n\\n        cal : str\\n            Calendar to use for expiry (if None, uses that of FX pair)\\n\\n        output_calculation_fields : bool\\n            Also output additional data should forward expiries etc. alongside total returns indices\\n        \"\n    self._market_data_generator = market_data_generator\n    self._calculations = Calculations()\n    self._calendar = Calendar()\n    self._filter = Filter()\n    self._fx_vol_surface = fx_vol_surface\n    self._enter_trading_dates = enter_trading_dates\n    self._fx_options_trading_tenor = fx_options_trading_tenor\n    self._roll_days_before = roll_days_before\n    self._roll_event = roll_event\n    self._construct_via_currency = construct_via_currency\n    self._fx_options_tenor_for_interpolation = fx_options_tenor_for_interpolation\n    self._base_depos_tenor = base_depos_tenor\n    self._roll_months = roll_months\n    self._cum_index = cum_index\n    self._contact_type = contract_type\n    self._strike = strike\n    self._premium_output = premium_output\n    self._position_multiplier = position_multiplier\n    self._depo_tenor_for_option = depo_tenor_for_option\n    self._freeze_implied_vol = freeze_implied_vol\n    self._tot_label = tot_label\n    self._cal = cal\n    self._output_calculation_fields = output_calculation_fields",
            "def __init__(self, market_data_generator=None, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=market_constants.fx_options_trading_tenor, roll_days_before=market_constants.fx_options_roll_days_before, roll_event=market_constants.fx_options_roll_event, construct_via_currency='no', fx_options_tenor_for_interpolation=market_constants.fx_options_tenor_for_interpolation, base_depos_tenor=data_constants.base_depos_tenor, roll_months=market_constants.fx_options_roll_months, cum_index=market_constants.fx_options_cum_index, strike=market_constants.fx_options_index_strike, contract_type=market_constants.fx_options_index_contract_type, premium_output=market_constants.fx_options_index_premium_output, position_multiplier=1, depo_tenor_for_option=market_constants.fx_options_depo_tenor, freeze_implied_vol=market_constants.fx_options_freeze_implied_vol, tot_label='', cal=None, output_calculation_fields=market_constants.output_calculation_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Initializes FXForwardsCurve\\n\\n        Parameters\\n        ----------\\n        market_data_generator : MarketDataGenerator\\n            Used for downloading market data\\n\\n        fx_vol_surface : FXVolSurface\\n            We can specify the FX vol surface beforehand if we want\\n\\n        fx_options_trading_tenor : str\\n            What is primary forward contract being used to trade (default - '1M')\\n\\n        roll_days_before : int\\n            Number of days before roll event to enter into a new forwards contract\\n\\n        roll_event : str\\n            What constitutes a roll event? ('month-end', 'quarter-end', 'year-end', 'expiry')\\n\\n        cum_index : str\\n            In total return index, do we compute in additive or multiplicative way ('add' or 'mult')\\n\\n        construct_via_currency : str\\n            What currency should we construct the forward via? Eg. if we asked for AUDJPY we can construct it via\\n            AUDUSD & JPYUSD forwards, as opposed to AUDJPY forwards (default - 'no')\\n\\n        fx_options_tenor_for_interpolation : str(list)\\n            Which forwards should we use for interpolation\\n\\n        base_depos_tenor : str(list)\\n            Which base deposits tenors do we need (this is only necessary if we want to start inferring depos)\\n\\n        roll_months : int\\n            After how many months should we initiate a roll. Typically for trading 1M this should 1, 3M this should be 3\\n            etc.\\n\\n        tot_label : str\\n            Postfix for the total returns field\\n\\n        cal : str\\n            Calendar to use for expiry (if None, uses that of FX pair)\\n\\n        output_calculation_fields : bool\\n            Also output additional data should forward expiries etc. alongside total returns indices\\n        \"\n    self._market_data_generator = market_data_generator\n    self._calculations = Calculations()\n    self._calendar = Calendar()\n    self._filter = Filter()\n    self._fx_vol_surface = fx_vol_surface\n    self._enter_trading_dates = enter_trading_dates\n    self._fx_options_trading_tenor = fx_options_trading_tenor\n    self._roll_days_before = roll_days_before\n    self._roll_event = roll_event\n    self._construct_via_currency = construct_via_currency\n    self._fx_options_tenor_for_interpolation = fx_options_tenor_for_interpolation\n    self._base_depos_tenor = base_depos_tenor\n    self._roll_months = roll_months\n    self._cum_index = cum_index\n    self._contact_type = contract_type\n    self._strike = strike\n    self._premium_output = premium_output\n    self._position_multiplier = position_multiplier\n    self._depo_tenor_for_option = depo_tenor_for_option\n    self._freeze_implied_vol = freeze_implied_vol\n    self._tot_label = tot_label\n    self._cal = cal\n    self._output_calculation_fields = output_calculation_fields",
            "def __init__(self, market_data_generator=None, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=market_constants.fx_options_trading_tenor, roll_days_before=market_constants.fx_options_roll_days_before, roll_event=market_constants.fx_options_roll_event, construct_via_currency='no', fx_options_tenor_for_interpolation=market_constants.fx_options_tenor_for_interpolation, base_depos_tenor=data_constants.base_depos_tenor, roll_months=market_constants.fx_options_roll_months, cum_index=market_constants.fx_options_cum_index, strike=market_constants.fx_options_index_strike, contract_type=market_constants.fx_options_index_contract_type, premium_output=market_constants.fx_options_index_premium_output, position_multiplier=1, depo_tenor_for_option=market_constants.fx_options_depo_tenor, freeze_implied_vol=market_constants.fx_options_freeze_implied_vol, tot_label='', cal=None, output_calculation_fields=market_constants.output_calculation_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Initializes FXForwardsCurve\\n\\n        Parameters\\n        ----------\\n        market_data_generator : MarketDataGenerator\\n            Used for downloading market data\\n\\n        fx_vol_surface : FXVolSurface\\n            We can specify the FX vol surface beforehand if we want\\n\\n        fx_options_trading_tenor : str\\n            What is primary forward contract being used to trade (default - '1M')\\n\\n        roll_days_before : int\\n            Number of days before roll event to enter into a new forwards contract\\n\\n        roll_event : str\\n            What constitutes a roll event? ('month-end', 'quarter-end', 'year-end', 'expiry')\\n\\n        cum_index : str\\n            In total return index, do we compute in additive or multiplicative way ('add' or 'mult')\\n\\n        construct_via_currency : str\\n            What currency should we construct the forward via? Eg. if we asked for AUDJPY we can construct it via\\n            AUDUSD & JPYUSD forwards, as opposed to AUDJPY forwards (default - 'no')\\n\\n        fx_options_tenor_for_interpolation : str(list)\\n            Which forwards should we use for interpolation\\n\\n        base_depos_tenor : str(list)\\n            Which base deposits tenors do we need (this is only necessary if we want to start inferring depos)\\n\\n        roll_months : int\\n            After how many months should we initiate a roll. Typically for trading 1M this should 1, 3M this should be 3\\n            etc.\\n\\n        tot_label : str\\n            Postfix for the total returns field\\n\\n        cal : str\\n            Calendar to use for expiry (if None, uses that of FX pair)\\n\\n        output_calculation_fields : bool\\n            Also output additional data should forward expiries etc. alongside total returns indices\\n        \"\n    self._market_data_generator = market_data_generator\n    self._calculations = Calculations()\n    self._calendar = Calendar()\n    self._filter = Filter()\n    self._fx_vol_surface = fx_vol_surface\n    self._enter_trading_dates = enter_trading_dates\n    self._fx_options_trading_tenor = fx_options_trading_tenor\n    self._roll_days_before = roll_days_before\n    self._roll_event = roll_event\n    self._construct_via_currency = construct_via_currency\n    self._fx_options_tenor_for_interpolation = fx_options_tenor_for_interpolation\n    self._base_depos_tenor = base_depos_tenor\n    self._roll_months = roll_months\n    self._cum_index = cum_index\n    self._contact_type = contract_type\n    self._strike = strike\n    self._premium_output = premium_output\n    self._position_multiplier = position_multiplier\n    self._depo_tenor_for_option = depo_tenor_for_option\n    self._freeze_implied_vol = freeze_implied_vol\n    self._tot_label = tot_label\n    self._cal = cal\n    self._output_calculation_fields = output_calculation_fields"
        ]
    },
    {
        "func_name": "generate_key",
        "original": "def generate_key(self):\n    from findatapy.market.ioengine import SpeedCache\n    return SpeedCache().generate_key(self, ['_market_data_generator', '_calculations', '_calendar', '_filter'])",
        "mutated": [
            "def generate_key(self):\n    if False:\n        i = 10\n    from findatapy.market.ioengine import SpeedCache\n    return SpeedCache().generate_key(self, ['_market_data_generator', '_calculations', '_calendar', '_filter'])",
            "def generate_key(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from findatapy.market.ioengine import SpeedCache\n    return SpeedCache().generate_key(self, ['_market_data_generator', '_calculations', '_calendar', '_filter'])",
            "def generate_key(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from findatapy.market.ioengine import SpeedCache\n    return SpeedCache().generate_key(self, ['_market_data_generator', '_calculations', '_calendar', '_filter'])",
            "def generate_key(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from findatapy.market.ioengine import SpeedCache\n    return SpeedCache().generate_key(self, ['_market_data_generator', '_calculations', '_calendar', '_filter'])",
            "def generate_key(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from findatapy.market.ioengine import SpeedCache\n    return SpeedCache().generate_key(self, ['_market_data_generator', '_calculations', '_calendar', '_filter'])"
        ]
    },
    {
        "func_name": "fetch_continuous_time_series",
        "original": "def fetch_continuous_time_series(self, md_request, market_data_generator, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, construct_via_currency=None, fx_options_tenor_for_interpolation=None, base_depos_tenor=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, depo_tenor_for_option=None, freeze_implied_vol=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if market_data_generator is None:\n        market_data_generator = self._market_data_generator\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if construct_via_currency is None:\n        construct_via_currency = self._construct_via_currency\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if base_depos_tenor is None:\n        base_depos_tenor = self._base_depos_tenor\n    if roll_months is None:\n        roll_months = self._roll_months\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if construct_via_currency == 'no':\n        if fx_vol_surface is None:\n            market = Market(market_data_generator=market_data_generator)\n            md_request_download = MarketDataRequest(md_request=md_request)\n            fx_conv = FXConv()\n            md_request_download.tickers = [fx_conv.correct_notation(x) for x in md_request.tickers]\n            md_request_download.category = 'fx-vol-market'\n            md_request_download.fields = 'close'\n            md_request_download.abstract_curve = None\n            md_request_download.fx_options_tenor = fx_options_tenor_for_interpolation\n            md_request_download.base_depos_tenor = base_depos_tenor\n            forwards_market_df = market.fetch_market(md_request_download)\n        else:\n            forwards_market_df = None\n        return self.construct_total_return_index(md_request.tickers, forwards_market_df, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, freeze_implied_vol=freeze_implied_vol, depo_tenor_for_option=depo_tenor_for_option, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields)\n    else:\n        total_return_indices = []\n        for tick in md_request.tickers:\n            base = tick[0:3]\n            terms = tick[3:6]\n            md_request_base = MarketDataRequest(md_request=md_request)\n            md_request_base.tickers = base + construct_via_currency\n            md_request_terms = MarketDataRequest(md_request=md_request)\n            md_request_terms.tickers = terms + construct_via_currency\n            base_vals = self.fetch_continuous_time_series(md_request_base, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            terms_vals = self.fetch_continuous_time_series(md_request_terms, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            if base + terms == construct_via_currency + construct_via_currency:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                cross_rets = pd.DataFrame(0, index=base_rets.index, columns=base_rets.columns)\n            elif base + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = -self._calculations.calculate_returns(terms_vals)\n            elif terms + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = self._calculations.calculate_returns(base_vals)\n            else:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                terms_rets = self._calculations.calculate_returns(terms_vals)\n                cross_rets = base_rets.sub(terms_rets.iloc[:, 0], axis=0)\n            cross_rets.iloc[0] = 0\n            cross_vals = self._calculations.create_mult_index(cross_rets)\n            cross_vals.columns = [tick + '-option-tot.close']\n            total_return_indices.append(cross_vals)\n        return self._calculations.join(total_return_indices, how='outer')",
        "mutated": [
            "def fetch_continuous_time_series(self, md_request, market_data_generator, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, construct_via_currency=None, fx_options_tenor_for_interpolation=None, base_depos_tenor=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, depo_tenor_for_option=None, freeze_implied_vol=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if market_data_generator is None:\n        market_data_generator = self._market_data_generator\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if construct_via_currency is None:\n        construct_via_currency = self._construct_via_currency\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if base_depos_tenor is None:\n        base_depos_tenor = self._base_depos_tenor\n    if roll_months is None:\n        roll_months = self._roll_months\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if construct_via_currency == 'no':\n        if fx_vol_surface is None:\n            market = Market(market_data_generator=market_data_generator)\n            md_request_download = MarketDataRequest(md_request=md_request)\n            fx_conv = FXConv()\n            md_request_download.tickers = [fx_conv.correct_notation(x) for x in md_request.tickers]\n            md_request_download.category = 'fx-vol-market'\n            md_request_download.fields = 'close'\n            md_request_download.abstract_curve = None\n            md_request_download.fx_options_tenor = fx_options_tenor_for_interpolation\n            md_request_download.base_depos_tenor = base_depos_tenor\n            forwards_market_df = market.fetch_market(md_request_download)\n        else:\n            forwards_market_df = None\n        return self.construct_total_return_index(md_request.tickers, forwards_market_df, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, freeze_implied_vol=freeze_implied_vol, depo_tenor_for_option=depo_tenor_for_option, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields)\n    else:\n        total_return_indices = []\n        for tick in md_request.tickers:\n            base = tick[0:3]\n            terms = tick[3:6]\n            md_request_base = MarketDataRequest(md_request=md_request)\n            md_request_base.tickers = base + construct_via_currency\n            md_request_terms = MarketDataRequest(md_request=md_request)\n            md_request_terms.tickers = terms + construct_via_currency\n            base_vals = self.fetch_continuous_time_series(md_request_base, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            terms_vals = self.fetch_continuous_time_series(md_request_terms, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            if base + terms == construct_via_currency + construct_via_currency:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                cross_rets = pd.DataFrame(0, index=base_rets.index, columns=base_rets.columns)\n            elif base + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = -self._calculations.calculate_returns(terms_vals)\n            elif terms + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = self._calculations.calculate_returns(base_vals)\n            else:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                terms_rets = self._calculations.calculate_returns(terms_vals)\n                cross_rets = base_rets.sub(terms_rets.iloc[:, 0], axis=0)\n            cross_rets.iloc[0] = 0\n            cross_vals = self._calculations.create_mult_index(cross_rets)\n            cross_vals.columns = [tick + '-option-tot.close']\n            total_return_indices.append(cross_vals)\n        return self._calculations.join(total_return_indices, how='outer')",
            "def fetch_continuous_time_series(self, md_request, market_data_generator, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, construct_via_currency=None, fx_options_tenor_for_interpolation=None, base_depos_tenor=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, depo_tenor_for_option=None, freeze_implied_vol=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if market_data_generator is None:\n        market_data_generator = self._market_data_generator\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if construct_via_currency is None:\n        construct_via_currency = self._construct_via_currency\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if base_depos_tenor is None:\n        base_depos_tenor = self._base_depos_tenor\n    if roll_months is None:\n        roll_months = self._roll_months\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if construct_via_currency == 'no':\n        if fx_vol_surface is None:\n            market = Market(market_data_generator=market_data_generator)\n            md_request_download = MarketDataRequest(md_request=md_request)\n            fx_conv = FXConv()\n            md_request_download.tickers = [fx_conv.correct_notation(x) for x in md_request.tickers]\n            md_request_download.category = 'fx-vol-market'\n            md_request_download.fields = 'close'\n            md_request_download.abstract_curve = None\n            md_request_download.fx_options_tenor = fx_options_tenor_for_interpolation\n            md_request_download.base_depos_tenor = base_depos_tenor\n            forwards_market_df = market.fetch_market(md_request_download)\n        else:\n            forwards_market_df = None\n        return self.construct_total_return_index(md_request.tickers, forwards_market_df, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, freeze_implied_vol=freeze_implied_vol, depo_tenor_for_option=depo_tenor_for_option, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields)\n    else:\n        total_return_indices = []\n        for tick in md_request.tickers:\n            base = tick[0:3]\n            terms = tick[3:6]\n            md_request_base = MarketDataRequest(md_request=md_request)\n            md_request_base.tickers = base + construct_via_currency\n            md_request_terms = MarketDataRequest(md_request=md_request)\n            md_request_terms.tickers = terms + construct_via_currency\n            base_vals = self.fetch_continuous_time_series(md_request_base, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            terms_vals = self.fetch_continuous_time_series(md_request_terms, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            if base + terms == construct_via_currency + construct_via_currency:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                cross_rets = pd.DataFrame(0, index=base_rets.index, columns=base_rets.columns)\n            elif base + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = -self._calculations.calculate_returns(terms_vals)\n            elif terms + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = self._calculations.calculate_returns(base_vals)\n            else:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                terms_rets = self._calculations.calculate_returns(terms_vals)\n                cross_rets = base_rets.sub(terms_rets.iloc[:, 0], axis=0)\n            cross_rets.iloc[0] = 0\n            cross_vals = self._calculations.create_mult_index(cross_rets)\n            cross_vals.columns = [tick + '-option-tot.close']\n            total_return_indices.append(cross_vals)\n        return self._calculations.join(total_return_indices, how='outer')",
            "def fetch_continuous_time_series(self, md_request, market_data_generator, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, construct_via_currency=None, fx_options_tenor_for_interpolation=None, base_depos_tenor=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, depo_tenor_for_option=None, freeze_implied_vol=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if market_data_generator is None:\n        market_data_generator = self._market_data_generator\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if construct_via_currency is None:\n        construct_via_currency = self._construct_via_currency\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if base_depos_tenor is None:\n        base_depos_tenor = self._base_depos_tenor\n    if roll_months is None:\n        roll_months = self._roll_months\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if construct_via_currency == 'no':\n        if fx_vol_surface is None:\n            market = Market(market_data_generator=market_data_generator)\n            md_request_download = MarketDataRequest(md_request=md_request)\n            fx_conv = FXConv()\n            md_request_download.tickers = [fx_conv.correct_notation(x) for x in md_request.tickers]\n            md_request_download.category = 'fx-vol-market'\n            md_request_download.fields = 'close'\n            md_request_download.abstract_curve = None\n            md_request_download.fx_options_tenor = fx_options_tenor_for_interpolation\n            md_request_download.base_depos_tenor = base_depos_tenor\n            forwards_market_df = market.fetch_market(md_request_download)\n        else:\n            forwards_market_df = None\n        return self.construct_total_return_index(md_request.tickers, forwards_market_df, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, freeze_implied_vol=freeze_implied_vol, depo_tenor_for_option=depo_tenor_for_option, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields)\n    else:\n        total_return_indices = []\n        for tick in md_request.tickers:\n            base = tick[0:3]\n            terms = tick[3:6]\n            md_request_base = MarketDataRequest(md_request=md_request)\n            md_request_base.tickers = base + construct_via_currency\n            md_request_terms = MarketDataRequest(md_request=md_request)\n            md_request_terms.tickers = terms + construct_via_currency\n            base_vals = self.fetch_continuous_time_series(md_request_base, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            terms_vals = self.fetch_continuous_time_series(md_request_terms, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            if base + terms == construct_via_currency + construct_via_currency:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                cross_rets = pd.DataFrame(0, index=base_rets.index, columns=base_rets.columns)\n            elif base + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = -self._calculations.calculate_returns(terms_vals)\n            elif terms + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = self._calculations.calculate_returns(base_vals)\n            else:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                terms_rets = self._calculations.calculate_returns(terms_vals)\n                cross_rets = base_rets.sub(terms_rets.iloc[:, 0], axis=0)\n            cross_rets.iloc[0] = 0\n            cross_vals = self._calculations.create_mult_index(cross_rets)\n            cross_vals.columns = [tick + '-option-tot.close']\n            total_return_indices.append(cross_vals)\n        return self._calculations.join(total_return_indices, how='outer')",
            "def fetch_continuous_time_series(self, md_request, market_data_generator, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, construct_via_currency=None, fx_options_tenor_for_interpolation=None, base_depos_tenor=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, depo_tenor_for_option=None, freeze_implied_vol=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if market_data_generator is None:\n        market_data_generator = self._market_data_generator\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if construct_via_currency is None:\n        construct_via_currency = self._construct_via_currency\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if base_depos_tenor is None:\n        base_depos_tenor = self._base_depos_tenor\n    if roll_months is None:\n        roll_months = self._roll_months\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if construct_via_currency == 'no':\n        if fx_vol_surface is None:\n            market = Market(market_data_generator=market_data_generator)\n            md_request_download = MarketDataRequest(md_request=md_request)\n            fx_conv = FXConv()\n            md_request_download.tickers = [fx_conv.correct_notation(x) for x in md_request.tickers]\n            md_request_download.category = 'fx-vol-market'\n            md_request_download.fields = 'close'\n            md_request_download.abstract_curve = None\n            md_request_download.fx_options_tenor = fx_options_tenor_for_interpolation\n            md_request_download.base_depos_tenor = base_depos_tenor\n            forwards_market_df = market.fetch_market(md_request_download)\n        else:\n            forwards_market_df = None\n        return self.construct_total_return_index(md_request.tickers, forwards_market_df, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, freeze_implied_vol=freeze_implied_vol, depo_tenor_for_option=depo_tenor_for_option, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields)\n    else:\n        total_return_indices = []\n        for tick in md_request.tickers:\n            base = tick[0:3]\n            terms = tick[3:6]\n            md_request_base = MarketDataRequest(md_request=md_request)\n            md_request_base.tickers = base + construct_via_currency\n            md_request_terms = MarketDataRequest(md_request=md_request)\n            md_request_terms.tickers = terms + construct_via_currency\n            base_vals = self.fetch_continuous_time_series(md_request_base, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            terms_vals = self.fetch_continuous_time_series(md_request_terms, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            if base + terms == construct_via_currency + construct_via_currency:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                cross_rets = pd.DataFrame(0, index=base_rets.index, columns=base_rets.columns)\n            elif base + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = -self._calculations.calculate_returns(terms_vals)\n            elif terms + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = self._calculations.calculate_returns(base_vals)\n            else:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                terms_rets = self._calculations.calculate_returns(terms_vals)\n                cross_rets = base_rets.sub(terms_rets.iloc[:, 0], axis=0)\n            cross_rets.iloc[0] = 0\n            cross_vals = self._calculations.create_mult_index(cross_rets)\n            cross_vals.columns = [tick + '-option-tot.close']\n            total_return_indices.append(cross_vals)\n        return self._calculations.join(total_return_indices, how='outer')",
            "def fetch_continuous_time_series(self, md_request, market_data_generator, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, construct_via_currency=None, fx_options_tenor_for_interpolation=None, base_depos_tenor=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, depo_tenor_for_option=None, freeze_implied_vol=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if market_data_generator is None:\n        market_data_generator = self._market_data_generator\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if construct_via_currency is None:\n        construct_via_currency = self._construct_via_currency\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if base_depos_tenor is None:\n        base_depos_tenor = self._base_depos_tenor\n    if roll_months is None:\n        roll_months = self._roll_months\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if construct_via_currency == 'no':\n        if fx_vol_surface is None:\n            market = Market(market_data_generator=market_data_generator)\n            md_request_download = MarketDataRequest(md_request=md_request)\n            fx_conv = FXConv()\n            md_request_download.tickers = [fx_conv.correct_notation(x) for x in md_request.tickers]\n            md_request_download.category = 'fx-vol-market'\n            md_request_download.fields = 'close'\n            md_request_download.abstract_curve = None\n            md_request_download.fx_options_tenor = fx_options_tenor_for_interpolation\n            md_request_download.base_depos_tenor = base_depos_tenor\n            forwards_market_df = market.fetch_market(md_request_download)\n        else:\n            forwards_market_df = None\n        return self.construct_total_return_index(md_request.tickers, forwards_market_df, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, freeze_implied_vol=freeze_implied_vol, depo_tenor_for_option=depo_tenor_for_option, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields)\n    else:\n        total_return_indices = []\n        for tick in md_request.tickers:\n            base = tick[0:3]\n            terms = tick[3:6]\n            md_request_base = MarketDataRequest(md_request=md_request)\n            md_request_base.tickers = base + construct_via_currency\n            md_request_terms = MarketDataRequest(md_request=md_request)\n            md_request_terms.tickers = terms + construct_via_currency\n            base_vals = self.fetch_continuous_time_series(md_request_base, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, premium_output=premium_output, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            terms_vals = self.fetch_continuous_time_series(md_request_terms, market_data_generator, fx_vol_surface=fx_vol_surface, enter_trading_dates=enter_trading_dates, fx_options_trading_tenor=fx_options_trading_tenor, roll_days_before=roll_days_before, roll_event=roll_event, fx_options_tenor_for_interpolation=fx_options_tenor_for_interpolation, base_depos_tenor=base_depos_tenor, roll_months=roll_months, cum_index=cum_index, strike=strike, contract_type=contract_type, position_multiplier=position_multiplier, depo_tenor_for_option=depo_tenor_for_option, freeze_implied_vol=freeze_implied_vol, tot_label=tot_label, cal=cal, output_calculation_fields=output_calculation_fields, construct_via_currency='no')\n            if base + terms == construct_via_currency + construct_via_currency:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                cross_rets = pd.DataFrame(0, index=base_rets.index, columns=base_rets.columns)\n            elif base + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = -self._calculations.calculate_returns(terms_vals)\n            elif terms + construct_via_currency == construct_via_currency + construct_via_currency:\n                cross_rets = self._calculations.calculate_returns(base_vals)\n            else:\n                base_rets = self._calculations.calculate_returns(base_vals)\n                terms_rets = self._calculations.calculate_returns(terms_vals)\n                cross_rets = base_rets.sub(terms_rets.iloc[:, 0], axis=0)\n            cross_rets.iloc[0] = 0\n            cross_vals = self._calculations.create_mult_index(cross_rets)\n            cross_vals.columns = [tick + '-option-tot.close']\n            total_return_indices.append(cross_vals)\n        return self._calculations.join(total_return_indices, how='outer')"
        ]
    },
    {
        "func_name": "unhedged_asset_fx",
        "original": "def unhedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None):\n    pass",
        "mutated": [
            "def unhedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None):\n    if False:\n        i = 10\n    pass",
            "def unhedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def unhedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def unhedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def unhedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "hedged_asset_fx",
        "original": "def hedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None, total_return_indices_df=None):\n    pass",
        "mutated": [
            "def hedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None, total_return_indices_df=None):\n    if False:\n        i = 10\n    pass",
            "def hedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None, total_return_indices_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def hedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None, total_return_indices_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def hedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None, total_return_indices_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def hedged_asset_fx(self, assets_df, asset_currency, home_curr, start_date, finish_date, spot_df=None, total_return_indices_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "get_day_count_conv",
        "original": "def get_day_count_conv(self, currency):\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
        "mutated": [
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0",
            "def get_day_count_conv(self, currency):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if currency in market_constants.currencies_with_365_basis:\n        return 365.0\n    return 360.0"
        ]
    },
    {
        "func_name": "get_roll_date",
        "original": "def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n    if roll_event == 'month-end':\n        roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    elif roll_event == 'expiry-date':\n        roll_d = expiry_d\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    return roll_d",
        "mutated": [
            "def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n    if False:\n        i = 10\n    if roll_event == 'month-end':\n        roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    elif roll_event == 'expiry-date':\n        roll_d = expiry_d\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    return roll_d",
            "def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if roll_event == 'month-end':\n        roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    elif roll_event == 'expiry-date':\n        roll_d = expiry_d\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    return roll_d",
            "def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if roll_event == 'month-end':\n        roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    elif roll_event == 'expiry-date':\n        roll_d = expiry_d\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    return roll_d",
            "def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if roll_event == 'month-end':\n        roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    elif roll_event == 'expiry-date':\n        roll_d = expiry_d\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    return roll_d",
            "def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if roll_event == 'month-end':\n        roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    elif roll_event == 'expiry-date':\n        roll_d = expiry_d\n        if roll_days_before > 0:\n            return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n    return roll_d"
        ]
    },
    {
        "func_name": "construct_total_return_index",
        "original": "def construct_total_return_index(self, cross_fx, market_df, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, fx_options_tenor_for_interpolation=None, freeze_implied_vol=None, depo_tenor_for_option=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if roll_months is None:\n        roll_months = self._roll_months\n    if cum_index is None:\n        cum_index = self._cum_index\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    total_return_index_df_agg = []\n    if market_df is not None:\n        market_df = market_df.dropna(how='all', axis=1)\n    fx_options_pricer = FXOptionsPricer(premium_output=premium_output)\n\n    def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n        if roll_event == 'month-end':\n            roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        elif roll_event == 'expiry-date':\n            roll_d = expiry_d\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        return roll_d\n    for cross in cross_fx:\n        if cal is None:\n            cal = cross\n        if cross[0:3] == cross[3:6]:\n            total_return_index_df_agg.append(pd.DataFrame(100, index=market_df.index, columns=[cross + '-option-tot.close']))\n        else:\n            old_cross = cross\n            cross = FXConv().correct_notation(cross)\n            if old_cross != cross:\n                pass\n            if fx_vol_surface is None:\n                fx_vol_surface = FXVolSurface(market_df=market_df, asset=cross, tenors=fx_options_tenor_for_interpolation, depo_tenor=depo_tenor_for_option)\n                market_df = fx_vol_surface.get_all_market_data()\n            horizon_date = market_df.index\n            expiry_date = np.zeros(len(horizon_date), dtype=object)\n            roll_date = np.zeros(len(horizon_date), dtype=object)\n            new_trade = np.full(len(horizon_date), False, dtype=bool)\n            exit_trade = np.full(len(horizon_date), False, dtype=bool)\n            has_position = np.full(len(horizon_date), False, dtype=bool)\n            asset_holidays = self._calendar.get_holidays(cal=cross)\n            if enter_trading_dates is None:\n                expiry_date[0] = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[0]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                roll_date[0] = get_roll_date(horizon_date[0], expiry_date[0], asset_holidays, month_adj=0)\n                new_trade[0] = True\n                exit_trade[0] = False\n                has_position[0] = True\n                for i in range(1, len(horizon_date)):\n                    has_position[i] = True\n                    if (horizon_date[i] - roll_date[i - 1]).days >= 0:\n                        new_trade[i] = True\n                    else:\n                        new_trade[i] = False\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        roll_date[i] = get_roll_date(horizon_date[i], expiry_date[i], asset_holidays)\n                        exit_trade[i] = True\n                    elif horizon_date[i] <= expiry_date[i - 1]:\n                        expiry_date[i] = expiry_date[i - 1]\n                        roll_date[i] = roll_date[i - 1]\n                        exit_trade[i] = False\n                    else:\n                        exit_trade[i] = True\n            else:\n                new_trade[horizon_date.searchsorted(enter_trading_dates)] = True\n                has_position[horizon_date.searchsorted(enter_trading_dates)] = True\n                for i in range(0, len(horizon_date)):\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        exit_trade[i] = False\n                    elif i > 0:\n                        if expiry_date[i - 1] == 0:\n                            has_position[i] = False\n                        else:\n                            if horizon_date[i] <= expiry_date[i - 1]:\n                                expiry_date[i] = expiry_date[i - 1]\n                                has_position[i] = True\n                            if horizon_date[i] == expiry_date[i]:\n                                exit_trade[i] = True\n                            else:\n                                exit_trade[i] = False\n            mtm = np.zeros(len(horizon_date))\n            calculated_strike = np.zeros(len(horizon_date))\n            interpolated_option = np.zeros(len(horizon_date))\n            implied_vol = np.zeros(len(horizon_date))\n            delta = np.zeros(len(horizon_date))\n            df_temp = pd.DataFrame()\n            df_temp['expiry-date'] = expiry_date\n            df_temp['horizon-date'] = horizon_date\n            df_temp['roll-date'] = roll_date\n            df_temp['new-trade'] = new_trade\n            df_temp['exit-trade'] = exit_trade\n            df_temp['has-position'] = has_position\n            if has_position[0]:\n                (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[0], strike, expiry_date[0], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                interpolated_option[0] = option_values_\n                calculated_strike[0] = strike_\n                implied_vol[0] = vol_\n            mtm[0] = 0\n            for i in range(1, len(horizon_date)):\n                if exit_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i - 1], expiry_date[i - 1], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    mtm[i] = option_values_\n                    delta[i] = 0\n                    calculated_strike[i] = calculated_strike[i - 1]\n                if new_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], strike, expiry_date[i], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    calculated_strike[i] = strike_\n                    implied_vol[i] = vol_\n                    interpolated_option[i] = option_values_\n                    delta[i] = delta_\n                elif has_position[i] and (not exit_trade[i]):\n                    calculated_strike[i] = calculated_strike[i - 1]\n                    if freeze_implied_vol:\n                        frozen_vol = implied_vol[i - 1]\n                    else:\n                        frozen_vol = None\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i], expiry_date[i], vol=frozen_vol, contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    interpolated_option[i] = option_values_\n                    implied_vol[i] = vol_\n                    mtm[i] = interpolated_option[i]\n                    delta[i] = delta_\n            spot_rets = (market_df[cross + '.close'] / market_df[cross + '.close'].shift(1) - 1).values\n            if tot_label == '':\n                tot_rets = spot_rets\n            else:\n                tot_rets = (market_df[cross + '-' + tot_label + '.close'] / market_df[cross + '-' + tot_label + '.close'].shift(1) - 1).values\n            delta_hedging_pnl = -np.roll(delta, 1) * tot_rets * position_multiplier\n            delta_hedging_pnl[0] = 0\n            option_rets = (mtm - np.roll(interpolated_option, 1)) * position_multiplier\n            option_rets[0] = 0\n            option_delta_rets = delta_hedging_pnl + option_rets\n            if cum_index == 'mult':\n                cum_rets = 100 * np.cumprod(1.0 + option_rets)\n                cum_delta_rets = 100 * np.cumprod(1.0 + delta_hedging_pnl)\n                cum_option_delta_rets = 100 * np.cumprod(1.0 + option_delta_rets)\n            elif cum_index == 'add':\n                cum_rets = 100 + 100 * np.cumsum(option_rets)\n                cum_delta_rets = 100 + 100 * np.cumsum(delta_hedging_pnl)\n                cum_option_delta_rets = 100 + 100 * np.cumsum(option_delta_rets)\n            total_return_index_df = pd.DataFrame(index=horizon_date, columns=[cross + '-option-tot.close'])\n            total_return_index_df[cross + '-option-tot.close'] = cum_rets\n            if output_calculation_fields:\n                total_return_index_df[cross + '-interpolated-option.close'] = interpolated_option\n                total_return_index_df[cross + '-mtm.close'] = mtm\n                total_return_index_df[cross + '.close'] = market_df[cross + '.close'].values\n                total_return_index_df[cross + '-implied-vol.close'] = implied_vol\n                total_return_index_df[cross + '-new-trade.close'] = new_trade\n                total_return_index_df[cross + '.roll-date'] = roll_date\n                total_return_index_df[cross + '-exit-trade.close'] = exit_trade\n                total_return_index_df[cross + '.expiry-date'] = expiry_date\n                total_return_index_df[cross + '-calculated-strike.close'] = calculated_strike\n                total_return_index_df[cross + '-option-return.close'] = option_rets\n                total_return_index_df[cross + '-spot-return.close'] = spot_rets\n                total_return_index_df[cross + '-tot-return.close'] = tot_rets\n                total_return_index_df[cross + '-delta.close'] = delta\n                total_return_index_df[cross + '-delta-pnl-return.close'] = delta_hedging_pnl\n                total_return_index_df[cross + '-delta-pnl-index.close'] = cum_delta_rets\n                total_return_index_df[cross + '-option-delta-return.close'] = option_delta_rets\n                total_return_index_df[cross + '-option-delta-tot.close'] = cum_option_delta_rets\n            total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
        "mutated": [
            "def construct_total_return_index(self, cross_fx, market_df, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, fx_options_tenor_for_interpolation=None, freeze_implied_vol=None, depo_tenor_for_option=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if roll_months is None:\n        roll_months = self._roll_months\n    if cum_index is None:\n        cum_index = self._cum_index\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    total_return_index_df_agg = []\n    if market_df is not None:\n        market_df = market_df.dropna(how='all', axis=1)\n    fx_options_pricer = FXOptionsPricer(premium_output=premium_output)\n\n    def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n        if roll_event == 'month-end':\n            roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        elif roll_event == 'expiry-date':\n            roll_d = expiry_d\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        return roll_d\n    for cross in cross_fx:\n        if cal is None:\n            cal = cross\n        if cross[0:3] == cross[3:6]:\n            total_return_index_df_agg.append(pd.DataFrame(100, index=market_df.index, columns=[cross + '-option-tot.close']))\n        else:\n            old_cross = cross\n            cross = FXConv().correct_notation(cross)\n            if old_cross != cross:\n                pass\n            if fx_vol_surface is None:\n                fx_vol_surface = FXVolSurface(market_df=market_df, asset=cross, tenors=fx_options_tenor_for_interpolation, depo_tenor=depo_tenor_for_option)\n                market_df = fx_vol_surface.get_all_market_data()\n            horizon_date = market_df.index\n            expiry_date = np.zeros(len(horizon_date), dtype=object)\n            roll_date = np.zeros(len(horizon_date), dtype=object)\n            new_trade = np.full(len(horizon_date), False, dtype=bool)\n            exit_trade = np.full(len(horizon_date), False, dtype=bool)\n            has_position = np.full(len(horizon_date), False, dtype=bool)\n            asset_holidays = self._calendar.get_holidays(cal=cross)\n            if enter_trading_dates is None:\n                expiry_date[0] = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[0]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                roll_date[0] = get_roll_date(horizon_date[0], expiry_date[0], asset_holidays, month_adj=0)\n                new_trade[0] = True\n                exit_trade[0] = False\n                has_position[0] = True\n                for i in range(1, len(horizon_date)):\n                    has_position[i] = True\n                    if (horizon_date[i] - roll_date[i - 1]).days >= 0:\n                        new_trade[i] = True\n                    else:\n                        new_trade[i] = False\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        roll_date[i] = get_roll_date(horizon_date[i], expiry_date[i], asset_holidays)\n                        exit_trade[i] = True\n                    elif horizon_date[i] <= expiry_date[i - 1]:\n                        expiry_date[i] = expiry_date[i - 1]\n                        roll_date[i] = roll_date[i - 1]\n                        exit_trade[i] = False\n                    else:\n                        exit_trade[i] = True\n            else:\n                new_trade[horizon_date.searchsorted(enter_trading_dates)] = True\n                has_position[horizon_date.searchsorted(enter_trading_dates)] = True\n                for i in range(0, len(horizon_date)):\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        exit_trade[i] = False\n                    elif i > 0:\n                        if expiry_date[i - 1] == 0:\n                            has_position[i] = False\n                        else:\n                            if horizon_date[i] <= expiry_date[i - 1]:\n                                expiry_date[i] = expiry_date[i - 1]\n                                has_position[i] = True\n                            if horizon_date[i] == expiry_date[i]:\n                                exit_trade[i] = True\n                            else:\n                                exit_trade[i] = False\n            mtm = np.zeros(len(horizon_date))\n            calculated_strike = np.zeros(len(horizon_date))\n            interpolated_option = np.zeros(len(horizon_date))\n            implied_vol = np.zeros(len(horizon_date))\n            delta = np.zeros(len(horizon_date))\n            df_temp = pd.DataFrame()\n            df_temp['expiry-date'] = expiry_date\n            df_temp['horizon-date'] = horizon_date\n            df_temp['roll-date'] = roll_date\n            df_temp['new-trade'] = new_trade\n            df_temp['exit-trade'] = exit_trade\n            df_temp['has-position'] = has_position\n            if has_position[0]:\n                (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[0], strike, expiry_date[0], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                interpolated_option[0] = option_values_\n                calculated_strike[0] = strike_\n                implied_vol[0] = vol_\n            mtm[0] = 0\n            for i in range(1, len(horizon_date)):\n                if exit_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i - 1], expiry_date[i - 1], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    mtm[i] = option_values_\n                    delta[i] = 0\n                    calculated_strike[i] = calculated_strike[i - 1]\n                if new_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], strike, expiry_date[i], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    calculated_strike[i] = strike_\n                    implied_vol[i] = vol_\n                    interpolated_option[i] = option_values_\n                    delta[i] = delta_\n                elif has_position[i] and (not exit_trade[i]):\n                    calculated_strike[i] = calculated_strike[i - 1]\n                    if freeze_implied_vol:\n                        frozen_vol = implied_vol[i - 1]\n                    else:\n                        frozen_vol = None\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i], expiry_date[i], vol=frozen_vol, contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    interpolated_option[i] = option_values_\n                    implied_vol[i] = vol_\n                    mtm[i] = interpolated_option[i]\n                    delta[i] = delta_\n            spot_rets = (market_df[cross + '.close'] / market_df[cross + '.close'].shift(1) - 1).values\n            if tot_label == '':\n                tot_rets = spot_rets\n            else:\n                tot_rets = (market_df[cross + '-' + tot_label + '.close'] / market_df[cross + '-' + tot_label + '.close'].shift(1) - 1).values\n            delta_hedging_pnl = -np.roll(delta, 1) * tot_rets * position_multiplier\n            delta_hedging_pnl[0] = 0\n            option_rets = (mtm - np.roll(interpolated_option, 1)) * position_multiplier\n            option_rets[0] = 0\n            option_delta_rets = delta_hedging_pnl + option_rets\n            if cum_index == 'mult':\n                cum_rets = 100 * np.cumprod(1.0 + option_rets)\n                cum_delta_rets = 100 * np.cumprod(1.0 + delta_hedging_pnl)\n                cum_option_delta_rets = 100 * np.cumprod(1.0 + option_delta_rets)\n            elif cum_index == 'add':\n                cum_rets = 100 + 100 * np.cumsum(option_rets)\n                cum_delta_rets = 100 + 100 * np.cumsum(delta_hedging_pnl)\n                cum_option_delta_rets = 100 + 100 * np.cumsum(option_delta_rets)\n            total_return_index_df = pd.DataFrame(index=horizon_date, columns=[cross + '-option-tot.close'])\n            total_return_index_df[cross + '-option-tot.close'] = cum_rets\n            if output_calculation_fields:\n                total_return_index_df[cross + '-interpolated-option.close'] = interpolated_option\n                total_return_index_df[cross + '-mtm.close'] = mtm\n                total_return_index_df[cross + '.close'] = market_df[cross + '.close'].values\n                total_return_index_df[cross + '-implied-vol.close'] = implied_vol\n                total_return_index_df[cross + '-new-trade.close'] = new_trade\n                total_return_index_df[cross + '.roll-date'] = roll_date\n                total_return_index_df[cross + '-exit-trade.close'] = exit_trade\n                total_return_index_df[cross + '.expiry-date'] = expiry_date\n                total_return_index_df[cross + '-calculated-strike.close'] = calculated_strike\n                total_return_index_df[cross + '-option-return.close'] = option_rets\n                total_return_index_df[cross + '-spot-return.close'] = spot_rets\n                total_return_index_df[cross + '-tot-return.close'] = tot_rets\n                total_return_index_df[cross + '-delta.close'] = delta\n                total_return_index_df[cross + '-delta-pnl-return.close'] = delta_hedging_pnl\n                total_return_index_df[cross + '-delta-pnl-index.close'] = cum_delta_rets\n                total_return_index_df[cross + '-option-delta-return.close'] = option_delta_rets\n                total_return_index_df[cross + '-option-delta-tot.close'] = cum_option_delta_rets\n            total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
            "def construct_total_return_index(self, cross_fx, market_df, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, fx_options_tenor_for_interpolation=None, freeze_implied_vol=None, depo_tenor_for_option=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if roll_months is None:\n        roll_months = self._roll_months\n    if cum_index is None:\n        cum_index = self._cum_index\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    total_return_index_df_agg = []\n    if market_df is not None:\n        market_df = market_df.dropna(how='all', axis=1)\n    fx_options_pricer = FXOptionsPricer(premium_output=premium_output)\n\n    def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n        if roll_event == 'month-end':\n            roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        elif roll_event == 'expiry-date':\n            roll_d = expiry_d\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        return roll_d\n    for cross in cross_fx:\n        if cal is None:\n            cal = cross\n        if cross[0:3] == cross[3:6]:\n            total_return_index_df_agg.append(pd.DataFrame(100, index=market_df.index, columns=[cross + '-option-tot.close']))\n        else:\n            old_cross = cross\n            cross = FXConv().correct_notation(cross)\n            if old_cross != cross:\n                pass\n            if fx_vol_surface is None:\n                fx_vol_surface = FXVolSurface(market_df=market_df, asset=cross, tenors=fx_options_tenor_for_interpolation, depo_tenor=depo_tenor_for_option)\n                market_df = fx_vol_surface.get_all_market_data()\n            horizon_date = market_df.index\n            expiry_date = np.zeros(len(horizon_date), dtype=object)\n            roll_date = np.zeros(len(horizon_date), dtype=object)\n            new_trade = np.full(len(horizon_date), False, dtype=bool)\n            exit_trade = np.full(len(horizon_date), False, dtype=bool)\n            has_position = np.full(len(horizon_date), False, dtype=bool)\n            asset_holidays = self._calendar.get_holidays(cal=cross)\n            if enter_trading_dates is None:\n                expiry_date[0] = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[0]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                roll_date[0] = get_roll_date(horizon_date[0], expiry_date[0], asset_holidays, month_adj=0)\n                new_trade[0] = True\n                exit_trade[0] = False\n                has_position[0] = True\n                for i in range(1, len(horizon_date)):\n                    has_position[i] = True\n                    if (horizon_date[i] - roll_date[i - 1]).days >= 0:\n                        new_trade[i] = True\n                    else:\n                        new_trade[i] = False\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        roll_date[i] = get_roll_date(horizon_date[i], expiry_date[i], asset_holidays)\n                        exit_trade[i] = True\n                    elif horizon_date[i] <= expiry_date[i - 1]:\n                        expiry_date[i] = expiry_date[i - 1]\n                        roll_date[i] = roll_date[i - 1]\n                        exit_trade[i] = False\n                    else:\n                        exit_trade[i] = True\n            else:\n                new_trade[horizon_date.searchsorted(enter_trading_dates)] = True\n                has_position[horizon_date.searchsorted(enter_trading_dates)] = True\n                for i in range(0, len(horizon_date)):\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        exit_trade[i] = False\n                    elif i > 0:\n                        if expiry_date[i - 1] == 0:\n                            has_position[i] = False\n                        else:\n                            if horizon_date[i] <= expiry_date[i - 1]:\n                                expiry_date[i] = expiry_date[i - 1]\n                                has_position[i] = True\n                            if horizon_date[i] == expiry_date[i]:\n                                exit_trade[i] = True\n                            else:\n                                exit_trade[i] = False\n            mtm = np.zeros(len(horizon_date))\n            calculated_strike = np.zeros(len(horizon_date))\n            interpolated_option = np.zeros(len(horizon_date))\n            implied_vol = np.zeros(len(horizon_date))\n            delta = np.zeros(len(horizon_date))\n            df_temp = pd.DataFrame()\n            df_temp['expiry-date'] = expiry_date\n            df_temp['horizon-date'] = horizon_date\n            df_temp['roll-date'] = roll_date\n            df_temp['new-trade'] = new_trade\n            df_temp['exit-trade'] = exit_trade\n            df_temp['has-position'] = has_position\n            if has_position[0]:\n                (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[0], strike, expiry_date[0], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                interpolated_option[0] = option_values_\n                calculated_strike[0] = strike_\n                implied_vol[0] = vol_\n            mtm[0] = 0\n            for i in range(1, len(horizon_date)):\n                if exit_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i - 1], expiry_date[i - 1], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    mtm[i] = option_values_\n                    delta[i] = 0\n                    calculated_strike[i] = calculated_strike[i - 1]\n                if new_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], strike, expiry_date[i], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    calculated_strike[i] = strike_\n                    implied_vol[i] = vol_\n                    interpolated_option[i] = option_values_\n                    delta[i] = delta_\n                elif has_position[i] and (not exit_trade[i]):\n                    calculated_strike[i] = calculated_strike[i - 1]\n                    if freeze_implied_vol:\n                        frozen_vol = implied_vol[i - 1]\n                    else:\n                        frozen_vol = None\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i], expiry_date[i], vol=frozen_vol, contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    interpolated_option[i] = option_values_\n                    implied_vol[i] = vol_\n                    mtm[i] = interpolated_option[i]\n                    delta[i] = delta_\n            spot_rets = (market_df[cross + '.close'] / market_df[cross + '.close'].shift(1) - 1).values\n            if tot_label == '':\n                tot_rets = spot_rets\n            else:\n                tot_rets = (market_df[cross + '-' + tot_label + '.close'] / market_df[cross + '-' + tot_label + '.close'].shift(1) - 1).values\n            delta_hedging_pnl = -np.roll(delta, 1) * tot_rets * position_multiplier\n            delta_hedging_pnl[0] = 0\n            option_rets = (mtm - np.roll(interpolated_option, 1)) * position_multiplier\n            option_rets[0] = 0\n            option_delta_rets = delta_hedging_pnl + option_rets\n            if cum_index == 'mult':\n                cum_rets = 100 * np.cumprod(1.0 + option_rets)\n                cum_delta_rets = 100 * np.cumprod(1.0 + delta_hedging_pnl)\n                cum_option_delta_rets = 100 * np.cumprod(1.0 + option_delta_rets)\n            elif cum_index == 'add':\n                cum_rets = 100 + 100 * np.cumsum(option_rets)\n                cum_delta_rets = 100 + 100 * np.cumsum(delta_hedging_pnl)\n                cum_option_delta_rets = 100 + 100 * np.cumsum(option_delta_rets)\n            total_return_index_df = pd.DataFrame(index=horizon_date, columns=[cross + '-option-tot.close'])\n            total_return_index_df[cross + '-option-tot.close'] = cum_rets\n            if output_calculation_fields:\n                total_return_index_df[cross + '-interpolated-option.close'] = interpolated_option\n                total_return_index_df[cross + '-mtm.close'] = mtm\n                total_return_index_df[cross + '.close'] = market_df[cross + '.close'].values\n                total_return_index_df[cross + '-implied-vol.close'] = implied_vol\n                total_return_index_df[cross + '-new-trade.close'] = new_trade\n                total_return_index_df[cross + '.roll-date'] = roll_date\n                total_return_index_df[cross + '-exit-trade.close'] = exit_trade\n                total_return_index_df[cross + '.expiry-date'] = expiry_date\n                total_return_index_df[cross + '-calculated-strike.close'] = calculated_strike\n                total_return_index_df[cross + '-option-return.close'] = option_rets\n                total_return_index_df[cross + '-spot-return.close'] = spot_rets\n                total_return_index_df[cross + '-tot-return.close'] = tot_rets\n                total_return_index_df[cross + '-delta.close'] = delta\n                total_return_index_df[cross + '-delta-pnl-return.close'] = delta_hedging_pnl\n                total_return_index_df[cross + '-delta-pnl-index.close'] = cum_delta_rets\n                total_return_index_df[cross + '-option-delta-return.close'] = option_delta_rets\n                total_return_index_df[cross + '-option-delta-tot.close'] = cum_option_delta_rets\n            total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
            "def construct_total_return_index(self, cross_fx, market_df, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, fx_options_tenor_for_interpolation=None, freeze_implied_vol=None, depo_tenor_for_option=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if roll_months is None:\n        roll_months = self._roll_months\n    if cum_index is None:\n        cum_index = self._cum_index\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    total_return_index_df_agg = []\n    if market_df is not None:\n        market_df = market_df.dropna(how='all', axis=1)\n    fx_options_pricer = FXOptionsPricer(premium_output=premium_output)\n\n    def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n        if roll_event == 'month-end':\n            roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        elif roll_event == 'expiry-date':\n            roll_d = expiry_d\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        return roll_d\n    for cross in cross_fx:\n        if cal is None:\n            cal = cross\n        if cross[0:3] == cross[3:6]:\n            total_return_index_df_agg.append(pd.DataFrame(100, index=market_df.index, columns=[cross + '-option-tot.close']))\n        else:\n            old_cross = cross\n            cross = FXConv().correct_notation(cross)\n            if old_cross != cross:\n                pass\n            if fx_vol_surface is None:\n                fx_vol_surface = FXVolSurface(market_df=market_df, asset=cross, tenors=fx_options_tenor_for_interpolation, depo_tenor=depo_tenor_for_option)\n                market_df = fx_vol_surface.get_all_market_data()\n            horizon_date = market_df.index\n            expiry_date = np.zeros(len(horizon_date), dtype=object)\n            roll_date = np.zeros(len(horizon_date), dtype=object)\n            new_trade = np.full(len(horizon_date), False, dtype=bool)\n            exit_trade = np.full(len(horizon_date), False, dtype=bool)\n            has_position = np.full(len(horizon_date), False, dtype=bool)\n            asset_holidays = self._calendar.get_holidays(cal=cross)\n            if enter_trading_dates is None:\n                expiry_date[0] = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[0]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                roll_date[0] = get_roll_date(horizon_date[0], expiry_date[0], asset_holidays, month_adj=0)\n                new_trade[0] = True\n                exit_trade[0] = False\n                has_position[0] = True\n                for i in range(1, len(horizon_date)):\n                    has_position[i] = True\n                    if (horizon_date[i] - roll_date[i - 1]).days >= 0:\n                        new_trade[i] = True\n                    else:\n                        new_trade[i] = False\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        roll_date[i] = get_roll_date(horizon_date[i], expiry_date[i], asset_holidays)\n                        exit_trade[i] = True\n                    elif horizon_date[i] <= expiry_date[i - 1]:\n                        expiry_date[i] = expiry_date[i - 1]\n                        roll_date[i] = roll_date[i - 1]\n                        exit_trade[i] = False\n                    else:\n                        exit_trade[i] = True\n            else:\n                new_trade[horizon_date.searchsorted(enter_trading_dates)] = True\n                has_position[horizon_date.searchsorted(enter_trading_dates)] = True\n                for i in range(0, len(horizon_date)):\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        exit_trade[i] = False\n                    elif i > 0:\n                        if expiry_date[i - 1] == 0:\n                            has_position[i] = False\n                        else:\n                            if horizon_date[i] <= expiry_date[i - 1]:\n                                expiry_date[i] = expiry_date[i - 1]\n                                has_position[i] = True\n                            if horizon_date[i] == expiry_date[i]:\n                                exit_trade[i] = True\n                            else:\n                                exit_trade[i] = False\n            mtm = np.zeros(len(horizon_date))\n            calculated_strike = np.zeros(len(horizon_date))\n            interpolated_option = np.zeros(len(horizon_date))\n            implied_vol = np.zeros(len(horizon_date))\n            delta = np.zeros(len(horizon_date))\n            df_temp = pd.DataFrame()\n            df_temp['expiry-date'] = expiry_date\n            df_temp['horizon-date'] = horizon_date\n            df_temp['roll-date'] = roll_date\n            df_temp['new-trade'] = new_trade\n            df_temp['exit-trade'] = exit_trade\n            df_temp['has-position'] = has_position\n            if has_position[0]:\n                (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[0], strike, expiry_date[0], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                interpolated_option[0] = option_values_\n                calculated_strike[0] = strike_\n                implied_vol[0] = vol_\n            mtm[0] = 0\n            for i in range(1, len(horizon_date)):\n                if exit_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i - 1], expiry_date[i - 1], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    mtm[i] = option_values_\n                    delta[i] = 0\n                    calculated_strike[i] = calculated_strike[i - 1]\n                if new_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], strike, expiry_date[i], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    calculated_strike[i] = strike_\n                    implied_vol[i] = vol_\n                    interpolated_option[i] = option_values_\n                    delta[i] = delta_\n                elif has_position[i] and (not exit_trade[i]):\n                    calculated_strike[i] = calculated_strike[i - 1]\n                    if freeze_implied_vol:\n                        frozen_vol = implied_vol[i - 1]\n                    else:\n                        frozen_vol = None\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i], expiry_date[i], vol=frozen_vol, contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    interpolated_option[i] = option_values_\n                    implied_vol[i] = vol_\n                    mtm[i] = interpolated_option[i]\n                    delta[i] = delta_\n            spot_rets = (market_df[cross + '.close'] / market_df[cross + '.close'].shift(1) - 1).values\n            if tot_label == '':\n                tot_rets = spot_rets\n            else:\n                tot_rets = (market_df[cross + '-' + tot_label + '.close'] / market_df[cross + '-' + tot_label + '.close'].shift(1) - 1).values\n            delta_hedging_pnl = -np.roll(delta, 1) * tot_rets * position_multiplier\n            delta_hedging_pnl[0] = 0\n            option_rets = (mtm - np.roll(interpolated_option, 1)) * position_multiplier\n            option_rets[0] = 0\n            option_delta_rets = delta_hedging_pnl + option_rets\n            if cum_index == 'mult':\n                cum_rets = 100 * np.cumprod(1.0 + option_rets)\n                cum_delta_rets = 100 * np.cumprod(1.0 + delta_hedging_pnl)\n                cum_option_delta_rets = 100 * np.cumprod(1.0 + option_delta_rets)\n            elif cum_index == 'add':\n                cum_rets = 100 + 100 * np.cumsum(option_rets)\n                cum_delta_rets = 100 + 100 * np.cumsum(delta_hedging_pnl)\n                cum_option_delta_rets = 100 + 100 * np.cumsum(option_delta_rets)\n            total_return_index_df = pd.DataFrame(index=horizon_date, columns=[cross + '-option-tot.close'])\n            total_return_index_df[cross + '-option-tot.close'] = cum_rets\n            if output_calculation_fields:\n                total_return_index_df[cross + '-interpolated-option.close'] = interpolated_option\n                total_return_index_df[cross + '-mtm.close'] = mtm\n                total_return_index_df[cross + '.close'] = market_df[cross + '.close'].values\n                total_return_index_df[cross + '-implied-vol.close'] = implied_vol\n                total_return_index_df[cross + '-new-trade.close'] = new_trade\n                total_return_index_df[cross + '.roll-date'] = roll_date\n                total_return_index_df[cross + '-exit-trade.close'] = exit_trade\n                total_return_index_df[cross + '.expiry-date'] = expiry_date\n                total_return_index_df[cross + '-calculated-strike.close'] = calculated_strike\n                total_return_index_df[cross + '-option-return.close'] = option_rets\n                total_return_index_df[cross + '-spot-return.close'] = spot_rets\n                total_return_index_df[cross + '-tot-return.close'] = tot_rets\n                total_return_index_df[cross + '-delta.close'] = delta\n                total_return_index_df[cross + '-delta-pnl-return.close'] = delta_hedging_pnl\n                total_return_index_df[cross + '-delta-pnl-index.close'] = cum_delta_rets\n                total_return_index_df[cross + '-option-delta-return.close'] = option_delta_rets\n                total_return_index_df[cross + '-option-delta-tot.close'] = cum_option_delta_rets\n            total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
            "def construct_total_return_index(self, cross_fx, market_df, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, fx_options_tenor_for_interpolation=None, freeze_implied_vol=None, depo_tenor_for_option=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if roll_months is None:\n        roll_months = self._roll_months\n    if cum_index is None:\n        cum_index = self._cum_index\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    total_return_index_df_agg = []\n    if market_df is not None:\n        market_df = market_df.dropna(how='all', axis=1)\n    fx_options_pricer = FXOptionsPricer(premium_output=premium_output)\n\n    def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n        if roll_event == 'month-end':\n            roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        elif roll_event == 'expiry-date':\n            roll_d = expiry_d\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        return roll_d\n    for cross in cross_fx:\n        if cal is None:\n            cal = cross\n        if cross[0:3] == cross[3:6]:\n            total_return_index_df_agg.append(pd.DataFrame(100, index=market_df.index, columns=[cross + '-option-tot.close']))\n        else:\n            old_cross = cross\n            cross = FXConv().correct_notation(cross)\n            if old_cross != cross:\n                pass\n            if fx_vol_surface is None:\n                fx_vol_surface = FXVolSurface(market_df=market_df, asset=cross, tenors=fx_options_tenor_for_interpolation, depo_tenor=depo_tenor_for_option)\n                market_df = fx_vol_surface.get_all_market_data()\n            horizon_date = market_df.index\n            expiry_date = np.zeros(len(horizon_date), dtype=object)\n            roll_date = np.zeros(len(horizon_date), dtype=object)\n            new_trade = np.full(len(horizon_date), False, dtype=bool)\n            exit_trade = np.full(len(horizon_date), False, dtype=bool)\n            has_position = np.full(len(horizon_date), False, dtype=bool)\n            asset_holidays = self._calendar.get_holidays(cal=cross)\n            if enter_trading_dates is None:\n                expiry_date[0] = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[0]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                roll_date[0] = get_roll_date(horizon_date[0], expiry_date[0], asset_holidays, month_adj=0)\n                new_trade[0] = True\n                exit_trade[0] = False\n                has_position[0] = True\n                for i in range(1, len(horizon_date)):\n                    has_position[i] = True\n                    if (horizon_date[i] - roll_date[i - 1]).days >= 0:\n                        new_trade[i] = True\n                    else:\n                        new_trade[i] = False\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        roll_date[i] = get_roll_date(horizon_date[i], expiry_date[i], asset_holidays)\n                        exit_trade[i] = True\n                    elif horizon_date[i] <= expiry_date[i - 1]:\n                        expiry_date[i] = expiry_date[i - 1]\n                        roll_date[i] = roll_date[i - 1]\n                        exit_trade[i] = False\n                    else:\n                        exit_trade[i] = True\n            else:\n                new_trade[horizon_date.searchsorted(enter_trading_dates)] = True\n                has_position[horizon_date.searchsorted(enter_trading_dates)] = True\n                for i in range(0, len(horizon_date)):\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        exit_trade[i] = False\n                    elif i > 0:\n                        if expiry_date[i - 1] == 0:\n                            has_position[i] = False\n                        else:\n                            if horizon_date[i] <= expiry_date[i - 1]:\n                                expiry_date[i] = expiry_date[i - 1]\n                                has_position[i] = True\n                            if horizon_date[i] == expiry_date[i]:\n                                exit_trade[i] = True\n                            else:\n                                exit_trade[i] = False\n            mtm = np.zeros(len(horizon_date))\n            calculated_strike = np.zeros(len(horizon_date))\n            interpolated_option = np.zeros(len(horizon_date))\n            implied_vol = np.zeros(len(horizon_date))\n            delta = np.zeros(len(horizon_date))\n            df_temp = pd.DataFrame()\n            df_temp['expiry-date'] = expiry_date\n            df_temp['horizon-date'] = horizon_date\n            df_temp['roll-date'] = roll_date\n            df_temp['new-trade'] = new_trade\n            df_temp['exit-trade'] = exit_trade\n            df_temp['has-position'] = has_position\n            if has_position[0]:\n                (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[0], strike, expiry_date[0], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                interpolated_option[0] = option_values_\n                calculated_strike[0] = strike_\n                implied_vol[0] = vol_\n            mtm[0] = 0\n            for i in range(1, len(horizon_date)):\n                if exit_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i - 1], expiry_date[i - 1], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    mtm[i] = option_values_\n                    delta[i] = 0\n                    calculated_strike[i] = calculated_strike[i - 1]\n                if new_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], strike, expiry_date[i], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    calculated_strike[i] = strike_\n                    implied_vol[i] = vol_\n                    interpolated_option[i] = option_values_\n                    delta[i] = delta_\n                elif has_position[i] and (not exit_trade[i]):\n                    calculated_strike[i] = calculated_strike[i - 1]\n                    if freeze_implied_vol:\n                        frozen_vol = implied_vol[i - 1]\n                    else:\n                        frozen_vol = None\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i], expiry_date[i], vol=frozen_vol, contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    interpolated_option[i] = option_values_\n                    implied_vol[i] = vol_\n                    mtm[i] = interpolated_option[i]\n                    delta[i] = delta_\n            spot_rets = (market_df[cross + '.close'] / market_df[cross + '.close'].shift(1) - 1).values\n            if tot_label == '':\n                tot_rets = spot_rets\n            else:\n                tot_rets = (market_df[cross + '-' + tot_label + '.close'] / market_df[cross + '-' + tot_label + '.close'].shift(1) - 1).values\n            delta_hedging_pnl = -np.roll(delta, 1) * tot_rets * position_multiplier\n            delta_hedging_pnl[0] = 0\n            option_rets = (mtm - np.roll(interpolated_option, 1)) * position_multiplier\n            option_rets[0] = 0\n            option_delta_rets = delta_hedging_pnl + option_rets\n            if cum_index == 'mult':\n                cum_rets = 100 * np.cumprod(1.0 + option_rets)\n                cum_delta_rets = 100 * np.cumprod(1.0 + delta_hedging_pnl)\n                cum_option_delta_rets = 100 * np.cumprod(1.0 + option_delta_rets)\n            elif cum_index == 'add':\n                cum_rets = 100 + 100 * np.cumsum(option_rets)\n                cum_delta_rets = 100 + 100 * np.cumsum(delta_hedging_pnl)\n                cum_option_delta_rets = 100 + 100 * np.cumsum(option_delta_rets)\n            total_return_index_df = pd.DataFrame(index=horizon_date, columns=[cross + '-option-tot.close'])\n            total_return_index_df[cross + '-option-tot.close'] = cum_rets\n            if output_calculation_fields:\n                total_return_index_df[cross + '-interpolated-option.close'] = interpolated_option\n                total_return_index_df[cross + '-mtm.close'] = mtm\n                total_return_index_df[cross + '.close'] = market_df[cross + '.close'].values\n                total_return_index_df[cross + '-implied-vol.close'] = implied_vol\n                total_return_index_df[cross + '-new-trade.close'] = new_trade\n                total_return_index_df[cross + '.roll-date'] = roll_date\n                total_return_index_df[cross + '-exit-trade.close'] = exit_trade\n                total_return_index_df[cross + '.expiry-date'] = expiry_date\n                total_return_index_df[cross + '-calculated-strike.close'] = calculated_strike\n                total_return_index_df[cross + '-option-return.close'] = option_rets\n                total_return_index_df[cross + '-spot-return.close'] = spot_rets\n                total_return_index_df[cross + '-tot-return.close'] = tot_rets\n                total_return_index_df[cross + '-delta.close'] = delta\n                total_return_index_df[cross + '-delta-pnl-return.close'] = delta_hedging_pnl\n                total_return_index_df[cross + '-delta-pnl-index.close'] = cum_delta_rets\n                total_return_index_df[cross + '-option-delta-return.close'] = option_delta_rets\n                total_return_index_df[cross + '-option-delta-tot.close'] = cum_option_delta_rets\n            total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
            "def construct_total_return_index(self, cross_fx, market_df, fx_vol_surface=None, enter_trading_dates=None, fx_options_trading_tenor=None, roll_days_before=None, roll_event=None, roll_months=None, cum_index=None, strike=None, contract_type=None, premium_output=None, position_multiplier=None, fx_options_tenor_for_interpolation=None, freeze_implied_vol=None, depo_tenor_for_option=None, tot_label=None, cal=None, output_calculation_fields=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if fx_vol_surface is None:\n        fx_vol_surface = self._fx_vol_surface\n    if enter_trading_dates is None:\n        enter_trading_dates = self._enter_trading_dates\n    if fx_options_trading_tenor is None:\n        fx_options_trading_tenor = self._fx_options_trading_tenor\n    if roll_days_before is None:\n        roll_days_before = self._roll_days_before\n    if roll_event is None:\n        roll_event = self._roll_event\n    if roll_months is None:\n        roll_months = self._roll_months\n    if cum_index is None:\n        cum_index = self._cum_index\n    if strike is None:\n        strike = self._strike\n    if contract_type is None:\n        contract_type = self._contact_type\n    if premium_output is None:\n        premium_output = self._premium_output\n    if position_multiplier is None:\n        position_multiplier = self._position_multiplier\n    if fx_options_tenor_for_interpolation is None:\n        fx_options_tenor_for_interpolation = self._fx_options_tenor_for_interpolation\n    if freeze_implied_vol is None:\n        freeze_implied_vol = self._freeze_implied_vol\n    if depo_tenor_for_option is None:\n        depo_tenor_for_option = self._depo_tenor_for_option\n    if tot_label is None:\n        tot_label = self._tot_label\n    if cal is None:\n        cal = self._cal\n    if output_calculation_fields is None:\n        output_calculation_fields = self._output_calculation_fields\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    total_return_index_df_agg = []\n    if market_df is not None:\n        market_df = market_df.dropna(how='all', axis=1)\n    fx_options_pricer = FXOptionsPricer(premium_output=premium_output)\n\n    def get_roll_date(horizon_d, expiry_d, asset_hols, month_adj=0):\n        if roll_event == 'month-end':\n            roll_d = horizon_d + CustomBusinessMonthEnd(roll_months + month_adj, holidays=asset_hols)\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        elif roll_event == 'expiry-date':\n            roll_d = expiry_d\n            if roll_days_before > 0:\n                return roll_d - CustomBusinessDay(n=roll_days_before, holidays=asset_hols)\n        return roll_d\n    for cross in cross_fx:\n        if cal is None:\n            cal = cross\n        if cross[0:3] == cross[3:6]:\n            total_return_index_df_agg.append(pd.DataFrame(100, index=market_df.index, columns=[cross + '-option-tot.close']))\n        else:\n            old_cross = cross\n            cross = FXConv().correct_notation(cross)\n            if old_cross != cross:\n                pass\n            if fx_vol_surface is None:\n                fx_vol_surface = FXVolSurface(market_df=market_df, asset=cross, tenors=fx_options_tenor_for_interpolation, depo_tenor=depo_tenor_for_option)\n                market_df = fx_vol_surface.get_all_market_data()\n            horizon_date = market_df.index\n            expiry_date = np.zeros(len(horizon_date), dtype=object)\n            roll_date = np.zeros(len(horizon_date), dtype=object)\n            new_trade = np.full(len(horizon_date), False, dtype=bool)\n            exit_trade = np.full(len(horizon_date), False, dtype=bool)\n            has_position = np.full(len(horizon_date), False, dtype=bool)\n            asset_holidays = self._calendar.get_holidays(cal=cross)\n            if enter_trading_dates is None:\n                expiry_date[0] = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[0]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                roll_date[0] = get_roll_date(horizon_date[0], expiry_date[0], asset_holidays, month_adj=0)\n                new_trade[0] = True\n                exit_trade[0] = False\n                has_position[0] = True\n                for i in range(1, len(horizon_date)):\n                    has_position[i] = True\n                    if (horizon_date[i] - roll_date[i - 1]).days >= 0:\n                        new_trade[i] = True\n                    else:\n                        new_trade[i] = False\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        roll_date[i] = get_roll_date(horizon_date[i], expiry_date[i], asset_holidays)\n                        exit_trade[i] = True\n                    elif horizon_date[i] <= expiry_date[i - 1]:\n                        expiry_date[i] = expiry_date[i - 1]\n                        roll_date[i] = roll_date[i - 1]\n                        exit_trade[i] = False\n                    else:\n                        exit_trade[i] = True\n            else:\n                new_trade[horizon_date.searchsorted(enter_trading_dates)] = True\n                has_position[horizon_date.searchsorted(enter_trading_dates)] = True\n                for i in range(0, len(horizon_date)):\n                    if new_trade[i]:\n                        exp = self._calendar.get_expiry_date_from_horizon_date(pd.DatetimeIndex([horizon_date[i]]), fx_options_trading_tenor, cal=cal, asset_class='fx-vol')[0]\n                        if exp not in market_df.index:\n                            exp_index = market_df.index.searchsorted(exp)\n                            if exp_index < len(market_df.index):\n                                exp_index = min(exp_index, len(market_df.index))\n                                exp = market_df.index[exp_index]\n                        expiry_date[i] = exp\n                        exit_trade[i] = False\n                    elif i > 0:\n                        if expiry_date[i - 1] == 0:\n                            has_position[i] = False\n                        else:\n                            if horizon_date[i] <= expiry_date[i - 1]:\n                                expiry_date[i] = expiry_date[i - 1]\n                                has_position[i] = True\n                            if horizon_date[i] == expiry_date[i]:\n                                exit_trade[i] = True\n                            else:\n                                exit_trade[i] = False\n            mtm = np.zeros(len(horizon_date))\n            calculated_strike = np.zeros(len(horizon_date))\n            interpolated_option = np.zeros(len(horizon_date))\n            implied_vol = np.zeros(len(horizon_date))\n            delta = np.zeros(len(horizon_date))\n            df_temp = pd.DataFrame()\n            df_temp['expiry-date'] = expiry_date\n            df_temp['horizon-date'] = horizon_date\n            df_temp['roll-date'] = roll_date\n            df_temp['new-trade'] = new_trade\n            df_temp['exit-trade'] = exit_trade\n            df_temp['has-position'] = has_position\n            if has_position[0]:\n                (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[0], strike, expiry_date[0], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                interpolated_option[0] = option_values_\n                calculated_strike[0] = strike_\n                implied_vol[0] = vol_\n            mtm[0] = 0\n            for i in range(1, len(horizon_date)):\n                if exit_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i - 1], expiry_date[i - 1], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    mtm[i] = option_values_\n                    delta[i] = 0\n                    calculated_strike[i] = calculated_strike[i - 1]\n                if new_trade[i]:\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], strike, expiry_date[i], contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    calculated_strike[i] = strike_\n                    implied_vol[i] = vol_\n                    interpolated_option[i] = option_values_\n                    delta[i] = delta_\n                elif has_position[i] and (not exit_trade[i]):\n                    calculated_strike[i] = calculated_strike[i - 1]\n                    if freeze_implied_vol:\n                        frozen_vol = implied_vol[i - 1]\n                    else:\n                        frozen_vol = None\n                    (option_values_, spot_, strike_, vol_, delta_, expiry_date_, intrinsic_values_) = fx_options_pricer.price_instrument(cross, horizon_date[i], calculated_strike[i], expiry_date[i], vol=frozen_vol, contract_type=contract_type, tenor=fx_options_trading_tenor, fx_vol_surface=fx_vol_surface, return_as_df=False)\n                    interpolated_option[i] = option_values_\n                    implied_vol[i] = vol_\n                    mtm[i] = interpolated_option[i]\n                    delta[i] = delta_\n            spot_rets = (market_df[cross + '.close'] / market_df[cross + '.close'].shift(1) - 1).values\n            if tot_label == '':\n                tot_rets = spot_rets\n            else:\n                tot_rets = (market_df[cross + '-' + tot_label + '.close'] / market_df[cross + '-' + tot_label + '.close'].shift(1) - 1).values\n            delta_hedging_pnl = -np.roll(delta, 1) * tot_rets * position_multiplier\n            delta_hedging_pnl[0] = 0\n            option_rets = (mtm - np.roll(interpolated_option, 1)) * position_multiplier\n            option_rets[0] = 0\n            option_delta_rets = delta_hedging_pnl + option_rets\n            if cum_index == 'mult':\n                cum_rets = 100 * np.cumprod(1.0 + option_rets)\n                cum_delta_rets = 100 * np.cumprod(1.0 + delta_hedging_pnl)\n                cum_option_delta_rets = 100 * np.cumprod(1.0 + option_delta_rets)\n            elif cum_index == 'add':\n                cum_rets = 100 + 100 * np.cumsum(option_rets)\n                cum_delta_rets = 100 + 100 * np.cumsum(delta_hedging_pnl)\n                cum_option_delta_rets = 100 + 100 * np.cumsum(option_delta_rets)\n            total_return_index_df = pd.DataFrame(index=horizon_date, columns=[cross + '-option-tot.close'])\n            total_return_index_df[cross + '-option-tot.close'] = cum_rets\n            if output_calculation_fields:\n                total_return_index_df[cross + '-interpolated-option.close'] = interpolated_option\n                total_return_index_df[cross + '-mtm.close'] = mtm\n                total_return_index_df[cross + '.close'] = market_df[cross + '.close'].values\n                total_return_index_df[cross + '-implied-vol.close'] = implied_vol\n                total_return_index_df[cross + '-new-trade.close'] = new_trade\n                total_return_index_df[cross + '.roll-date'] = roll_date\n                total_return_index_df[cross + '-exit-trade.close'] = exit_trade\n                total_return_index_df[cross + '.expiry-date'] = expiry_date\n                total_return_index_df[cross + '-calculated-strike.close'] = calculated_strike\n                total_return_index_df[cross + '-option-return.close'] = option_rets\n                total_return_index_df[cross + '-spot-return.close'] = spot_rets\n                total_return_index_df[cross + '-tot-return.close'] = tot_rets\n                total_return_index_df[cross + '-delta.close'] = delta\n                total_return_index_df[cross + '-delta-pnl-return.close'] = delta_hedging_pnl\n                total_return_index_df[cross + '-delta-pnl-index.close'] = cum_delta_rets\n                total_return_index_df[cross + '-option-delta-return.close'] = option_delta_rets\n                total_return_index_df[cross + '-option-delta-tot.close'] = cum_option_delta_rets\n            total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')"
        ]
    },
    {
        "func_name": "apply_tc_signals_to_total_return_index",
        "original": "def apply_tc_signals_to_total_return_index(self, cross_fx, total_return_index_orig_df, option_tc_bp, spot_tc_bp, signal_df=None, cum_index=None):\n    if cum_index is None:\n        cum_index = self._cum_index\n    total_return_index_df_agg = []\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    option_tc = option_tc_bp / (2 * 100 * 100)\n    spot_tc = spot_tc_bp / (2 * 100 * 100)\n    total_return_index_df = total_return_index_orig_df.copy()\n    for cross in cross_fx:\n        total_return_index_df[cross + '-option-return-with-tc.close'] = total_return_index_df[cross + '-option-return.close'] - abs(total_return_index_df[cross + '-new-trade.close'].shift(1)) * option_tc\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'] = total_return_index_df[cross + '-delta-pnl-return.close'] - abs(total_return_index_df[cross + '-delta.close'] - total_return_index_df[cross + '-delta.close'].shift(1)) * spot_tc\n        total_return_index_df[cross + '-option-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-option-delta-return-with-tc.close'] = total_return_index_df[cross + '-option-return-with-tc.close'] + total_return_index_df[cross + '-delta-pnl-return-with-tc.close']\n        if cum_index == 'mult':\n            cum_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        elif cum_index == 'add':\n            cum_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        total_return_index_df[cross + '-option-tot-with-tc.close'] = cum_rets\n        total_return_index_df[cross + '-delta-pnl-index-with-tc.close'] = cum_delta_rets\n        total_return_index_df[cross + '-option-delta-tot-with-tc.close'] = cum_option_delta_rets\n        total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
        "mutated": [
            "def apply_tc_signals_to_total_return_index(self, cross_fx, total_return_index_orig_df, option_tc_bp, spot_tc_bp, signal_df=None, cum_index=None):\n    if False:\n        i = 10\n    if cum_index is None:\n        cum_index = self._cum_index\n    total_return_index_df_agg = []\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    option_tc = option_tc_bp / (2 * 100 * 100)\n    spot_tc = spot_tc_bp / (2 * 100 * 100)\n    total_return_index_df = total_return_index_orig_df.copy()\n    for cross in cross_fx:\n        total_return_index_df[cross + '-option-return-with-tc.close'] = total_return_index_df[cross + '-option-return.close'] - abs(total_return_index_df[cross + '-new-trade.close'].shift(1)) * option_tc\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'] = total_return_index_df[cross + '-delta-pnl-return.close'] - abs(total_return_index_df[cross + '-delta.close'] - total_return_index_df[cross + '-delta.close'].shift(1)) * spot_tc\n        total_return_index_df[cross + '-option-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-option-delta-return-with-tc.close'] = total_return_index_df[cross + '-option-return-with-tc.close'] + total_return_index_df[cross + '-delta-pnl-return-with-tc.close']\n        if cum_index == 'mult':\n            cum_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        elif cum_index == 'add':\n            cum_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        total_return_index_df[cross + '-option-tot-with-tc.close'] = cum_rets\n        total_return_index_df[cross + '-delta-pnl-index-with-tc.close'] = cum_delta_rets\n        total_return_index_df[cross + '-option-delta-tot-with-tc.close'] = cum_option_delta_rets\n        total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
            "def apply_tc_signals_to_total_return_index(self, cross_fx, total_return_index_orig_df, option_tc_bp, spot_tc_bp, signal_df=None, cum_index=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if cum_index is None:\n        cum_index = self._cum_index\n    total_return_index_df_agg = []\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    option_tc = option_tc_bp / (2 * 100 * 100)\n    spot_tc = spot_tc_bp / (2 * 100 * 100)\n    total_return_index_df = total_return_index_orig_df.copy()\n    for cross in cross_fx:\n        total_return_index_df[cross + '-option-return-with-tc.close'] = total_return_index_df[cross + '-option-return.close'] - abs(total_return_index_df[cross + '-new-trade.close'].shift(1)) * option_tc\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'] = total_return_index_df[cross + '-delta-pnl-return.close'] - abs(total_return_index_df[cross + '-delta.close'] - total_return_index_df[cross + '-delta.close'].shift(1)) * spot_tc\n        total_return_index_df[cross + '-option-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-option-delta-return-with-tc.close'] = total_return_index_df[cross + '-option-return-with-tc.close'] + total_return_index_df[cross + '-delta-pnl-return-with-tc.close']\n        if cum_index == 'mult':\n            cum_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        elif cum_index == 'add':\n            cum_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        total_return_index_df[cross + '-option-tot-with-tc.close'] = cum_rets\n        total_return_index_df[cross + '-delta-pnl-index-with-tc.close'] = cum_delta_rets\n        total_return_index_df[cross + '-option-delta-tot-with-tc.close'] = cum_option_delta_rets\n        total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
            "def apply_tc_signals_to_total_return_index(self, cross_fx, total_return_index_orig_df, option_tc_bp, spot_tc_bp, signal_df=None, cum_index=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if cum_index is None:\n        cum_index = self._cum_index\n    total_return_index_df_agg = []\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    option_tc = option_tc_bp / (2 * 100 * 100)\n    spot_tc = spot_tc_bp / (2 * 100 * 100)\n    total_return_index_df = total_return_index_orig_df.copy()\n    for cross in cross_fx:\n        total_return_index_df[cross + '-option-return-with-tc.close'] = total_return_index_df[cross + '-option-return.close'] - abs(total_return_index_df[cross + '-new-trade.close'].shift(1)) * option_tc\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'] = total_return_index_df[cross + '-delta-pnl-return.close'] - abs(total_return_index_df[cross + '-delta.close'] - total_return_index_df[cross + '-delta.close'].shift(1)) * spot_tc\n        total_return_index_df[cross + '-option-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-option-delta-return-with-tc.close'] = total_return_index_df[cross + '-option-return-with-tc.close'] + total_return_index_df[cross + '-delta-pnl-return-with-tc.close']\n        if cum_index == 'mult':\n            cum_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        elif cum_index == 'add':\n            cum_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        total_return_index_df[cross + '-option-tot-with-tc.close'] = cum_rets\n        total_return_index_df[cross + '-delta-pnl-index-with-tc.close'] = cum_delta_rets\n        total_return_index_df[cross + '-option-delta-tot-with-tc.close'] = cum_option_delta_rets\n        total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
            "def apply_tc_signals_to_total_return_index(self, cross_fx, total_return_index_orig_df, option_tc_bp, spot_tc_bp, signal_df=None, cum_index=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if cum_index is None:\n        cum_index = self._cum_index\n    total_return_index_df_agg = []\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    option_tc = option_tc_bp / (2 * 100 * 100)\n    spot_tc = spot_tc_bp / (2 * 100 * 100)\n    total_return_index_df = total_return_index_orig_df.copy()\n    for cross in cross_fx:\n        total_return_index_df[cross + '-option-return-with-tc.close'] = total_return_index_df[cross + '-option-return.close'] - abs(total_return_index_df[cross + '-new-trade.close'].shift(1)) * option_tc\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'] = total_return_index_df[cross + '-delta-pnl-return.close'] - abs(total_return_index_df[cross + '-delta.close'] - total_return_index_df[cross + '-delta.close'].shift(1)) * spot_tc\n        total_return_index_df[cross + '-option-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-option-delta-return-with-tc.close'] = total_return_index_df[cross + '-option-return-with-tc.close'] + total_return_index_df[cross + '-delta-pnl-return-with-tc.close']\n        if cum_index == 'mult':\n            cum_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        elif cum_index == 'add':\n            cum_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        total_return_index_df[cross + '-option-tot-with-tc.close'] = cum_rets\n        total_return_index_df[cross + '-delta-pnl-index-with-tc.close'] = cum_delta_rets\n        total_return_index_df[cross + '-option-delta-tot-with-tc.close'] = cum_option_delta_rets\n        total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')",
            "def apply_tc_signals_to_total_return_index(self, cross_fx, total_return_index_orig_df, option_tc_bp, spot_tc_bp, signal_df=None, cum_index=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if cum_index is None:\n        cum_index = self._cum_index\n    total_return_index_df_agg = []\n    if not isinstance(cross_fx, list):\n        cross_fx = [cross_fx]\n    option_tc = option_tc_bp / (2 * 100 * 100)\n    spot_tc = spot_tc_bp / (2 * 100 * 100)\n    total_return_index_df = total_return_index_orig_df.copy()\n    for cross in cross_fx:\n        total_return_index_df[cross + '-option-return-with-tc.close'] = total_return_index_df[cross + '-option-return.close'] - abs(total_return_index_df[cross + '-new-trade.close'].shift(1)) * option_tc\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'] = total_return_index_df[cross + '-delta-pnl-return.close'] - abs(total_return_index_df[cross + '-delta.close'] - total_return_index_df[cross + '-delta.close'].shift(1)) * spot_tc\n        total_return_index_df[cross + '-option-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-delta-pnl-return-with-tc.close'][0] = 0\n        total_return_index_df[cross + '-option-delta-return-with-tc.close'] = total_return_index_df[cross + '-option-return-with-tc.close'] + total_return_index_df[cross + '-delta-pnl-return-with-tc.close']\n        if cum_index == 'mult':\n            cum_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 * np.cumprod(1.0 + total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        elif cum_index == 'add':\n            cum_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-return-with-tc.close'].values)\n            cum_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-delta-pnl-return-with-tc.close'].values)\n            cum_option_delta_rets = 100 + 100 * np.cumsum(total_return_index_df[cross + '-option-delta-return-with-tc.close'].values)\n        total_return_index_df[cross + '-option-tot-with-tc.close'] = cum_rets\n        total_return_index_df[cross + '-delta-pnl-index-with-tc.close'] = cum_delta_rets\n        total_return_index_df[cross + '-option-delta-tot-with-tc.close'] = cum_option_delta_rets\n        total_return_index_df_agg.append(total_return_index_df)\n    return self._calculations.join(total_return_index_df_agg, how='outer')"
        ]
    }
]