[
    {
        "func_name": "build_tracker",
        "original": "def build_tracker(cfg):\n    \"\"\"Build tracker.\"\"\"\n    return build(cfg, TRACKERS)",
        "mutated": [
            "def build_tracker(cfg):\n    if False:\n        i = 10\n    'Build tracker.'\n    return build(cfg, TRACKERS)",
            "def build_tracker(cfg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Build tracker.'\n    return build(cfg, TRACKERS)",
            "def build_tracker(cfg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Build tracker.'\n    return build(cfg, TRACKERS)",
            "def build_tracker(cfg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Build tracker.'\n    return build(cfg, TRACKERS)",
            "def build_tracker(cfg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Build tracker.'\n    return build(cfg, TRACKERS)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, init_score_thr=0.8, obj_score_thr=0.5, match_score_thr=0.5, memo_tracklet_frames=10, memo_backdrop_frames=1, memo_momentum=0.8, nms_conf_thr=0.5, nms_backdrop_iou_thr=0.3, nms_class_iou_thr=0.7, with_cats=True, match_metric='bisoftmax'):\n    assert 0 <= memo_momentum <= 1.0\n    assert memo_tracklet_frames >= 0\n    assert memo_backdrop_frames >= 0\n    self.init_score_thr = init_score_thr\n    self.obj_score_thr = obj_score_thr\n    self.match_score_thr = match_score_thr\n    self.memo_tracklet_frames = memo_tracklet_frames\n    self.memo_backdrop_frames = memo_backdrop_frames\n    self.memo_momentum = memo_momentum\n    self.nms_conf_thr = nms_conf_thr\n    self.nms_backdrop_iou_thr = nms_backdrop_iou_thr\n    self.nms_class_iou_thr = nms_class_iou_thr\n    self.with_cats = with_cats\n    assert match_metric in ['bisoftmax', 'softmax', 'cosine']\n    self.match_metric = match_metric\n    self.num_tracklets = 0\n    self.tracklets = dict()\n    self.backdrops = []",
        "mutated": [
            "def __init__(self, init_score_thr=0.8, obj_score_thr=0.5, match_score_thr=0.5, memo_tracklet_frames=10, memo_backdrop_frames=1, memo_momentum=0.8, nms_conf_thr=0.5, nms_backdrop_iou_thr=0.3, nms_class_iou_thr=0.7, with_cats=True, match_metric='bisoftmax'):\n    if False:\n        i = 10\n    assert 0 <= memo_momentum <= 1.0\n    assert memo_tracklet_frames >= 0\n    assert memo_backdrop_frames >= 0\n    self.init_score_thr = init_score_thr\n    self.obj_score_thr = obj_score_thr\n    self.match_score_thr = match_score_thr\n    self.memo_tracklet_frames = memo_tracklet_frames\n    self.memo_backdrop_frames = memo_backdrop_frames\n    self.memo_momentum = memo_momentum\n    self.nms_conf_thr = nms_conf_thr\n    self.nms_backdrop_iou_thr = nms_backdrop_iou_thr\n    self.nms_class_iou_thr = nms_class_iou_thr\n    self.with_cats = with_cats\n    assert match_metric in ['bisoftmax', 'softmax', 'cosine']\n    self.match_metric = match_metric\n    self.num_tracklets = 0\n    self.tracklets = dict()\n    self.backdrops = []",
            "def __init__(self, init_score_thr=0.8, obj_score_thr=0.5, match_score_thr=0.5, memo_tracklet_frames=10, memo_backdrop_frames=1, memo_momentum=0.8, nms_conf_thr=0.5, nms_backdrop_iou_thr=0.3, nms_class_iou_thr=0.7, with_cats=True, match_metric='bisoftmax'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert 0 <= memo_momentum <= 1.0\n    assert memo_tracklet_frames >= 0\n    assert memo_backdrop_frames >= 0\n    self.init_score_thr = init_score_thr\n    self.obj_score_thr = obj_score_thr\n    self.match_score_thr = match_score_thr\n    self.memo_tracklet_frames = memo_tracklet_frames\n    self.memo_backdrop_frames = memo_backdrop_frames\n    self.memo_momentum = memo_momentum\n    self.nms_conf_thr = nms_conf_thr\n    self.nms_backdrop_iou_thr = nms_backdrop_iou_thr\n    self.nms_class_iou_thr = nms_class_iou_thr\n    self.with_cats = with_cats\n    assert match_metric in ['bisoftmax', 'softmax', 'cosine']\n    self.match_metric = match_metric\n    self.num_tracklets = 0\n    self.tracklets = dict()\n    self.backdrops = []",
            "def __init__(self, init_score_thr=0.8, obj_score_thr=0.5, match_score_thr=0.5, memo_tracklet_frames=10, memo_backdrop_frames=1, memo_momentum=0.8, nms_conf_thr=0.5, nms_backdrop_iou_thr=0.3, nms_class_iou_thr=0.7, with_cats=True, match_metric='bisoftmax'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert 0 <= memo_momentum <= 1.0\n    assert memo_tracklet_frames >= 0\n    assert memo_backdrop_frames >= 0\n    self.init_score_thr = init_score_thr\n    self.obj_score_thr = obj_score_thr\n    self.match_score_thr = match_score_thr\n    self.memo_tracklet_frames = memo_tracklet_frames\n    self.memo_backdrop_frames = memo_backdrop_frames\n    self.memo_momentum = memo_momentum\n    self.nms_conf_thr = nms_conf_thr\n    self.nms_backdrop_iou_thr = nms_backdrop_iou_thr\n    self.nms_class_iou_thr = nms_class_iou_thr\n    self.with_cats = with_cats\n    assert match_metric in ['bisoftmax', 'softmax', 'cosine']\n    self.match_metric = match_metric\n    self.num_tracklets = 0\n    self.tracklets = dict()\n    self.backdrops = []",
            "def __init__(self, init_score_thr=0.8, obj_score_thr=0.5, match_score_thr=0.5, memo_tracklet_frames=10, memo_backdrop_frames=1, memo_momentum=0.8, nms_conf_thr=0.5, nms_backdrop_iou_thr=0.3, nms_class_iou_thr=0.7, with_cats=True, match_metric='bisoftmax'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert 0 <= memo_momentum <= 1.0\n    assert memo_tracklet_frames >= 0\n    assert memo_backdrop_frames >= 0\n    self.init_score_thr = init_score_thr\n    self.obj_score_thr = obj_score_thr\n    self.match_score_thr = match_score_thr\n    self.memo_tracklet_frames = memo_tracklet_frames\n    self.memo_backdrop_frames = memo_backdrop_frames\n    self.memo_momentum = memo_momentum\n    self.nms_conf_thr = nms_conf_thr\n    self.nms_backdrop_iou_thr = nms_backdrop_iou_thr\n    self.nms_class_iou_thr = nms_class_iou_thr\n    self.with_cats = with_cats\n    assert match_metric in ['bisoftmax', 'softmax', 'cosine']\n    self.match_metric = match_metric\n    self.num_tracklets = 0\n    self.tracklets = dict()\n    self.backdrops = []",
            "def __init__(self, init_score_thr=0.8, obj_score_thr=0.5, match_score_thr=0.5, memo_tracklet_frames=10, memo_backdrop_frames=1, memo_momentum=0.8, nms_conf_thr=0.5, nms_backdrop_iou_thr=0.3, nms_class_iou_thr=0.7, with_cats=True, match_metric='bisoftmax'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert 0 <= memo_momentum <= 1.0\n    assert memo_tracklet_frames >= 0\n    assert memo_backdrop_frames >= 0\n    self.init_score_thr = init_score_thr\n    self.obj_score_thr = obj_score_thr\n    self.match_score_thr = match_score_thr\n    self.memo_tracklet_frames = memo_tracklet_frames\n    self.memo_backdrop_frames = memo_backdrop_frames\n    self.memo_momentum = memo_momentum\n    self.nms_conf_thr = nms_conf_thr\n    self.nms_backdrop_iou_thr = nms_backdrop_iou_thr\n    self.nms_class_iou_thr = nms_class_iou_thr\n    self.with_cats = with_cats\n    assert match_metric in ['bisoftmax', 'softmax', 'cosine']\n    self.match_metric = match_metric\n    self.num_tracklets = 0\n    self.tracklets = dict()\n    self.backdrops = []"
        ]
    },
    {
        "func_name": "empty",
        "original": "@property\ndef empty(self):\n    return False if self.tracklets else True",
        "mutated": [
            "@property\ndef empty(self):\n    if False:\n        i = 10\n    return False if self.tracklets else True",
            "@property\ndef empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return False if self.tracklets else True",
            "@property\ndef empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return False if self.tracklets else True",
            "@property\ndef empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return False if self.tracklets else True",
            "@property\ndef empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return False if self.tracklets else True"
        ]
    },
    {
        "func_name": "update_memo",
        "original": "def update_memo(self, ids, bboxes, embeds, labels, frame_id):\n    tracklet_inds = ids > -1\n    for (id, bbox, embed, label) in zip(ids[tracklet_inds], bboxes[tracklet_inds], embeds[tracklet_inds], labels[tracklet_inds]):\n        id = int(id)\n        if id in self.tracklets.keys():\n            velocity = (bbox - self.tracklets[id]['bbox']) / (frame_id - self.tracklets[id]['last_frame'])\n            self.tracklets[id]['bbox'] = bbox\n            self.tracklets[id]['embed'] = (1 - self.memo_momentum) * self.tracklets[id]['embed'] + self.memo_momentum * embed\n            self.tracklets[id]['last_frame'] = frame_id\n            self.tracklets[id]['label'] = label\n            self.tracklets[id]['velocity'] = (self.tracklets[id]['velocity'] * self.tracklets[id]['acc_frame'] + velocity) / (self.tracklets[id]['acc_frame'] + 1)\n            self.tracklets[id]['acc_frame'] += 1\n        else:\n            self.tracklets[id] = dict(bbox=bbox, embed=embed, label=label, last_frame=frame_id, velocity=torch.zeros_like(bbox), acc_frame=0)\n    backdrop_inds = torch.nonzero(ids == -1, as_tuple=False).squeeze(1)\n    ious = bbox_overlaps(bboxes[backdrop_inds, :-1], bboxes[:, :-1])\n    for (i, ind) in enumerate(backdrop_inds):\n        if (ious[i, :ind] > self.nms_backdrop_iou_thr).any():\n            backdrop_inds[i] = -1\n    backdrop_inds = backdrop_inds[backdrop_inds > -1]\n    self.backdrops.insert(0, dict(bboxes=bboxes[backdrop_inds], embeds=embeds[backdrop_inds], labels=labels[backdrop_inds]))\n    invalid_ids = []\n    for (k, v) in self.tracklets.items():\n        if frame_id - v['last_frame'] >= self.memo_tracklet_frames:\n            invalid_ids.append(k)\n    for invalid_id in invalid_ids:\n        self.tracklets.pop(invalid_id)\n    if len(self.backdrops) > self.memo_backdrop_frames:\n        self.backdrops.pop()",
        "mutated": [
            "def update_memo(self, ids, bboxes, embeds, labels, frame_id):\n    if False:\n        i = 10\n    tracklet_inds = ids > -1\n    for (id, bbox, embed, label) in zip(ids[tracklet_inds], bboxes[tracklet_inds], embeds[tracklet_inds], labels[tracklet_inds]):\n        id = int(id)\n        if id in self.tracklets.keys():\n            velocity = (bbox - self.tracklets[id]['bbox']) / (frame_id - self.tracklets[id]['last_frame'])\n            self.tracklets[id]['bbox'] = bbox\n            self.tracklets[id]['embed'] = (1 - self.memo_momentum) * self.tracklets[id]['embed'] + self.memo_momentum * embed\n            self.tracklets[id]['last_frame'] = frame_id\n            self.tracklets[id]['label'] = label\n            self.tracklets[id]['velocity'] = (self.tracklets[id]['velocity'] * self.tracklets[id]['acc_frame'] + velocity) / (self.tracklets[id]['acc_frame'] + 1)\n            self.tracklets[id]['acc_frame'] += 1\n        else:\n            self.tracklets[id] = dict(bbox=bbox, embed=embed, label=label, last_frame=frame_id, velocity=torch.zeros_like(bbox), acc_frame=0)\n    backdrop_inds = torch.nonzero(ids == -1, as_tuple=False).squeeze(1)\n    ious = bbox_overlaps(bboxes[backdrop_inds, :-1], bboxes[:, :-1])\n    for (i, ind) in enumerate(backdrop_inds):\n        if (ious[i, :ind] > self.nms_backdrop_iou_thr).any():\n            backdrop_inds[i] = -1\n    backdrop_inds = backdrop_inds[backdrop_inds > -1]\n    self.backdrops.insert(0, dict(bboxes=bboxes[backdrop_inds], embeds=embeds[backdrop_inds], labels=labels[backdrop_inds]))\n    invalid_ids = []\n    for (k, v) in self.tracklets.items():\n        if frame_id - v['last_frame'] >= self.memo_tracklet_frames:\n            invalid_ids.append(k)\n    for invalid_id in invalid_ids:\n        self.tracklets.pop(invalid_id)\n    if len(self.backdrops) > self.memo_backdrop_frames:\n        self.backdrops.pop()",
            "def update_memo(self, ids, bboxes, embeds, labels, frame_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    tracklet_inds = ids > -1\n    for (id, bbox, embed, label) in zip(ids[tracklet_inds], bboxes[tracklet_inds], embeds[tracklet_inds], labels[tracklet_inds]):\n        id = int(id)\n        if id in self.tracklets.keys():\n            velocity = (bbox - self.tracklets[id]['bbox']) / (frame_id - self.tracklets[id]['last_frame'])\n            self.tracklets[id]['bbox'] = bbox\n            self.tracklets[id]['embed'] = (1 - self.memo_momentum) * self.tracklets[id]['embed'] + self.memo_momentum * embed\n            self.tracklets[id]['last_frame'] = frame_id\n            self.tracklets[id]['label'] = label\n            self.tracklets[id]['velocity'] = (self.tracklets[id]['velocity'] * self.tracklets[id]['acc_frame'] + velocity) / (self.tracklets[id]['acc_frame'] + 1)\n            self.tracklets[id]['acc_frame'] += 1\n        else:\n            self.tracklets[id] = dict(bbox=bbox, embed=embed, label=label, last_frame=frame_id, velocity=torch.zeros_like(bbox), acc_frame=0)\n    backdrop_inds = torch.nonzero(ids == -1, as_tuple=False).squeeze(1)\n    ious = bbox_overlaps(bboxes[backdrop_inds, :-1], bboxes[:, :-1])\n    for (i, ind) in enumerate(backdrop_inds):\n        if (ious[i, :ind] > self.nms_backdrop_iou_thr).any():\n            backdrop_inds[i] = -1\n    backdrop_inds = backdrop_inds[backdrop_inds > -1]\n    self.backdrops.insert(0, dict(bboxes=bboxes[backdrop_inds], embeds=embeds[backdrop_inds], labels=labels[backdrop_inds]))\n    invalid_ids = []\n    for (k, v) in self.tracklets.items():\n        if frame_id - v['last_frame'] >= self.memo_tracklet_frames:\n            invalid_ids.append(k)\n    for invalid_id in invalid_ids:\n        self.tracklets.pop(invalid_id)\n    if len(self.backdrops) > self.memo_backdrop_frames:\n        self.backdrops.pop()",
            "def update_memo(self, ids, bboxes, embeds, labels, frame_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    tracklet_inds = ids > -1\n    for (id, bbox, embed, label) in zip(ids[tracklet_inds], bboxes[tracklet_inds], embeds[tracklet_inds], labels[tracklet_inds]):\n        id = int(id)\n        if id in self.tracklets.keys():\n            velocity = (bbox - self.tracklets[id]['bbox']) / (frame_id - self.tracklets[id]['last_frame'])\n            self.tracklets[id]['bbox'] = bbox\n            self.tracklets[id]['embed'] = (1 - self.memo_momentum) * self.tracklets[id]['embed'] + self.memo_momentum * embed\n            self.tracklets[id]['last_frame'] = frame_id\n            self.tracklets[id]['label'] = label\n            self.tracklets[id]['velocity'] = (self.tracklets[id]['velocity'] * self.tracklets[id]['acc_frame'] + velocity) / (self.tracklets[id]['acc_frame'] + 1)\n            self.tracklets[id]['acc_frame'] += 1\n        else:\n            self.tracklets[id] = dict(bbox=bbox, embed=embed, label=label, last_frame=frame_id, velocity=torch.zeros_like(bbox), acc_frame=0)\n    backdrop_inds = torch.nonzero(ids == -1, as_tuple=False).squeeze(1)\n    ious = bbox_overlaps(bboxes[backdrop_inds, :-1], bboxes[:, :-1])\n    for (i, ind) in enumerate(backdrop_inds):\n        if (ious[i, :ind] > self.nms_backdrop_iou_thr).any():\n            backdrop_inds[i] = -1\n    backdrop_inds = backdrop_inds[backdrop_inds > -1]\n    self.backdrops.insert(0, dict(bboxes=bboxes[backdrop_inds], embeds=embeds[backdrop_inds], labels=labels[backdrop_inds]))\n    invalid_ids = []\n    for (k, v) in self.tracklets.items():\n        if frame_id - v['last_frame'] >= self.memo_tracklet_frames:\n            invalid_ids.append(k)\n    for invalid_id in invalid_ids:\n        self.tracklets.pop(invalid_id)\n    if len(self.backdrops) > self.memo_backdrop_frames:\n        self.backdrops.pop()",
            "def update_memo(self, ids, bboxes, embeds, labels, frame_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    tracklet_inds = ids > -1\n    for (id, bbox, embed, label) in zip(ids[tracklet_inds], bboxes[tracklet_inds], embeds[tracklet_inds], labels[tracklet_inds]):\n        id = int(id)\n        if id in self.tracklets.keys():\n            velocity = (bbox - self.tracklets[id]['bbox']) / (frame_id - self.tracklets[id]['last_frame'])\n            self.tracklets[id]['bbox'] = bbox\n            self.tracklets[id]['embed'] = (1 - self.memo_momentum) * self.tracklets[id]['embed'] + self.memo_momentum * embed\n            self.tracklets[id]['last_frame'] = frame_id\n            self.tracklets[id]['label'] = label\n            self.tracklets[id]['velocity'] = (self.tracklets[id]['velocity'] * self.tracklets[id]['acc_frame'] + velocity) / (self.tracklets[id]['acc_frame'] + 1)\n            self.tracklets[id]['acc_frame'] += 1\n        else:\n            self.tracklets[id] = dict(bbox=bbox, embed=embed, label=label, last_frame=frame_id, velocity=torch.zeros_like(bbox), acc_frame=0)\n    backdrop_inds = torch.nonzero(ids == -1, as_tuple=False).squeeze(1)\n    ious = bbox_overlaps(bboxes[backdrop_inds, :-1], bboxes[:, :-1])\n    for (i, ind) in enumerate(backdrop_inds):\n        if (ious[i, :ind] > self.nms_backdrop_iou_thr).any():\n            backdrop_inds[i] = -1\n    backdrop_inds = backdrop_inds[backdrop_inds > -1]\n    self.backdrops.insert(0, dict(bboxes=bboxes[backdrop_inds], embeds=embeds[backdrop_inds], labels=labels[backdrop_inds]))\n    invalid_ids = []\n    for (k, v) in self.tracklets.items():\n        if frame_id - v['last_frame'] >= self.memo_tracklet_frames:\n            invalid_ids.append(k)\n    for invalid_id in invalid_ids:\n        self.tracklets.pop(invalid_id)\n    if len(self.backdrops) > self.memo_backdrop_frames:\n        self.backdrops.pop()",
            "def update_memo(self, ids, bboxes, embeds, labels, frame_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    tracklet_inds = ids > -1\n    for (id, bbox, embed, label) in zip(ids[tracklet_inds], bboxes[tracklet_inds], embeds[tracklet_inds], labels[tracklet_inds]):\n        id = int(id)\n        if id in self.tracklets.keys():\n            velocity = (bbox - self.tracklets[id]['bbox']) / (frame_id - self.tracklets[id]['last_frame'])\n            self.tracklets[id]['bbox'] = bbox\n            self.tracklets[id]['embed'] = (1 - self.memo_momentum) * self.tracklets[id]['embed'] + self.memo_momentum * embed\n            self.tracklets[id]['last_frame'] = frame_id\n            self.tracklets[id]['label'] = label\n            self.tracklets[id]['velocity'] = (self.tracklets[id]['velocity'] * self.tracklets[id]['acc_frame'] + velocity) / (self.tracklets[id]['acc_frame'] + 1)\n            self.tracklets[id]['acc_frame'] += 1\n        else:\n            self.tracklets[id] = dict(bbox=bbox, embed=embed, label=label, last_frame=frame_id, velocity=torch.zeros_like(bbox), acc_frame=0)\n    backdrop_inds = torch.nonzero(ids == -1, as_tuple=False).squeeze(1)\n    ious = bbox_overlaps(bboxes[backdrop_inds, :-1], bboxes[:, :-1])\n    for (i, ind) in enumerate(backdrop_inds):\n        if (ious[i, :ind] > self.nms_backdrop_iou_thr).any():\n            backdrop_inds[i] = -1\n    backdrop_inds = backdrop_inds[backdrop_inds > -1]\n    self.backdrops.insert(0, dict(bboxes=bboxes[backdrop_inds], embeds=embeds[backdrop_inds], labels=labels[backdrop_inds]))\n    invalid_ids = []\n    for (k, v) in self.tracklets.items():\n        if frame_id - v['last_frame'] >= self.memo_tracklet_frames:\n            invalid_ids.append(k)\n    for invalid_id in invalid_ids:\n        self.tracklets.pop(invalid_id)\n    if len(self.backdrops) > self.memo_backdrop_frames:\n        self.backdrops.pop()"
        ]
    },
    {
        "func_name": "memo",
        "original": "@property\ndef memo(self):\n    memo_embeds = []\n    memo_ids = []\n    memo_bboxes = []\n    memo_labels = []\n    memo_vs = []\n    for (k, v) in self.tracklets.items():\n        memo_bboxes.append(v['bbox'][None, :])\n        memo_embeds.append(v['embed'][None, :])\n        memo_ids.append(k)\n        memo_labels.append(v['label'].view(1, 1))\n        memo_vs.append(v['velocity'][None, :])\n    memo_ids = torch.tensor(memo_ids, dtype=torch.long).view(1, -1)\n    for backdrop in self.backdrops:\n        backdrop_ids = torch.full((1, backdrop['embeds'].size(0)), -1, dtype=torch.long)\n        backdrop_vs = torch.zeros_like(backdrop['bboxes'])\n        memo_bboxes.append(backdrop['bboxes'])\n        memo_embeds.append(backdrop['embeds'])\n        memo_ids = torch.cat([memo_ids, backdrop_ids], dim=1)\n        memo_labels.append(backdrop['labels'][:, None])\n        memo_vs.append(backdrop_vs)\n    memo_bboxes = torch.cat(memo_bboxes, dim=0)\n    memo_embeds = torch.cat(memo_embeds, dim=0)\n    memo_labels = torch.cat(memo_labels, dim=0).squeeze(1)\n    memo_vs = torch.cat(memo_vs, dim=0)\n    return (memo_bboxes, memo_labels, memo_embeds, memo_ids.squeeze(0), memo_vs)",
        "mutated": [
            "@property\ndef memo(self):\n    if False:\n        i = 10\n    memo_embeds = []\n    memo_ids = []\n    memo_bboxes = []\n    memo_labels = []\n    memo_vs = []\n    for (k, v) in self.tracklets.items():\n        memo_bboxes.append(v['bbox'][None, :])\n        memo_embeds.append(v['embed'][None, :])\n        memo_ids.append(k)\n        memo_labels.append(v['label'].view(1, 1))\n        memo_vs.append(v['velocity'][None, :])\n    memo_ids = torch.tensor(memo_ids, dtype=torch.long).view(1, -1)\n    for backdrop in self.backdrops:\n        backdrop_ids = torch.full((1, backdrop['embeds'].size(0)), -1, dtype=torch.long)\n        backdrop_vs = torch.zeros_like(backdrop['bboxes'])\n        memo_bboxes.append(backdrop['bboxes'])\n        memo_embeds.append(backdrop['embeds'])\n        memo_ids = torch.cat([memo_ids, backdrop_ids], dim=1)\n        memo_labels.append(backdrop['labels'][:, None])\n        memo_vs.append(backdrop_vs)\n    memo_bboxes = torch.cat(memo_bboxes, dim=0)\n    memo_embeds = torch.cat(memo_embeds, dim=0)\n    memo_labels = torch.cat(memo_labels, dim=0).squeeze(1)\n    memo_vs = torch.cat(memo_vs, dim=0)\n    return (memo_bboxes, memo_labels, memo_embeds, memo_ids.squeeze(0), memo_vs)",
            "@property\ndef memo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    memo_embeds = []\n    memo_ids = []\n    memo_bboxes = []\n    memo_labels = []\n    memo_vs = []\n    for (k, v) in self.tracklets.items():\n        memo_bboxes.append(v['bbox'][None, :])\n        memo_embeds.append(v['embed'][None, :])\n        memo_ids.append(k)\n        memo_labels.append(v['label'].view(1, 1))\n        memo_vs.append(v['velocity'][None, :])\n    memo_ids = torch.tensor(memo_ids, dtype=torch.long).view(1, -1)\n    for backdrop in self.backdrops:\n        backdrop_ids = torch.full((1, backdrop['embeds'].size(0)), -1, dtype=torch.long)\n        backdrop_vs = torch.zeros_like(backdrop['bboxes'])\n        memo_bboxes.append(backdrop['bboxes'])\n        memo_embeds.append(backdrop['embeds'])\n        memo_ids = torch.cat([memo_ids, backdrop_ids], dim=1)\n        memo_labels.append(backdrop['labels'][:, None])\n        memo_vs.append(backdrop_vs)\n    memo_bboxes = torch.cat(memo_bboxes, dim=0)\n    memo_embeds = torch.cat(memo_embeds, dim=0)\n    memo_labels = torch.cat(memo_labels, dim=0).squeeze(1)\n    memo_vs = torch.cat(memo_vs, dim=0)\n    return (memo_bboxes, memo_labels, memo_embeds, memo_ids.squeeze(0), memo_vs)",
            "@property\ndef memo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    memo_embeds = []\n    memo_ids = []\n    memo_bboxes = []\n    memo_labels = []\n    memo_vs = []\n    for (k, v) in self.tracklets.items():\n        memo_bboxes.append(v['bbox'][None, :])\n        memo_embeds.append(v['embed'][None, :])\n        memo_ids.append(k)\n        memo_labels.append(v['label'].view(1, 1))\n        memo_vs.append(v['velocity'][None, :])\n    memo_ids = torch.tensor(memo_ids, dtype=torch.long).view(1, -1)\n    for backdrop in self.backdrops:\n        backdrop_ids = torch.full((1, backdrop['embeds'].size(0)), -1, dtype=torch.long)\n        backdrop_vs = torch.zeros_like(backdrop['bboxes'])\n        memo_bboxes.append(backdrop['bboxes'])\n        memo_embeds.append(backdrop['embeds'])\n        memo_ids = torch.cat([memo_ids, backdrop_ids], dim=1)\n        memo_labels.append(backdrop['labels'][:, None])\n        memo_vs.append(backdrop_vs)\n    memo_bboxes = torch.cat(memo_bboxes, dim=0)\n    memo_embeds = torch.cat(memo_embeds, dim=0)\n    memo_labels = torch.cat(memo_labels, dim=0).squeeze(1)\n    memo_vs = torch.cat(memo_vs, dim=0)\n    return (memo_bboxes, memo_labels, memo_embeds, memo_ids.squeeze(0), memo_vs)",
            "@property\ndef memo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    memo_embeds = []\n    memo_ids = []\n    memo_bboxes = []\n    memo_labels = []\n    memo_vs = []\n    for (k, v) in self.tracklets.items():\n        memo_bboxes.append(v['bbox'][None, :])\n        memo_embeds.append(v['embed'][None, :])\n        memo_ids.append(k)\n        memo_labels.append(v['label'].view(1, 1))\n        memo_vs.append(v['velocity'][None, :])\n    memo_ids = torch.tensor(memo_ids, dtype=torch.long).view(1, -1)\n    for backdrop in self.backdrops:\n        backdrop_ids = torch.full((1, backdrop['embeds'].size(0)), -1, dtype=torch.long)\n        backdrop_vs = torch.zeros_like(backdrop['bboxes'])\n        memo_bboxes.append(backdrop['bboxes'])\n        memo_embeds.append(backdrop['embeds'])\n        memo_ids = torch.cat([memo_ids, backdrop_ids], dim=1)\n        memo_labels.append(backdrop['labels'][:, None])\n        memo_vs.append(backdrop_vs)\n    memo_bboxes = torch.cat(memo_bboxes, dim=0)\n    memo_embeds = torch.cat(memo_embeds, dim=0)\n    memo_labels = torch.cat(memo_labels, dim=0).squeeze(1)\n    memo_vs = torch.cat(memo_vs, dim=0)\n    return (memo_bboxes, memo_labels, memo_embeds, memo_ids.squeeze(0), memo_vs)",
            "@property\ndef memo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    memo_embeds = []\n    memo_ids = []\n    memo_bboxes = []\n    memo_labels = []\n    memo_vs = []\n    for (k, v) in self.tracklets.items():\n        memo_bboxes.append(v['bbox'][None, :])\n        memo_embeds.append(v['embed'][None, :])\n        memo_ids.append(k)\n        memo_labels.append(v['label'].view(1, 1))\n        memo_vs.append(v['velocity'][None, :])\n    memo_ids = torch.tensor(memo_ids, dtype=torch.long).view(1, -1)\n    for backdrop in self.backdrops:\n        backdrop_ids = torch.full((1, backdrop['embeds'].size(0)), -1, dtype=torch.long)\n        backdrop_vs = torch.zeros_like(backdrop['bboxes'])\n        memo_bboxes.append(backdrop['bboxes'])\n        memo_embeds.append(backdrop['embeds'])\n        memo_ids = torch.cat([memo_ids, backdrop_ids], dim=1)\n        memo_labels.append(backdrop['labels'][:, None])\n        memo_vs.append(backdrop_vs)\n    memo_bboxes = torch.cat(memo_bboxes, dim=0)\n    memo_embeds = torch.cat(memo_embeds, dim=0)\n    memo_labels = torch.cat(memo_labels, dim=0).squeeze(1)\n    memo_vs = torch.cat(memo_vs, dim=0)\n    return (memo_bboxes, memo_labels, memo_embeds, memo_ids.squeeze(0), memo_vs)"
        ]
    },
    {
        "func_name": "match",
        "original": "def match(self, bboxes, labels, track_feats, frame_id, asso_tau=-1):\n    (_, inds) = bboxes[:, -1].sort(descending=True)\n    bboxes = bboxes[inds, :]\n    labels = labels[inds]\n    embeds = track_feats[inds, :]\n    valids = bboxes.new_ones(bboxes.size(0))\n    ious = bbox_overlaps(bboxes[:, :-1], bboxes[:, :-1])\n    for i in range(1, bboxes.size(0)):\n        thr = self.nms_backdrop_iou_thr if bboxes[i, -1] < self.obj_score_thr else self.nms_class_iou_thr\n        if (ious[i, :i] > thr).any():\n            valids[i] = 0\n    valids = valids == 1\n    bboxes = bboxes[valids, :]\n    labels = labels[valids]\n    embeds = embeds[valids, :]\n    ids = torch.full((bboxes.size(0),), -1, dtype=torch.long)\n    if bboxes.size(0) > 0 and (not self.empty):\n        (memo_bboxes, memo_labels, memo_embeds, memo_ids, memo_vs) = self.memo\n        if self.match_metric == 'bisoftmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            d2t_scores = feats.softmax(dim=1)\n            t2d_scores = feats.softmax(dim=0)\n            scores = (d2t_scores + t2d_scores) / 2\n        elif self.match_metric == 'softmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            scores = feats.softmax(dim=1)\n        elif self.match_metric == 'cosine':\n            scores = torch.mm(F.normalize(embeds, p=2, dim=1), F.normalize(memo_embeds, p=2, dim=1).t())\n        else:\n            raise NotImplementedError\n        if self.with_cats:\n            cat_same = labels.view(-1, 1) == memo_labels.view(1, -1)\n            scores *= cat_same.float().to(scores.device)\n        for i in range(bboxes.size(0)):\n            (conf, memo_ind) = torch.max(scores[i, :], dim=0)\n            id = memo_ids[memo_ind]\n            if conf > self.match_score_thr:\n                if id > -1:\n                    if bboxes[i, -1] > self.obj_score_thr:\n                        ids[i] = id\n                        scores[:i, memo_ind] = 0\n                        scores[i + 1:, memo_ind] = 0\n                    elif conf > self.nms_conf_thr:\n                        ids[i] = -2\n    new_inds = (ids == -1) & (bboxes[:, 4] > self.init_score_thr).cpu()\n    num_news = new_inds.sum()\n    ids[new_inds] = torch.arange(self.num_tracklets, self.num_tracklets + num_news, dtype=torch.long)\n    self.num_tracklets += num_news\n    self.update_memo(ids, bboxes, embeds, labels, frame_id)\n    return (bboxes, labels, ids)",
        "mutated": [
            "def match(self, bboxes, labels, track_feats, frame_id, asso_tau=-1):\n    if False:\n        i = 10\n    (_, inds) = bboxes[:, -1].sort(descending=True)\n    bboxes = bboxes[inds, :]\n    labels = labels[inds]\n    embeds = track_feats[inds, :]\n    valids = bboxes.new_ones(bboxes.size(0))\n    ious = bbox_overlaps(bboxes[:, :-1], bboxes[:, :-1])\n    for i in range(1, bboxes.size(0)):\n        thr = self.nms_backdrop_iou_thr if bboxes[i, -1] < self.obj_score_thr else self.nms_class_iou_thr\n        if (ious[i, :i] > thr).any():\n            valids[i] = 0\n    valids = valids == 1\n    bboxes = bboxes[valids, :]\n    labels = labels[valids]\n    embeds = embeds[valids, :]\n    ids = torch.full((bboxes.size(0),), -1, dtype=torch.long)\n    if bboxes.size(0) > 0 and (not self.empty):\n        (memo_bboxes, memo_labels, memo_embeds, memo_ids, memo_vs) = self.memo\n        if self.match_metric == 'bisoftmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            d2t_scores = feats.softmax(dim=1)\n            t2d_scores = feats.softmax(dim=0)\n            scores = (d2t_scores + t2d_scores) / 2\n        elif self.match_metric == 'softmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            scores = feats.softmax(dim=1)\n        elif self.match_metric == 'cosine':\n            scores = torch.mm(F.normalize(embeds, p=2, dim=1), F.normalize(memo_embeds, p=2, dim=1).t())\n        else:\n            raise NotImplementedError\n        if self.with_cats:\n            cat_same = labels.view(-1, 1) == memo_labels.view(1, -1)\n            scores *= cat_same.float().to(scores.device)\n        for i in range(bboxes.size(0)):\n            (conf, memo_ind) = torch.max(scores[i, :], dim=0)\n            id = memo_ids[memo_ind]\n            if conf > self.match_score_thr:\n                if id > -1:\n                    if bboxes[i, -1] > self.obj_score_thr:\n                        ids[i] = id\n                        scores[:i, memo_ind] = 0\n                        scores[i + 1:, memo_ind] = 0\n                    elif conf > self.nms_conf_thr:\n                        ids[i] = -2\n    new_inds = (ids == -1) & (bboxes[:, 4] > self.init_score_thr).cpu()\n    num_news = new_inds.sum()\n    ids[new_inds] = torch.arange(self.num_tracklets, self.num_tracklets + num_news, dtype=torch.long)\n    self.num_tracklets += num_news\n    self.update_memo(ids, bboxes, embeds, labels, frame_id)\n    return (bboxes, labels, ids)",
            "def match(self, bboxes, labels, track_feats, frame_id, asso_tau=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (_, inds) = bboxes[:, -1].sort(descending=True)\n    bboxes = bboxes[inds, :]\n    labels = labels[inds]\n    embeds = track_feats[inds, :]\n    valids = bboxes.new_ones(bboxes.size(0))\n    ious = bbox_overlaps(bboxes[:, :-1], bboxes[:, :-1])\n    for i in range(1, bboxes.size(0)):\n        thr = self.nms_backdrop_iou_thr if bboxes[i, -1] < self.obj_score_thr else self.nms_class_iou_thr\n        if (ious[i, :i] > thr).any():\n            valids[i] = 0\n    valids = valids == 1\n    bboxes = bboxes[valids, :]\n    labels = labels[valids]\n    embeds = embeds[valids, :]\n    ids = torch.full((bboxes.size(0),), -1, dtype=torch.long)\n    if bboxes.size(0) > 0 and (not self.empty):\n        (memo_bboxes, memo_labels, memo_embeds, memo_ids, memo_vs) = self.memo\n        if self.match_metric == 'bisoftmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            d2t_scores = feats.softmax(dim=1)\n            t2d_scores = feats.softmax(dim=0)\n            scores = (d2t_scores + t2d_scores) / 2\n        elif self.match_metric == 'softmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            scores = feats.softmax(dim=1)\n        elif self.match_metric == 'cosine':\n            scores = torch.mm(F.normalize(embeds, p=2, dim=1), F.normalize(memo_embeds, p=2, dim=1).t())\n        else:\n            raise NotImplementedError\n        if self.with_cats:\n            cat_same = labels.view(-1, 1) == memo_labels.view(1, -1)\n            scores *= cat_same.float().to(scores.device)\n        for i in range(bboxes.size(0)):\n            (conf, memo_ind) = torch.max(scores[i, :], dim=0)\n            id = memo_ids[memo_ind]\n            if conf > self.match_score_thr:\n                if id > -1:\n                    if bboxes[i, -1] > self.obj_score_thr:\n                        ids[i] = id\n                        scores[:i, memo_ind] = 0\n                        scores[i + 1:, memo_ind] = 0\n                    elif conf > self.nms_conf_thr:\n                        ids[i] = -2\n    new_inds = (ids == -1) & (bboxes[:, 4] > self.init_score_thr).cpu()\n    num_news = new_inds.sum()\n    ids[new_inds] = torch.arange(self.num_tracklets, self.num_tracklets + num_news, dtype=torch.long)\n    self.num_tracklets += num_news\n    self.update_memo(ids, bboxes, embeds, labels, frame_id)\n    return (bboxes, labels, ids)",
            "def match(self, bboxes, labels, track_feats, frame_id, asso_tau=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (_, inds) = bboxes[:, -1].sort(descending=True)\n    bboxes = bboxes[inds, :]\n    labels = labels[inds]\n    embeds = track_feats[inds, :]\n    valids = bboxes.new_ones(bboxes.size(0))\n    ious = bbox_overlaps(bboxes[:, :-1], bboxes[:, :-1])\n    for i in range(1, bboxes.size(0)):\n        thr = self.nms_backdrop_iou_thr if bboxes[i, -1] < self.obj_score_thr else self.nms_class_iou_thr\n        if (ious[i, :i] > thr).any():\n            valids[i] = 0\n    valids = valids == 1\n    bboxes = bboxes[valids, :]\n    labels = labels[valids]\n    embeds = embeds[valids, :]\n    ids = torch.full((bboxes.size(0),), -1, dtype=torch.long)\n    if bboxes.size(0) > 0 and (not self.empty):\n        (memo_bboxes, memo_labels, memo_embeds, memo_ids, memo_vs) = self.memo\n        if self.match_metric == 'bisoftmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            d2t_scores = feats.softmax(dim=1)\n            t2d_scores = feats.softmax(dim=0)\n            scores = (d2t_scores + t2d_scores) / 2\n        elif self.match_metric == 'softmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            scores = feats.softmax(dim=1)\n        elif self.match_metric == 'cosine':\n            scores = torch.mm(F.normalize(embeds, p=2, dim=1), F.normalize(memo_embeds, p=2, dim=1).t())\n        else:\n            raise NotImplementedError\n        if self.with_cats:\n            cat_same = labels.view(-1, 1) == memo_labels.view(1, -1)\n            scores *= cat_same.float().to(scores.device)\n        for i in range(bboxes.size(0)):\n            (conf, memo_ind) = torch.max(scores[i, :], dim=0)\n            id = memo_ids[memo_ind]\n            if conf > self.match_score_thr:\n                if id > -1:\n                    if bboxes[i, -1] > self.obj_score_thr:\n                        ids[i] = id\n                        scores[:i, memo_ind] = 0\n                        scores[i + 1:, memo_ind] = 0\n                    elif conf > self.nms_conf_thr:\n                        ids[i] = -2\n    new_inds = (ids == -1) & (bboxes[:, 4] > self.init_score_thr).cpu()\n    num_news = new_inds.sum()\n    ids[new_inds] = torch.arange(self.num_tracklets, self.num_tracklets + num_news, dtype=torch.long)\n    self.num_tracklets += num_news\n    self.update_memo(ids, bboxes, embeds, labels, frame_id)\n    return (bboxes, labels, ids)",
            "def match(self, bboxes, labels, track_feats, frame_id, asso_tau=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (_, inds) = bboxes[:, -1].sort(descending=True)\n    bboxes = bboxes[inds, :]\n    labels = labels[inds]\n    embeds = track_feats[inds, :]\n    valids = bboxes.new_ones(bboxes.size(0))\n    ious = bbox_overlaps(bboxes[:, :-1], bboxes[:, :-1])\n    for i in range(1, bboxes.size(0)):\n        thr = self.nms_backdrop_iou_thr if bboxes[i, -1] < self.obj_score_thr else self.nms_class_iou_thr\n        if (ious[i, :i] > thr).any():\n            valids[i] = 0\n    valids = valids == 1\n    bboxes = bboxes[valids, :]\n    labels = labels[valids]\n    embeds = embeds[valids, :]\n    ids = torch.full((bboxes.size(0),), -1, dtype=torch.long)\n    if bboxes.size(0) > 0 and (not self.empty):\n        (memo_bboxes, memo_labels, memo_embeds, memo_ids, memo_vs) = self.memo\n        if self.match_metric == 'bisoftmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            d2t_scores = feats.softmax(dim=1)\n            t2d_scores = feats.softmax(dim=0)\n            scores = (d2t_scores + t2d_scores) / 2\n        elif self.match_metric == 'softmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            scores = feats.softmax(dim=1)\n        elif self.match_metric == 'cosine':\n            scores = torch.mm(F.normalize(embeds, p=2, dim=1), F.normalize(memo_embeds, p=2, dim=1).t())\n        else:\n            raise NotImplementedError\n        if self.with_cats:\n            cat_same = labels.view(-1, 1) == memo_labels.view(1, -1)\n            scores *= cat_same.float().to(scores.device)\n        for i in range(bboxes.size(0)):\n            (conf, memo_ind) = torch.max(scores[i, :], dim=0)\n            id = memo_ids[memo_ind]\n            if conf > self.match_score_thr:\n                if id > -1:\n                    if bboxes[i, -1] > self.obj_score_thr:\n                        ids[i] = id\n                        scores[:i, memo_ind] = 0\n                        scores[i + 1:, memo_ind] = 0\n                    elif conf > self.nms_conf_thr:\n                        ids[i] = -2\n    new_inds = (ids == -1) & (bboxes[:, 4] > self.init_score_thr).cpu()\n    num_news = new_inds.sum()\n    ids[new_inds] = torch.arange(self.num_tracklets, self.num_tracklets + num_news, dtype=torch.long)\n    self.num_tracklets += num_news\n    self.update_memo(ids, bboxes, embeds, labels, frame_id)\n    return (bboxes, labels, ids)",
            "def match(self, bboxes, labels, track_feats, frame_id, asso_tau=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (_, inds) = bboxes[:, -1].sort(descending=True)\n    bboxes = bboxes[inds, :]\n    labels = labels[inds]\n    embeds = track_feats[inds, :]\n    valids = bboxes.new_ones(bboxes.size(0))\n    ious = bbox_overlaps(bboxes[:, :-1], bboxes[:, :-1])\n    for i in range(1, bboxes.size(0)):\n        thr = self.nms_backdrop_iou_thr if bboxes[i, -1] < self.obj_score_thr else self.nms_class_iou_thr\n        if (ious[i, :i] > thr).any():\n            valids[i] = 0\n    valids = valids == 1\n    bboxes = bboxes[valids, :]\n    labels = labels[valids]\n    embeds = embeds[valids, :]\n    ids = torch.full((bboxes.size(0),), -1, dtype=torch.long)\n    if bboxes.size(0) > 0 and (not self.empty):\n        (memo_bboxes, memo_labels, memo_embeds, memo_ids, memo_vs) = self.memo\n        if self.match_metric == 'bisoftmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            d2t_scores = feats.softmax(dim=1)\n            t2d_scores = feats.softmax(dim=0)\n            scores = (d2t_scores + t2d_scores) / 2\n        elif self.match_metric == 'softmax':\n            feats = torch.mm(embeds, memo_embeds.t())\n            scores = feats.softmax(dim=1)\n        elif self.match_metric == 'cosine':\n            scores = torch.mm(F.normalize(embeds, p=2, dim=1), F.normalize(memo_embeds, p=2, dim=1).t())\n        else:\n            raise NotImplementedError\n        if self.with_cats:\n            cat_same = labels.view(-1, 1) == memo_labels.view(1, -1)\n            scores *= cat_same.float().to(scores.device)\n        for i in range(bboxes.size(0)):\n            (conf, memo_ind) = torch.max(scores[i, :], dim=0)\n            id = memo_ids[memo_ind]\n            if conf > self.match_score_thr:\n                if id > -1:\n                    if bboxes[i, -1] > self.obj_score_thr:\n                        ids[i] = id\n                        scores[:i, memo_ind] = 0\n                        scores[i + 1:, memo_ind] = 0\n                    elif conf > self.nms_conf_thr:\n                        ids[i] = -2\n    new_inds = (ids == -1) & (bboxes[:, 4] > self.init_score_thr).cpu()\n    num_news = new_inds.sum()\n    ids[new_inds] = torch.arange(self.num_tracklets, self.num_tracklets + num_news, dtype=torch.long)\n    self.num_tracklets += num_news\n    self.update_memo(ids, bboxes, embeds, labels, frame_id)\n    return (bboxes, labels, ids)"
        ]
    }
]