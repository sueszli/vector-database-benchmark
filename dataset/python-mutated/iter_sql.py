from __future__ import annotations
import sqlalchemy
from river import base
__all__ = ['iter_sql']

def iter_sql(query: str | sqlalchemy.TextClause | sqlalchemy.Select, conn: sqlalchemy.Connection, target_name: str | None=None) -> base.typing.Stream:
    if False:
        for i in range(10):
            print('nop')
    'Iterates over the results from an SQL query.\n\n    By default, SQLAlchemy prefetches results. Therefore, even though you can iterate over the\n    resulting rows one by one, the results are in fact loaded in batch. You can modify this\n    behavior by configuring the connection you pass to `iter_sql`. For instance, you can set\n    the `stream_results` parameter to `True`, as [explained in SQLAlchemy\'s documentation](https://docs.sqlalchemy.org/en/13/core/connections.html#sqlalchemy.engine.Connection.execution_options). Note, however,\n    that this isn\'t available for all database engines.\n\n    Parameters\n    ----------\n    query\n        SQL query to be executed.\n    conn\n        An SQLAlchemy construct which has an `execute` method. In other words you can pass an\n        engine, a connection, or a session.\n    target_name\n        The name of the target field. If this is `None`, then `y` will also be `None`.\n\n    Examples\n    --------\n\n    As an example we\'ll create an in-memory database with SQLAlchemy.\n\n    >>> import datetime as dt\n    >>> import sqlalchemy\n\n    >>> engine = sqlalchemy.create_engine(\'sqlite://\')\n\n    >>> metadata = sqlalchemy.MetaData()\n\n    >>> t_sales = sqlalchemy.Table(\'sales\', metadata,\n    ...     sqlalchemy.Column(\'shop\', sqlalchemy.String, primary_key=True),\n    ...     sqlalchemy.Column(\'date\', sqlalchemy.Date, primary_key=True),\n    ...     sqlalchemy.Column(\'amount\', sqlalchemy.Integer)\n    ... )\n\n    >>> metadata.create_all(engine)\n\n    >>> sales = [\n    ...     {\'shop\': \'Hema\', \'date\': dt.date(2016, 8, 2), \'amount\': 20},\n    ...     {\'shop\': \'Ikea\', \'date\': dt.date(2016, 8, 2), \'amount\': 18},\n    ...     {\'shop\': \'Hema\', \'date\': dt.date(2016, 8, 3), \'amount\': 22},\n    ...     {\'shop\': \'Ikea\', \'date\': dt.date(2016, 8, 3), \'amount\': 14},\n    ...     {\'shop\': \'Hema\', \'date\': dt.date(2016, 8, 4), \'amount\': 12},\n    ...     {\'shop\': \'Ikea\', \'date\': dt.date(2016, 8, 4), \'amount\': 16}\n    ... ]\n\n    >>> with engine.connect() as conn:\n    ...     _ = conn.execute(t_sales.insert(), sales)\n    ...     conn.commit()\n\n    We can now query the database. We will set `amount` to be the target field.\n\n    >>> from river import stream\n\n    >>> with engine.connect() as conn:\n    ...     query = sqlalchemy.sql.select(t_sales)\n    ...     dataset = stream.iter_sql(query, conn, target_name=\'amount\')\n    ...     for x, y in dataset:\n    ...         print(x, y)\n    {\'shop\': \'Hema\', \'date\': datetime.date(2016, 8, 2)} 20\n    {\'shop\': \'Ikea\', \'date\': datetime.date(2016, 8, 2)} 18\n    {\'shop\': \'Hema\', \'date\': datetime.date(2016, 8, 3)} 22\n    {\'shop\': \'Ikea\', \'date\': datetime.date(2016, 8, 3)} 14\n    {\'shop\': \'Hema\', \'date\': datetime.date(2016, 8, 4)} 12\n    {\'shop\': \'Ikea\', \'date\': datetime.date(2016, 8, 4)} 16\n\n    This also with raw SQL queries.\n\n    >>> with engine.connect() as conn:\n    ...     query = "SELECT * FROM sales WHERE shop = \'Hema\'"\n    ...     dataset = stream.iter_sql(query, conn, target_name=\'amount\')\n    ...     for x, y in dataset:\n    ...         print(x, y)\n    {\'shop\': \'Hema\', \'date\': \'2016-08-02\'} 20\n    {\'shop\': \'Hema\', \'date\': \'2016-08-03\'} 22\n    {\'shop\': \'Hema\', \'date\': \'2016-08-04\'} 12\n\n    '
    result_proxy = conn.execute(sqlalchemy.sql.text(query) if isinstance(query, str) else query)
    if target_name is None:
        for row in result_proxy:
            yield (dict(row._mapping.items()), None)
        return
    for row in result_proxy:
        x = dict(row._mapping.items())
        y = x.pop(target_name)
        yield (x, y)