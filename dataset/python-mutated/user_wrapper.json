[
    {
        "func_name": "create_user",
        "original": "def create_user(user_name):\n    \"\"\"\n    Creates a user. By default, a user has no permissions or access keys.\n\n    :param user_name: The name of the user.\n    :return: The newly created user.\n    \"\"\"\n    try:\n        user = iam.create_user(UserName=user_name)\n        logger.info('Created user %s.', user.name)\n    except ClientError:\n        logger.exception(\"Couldn't create user %s.\", user_name)\n        raise\n    else:\n        return user",
        "mutated": [
            "def create_user(user_name):\n    if False:\n        i = 10\n    '\\n    Creates a user. By default, a user has no permissions or access keys.\\n\\n    :param user_name: The name of the user.\\n    :return: The newly created user.\\n    '\n    try:\n        user = iam.create_user(UserName=user_name)\n        logger.info('Created user %s.', user.name)\n    except ClientError:\n        logger.exception(\"Couldn't create user %s.\", user_name)\n        raise\n    else:\n        return user",
            "def create_user(user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Creates a user. By default, a user has no permissions or access keys.\\n\\n    :param user_name: The name of the user.\\n    :return: The newly created user.\\n    '\n    try:\n        user = iam.create_user(UserName=user_name)\n        logger.info('Created user %s.', user.name)\n    except ClientError:\n        logger.exception(\"Couldn't create user %s.\", user_name)\n        raise\n    else:\n        return user",
            "def create_user(user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Creates a user. By default, a user has no permissions or access keys.\\n\\n    :param user_name: The name of the user.\\n    :return: The newly created user.\\n    '\n    try:\n        user = iam.create_user(UserName=user_name)\n        logger.info('Created user %s.', user.name)\n    except ClientError:\n        logger.exception(\"Couldn't create user %s.\", user_name)\n        raise\n    else:\n        return user",
            "def create_user(user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Creates a user. By default, a user has no permissions or access keys.\\n\\n    :param user_name: The name of the user.\\n    :return: The newly created user.\\n    '\n    try:\n        user = iam.create_user(UserName=user_name)\n        logger.info('Created user %s.', user.name)\n    except ClientError:\n        logger.exception(\"Couldn't create user %s.\", user_name)\n        raise\n    else:\n        return user",
            "def create_user(user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Creates a user. By default, a user has no permissions or access keys.\\n\\n    :param user_name: The name of the user.\\n    :return: The newly created user.\\n    '\n    try:\n        user = iam.create_user(UserName=user_name)\n        logger.info('Created user %s.', user.name)\n    except ClientError:\n        logger.exception(\"Couldn't create user %s.\", user_name)\n        raise\n    else:\n        return user"
        ]
    },
    {
        "func_name": "delete_user",
        "original": "def delete_user(user_name):\n    \"\"\"\n    Deletes a user. Before a user can be deleted, all associated resources,\n    such as access keys and policies, must be deleted or detached.\n\n    :param user_name: The name of the user.\n    \"\"\"\n    try:\n        iam.User(user_name).delete()\n        logger.info('Deleted user %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't delete user %s.\", user_name)\n        raise",
        "mutated": [
            "def delete_user(user_name):\n    if False:\n        i = 10\n    '\\n    Deletes a user. Before a user can be deleted, all associated resources,\\n    such as access keys and policies, must be deleted or detached.\\n\\n    :param user_name: The name of the user.\\n    '\n    try:\n        iam.User(user_name).delete()\n        logger.info('Deleted user %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't delete user %s.\", user_name)\n        raise",
            "def delete_user(user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Deletes a user. Before a user can be deleted, all associated resources,\\n    such as access keys and policies, must be deleted or detached.\\n\\n    :param user_name: The name of the user.\\n    '\n    try:\n        iam.User(user_name).delete()\n        logger.info('Deleted user %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't delete user %s.\", user_name)\n        raise",
            "def delete_user(user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Deletes a user. Before a user can be deleted, all associated resources,\\n    such as access keys and policies, must be deleted or detached.\\n\\n    :param user_name: The name of the user.\\n    '\n    try:\n        iam.User(user_name).delete()\n        logger.info('Deleted user %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't delete user %s.\", user_name)\n        raise",
            "def delete_user(user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Deletes a user. Before a user can be deleted, all associated resources,\\n    such as access keys and policies, must be deleted or detached.\\n\\n    :param user_name: The name of the user.\\n    '\n    try:\n        iam.User(user_name).delete()\n        logger.info('Deleted user %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't delete user %s.\", user_name)\n        raise",
            "def delete_user(user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Deletes a user. Before a user can be deleted, all associated resources,\\n    such as access keys and policies, must be deleted or detached.\\n\\n    :param user_name: The name of the user.\\n    '\n    try:\n        iam.User(user_name).delete()\n        logger.info('Deleted user %s.', user_name)\n    except ClientError:\n        logger.exception(\"Couldn't delete user %s.\", user_name)\n        raise"
        ]
    },
    {
        "func_name": "list_users",
        "original": "def list_users():\n    \"\"\"\n    Lists the users in the current account.\n\n    :return: The list of users.\n    \"\"\"\n    try:\n        users = list(iam.users.all())\n        logger.info('Got %s users.', len(users))\n    except ClientError:\n        logger.exception(\"Couldn't get users.\")\n        raise\n    else:\n        return users",
        "mutated": [
            "def list_users():\n    if False:\n        i = 10\n    '\\n    Lists the users in the current account.\\n\\n    :return: The list of users.\\n    '\n    try:\n        users = list(iam.users.all())\n        logger.info('Got %s users.', len(users))\n    except ClientError:\n        logger.exception(\"Couldn't get users.\")\n        raise\n    else:\n        return users",
            "def list_users():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Lists the users in the current account.\\n\\n    :return: The list of users.\\n    '\n    try:\n        users = list(iam.users.all())\n        logger.info('Got %s users.', len(users))\n    except ClientError:\n        logger.exception(\"Couldn't get users.\")\n        raise\n    else:\n        return users",
            "def list_users():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Lists the users in the current account.\\n\\n    :return: The list of users.\\n    '\n    try:\n        users = list(iam.users.all())\n        logger.info('Got %s users.', len(users))\n    except ClientError:\n        logger.exception(\"Couldn't get users.\")\n        raise\n    else:\n        return users",
            "def list_users():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Lists the users in the current account.\\n\\n    :return: The list of users.\\n    '\n    try:\n        users = list(iam.users.all())\n        logger.info('Got %s users.', len(users))\n    except ClientError:\n        logger.exception(\"Couldn't get users.\")\n        raise\n    else:\n        return users",
            "def list_users():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Lists the users in the current account.\\n\\n    :return: The list of users.\\n    '\n    try:\n        users = list(iam.users.all())\n        logger.info('Got %s users.', len(users))\n    except ClientError:\n        logger.exception(\"Couldn't get users.\")\n        raise\n    else:\n        return users"
        ]
    },
    {
        "func_name": "update_user",
        "original": "def update_user(user_name, new_user_name):\n    \"\"\"\n    Updates a user's name.\n\n    :param user_name: The current name of the user to update.\n    :param new_user_name: The new name to assign to the user.\n    :return: The updated user.\n    \"\"\"\n    try:\n        user = iam.User(user_name)\n        user.update(NewUserName=new_user_name)\n        logger.info('Renamed %s to %s.', user_name, new_user_name)\n    except ClientError:\n        logger.exception(\"Couldn't update name for user %s.\", user_name)\n        raise\n    return user",
        "mutated": [
            "def update_user(user_name, new_user_name):\n    if False:\n        i = 10\n    \"\\n    Updates a user's name.\\n\\n    :param user_name: The current name of the user to update.\\n    :param new_user_name: The new name to assign to the user.\\n    :return: The updated user.\\n    \"\n    try:\n        user = iam.User(user_name)\n        user.update(NewUserName=new_user_name)\n        logger.info('Renamed %s to %s.', user_name, new_user_name)\n    except ClientError:\n        logger.exception(\"Couldn't update name for user %s.\", user_name)\n        raise\n    return user",
            "def update_user(user_name, new_user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Updates a user's name.\\n\\n    :param user_name: The current name of the user to update.\\n    :param new_user_name: The new name to assign to the user.\\n    :return: The updated user.\\n    \"\n    try:\n        user = iam.User(user_name)\n        user.update(NewUserName=new_user_name)\n        logger.info('Renamed %s to %s.', user_name, new_user_name)\n    except ClientError:\n        logger.exception(\"Couldn't update name for user %s.\", user_name)\n        raise\n    return user",
            "def update_user(user_name, new_user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Updates a user's name.\\n\\n    :param user_name: The current name of the user to update.\\n    :param new_user_name: The new name to assign to the user.\\n    :return: The updated user.\\n    \"\n    try:\n        user = iam.User(user_name)\n        user.update(NewUserName=new_user_name)\n        logger.info('Renamed %s to %s.', user_name, new_user_name)\n    except ClientError:\n        logger.exception(\"Couldn't update name for user %s.\", user_name)\n        raise\n    return user",
            "def update_user(user_name, new_user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Updates a user's name.\\n\\n    :param user_name: The current name of the user to update.\\n    :param new_user_name: The new name to assign to the user.\\n    :return: The updated user.\\n    \"\n    try:\n        user = iam.User(user_name)\n        user.update(NewUserName=new_user_name)\n        logger.info('Renamed %s to %s.', user_name, new_user_name)\n    except ClientError:\n        logger.exception(\"Couldn't update name for user %s.\", user_name)\n        raise\n    return user",
            "def update_user(user_name, new_user_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Updates a user's name.\\n\\n    :param user_name: The current name of the user to update.\\n    :param new_user_name: The new name to assign to the user.\\n    :return: The updated user.\\n    \"\n    try:\n        user = iam.User(user_name)\n        user.update(NewUserName=new_user_name)\n        logger.info('Renamed %s to %s.', user_name, new_user_name)\n    except ClientError:\n        logger.exception(\"Couldn't update name for user %s.\", user_name)\n        raise\n    return user"
        ]
    },
    {
        "func_name": "attach_policy",
        "original": "def attach_policy(user_name, policy_arn):\n    \"\"\"\n    Attaches a policy to a user.\n\n    :param user_name: The name of the user.\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\n    \"\"\"\n    try:\n        iam.User(user_name).attach_policy(PolicyArn=policy_arn)\n        logger.info('Attached policy %s to user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't attach policy %s to user %s.\", policy_arn, user_name)\n        raise",
        "mutated": [
            "def attach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n    '\\n    Attaches a policy to a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).attach_policy(PolicyArn=policy_arn)\n        logger.info('Attached policy %s to user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't attach policy %s to user %s.\", policy_arn, user_name)\n        raise",
            "def attach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Attaches a policy to a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).attach_policy(PolicyArn=policy_arn)\n        logger.info('Attached policy %s to user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't attach policy %s to user %s.\", policy_arn, user_name)\n        raise",
            "def attach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Attaches a policy to a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).attach_policy(PolicyArn=policy_arn)\n        logger.info('Attached policy %s to user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't attach policy %s to user %s.\", policy_arn, user_name)\n        raise",
            "def attach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Attaches a policy to a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).attach_policy(PolicyArn=policy_arn)\n        logger.info('Attached policy %s to user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't attach policy %s to user %s.\", policy_arn, user_name)\n        raise",
            "def attach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Attaches a policy to a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).attach_policy(PolicyArn=policy_arn)\n        logger.info('Attached policy %s to user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't attach policy %s to user %s.\", policy_arn, user_name)\n        raise"
        ]
    },
    {
        "func_name": "detach_policy",
        "original": "def detach_policy(user_name, policy_arn):\n    \"\"\"\n    Detaches a policy from a user.\n\n    :param user_name: The name of the user.\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\n    \"\"\"\n    try:\n        iam.User(user_name).detach_policy(PolicyArn=policy_arn)\n        logger.info('Detached policy %s from user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't detach policy %s from user %s.\", policy_arn, user_name)\n        raise",
        "mutated": [
            "def detach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n    '\\n    Detaches a policy from a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).detach_policy(PolicyArn=policy_arn)\n        logger.info('Detached policy %s from user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't detach policy %s from user %s.\", policy_arn, user_name)\n        raise",
            "def detach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Detaches a policy from a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).detach_policy(PolicyArn=policy_arn)\n        logger.info('Detached policy %s from user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't detach policy %s from user %s.\", policy_arn, user_name)\n        raise",
            "def detach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Detaches a policy from a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).detach_policy(PolicyArn=policy_arn)\n        logger.info('Detached policy %s from user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't detach policy %s from user %s.\", policy_arn, user_name)\n        raise",
            "def detach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Detaches a policy from a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).detach_policy(PolicyArn=policy_arn)\n        logger.info('Detached policy %s from user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't detach policy %s from user %s.\", policy_arn, user_name)\n        raise",
            "def detach_policy(user_name, policy_arn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Detaches a policy from a user.\\n\\n    :param user_name: The name of the user.\\n    :param policy_arn: The Amazon Resource Name (ARN) of the policy.\\n    '\n    try:\n        iam.User(user_name).detach_policy(PolicyArn=policy_arn)\n        logger.info('Detached policy %s from user %s.', policy_arn, user_name)\n    except ClientError:\n        logger.exception(\"Couldn't detach policy %s from user %s.\", policy_arn, user_name)\n        raise"
        ]
    },
    {
        "func_name": "usage_demo",
        "original": "def usage_demo():\n    \"\"\"\n    Shows how to manage users, keys, and policies.\n    This demonstration creates two users: one user who can put and get objects in an\n    Amazon S3 bucket, and another user who can only get objects from the bucket.\n    The demo then shows how the users can perform only the actions they are permitted\n    to perform.\n    \"\"\"\n    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\n    print('-' * 88)\n    print('Welcome to the AWS Identity and Account Management user demo.')\n    print('-' * 88)\n    print('Users can have policies and roles attached to grant them specific permissions.')\n    s3 = boto3.resource('s3')\n    bucket = s3.create_bucket(Bucket=f'demo-iam-bucket-{time.time_ns()}', CreateBucketConfiguration={'LocationConstraint': s3.meta.client.meta.region_name})\n    print(f'Created an Amazon S3 bucket named {bucket.name}.')\n    user_read_writer = create_user('demo-iam-read-writer')\n    user_reader = create_user('demo-iam-reader')\n    print(f'Created two IAM users: {user_read_writer.name} and {user_reader.name}')\n    update_user(user_read_writer.name, 'demo-iam-creator')\n    update_user(user_reader.name, 'demo-iam-getter')\n    users = list_users()\n    user_read_writer = next((user for user in users if user.user_id == user_read_writer.user_id))\n    user_reader = next((user for user in users if user.user_id == user_reader.user_id))\n    print(f'Changed the names of the users to {user_read_writer.name} and {user_reader.name}.')\n    read_write_policy = policy_wrapper.create_policy('demo-iam-read-write-policy', 'Grants rights to create and get an object in the demo bucket.', ['s3:PutObject', 's3:GetObject'], f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_write_policy.policy_name} with ARN: {read_write_policy.arn}')\n    print(read_write_policy.description)\n    read_policy = policy_wrapper.create_policy('demo-iam-read-policy', 'Grants rights to get an object from the demo bucket.', 's3:GetObject', f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_policy.policy_name} with ARN: {read_policy.arn}')\n    print(read_policy.description)\n    attach_policy(user_read_writer.name, read_write_policy.arn)\n    print(f'Attached {read_write_policy.policy_name} to {user_read_writer.name}.')\n    attach_policy(user_reader.name, read_policy.arn)\n    print(f'Attached {read_policy.policy_name} to {user_reader.name}.')\n    user_read_writer_key = access_key_wrapper.create_key(user_read_writer.name)\n    print(f'Created access key pair for {user_read_writer.name}.')\n    user_reader_key = access_key_wrapper.create_key(user_reader.name)\n    print(f'Created access key pair for {user_reader.name}.')\n    s3_read_writer_resource = boto3.resource('s3', aws_access_key_id=user_read_writer_key.id, aws_secret_access_key=user_read_writer_key.secret)\n    demo_object_key = f'object-{time.time_ns()}'\n    demo_object = None\n    while demo_object is None:\n        try:\n            demo_object = s3_read_writer_resource.Bucket(bucket.name).put_object(Key=demo_object_key, Body=b'AWS IAM demo object content!')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    print(f\"Put {demo_object_key} into {bucket.name} using {user_read_writer.name}'s credentials.\")\n    read_writer_object = s3_read_writer_resource.Bucket(bucket.name).Object(demo_object_key)\n    read_writer_content = read_writer_object.get()['Body'].read()\n    print(f\"Got object {read_writer_object.key} using read-writer user's credentials.\")\n    print(f'Object content: {read_writer_content}')\n    s3_reader_resource = boto3.resource('s3', aws_access_key_id=user_reader_key.id, aws_secret_access_key=user_reader_key.secret)\n    demo_content = None\n    while demo_content is None:\n        try:\n            demo_object = s3_reader_resource.Bucket(bucket.name).Object(demo_object_key)\n            demo_content = demo_object.get()['Body'].read()\n            print(f\"Got object {demo_object.key} using reader user's credentials.\")\n            print(f'Object content: {demo_content}')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    try:\n        demo_object.delete()\n    except ClientError as error:\n        if error.response['Error']['Code'] == 'AccessDenied':\n            print('-' * 88)\n            print(\"Tried to delete the object using the reader user's credentials. Got expected AccessDenied error because the reader is not allowed to delete objects.\")\n            print('-' * 88)\n    access_key_wrapper.delete_key(user_reader.name, user_reader_key.id)\n    detach_policy(user_reader.name, read_policy.arn)\n    policy_wrapper.delete_policy(read_policy.arn)\n    delete_user(user_reader.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_reader.name}.')\n    access_key_wrapper.delete_key(user_read_writer.name, user_read_writer_key.id)\n    detach_policy(user_read_writer.name, read_write_policy.arn)\n    policy_wrapper.delete_policy(read_write_policy.arn)\n    delete_user(user_read_writer.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_read_writer.name}.')\n    bucket.objects.delete()\n    bucket.delete()\n    print(f'Emptied and deleted {bucket.name}.')\n    print('Thanks for watching!')",
        "mutated": [
            "def usage_demo():\n    if False:\n        i = 10\n    '\\n    Shows how to manage users, keys, and policies.\\n    This demonstration creates two users: one user who can put and get objects in an\\n    Amazon S3 bucket, and another user who can only get objects from the bucket.\\n    The demo then shows how the users can perform only the actions they are permitted\\n    to perform.\\n    '\n    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\n    print('-' * 88)\n    print('Welcome to the AWS Identity and Account Management user demo.')\n    print('-' * 88)\n    print('Users can have policies and roles attached to grant them specific permissions.')\n    s3 = boto3.resource('s3')\n    bucket = s3.create_bucket(Bucket=f'demo-iam-bucket-{time.time_ns()}', CreateBucketConfiguration={'LocationConstraint': s3.meta.client.meta.region_name})\n    print(f'Created an Amazon S3 bucket named {bucket.name}.')\n    user_read_writer = create_user('demo-iam-read-writer')\n    user_reader = create_user('demo-iam-reader')\n    print(f'Created two IAM users: {user_read_writer.name} and {user_reader.name}')\n    update_user(user_read_writer.name, 'demo-iam-creator')\n    update_user(user_reader.name, 'demo-iam-getter')\n    users = list_users()\n    user_read_writer = next((user for user in users if user.user_id == user_read_writer.user_id))\n    user_reader = next((user for user in users if user.user_id == user_reader.user_id))\n    print(f'Changed the names of the users to {user_read_writer.name} and {user_reader.name}.')\n    read_write_policy = policy_wrapper.create_policy('demo-iam-read-write-policy', 'Grants rights to create and get an object in the demo bucket.', ['s3:PutObject', 's3:GetObject'], f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_write_policy.policy_name} with ARN: {read_write_policy.arn}')\n    print(read_write_policy.description)\n    read_policy = policy_wrapper.create_policy('demo-iam-read-policy', 'Grants rights to get an object from the demo bucket.', 's3:GetObject', f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_policy.policy_name} with ARN: {read_policy.arn}')\n    print(read_policy.description)\n    attach_policy(user_read_writer.name, read_write_policy.arn)\n    print(f'Attached {read_write_policy.policy_name} to {user_read_writer.name}.')\n    attach_policy(user_reader.name, read_policy.arn)\n    print(f'Attached {read_policy.policy_name} to {user_reader.name}.')\n    user_read_writer_key = access_key_wrapper.create_key(user_read_writer.name)\n    print(f'Created access key pair for {user_read_writer.name}.')\n    user_reader_key = access_key_wrapper.create_key(user_reader.name)\n    print(f'Created access key pair for {user_reader.name}.')\n    s3_read_writer_resource = boto3.resource('s3', aws_access_key_id=user_read_writer_key.id, aws_secret_access_key=user_read_writer_key.secret)\n    demo_object_key = f'object-{time.time_ns()}'\n    demo_object = None\n    while demo_object is None:\n        try:\n            demo_object = s3_read_writer_resource.Bucket(bucket.name).put_object(Key=demo_object_key, Body=b'AWS IAM demo object content!')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    print(f\"Put {demo_object_key} into {bucket.name} using {user_read_writer.name}'s credentials.\")\n    read_writer_object = s3_read_writer_resource.Bucket(bucket.name).Object(demo_object_key)\n    read_writer_content = read_writer_object.get()['Body'].read()\n    print(f\"Got object {read_writer_object.key} using read-writer user's credentials.\")\n    print(f'Object content: {read_writer_content}')\n    s3_reader_resource = boto3.resource('s3', aws_access_key_id=user_reader_key.id, aws_secret_access_key=user_reader_key.secret)\n    demo_content = None\n    while demo_content is None:\n        try:\n            demo_object = s3_reader_resource.Bucket(bucket.name).Object(demo_object_key)\n            demo_content = demo_object.get()['Body'].read()\n            print(f\"Got object {demo_object.key} using reader user's credentials.\")\n            print(f'Object content: {demo_content}')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    try:\n        demo_object.delete()\n    except ClientError as error:\n        if error.response['Error']['Code'] == 'AccessDenied':\n            print('-' * 88)\n            print(\"Tried to delete the object using the reader user's credentials. Got expected AccessDenied error because the reader is not allowed to delete objects.\")\n            print('-' * 88)\n    access_key_wrapper.delete_key(user_reader.name, user_reader_key.id)\n    detach_policy(user_reader.name, read_policy.arn)\n    policy_wrapper.delete_policy(read_policy.arn)\n    delete_user(user_reader.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_reader.name}.')\n    access_key_wrapper.delete_key(user_read_writer.name, user_read_writer_key.id)\n    detach_policy(user_read_writer.name, read_write_policy.arn)\n    policy_wrapper.delete_policy(read_write_policy.arn)\n    delete_user(user_read_writer.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_read_writer.name}.')\n    bucket.objects.delete()\n    bucket.delete()\n    print(f'Emptied and deleted {bucket.name}.')\n    print('Thanks for watching!')",
            "def usage_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Shows how to manage users, keys, and policies.\\n    This demonstration creates two users: one user who can put and get objects in an\\n    Amazon S3 bucket, and another user who can only get objects from the bucket.\\n    The demo then shows how the users can perform only the actions they are permitted\\n    to perform.\\n    '\n    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\n    print('-' * 88)\n    print('Welcome to the AWS Identity and Account Management user demo.')\n    print('-' * 88)\n    print('Users can have policies and roles attached to grant them specific permissions.')\n    s3 = boto3.resource('s3')\n    bucket = s3.create_bucket(Bucket=f'demo-iam-bucket-{time.time_ns()}', CreateBucketConfiguration={'LocationConstraint': s3.meta.client.meta.region_name})\n    print(f'Created an Amazon S3 bucket named {bucket.name}.')\n    user_read_writer = create_user('demo-iam-read-writer')\n    user_reader = create_user('demo-iam-reader')\n    print(f'Created two IAM users: {user_read_writer.name} and {user_reader.name}')\n    update_user(user_read_writer.name, 'demo-iam-creator')\n    update_user(user_reader.name, 'demo-iam-getter')\n    users = list_users()\n    user_read_writer = next((user for user in users if user.user_id == user_read_writer.user_id))\n    user_reader = next((user for user in users if user.user_id == user_reader.user_id))\n    print(f'Changed the names of the users to {user_read_writer.name} and {user_reader.name}.')\n    read_write_policy = policy_wrapper.create_policy('demo-iam-read-write-policy', 'Grants rights to create and get an object in the demo bucket.', ['s3:PutObject', 's3:GetObject'], f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_write_policy.policy_name} with ARN: {read_write_policy.arn}')\n    print(read_write_policy.description)\n    read_policy = policy_wrapper.create_policy('demo-iam-read-policy', 'Grants rights to get an object from the demo bucket.', 's3:GetObject', f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_policy.policy_name} with ARN: {read_policy.arn}')\n    print(read_policy.description)\n    attach_policy(user_read_writer.name, read_write_policy.arn)\n    print(f'Attached {read_write_policy.policy_name} to {user_read_writer.name}.')\n    attach_policy(user_reader.name, read_policy.arn)\n    print(f'Attached {read_policy.policy_name} to {user_reader.name}.')\n    user_read_writer_key = access_key_wrapper.create_key(user_read_writer.name)\n    print(f'Created access key pair for {user_read_writer.name}.')\n    user_reader_key = access_key_wrapper.create_key(user_reader.name)\n    print(f'Created access key pair for {user_reader.name}.')\n    s3_read_writer_resource = boto3.resource('s3', aws_access_key_id=user_read_writer_key.id, aws_secret_access_key=user_read_writer_key.secret)\n    demo_object_key = f'object-{time.time_ns()}'\n    demo_object = None\n    while demo_object is None:\n        try:\n            demo_object = s3_read_writer_resource.Bucket(bucket.name).put_object(Key=demo_object_key, Body=b'AWS IAM demo object content!')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    print(f\"Put {demo_object_key} into {bucket.name} using {user_read_writer.name}'s credentials.\")\n    read_writer_object = s3_read_writer_resource.Bucket(bucket.name).Object(demo_object_key)\n    read_writer_content = read_writer_object.get()['Body'].read()\n    print(f\"Got object {read_writer_object.key} using read-writer user's credentials.\")\n    print(f'Object content: {read_writer_content}')\n    s3_reader_resource = boto3.resource('s3', aws_access_key_id=user_reader_key.id, aws_secret_access_key=user_reader_key.secret)\n    demo_content = None\n    while demo_content is None:\n        try:\n            demo_object = s3_reader_resource.Bucket(bucket.name).Object(demo_object_key)\n            demo_content = demo_object.get()['Body'].read()\n            print(f\"Got object {demo_object.key} using reader user's credentials.\")\n            print(f'Object content: {demo_content}')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    try:\n        demo_object.delete()\n    except ClientError as error:\n        if error.response['Error']['Code'] == 'AccessDenied':\n            print('-' * 88)\n            print(\"Tried to delete the object using the reader user's credentials. Got expected AccessDenied error because the reader is not allowed to delete objects.\")\n            print('-' * 88)\n    access_key_wrapper.delete_key(user_reader.name, user_reader_key.id)\n    detach_policy(user_reader.name, read_policy.arn)\n    policy_wrapper.delete_policy(read_policy.arn)\n    delete_user(user_reader.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_reader.name}.')\n    access_key_wrapper.delete_key(user_read_writer.name, user_read_writer_key.id)\n    detach_policy(user_read_writer.name, read_write_policy.arn)\n    policy_wrapper.delete_policy(read_write_policy.arn)\n    delete_user(user_read_writer.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_read_writer.name}.')\n    bucket.objects.delete()\n    bucket.delete()\n    print(f'Emptied and deleted {bucket.name}.')\n    print('Thanks for watching!')",
            "def usage_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Shows how to manage users, keys, and policies.\\n    This demonstration creates two users: one user who can put and get objects in an\\n    Amazon S3 bucket, and another user who can only get objects from the bucket.\\n    The demo then shows how the users can perform only the actions they are permitted\\n    to perform.\\n    '\n    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\n    print('-' * 88)\n    print('Welcome to the AWS Identity and Account Management user demo.')\n    print('-' * 88)\n    print('Users can have policies and roles attached to grant them specific permissions.')\n    s3 = boto3.resource('s3')\n    bucket = s3.create_bucket(Bucket=f'demo-iam-bucket-{time.time_ns()}', CreateBucketConfiguration={'LocationConstraint': s3.meta.client.meta.region_name})\n    print(f'Created an Amazon S3 bucket named {bucket.name}.')\n    user_read_writer = create_user('demo-iam-read-writer')\n    user_reader = create_user('demo-iam-reader')\n    print(f'Created two IAM users: {user_read_writer.name} and {user_reader.name}')\n    update_user(user_read_writer.name, 'demo-iam-creator')\n    update_user(user_reader.name, 'demo-iam-getter')\n    users = list_users()\n    user_read_writer = next((user for user in users if user.user_id == user_read_writer.user_id))\n    user_reader = next((user for user in users if user.user_id == user_reader.user_id))\n    print(f'Changed the names of the users to {user_read_writer.name} and {user_reader.name}.')\n    read_write_policy = policy_wrapper.create_policy('demo-iam-read-write-policy', 'Grants rights to create and get an object in the demo bucket.', ['s3:PutObject', 's3:GetObject'], f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_write_policy.policy_name} with ARN: {read_write_policy.arn}')\n    print(read_write_policy.description)\n    read_policy = policy_wrapper.create_policy('demo-iam-read-policy', 'Grants rights to get an object from the demo bucket.', 's3:GetObject', f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_policy.policy_name} with ARN: {read_policy.arn}')\n    print(read_policy.description)\n    attach_policy(user_read_writer.name, read_write_policy.arn)\n    print(f'Attached {read_write_policy.policy_name} to {user_read_writer.name}.')\n    attach_policy(user_reader.name, read_policy.arn)\n    print(f'Attached {read_policy.policy_name} to {user_reader.name}.')\n    user_read_writer_key = access_key_wrapper.create_key(user_read_writer.name)\n    print(f'Created access key pair for {user_read_writer.name}.')\n    user_reader_key = access_key_wrapper.create_key(user_reader.name)\n    print(f'Created access key pair for {user_reader.name}.')\n    s3_read_writer_resource = boto3.resource('s3', aws_access_key_id=user_read_writer_key.id, aws_secret_access_key=user_read_writer_key.secret)\n    demo_object_key = f'object-{time.time_ns()}'\n    demo_object = None\n    while demo_object is None:\n        try:\n            demo_object = s3_read_writer_resource.Bucket(bucket.name).put_object(Key=demo_object_key, Body=b'AWS IAM demo object content!')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    print(f\"Put {demo_object_key} into {bucket.name} using {user_read_writer.name}'s credentials.\")\n    read_writer_object = s3_read_writer_resource.Bucket(bucket.name).Object(demo_object_key)\n    read_writer_content = read_writer_object.get()['Body'].read()\n    print(f\"Got object {read_writer_object.key} using read-writer user's credentials.\")\n    print(f'Object content: {read_writer_content}')\n    s3_reader_resource = boto3.resource('s3', aws_access_key_id=user_reader_key.id, aws_secret_access_key=user_reader_key.secret)\n    demo_content = None\n    while demo_content is None:\n        try:\n            demo_object = s3_reader_resource.Bucket(bucket.name).Object(demo_object_key)\n            demo_content = demo_object.get()['Body'].read()\n            print(f\"Got object {demo_object.key} using reader user's credentials.\")\n            print(f'Object content: {demo_content}')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    try:\n        demo_object.delete()\n    except ClientError as error:\n        if error.response['Error']['Code'] == 'AccessDenied':\n            print('-' * 88)\n            print(\"Tried to delete the object using the reader user's credentials. Got expected AccessDenied error because the reader is not allowed to delete objects.\")\n            print('-' * 88)\n    access_key_wrapper.delete_key(user_reader.name, user_reader_key.id)\n    detach_policy(user_reader.name, read_policy.arn)\n    policy_wrapper.delete_policy(read_policy.arn)\n    delete_user(user_reader.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_reader.name}.')\n    access_key_wrapper.delete_key(user_read_writer.name, user_read_writer_key.id)\n    detach_policy(user_read_writer.name, read_write_policy.arn)\n    policy_wrapper.delete_policy(read_write_policy.arn)\n    delete_user(user_read_writer.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_read_writer.name}.')\n    bucket.objects.delete()\n    bucket.delete()\n    print(f'Emptied and deleted {bucket.name}.')\n    print('Thanks for watching!')",
            "def usage_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Shows how to manage users, keys, and policies.\\n    This demonstration creates two users: one user who can put and get objects in an\\n    Amazon S3 bucket, and another user who can only get objects from the bucket.\\n    The demo then shows how the users can perform only the actions they are permitted\\n    to perform.\\n    '\n    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\n    print('-' * 88)\n    print('Welcome to the AWS Identity and Account Management user demo.')\n    print('-' * 88)\n    print('Users can have policies and roles attached to grant them specific permissions.')\n    s3 = boto3.resource('s3')\n    bucket = s3.create_bucket(Bucket=f'demo-iam-bucket-{time.time_ns()}', CreateBucketConfiguration={'LocationConstraint': s3.meta.client.meta.region_name})\n    print(f'Created an Amazon S3 bucket named {bucket.name}.')\n    user_read_writer = create_user('demo-iam-read-writer')\n    user_reader = create_user('demo-iam-reader')\n    print(f'Created two IAM users: {user_read_writer.name} and {user_reader.name}')\n    update_user(user_read_writer.name, 'demo-iam-creator')\n    update_user(user_reader.name, 'demo-iam-getter')\n    users = list_users()\n    user_read_writer = next((user for user in users if user.user_id == user_read_writer.user_id))\n    user_reader = next((user for user in users if user.user_id == user_reader.user_id))\n    print(f'Changed the names of the users to {user_read_writer.name} and {user_reader.name}.')\n    read_write_policy = policy_wrapper.create_policy('demo-iam-read-write-policy', 'Grants rights to create and get an object in the demo bucket.', ['s3:PutObject', 's3:GetObject'], f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_write_policy.policy_name} with ARN: {read_write_policy.arn}')\n    print(read_write_policy.description)\n    read_policy = policy_wrapper.create_policy('demo-iam-read-policy', 'Grants rights to get an object from the demo bucket.', 's3:GetObject', f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_policy.policy_name} with ARN: {read_policy.arn}')\n    print(read_policy.description)\n    attach_policy(user_read_writer.name, read_write_policy.arn)\n    print(f'Attached {read_write_policy.policy_name} to {user_read_writer.name}.')\n    attach_policy(user_reader.name, read_policy.arn)\n    print(f'Attached {read_policy.policy_name} to {user_reader.name}.')\n    user_read_writer_key = access_key_wrapper.create_key(user_read_writer.name)\n    print(f'Created access key pair for {user_read_writer.name}.')\n    user_reader_key = access_key_wrapper.create_key(user_reader.name)\n    print(f'Created access key pair for {user_reader.name}.')\n    s3_read_writer_resource = boto3.resource('s3', aws_access_key_id=user_read_writer_key.id, aws_secret_access_key=user_read_writer_key.secret)\n    demo_object_key = f'object-{time.time_ns()}'\n    demo_object = None\n    while demo_object is None:\n        try:\n            demo_object = s3_read_writer_resource.Bucket(bucket.name).put_object(Key=demo_object_key, Body=b'AWS IAM demo object content!')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    print(f\"Put {demo_object_key} into {bucket.name} using {user_read_writer.name}'s credentials.\")\n    read_writer_object = s3_read_writer_resource.Bucket(bucket.name).Object(demo_object_key)\n    read_writer_content = read_writer_object.get()['Body'].read()\n    print(f\"Got object {read_writer_object.key} using read-writer user's credentials.\")\n    print(f'Object content: {read_writer_content}')\n    s3_reader_resource = boto3.resource('s3', aws_access_key_id=user_reader_key.id, aws_secret_access_key=user_reader_key.secret)\n    demo_content = None\n    while demo_content is None:\n        try:\n            demo_object = s3_reader_resource.Bucket(bucket.name).Object(demo_object_key)\n            demo_content = demo_object.get()['Body'].read()\n            print(f\"Got object {demo_object.key} using reader user's credentials.\")\n            print(f'Object content: {demo_content}')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    try:\n        demo_object.delete()\n    except ClientError as error:\n        if error.response['Error']['Code'] == 'AccessDenied':\n            print('-' * 88)\n            print(\"Tried to delete the object using the reader user's credentials. Got expected AccessDenied error because the reader is not allowed to delete objects.\")\n            print('-' * 88)\n    access_key_wrapper.delete_key(user_reader.name, user_reader_key.id)\n    detach_policy(user_reader.name, read_policy.arn)\n    policy_wrapper.delete_policy(read_policy.arn)\n    delete_user(user_reader.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_reader.name}.')\n    access_key_wrapper.delete_key(user_read_writer.name, user_read_writer_key.id)\n    detach_policy(user_read_writer.name, read_write_policy.arn)\n    policy_wrapper.delete_policy(read_write_policy.arn)\n    delete_user(user_read_writer.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_read_writer.name}.')\n    bucket.objects.delete()\n    bucket.delete()\n    print(f'Emptied and deleted {bucket.name}.')\n    print('Thanks for watching!')",
            "def usage_demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Shows how to manage users, keys, and policies.\\n    This demonstration creates two users: one user who can put and get objects in an\\n    Amazon S3 bucket, and another user who can only get objects from the bucket.\\n    The demo then shows how the users can perform only the actions they are permitted\\n    to perform.\\n    '\n    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\n    print('-' * 88)\n    print('Welcome to the AWS Identity and Account Management user demo.')\n    print('-' * 88)\n    print('Users can have policies and roles attached to grant them specific permissions.')\n    s3 = boto3.resource('s3')\n    bucket = s3.create_bucket(Bucket=f'demo-iam-bucket-{time.time_ns()}', CreateBucketConfiguration={'LocationConstraint': s3.meta.client.meta.region_name})\n    print(f'Created an Amazon S3 bucket named {bucket.name}.')\n    user_read_writer = create_user('demo-iam-read-writer')\n    user_reader = create_user('demo-iam-reader')\n    print(f'Created two IAM users: {user_read_writer.name} and {user_reader.name}')\n    update_user(user_read_writer.name, 'demo-iam-creator')\n    update_user(user_reader.name, 'demo-iam-getter')\n    users = list_users()\n    user_read_writer = next((user for user in users if user.user_id == user_read_writer.user_id))\n    user_reader = next((user for user in users if user.user_id == user_reader.user_id))\n    print(f'Changed the names of the users to {user_read_writer.name} and {user_reader.name}.')\n    read_write_policy = policy_wrapper.create_policy('demo-iam-read-write-policy', 'Grants rights to create and get an object in the demo bucket.', ['s3:PutObject', 's3:GetObject'], f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_write_policy.policy_name} with ARN: {read_write_policy.arn}')\n    print(read_write_policy.description)\n    read_policy = policy_wrapper.create_policy('demo-iam-read-policy', 'Grants rights to get an object from the demo bucket.', 's3:GetObject', f'arn:aws:s3:::{bucket.name}/*')\n    print(f'Created policy {read_policy.policy_name} with ARN: {read_policy.arn}')\n    print(read_policy.description)\n    attach_policy(user_read_writer.name, read_write_policy.arn)\n    print(f'Attached {read_write_policy.policy_name} to {user_read_writer.name}.')\n    attach_policy(user_reader.name, read_policy.arn)\n    print(f'Attached {read_policy.policy_name} to {user_reader.name}.')\n    user_read_writer_key = access_key_wrapper.create_key(user_read_writer.name)\n    print(f'Created access key pair for {user_read_writer.name}.')\n    user_reader_key = access_key_wrapper.create_key(user_reader.name)\n    print(f'Created access key pair for {user_reader.name}.')\n    s3_read_writer_resource = boto3.resource('s3', aws_access_key_id=user_read_writer_key.id, aws_secret_access_key=user_read_writer_key.secret)\n    demo_object_key = f'object-{time.time_ns()}'\n    demo_object = None\n    while demo_object is None:\n        try:\n            demo_object = s3_read_writer_resource.Bucket(bucket.name).put_object(Key=demo_object_key, Body=b'AWS IAM demo object content!')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    print(f\"Put {demo_object_key} into {bucket.name} using {user_read_writer.name}'s credentials.\")\n    read_writer_object = s3_read_writer_resource.Bucket(bucket.name).Object(demo_object_key)\n    read_writer_content = read_writer_object.get()['Body'].read()\n    print(f\"Got object {read_writer_object.key} using read-writer user's credentials.\")\n    print(f'Object content: {read_writer_content}')\n    s3_reader_resource = boto3.resource('s3', aws_access_key_id=user_reader_key.id, aws_secret_access_key=user_reader_key.secret)\n    demo_content = None\n    while demo_content is None:\n        try:\n            demo_object = s3_reader_resource.Bucket(bucket.name).Object(demo_object_key)\n            demo_content = demo_object.get()['Body'].read()\n            print(f\"Got object {demo_object.key} using reader user's credentials.\")\n            print(f'Object content: {demo_content}')\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'InvalidAccessKeyId':\n                print('Access key not yet available. Waiting...')\n                time.sleep(1)\n            else:\n                raise\n    try:\n        demo_object.delete()\n    except ClientError as error:\n        if error.response['Error']['Code'] == 'AccessDenied':\n            print('-' * 88)\n            print(\"Tried to delete the object using the reader user's credentials. Got expected AccessDenied error because the reader is not allowed to delete objects.\")\n            print('-' * 88)\n    access_key_wrapper.delete_key(user_reader.name, user_reader_key.id)\n    detach_policy(user_reader.name, read_policy.arn)\n    policy_wrapper.delete_policy(read_policy.arn)\n    delete_user(user_reader.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_reader.name}.')\n    access_key_wrapper.delete_key(user_read_writer.name, user_read_writer_key.id)\n    detach_policy(user_read_writer.name, read_write_policy.arn)\n    policy_wrapper.delete_policy(read_write_policy.arn)\n    delete_user(user_read_writer.name)\n    print(f'Deleted keys, detached and deleted policy, and deleted {user_read_writer.name}.')\n    bucket.objects.delete()\n    bucket.delete()\n    print(f'Emptied and deleted {bucket.name}.')\n    print('Thanks for watching!')"
        ]
    }
]