[
    {
        "func_name": "_assemble_from_fragments",
        "original": "def _assemble_from_fragments(self, src_path, delimiter=None, compiled_regexp=None, ignore_hidden=False, decrypt=True):\n    \"\"\" assemble a file from a directory of fragments \"\"\"\n    (tmpfd, temp_path) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    tmp = os.fdopen(tmpfd, 'wb')\n    delimit_me = False\n    add_newline = False\n    for f in (to_text(p, errors='surrogate_or_strict') for p in sorted(os.listdir(src_path))):\n        if compiled_regexp and (not compiled_regexp.search(f)):\n            continue\n        fragment = u'%s/%s' % (src_path, f)\n        if not os.path.isfile(fragment) or (ignore_hidden and os.path.basename(fragment).startswith('.')):\n            continue\n        with open(self._loader.get_real_file(fragment, decrypt=decrypt), 'rb') as fragment_fh:\n            fragment_content = fragment_fh.read()\n        if add_newline:\n            tmp.write(b'\\n')\n        if delimit_me:\n            if delimiter:\n                delimiter = codecs.escape_decode(delimiter)[0]\n                tmp.write(delimiter)\n                if delimiter[-1] != b'\\n':\n                    tmp.write(b'\\n')\n        tmp.write(fragment_content)\n        delimit_me = True\n        if fragment_content.endswith(b'\\n'):\n            add_newline = False\n        else:\n            add_newline = True\n    tmp.close()\n    return temp_path",
        "mutated": [
            "def _assemble_from_fragments(self, src_path, delimiter=None, compiled_regexp=None, ignore_hidden=False, decrypt=True):\n    if False:\n        i = 10\n    ' assemble a file from a directory of fragments '\n    (tmpfd, temp_path) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    tmp = os.fdopen(tmpfd, 'wb')\n    delimit_me = False\n    add_newline = False\n    for f in (to_text(p, errors='surrogate_or_strict') for p in sorted(os.listdir(src_path))):\n        if compiled_regexp and (not compiled_regexp.search(f)):\n            continue\n        fragment = u'%s/%s' % (src_path, f)\n        if not os.path.isfile(fragment) or (ignore_hidden and os.path.basename(fragment).startswith('.')):\n            continue\n        with open(self._loader.get_real_file(fragment, decrypt=decrypt), 'rb') as fragment_fh:\n            fragment_content = fragment_fh.read()\n        if add_newline:\n            tmp.write(b'\\n')\n        if delimit_me:\n            if delimiter:\n                delimiter = codecs.escape_decode(delimiter)[0]\n                tmp.write(delimiter)\n                if delimiter[-1] != b'\\n':\n                    tmp.write(b'\\n')\n        tmp.write(fragment_content)\n        delimit_me = True\n        if fragment_content.endswith(b'\\n'):\n            add_newline = False\n        else:\n            add_newline = True\n    tmp.close()\n    return temp_path",
            "def _assemble_from_fragments(self, src_path, delimiter=None, compiled_regexp=None, ignore_hidden=False, decrypt=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' assemble a file from a directory of fragments '\n    (tmpfd, temp_path) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    tmp = os.fdopen(tmpfd, 'wb')\n    delimit_me = False\n    add_newline = False\n    for f in (to_text(p, errors='surrogate_or_strict') for p in sorted(os.listdir(src_path))):\n        if compiled_regexp and (not compiled_regexp.search(f)):\n            continue\n        fragment = u'%s/%s' % (src_path, f)\n        if not os.path.isfile(fragment) or (ignore_hidden and os.path.basename(fragment).startswith('.')):\n            continue\n        with open(self._loader.get_real_file(fragment, decrypt=decrypt), 'rb') as fragment_fh:\n            fragment_content = fragment_fh.read()\n        if add_newline:\n            tmp.write(b'\\n')\n        if delimit_me:\n            if delimiter:\n                delimiter = codecs.escape_decode(delimiter)[0]\n                tmp.write(delimiter)\n                if delimiter[-1] != b'\\n':\n                    tmp.write(b'\\n')\n        tmp.write(fragment_content)\n        delimit_me = True\n        if fragment_content.endswith(b'\\n'):\n            add_newline = False\n        else:\n            add_newline = True\n    tmp.close()\n    return temp_path",
            "def _assemble_from_fragments(self, src_path, delimiter=None, compiled_regexp=None, ignore_hidden=False, decrypt=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' assemble a file from a directory of fragments '\n    (tmpfd, temp_path) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    tmp = os.fdopen(tmpfd, 'wb')\n    delimit_me = False\n    add_newline = False\n    for f in (to_text(p, errors='surrogate_or_strict') for p in sorted(os.listdir(src_path))):\n        if compiled_regexp and (not compiled_regexp.search(f)):\n            continue\n        fragment = u'%s/%s' % (src_path, f)\n        if not os.path.isfile(fragment) or (ignore_hidden and os.path.basename(fragment).startswith('.')):\n            continue\n        with open(self._loader.get_real_file(fragment, decrypt=decrypt), 'rb') as fragment_fh:\n            fragment_content = fragment_fh.read()\n        if add_newline:\n            tmp.write(b'\\n')\n        if delimit_me:\n            if delimiter:\n                delimiter = codecs.escape_decode(delimiter)[0]\n                tmp.write(delimiter)\n                if delimiter[-1] != b'\\n':\n                    tmp.write(b'\\n')\n        tmp.write(fragment_content)\n        delimit_me = True\n        if fragment_content.endswith(b'\\n'):\n            add_newline = False\n        else:\n            add_newline = True\n    tmp.close()\n    return temp_path",
            "def _assemble_from_fragments(self, src_path, delimiter=None, compiled_regexp=None, ignore_hidden=False, decrypt=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' assemble a file from a directory of fragments '\n    (tmpfd, temp_path) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    tmp = os.fdopen(tmpfd, 'wb')\n    delimit_me = False\n    add_newline = False\n    for f in (to_text(p, errors='surrogate_or_strict') for p in sorted(os.listdir(src_path))):\n        if compiled_regexp and (not compiled_regexp.search(f)):\n            continue\n        fragment = u'%s/%s' % (src_path, f)\n        if not os.path.isfile(fragment) or (ignore_hidden and os.path.basename(fragment).startswith('.')):\n            continue\n        with open(self._loader.get_real_file(fragment, decrypt=decrypt), 'rb') as fragment_fh:\n            fragment_content = fragment_fh.read()\n        if add_newline:\n            tmp.write(b'\\n')\n        if delimit_me:\n            if delimiter:\n                delimiter = codecs.escape_decode(delimiter)[0]\n                tmp.write(delimiter)\n                if delimiter[-1] != b'\\n':\n                    tmp.write(b'\\n')\n        tmp.write(fragment_content)\n        delimit_me = True\n        if fragment_content.endswith(b'\\n'):\n            add_newline = False\n        else:\n            add_newline = True\n    tmp.close()\n    return temp_path",
            "def _assemble_from_fragments(self, src_path, delimiter=None, compiled_regexp=None, ignore_hidden=False, decrypt=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' assemble a file from a directory of fragments '\n    (tmpfd, temp_path) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    tmp = os.fdopen(tmpfd, 'wb')\n    delimit_me = False\n    add_newline = False\n    for f in (to_text(p, errors='surrogate_or_strict') for p in sorted(os.listdir(src_path))):\n        if compiled_regexp and (not compiled_regexp.search(f)):\n            continue\n        fragment = u'%s/%s' % (src_path, f)\n        if not os.path.isfile(fragment) or (ignore_hidden and os.path.basename(fragment).startswith('.')):\n            continue\n        with open(self._loader.get_real_file(fragment, decrypt=decrypt), 'rb') as fragment_fh:\n            fragment_content = fragment_fh.read()\n        if add_newline:\n            tmp.write(b'\\n')\n        if delimit_me:\n            if delimiter:\n                delimiter = codecs.escape_decode(delimiter)[0]\n                tmp.write(delimiter)\n                if delimiter[-1] != b'\\n':\n                    tmp.write(b'\\n')\n        tmp.write(fragment_content)\n        delimit_me = True\n        if fragment_content.endswith(b'\\n'):\n            add_newline = False\n        else:\n            add_newline = True\n    tmp.close()\n    return temp_path"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self, tmp=None, task_vars=None):\n    self._supports_check_mode = False\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    if task_vars is None:\n        task_vars = dict()\n    src = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    delimiter = self._task.args.get('delimiter', None)\n    remote_src = self._task.args.get('remote_src', 'yes')\n    regexp = self._task.args.get('regexp', None)\n    follow = self._task.args.get('follow', False)\n    ignore_hidden = self._task.args.get('ignore_hidden', False)\n    decrypt = self._task.args.pop('decrypt', True)\n    try:\n        if src is None or dest is None:\n            raise AnsibleActionFail('src and dest are required')\n        if boolean(remote_src, strict=False):\n            result.update(self._execute_module(module_name='ansible.legacy.assemble', task_vars=task_vars))\n            raise _AnsibleActionDone()\n        else:\n            try:\n                src = self._find_needle('files', src)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_native(e))\n        if not os.path.isdir(src):\n            raise AnsibleActionFail(u'Source (%s) is not a directory' % src)\n        _re = None\n        if regexp is not None:\n            _re = re.compile(regexp)\n        path = self._assemble_from_fragments(src, delimiter, _re, ignore_hidden, decrypt)\n        path_checksum = checksum_s(path)\n        dest = self._remote_expand_user(dest)\n        dest_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=follow)\n        diff = {}\n        new_module_args = self._task.args.copy()\n        for opt in ['remote_src', 'regexp', 'delimiter', 'ignore_hidden', 'decrypt']:\n            if opt in new_module_args:\n                del new_module_args[opt]\n        new_module_args['dest'] = dest\n        if path_checksum != dest_stat['checksum']:\n            if self._play_context.diff:\n                diff = self._get_diff_data(dest, path, task_vars)\n            remote_path = self._connection._shell.join_path(self._connection._shell.tmpdir, 'src')\n            xfered = self._transfer_file(path, remote_path)\n            self._fixup_perms2((self._connection._shell.tmpdir, remote_path))\n            new_module_args.update(dict(src=xfered))\n            res = self._execute_module(module_name='ansible.legacy.copy', module_args=new_module_args, task_vars=task_vars)\n            if diff:\n                res['diff'] = diff\n            result.update(res)\n        else:\n            result.update(self._execute_module(module_name='ansible.legacy.file', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
        "mutated": [
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n    self._supports_check_mode = False\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    if task_vars is None:\n        task_vars = dict()\n    src = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    delimiter = self._task.args.get('delimiter', None)\n    remote_src = self._task.args.get('remote_src', 'yes')\n    regexp = self._task.args.get('regexp', None)\n    follow = self._task.args.get('follow', False)\n    ignore_hidden = self._task.args.get('ignore_hidden', False)\n    decrypt = self._task.args.pop('decrypt', True)\n    try:\n        if src is None or dest is None:\n            raise AnsibleActionFail('src and dest are required')\n        if boolean(remote_src, strict=False):\n            result.update(self._execute_module(module_name='ansible.legacy.assemble', task_vars=task_vars))\n            raise _AnsibleActionDone()\n        else:\n            try:\n                src = self._find_needle('files', src)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_native(e))\n        if not os.path.isdir(src):\n            raise AnsibleActionFail(u'Source (%s) is not a directory' % src)\n        _re = None\n        if regexp is not None:\n            _re = re.compile(regexp)\n        path = self._assemble_from_fragments(src, delimiter, _re, ignore_hidden, decrypt)\n        path_checksum = checksum_s(path)\n        dest = self._remote_expand_user(dest)\n        dest_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=follow)\n        diff = {}\n        new_module_args = self._task.args.copy()\n        for opt in ['remote_src', 'regexp', 'delimiter', 'ignore_hidden', 'decrypt']:\n            if opt in new_module_args:\n                del new_module_args[opt]\n        new_module_args['dest'] = dest\n        if path_checksum != dest_stat['checksum']:\n            if self._play_context.diff:\n                diff = self._get_diff_data(dest, path, task_vars)\n            remote_path = self._connection._shell.join_path(self._connection._shell.tmpdir, 'src')\n            xfered = self._transfer_file(path, remote_path)\n            self._fixup_perms2((self._connection._shell.tmpdir, remote_path))\n            new_module_args.update(dict(src=xfered))\n            res = self._execute_module(module_name='ansible.legacy.copy', module_args=new_module_args, task_vars=task_vars)\n            if diff:\n                res['diff'] = diff\n            result.update(res)\n        else:\n            result.update(self._execute_module(module_name='ansible.legacy.file', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._supports_check_mode = False\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    if task_vars is None:\n        task_vars = dict()\n    src = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    delimiter = self._task.args.get('delimiter', None)\n    remote_src = self._task.args.get('remote_src', 'yes')\n    regexp = self._task.args.get('regexp', None)\n    follow = self._task.args.get('follow', False)\n    ignore_hidden = self._task.args.get('ignore_hidden', False)\n    decrypt = self._task.args.pop('decrypt', True)\n    try:\n        if src is None or dest is None:\n            raise AnsibleActionFail('src and dest are required')\n        if boolean(remote_src, strict=False):\n            result.update(self._execute_module(module_name='ansible.legacy.assemble', task_vars=task_vars))\n            raise _AnsibleActionDone()\n        else:\n            try:\n                src = self._find_needle('files', src)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_native(e))\n        if not os.path.isdir(src):\n            raise AnsibleActionFail(u'Source (%s) is not a directory' % src)\n        _re = None\n        if regexp is not None:\n            _re = re.compile(regexp)\n        path = self._assemble_from_fragments(src, delimiter, _re, ignore_hidden, decrypt)\n        path_checksum = checksum_s(path)\n        dest = self._remote_expand_user(dest)\n        dest_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=follow)\n        diff = {}\n        new_module_args = self._task.args.copy()\n        for opt in ['remote_src', 'regexp', 'delimiter', 'ignore_hidden', 'decrypt']:\n            if opt in new_module_args:\n                del new_module_args[opt]\n        new_module_args['dest'] = dest\n        if path_checksum != dest_stat['checksum']:\n            if self._play_context.diff:\n                diff = self._get_diff_data(dest, path, task_vars)\n            remote_path = self._connection._shell.join_path(self._connection._shell.tmpdir, 'src')\n            xfered = self._transfer_file(path, remote_path)\n            self._fixup_perms2((self._connection._shell.tmpdir, remote_path))\n            new_module_args.update(dict(src=xfered))\n            res = self._execute_module(module_name='ansible.legacy.copy', module_args=new_module_args, task_vars=task_vars)\n            if diff:\n                res['diff'] = diff\n            result.update(res)\n        else:\n            result.update(self._execute_module(module_name='ansible.legacy.file', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._supports_check_mode = False\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    if task_vars is None:\n        task_vars = dict()\n    src = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    delimiter = self._task.args.get('delimiter', None)\n    remote_src = self._task.args.get('remote_src', 'yes')\n    regexp = self._task.args.get('regexp', None)\n    follow = self._task.args.get('follow', False)\n    ignore_hidden = self._task.args.get('ignore_hidden', False)\n    decrypt = self._task.args.pop('decrypt', True)\n    try:\n        if src is None or dest is None:\n            raise AnsibleActionFail('src and dest are required')\n        if boolean(remote_src, strict=False):\n            result.update(self._execute_module(module_name='ansible.legacy.assemble', task_vars=task_vars))\n            raise _AnsibleActionDone()\n        else:\n            try:\n                src = self._find_needle('files', src)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_native(e))\n        if not os.path.isdir(src):\n            raise AnsibleActionFail(u'Source (%s) is not a directory' % src)\n        _re = None\n        if regexp is not None:\n            _re = re.compile(regexp)\n        path = self._assemble_from_fragments(src, delimiter, _re, ignore_hidden, decrypt)\n        path_checksum = checksum_s(path)\n        dest = self._remote_expand_user(dest)\n        dest_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=follow)\n        diff = {}\n        new_module_args = self._task.args.copy()\n        for opt in ['remote_src', 'regexp', 'delimiter', 'ignore_hidden', 'decrypt']:\n            if opt in new_module_args:\n                del new_module_args[opt]\n        new_module_args['dest'] = dest\n        if path_checksum != dest_stat['checksum']:\n            if self._play_context.diff:\n                diff = self._get_diff_data(dest, path, task_vars)\n            remote_path = self._connection._shell.join_path(self._connection._shell.tmpdir, 'src')\n            xfered = self._transfer_file(path, remote_path)\n            self._fixup_perms2((self._connection._shell.tmpdir, remote_path))\n            new_module_args.update(dict(src=xfered))\n            res = self._execute_module(module_name='ansible.legacy.copy', module_args=new_module_args, task_vars=task_vars)\n            if diff:\n                res['diff'] = diff\n            result.update(res)\n        else:\n            result.update(self._execute_module(module_name='ansible.legacy.file', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._supports_check_mode = False\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    if task_vars is None:\n        task_vars = dict()\n    src = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    delimiter = self._task.args.get('delimiter', None)\n    remote_src = self._task.args.get('remote_src', 'yes')\n    regexp = self._task.args.get('regexp', None)\n    follow = self._task.args.get('follow', False)\n    ignore_hidden = self._task.args.get('ignore_hidden', False)\n    decrypt = self._task.args.pop('decrypt', True)\n    try:\n        if src is None or dest is None:\n            raise AnsibleActionFail('src and dest are required')\n        if boolean(remote_src, strict=False):\n            result.update(self._execute_module(module_name='ansible.legacy.assemble', task_vars=task_vars))\n            raise _AnsibleActionDone()\n        else:\n            try:\n                src = self._find_needle('files', src)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_native(e))\n        if not os.path.isdir(src):\n            raise AnsibleActionFail(u'Source (%s) is not a directory' % src)\n        _re = None\n        if regexp is not None:\n            _re = re.compile(regexp)\n        path = self._assemble_from_fragments(src, delimiter, _re, ignore_hidden, decrypt)\n        path_checksum = checksum_s(path)\n        dest = self._remote_expand_user(dest)\n        dest_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=follow)\n        diff = {}\n        new_module_args = self._task.args.copy()\n        for opt in ['remote_src', 'regexp', 'delimiter', 'ignore_hidden', 'decrypt']:\n            if opt in new_module_args:\n                del new_module_args[opt]\n        new_module_args['dest'] = dest\n        if path_checksum != dest_stat['checksum']:\n            if self._play_context.diff:\n                diff = self._get_diff_data(dest, path, task_vars)\n            remote_path = self._connection._shell.join_path(self._connection._shell.tmpdir, 'src')\n            xfered = self._transfer_file(path, remote_path)\n            self._fixup_perms2((self._connection._shell.tmpdir, remote_path))\n            new_module_args.update(dict(src=xfered))\n            res = self._execute_module(module_name='ansible.legacy.copy', module_args=new_module_args, task_vars=task_vars)\n            if diff:\n                res['diff'] = diff\n            result.update(res)\n        else:\n            result.update(self._execute_module(module_name='ansible.legacy.file', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._supports_check_mode = False\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    if task_vars is None:\n        task_vars = dict()\n    src = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    delimiter = self._task.args.get('delimiter', None)\n    remote_src = self._task.args.get('remote_src', 'yes')\n    regexp = self._task.args.get('regexp', None)\n    follow = self._task.args.get('follow', False)\n    ignore_hidden = self._task.args.get('ignore_hidden', False)\n    decrypt = self._task.args.pop('decrypt', True)\n    try:\n        if src is None or dest is None:\n            raise AnsibleActionFail('src and dest are required')\n        if boolean(remote_src, strict=False):\n            result.update(self._execute_module(module_name='ansible.legacy.assemble', task_vars=task_vars))\n            raise _AnsibleActionDone()\n        else:\n            try:\n                src = self._find_needle('files', src)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_native(e))\n        if not os.path.isdir(src):\n            raise AnsibleActionFail(u'Source (%s) is not a directory' % src)\n        _re = None\n        if regexp is not None:\n            _re = re.compile(regexp)\n        path = self._assemble_from_fragments(src, delimiter, _re, ignore_hidden, decrypt)\n        path_checksum = checksum_s(path)\n        dest = self._remote_expand_user(dest)\n        dest_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=follow)\n        diff = {}\n        new_module_args = self._task.args.copy()\n        for opt in ['remote_src', 'regexp', 'delimiter', 'ignore_hidden', 'decrypt']:\n            if opt in new_module_args:\n                del new_module_args[opt]\n        new_module_args['dest'] = dest\n        if path_checksum != dest_stat['checksum']:\n            if self._play_context.diff:\n                diff = self._get_diff_data(dest, path, task_vars)\n            remote_path = self._connection._shell.join_path(self._connection._shell.tmpdir, 'src')\n            xfered = self._transfer_file(path, remote_path)\n            self._fixup_perms2((self._connection._shell.tmpdir, remote_path))\n            new_module_args.update(dict(src=xfered))\n            res = self._execute_module(module_name='ansible.legacy.copy', module_args=new_module_args, task_vars=task_vars)\n            if diff:\n                res['diff'] = diff\n            result.update(res)\n        else:\n            result.update(self._execute_module(module_name='ansible.legacy.file', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result"
        ]
    }
]