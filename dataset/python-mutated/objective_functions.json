[
    {
        "func_name": "_objective_value",
        "original": "def _objective_value(w, obj):\n    \"\"\"\n    Helper method to return either the value of the objective function\n    or the objective function as a cvxpy object depending on whether\n    w is a cvxpy variable or np array.\n\n    :param w: weights\n    :type w: np.ndarray OR cp.Variable\n    :param obj: objective function expression\n    :type obj: cp.Expression\n    :return: value of the objective function OR objective function expression\n    :rtype: float OR cp.Expression\n    \"\"\"\n    if isinstance(w, np.ndarray):\n        if np.isscalar(obj):\n            return obj\n        elif np.isscalar(obj.value):\n            return obj.value\n        else:\n            return obj.value.item()\n    else:\n        return obj",
        "mutated": [
            "def _objective_value(w, obj):\n    if False:\n        i = 10\n    '\\n    Helper method to return either the value of the objective function\\n    or the objective function as a cvxpy object depending on whether\\n    w is a cvxpy variable or np array.\\n\\n    :param w: weights\\n    :type w: np.ndarray OR cp.Variable\\n    :param obj: objective function expression\\n    :type obj: cp.Expression\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if isinstance(w, np.ndarray):\n        if np.isscalar(obj):\n            return obj\n        elif np.isscalar(obj.value):\n            return obj.value\n        else:\n            return obj.value.item()\n    else:\n        return obj",
            "def _objective_value(w, obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper method to return either the value of the objective function\\n    or the objective function as a cvxpy object depending on whether\\n    w is a cvxpy variable or np array.\\n\\n    :param w: weights\\n    :type w: np.ndarray OR cp.Variable\\n    :param obj: objective function expression\\n    :type obj: cp.Expression\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if isinstance(w, np.ndarray):\n        if np.isscalar(obj):\n            return obj\n        elif np.isscalar(obj.value):\n            return obj.value\n        else:\n            return obj.value.item()\n    else:\n        return obj",
            "def _objective_value(w, obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper method to return either the value of the objective function\\n    or the objective function as a cvxpy object depending on whether\\n    w is a cvxpy variable or np array.\\n\\n    :param w: weights\\n    :type w: np.ndarray OR cp.Variable\\n    :param obj: objective function expression\\n    :type obj: cp.Expression\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if isinstance(w, np.ndarray):\n        if np.isscalar(obj):\n            return obj\n        elif np.isscalar(obj.value):\n            return obj.value\n        else:\n            return obj.value.item()\n    else:\n        return obj",
            "def _objective_value(w, obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper method to return either the value of the objective function\\n    or the objective function as a cvxpy object depending on whether\\n    w is a cvxpy variable or np array.\\n\\n    :param w: weights\\n    :type w: np.ndarray OR cp.Variable\\n    :param obj: objective function expression\\n    :type obj: cp.Expression\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if isinstance(w, np.ndarray):\n        if np.isscalar(obj):\n            return obj\n        elif np.isscalar(obj.value):\n            return obj.value\n        else:\n            return obj.value.item()\n    else:\n        return obj",
            "def _objective_value(w, obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper method to return either the value of the objective function\\n    or the objective function as a cvxpy object depending on whether\\n    w is a cvxpy variable or np array.\\n\\n    :param w: weights\\n    :type w: np.ndarray OR cp.Variable\\n    :param obj: objective function expression\\n    :type obj: cp.Expression\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if isinstance(w, np.ndarray):\n        if np.isscalar(obj):\n            return obj\n        elif np.isscalar(obj.value):\n            return obj.value\n        else:\n            return obj.value.item()\n    else:\n        return obj"
        ]
    },
    {
        "func_name": "portfolio_variance",
        "original": "def portfolio_variance(w, cov_matrix):\n    \"\"\"\n    Calculate the total portfolio variance (i.e square volatility).\n\n    :param w: asset weights in the portfolio\n    :type w: np.ndarray OR cp.Variable\n    :param cov_matrix: covariance matrix\n    :type cov_matrix: np.ndarray\n    :return: value of the objective function OR objective function expression\n    :rtype: float OR cp.Expression\n    \"\"\"\n    variance = cp.quad_form(w, cov_matrix)\n    return _objective_value(w, variance)",
        "mutated": [
            "def portfolio_variance(w, cov_matrix):\n    if False:\n        i = 10\n    '\\n    Calculate the total portfolio variance (i.e square volatility).\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    variance = cp.quad_form(w, cov_matrix)\n    return _objective_value(w, variance)",
            "def portfolio_variance(w, cov_matrix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the total portfolio variance (i.e square volatility).\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    variance = cp.quad_form(w, cov_matrix)\n    return _objective_value(w, variance)",
            "def portfolio_variance(w, cov_matrix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the total portfolio variance (i.e square volatility).\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    variance = cp.quad_form(w, cov_matrix)\n    return _objective_value(w, variance)",
            "def portfolio_variance(w, cov_matrix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the total portfolio variance (i.e square volatility).\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    variance = cp.quad_form(w, cov_matrix)\n    return _objective_value(w, variance)",
            "def portfolio_variance(w, cov_matrix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the total portfolio variance (i.e square volatility).\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    variance = cp.quad_form(w, cov_matrix)\n    return _objective_value(w, variance)"
        ]
    },
    {
        "func_name": "portfolio_return",
        "original": "def portfolio_return(w, expected_returns, negative=True):\n    \"\"\"\n    Calculate the (negative) mean return of a portfolio\n\n    :param w: asset weights in the portfolio\n    :type w: np.ndarray OR cp.Variable\n    :param expected_returns: expected return of each asset\n    :type expected_returns: np.ndarray\n    :param negative: whether quantity should be made negative (so we can minimise)\n    :type negative: boolean\n    :return: negative mean return\n    :rtype: float\n    \"\"\"\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    return _objective_value(w, sign * mu)",
        "mutated": [
            "def portfolio_return(w, expected_returns, negative=True):\n    if False:\n        i = 10\n    '\\n    Calculate the (negative) mean return of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: negative mean return\\n    :rtype: float\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    return _objective_value(w, sign * mu)",
            "def portfolio_return(w, expected_returns, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the (negative) mean return of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: negative mean return\\n    :rtype: float\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    return _objective_value(w, sign * mu)",
            "def portfolio_return(w, expected_returns, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the (negative) mean return of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: negative mean return\\n    :rtype: float\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    return _objective_value(w, sign * mu)",
            "def portfolio_return(w, expected_returns, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the (negative) mean return of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: negative mean return\\n    :rtype: float\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    return _objective_value(w, sign * mu)",
            "def portfolio_return(w, expected_returns, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the (negative) mean return of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: negative mean return\\n    :rtype: float\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    return _objective_value(w, sign * mu)"
        ]
    },
    {
        "func_name": "sharpe_ratio",
        "original": "def sharpe_ratio(w, expected_returns, cov_matrix, risk_free_rate=0.02, negative=True):\n    \"\"\"\n    Calculate the (negative) Sharpe ratio of a portfolio\n\n    :param w: asset weights in the portfolio\n    :type w: np.ndarray OR cp.Variable\n    :param expected_returns: expected return of each asset\n    :type expected_returns: np.ndarray\n    :param cov_matrix: covariance matrix\n    :type cov_matrix: np.ndarray\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\n                           The period of the risk-free rate should correspond to the\n                           frequency of expected returns.\n    :type risk_free_rate: float, optional\n    :param negative: whether quantity should be made negative (so we can minimise)\n    :type negative: boolean\n    :return: (negative) Sharpe ratio\n    :rtype: float\n    \"\"\"\n    mu = w @ expected_returns\n    sigma = cp.sqrt(cp.quad_form(w, cov_matrix))\n    sign = -1 if negative else 1\n    sharpe = (mu - risk_free_rate) / sigma\n    return _objective_value(w, sign * sharpe)",
        "mutated": [
            "def sharpe_ratio(w, expected_returns, cov_matrix, risk_free_rate=0.02, negative=True):\n    if False:\n        i = 10\n    '\\n    Calculate the (negative) Sharpe ratio of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           The period of the risk-free rate should correspond to the\\n                           frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: (negative) Sharpe ratio\\n    :rtype: float\\n    '\n    mu = w @ expected_returns\n    sigma = cp.sqrt(cp.quad_form(w, cov_matrix))\n    sign = -1 if negative else 1\n    sharpe = (mu - risk_free_rate) / sigma\n    return _objective_value(w, sign * sharpe)",
            "def sharpe_ratio(w, expected_returns, cov_matrix, risk_free_rate=0.02, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the (negative) Sharpe ratio of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           The period of the risk-free rate should correspond to the\\n                           frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: (negative) Sharpe ratio\\n    :rtype: float\\n    '\n    mu = w @ expected_returns\n    sigma = cp.sqrt(cp.quad_form(w, cov_matrix))\n    sign = -1 if negative else 1\n    sharpe = (mu - risk_free_rate) / sigma\n    return _objective_value(w, sign * sharpe)",
            "def sharpe_ratio(w, expected_returns, cov_matrix, risk_free_rate=0.02, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the (negative) Sharpe ratio of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           The period of the risk-free rate should correspond to the\\n                           frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: (negative) Sharpe ratio\\n    :rtype: float\\n    '\n    mu = w @ expected_returns\n    sigma = cp.sqrt(cp.quad_form(w, cov_matrix))\n    sign = -1 if negative else 1\n    sharpe = (mu - risk_free_rate) / sigma\n    return _objective_value(w, sign * sharpe)",
            "def sharpe_ratio(w, expected_returns, cov_matrix, risk_free_rate=0.02, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the (negative) Sharpe ratio of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           The period of the risk-free rate should correspond to the\\n                           frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: (negative) Sharpe ratio\\n    :rtype: float\\n    '\n    mu = w @ expected_returns\n    sigma = cp.sqrt(cp.quad_form(w, cov_matrix))\n    sign = -1 if negative else 1\n    sharpe = (mu - risk_free_rate) / sigma\n    return _objective_value(w, sign * sharpe)",
            "def sharpe_ratio(w, expected_returns, cov_matrix, risk_free_rate=0.02, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the (negative) Sharpe ratio of a portfolio\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_free_rate: risk-free rate of borrowing/lending, defaults to 0.02.\\n                           The period of the risk-free rate should correspond to the\\n                           frequency of expected returns.\\n    :type risk_free_rate: float, optional\\n    :param negative: whether quantity should be made negative (so we can minimise)\\n    :type negative: boolean\\n    :return: (negative) Sharpe ratio\\n    :rtype: float\\n    '\n    mu = w @ expected_returns\n    sigma = cp.sqrt(cp.quad_form(w, cov_matrix))\n    sign = -1 if negative else 1\n    sharpe = (mu - risk_free_rate) / sigma\n    return _objective_value(w, sign * sharpe)"
        ]
    },
    {
        "func_name": "L2_reg",
        "original": "def L2_reg(w, gamma=1):\n    \"\"\"\n    L2 regularisation, i.e :math:`\\\\gamma ||w||^2`, to increase the number of nonzero weights.\n\n    Example::\n\n        ef = EfficientFrontier(mu, S)\n        ef.add_objective(objective_functions.L2_reg, gamma=2)\n        ef.min_volatility()\n\n    :param w: asset weights in the portfolio\n    :type w: np.ndarray OR cp.Variable\n    :param gamma: L2 regularisation parameter, defaults to 1. Increase if you want more\n                    non-negligible weights\n    :type gamma: float, optional\n    :return: value of the objective function OR objective function expression\n    :rtype: float OR cp.Expression\n    \"\"\"\n    L2_reg = gamma * cp.sum_squares(w)\n    return _objective_value(w, L2_reg)",
        "mutated": [
            "def L2_reg(w, gamma=1):\n    if False:\n        i = 10\n    '\\n    L2 regularisation, i.e :math:`\\\\gamma ||w||^2`, to increase the number of nonzero weights.\\n\\n    Example::\\n\\n        ef = EfficientFrontier(mu, S)\\n        ef.add_objective(objective_functions.L2_reg, gamma=2)\\n        ef.min_volatility()\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param gamma: L2 regularisation parameter, defaults to 1. Increase if you want more\\n                    non-negligible weights\\n    :type gamma: float, optional\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    L2_reg = gamma * cp.sum_squares(w)\n    return _objective_value(w, L2_reg)",
            "def L2_reg(w, gamma=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    L2 regularisation, i.e :math:`\\\\gamma ||w||^2`, to increase the number of nonzero weights.\\n\\n    Example::\\n\\n        ef = EfficientFrontier(mu, S)\\n        ef.add_objective(objective_functions.L2_reg, gamma=2)\\n        ef.min_volatility()\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param gamma: L2 regularisation parameter, defaults to 1. Increase if you want more\\n                    non-negligible weights\\n    :type gamma: float, optional\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    L2_reg = gamma * cp.sum_squares(w)\n    return _objective_value(w, L2_reg)",
            "def L2_reg(w, gamma=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    L2 regularisation, i.e :math:`\\\\gamma ||w||^2`, to increase the number of nonzero weights.\\n\\n    Example::\\n\\n        ef = EfficientFrontier(mu, S)\\n        ef.add_objective(objective_functions.L2_reg, gamma=2)\\n        ef.min_volatility()\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param gamma: L2 regularisation parameter, defaults to 1. Increase if you want more\\n                    non-negligible weights\\n    :type gamma: float, optional\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    L2_reg = gamma * cp.sum_squares(w)\n    return _objective_value(w, L2_reg)",
            "def L2_reg(w, gamma=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    L2 regularisation, i.e :math:`\\\\gamma ||w||^2`, to increase the number of nonzero weights.\\n\\n    Example::\\n\\n        ef = EfficientFrontier(mu, S)\\n        ef.add_objective(objective_functions.L2_reg, gamma=2)\\n        ef.min_volatility()\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param gamma: L2 regularisation parameter, defaults to 1. Increase if you want more\\n                    non-negligible weights\\n    :type gamma: float, optional\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    L2_reg = gamma * cp.sum_squares(w)\n    return _objective_value(w, L2_reg)",
            "def L2_reg(w, gamma=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    L2 regularisation, i.e :math:`\\\\gamma ||w||^2`, to increase the number of nonzero weights.\\n\\n    Example::\\n\\n        ef = EfficientFrontier(mu, S)\\n        ef.add_objective(objective_functions.L2_reg, gamma=2)\\n        ef.min_volatility()\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param gamma: L2 regularisation parameter, defaults to 1. Increase if you want more\\n                    non-negligible weights\\n    :type gamma: float, optional\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    L2_reg = gamma * cp.sum_squares(w)\n    return _objective_value(w, L2_reg)"
        ]
    },
    {
        "func_name": "quadratic_utility",
        "original": "def quadratic_utility(w, expected_returns, cov_matrix, risk_aversion, negative=True):\n    \"\"\"\n    Quadratic utility function, i.e :math:`\\\\mu - \\\\frac 1 2 \\\\delta  w^T \\\\Sigma w`.\n\n    :param w: asset weights in the portfolio\n    :type w: np.ndarray OR cp.Variable\n    :param expected_returns: expected return of each asset\n    :type expected_returns: np.ndarray\n    :param cov_matrix: covariance matrix\n    :type cov_matrix: np.ndarray\n    :param risk_aversion: risk aversion coefficient. Increase to reduce risk.\n    :type risk_aversion: float\n    :param negative: whether quantity should be made negative (so we can minimise).\n    :type negative: boolean\n    :return: value of the objective function OR objective function expression\n    :rtype: float OR cp.Expression\n    \"\"\"\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    variance = cp.quad_form(w, cov_matrix)\n    risk_aversion_par = cp.Parameter(value=risk_aversion, name='risk_aversion', nonneg=True)\n    utility = mu - 0.5 * risk_aversion_par * variance\n    return _objective_value(w, sign * utility)",
        "mutated": [
            "def quadratic_utility(w, expected_returns, cov_matrix, risk_aversion, negative=True):\n    if False:\n        i = 10\n    '\\n    Quadratic utility function, i.e :math:`\\\\mu - \\\\frac 1 2 \\\\delta  w^T \\\\Sigma w`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_aversion: risk aversion coefficient. Increase to reduce risk.\\n    :type risk_aversion: float\\n    :param negative: whether quantity should be made negative (so we can minimise).\\n    :type negative: boolean\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    variance = cp.quad_form(w, cov_matrix)\n    risk_aversion_par = cp.Parameter(value=risk_aversion, name='risk_aversion', nonneg=True)\n    utility = mu - 0.5 * risk_aversion_par * variance\n    return _objective_value(w, sign * utility)",
            "def quadratic_utility(w, expected_returns, cov_matrix, risk_aversion, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Quadratic utility function, i.e :math:`\\\\mu - \\\\frac 1 2 \\\\delta  w^T \\\\Sigma w`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_aversion: risk aversion coefficient. Increase to reduce risk.\\n    :type risk_aversion: float\\n    :param negative: whether quantity should be made negative (so we can minimise).\\n    :type negative: boolean\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    variance = cp.quad_form(w, cov_matrix)\n    risk_aversion_par = cp.Parameter(value=risk_aversion, name='risk_aversion', nonneg=True)\n    utility = mu - 0.5 * risk_aversion_par * variance\n    return _objective_value(w, sign * utility)",
            "def quadratic_utility(w, expected_returns, cov_matrix, risk_aversion, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Quadratic utility function, i.e :math:`\\\\mu - \\\\frac 1 2 \\\\delta  w^T \\\\Sigma w`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_aversion: risk aversion coefficient. Increase to reduce risk.\\n    :type risk_aversion: float\\n    :param negative: whether quantity should be made negative (so we can minimise).\\n    :type negative: boolean\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    variance = cp.quad_form(w, cov_matrix)\n    risk_aversion_par = cp.Parameter(value=risk_aversion, name='risk_aversion', nonneg=True)\n    utility = mu - 0.5 * risk_aversion_par * variance\n    return _objective_value(w, sign * utility)",
            "def quadratic_utility(w, expected_returns, cov_matrix, risk_aversion, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Quadratic utility function, i.e :math:`\\\\mu - \\\\frac 1 2 \\\\delta  w^T \\\\Sigma w`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_aversion: risk aversion coefficient. Increase to reduce risk.\\n    :type risk_aversion: float\\n    :param negative: whether quantity should be made negative (so we can minimise).\\n    :type negative: boolean\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    variance = cp.quad_form(w, cov_matrix)\n    risk_aversion_par = cp.Parameter(value=risk_aversion, name='risk_aversion', nonneg=True)\n    utility = mu - 0.5 * risk_aversion_par * variance\n    return _objective_value(w, sign * utility)",
            "def quadratic_utility(w, expected_returns, cov_matrix, risk_aversion, negative=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Quadratic utility function, i.e :math:`\\\\mu - \\\\frac 1 2 \\\\delta  w^T \\\\Sigma w`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param expected_returns: expected return of each asset\\n    :type expected_returns: np.ndarray\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param risk_aversion: risk aversion coefficient. Increase to reduce risk.\\n    :type risk_aversion: float\\n    :param negative: whether quantity should be made negative (so we can minimise).\\n    :type negative: boolean\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    sign = -1 if negative else 1\n    mu = w @ expected_returns\n    variance = cp.quad_form(w, cov_matrix)\n    risk_aversion_par = cp.Parameter(value=risk_aversion, name='risk_aversion', nonneg=True)\n    utility = mu - 0.5 * risk_aversion_par * variance\n    return _objective_value(w, sign * utility)"
        ]
    },
    {
        "func_name": "transaction_cost",
        "original": "def transaction_cost(w, w_prev, k=0.001):\n    \"\"\"\n    A very simple transaction cost model: sum all the weight changes\n    and multiply by a given fraction (default to 10bps). This simulates\n    a fixed percentage commission from your broker.\n\n    :param w: asset weights in the portfolio\n    :type w: np.ndarray OR cp.Variable\n    :param w_prev: previous weights\n    :type w_prev: np.ndarray\n    :param k: fractional cost per unit weight exchanged\n    :type k: float\n    :return: value of the objective function OR objective function expression\n    :rtype: float OR cp.Expression\n    \"\"\"\n    return _objective_value(w, k * cp.norm(w - w_prev, 1))",
        "mutated": [
            "def transaction_cost(w, w_prev, k=0.001):\n    if False:\n        i = 10\n    '\\n    A very simple transaction cost model: sum all the weight changes\\n    and multiply by a given fraction (default to 10bps). This simulates\\n    a fixed percentage commission from your broker.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param w_prev: previous weights\\n    :type w_prev: np.ndarray\\n    :param k: fractional cost per unit weight exchanged\\n    :type k: float\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    return _objective_value(w, k * cp.norm(w - w_prev, 1))",
            "def transaction_cost(w, w_prev, k=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A very simple transaction cost model: sum all the weight changes\\n    and multiply by a given fraction (default to 10bps). This simulates\\n    a fixed percentage commission from your broker.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param w_prev: previous weights\\n    :type w_prev: np.ndarray\\n    :param k: fractional cost per unit weight exchanged\\n    :type k: float\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    return _objective_value(w, k * cp.norm(w - w_prev, 1))",
            "def transaction_cost(w, w_prev, k=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A very simple transaction cost model: sum all the weight changes\\n    and multiply by a given fraction (default to 10bps). This simulates\\n    a fixed percentage commission from your broker.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param w_prev: previous weights\\n    :type w_prev: np.ndarray\\n    :param k: fractional cost per unit weight exchanged\\n    :type k: float\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    return _objective_value(w, k * cp.norm(w - w_prev, 1))",
            "def transaction_cost(w, w_prev, k=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A very simple transaction cost model: sum all the weight changes\\n    and multiply by a given fraction (default to 10bps). This simulates\\n    a fixed percentage commission from your broker.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param w_prev: previous weights\\n    :type w_prev: np.ndarray\\n    :param k: fractional cost per unit weight exchanged\\n    :type k: float\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    return _objective_value(w, k * cp.norm(w - w_prev, 1))",
            "def transaction_cost(w, w_prev, k=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A very simple transaction cost model: sum all the weight changes\\n    and multiply by a given fraction (default to 10bps). This simulates\\n    a fixed percentage commission from your broker.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param w_prev: previous weights\\n    :type w_prev: np.ndarray\\n    :param k: fractional cost per unit weight exchanged\\n    :type k: float\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    return _objective_value(w, k * cp.norm(w - w_prev, 1))"
        ]
    },
    {
        "func_name": "ex_ante_tracking_error",
        "original": "def ex_ante_tracking_error(w, cov_matrix, benchmark_weights):\n    \"\"\"\n    Calculate the (square of) the ex-ante Tracking Error, i.e\n    :math:`(w - w_b)^T \\\\Sigma (w-w_b)`.\n\n    :param w: asset weights in the portfolio\n    :type w: np.ndarray OR cp.Variable\n    :param cov_matrix: covariance matrix\n    :type cov_matrix: np.ndarray\n    :param benchmark_weights: asset weights in the benchmark\n    :type benchmark_weights: np.ndarray\n    :return: value of the objective function OR objective function expression\n    :rtype: float OR cp.Expression\n    \"\"\"\n    relative_weights = w - benchmark_weights\n    tracking_error = cp.quad_form(relative_weights, cov_matrix)\n    return _objective_value(w, tracking_error)",
        "mutated": [
            "def ex_ante_tracking_error(w, cov_matrix, benchmark_weights):\n    if False:\n        i = 10\n    '\\n    Calculate the (square of) the ex-ante Tracking Error, i.e\\n    :math:`(w - w_b)^T \\\\Sigma (w-w_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param benchmark_weights: asset weights in the benchmark\\n    :type benchmark_weights: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    relative_weights = w - benchmark_weights\n    tracking_error = cp.quad_form(relative_weights, cov_matrix)\n    return _objective_value(w, tracking_error)",
            "def ex_ante_tracking_error(w, cov_matrix, benchmark_weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the (square of) the ex-ante Tracking Error, i.e\\n    :math:`(w - w_b)^T \\\\Sigma (w-w_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param benchmark_weights: asset weights in the benchmark\\n    :type benchmark_weights: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    relative_weights = w - benchmark_weights\n    tracking_error = cp.quad_form(relative_weights, cov_matrix)\n    return _objective_value(w, tracking_error)",
            "def ex_ante_tracking_error(w, cov_matrix, benchmark_weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the (square of) the ex-ante Tracking Error, i.e\\n    :math:`(w - w_b)^T \\\\Sigma (w-w_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param benchmark_weights: asset weights in the benchmark\\n    :type benchmark_weights: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    relative_weights = w - benchmark_weights\n    tracking_error = cp.quad_form(relative_weights, cov_matrix)\n    return _objective_value(w, tracking_error)",
            "def ex_ante_tracking_error(w, cov_matrix, benchmark_weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the (square of) the ex-ante Tracking Error, i.e\\n    :math:`(w - w_b)^T \\\\Sigma (w-w_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param benchmark_weights: asset weights in the benchmark\\n    :type benchmark_weights: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    relative_weights = w - benchmark_weights\n    tracking_error = cp.quad_form(relative_weights, cov_matrix)\n    return _objective_value(w, tracking_error)",
            "def ex_ante_tracking_error(w, cov_matrix, benchmark_weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the (square of) the ex-ante Tracking Error, i.e\\n    :math:`(w - w_b)^T \\\\Sigma (w-w_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param cov_matrix: covariance matrix\\n    :type cov_matrix: np.ndarray\\n    :param benchmark_weights: asset weights in the benchmark\\n    :type benchmark_weights: np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    relative_weights = w - benchmark_weights\n    tracking_error = cp.quad_form(relative_weights, cov_matrix)\n    return _objective_value(w, tracking_error)"
        ]
    },
    {
        "func_name": "ex_post_tracking_error",
        "original": "def ex_post_tracking_error(w, historic_returns, benchmark_returns):\n    \"\"\"\n    Calculate the (square of) the ex-post Tracking Error, i.e :math:`Var(r - r_b)`.\n\n    :param w: asset weights in the portfolio\n    :type w: np.ndarray OR cp.Variable\n    :param historic_returns: historic asset returns\n    :type historic_returns: np.ndarray\n    :param benchmark_returns: historic benchmark returns\n    :type benchmark_returns: pd.Series or np.ndarray\n    :return: value of the objective function OR objective function expression\n    :rtype: float OR cp.Expression\n    \"\"\"\n    if not isinstance(historic_returns, np.ndarray):\n        historic_returns = np.array(historic_returns)\n    if not isinstance(benchmark_returns, np.ndarray):\n        benchmark_returns = np.array(benchmark_returns)\n    x_i = w @ historic_returns.T - benchmark_returns\n    mean = cp.sum(x_i) / len(benchmark_returns)\n    tracking_error = cp.sum_squares(x_i - mean)\n    return _objective_value(w, tracking_error)",
        "mutated": [
            "def ex_post_tracking_error(w, historic_returns, benchmark_returns):\n    if False:\n        i = 10\n    '\\n    Calculate the (square of) the ex-post Tracking Error, i.e :math:`Var(r - r_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param historic_returns: historic asset returns\\n    :type historic_returns: np.ndarray\\n    :param benchmark_returns: historic benchmark returns\\n    :type benchmark_returns: pd.Series or np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if not isinstance(historic_returns, np.ndarray):\n        historic_returns = np.array(historic_returns)\n    if not isinstance(benchmark_returns, np.ndarray):\n        benchmark_returns = np.array(benchmark_returns)\n    x_i = w @ historic_returns.T - benchmark_returns\n    mean = cp.sum(x_i) / len(benchmark_returns)\n    tracking_error = cp.sum_squares(x_i - mean)\n    return _objective_value(w, tracking_error)",
            "def ex_post_tracking_error(w, historic_returns, benchmark_returns):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the (square of) the ex-post Tracking Error, i.e :math:`Var(r - r_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param historic_returns: historic asset returns\\n    :type historic_returns: np.ndarray\\n    :param benchmark_returns: historic benchmark returns\\n    :type benchmark_returns: pd.Series or np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if not isinstance(historic_returns, np.ndarray):\n        historic_returns = np.array(historic_returns)\n    if not isinstance(benchmark_returns, np.ndarray):\n        benchmark_returns = np.array(benchmark_returns)\n    x_i = w @ historic_returns.T - benchmark_returns\n    mean = cp.sum(x_i) / len(benchmark_returns)\n    tracking_error = cp.sum_squares(x_i - mean)\n    return _objective_value(w, tracking_error)",
            "def ex_post_tracking_error(w, historic_returns, benchmark_returns):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the (square of) the ex-post Tracking Error, i.e :math:`Var(r - r_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param historic_returns: historic asset returns\\n    :type historic_returns: np.ndarray\\n    :param benchmark_returns: historic benchmark returns\\n    :type benchmark_returns: pd.Series or np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if not isinstance(historic_returns, np.ndarray):\n        historic_returns = np.array(historic_returns)\n    if not isinstance(benchmark_returns, np.ndarray):\n        benchmark_returns = np.array(benchmark_returns)\n    x_i = w @ historic_returns.T - benchmark_returns\n    mean = cp.sum(x_i) / len(benchmark_returns)\n    tracking_error = cp.sum_squares(x_i - mean)\n    return _objective_value(w, tracking_error)",
            "def ex_post_tracking_error(w, historic_returns, benchmark_returns):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the (square of) the ex-post Tracking Error, i.e :math:`Var(r - r_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param historic_returns: historic asset returns\\n    :type historic_returns: np.ndarray\\n    :param benchmark_returns: historic benchmark returns\\n    :type benchmark_returns: pd.Series or np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if not isinstance(historic_returns, np.ndarray):\n        historic_returns = np.array(historic_returns)\n    if not isinstance(benchmark_returns, np.ndarray):\n        benchmark_returns = np.array(benchmark_returns)\n    x_i = w @ historic_returns.T - benchmark_returns\n    mean = cp.sum(x_i) / len(benchmark_returns)\n    tracking_error = cp.sum_squares(x_i - mean)\n    return _objective_value(w, tracking_error)",
            "def ex_post_tracking_error(w, historic_returns, benchmark_returns):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the (square of) the ex-post Tracking Error, i.e :math:`Var(r - r_b)`.\\n\\n    :param w: asset weights in the portfolio\\n    :type w: np.ndarray OR cp.Variable\\n    :param historic_returns: historic asset returns\\n    :type historic_returns: np.ndarray\\n    :param benchmark_returns: historic benchmark returns\\n    :type benchmark_returns: pd.Series or np.ndarray\\n    :return: value of the objective function OR objective function expression\\n    :rtype: float OR cp.Expression\\n    '\n    if not isinstance(historic_returns, np.ndarray):\n        historic_returns = np.array(historic_returns)\n    if not isinstance(benchmark_returns, np.ndarray):\n        benchmark_returns = np.array(benchmark_returns)\n    x_i = w @ historic_returns.T - benchmark_returns\n    mean = cp.sum(x_i) / len(benchmark_returns)\n    tracking_error = cp.sum_squares(x_i - mean)\n    return _objective_value(w, tracking_error)"
        ]
    }
]