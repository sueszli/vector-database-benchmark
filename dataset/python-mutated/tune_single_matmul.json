[
    {
        "func_name": "other_features_equal_to_best",
        "original": "def other_features_equal_to_best(t):\n    return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))",
        "mutated": [
            "def other_features_equal_to_best(t):\n    if False:\n        i = 10\n    return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))",
            "def other_features_equal_to_best(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))",
            "def other_features_equal_to_best(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))",
            "def other_features_equal_to_best(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))",
            "def other_features_equal_to_best(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))"
        ]
    },
    {
        "func_name": "main",
        "original": "def main() -> None:\n    dims = MatmulSize(M=_M.value, N=_N.value, K=_K.value, quantized_lhs=_QUANTIZED_LHS.value, quantized_rhs=_QUANTIZED_RHS.value)\n    s = torch.cuda.Stream()\n    tilings = generate_tiling_configs(parse_int_list(_TILINGS_M.value), parse_int_list(_TILINGS_N.value), parse_int_list(_TILINGS_K.value), parse_int_list(_SPLIT_KS.value), parse_layout_list(_LHS_LAYOUTS.value), parse_layout_list(_RHS_LAYOUTS.value), parse_layout_list(_RESULT_LAYOUTS.value), parse_int_list(_NUM_STAGES.value), parse_int_list(_NUM_WARPS.value))\n    pbar = tqdm.tqdm(total=len(tilings), ncols=0)\n    timings = sorted(benchmark_matmul(dims, pbar, s, tilings, repetitions_ms=300, debug=_DEBUG.value), key=lambda t: t.min_time_ms)\n    fastest: MatmulTiming = timings[0]\n    print(f'Fastest configuration: {fastest}')\n    features_list = ['BLOCK_M', 'BLOCK_N', 'BLOCK_K', 'SPLIT_K', 'lhs_layout', 'rhs_layout', 'result_layout', 'num_stages', 'num_warps']\n    features = frozenset(features_list)\n    for f in features:\n        other_features = features - {f}\n\n        def other_features_equal_to_best(t):\n            return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))\n        others_fixed = [t for t in timings if other_features_equal_to_best(t)]\n        print(f'Varying feature {f}:', ', '.join((f'{t.min_time_ms:0.4f} @ {f}={getattr(t.tiling, f)}' for t in others_fixed)))\n    print_roofline_performance(dims, fastest.min_time_ms)\n    cublas_time = benchmark_cublas(dims)\n    print(f'Reference cuBLAS time (bf16xbf16->bf16): {cublas_time:0.4f}ms')\n    if _APPEND_TO_CSV.value:\n        fields = ['M', 'N', 'K', 'quantized_lhs', 'quantized_rhs'] + features_list + ['min_time_ms', 'cublas_time_ms']\n        with open(_APPEND_TO_CSV.value, 'a') as f:\n            writer = csv.DictWriter(f, fieldnames=fields)\n            if f.tell() == 0:\n                writer.writeheader()\n            writer.writerow(dict(fastest.dims._asdict(), **fastest.tiling._asdict(), min_time_ms=fastest.min_time_ms, cublas_time_ms=cublas_time))",
        "mutated": [
            "def main() -> None:\n    if False:\n        i = 10\n    dims = MatmulSize(M=_M.value, N=_N.value, K=_K.value, quantized_lhs=_QUANTIZED_LHS.value, quantized_rhs=_QUANTIZED_RHS.value)\n    s = torch.cuda.Stream()\n    tilings = generate_tiling_configs(parse_int_list(_TILINGS_M.value), parse_int_list(_TILINGS_N.value), parse_int_list(_TILINGS_K.value), parse_int_list(_SPLIT_KS.value), parse_layout_list(_LHS_LAYOUTS.value), parse_layout_list(_RHS_LAYOUTS.value), parse_layout_list(_RESULT_LAYOUTS.value), parse_int_list(_NUM_STAGES.value), parse_int_list(_NUM_WARPS.value))\n    pbar = tqdm.tqdm(total=len(tilings), ncols=0)\n    timings = sorted(benchmark_matmul(dims, pbar, s, tilings, repetitions_ms=300, debug=_DEBUG.value), key=lambda t: t.min_time_ms)\n    fastest: MatmulTiming = timings[0]\n    print(f'Fastest configuration: {fastest}')\n    features_list = ['BLOCK_M', 'BLOCK_N', 'BLOCK_K', 'SPLIT_K', 'lhs_layout', 'rhs_layout', 'result_layout', 'num_stages', 'num_warps']\n    features = frozenset(features_list)\n    for f in features:\n        other_features = features - {f}\n\n        def other_features_equal_to_best(t):\n            return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))\n        others_fixed = [t for t in timings if other_features_equal_to_best(t)]\n        print(f'Varying feature {f}:', ', '.join((f'{t.min_time_ms:0.4f} @ {f}={getattr(t.tiling, f)}' for t in others_fixed)))\n    print_roofline_performance(dims, fastest.min_time_ms)\n    cublas_time = benchmark_cublas(dims)\n    print(f'Reference cuBLAS time (bf16xbf16->bf16): {cublas_time:0.4f}ms')\n    if _APPEND_TO_CSV.value:\n        fields = ['M', 'N', 'K', 'quantized_lhs', 'quantized_rhs'] + features_list + ['min_time_ms', 'cublas_time_ms']\n        with open(_APPEND_TO_CSV.value, 'a') as f:\n            writer = csv.DictWriter(f, fieldnames=fields)\n            if f.tell() == 0:\n                writer.writeheader()\n            writer.writerow(dict(fastest.dims._asdict(), **fastest.tiling._asdict(), min_time_ms=fastest.min_time_ms, cublas_time_ms=cublas_time))",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dims = MatmulSize(M=_M.value, N=_N.value, K=_K.value, quantized_lhs=_QUANTIZED_LHS.value, quantized_rhs=_QUANTIZED_RHS.value)\n    s = torch.cuda.Stream()\n    tilings = generate_tiling_configs(parse_int_list(_TILINGS_M.value), parse_int_list(_TILINGS_N.value), parse_int_list(_TILINGS_K.value), parse_int_list(_SPLIT_KS.value), parse_layout_list(_LHS_LAYOUTS.value), parse_layout_list(_RHS_LAYOUTS.value), parse_layout_list(_RESULT_LAYOUTS.value), parse_int_list(_NUM_STAGES.value), parse_int_list(_NUM_WARPS.value))\n    pbar = tqdm.tqdm(total=len(tilings), ncols=0)\n    timings = sorted(benchmark_matmul(dims, pbar, s, tilings, repetitions_ms=300, debug=_DEBUG.value), key=lambda t: t.min_time_ms)\n    fastest: MatmulTiming = timings[0]\n    print(f'Fastest configuration: {fastest}')\n    features_list = ['BLOCK_M', 'BLOCK_N', 'BLOCK_K', 'SPLIT_K', 'lhs_layout', 'rhs_layout', 'result_layout', 'num_stages', 'num_warps']\n    features = frozenset(features_list)\n    for f in features:\n        other_features = features - {f}\n\n        def other_features_equal_to_best(t):\n            return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))\n        others_fixed = [t for t in timings if other_features_equal_to_best(t)]\n        print(f'Varying feature {f}:', ', '.join((f'{t.min_time_ms:0.4f} @ {f}={getattr(t.tiling, f)}' for t in others_fixed)))\n    print_roofline_performance(dims, fastest.min_time_ms)\n    cublas_time = benchmark_cublas(dims)\n    print(f'Reference cuBLAS time (bf16xbf16->bf16): {cublas_time:0.4f}ms')\n    if _APPEND_TO_CSV.value:\n        fields = ['M', 'N', 'K', 'quantized_lhs', 'quantized_rhs'] + features_list + ['min_time_ms', 'cublas_time_ms']\n        with open(_APPEND_TO_CSV.value, 'a') as f:\n            writer = csv.DictWriter(f, fieldnames=fields)\n            if f.tell() == 0:\n                writer.writeheader()\n            writer.writerow(dict(fastest.dims._asdict(), **fastest.tiling._asdict(), min_time_ms=fastest.min_time_ms, cublas_time_ms=cublas_time))",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dims = MatmulSize(M=_M.value, N=_N.value, K=_K.value, quantized_lhs=_QUANTIZED_LHS.value, quantized_rhs=_QUANTIZED_RHS.value)\n    s = torch.cuda.Stream()\n    tilings = generate_tiling_configs(parse_int_list(_TILINGS_M.value), parse_int_list(_TILINGS_N.value), parse_int_list(_TILINGS_K.value), parse_int_list(_SPLIT_KS.value), parse_layout_list(_LHS_LAYOUTS.value), parse_layout_list(_RHS_LAYOUTS.value), parse_layout_list(_RESULT_LAYOUTS.value), parse_int_list(_NUM_STAGES.value), parse_int_list(_NUM_WARPS.value))\n    pbar = tqdm.tqdm(total=len(tilings), ncols=0)\n    timings = sorted(benchmark_matmul(dims, pbar, s, tilings, repetitions_ms=300, debug=_DEBUG.value), key=lambda t: t.min_time_ms)\n    fastest: MatmulTiming = timings[0]\n    print(f'Fastest configuration: {fastest}')\n    features_list = ['BLOCK_M', 'BLOCK_N', 'BLOCK_K', 'SPLIT_K', 'lhs_layout', 'rhs_layout', 'result_layout', 'num_stages', 'num_warps']\n    features = frozenset(features_list)\n    for f in features:\n        other_features = features - {f}\n\n        def other_features_equal_to_best(t):\n            return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))\n        others_fixed = [t for t in timings if other_features_equal_to_best(t)]\n        print(f'Varying feature {f}:', ', '.join((f'{t.min_time_ms:0.4f} @ {f}={getattr(t.tiling, f)}' for t in others_fixed)))\n    print_roofline_performance(dims, fastest.min_time_ms)\n    cublas_time = benchmark_cublas(dims)\n    print(f'Reference cuBLAS time (bf16xbf16->bf16): {cublas_time:0.4f}ms')\n    if _APPEND_TO_CSV.value:\n        fields = ['M', 'N', 'K', 'quantized_lhs', 'quantized_rhs'] + features_list + ['min_time_ms', 'cublas_time_ms']\n        with open(_APPEND_TO_CSV.value, 'a') as f:\n            writer = csv.DictWriter(f, fieldnames=fields)\n            if f.tell() == 0:\n                writer.writeheader()\n            writer.writerow(dict(fastest.dims._asdict(), **fastest.tiling._asdict(), min_time_ms=fastest.min_time_ms, cublas_time_ms=cublas_time))",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dims = MatmulSize(M=_M.value, N=_N.value, K=_K.value, quantized_lhs=_QUANTIZED_LHS.value, quantized_rhs=_QUANTIZED_RHS.value)\n    s = torch.cuda.Stream()\n    tilings = generate_tiling_configs(parse_int_list(_TILINGS_M.value), parse_int_list(_TILINGS_N.value), parse_int_list(_TILINGS_K.value), parse_int_list(_SPLIT_KS.value), parse_layout_list(_LHS_LAYOUTS.value), parse_layout_list(_RHS_LAYOUTS.value), parse_layout_list(_RESULT_LAYOUTS.value), parse_int_list(_NUM_STAGES.value), parse_int_list(_NUM_WARPS.value))\n    pbar = tqdm.tqdm(total=len(tilings), ncols=0)\n    timings = sorted(benchmark_matmul(dims, pbar, s, tilings, repetitions_ms=300, debug=_DEBUG.value), key=lambda t: t.min_time_ms)\n    fastest: MatmulTiming = timings[0]\n    print(f'Fastest configuration: {fastest}')\n    features_list = ['BLOCK_M', 'BLOCK_N', 'BLOCK_K', 'SPLIT_K', 'lhs_layout', 'rhs_layout', 'result_layout', 'num_stages', 'num_warps']\n    features = frozenset(features_list)\n    for f in features:\n        other_features = features - {f}\n\n        def other_features_equal_to_best(t):\n            return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))\n        others_fixed = [t for t in timings if other_features_equal_to_best(t)]\n        print(f'Varying feature {f}:', ', '.join((f'{t.min_time_ms:0.4f} @ {f}={getattr(t.tiling, f)}' for t in others_fixed)))\n    print_roofline_performance(dims, fastest.min_time_ms)\n    cublas_time = benchmark_cublas(dims)\n    print(f'Reference cuBLAS time (bf16xbf16->bf16): {cublas_time:0.4f}ms')\n    if _APPEND_TO_CSV.value:\n        fields = ['M', 'N', 'K', 'quantized_lhs', 'quantized_rhs'] + features_list + ['min_time_ms', 'cublas_time_ms']\n        with open(_APPEND_TO_CSV.value, 'a') as f:\n            writer = csv.DictWriter(f, fieldnames=fields)\n            if f.tell() == 0:\n                writer.writeheader()\n            writer.writerow(dict(fastest.dims._asdict(), **fastest.tiling._asdict(), min_time_ms=fastest.min_time_ms, cublas_time_ms=cublas_time))",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dims = MatmulSize(M=_M.value, N=_N.value, K=_K.value, quantized_lhs=_QUANTIZED_LHS.value, quantized_rhs=_QUANTIZED_RHS.value)\n    s = torch.cuda.Stream()\n    tilings = generate_tiling_configs(parse_int_list(_TILINGS_M.value), parse_int_list(_TILINGS_N.value), parse_int_list(_TILINGS_K.value), parse_int_list(_SPLIT_KS.value), parse_layout_list(_LHS_LAYOUTS.value), parse_layout_list(_RHS_LAYOUTS.value), parse_layout_list(_RESULT_LAYOUTS.value), parse_int_list(_NUM_STAGES.value), parse_int_list(_NUM_WARPS.value))\n    pbar = tqdm.tqdm(total=len(tilings), ncols=0)\n    timings = sorted(benchmark_matmul(dims, pbar, s, tilings, repetitions_ms=300, debug=_DEBUG.value), key=lambda t: t.min_time_ms)\n    fastest: MatmulTiming = timings[0]\n    print(f'Fastest configuration: {fastest}')\n    features_list = ['BLOCK_M', 'BLOCK_N', 'BLOCK_K', 'SPLIT_K', 'lhs_layout', 'rhs_layout', 'result_layout', 'num_stages', 'num_warps']\n    features = frozenset(features_list)\n    for f in features:\n        other_features = features - {f}\n\n        def other_features_equal_to_best(t):\n            return all((getattr(fastest.tiling, of) == getattr(t.tiling, of) for of in other_features))\n        others_fixed = [t for t in timings if other_features_equal_to_best(t)]\n        print(f'Varying feature {f}:', ', '.join((f'{t.min_time_ms:0.4f} @ {f}={getattr(t.tiling, f)}' for t in others_fixed)))\n    print_roofline_performance(dims, fastest.min_time_ms)\n    cublas_time = benchmark_cublas(dims)\n    print(f'Reference cuBLAS time (bf16xbf16->bf16): {cublas_time:0.4f}ms')\n    if _APPEND_TO_CSV.value:\n        fields = ['M', 'N', 'K', 'quantized_lhs', 'quantized_rhs'] + features_list + ['min_time_ms', 'cublas_time_ms']\n        with open(_APPEND_TO_CSV.value, 'a') as f:\n            writer = csv.DictWriter(f, fieldnames=fields)\n            if f.tell() == 0:\n                writer.writeheader()\n            writer.writerow(dict(fastest.dims._asdict(), **fastest.tiling._asdict(), min_time_ms=fastest.min_time_ms, cublas_time_ms=cublas_time))"
        ]
    }
]