[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\n    \"\"\"\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)"
        ]
    },
    {
        "func_name": "config",
        "original": "@proxy_napalm_wrap\ndef config(**kwargs):\n    \"\"\"\n    Returns the configuration of the users on the device\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' users.config\n\n    Output example:\n\n    .. code-block:: python\n\n        {\n            'mircea': {\n                'level': 15,\n                'password': '$1$0P70xKPa$4jt5/10cBTckk6I/w/',\n                'sshkeys': [\n                    'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4pFn+shPwTb2yELO4L7NtQrKOJXNeCl1je                    l9STXVaGnRAnuc2PXl35vnWmcUq6YbUEcgUTRzzXfmelJKuVJTJIlMXii7h2xkbQp0YZIEs4P                    8ipwnRBAxFfk/ZcDsN3mjep4/yjN56ejk345jhk345jk345jk341p3A/9LIL7l6YewLBCwJj6                    D+fWSJ0/YW+7oH17Fk2HH+tw0L5PcWLHkwA4t60iXn16qDbIk/ze6jv2hDGdCdz7oYQeCE55C                    CHOHMJWYfN3jcL4s0qv8/u6Ka1FVkV7iMmro7ChThoV/5snI4Ljf2wKqgHH7TfNaCfpU0WvHA                    nTs8zhOrGScSrtb mircea@master-roshi'\n                ]\n            }\n        }\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'get_users', **{})",
        "mutated": [
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns the configuration of the users on the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' users.config\\n\\n    Output example:\\n\\n    .. code-block:: python\\n\\n        {\\n            'mircea': {\\n                'level': 15,\\n                'password': '$1$0P70xKPa$4jt5/10cBTckk6I/w/',\\n                'sshkeys': [\\n                    'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4pFn+shPwTb2yELO4L7NtQrKOJXNeCl1je                    l9STXVaGnRAnuc2PXl35vnWmcUq6YbUEcgUTRzzXfmelJKuVJTJIlMXii7h2xkbQp0YZIEs4P                    8ipwnRBAxFfk/ZcDsN3mjep4/yjN56ejk345jhk345jk345jk341p3A/9LIL7l6YewLBCwJj6                    D+fWSJ0/YW+7oH17Fk2HH+tw0L5PcWLHkwA4t60iXn16qDbIk/ze6jv2hDGdCdz7oYQeCE55C                    CHOHMJWYfN3jcL4s0qv8/u6Ka1FVkV7iMmro7ChThoV/5snI4Ljf2wKqgHH7TfNaCfpU0WvHA                    nTs8zhOrGScSrtb mircea@master-roshi'\\n                ]\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_users', **{})",
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns the configuration of the users on the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' users.config\\n\\n    Output example:\\n\\n    .. code-block:: python\\n\\n        {\\n            'mircea': {\\n                'level': 15,\\n                'password': '$1$0P70xKPa$4jt5/10cBTckk6I/w/',\\n                'sshkeys': [\\n                    'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4pFn+shPwTb2yELO4L7NtQrKOJXNeCl1je                    l9STXVaGnRAnuc2PXl35vnWmcUq6YbUEcgUTRzzXfmelJKuVJTJIlMXii7h2xkbQp0YZIEs4P                    8ipwnRBAxFfk/ZcDsN3mjep4/yjN56ejk345jhk345jk345jk341p3A/9LIL7l6YewLBCwJj6                    D+fWSJ0/YW+7oH17Fk2HH+tw0L5PcWLHkwA4t60iXn16qDbIk/ze6jv2hDGdCdz7oYQeCE55C                    CHOHMJWYfN3jcL4s0qv8/u6Ka1FVkV7iMmro7ChThoV/5snI4Ljf2wKqgHH7TfNaCfpU0WvHA                    nTs8zhOrGScSrtb mircea@master-roshi'\\n                ]\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_users', **{})",
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns the configuration of the users on the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' users.config\\n\\n    Output example:\\n\\n    .. code-block:: python\\n\\n        {\\n            'mircea': {\\n                'level': 15,\\n                'password': '$1$0P70xKPa$4jt5/10cBTckk6I/w/',\\n                'sshkeys': [\\n                    'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4pFn+shPwTb2yELO4L7NtQrKOJXNeCl1je                    l9STXVaGnRAnuc2PXl35vnWmcUq6YbUEcgUTRzzXfmelJKuVJTJIlMXii7h2xkbQp0YZIEs4P                    8ipwnRBAxFfk/ZcDsN3mjep4/yjN56ejk345jhk345jk345jk341p3A/9LIL7l6YewLBCwJj6                    D+fWSJ0/YW+7oH17Fk2HH+tw0L5PcWLHkwA4t60iXn16qDbIk/ze6jv2hDGdCdz7oYQeCE55C                    CHOHMJWYfN3jcL4s0qv8/u6Ka1FVkV7iMmro7ChThoV/5snI4Ljf2wKqgHH7TfNaCfpU0WvHA                    nTs8zhOrGScSrtb mircea@master-roshi'\\n                ]\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_users', **{})",
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns the configuration of the users on the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' users.config\\n\\n    Output example:\\n\\n    .. code-block:: python\\n\\n        {\\n            'mircea': {\\n                'level': 15,\\n                'password': '$1$0P70xKPa$4jt5/10cBTckk6I/w/',\\n                'sshkeys': [\\n                    'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4pFn+shPwTb2yELO4L7NtQrKOJXNeCl1je                    l9STXVaGnRAnuc2PXl35vnWmcUq6YbUEcgUTRzzXfmelJKuVJTJIlMXii7h2xkbQp0YZIEs4P                    8ipwnRBAxFfk/ZcDsN3mjep4/yjN56ejk345jhk345jk345jk341p3A/9LIL7l6YewLBCwJj6                    D+fWSJ0/YW+7oH17Fk2HH+tw0L5PcWLHkwA4t60iXn16qDbIk/ze6jv2hDGdCdz7oYQeCE55C                    CHOHMJWYfN3jcL4s0qv8/u6Ka1FVkV7iMmro7ChThoV/5snI4Ljf2wKqgHH7TfNaCfpU0WvHA                    nTs8zhOrGScSrtb mircea@master-roshi'\\n                ]\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_users', **{})",
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns the configuration of the users on the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' users.config\\n\\n    Output example:\\n\\n    .. code-block:: python\\n\\n        {\\n            'mircea': {\\n                'level': 15,\\n                'password': '$1$0P70xKPa$4jt5/10cBTckk6I/w/',\\n                'sshkeys': [\\n                    'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4pFn+shPwTb2yELO4L7NtQrKOJXNeCl1je                    l9STXVaGnRAnuc2PXl35vnWmcUq6YbUEcgUTRzzXfmelJKuVJTJIlMXii7h2xkbQp0YZIEs4P                    8ipwnRBAxFfk/ZcDsN3mjep4/yjN56ejk345jhk345jk345jk341p3A/9LIL7l6YewLBCwJj6                    D+fWSJ0/YW+7oH17Fk2HH+tw0L5PcWLHkwA4t60iXn16qDbIk/ze6jv2hDGdCdz7oYQeCE55C                    CHOHMJWYfN3jcL4s0qv8/u6Ka1FVkV7iMmro7ChThoV/5snI4Ljf2wKqgHH7TfNaCfpU0WvHA                    nTs8zhOrGScSrtb mircea@master-roshi'\\n                ]\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_users', **{})"
        ]
    },
    {
        "func_name": "set_users",
        "original": "@proxy_napalm_wrap\ndef set_users(users, test=False, commit=True, **kwargs):\n    \"\"\"\n    Configures users on network devices.\n\n    :param users: Dictionary formatted as the output of the function config()\n\n    :param test: Dry run? If set as True, will apply the config, discard and\n        return the changes. Default: False\n\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\n        the config immediately after loading the changes. E.g.: a state loads a\n        couple of parts (add / remove / update) and would not be optimal to\n        commit after each operation.  Also, from the CLI when the user needs to\n        apply the similar changes before committing, can specify commit=False\n        and will not discard the config.\n\n    :raise MergeConfigException: If there is an error on the configuration sent.\n    :return a dictionary having the following keys:\n\n    - result (bool): if the config was applied successfully. It is `False` only\n      in case of failure. In case there are no changes to be applied and\n      successfully performs all operations it is still `True` and so will be\n      the `already_configured` flag (example below)\n    - comment (str): a message for the user\n    - already_configured (bool): flag to check if there were no changes applied\n    - diff (str): returns the config changes applied\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' users.set_users \"{'mircea': {}}\"\n    \"\"\"\n    return __salt__['net.load_template']('set_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
        "mutated": [
            "@proxy_napalm_wrap\ndef set_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n    '\\n    Configures users on network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and\\n        return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.set_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('set_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef set_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Configures users on network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and\\n        return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.set_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('set_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef set_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Configures users on network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and\\n        return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.set_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('set_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef set_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Configures users on network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and\\n        return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.set_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('set_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef set_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Configures users on network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and\\n        return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.set_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('set_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)"
        ]
    },
    {
        "func_name": "delete_users",
        "original": "@proxy_napalm_wrap\ndef delete_users(users, test=False, commit=True, **kwargs):\n    \"\"\"\n    Removes users from the configuration of network devices.\n\n    :param users: Dictionary formatted as the output of the function config()\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\n        and would not be optimal to commit after each operation.\n        Also, from the CLI when the user needs to apply the similar changes before committing,\n        can specify commit=False and will not discard the config.\n    :raise MergeConfigException: If there is an error on the configuration sent.\n    :return a dictionary having the following keys:\n        - result (bool): if the config was applied successfully. It is `False`\n          only in case of failure. In case there are no changes to be applied\n          and successfully performs all operations it is still `True` and so\n          will be the `already_configured` flag (example below)\n        - comment (str): a message for the user\n        - already_configured (bool): flag to check if there were no changes applied\n        - diff (str): returns the config changes applied\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' users.delete_users \"{'mircea': {}}\"\n    \"\"\"\n    return __salt__['net.load_template']('delete_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
        "mutated": [
            "@proxy_napalm_wrap\ndef delete_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n    '\\n    Removes users from the configuration of network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n        - result (bool): if the config was applied successfully. It is `False`\\n          only in case of failure. In case there are no changes to be applied\\n          and successfully performs all operations it is still `True` and so\\n          will be the `already_configured` flag (example below)\\n        - comment (str): a message for the user\\n        - already_configured (bool): flag to check if there were no changes applied\\n        - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.delete_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('delete_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef delete_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Removes users from the configuration of network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n        - result (bool): if the config was applied successfully. It is `False`\\n          only in case of failure. In case there are no changes to be applied\\n          and successfully performs all operations it is still `True` and so\\n          will be the `already_configured` flag (example below)\\n        - comment (str): a message for the user\\n        - already_configured (bool): flag to check if there were no changes applied\\n        - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.delete_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('delete_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef delete_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Removes users from the configuration of network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n        - result (bool): if the config was applied successfully. It is `False`\\n          only in case of failure. In case there are no changes to be applied\\n          and successfully performs all operations it is still `True` and so\\n          will be the `already_configured` flag (example below)\\n        - comment (str): a message for the user\\n        - already_configured (bool): flag to check if there were no changes applied\\n        - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.delete_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('delete_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef delete_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Removes users from the configuration of network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n        - result (bool): if the config was applied successfully. It is `False`\\n          only in case of failure. In case there are no changes to be applied\\n          and successfully performs all operations it is still `True` and so\\n          will be the `already_configured` flag (example below)\\n        - comment (str): a message for the user\\n        - already_configured (bool): flag to check if there were no changes applied\\n        - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.delete_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('delete_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef delete_users(users, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Removes users from the configuration of network devices.\\n\\n    :param users: Dictionary formatted as the output of the function config()\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n        - result (bool): if the config was applied successfully. It is `False`\\n          only in case of failure. In case there are no changes to be applied\\n          and successfully performs all operations it is still `True` and so\\n          will be the `already_configured` flag (example below)\\n        - comment (str): a message for the user\\n        - already_configured (bool): flag to check if there were no changes applied\\n        - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' users.delete_users \"{\\'mircea\\': {}}\"\\n    '\n    return __salt__['net.load_template']('delete_users', users=users, test=test, commit=commit, inherit_napalm_device=napalm_device)"
        ]
    }
]