[
    {
        "func_name": "get_coeff_generator",
        "original": "def get_coeff_generator(degree):\n    gen = coeff_generators.get(degree, coeff_search(degree, 1))\n    coeff_generators[degree] = gen\n    return gen",
        "mutated": [
            "def get_coeff_generator(degree):\n    if False:\n        i = 10\n    gen = coeff_generators.get(degree, coeff_search(degree, 1))\n    coeff_generators[degree] = gen\n    return gen",
            "def get_coeff_generator(degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    gen = coeff_generators.get(degree, coeff_search(degree, 1))\n    coeff_generators[degree] = gen\n    return gen",
            "def get_coeff_generator(degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    gen = coeff_generators.get(degree, coeff_search(degree, 1))\n    coeff_generators[degree] = gen\n    return gen",
            "def get_coeff_generator(degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    gen = coeff_generators.get(degree, coeff_search(degree, 1))\n    coeff_generators[degree] = gen\n    return gen",
            "def get_coeff_generator(degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    gen = coeff_generators.get(degree, coeff_search(degree, 1))\n    coeff_generators[degree] = gen\n    return gen"
        ]
    },
    {
        "func_name": "tschirnhausen_transformation",
        "original": "def tschirnhausen_transformation(T, max_coeff=10, max_tries=30, history=None, fixed_order=True):\n    \"\"\"\n    Given a univariate, monic, irreducible polynomial over the integers, find\n    another such polynomial defining the same number field.\n\n    Explanation\n    ===========\n\n    See Alg 6.3.4 of [1].\n\n    Parameters\n    ==========\n\n    T : Poly\n        The given polynomial\n    max_coeff : int\n        When choosing a transformation as part of the process,\n        keep the coeffs between plus and minus this.\n    max_tries : int\n        Consider at most this many transformations.\n    history : set, None, optional (default=None)\n        Pass a set of ``Poly.rep``'s in order to prevent any of these\n        polynomials from being returned as the polynomial ``U`` i.e. the\n        transformation of the given polynomial *T*. The given poly *T* will\n        automatically be added to this set, before we try to find a new one.\n    fixed_order : bool, default True\n        If ``True``, work through candidate transformations A(x) in a fixed\n        order, from small coeffs to large, resulting in deterministic behavior.\n        If ``False``, the A(x) are chosen randomly, while still working our way\n        up from small coefficients to larger ones.\n\n    Returns\n    =======\n\n    Pair ``(A, U)``\n\n        ``A`` and ``U`` are ``Poly``, ``A`` is the\n        transformation, and ``U`` is the transformed polynomial that defines\n        the same number field as *T*. The polynomial ``A`` maps the roots of\n        *T* to the roots of ``U``.\n\n    Raises\n    ======\n\n    MaxTriesException\n        if could not find a polynomial before exceeding *max_tries*.\n\n    \"\"\"\n    X = Dummy('X')\n    n = T.degree()\n    if history is None:\n        history = set()\n    history.add(T.rep)\n    if fixed_order:\n        coeff_generators = {}\n        deg_coeff_sum = 3\n        current_degree = 2\n\n    def get_coeff_generator(degree):\n        gen = coeff_generators.get(degree, coeff_search(degree, 1))\n        coeff_generators[degree] = gen\n        return gen\n    for i in range(max_tries):\n        if fixed_order:\n            gen = get_coeff_generator(current_degree)\n            coeffs = next(gen)\n            m = max((abs(c) for c in coeffs))\n            if current_degree + m > deg_coeff_sum:\n                if current_degree == 2:\n                    deg_coeff_sum += 1\n                    current_degree = deg_coeff_sum - 1\n                else:\n                    current_degree -= 1\n                gen = get_coeff_generator(current_degree)\n                coeffs = next(gen)\n            a = [ZZ(1)] + [ZZ(c) for c in coeffs]\n        else:\n            C = min(i // 5 + 1, max_coeff)\n            d = random.randint(2, n - 1)\n            a = dup_random(d, -C, C, ZZ)\n        A = Poly(a, T.gen)\n        U = Poly(T.resultant(X - A), X)\n        if U.rep not in history and dup_sqf_p(U.rep.to_list(), ZZ):\n            return (A, U)\n    raise MaxTriesException",
        "mutated": [
            "def tschirnhausen_transformation(T, max_coeff=10, max_tries=30, history=None, fixed_order=True):\n    if False:\n        i = 10\n    \"\\n    Given a univariate, monic, irreducible polynomial over the integers, find\\n    another such polynomial defining the same number field.\\n\\n    Explanation\\n    ===========\\n\\n    See Alg 6.3.4 of [1].\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The given polynomial\\n    max_coeff : int\\n        When choosing a transformation as part of the process,\\n        keep the coeffs between plus and minus this.\\n    max_tries : int\\n        Consider at most this many transformations.\\n    history : set, None, optional (default=None)\\n        Pass a set of ``Poly.rep``'s in order to prevent any of these\\n        polynomials from being returned as the polynomial ``U`` i.e. the\\n        transformation of the given polynomial *T*. The given poly *T* will\\n        automatically be added to this set, before we try to find a new one.\\n    fixed_order : bool, default True\\n        If ``True``, work through candidate transformations A(x) in a fixed\\n        order, from small coeffs to large, resulting in deterministic behavior.\\n        If ``False``, the A(x) are chosen randomly, while still working our way\\n        up from small coefficients to larger ones.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(A, U)``\\n\\n        ``A`` and ``U`` are ``Poly``, ``A`` is the\\n        transformation, and ``U`` is the transformed polynomial that defines\\n        the same number field as *T*. The polynomial ``A`` maps the roots of\\n        *T* to the roots of ``U``.\\n\\n    Raises\\n    ======\\n\\n    MaxTriesException\\n        if could not find a polynomial before exceeding *max_tries*.\\n\\n    \"\n    X = Dummy('X')\n    n = T.degree()\n    if history is None:\n        history = set()\n    history.add(T.rep)\n    if fixed_order:\n        coeff_generators = {}\n        deg_coeff_sum = 3\n        current_degree = 2\n\n    def get_coeff_generator(degree):\n        gen = coeff_generators.get(degree, coeff_search(degree, 1))\n        coeff_generators[degree] = gen\n        return gen\n    for i in range(max_tries):\n        if fixed_order:\n            gen = get_coeff_generator(current_degree)\n            coeffs = next(gen)\n            m = max((abs(c) for c in coeffs))\n            if current_degree + m > deg_coeff_sum:\n                if current_degree == 2:\n                    deg_coeff_sum += 1\n                    current_degree = deg_coeff_sum - 1\n                else:\n                    current_degree -= 1\n                gen = get_coeff_generator(current_degree)\n                coeffs = next(gen)\n            a = [ZZ(1)] + [ZZ(c) for c in coeffs]\n        else:\n            C = min(i // 5 + 1, max_coeff)\n            d = random.randint(2, n - 1)\n            a = dup_random(d, -C, C, ZZ)\n        A = Poly(a, T.gen)\n        U = Poly(T.resultant(X - A), X)\n        if U.rep not in history and dup_sqf_p(U.rep.to_list(), ZZ):\n            return (A, U)\n    raise MaxTriesException",
            "def tschirnhausen_transformation(T, max_coeff=10, max_tries=30, history=None, fixed_order=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Given a univariate, monic, irreducible polynomial over the integers, find\\n    another such polynomial defining the same number field.\\n\\n    Explanation\\n    ===========\\n\\n    See Alg 6.3.4 of [1].\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The given polynomial\\n    max_coeff : int\\n        When choosing a transformation as part of the process,\\n        keep the coeffs between plus and minus this.\\n    max_tries : int\\n        Consider at most this many transformations.\\n    history : set, None, optional (default=None)\\n        Pass a set of ``Poly.rep``'s in order to prevent any of these\\n        polynomials from being returned as the polynomial ``U`` i.e. the\\n        transformation of the given polynomial *T*. The given poly *T* will\\n        automatically be added to this set, before we try to find a new one.\\n    fixed_order : bool, default True\\n        If ``True``, work through candidate transformations A(x) in a fixed\\n        order, from small coeffs to large, resulting in deterministic behavior.\\n        If ``False``, the A(x) are chosen randomly, while still working our way\\n        up from small coefficients to larger ones.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(A, U)``\\n\\n        ``A`` and ``U`` are ``Poly``, ``A`` is the\\n        transformation, and ``U`` is the transformed polynomial that defines\\n        the same number field as *T*. The polynomial ``A`` maps the roots of\\n        *T* to the roots of ``U``.\\n\\n    Raises\\n    ======\\n\\n    MaxTriesException\\n        if could not find a polynomial before exceeding *max_tries*.\\n\\n    \"\n    X = Dummy('X')\n    n = T.degree()\n    if history is None:\n        history = set()\n    history.add(T.rep)\n    if fixed_order:\n        coeff_generators = {}\n        deg_coeff_sum = 3\n        current_degree = 2\n\n    def get_coeff_generator(degree):\n        gen = coeff_generators.get(degree, coeff_search(degree, 1))\n        coeff_generators[degree] = gen\n        return gen\n    for i in range(max_tries):\n        if fixed_order:\n            gen = get_coeff_generator(current_degree)\n            coeffs = next(gen)\n            m = max((abs(c) for c in coeffs))\n            if current_degree + m > deg_coeff_sum:\n                if current_degree == 2:\n                    deg_coeff_sum += 1\n                    current_degree = deg_coeff_sum - 1\n                else:\n                    current_degree -= 1\n                gen = get_coeff_generator(current_degree)\n                coeffs = next(gen)\n            a = [ZZ(1)] + [ZZ(c) for c in coeffs]\n        else:\n            C = min(i // 5 + 1, max_coeff)\n            d = random.randint(2, n - 1)\n            a = dup_random(d, -C, C, ZZ)\n        A = Poly(a, T.gen)\n        U = Poly(T.resultant(X - A), X)\n        if U.rep not in history and dup_sqf_p(U.rep.to_list(), ZZ):\n            return (A, U)\n    raise MaxTriesException",
            "def tschirnhausen_transformation(T, max_coeff=10, max_tries=30, history=None, fixed_order=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Given a univariate, monic, irreducible polynomial over the integers, find\\n    another such polynomial defining the same number field.\\n\\n    Explanation\\n    ===========\\n\\n    See Alg 6.3.4 of [1].\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The given polynomial\\n    max_coeff : int\\n        When choosing a transformation as part of the process,\\n        keep the coeffs between plus and minus this.\\n    max_tries : int\\n        Consider at most this many transformations.\\n    history : set, None, optional (default=None)\\n        Pass a set of ``Poly.rep``'s in order to prevent any of these\\n        polynomials from being returned as the polynomial ``U`` i.e. the\\n        transformation of the given polynomial *T*. The given poly *T* will\\n        automatically be added to this set, before we try to find a new one.\\n    fixed_order : bool, default True\\n        If ``True``, work through candidate transformations A(x) in a fixed\\n        order, from small coeffs to large, resulting in deterministic behavior.\\n        If ``False``, the A(x) are chosen randomly, while still working our way\\n        up from small coefficients to larger ones.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(A, U)``\\n\\n        ``A`` and ``U`` are ``Poly``, ``A`` is the\\n        transformation, and ``U`` is the transformed polynomial that defines\\n        the same number field as *T*. The polynomial ``A`` maps the roots of\\n        *T* to the roots of ``U``.\\n\\n    Raises\\n    ======\\n\\n    MaxTriesException\\n        if could not find a polynomial before exceeding *max_tries*.\\n\\n    \"\n    X = Dummy('X')\n    n = T.degree()\n    if history is None:\n        history = set()\n    history.add(T.rep)\n    if fixed_order:\n        coeff_generators = {}\n        deg_coeff_sum = 3\n        current_degree = 2\n\n    def get_coeff_generator(degree):\n        gen = coeff_generators.get(degree, coeff_search(degree, 1))\n        coeff_generators[degree] = gen\n        return gen\n    for i in range(max_tries):\n        if fixed_order:\n            gen = get_coeff_generator(current_degree)\n            coeffs = next(gen)\n            m = max((abs(c) for c in coeffs))\n            if current_degree + m > deg_coeff_sum:\n                if current_degree == 2:\n                    deg_coeff_sum += 1\n                    current_degree = deg_coeff_sum - 1\n                else:\n                    current_degree -= 1\n                gen = get_coeff_generator(current_degree)\n                coeffs = next(gen)\n            a = [ZZ(1)] + [ZZ(c) for c in coeffs]\n        else:\n            C = min(i // 5 + 1, max_coeff)\n            d = random.randint(2, n - 1)\n            a = dup_random(d, -C, C, ZZ)\n        A = Poly(a, T.gen)\n        U = Poly(T.resultant(X - A), X)\n        if U.rep not in history and dup_sqf_p(U.rep.to_list(), ZZ):\n            return (A, U)\n    raise MaxTriesException",
            "def tschirnhausen_transformation(T, max_coeff=10, max_tries=30, history=None, fixed_order=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Given a univariate, monic, irreducible polynomial over the integers, find\\n    another such polynomial defining the same number field.\\n\\n    Explanation\\n    ===========\\n\\n    See Alg 6.3.4 of [1].\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The given polynomial\\n    max_coeff : int\\n        When choosing a transformation as part of the process,\\n        keep the coeffs between plus and minus this.\\n    max_tries : int\\n        Consider at most this many transformations.\\n    history : set, None, optional (default=None)\\n        Pass a set of ``Poly.rep``'s in order to prevent any of these\\n        polynomials from being returned as the polynomial ``U`` i.e. the\\n        transformation of the given polynomial *T*. The given poly *T* will\\n        automatically be added to this set, before we try to find a new one.\\n    fixed_order : bool, default True\\n        If ``True``, work through candidate transformations A(x) in a fixed\\n        order, from small coeffs to large, resulting in deterministic behavior.\\n        If ``False``, the A(x) are chosen randomly, while still working our way\\n        up from small coefficients to larger ones.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(A, U)``\\n\\n        ``A`` and ``U`` are ``Poly``, ``A`` is the\\n        transformation, and ``U`` is the transformed polynomial that defines\\n        the same number field as *T*. The polynomial ``A`` maps the roots of\\n        *T* to the roots of ``U``.\\n\\n    Raises\\n    ======\\n\\n    MaxTriesException\\n        if could not find a polynomial before exceeding *max_tries*.\\n\\n    \"\n    X = Dummy('X')\n    n = T.degree()\n    if history is None:\n        history = set()\n    history.add(T.rep)\n    if fixed_order:\n        coeff_generators = {}\n        deg_coeff_sum = 3\n        current_degree = 2\n\n    def get_coeff_generator(degree):\n        gen = coeff_generators.get(degree, coeff_search(degree, 1))\n        coeff_generators[degree] = gen\n        return gen\n    for i in range(max_tries):\n        if fixed_order:\n            gen = get_coeff_generator(current_degree)\n            coeffs = next(gen)\n            m = max((abs(c) for c in coeffs))\n            if current_degree + m > deg_coeff_sum:\n                if current_degree == 2:\n                    deg_coeff_sum += 1\n                    current_degree = deg_coeff_sum - 1\n                else:\n                    current_degree -= 1\n                gen = get_coeff_generator(current_degree)\n                coeffs = next(gen)\n            a = [ZZ(1)] + [ZZ(c) for c in coeffs]\n        else:\n            C = min(i // 5 + 1, max_coeff)\n            d = random.randint(2, n - 1)\n            a = dup_random(d, -C, C, ZZ)\n        A = Poly(a, T.gen)\n        U = Poly(T.resultant(X - A), X)\n        if U.rep not in history and dup_sqf_p(U.rep.to_list(), ZZ):\n            return (A, U)\n    raise MaxTriesException",
            "def tschirnhausen_transformation(T, max_coeff=10, max_tries=30, history=None, fixed_order=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Given a univariate, monic, irreducible polynomial over the integers, find\\n    another such polynomial defining the same number field.\\n\\n    Explanation\\n    ===========\\n\\n    See Alg 6.3.4 of [1].\\n\\n    Parameters\\n    ==========\\n\\n    T : Poly\\n        The given polynomial\\n    max_coeff : int\\n        When choosing a transformation as part of the process,\\n        keep the coeffs between plus and minus this.\\n    max_tries : int\\n        Consider at most this many transformations.\\n    history : set, None, optional (default=None)\\n        Pass a set of ``Poly.rep``'s in order to prevent any of these\\n        polynomials from being returned as the polynomial ``U`` i.e. the\\n        transformation of the given polynomial *T*. The given poly *T* will\\n        automatically be added to this set, before we try to find a new one.\\n    fixed_order : bool, default True\\n        If ``True``, work through candidate transformations A(x) in a fixed\\n        order, from small coeffs to large, resulting in deterministic behavior.\\n        If ``False``, the A(x) are chosen randomly, while still working our way\\n        up from small coefficients to larger ones.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(A, U)``\\n\\n        ``A`` and ``U`` are ``Poly``, ``A`` is the\\n        transformation, and ``U`` is the transformed polynomial that defines\\n        the same number field as *T*. The polynomial ``A`` maps the roots of\\n        *T* to the roots of ``U``.\\n\\n    Raises\\n    ======\\n\\n    MaxTriesException\\n        if could not find a polynomial before exceeding *max_tries*.\\n\\n    \"\n    X = Dummy('X')\n    n = T.degree()\n    if history is None:\n        history = set()\n    history.add(T.rep)\n    if fixed_order:\n        coeff_generators = {}\n        deg_coeff_sum = 3\n        current_degree = 2\n\n    def get_coeff_generator(degree):\n        gen = coeff_generators.get(degree, coeff_search(degree, 1))\n        coeff_generators[degree] = gen\n        return gen\n    for i in range(max_tries):\n        if fixed_order:\n            gen = get_coeff_generator(current_degree)\n            coeffs = next(gen)\n            m = max((abs(c) for c in coeffs))\n            if current_degree + m > deg_coeff_sum:\n                if current_degree == 2:\n                    deg_coeff_sum += 1\n                    current_degree = deg_coeff_sum - 1\n                else:\n                    current_degree -= 1\n                gen = get_coeff_generator(current_degree)\n                coeffs = next(gen)\n            a = [ZZ(1)] + [ZZ(c) for c in coeffs]\n        else:\n            C = min(i // 5 + 1, max_coeff)\n            d = random.randint(2, n - 1)\n            a = dup_random(d, -C, C, ZZ)\n        A = Poly(a, T.gen)\n        U = Poly(T.resultant(X - A), X)\n        if U.rep not in history and dup_sqf_p(U.rep.to_list(), ZZ):\n            return (A, U)\n    raise MaxTriesException"
        ]
    },
    {
        "func_name": "has_square_disc",
        "original": "def has_square_disc(T):\n    \"\"\"Convenience to check if a Poly or dup has square discriminant. \"\"\"\n    d = T.discriminant() if isinstance(T, Poly) else dup_discriminant(T, ZZ)\n    return is_square(d)",
        "mutated": [
            "def has_square_disc(T):\n    if False:\n        i = 10\n    'Convenience to check if a Poly or dup has square discriminant. '\n    d = T.discriminant() if isinstance(T, Poly) else dup_discriminant(T, ZZ)\n    return is_square(d)",
            "def has_square_disc(T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convenience to check if a Poly or dup has square discriminant. '\n    d = T.discriminant() if isinstance(T, Poly) else dup_discriminant(T, ZZ)\n    return is_square(d)",
            "def has_square_disc(T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convenience to check if a Poly or dup has square discriminant. '\n    d = T.discriminant() if isinstance(T, Poly) else dup_discriminant(T, ZZ)\n    return is_square(d)",
            "def has_square_disc(T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convenience to check if a Poly or dup has square discriminant. '\n    d = T.discriminant() if isinstance(T, Poly) else dup_discriminant(T, ZZ)\n    return is_square(d)",
            "def has_square_disc(T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convenience to check if a Poly or dup has square discriminant. '\n    d = T.discriminant() if isinstance(T, Poly) else dup_discriminant(T, ZZ)\n    return is_square(d)"
        ]
    },
    {
        "func_name": "_galois_group_degree_3",
        "original": "def _galois_group_degree_3(T, max_tries=30, randomize=False):\n    \"\"\"\n    Compute the Galois group of a polynomial of degree 3.\n\n    Explanation\n    ===========\n\n    Uses Prop 6.3.5 of [1].\n\n    \"\"\"\n    from sympy.combinatorics.galois import S3TransitiveSubgroups\n    return (S3TransitiveSubgroups.A3, True) if has_square_disc(T) else (S3TransitiveSubgroups.S3, False)",
        "mutated": [
            "def _galois_group_degree_3(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n    '\\n    Compute the Galois group of a polynomial of degree 3.\\n\\n    Explanation\\n    ===========\\n\\n    Uses Prop 6.3.5 of [1].\\n\\n    '\n    from sympy.combinatorics.galois import S3TransitiveSubgroups\n    return (S3TransitiveSubgroups.A3, True) if has_square_disc(T) else (S3TransitiveSubgroups.S3, False)",
            "def _galois_group_degree_3(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the Galois group of a polynomial of degree 3.\\n\\n    Explanation\\n    ===========\\n\\n    Uses Prop 6.3.5 of [1].\\n\\n    '\n    from sympy.combinatorics.galois import S3TransitiveSubgroups\n    return (S3TransitiveSubgroups.A3, True) if has_square_disc(T) else (S3TransitiveSubgroups.S3, False)",
            "def _galois_group_degree_3(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the Galois group of a polynomial of degree 3.\\n\\n    Explanation\\n    ===========\\n\\n    Uses Prop 6.3.5 of [1].\\n\\n    '\n    from sympy.combinatorics.galois import S3TransitiveSubgroups\n    return (S3TransitiveSubgroups.A3, True) if has_square_disc(T) else (S3TransitiveSubgroups.S3, False)",
            "def _galois_group_degree_3(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the Galois group of a polynomial of degree 3.\\n\\n    Explanation\\n    ===========\\n\\n    Uses Prop 6.3.5 of [1].\\n\\n    '\n    from sympy.combinatorics.galois import S3TransitiveSubgroups\n    return (S3TransitiveSubgroups.A3, True) if has_square_disc(T) else (S3TransitiveSubgroups.S3, False)",
            "def _galois_group_degree_3(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the Galois group of a polynomial of degree 3.\\n\\n    Explanation\\n    ===========\\n\\n    Uses Prop 6.3.5 of [1].\\n\\n    '\n    from sympy.combinatorics.galois import S3TransitiveSubgroups\n    return (S3TransitiveSubgroups.A3, True) if has_square_disc(T) else (S3TransitiveSubgroups.S3, False)"
        ]
    },
    {
        "func_name": "_galois_group_degree_4_root_approx",
        "original": "def _galois_group_degree_4_root_approx(T, max_tries=30, randomize=False):\n    \"\"\"\n    Compute the Galois group of a polynomial of degree 4.\n\n    Explanation\n    ===========\n\n    Follows Alg 6.3.7 of [1], using a pure root approximation approach.\n\n    \"\"\"\n    from sympy.combinatorics.permutations import Permutation\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    X = symbols('X0 X1 X2 X3')\n    F1 = X[0] * X[2] + X[1] * X[3]\n    s1 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    R1 = Resolvent(F1, X, s1)\n    F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s2_pre = [Permutation(3), Permutation(3)(0, 2)]\n    history = set()\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        (R_dup, _, i0) = R1.eval_for_poly(T, find_integer_root=True)\n        if not dup_sqf_p(R_dup, ZZ):\n            continue\n        sq_disc = has_square_disc(T)\n        if i0 is None:\n            return (S4TransitiveSubgroups.A4, True) if sq_disc else (S4TransitiveSubgroups.S4, False)\n        if sq_disc:\n            return (S4TransitiveSubgroups.V, True)\n        sigma = s1[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S4TransitiveSubgroups.C4, False)\n        else:\n            return (S4TransitiveSubgroups.D4, False)\n    raise MaxTriesException",
        "mutated": [
            "def _galois_group_degree_4_root_approx(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Follows Alg 6.3.7 of [1], using a pure root approximation approach.\\n\\n    '\n    from sympy.combinatorics.permutations import Permutation\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    X = symbols('X0 X1 X2 X3')\n    F1 = X[0] * X[2] + X[1] * X[3]\n    s1 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    R1 = Resolvent(F1, X, s1)\n    F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s2_pre = [Permutation(3), Permutation(3)(0, 2)]\n    history = set()\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        (R_dup, _, i0) = R1.eval_for_poly(T, find_integer_root=True)\n        if not dup_sqf_p(R_dup, ZZ):\n            continue\n        sq_disc = has_square_disc(T)\n        if i0 is None:\n            return (S4TransitiveSubgroups.A4, True) if sq_disc else (S4TransitiveSubgroups.S4, False)\n        if sq_disc:\n            return (S4TransitiveSubgroups.V, True)\n        sigma = s1[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S4TransitiveSubgroups.C4, False)\n        else:\n            return (S4TransitiveSubgroups.D4, False)\n    raise MaxTriesException",
            "def _galois_group_degree_4_root_approx(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Follows Alg 6.3.7 of [1], using a pure root approximation approach.\\n\\n    '\n    from sympy.combinatorics.permutations import Permutation\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    X = symbols('X0 X1 X2 X3')\n    F1 = X[0] * X[2] + X[1] * X[3]\n    s1 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    R1 = Resolvent(F1, X, s1)\n    F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s2_pre = [Permutation(3), Permutation(3)(0, 2)]\n    history = set()\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        (R_dup, _, i0) = R1.eval_for_poly(T, find_integer_root=True)\n        if not dup_sqf_p(R_dup, ZZ):\n            continue\n        sq_disc = has_square_disc(T)\n        if i0 is None:\n            return (S4TransitiveSubgroups.A4, True) if sq_disc else (S4TransitiveSubgroups.S4, False)\n        if sq_disc:\n            return (S4TransitiveSubgroups.V, True)\n        sigma = s1[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S4TransitiveSubgroups.C4, False)\n        else:\n            return (S4TransitiveSubgroups.D4, False)\n    raise MaxTriesException",
            "def _galois_group_degree_4_root_approx(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Follows Alg 6.3.7 of [1], using a pure root approximation approach.\\n\\n    '\n    from sympy.combinatorics.permutations import Permutation\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    X = symbols('X0 X1 X2 X3')\n    F1 = X[0] * X[2] + X[1] * X[3]\n    s1 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    R1 = Resolvent(F1, X, s1)\n    F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s2_pre = [Permutation(3), Permutation(3)(0, 2)]\n    history = set()\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        (R_dup, _, i0) = R1.eval_for_poly(T, find_integer_root=True)\n        if not dup_sqf_p(R_dup, ZZ):\n            continue\n        sq_disc = has_square_disc(T)\n        if i0 is None:\n            return (S4TransitiveSubgroups.A4, True) if sq_disc else (S4TransitiveSubgroups.S4, False)\n        if sq_disc:\n            return (S4TransitiveSubgroups.V, True)\n        sigma = s1[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S4TransitiveSubgroups.C4, False)\n        else:\n            return (S4TransitiveSubgroups.D4, False)\n    raise MaxTriesException",
            "def _galois_group_degree_4_root_approx(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Follows Alg 6.3.7 of [1], using a pure root approximation approach.\\n\\n    '\n    from sympy.combinatorics.permutations import Permutation\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    X = symbols('X0 X1 X2 X3')\n    F1 = X[0] * X[2] + X[1] * X[3]\n    s1 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    R1 = Resolvent(F1, X, s1)\n    F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s2_pre = [Permutation(3), Permutation(3)(0, 2)]\n    history = set()\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        (R_dup, _, i0) = R1.eval_for_poly(T, find_integer_root=True)\n        if not dup_sqf_p(R_dup, ZZ):\n            continue\n        sq_disc = has_square_disc(T)\n        if i0 is None:\n            return (S4TransitiveSubgroups.A4, True) if sq_disc else (S4TransitiveSubgroups.S4, False)\n        if sq_disc:\n            return (S4TransitiveSubgroups.V, True)\n        sigma = s1[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S4TransitiveSubgroups.C4, False)\n        else:\n            return (S4TransitiveSubgroups.D4, False)\n    raise MaxTriesException",
            "def _galois_group_degree_4_root_approx(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Follows Alg 6.3.7 of [1], using a pure root approximation approach.\\n\\n    '\n    from sympy.combinatorics.permutations import Permutation\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    X = symbols('X0 X1 X2 X3')\n    F1 = X[0] * X[2] + X[1] * X[3]\n    s1 = [Permutation(3), Permutation(3)(0, 1), Permutation(3)(0, 3)]\n    R1 = Resolvent(F1, X, s1)\n    F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[0] ** 2\n    s2_pre = [Permutation(3), Permutation(3)(0, 2)]\n    history = set()\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        (R_dup, _, i0) = R1.eval_for_poly(T, find_integer_root=True)\n        if not dup_sqf_p(R_dup, ZZ):\n            continue\n        sq_disc = has_square_disc(T)\n        if i0 is None:\n            return (S4TransitiveSubgroups.A4, True) if sq_disc else (S4TransitiveSubgroups.S4, False)\n        if sq_disc:\n            return (S4TransitiveSubgroups.V, True)\n        sigma = s1[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S4TransitiveSubgroups.C4, False)\n        else:\n            return (S4TransitiveSubgroups.D4, False)\n    raise MaxTriesException"
        ]
    },
    {
        "func_name": "_galois_group_degree_4_lookup",
        "original": "def _galois_group_degree_4_lookup(T, max_tries=30, randomize=False):\n    \"\"\"\n    Compute the Galois group of a polynomial of degree 4.\n\n    Explanation\n    ===========\n\n    Based on Alg 6.3.6 of [1], but uses resolvent coeff lookup.\n\n    \"\"\"\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 0)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    L = sorted(sum([[len(r) - 1] * e for (r, e) in fl[1]], []))\n    if L == [6]:\n        return (S4TransitiveSubgroups.A4, True) if has_square_disc(T) else (S4TransitiveSubgroups.S4, False)\n    if L == [1, 1, 4]:\n        return (S4TransitiveSubgroups.C4, False)\n    if L == [2, 2, 2]:\n        return (S4TransitiveSubgroups.V, True)\n    assert L == [2, 4]\n    return (S4TransitiveSubgroups.D4, False)",
        "mutated": [
            "def _galois_group_degree_4_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.6 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 0)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    L = sorted(sum([[len(r) - 1] * e for (r, e) in fl[1]], []))\n    if L == [6]:\n        return (S4TransitiveSubgroups.A4, True) if has_square_disc(T) else (S4TransitiveSubgroups.S4, False)\n    if L == [1, 1, 4]:\n        return (S4TransitiveSubgroups.C4, False)\n    if L == [2, 2, 2]:\n        return (S4TransitiveSubgroups.V, True)\n    assert L == [2, 4]\n    return (S4TransitiveSubgroups.D4, False)",
            "def _galois_group_degree_4_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.6 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 0)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    L = sorted(sum([[len(r) - 1] * e for (r, e) in fl[1]], []))\n    if L == [6]:\n        return (S4TransitiveSubgroups.A4, True) if has_square_disc(T) else (S4TransitiveSubgroups.S4, False)\n    if L == [1, 1, 4]:\n        return (S4TransitiveSubgroups.C4, False)\n    if L == [2, 2, 2]:\n        return (S4TransitiveSubgroups.V, True)\n    assert L == [2, 4]\n    return (S4TransitiveSubgroups.D4, False)",
            "def _galois_group_degree_4_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.6 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 0)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    L = sorted(sum([[len(r) - 1] * e for (r, e) in fl[1]], []))\n    if L == [6]:\n        return (S4TransitiveSubgroups.A4, True) if has_square_disc(T) else (S4TransitiveSubgroups.S4, False)\n    if L == [1, 1, 4]:\n        return (S4TransitiveSubgroups.C4, False)\n    if L == [2, 2, 2]:\n        return (S4TransitiveSubgroups.V, True)\n    assert L == [2, 4]\n    return (S4TransitiveSubgroups.D4, False)",
            "def _galois_group_degree_4_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.6 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 0)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    L = sorted(sum([[len(r) - 1] * e for (r, e) in fl[1]], []))\n    if L == [6]:\n        return (S4TransitiveSubgroups.A4, True) if has_square_disc(T) else (S4TransitiveSubgroups.S4, False)\n    if L == [1, 1, 4]:\n        return (S4TransitiveSubgroups.C4, False)\n    if L == [2, 2, 2]:\n        return (S4TransitiveSubgroups.V, True)\n    assert L == [2, 4]\n    return (S4TransitiveSubgroups.D4, False)",
            "def _galois_group_degree_4_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the Galois group of a polynomial of degree 4.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.6 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S4TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 0)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    L = sorted(sum([[len(r) - 1] * e for (r, e) in fl[1]], []))\n    if L == [6]:\n        return (S4TransitiveSubgroups.A4, True) if has_square_disc(T) else (S4TransitiveSubgroups.S4, False)\n    if L == [1, 1, 4]:\n        return (S4TransitiveSubgroups.C4, False)\n    if L == [2, 2, 2]:\n        return (S4TransitiveSubgroups.V, True)\n    assert L == [2, 4]\n    return (S4TransitiveSubgroups.D4, False)"
        ]
    },
    {
        "func_name": "_galois_group_degree_5_hybrid",
        "original": "def _galois_group_degree_5_hybrid(T, max_tries=30, randomize=False):\n    \"\"\"\n    Compute the Galois group of a polynomial of degree 5.\n\n    Explanation\n    ===========\n\n    Based on Alg 6.3.9 of [1], but uses a hybrid approach, combining resolvent\n    coeff lookup, with root approximation.\n\n    \"\"\"\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    from sympy.combinatorics.permutations import Permutation\n    X5 = symbols('X0,X1,X2,X3,X4')\n    res = define_resolvents()\n    (F51, _, s51) = res[5, 1]\n    F51 = F51.as_expr(*X5)\n    R51 = Resolvent(F51, X5, s51)\n    history = set()\n    reached_second_stage = False\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        R51_dup = get_resolvent_by_lookup(T, 1)\n        if not dup_sqf_p(R51_dup, ZZ):\n            continue\n        if not reached_second_stage:\n            sq_disc = has_square_disc(T)\n            if dup_irreducible_p(R51_dup, ZZ):\n                return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n            if not sq_disc:\n                return (S5TransitiveSubgroups.M20, False)\n        reached_second_stage = True\n        rounded_roots = R51.round_roots_to_integers_for_poly(T)\n        for (permutation_index, candidate_root) in rounded_roots.items():\n            if not dup_eval(R51_dup, candidate_root, ZZ):\n                break\n        X = X5\n        F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[4] ** 2 + X[4] * X[0] ** 2\n        s2_pre = [Permutation(4), Permutation(4)(0, 1)(2, 4)]\n        i0 = permutation_index\n        sigma = s51[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S5TransitiveSubgroups.C5, True)\n        else:\n            return (S5TransitiveSubgroups.D5, True)\n    raise MaxTriesException",
        "mutated": [
            "def _galois_group_degree_5_hybrid(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses a hybrid approach, combining resolvent\\n    coeff lookup, with root approximation.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    from sympy.combinatorics.permutations import Permutation\n    X5 = symbols('X0,X1,X2,X3,X4')\n    res = define_resolvents()\n    (F51, _, s51) = res[5, 1]\n    F51 = F51.as_expr(*X5)\n    R51 = Resolvent(F51, X5, s51)\n    history = set()\n    reached_second_stage = False\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        R51_dup = get_resolvent_by_lookup(T, 1)\n        if not dup_sqf_p(R51_dup, ZZ):\n            continue\n        if not reached_second_stage:\n            sq_disc = has_square_disc(T)\n            if dup_irreducible_p(R51_dup, ZZ):\n                return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n            if not sq_disc:\n                return (S5TransitiveSubgroups.M20, False)\n        reached_second_stage = True\n        rounded_roots = R51.round_roots_to_integers_for_poly(T)\n        for (permutation_index, candidate_root) in rounded_roots.items():\n            if not dup_eval(R51_dup, candidate_root, ZZ):\n                break\n        X = X5\n        F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[4] ** 2 + X[4] * X[0] ** 2\n        s2_pre = [Permutation(4), Permutation(4)(0, 1)(2, 4)]\n        i0 = permutation_index\n        sigma = s51[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S5TransitiveSubgroups.C5, True)\n        else:\n            return (S5TransitiveSubgroups.D5, True)\n    raise MaxTriesException",
            "def _galois_group_degree_5_hybrid(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses a hybrid approach, combining resolvent\\n    coeff lookup, with root approximation.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    from sympy.combinatorics.permutations import Permutation\n    X5 = symbols('X0,X1,X2,X3,X4')\n    res = define_resolvents()\n    (F51, _, s51) = res[5, 1]\n    F51 = F51.as_expr(*X5)\n    R51 = Resolvent(F51, X5, s51)\n    history = set()\n    reached_second_stage = False\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        R51_dup = get_resolvent_by_lookup(T, 1)\n        if not dup_sqf_p(R51_dup, ZZ):\n            continue\n        if not reached_second_stage:\n            sq_disc = has_square_disc(T)\n            if dup_irreducible_p(R51_dup, ZZ):\n                return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n            if not sq_disc:\n                return (S5TransitiveSubgroups.M20, False)\n        reached_second_stage = True\n        rounded_roots = R51.round_roots_to_integers_for_poly(T)\n        for (permutation_index, candidate_root) in rounded_roots.items():\n            if not dup_eval(R51_dup, candidate_root, ZZ):\n                break\n        X = X5\n        F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[4] ** 2 + X[4] * X[0] ** 2\n        s2_pre = [Permutation(4), Permutation(4)(0, 1)(2, 4)]\n        i0 = permutation_index\n        sigma = s51[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S5TransitiveSubgroups.C5, True)\n        else:\n            return (S5TransitiveSubgroups.D5, True)\n    raise MaxTriesException",
            "def _galois_group_degree_5_hybrid(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses a hybrid approach, combining resolvent\\n    coeff lookup, with root approximation.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    from sympy.combinatorics.permutations import Permutation\n    X5 = symbols('X0,X1,X2,X3,X4')\n    res = define_resolvents()\n    (F51, _, s51) = res[5, 1]\n    F51 = F51.as_expr(*X5)\n    R51 = Resolvent(F51, X5, s51)\n    history = set()\n    reached_second_stage = False\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        R51_dup = get_resolvent_by_lookup(T, 1)\n        if not dup_sqf_p(R51_dup, ZZ):\n            continue\n        if not reached_second_stage:\n            sq_disc = has_square_disc(T)\n            if dup_irreducible_p(R51_dup, ZZ):\n                return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n            if not sq_disc:\n                return (S5TransitiveSubgroups.M20, False)\n        reached_second_stage = True\n        rounded_roots = R51.round_roots_to_integers_for_poly(T)\n        for (permutation_index, candidate_root) in rounded_roots.items():\n            if not dup_eval(R51_dup, candidate_root, ZZ):\n                break\n        X = X5\n        F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[4] ** 2 + X[4] * X[0] ** 2\n        s2_pre = [Permutation(4), Permutation(4)(0, 1)(2, 4)]\n        i0 = permutation_index\n        sigma = s51[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S5TransitiveSubgroups.C5, True)\n        else:\n            return (S5TransitiveSubgroups.D5, True)\n    raise MaxTriesException",
            "def _galois_group_degree_5_hybrid(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses a hybrid approach, combining resolvent\\n    coeff lookup, with root approximation.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    from sympy.combinatorics.permutations import Permutation\n    X5 = symbols('X0,X1,X2,X3,X4')\n    res = define_resolvents()\n    (F51, _, s51) = res[5, 1]\n    F51 = F51.as_expr(*X5)\n    R51 = Resolvent(F51, X5, s51)\n    history = set()\n    reached_second_stage = False\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        R51_dup = get_resolvent_by_lookup(T, 1)\n        if not dup_sqf_p(R51_dup, ZZ):\n            continue\n        if not reached_second_stage:\n            sq_disc = has_square_disc(T)\n            if dup_irreducible_p(R51_dup, ZZ):\n                return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n            if not sq_disc:\n                return (S5TransitiveSubgroups.M20, False)\n        reached_second_stage = True\n        rounded_roots = R51.round_roots_to_integers_for_poly(T)\n        for (permutation_index, candidate_root) in rounded_roots.items():\n            if not dup_eval(R51_dup, candidate_root, ZZ):\n                break\n        X = X5\n        F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[4] ** 2 + X[4] * X[0] ** 2\n        s2_pre = [Permutation(4), Permutation(4)(0, 1)(2, 4)]\n        i0 = permutation_index\n        sigma = s51[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S5TransitiveSubgroups.C5, True)\n        else:\n            return (S5TransitiveSubgroups.D5, True)\n    raise MaxTriesException",
            "def _galois_group_degree_5_hybrid(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses a hybrid approach, combining resolvent\\n    coeff lookup, with root approximation.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    from sympy.combinatorics.permutations import Permutation\n    X5 = symbols('X0,X1,X2,X3,X4')\n    res = define_resolvents()\n    (F51, _, s51) = res[5, 1]\n    F51 = F51.as_expr(*X5)\n    R51 = Resolvent(F51, X5, s51)\n    history = set()\n    reached_second_stage = False\n    for i in range(max_tries):\n        if i > 0:\n            (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n        R51_dup = get_resolvent_by_lookup(T, 1)\n        if not dup_sqf_p(R51_dup, ZZ):\n            continue\n        if not reached_second_stage:\n            sq_disc = has_square_disc(T)\n            if dup_irreducible_p(R51_dup, ZZ):\n                return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n            if not sq_disc:\n                return (S5TransitiveSubgroups.M20, False)\n        reached_second_stage = True\n        rounded_roots = R51.round_roots_to_integers_for_poly(T)\n        for (permutation_index, candidate_root) in rounded_roots.items():\n            if not dup_eval(R51_dup, candidate_root, ZZ):\n                break\n        X = X5\n        F2_pre = X[0] * X[1] ** 2 + X[1] * X[2] ** 2 + X[2] * X[3] ** 2 + X[3] * X[4] ** 2 + X[4] * X[0] ** 2\n        s2_pre = [Permutation(4), Permutation(4)(0, 1)(2, 4)]\n        i0 = permutation_index\n        sigma = s51[i0]\n        F2 = F2_pre.subs(zip(X, sigma(X)), simultaneous=True)\n        s2 = [sigma * tau * sigma for tau in s2_pre]\n        R2 = Resolvent(F2, X, s2)\n        (R_dup, _, _) = R2.eval_for_poly(T)\n        d = dup_discriminant(R_dup, ZZ)\n        if d == 0:\n            continue\n        if is_square(d):\n            return (S5TransitiveSubgroups.C5, True)\n        else:\n            return (S5TransitiveSubgroups.D5, True)\n    raise MaxTriesException"
        ]
    },
    {
        "func_name": "_galois_group_degree_5_lookup_ext_factor",
        "original": "def _galois_group_degree_5_lookup_ext_factor(T, max_tries=30, randomize=False):\n    \"\"\"\n    Compute the Galois group of a polynomial of degree 5.\n\n    Explanation\n    ===========\n\n    Based on Alg 6.3.9 of [1], but uses resolvent coeff lookup, plus\n    factorization over an algebraic extension.\n\n    \"\"\"\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    _T = T\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n    if not sq_disc:\n        return (S5TransitiveSubgroups.M20, False)\n    fl = Poly(_T, domain=ZZ.alg_field_from_poly(_T)).factor_list()[1]\n    if len(fl) == 5:\n        return (S5TransitiveSubgroups.C5, True)\n    else:\n        return (S5TransitiveSubgroups.D5, True)",
        "mutated": [
            "def _galois_group_degree_5_lookup_ext_factor(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses resolvent coeff lookup, plus\\n    factorization over an algebraic extension.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    _T = T\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n    if not sq_disc:\n        return (S5TransitiveSubgroups.M20, False)\n    fl = Poly(_T, domain=ZZ.alg_field_from_poly(_T)).factor_list()[1]\n    if len(fl) == 5:\n        return (S5TransitiveSubgroups.C5, True)\n    else:\n        return (S5TransitiveSubgroups.D5, True)",
            "def _galois_group_degree_5_lookup_ext_factor(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses resolvent coeff lookup, plus\\n    factorization over an algebraic extension.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    _T = T\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n    if not sq_disc:\n        return (S5TransitiveSubgroups.M20, False)\n    fl = Poly(_T, domain=ZZ.alg_field_from_poly(_T)).factor_list()[1]\n    if len(fl) == 5:\n        return (S5TransitiveSubgroups.C5, True)\n    else:\n        return (S5TransitiveSubgroups.D5, True)",
            "def _galois_group_degree_5_lookup_ext_factor(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses resolvent coeff lookup, plus\\n    factorization over an algebraic extension.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    _T = T\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n    if not sq_disc:\n        return (S5TransitiveSubgroups.M20, False)\n    fl = Poly(_T, domain=ZZ.alg_field_from_poly(_T)).factor_list()[1]\n    if len(fl) == 5:\n        return (S5TransitiveSubgroups.C5, True)\n    else:\n        return (S5TransitiveSubgroups.D5, True)",
            "def _galois_group_degree_5_lookup_ext_factor(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses resolvent coeff lookup, plus\\n    factorization over an algebraic extension.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    _T = T\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n    if not sq_disc:\n        return (S5TransitiveSubgroups.M20, False)\n    fl = Poly(_T, domain=ZZ.alg_field_from_poly(_T)).factor_list()[1]\n    if len(fl) == 5:\n        return (S5TransitiveSubgroups.C5, True)\n    else:\n        return (S5TransitiveSubgroups.D5, True)",
            "def _galois_group_degree_5_lookup_ext_factor(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the Galois group of a polynomial of degree 5.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.9 of [1], but uses resolvent coeff lookup, plus\\n    factorization over an algebraic extension.\\n\\n    '\n    from sympy.combinatorics.galois import S5TransitiveSubgroups\n    _T = T\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S5TransitiveSubgroups.A5, True) if sq_disc else (S5TransitiveSubgroups.S5, False)\n    if not sq_disc:\n        return (S5TransitiveSubgroups.M20, False)\n    fl = Poly(_T, domain=ZZ.alg_field_from_poly(_T)).factor_list()[1]\n    if len(fl) == 5:\n        return (S5TransitiveSubgroups.C5, True)\n    else:\n        return (S5TransitiveSubgroups.D5, True)"
        ]
    },
    {
        "func_name": "_galois_group_degree_6_lookup",
        "original": "def _galois_group_degree_6_lookup(T, max_tries=30, randomize=False):\n    \"\"\"\n    Compute the Galois group of a polynomial of degree 6.\n\n    Explanation\n    ===========\n\n    Based on Alg 6.3.10 of [1], but uses resolvent coeff lookup.\n\n    \"\"\"\n    from sympy.combinatorics.galois import S6TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    factors_by_deg = defaultdict(list)\n    for (r, _) in fl[1]:\n        factors_by_deg[len(r) - 1].append(r)\n    L = sorted(sum([[d] * len(ff) for (d, ff) in factors_by_deg.items()], []))\n    T_has_sq_disc = has_square_disc(T)\n    if L == [1, 2, 3]:\n        f1 = factors_by_deg[3][0]\n        return (S6TransitiveSubgroups.C6, False) if has_square_disc(f1) else (S6TransitiveSubgroups.D6, False)\n    elif L == [3, 3]:\n        (f1, f2) = factors_by_deg[3]\n        any_square = has_square_disc(f1) or has_square_disc(f2)\n        return (S6TransitiveSubgroups.G18, False) if any_square else (S6TransitiveSubgroups.G36m, False)\n    elif L == [2, 4]:\n        if T_has_sq_disc:\n            return (S6TransitiveSubgroups.S4p, True)\n        else:\n            f1 = factors_by_deg[4][0]\n            return (S6TransitiveSubgroups.A4xC2, False) if has_square_disc(f1) else (S6TransitiveSubgroups.S4xC2, False)\n    elif L == [1, 1, 4]:\n        return (S6TransitiveSubgroups.A4, True) if T_has_sq_disc else (S6TransitiveSubgroups.S4m, False)\n    elif L == [1, 5]:\n        return (S6TransitiveSubgroups.PSL2F5, True) if T_has_sq_disc else (S6TransitiveSubgroups.PGL2F5, False)\n    elif L == [1, 1, 1, 3]:\n        return (S6TransitiveSubgroups.S3, False)\n    assert L == [6]\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 2)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    T_has_sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S6TransitiveSubgroups.A6, True) if T_has_sq_disc else (S6TransitiveSubgroups.S6, False)\n    else:\n        return (S6TransitiveSubgroups.G36p, True) if T_has_sq_disc else (S6TransitiveSubgroups.G72, False)",
        "mutated": [
            "def _galois_group_degree_6_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n    '\\n    Compute the Galois group of a polynomial of degree 6.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.10 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S6TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    factors_by_deg = defaultdict(list)\n    for (r, _) in fl[1]:\n        factors_by_deg[len(r) - 1].append(r)\n    L = sorted(sum([[d] * len(ff) for (d, ff) in factors_by_deg.items()], []))\n    T_has_sq_disc = has_square_disc(T)\n    if L == [1, 2, 3]:\n        f1 = factors_by_deg[3][0]\n        return (S6TransitiveSubgroups.C6, False) if has_square_disc(f1) else (S6TransitiveSubgroups.D6, False)\n    elif L == [3, 3]:\n        (f1, f2) = factors_by_deg[3]\n        any_square = has_square_disc(f1) or has_square_disc(f2)\n        return (S6TransitiveSubgroups.G18, False) if any_square else (S6TransitiveSubgroups.G36m, False)\n    elif L == [2, 4]:\n        if T_has_sq_disc:\n            return (S6TransitiveSubgroups.S4p, True)\n        else:\n            f1 = factors_by_deg[4][0]\n            return (S6TransitiveSubgroups.A4xC2, False) if has_square_disc(f1) else (S6TransitiveSubgroups.S4xC2, False)\n    elif L == [1, 1, 4]:\n        return (S6TransitiveSubgroups.A4, True) if T_has_sq_disc else (S6TransitiveSubgroups.S4m, False)\n    elif L == [1, 5]:\n        return (S6TransitiveSubgroups.PSL2F5, True) if T_has_sq_disc else (S6TransitiveSubgroups.PGL2F5, False)\n    elif L == [1, 1, 1, 3]:\n        return (S6TransitiveSubgroups.S3, False)\n    assert L == [6]\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 2)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    T_has_sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S6TransitiveSubgroups.A6, True) if T_has_sq_disc else (S6TransitiveSubgroups.S6, False)\n    else:\n        return (S6TransitiveSubgroups.G36p, True) if T_has_sq_disc else (S6TransitiveSubgroups.G72, False)",
            "def _galois_group_degree_6_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the Galois group of a polynomial of degree 6.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.10 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S6TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    factors_by_deg = defaultdict(list)\n    for (r, _) in fl[1]:\n        factors_by_deg[len(r) - 1].append(r)\n    L = sorted(sum([[d] * len(ff) for (d, ff) in factors_by_deg.items()], []))\n    T_has_sq_disc = has_square_disc(T)\n    if L == [1, 2, 3]:\n        f1 = factors_by_deg[3][0]\n        return (S6TransitiveSubgroups.C6, False) if has_square_disc(f1) else (S6TransitiveSubgroups.D6, False)\n    elif L == [3, 3]:\n        (f1, f2) = factors_by_deg[3]\n        any_square = has_square_disc(f1) or has_square_disc(f2)\n        return (S6TransitiveSubgroups.G18, False) if any_square else (S6TransitiveSubgroups.G36m, False)\n    elif L == [2, 4]:\n        if T_has_sq_disc:\n            return (S6TransitiveSubgroups.S4p, True)\n        else:\n            f1 = factors_by_deg[4][0]\n            return (S6TransitiveSubgroups.A4xC2, False) if has_square_disc(f1) else (S6TransitiveSubgroups.S4xC2, False)\n    elif L == [1, 1, 4]:\n        return (S6TransitiveSubgroups.A4, True) if T_has_sq_disc else (S6TransitiveSubgroups.S4m, False)\n    elif L == [1, 5]:\n        return (S6TransitiveSubgroups.PSL2F5, True) if T_has_sq_disc else (S6TransitiveSubgroups.PGL2F5, False)\n    elif L == [1, 1, 1, 3]:\n        return (S6TransitiveSubgroups.S3, False)\n    assert L == [6]\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 2)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    T_has_sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S6TransitiveSubgroups.A6, True) if T_has_sq_disc else (S6TransitiveSubgroups.S6, False)\n    else:\n        return (S6TransitiveSubgroups.G36p, True) if T_has_sq_disc else (S6TransitiveSubgroups.G72, False)",
            "def _galois_group_degree_6_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the Galois group of a polynomial of degree 6.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.10 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S6TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    factors_by_deg = defaultdict(list)\n    for (r, _) in fl[1]:\n        factors_by_deg[len(r) - 1].append(r)\n    L = sorted(sum([[d] * len(ff) for (d, ff) in factors_by_deg.items()], []))\n    T_has_sq_disc = has_square_disc(T)\n    if L == [1, 2, 3]:\n        f1 = factors_by_deg[3][0]\n        return (S6TransitiveSubgroups.C6, False) if has_square_disc(f1) else (S6TransitiveSubgroups.D6, False)\n    elif L == [3, 3]:\n        (f1, f2) = factors_by_deg[3]\n        any_square = has_square_disc(f1) or has_square_disc(f2)\n        return (S6TransitiveSubgroups.G18, False) if any_square else (S6TransitiveSubgroups.G36m, False)\n    elif L == [2, 4]:\n        if T_has_sq_disc:\n            return (S6TransitiveSubgroups.S4p, True)\n        else:\n            f1 = factors_by_deg[4][0]\n            return (S6TransitiveSubgroups.A4xC2, False) if has_square_disc(f1) else (S6TransitiveSubgroups.S4xC2, False)\n    elif L == [1, 1, 4]:\n        return (S6TransitiveSubgroups.A4, True) if T_has_sq_disc else (S6TransitiveSubgroups.S4m, False)\n    elif L == [1, 5]:\n        return (S6TransitiveSubgroups.PSL2F5, True) if T_has_sq_disc else (S6TransitiveSubgroups.PGL2F5, False)\n    elif L == [1, 1, 1, 3]:\n        return (S6TransitiveSubgroups.S3, False)\n    assert L == [6]\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 2)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    T_has_sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S6TransitiveSubgroups.A6, True) if T_has_sq_disc else (S6TransitiveSubgroups.S6, False)\n    else:\n        return (S6TransitiveSubgroups.G36p, True) if T_has_sq_disc else (S6TransitiveSubgroups.G72, False)",
            "def _galois_group_degree_6_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the Galois group of a polynomial of degree 6.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.10 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S6TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    factors_by_deg = defaultdict(list)\n    for (r, _) in fl[1]:\n        factors_by_deg[len(r) - 1].append(r)\n    L = sorted(sum([[d] * len(ff) for (d, ff) in factors_by_deg.items()], []))\n    T_has_sq_disc = has_square_disc(T)\n    if L == [1, 2, 3]:\n        f1 = factors_by_deg[3][0]\n        return (S6TransitiveSubgroups.C6, False) if has_square_disc(f1) else (S6TransitiveSubgroups.D6, False)\n    elif L == [3, 3]:\n        (f1, f2) = factors_by_deg[3]\n        any_square = has_square_disc(f1) or has_square_disc(f2)\n        return (S6TransitiveSubgroups.G18, False) if any_square else (S6TransitiveSubgroups.G36m, False)\n    elif L == [2, 4]:\n        if T_has_sq_disc:\n            return (S6TransitiveSubgroups.S4p, True)\n        else:\n            f1 = factors_by_deg[4][0]\n            return (S6TransitiveSubgroups.A4xC2, False) if has_square_disc(f1) else (S6TransitiveSubgroups.S4xC2, False)\n    elif L == [1, 1, 4]:\n        return (S6TransitiveSubgroups.A4, True) if T_has_sq_disc else (S6TransitiveSubgroups.S4m, False)\n    elif L == [1, 5]:\n        return (S6TransitiveSubgroups.PSL2F5, True) if T_has_sq_disc else (S6TransitiveSubgroups.PGL2F5, False)\n    elif L == [1, 1, 1, 3]:\n        return (S6TransitiveSubgroups.S3, False)\n    assert L == [6]\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 2)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    T_has_sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S6TransitiveSubgroups.A6, True) if T_has_sq_disc else (S6TransitiveSubgroups.S6, False)\n    else:\n        return (S6TransitiveSubgroups.G36p, True) if T_has_sq_disc else (S6TransitiveSubgroups.G72, False)",
            "def _galois_group_degree_6_lookup(T, max_tries=30, randomize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the Galois group of a polynomial of degree 6.\\n\\n    Explanation\\n    ===========\\n\\n    Based on Alg 6.3.10 of [1], but uses resolvent coeff lookup.\\n\\n    '\n    from sympy.combinatorics.galois import S6TransitiveSubgroups\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 1)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    fl = dup_factor_list(R_dup, ZZ)\n    factors_by_deg = defaultdict(list)\n    for (r, _) in fl[1]:\n        factors_by_deg[len(r) - 1].append(r)\n    L = sorted(sum([[d] * len(ff) for (d, ff) in factors_by_deg.items()], []))\n    T_has_sq_disc = has_square_disc(T)\n    if L == [1, 2, 3]:\n        f1 = factors_by_deg[3][0]\n        return (S6TransitiveSubgroups.C6, False) if has_square_disc(f1) else (S6TransitiveSubgroups.D6, False)\n    elif L == [3, 3]:\n        (f1, f2) = factors_by_deg[3]\n        any_square = has_square_disc(f1) or has_square_disc(f2)\n        return (S6TransitiveSubgroups.G18, False) if any_square else (S6TransitiveSubgroups.G36m, False)\n    elif L == [2, 4]:\n        if T_has_sq_disc:\n            return (S6TransitiveSubgroups.S4p, True)\n        else:\n            f1 = factors_by_deg[4][0]\n            return (S6TransitiveSubgroups.A4xC2, False) if has_square_disc(f1) else (S6TransitiveSubgroups.S4xC2, False)\n    elif L == [1, 1, 4]:\n        return (S6TransitiveSubgroups.A4, True) if T_has_sq_disc else (S6TransitiveSubgroups.S4m, False)\n    elif L == [1, 5]:\n        return (S6TransitiveSubgroups.PSL2F5, True) if T_has_sq_disc else (S6TransitiveSubgroups.PGL2F5, False)\n    elif L == [1, 1, 1, 3]:\n        return (S6TransitiveSubgroups.S3, False)\n    assert L == [6]\n    history = set()\n    for i in range(max_tries):\n        R_dup = get_resolvent_by_lookup(T, 2)\n        if dup_sqf_p(R_dup, ZZ):\n            break\n        (_, T) = tschirnhausen_transformation(T, max_tries=max_tries, history=history, fixed_order=not randomize)\n    else:\n        raise MaxTriesException\n    T_has_sq_disc = has_square_disc(T)\n    if dup_irreducible_p(R_dup, ZZ):\n        return (S6TransitiveSubgroups.A6, True) if T_has_sq_disc else (S6TransitiveSubgroups.S6, False)\n    else:\n        return (S6TransitiveSubgroups.G36p, True) if T_has_sq_disc else (S6TransitiveSubgroups.G72, False)"
        ]
    },
    {
        "func_name": "galois_group",
        "original": "@public\ndef galois_group(f, *gens, by_name=False, max_tries=30, randomize=False, **args):\n    \"\"\"\n    Compute the Galois group for polynomials *f* up to degree 6.\n\n    Examples\n    ========\n\n    >>> from sympy import galois_group\n    >>> from sympy.abc import x\n    >>> f = x**4 + 1\n    >>> G, alt = galois_group(f)\n    >>> print(G)\n    PermutationGroup([\n    (0 1)(2 3),\n    (0 2)(1 3)])\n\n    The group is returned along with a boolean, indicating whether it is\n    contained in the alternating group $A_n$, where $n$ is the degree of *T*.\n    Along with other group properties, this can help determine which group it\n    is:\n\n    >>> alt\n    True\n    >>> G.order()\n    4\n\n    Alternatively, the group can be returned by name:\n\n    >>> G_name, _ = galois_group(f, by_name=True)\n    >>> print(G_name)\n    S4TransitiveSubgroups.V\n\n    The group itself can then be obtained by calling the name's\n    ``get_perm_group()`` method:\n\n    >>> G_name.get_perm_group()\n    PermutationGroup([\n    (0 1)(2 3),\n    (0 2)(1 3)])\n\n    Group names are values of the enum classes\n    :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`,\n    :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`,\n    etc.\n\n    Parameters\n    ==========\n\n    f : Expr\n        Irreducible polynomial over :ref:`ZZ` or :ref:`QQ`, whose Galois group\n        is to be determined.\n    gens : optional list of symbols\n        For converting *f* to Poly, and will be passed on to the\n        :py:func:`~.poly_from_expr` function.\n    by_name : bool, default False\n        If ``True``, the Galois group will be returned by name.\n        Otherwise it will be returned as a :py:class:`~.PermutationGroup`.\n    max_tries : int, default 30\n        Make at most this many attempts in those steps that involve\n        generating Tschirnhausen transformations.\n    randomize : bool, default False\n        If ``True``, then use random coefficients when generating Tschirnhausen\n        transformations. Otherwise try transformations in a fixed order. Both\n        approaches start with small coefficients and degrees and work upward.\n    args : optional\n        For converting *f* to Poly, and will be passed on to the\n        :py:func:`~.poly_from_expr` function.\n\n    Returns\n    =======\n\n    Pair ``(G, alt)``\n        The first element ``G`` indicates the Galois group. It is an instance\n        of one of the :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`\n        :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`, etc. enum\n        classes if *by_name* was ``True``, and a :py:class:`~.PermutationGroup`\n        if ``False``.\n\n        The second element is a boolean, saying whether the group is contained\n        in the alternating group $A_n$ ($n$ the degree of *T*).\n\n    Raises\n    ======\n\n    ValueError\n        if *f* is of an unsupported degree.\n\n    MaxTriesException\n        if could not complete before exceeding *max_tries* in those steps\n        that involve generating Tschirnhausen transformations.\n\n    See Also\n    ========\n\n    .Poly.galois_group\n\n    \"\"\"\n    gens = gens or []\n    args = args or {}\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('galois_group', 1, exc)\n    return F.galois_group(by_name=by_name, max_tries=max_tries, randomize=randomize)",
        "mutated": [
            "@public\ndef galois_group(f, *gens, by_name=False, max_tries=30, randomize=False, **args):\n    if False:\n        i = 10\n    \"\\n    Compute the Galois group for polynomials *f* up to degree 6.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import galois_group\\n    >>> from sympy.abc import x\\n    >>> f = x**4 + 1\\n    >>> G, alt = galois_group(f)\\n    >>> print(G)\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    The group is returned along with a boolean, indicating whether it is\\n    contained in the alternating group $A_n$, where $n$ is the degree of *T*.\\n    Along with other group properties, this can help determine which group it\\n    is:\\n\\n    >>> alt\\n    True\\n    >>> G.order()\\n    4\\n\\n    Alternatively, the group can be returned by name:\\n\\n    >>> G_name, _ = galois_group(f, by_name=True)\\n    >>> print(G_name)\\n    S4TransitiveSubgroups.V\\n\\n    The group itself can then be obtained by calling the name's\\n    ``get_perm_group()`` method:\\n\\n    >>> G_name.get_perm_group()\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    Group names are values of the enum classes\\n    :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`,\\n    :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`,\\n    etc.\\n\\n    Parameters\\n    ==========\\n\\n    f : Expr\\n        Irreducible polynomial over :ref:`ZZ` or :ref:`QQ`, whose Galois group\\n        is to be determined.\\n    gens : optional list of symbols\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n    by_name : bool, default False\\n        If ``True``, the Galois group will be returned by name.\\n        Otherwise it will be returned as a :py:class:`~.PermutationGroup`.\\n    max_tries : int, default 30\\n        Make at most this many attempts in those steps that involve\\n        generating Tschirnhausen transformations.\\n    randomize : bool, default False\\n        If ``True``, then use random coefficients when generating Tschirnhausen\\n        transformations. Otherwise try transformations in a fixed order. Both\\n        approaches start with small coefficients and degrees and work upward.\\n    args : optional\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(G, alt)``\\n        The first element ``G`` indicates the Galois group. It is an instance\\n        of one of the :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`\\n        :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`, etc. enum\\n        classes if *by_name* was ``True``, and a :py:class:`~.PermutationGroup`\\n        if ``False``.\\n\\n        The second element is a boolean, saying whether the group is contained\\n        in the alternating group $A_n$ ($n$ the degree of *T*).\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        if *f* is of an unsupported degree.\\n\\n    MaxTriesException\\n        if could not complete before exceeding *max_tries* in those steps\\n        that involve generating Tschirnhausen transformations.\\n\\n    See Also\\n    ========\\n\\n    .Poly.galois_group\\n\\n    \"\n    gens = gens or []\n    args = args or {}\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('galois_group', 1, exc)\n    return F.galois_group(by_name=by_name, max_tries=max_tries, randomize=randomize)",
            "@public\ndef galois_group(f, *gens, by_name=False, max_tries=30, randomize=False, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute the Galois group for polynomials *f* up to degree 6.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import galois_group\\n    >>> from sympy.abc import x\\n    >>> f = x**4 + 1\\n    >>> G, alt = galois_group(f)\\n    >>> print(G)\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    The group is returned along with a boolean, indicating whether it is\\n    contained in the alternating group $A_n$, where $n$ is the degree of *T*.\\n    Along with other group properties, this can help determine which group it\\n    is:\\n\\n    >>> alt\\n    True\\n    >>> G.order()\\n    4\\n\\n    Alternatively, the group can be returned by name:\\n\\n    >>> G_name, _ = galois_group(f, by_name=True)\\n    >>> print(G_name)\\n    S4TransitiveSubgroups.V\\n\\n    The group itself can then be obtained by calling the name's\\n    ``get_perm_group()`` method:\\n\\n    >>> G_name.get_perm_group()\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    Group names are values of the enum classes\\n    :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`,\\n    :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`,\\n    etc.\\n\\n    Parameters\\n    ==========\\n\\n    f : Expr\\n        Irreducible polynomial over :ref:`ZZ` or :ref:`QQ`, whose Galois group\\n        is to be determined.\\n    gens : optional list of symbols\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n    by_name : bool, default False\\n        If ``True``, the Galois group will be returned by name.\\n        Otherwise it will be returned as a :py:class:`~.PermutationGroup`.\\n    max_tries : int, default 30\\n        Make at most this many attempts in those steps that involve\\n        generating Tschirnhausen transformations.\\n    randomize : bool, default False\\n        If ``True``, then use random coefficients when generating Tschirnhausen\\n        transformations. Otherwise try transformations in a fixed order. Both\\n        approaches start with small coefficients and degrees and work upward.\\n    args : optional\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(G, alt)``\\n        The first element ``G`` indicates the Galois group. It is an instance\\n        of one of the :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`\\n        :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`, etc. enum\\n        classes if *by_name* was ``True``, and a :py:class:`~.PermutationGroup`\\n        if ``False``.\\n\\n        The second element is a boolean, saying whether the group is contained\\n        in the alternating group $A_n$ ($n$ the degree of *T*).\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        if *f* is of an unsupported degree.\\n\\n    MaxTriesException\\n        if could not complete before exceeding *max_tries* in those steps\\n        that involve generating Tschirnhausen transformations.\\n\\n    See Also\\n    ========\\n\\n    .Poly.galois_group\\n\\n    \"\n    gens = gens or []\n    args = args or {}\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('galois_group', 1, exc)\n    return F.galois_group(by_name=by_name, max_tries=max_tries, randomize=randomize)",
            "@public\ndef galois_group(f, *gens, by_name=False, max_tries=30, randomize=False, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute the Galois group for polynomials *f* up to degree 6.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import galois_group\\n    >>> from sympy.abc import x\\n    >>> f = x**4 + 1\\n    >>> G, alt = galois_group(f)\\n    >>> print(G)\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    The group is returned along with a boolean, indicating whether it is\\n    contained in the alternating group $A_n$, where $n$ is the degree of *T*.\\n    Along with other group properties, this can help determine which group it\\n    is:\\n\\n    >>> alt\\n    True\\n    >>> G.order()\\n    4\\n\\n    Alternatively, the group can be returned by name:\\n\\n    >>> G_name, _ = galois_group(f, by_name=True)\\n    >>> print(G_name)\\n    S4TransitiveSubgroups.V\\n\\n    The group itself can then be obtained by calling the name's\\n    ``get_perm_group()`` method:\\n\\n    >>> G_name.get_perm_group()\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    Group names are values of the enum classes\\n    :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`,\\n    :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`,\\n    etc.\\n\\n    Parameters\\n    ==========\\n\\n    f : Expr\\n        Irreducible polynomial over :ref:`ZZ` or :ref:`QQ`, whose Galois group\\n        is to be determined.\\n    gens : optional list of symbols\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n    by_name : bool, default False\\n        If ``True``, the Galois group will be returned by name.\\n        Otherwise it will be returned as a :py:class:`~.PermutationGroup`.\\n    max_tries : int, default 30\\n        Make at most this many attempts in those steps that involve\\n        generating Tschirnhausen transformations.\\n    randomize : bool, default False\\n        If ``True``, then use random coefficients when generating Tschirnhausen\\n        transformations. Otherwise try transformations in a fixed order. Both\\n        approaches start with small coefficients and degrees and work upward.\\n    args : optional\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(G, alt)``\\n        The first element ``G`` indicates the Galois group. It is an instance\\n        of one of the :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`\\n        :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`, etc. enum\\n        classes if *by_name* was ``True``, and a :py:class:`~.PermutationGroup`\\n        if ``False``.\\n\\n        The second element is a boolean, saying whether the group is contained\\n        in the alternating group $A_n$ ($n$ the degree of *T*).\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        if *f* is of an unsupported degree.\\n\\n    MaxTriesException\\n        if could not complete before exceeding *max_tries* in those steps\\n        that involve generating Tschirnhausen transformations.\\n\\n    See Also\\n    ========\\n\\n    .Poly.galois_group\\n\\n    \"\n    gens = gens or []\n    args = args or {}\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('galois_group', 1, exc)\n    return F.galois_group(by_name=by_name, max_tries=max_tries, randomize=randomize)",
            "@public\ndef galois_group(f, *gens, by_name=False, max_tries=30, randomize=False, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute the Galois group for polynomials *f* up to degree 6.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import galois_group\\n    >>> from sympy.abc import x\\n    >>> f = x**4 + 1\\n    >>> G, alt = galois_group(f)\\n    >>> print(G)\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    The group is returned along with a boolean, indicating whether it is\\n    contained in the alternating group $A_n$, where $n$ is the degree of *T*.\\n    Along with other group properties, this can help determine which group it\\n    is:\\n\\n    >>> alt\\n    True\\n    >>> G.order()\\n    4\\n\\n    Alternatively, the group can be returned by name:\\n\\n    >>> G_name, _ = galois_group(f, by_name=True)\\n    >>> print(G_name)\\n    S4TransitiveSubgroups.V\\n\\n    The group itself can then be obtained by calling the name's\\n    ``get_perm_group()`` method:\\n\\n    >>> G_name.get_perm_group()\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    Group names are values of the enum classes\\n    :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`,\\n    :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`,\\n    etc.\\n\\n    Parameters\\n    ==========\\n\\n    f : Expr\\n        Irreducible polynomial over :ref:`ZZ` or :ref:`QQ`, whose Galois group\\n        is to be determined.\\n    gens : optional list of symbols\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n    by_name : bool, default False\\n        If ``True``, the Galois group will be returned by name.\\n        Otherwise it will be returned as a :py:class:`~.PermutationGroup`.\\n    max_tries : int, default 30\\n        Make at most this many attempts in those steps that involve\\n        generating Tschirnhausen transformations.\\n    randomize : bool, default False\\n        If ``True``, then use random coefficients when generating Tschirnhausen\\n        transformations. Otherwise try transformations in a fixed order. Both\\n        approaches start with small coefficients and degrees and work upward.\\n    args : optional\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(G, alt)``\\n        The first element ``G`` indicates the Galois group. It is an instance\\n        of one of the :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`\\n        :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`, etc. enum\\n        classes if *by_name* was ``True``, and a :py:class:`~.PermutationGroup`\\n        if ``False``.\\n\\n        The second element is a boolean, saying whether the group is contained\\n        in the alternating group $A_n$ ($n$ the degree of *T*).\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        if *f* is of an unsupported degree.\\n\\n    MaxTriesException\\n        if could not complete before exceeding *max_tries* in those steps\\n        that involve generating Tschirnhausen transformations.\\n\\n    See Also\\n    ========\\n\\n    .Poly.galois_group\\n\\n    \"\n    gens = gens or []\n    args = args or {}\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('galois_group', 1, exc)\n    return F.galois_group(by_name=by_name, max_tries=max_tries, randomize=randomize)",
            "@public\ndef galois_group(f, *gens, by_name=False, max_tries=30, randomize=False, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute the Galois group for polynomials *f* up to degree 6.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import galois_group\\n    >>> from sympy.abc import x\\n    >>> f = x**4 + 1\\n    >>> G, alt = galois_group(f)\\n    >>> print(G)\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    The group is returned along with a boolean, indicating whether it is\\n    contained in the alternating group $A_n$, where $n$ is the degree of *T*.\\n    Along with other group properties, this can help determine which group it\\n    is:\\n\\n    >>> alt\\n    True\\n    >>> G.order()\\n    4\\n\\n    Alternatively, the group can be returned by name:\\n\\n    >>> G_name, _ = galois_group(f, by_name=True)\\n    >>> print(G_name)\\n    S4TransitiveSubgroups.V\\n\\n    The group itself can then be obtained by calling the name's\\n    ``get_perm_group()`` method:\\n\\n    >>> G_name.get_perm_group()\\n    PermutationGroup([\\n    (0 1)(2 3),\\n    (0 2)(1 3)])\\n\\n    Group names are values of the enum classes\\n    :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`,\\n    :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`,\\n    etc.\\n\\n    Parameters\\n    ==========\\n\\n    f : Expr\\n        Irreducible polynomial over :ref:`ZZ` or :ref:`QQ`, whose Galois group\\n        is to be determined.\\n    gens : optional list of symbols\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n    by_name : bool, default False\\n        If ``True``, the Galois group will be returned by name.\\n        Otherwise it will be returned as a :py:class:`~.PermutationGroup`.\\n    max_tries : int, default 30\\n        Make at most this many attempts in those steps that involve\\n        generating Tschirnhausen transformations.\\n    randomize : bool, default False\\n        If ``True``, then use random coefficients when generating Tschirnhausen\\n        transformations. Otherwise try transformations in a fixed order. Both\\n        approaches start with small coefficients and degrees and work upward.\\n    args : optional\\n        For converting *f* to Poly, and will be passed on to the\\n        :py:func:`~.poly_from_expr` function.\\n\\n    Returns\\n    =======\\n\\n    Pair ``(G, alt)``\\n        The first element ``G`` indicates the Galois group. It is an instance\\n        of one of the :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`\\n        :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`, etc. enum\\n        classes if *by_name* was ``True``, and a :py:class:`~.PermutationGroup`\\n        if ``False``.\\n\\n        The second element is a boolean, saying whether the group is contained\\n        in the alternating group $A_n$ ($n$ the degree of *T*).\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        if *f* is of an unsupported degree.\\n\\n    MaxTriesException\\n        if could not complete before exceeding *max_tries* in those steps\\n        that involve generating Tschirnhausen transformations.\\n\\n    See Also\\n    ========\\n\\n    .Poly.galois_group\\n\\n    \"\n    gens = gens or []\n    args = args or {}\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('galois_group', 1, exc)\n    return F.galois_group(by_name=by_name, max_tries=max_tries, randomize=randomize)"
        ]
    }
]