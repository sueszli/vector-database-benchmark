"""
Copyright 2023 Ettus Research, A National Instruments Brand.

SPDX-License-Identifier: GPL-3.0-or-later
"""
import sys
MAX_NUM_CHANNELS = 4
MAIN_TMPL = 'id: uhd_rfnoc_replay\nlabel: RFNoC Replay Block\ncategory: \'[Core]/UHD/RFNoC/Blocks\'\n\nparameters:\n- id: num_in_ports\n  label: In Port Count\n  dtype: int\n  options: [ ${", ".join([str(n) for n in range(1, max_num_chans+1)])} ]\n  default: 1\n  hide: ${\'$\'}{ \'part\' }\n- id: num_out_ports\n  label: Out Port Count\n  dtype: int\n  options: [ ${", ".join([str(n) for n in range(1, max_num_chans+1)])} ]\n  default: 1\n  hide: ${\'$\'}{ \'part\' }\n- id: block_args\n  label: Block Args\n  dtype: string\n  default: ""\n  hide: ${\'$\'}{ \'part\' if not block_args else \'none\'}\n- id: device_select\n  label: Device Select\n  dtype: int\n  default: -1\n  hide: ${\'$\'}{ \'part\' if device_select == -1 else \'none\'}\n- id: instance_index\n  label: Instance Select\n  dtype: int\n  default: -1\n  hide: ${\'$\'}{ \'part\' if instance_index == -1 else \'none\'}\n${coeffs_params}\ninputs:\n- domain: message\n  id: command\n  optional: true\n${input_params}\n\noutputs:\n- domain: message\n  id: debug_msgs\n  optional: true\n${output_params}\n\ntemplates:\n  imports: |-\n    from gnuradio import uhd\n  make: |-\n    uhd.rfnoc_replay(\n        self.rfnoc_graph,\n        uhd.device_addr(${\'$\'}{block_args}),\n        ${\'$\'}{device_select},\n        ${\'$\'}{instance_index})\n${init_params}  callbacks:\n${callback_params}\n\ndocumentation: |-\n  This RFNoC block can record signals to memory from any of the input ports and play\n  back those signals from any of the output ports. The memory throughout the block\n  is shared among all ports, so it is the responsibility of the user to manage. The offset\n  of memory and size of memory used is controlled by \'Record Offset\' (record_offset) and\n  \'Record Size\' (record_size) for Record and \'Play Offset\' (play_offset) and \'Play Size\'\n  (play_size) for playback.\n\n  For both record and playback, the offset and the size must be aligned to the memory\'s\n  word size. For playback, the size must also be aligned to the size of an item. An item\n  is a single unit of data as defined by the data type of a port. It is the user\'s\n  responsibility to manage the types of the individual record and the playback ports.\n\n  One key configuration of playback is the packet size. Larger packet sizes provide for\n  better throughput while smaller packet sizes provide for lower latency.\n\n  To send commands such as record or play to the replay block, the user must send a\n  dictionary command. This can be accomplished using the Replay Msg Push Button.\n  The only required key is \'command\'. Other optional keys are \'port\', \'offset\', \'size\',\n  and \'time\'. \'Port\' will default to 0, \'time\' will default to 0.0. \'offset\' and \'size\'\n  will default to using the block properties.\n\n  There is also an optional debug output port that can be used to print output from\n  commands such as getting port record fullness or replay block size\n\nfile_format: 1\n'
COEFFS_PARAM = "- id: record_offset${n}\n  label: 'Ch${n}: Record Offset'\n  dtype: int\n  default: 0\n  hide: ${'$'}{ 'none' if num_in_ports > ${n} else 'all' }\n- id: record_size${n}\n  label: 'Ch${n}: Record Size'\n  dtype: int\n  default: 80000\n  hide: ${'$'}{ 'none' if num_in_ports > ${n} else 'all' }\n- id: record_type${n}\n  label: 'Ch${n}: Record Type'\n  dtype: enum\n  options: ['s16', 'sc16', 'u8']\n  default: 's16'\n  hide: ${'$'}{ 'part' if num_in_ports > ${n} else 'all' }\n- id: play_offset${n}\n  label: 'Ch${n}: Play Offset'\n  dtype: int\n  default: 0\n  hide: ${'$'}{ 'none' if num_out_ports > ${n} else 'all' }\n- id: play_size${n}\n  label: 'Ch${n}: Play Size'\n  dtype: int\n  default: 80000\n  hide: ${'$'}{ 'none' if num_out_ports > ${n} else 'all' }\n- id: play_type${n}\n  label: 'Ch${n}: Play Type'\n  dtype: enum\n  options: ['s16', 'sc16', 'u8']\n  default: 's16'\n  hide: ${'$'}{ 'part' if num_out_ports > ${n} else 'all' }\n"
INPUT_PARAM = "- domain: rfnoc\n  dtype: '${'$'}{record_type${n}}'\n  label: 'in${n}'\n  hide: ${'$'}{ num_in_ports <= ${n} }\n"
OUTPUT_PARAM = "- domain: rfnoc\n  dtype: '${'$'}{play_type${n}}'\n  label: 'out${n}'\n  hide: ${'$'}{ num_out_ports <= ${n} }\n"
INIT_PARAM = '    ${\'%\'} if context.get(\'num_in_ports\')() > ${n}:\n    self.${\'$\'}{id}.set_record_type("${\'$\'}{record_type${n}}", ${n})\n    self.${\'$\'}{id}.set_property(\'record_offset\',${\'$\'}{record_offset${n}}, ${n}, typename=\'uint64_t\')\n    self.${\'$\'}{id}.set_property(\'record_size\',${\'$\'}{record_size${n}}, ${n}, typename=\'uint64_t\')\n    ${\'%\'} endif\n    ${\'%\'} if context.get(\'num_out_ports\')() > ${n}:\n    self.${\'$\'}{id}.set_play_type("${\'$\'}{play_type${n}}", ${n})\n    self.${\'$\'}{id}.set_property(\'play_offset\',${\'$\'}{play_offset${n}}, ${n}, typename=\'uint64_t\')\n    self.${\'$\'}{id}.set_property(\'play_size\',${\'$\'}{play_size${n}}, ${n}, typename=\'uint64_t\')\n    ${\'%\'} endif\n'
CALLBACKS_PARAM = '  - |\n    ${\'%\'} if context.get(\'num_in_ports\')() > ${n}:\n    self.${\'$\'}{id}.set_property(\'record_offset\',${\'$\'}{record_offset${n}}, ${n}, typename=\'uint64_t\')\n    ${\'%\'} endif\n  - |\n    ${\'%\'} if context.get(\'num_in_ports\')() > ${n}:\n    self.${\'$\'}{id}.set_property(\'record_size\',${\'$\'}{record_size${n}}, ${n}, typename=\'uint64_t\')\n    ${\'%\'} endif\n  - |\n    ${\'%\'} if context.get(\'num_in_ports\')() > ${n}:\n    self.${\'$\'}{id}.set_record_type("${\'$\'}{record_type${n}}", ${n})\n    ${\'%\'} endif\n  - |\n    ${\'%\'} if context.get(\'num_out_ports\')() > ${n}:\n    self.${\'$\'}{id}.set_property(\'play_offset\',${\'$\'}{play_offset${n}}, ${n}, typename=\'uint64_t\')\n    ${\'%\'} endif\n  - |\n    ${\'%\'} if context.get(\'num_out_ports\')() > ${n}:\n    self.${\'$\'}{id}.set_property(\'play_size\',${\'$\'}{play_size${n}}, ${n}, typename=\'uint64_t\')\n    ${\'%\'} endif\n  - |\n    ${\'%\'} if context.get(\'num_out_ports\')() > ${n}:\n    self.${\'$\'}{id}.set_play_type("${\'$\'}{play_type${n}}", ${n})\n    ${\'%\'} endif\n'

def parse_tmpl(_tmpl, **kwargs):
    if False:
        i = 10
        return i + 15
    ' Render _tmpl using the kwargs '
    from mako.template import Template
    block_template = Template(_tmpl)
    return str(block_template.render(**kwargs))
if __name__ == '__main__':
    file = sys.argv[1]
    coeffs_params = ''.join([parse_tmpl(COEFFS_PARAM, n=n) for n in range(MAX_NUM_CHANNELS)])
    input_params = ''.join([parse_tmpl(INPUT_PARAM, n=n) for n in range(MAX_NUM_CHANNELS)])
    output_params = ''.join([parse_tmpl(OUTPUT_PARAM, n=n) for n in range(MAX_NUM_CHANNELS)])
    init_params = ''.join([parse_tmpl(INIT_PARAM, n=n) for n in range(MAX_NUM_CHANNELS)])
    callback_params = ''.join([parse_tmpl(CALLBACKS_PARAM, n=n) for n in range(MAX_NUM_CHANNELS)])
    open(file, 'w').write(parse_tmpl(MAIN_TMPL, max_num_chans=MAX_NUM_CHANNELS, coeffs_params=coeffs_params, input_params=input_params, output_params=output_params, init_params=init_params, callback_params=callback_params))