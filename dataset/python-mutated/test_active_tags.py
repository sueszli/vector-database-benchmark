"""
Functionals tests for active tag-matcher (mod:`behave.tag_matcher`).
"""
from __future__ import absolute_import, print_function
import pytest
from behave.tag_matcher import ActiveTagMatcher

class TestActivateTags(object):
    VALUE_PROVIDER = {'foo': 'Frank', 'bar': 'Bob'}

    def check_should_run_with_active_tags(self, case, expected, tags):
        if False:
            for i in range(10):
                print('nop')
        case += ' (tags: {tags})'
        tag_matcher = ActiveTagMatcher(self.VALUE_PROVIDER)
        actual_result1 = tag_matcher.should_run_with(tags)
        actual_result2 = tag_matcher.should_exclude_with(tags)
        assert expected == actual_result1, case.format(tags=tags)
        assert (not expected) == actual_result2

    @pytest.mark.parametrize('case, expected, tags', [('use.with_foo=VALUE matches', True, ['use.with_foo=Frank']), ('use.with_foo=VALUE mismatches', False, ['use.with_foo=OTHER']), ('not.with_foo=VALUE matches', False, ['not.with_foo=Frank']), ('not.with_foo=VALUE mismatches', True, ['not.with_foo=OTHER']), ('NO_TAGS', True, [])])
    def test_one_tag_for_category1(self, case, expected, tags):
        if False:
            i = 10
            return i + 15
        self.check_should_run_with_active_tags(case, expected, tags)

    @pytest.mark.parametrize('case, expected, tags', [('use.with_bar=Bob matches', True, ['use.with_bar=Bob']), ('use.with_bar=VALUE mismatches', False, ['use.with_bar=OTHER']), ('not.with_bar=VALUE matches', False, ['not.with_bar=Bob']), ('not.with_bar=VALUE mismatches', True, ['not.with_bar=OTHER'])])
    def test_one_tag_for_category2(self, case, expected, tags):
        if False:
            print('Hello World!')
        self.check_should_run_with_active_tags(case, expected, tags)

    @pytest.mark.parametrize('case, expected, tags', [('2x use.with_foo=VALUE: one matches', True, ['use.with_foo=Frank', 'use.with_foo=OTHER']), ('2x not.with_foo=VALUE: one matches', False, ['not.with_foo=Frank', 'not.with_foo=OTHER']), ('1x use./not.with_foo=VALUE: use-matches', True, ['use.with_foo=Frank', 'not.with_foo=OTHER']), ('1x use./not.with_foo=VALUE: not-matches', False, ['not.with_foo=Frank', 'use.with_foo=OTHER'])])
    def test_one_category_with_two_tags(self, case, expected, tags):
        if False:
            return 10
        self.check_should_run_with_active_tags(case, expected, tags)

    @pytest.mark.parametrize('case, expected, tags', [('3x use.with_foo=VALUE: one matches', True, ['use.with_foo=Frank', 'use.with_foo=OTHER_1', 'use.with_foo=OTHER_2']), ('3x not.with_foo=VALUE: one matches', False, ['not.with_foo=Frank', 'not.with_foo=OTHER_1', 'not.with_foo=OTHER_2']), ('2x use.with_foo=VALUE: use-matches', True, ['use.with_foo=Frank', 'use.with_foo=OTHER_1', 'not.with_foo=OTHER_2']), ('2x not.with_foo=VALUE: not-matches', False, ['not.with_foo=Frank', 'not.with_foo=OTHER_1', 'use.with_foo=OTHER_2']), ('1x use.with_foo=VALUE: use-matches', True, ['use.with_foo=Frank', 'not.with_foo=OTHER_1', 'not.with_foo=OTHER_2']), ('1x not.with_foo=VALUE: not-matches', False, ['not.with_foo=Frank', 'use.with_foo=OTHER_1', 'use.with_foo=OTHER_2'])])
    def test_one_category_with_three_tags(self, case, expected, tags):
        if False:
            return 10
        self.check_should_run_with_active_tags(case, expected, tags)

    @pytest.mark.parametrize('case, expected, tags', [('use.with_... 2x matches', True, ['use.with_foo=Frank', 'use.with_bar=Bob']), ('use.with_... 1x matches', False, ['use.with_foo=Frank', 'use.with_bar=OTHER']), ('use.with_... 1x matches', False, ['use.with_foo=OTHER', 'use.with_bar=OTHER']), ('use.with_... 1x matches', False, ['use.with_foo=OTHER', 'use.with_bar=Bob']), ('use.with_... 0x matches', False, ['use.with_foo=OTHER', 'use.with_bar=OTHER']), ('not.with_... 2x matches', False, ['not.with_foo=Frank', 'not.with_bar=Bob']), ('not.with_... 1x matches', False, ['not.with_foo=Frank', 'not.with_bar=OTHER']), ('not.with_... 1x matches', False, ['not.with_foo=OTHER', 'not.with_bar=Bob']), ('not.with_... 0x matches', True, ['not.with_foo=OTHER', 'not.with_bar=OTHER']), ('use./not.with_... use-matches', True, ['use.with_foo=Frank', 'not.with_bar=OTHER']), ('use./not.with_... not-matches', False, ['use.with_foo=OTHER', 'not.with_bar=Bob']), ('use./not.with_... 2x matches', False, ['use.with_foo=Frank', 'not.with_bar=Bob']), ('use./not.with_... 0x matches', False, ['use.with_foo=OTHER', 'not.with_bar=OTHER'])])
    def test_two_categories_with_two_tags(self, case, expected, tags):
        if False:
            while True:
                i = 10
        self.check_should_run_with_active_tags(case, expected, tags)

    @pytest.mark.parametrize('case, expected, tags', [('use.with_... 2x matches', True, ['use.with_foo=Frank', 'use.with_foo=OTHER', 'use.with_bar=Bob']), ('use.with_... 1x matches', False, ['use.with_foo=Frank', 'use.with_foo=OTHER', 'use.with_bar=OTHER']), ('use.with_... 1x matches', False, ['use.with_foo=OTHER', 'use.with_foo=Frank', 'use.with_bar=OTHER']), ('use.with_... 1x matches', False, ['use.with_foo=OTHER', 'use.with_foo=OTHER2', 'use.with_bar=Bob']), ('use.with_... 0x matches', False, ['use.with_foo=OTHER', 'use.with_bar=OTHER2', 'use.with_bar=OTHER']), ('not.with_... 2x matches', False, ['not.with_foo=Frank', 'not.with_foo=OTHER', 'not.with_bar=Bob']), ('not.with_... 1x matches', False, ['not.with_foo=Frank', 'not.with_foo=OTHER', 'not.with_bar=OTHER']), ('not.with_... 1x matches', False, ['not.with_foo=OTHER', 'not.with_foo=OTHER2', 'not.with_bar=Bob']), ('not.with_... 0x matches', True, ['not.with_foo=OTHER', 'not.with_foo=OTHER2', 'not.with_bar=OTHER']), ('use./not.with_... use-matches', True, ['use.with_foo=Frank', 'use.with_foo=OTHER', 'not.with_bar=OTHER']), ('use./not.with_... not-matches', False, ['use.with_foo=OTHER', 'use.with_foo=OTHER2', 'not.with_bar=Bob']), ('use./not.with_... 2x matches', False, ['use.with_foo=Frank', 'use.with_foo=OTHER', 'not.with_bar=Bob']), ('use./not.with_... 0x matches', False, ['use.with_foo=OTHER', 'use.with_foo=OTHER2', 'not.with_bar=OTHER']), ('use./not.with_... not-matches', False, ['not.with_foo=Frank', 'not.with_foo=OTHER', 'use.with_bar=OTHER']), ('use./not.with_... use-matches', True, ['not.with_foo=OTHER', 'not.with_foo=OTHER2', 'use.with_bar=Bob']), ('use./not.with_... 2x matches', False, ['not.with_foo=Frank', 'not.with_foo=OTHER', 'use.with_bar=Bob']), ('use./not.with_... 0x matches', False, ['not.with_foo=OTHER', 'not.with_foo=OTHER2', 'use.with_bar=OTHER'])])
    def test_two_categories_with_three_tags(self, case, expected, tags):
        if False:
            print('Hello World!')
        self.check_should_run_with_active_tags(case, expected, tags)
'\nclass Traits4ActiveTagMatcher(object):\n    TagMatcher = ActiveTagMatcher\n    value_provider = {\n        "foo": "alice",\n        "bar": "BOB",\n    }\n\n    category1_enabled_tag = TagMatcher.make_category_tag("foo", "alice")\n    category1_disabled_tag = TagMatcher.make_category_tag("foo", "bob")\n    category1_disabled_tag2 = TagMatcher.make_category_tag("foo", "charly")\n    category1_similar_tag = TagMatcher.make_category_tag("foo", "alice2")\n    category2_enabled_tag = TagMatcher.make_category_tag("bar", "BOB")\n    category2_disabled_tag = TagMatcher.make_category_tag("bar", "CHARLY")\n    category2_similar_tag = TagMatcher.make_category_tag("bar", "BOB2")\n    unknown_category_tag = TagMatcher.make_category_tag("UNKNOWN", "one")\n\n    # -- NEGATED TAGS:\n    category1_not_enabled_tag =         TagMatcher.make_category_tag("foo", "alice", "not_active")\n    category1_not_enabled_tag2 =         TagMatcher.make_category_tag("foo", "alice", "not")\n    category1_not_disabled_tag =         TagMatcher.make_category_tag("foo", "bob", "not_active")\n    category1_negated_similar_tag1 =         TagMatcher.make_category_tag("foo", "alice2", "not_active")\n\n\n    active_tags1 = [\n        category1_enabled_tag, category1_disabled_tag, category1_similar_tag,\n        category1_not_enabled_tag, category1_not_enabled_tag2,\n    ]\n    active_tags2 = [\n        category2_enabled_tag, category2_disabled_tag, category2_similar_tag,\n    ]\n    active_tags = active_tags1 + active_tags2\n\n\n# -- REQUIRES: pytest\nclass TestActiveTagMatcher2(object):\n    TagMatcher = ActiveTagMatcher\n    traits = Traits4ActiveTagMatcher\n\n    @classmethod\n    def make_tag_matcher(cls):\n        value_provider = {\n            "foo": "alice",\n            "bar": "BOB",\n        }\n        tag_matcher = cls.TagMatcher(value_provider)\n        return tag_matcher\n\n    @pytest.mark.parametrize("case, expected_len, tags", [\n        ("case: Two enabled tags", 2,\n         [traits.category1_enabled_tag, traits.category2_enabled_tag]),\n        ("case: Active enabled and normal tag", 1,\n         [traits.category1_enabled_tag,  "foo"]),\n        ("case: Active disabled and normal tag", 1,\n         [traits.category1_disabled_tag, "foo"]),\n        ("case: Normal and active negated tag", 1,\n         ["foo", traits.category1_not_enabled_tag]),\n        ("case: Two normal tags", 0,\n         ["foo", "bar"]),\n    ])\n    def test_select_active_tags__with_two_tags(self, case, expected_len, tags):\n        tag_matcher = self.make_tag_matcher()\n        selected = tag_matcher.select_active_tags(tags)\n        selected = list(selected)\n        assert len(selected) == expected_len, case\n\n    @pytest.mark.parametrize("case, expected, tags", [\n        # -- GROUP: With positive logic (non-negated tags)\n        ("case P00: 2 disabled tags", True,\n         [ traits.category1_disabled_tag, traits.category2_disabled_tag]),\n        ("case P01: disabled and enabled tag", True,\n         [ traits.category1_disabled_tag, traits.category2_enabled_tag]),\n        ("case P10: enabled and disabled tag", True,\n         [ traits.category1_enabled_tag, traits.category2_disabled_tag]),\n        ("case P11: 2 enabled tags", False,  # -- SHOULD-RUN\n         [ traits.category1_enabled_tag, traits.category2_enabled_tag]),\n        # -- GROUP: With negated tag\n        ("case N00: not-enabled and disabled tag", True,\n         [ traits.category1_not_enabled_tag, traits.category2_disabled_tag]),\n        ("case N01: not-enabled and enabled tag", True,\n         [ traits.category1_not_enabled_tag, traits.category2_enabled_tag]),\n        ("case N10: not-disabled and disabled tag", True,\n         [ traits.category1_not_disabled_tag, traits.category2_disabled_tag]),\n        ("case N11: not-disabled and enabled tag", False, # -- SHOULD-RUN\n         [ traits.category1_not_disabled_tag, traits.category2_enabled_tag]),\n        # -- GROUP: With unknown category\n        ("case U0x: disabled and unknown tag", True,\n         [ traits.category1_disabled_tag, traits.unknown_category_tag]),\n        ("case U1x: enabled and unknown tag", False,  # -- SHOULD-RUN\n         [ traits.category1_enabled_tag, traits.unknown_category_tag]),\n    ])\n    def test_should_exclude_with__combinations_of_2_categories(self, case, expected, tags):\n        tag_matcher = self.make_tag_matcher()\n        actual_result = tag_matcher.should_exclude_with(tags)\n        assert expected == actual_result, case\n\n    @pytest.mark.parametrize("case, expected, tags", [\n        # -- GROUP: With positive logic (non-negated tags)\n        ("case P00: 2 disabled tags", True,\n         [ traits.category1_disabled_tag, traits.category1_disabled_tag2]),\n        ("case P01: disabled and enabled tag", False,\n         [ traits.category1_disabled_tag, traits.category1_enabled_tag]),\n        ("case P10: enabled and disabled tag", False,\n         [ traits.category1_enabled_tag, traits.category1_disabled_tag]),\n        ("case P11: 2 enabled tags (same)", False,  # -- SHOULD-RUN\n         [ traits.category1_enabled_tag, traits.category1_enabled_tag]),\n        # -- GROUP: With negated tag\n        ("case N00: not-enabled and disabled tag", True,\n         [ traits.category1_not_enabled_tag, traits.category1_disabled_tag]),\n        ("case N01: not-enabled and enabled tag", True,\n         [ traits.category1_not_enabled_tag, traits.category1_enabled_tag]),\n        ("case N10: not-disabled and disabled tag", True,\n         [ traits.category1_not_disabled_tag, traits.category1_disabled_tag]),\n        ("case N11: not-disabled and enabled tag", False, # -- SHOULD-RUN\n         [ traits.category1_not_disabled_tag, traits.category1_enabled_tag]),\n    ])\n    def test_should_exclude_with__combinations_with_same_category(self,\n                                                        case, expected, tags):\n        tag_matcher = self.make_tag_matcher()\n        print("tags: {}".format(tags) )\n        print("tag_matcher.value: {}".format(tag_matcher.value_provider) )\n        actual_result = tag_matcher.should_exclude_with(tags)\n        assert expected == actual_result, case\n\n\nclass TestActiveTags(TestCase):\n    TagMatcher = ActiveTagMatcher\n    traits = Traits4ActiveTagMatcher\n\n    @classmethod\n    def make_tag_matcher(cls):\n        tag_matcher = cls.TagMatcher(cls.traits.value_provider)\n        return tag_matcher\n\n    def setUp(self):\n        self.tag_matcher = self.make_tag_matcher()\n\n    def test_select_active_tags__basics(self):\n        active_tag = "active.with_CATEGORY=VALUE"\n        tags = ["foo", active_tag, "bar"]\n        selected = list(self.tag_matcher.select_active_tags(tags))\n        self.assertEqual(len(selected), 1)\n        selected_tag, selected_match = selected[0]\n        self.assertEqual(selected_tag, active_tag)\n\n    def test_select_active_tags__matches_tag_parts(self):\n        tags = ["active.with_CATEGORY=VALUE"]\n        selected = list(self.tag_matcher.select_active_tags(tags))\n        self.assertEqual(len(selected), 1)\n        selected_tag, selected_match = selected[0]\n        self.assertEqual(selected_match.group("prefix"), "active")\n        self.assertEqual(selected_match.group("category"), "CATEGORY")\n        self.assertEqual(selected_match.group("value"), "VALUE")\n\n    def test_select_active_tags__finds_tag_with_any_valid_tag_prefix(self):\n        TagMatcher = self.TagMatcher\n        for tag_prefix in TagMatcher.tag_prefixes:\n            tag = TagMatcher.make_category_tag("foo", "alice", tag_prefix)\n            tags = [ tag ]\n            selected = self.tag_matcher.select_active_tags(tags)\n            selected = list(selected)\n            self.assertEqual(len(selected), 1)\n            selected_tag0 = selected[0][0]\n            self.assertEqual(selected_tag0, tag)\n            self.assertTrue(selected_tag0.startswith(tag_prefix))\n\n    def test_select_active_tags__ignores_invalid_active_tags(self):\n        invalid_active_tags = [\n            ("foo.alice",               "case: Normal tag"),\n            ("with_foo=Frank",          "case: Subset of an active tag"),\n            ("ACTIVE.with_foo.alice",   "case: Wrong tag_prefix (uppercase)"),\n            ("only.with_foo.alice",     "case: Wrong value_separator"),\n        ]\n        for invalid_tag, case in invalid_active_tags:\n            tags = [ invalid_tag ]\n            selected = self.tag_matcher.select_active_tags(tags)\n            selected = list(selected)\n            self.assertEqual(len(selected), 0, case)\n\n    def test_select_active_tags__with_two_tags(self):\n        # XXX-JE-DUPLICATED:\n        traits = self.traits\n        test_patterns = [\n            ("case: Two enabled tags",\n             [traits.category1_enabled_tag, traits.category2_enabled_tag]),\n            ("case: Active enabled and normal tag",\n             [traits.category1_enabled_tag,  "foo"]),\n            ("case: Active disabled and normal tag",\n             [traits.category1_disabled_tag, "foo"]),\n            ("case: Active negated and normal tag",\n             [traits.category1_not_enabled_tag, "foo"]),\n        ]\n        for case, tags in test_patterns:\n            selected = self.tag_matcher.select_active_tags(tags)\n            selected = list(selected)\n            self.assertTrue(len(selected) >= 1, case)\n\n\n    def test_should_exclude_with__returns_false_with_enabled_tag(self):\n        traits = self.traits\n        tags1 = [ traits.category1_enabled_tag ]\n        tags2 = [ traits.category2_enabled_tag ]\n        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags1))\n        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags2))\n\n    def test_should_exclude_with__returns_false_with_disabled_tag_and_more(self):\n        # -- NOTE: Need 1+ enabled active-tags of same category => ENABLED\n        # pylint: disable=line-too-long\n        traits = self.traits\n        test_patterns = [\n            ([ traits.category1_enabled_tag, traits.category1_disabled_tag ], "case: first"),\n            ([ traits.category1_disabled_tag, traits.category1_enabled_tag ], "case: last"),\n            ([ "foo", traits.category1_enabled_tag, traits.category1_disabled_tag, "bar" ], "case: middle"),\n        ]\n        enabled = True  # EXPECTED\n        for tags, case in test_patterns:\n            self.assertEqual(not enabled, self.tag_matcher.should_exclude_with(tags),\n                             "%s: tags=%s" % (case, tags))\n\n    def test_should_exclude_with__returns_true_with_other_tag(self):\n        traits = self.traits\n        tags = [ traits.category1_disabled_tag ]\n        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))\n\n    def test_should_exclude_with__returns_true_with_other_tag_and_more(self):\n        traits = self.traits\n        test_patterns = [\n            ([ traits.category1_disabled_tag, "foo" ], "case: first"),\n            ([ "foo", traits.category1_disabled_tag ], "case: last"),\n            ([ "foo", traits.category1_disabled_tag, "bar" ], "case: middle"),\n        ]\n        for tags, case in test_patterns:\n            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),\n                             "%s: tags=%s" % (case, tags))\n\n    def test_should_exclude_with__returns_true_with_similar_tag(self):\n        traits = self.traits\n        tags = [ traits.category1_similar_tag ]\n        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))\n\n    def test_should_exclude_with__returns_true_with_similar_and_more(self):\n        traits = self.traits\n        test_patterns = [\n            ([ traits.category1_similar_tag, "foo" ], "case: first"),\n            ([ "foo", traits.category1_similar_tag ], "case: last"),\n            ([ "foo", traits.category1_similar_tag, "bar" ], "case: middle"),\n        ]\n        for tags, case in test_patterns:\n            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),\n                             "%s: tags=%s" % (case, tags))\n\n    def test_should_exclude_with__returns_false_without_category_tag(self):\n        test_patterns = [\n            ([ ],           "case: No tags"),\n            ([ "foo" ],     "case: One tag"),\n            ([ "foo", "bar" ], "case: Two tags"),\n        ]\n        for tags, case in test_patterns:\n            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),\n                             "%s: tags=%s" % (case, tags))\n\n    def test_should_exclude_with__returns_false_with_unknown_category_tag(self):\n        """Tags from unknown categories, not supported by value_provider,\n        should not be excluded.\n        """\n        traits = self.traits\n        tags = [ traits.unknown_category_tag ]\n        self.assertEqual("use.with_UNKNOWN=one", traits.unknown_category_tag)\n        self.assertEqual(None, self.tag_matcher.value_provider.get("UNKNOWN"))\n        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags))\n\n    def test_should_exclude_with__combinations_of_2_categories(self):\n        # XXX-JE-DUPLICATED:\n        traits = self.traits\n        test_patterns = [\n            ("case P00: 2 disabled category tags", True,\n             [ traits.category1_disabled_tag, traits.category2_disabled_tag]),\n            ("case P01: disabled and enabled category tags", True,\n             [ traits.category1_disabled_tag, traits.category2_enabled_tag]),\n            ("case P10: enabled and disabled category tags", True,\n             [ traits.category1_enabled_tag, traits.category2_disabled_tag]),\n            ("case P11: 2 enabled category tags", False,  # -- SHOULD-RUN\n             [ traits.category1_enabled_tag, traits.category2_enabled_tag]),\n            # -- SPECIAL CASE: With negated category\n            ("case N00: not-enabled and disabled category tags", True,\n             [ traits.category1_not_enabled_tag, traits.category2_disabled_tag]),\n            ("case N01: not-enabled and enabled category tags", True,\n             [ traits.category1_not_enabled_tag, traits.category2_enabled_tag]),\n            ("case N10: not-disabled and disabled category tags", True,\n             [ traits.category1_not_disabled_tag, traits.category2_disabled_tag]),\n            ("case N11: not-enabled and enabled category tags", False,  # -- SHOULD-RUN\n             [ traits.category1_not_disabled_tag, traits.category2_enabled_tag]),\n            # -- SPECIAL CASE: With unknown category\n            ("case 0x: disabled and unknown category tags", True,\n             [ traits.category1_disabled_tag, traits.unknown_category_tag]),\n            ("case 1x: enabled and unknown category tags", False,  # SHOULD-RUN\n             [ traits.category1_enabled_tag, traits.unknown_category_tag]),\n        ]\n        for case, expected, tags in test_patterns:\n            actual_result = self.tag_matcher.should_exclude_with(tags)\n            self.assertEqual(expected, actual_result,\n                             "%s: tags=%s" % (case, tags))\n\n    def test_should_run_with__negates_result_of_should_exclude_with(self):\n        traits = self.traits\n        test_patterns = [\n            ([ ],                   "case: No tags"),\n            ([ "foo" ],             "case: One non-category tag"),\n            ([ "foo", "bar" ],      "case: Two non-category tags"),\n            ([ traits.category1_enabled_tag ],   "case: enabled tag"),\n            ([ traits.category1_enabled_tag, traits.category1_disabled_tag ],  "case: enabled and other tag"),\n            ([ traits.category1_enabled_tag, "foo" ],    "case: enabled and foo tag"),\n            ([ traits.category1_disabled_tag ],            "case: other tag"),\n            ([ traits.category1_disabled_tag, "foo" ],     "case: other and foo tag"),\n            ([ traits.category1_similar_tag ],          "case: similar tag"),\n            ([ "foo", traits.category1_similar_tag ],   "case: foo and similar tag"),\n        ]\n        for tags, case in test_patterns:\n            result1 = self.tag_matcher.should_run_with(tags)\n            result2 = self.tag_matcher.should_exclude_with(tags)\n            self.assertEqual(result1, not result2, "%s: tags=%s" % (case, tags))\n            self.assertEqual(not result1, result2, "%s: tags=%s" % (case, tags))\n\n\nclass TestCompositeTagMatcher(TestCase):\n\n    @staticmethod\n    def count_tag_matcher_with_result(tag_matchers, tags, result_value):\n        count = 0\n        for tag_matcher in tag_matchers:\n            current_result = tag_matcher.should_exclude_with(tags)\n            if current_result == result_value:\n                count += 1\n        return count\n\n    def setUp(self):\n        predicate_false = lambda tags: False\n        predicate_contains_foo = lambda tags: any(x == "foo" for x in tags)\n        self.tag_matcher_false = PredicateTagMatcher(predicate_false)\n        self.tag_matcher_foo = PredicateTagMatcher(predicate_contains_foo)\n        tag_matchers = [\n            self.tag_matcher_foo,\n            self.tag_matcher_false\n        ]\n        self.ctag_matcher = CompositeTagMatcher(tag_matchers)\n\n    def test_should_exclude_with__returns_true_when_any_tag_matcher_returns_true(self):\n        test_patterns = [\n            ("case: with foo",  ["foo", "bar"]),\n            ("case: with foo2", ["foozy", "foo", "bar"]),\n        ]\n        for case, tags in test_patterns:\n            actual_result = self.ctag_matcher.should_exclude_with(tags)\n            self.assertEqual(True, actual_result,\n                             "%s: tags=%s" % (case, tags))\n\n            actual_true_count = self.count_tag_matcher_with_result(\n                                self.ctag_matcher.tag_matchers, tags, True)\n            self.assertEqual(1, actual_true_count)\n\n    def test_should_exclude_with__returns_false_when_no_tag_matcher_return_true(self):\n        test_patterns = [\n            ("case: without foo",   ["fool", "bar"]),\n            ("case: without foo2",  ["foozy", "bar"]),\n        ]\n        for case, tags in test_patterns:\n            actual_result = self.ctag_matcher.should_exclude_with(tags)\n            self.assertEqual(False, actual_result,\n                             "%s: tags=%s" % (case, tags))\n\n            actual_true_count = self.count_tag_matcher_with_result(\n                                    self.ctag_matcher.tag_matchers, tags, True)\n            self.assertEqual(0, actual_true_count)\n'