[
    {
        "func_name": "cossin",
        "original": "def cossin(X, p=None, q=None, separate=False, swap_sign=False, compute_u=True, compute_vh=True):\n    \"\"\"\n    Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.\n\n    X is an ``(m, m)`` orthogonal/unitary matrix, partitioned as the following\n    where upper left block has the shape of ``(p, q)``::\n\n                                   \u250c                   \u2510\n                                   \u2502 I  0  0 \u2502 0  0  0 \u2502\n        \u250c           \u2510   \u250c         \u2510\u2502 0  C  0 \u2502 0 -S  0 \u2502\u250c         \u2510*\n        \u2502 X11 \u2502 X12 \u2502   \u2502 U1 \u2502    \u2502\u2502 0  0  0 \u2502 0  0 -I \u2502\u2502 V1 \u2502    \u2502\n        \u2502 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 \u2502 = \u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\n        \u2502 X21 \u2502 X22 \u2502   \u2502    \u2502 U2 \u2502\u2502 0  0  0 \u2502 I  0  0 \u2502\u2502    \u2502 V2 \u2502\n        \u2514           \u2518   \u2514         \u2518\u2502 0  S  0 \u2502 0  C  0 \u2502\u2514         \u2518\n                                   \u2502 0  0  I \u2502 0  0  0 \u2502\n                                   \u2514                   \u2518\n\n    ``U1``, ``U2``, ``V1``, ``V2`` are square orthogonal/unitary matrices of\n    dimensions ``(p,p)``, ``(m-p,m-p)``, ``(q,q)``, and ``(m-q,m-q)``\n    respectively, and ``C`` and ``S`` are ``(r, r)`` nonnegative diagonal\n    matrices satisfying ``C^2 + S^2 = I`` where ``r = min(p, m-p, q, m-q)``.\n\n    Moreover, the rank of the identity matrices are ``min(p, q) - r``,\n    ``min(p, m - q) - r``, ``min(m - p, q) - r``, and ``min(m - p, m - q) - r``\n    respectively.\n\n    X can be supplied either by itself and block specifications p, q or its\n    subblocks in an iterable from which the shapes would be derived. See the\n    examples below.\n\n    Parameters\n    ----------\n    X : array_like, iterable\n        complex unitary or real orthogonal matrix to be decomposed, or iterable\n        of subblocks ``X11``, ``X12``, ``X21``, ``X22``, when ``p``, ``q`` are\n        omitted.\n    p : int, optional\n        Number of rows of the upper left block ``X11``, used only when X is\n        given as an array.\n    q : int, optional\n        Number of columns of the upper left block ``X11``, used only when X is\n        given as an array.\n    separate : bool, optional\n        if ``True``, the low level components are returned instead of the\n        matrix factors, i.e. ``(u1,u2)``, ``theta``, ``(v1h,v2h)`` instead of\n        ``u``, ``cs``, ``vh``.\n    swap_sign : bool, optional\n        if ``True``, the ``-S``, ``-I`` block will be the bottom left,\n        otherwise (by default) they will be in the upper right block.\n    compute_u : bool, optional\n        if ``False``, ``u`` won't be computed and an empty array is returned.\n    compute_vh : bool, optional\n        if ``False``, ``vh`` won't be computed and an empty array is returned.\n\n    Returns\n    -------\n    u : ndarray\n        When ``compute_u=True``, contains the block diagonal orthogonal/unitary\n        matrix consisting of the blocks ``U1`` (``p`` x ``p``) and ``U2``\n        (``m-p`` x ``m-p``) orthogonal/unitary matrices. If ``separate=True``,\n        this contains the tuple of ``(U1, U2)``.\n    cs : ndarray\n        The cosine-sine factor with the structure described above.\n         If ``separate=True``, this contains the ``theta`` array containing the\n         angles in radians.\n    vh : ndarray\n        When ``compute_vh=True`, contains the block diagonal orthogonal/unitary\n        matrix consisting of the blocks ``V1H`` (``q`` x ``q``) and ``V2H``\n        (``m-q`` x ``m-q``) orthogonal/unitary matrices. If ``separate=True``,\n        this contains the tuple of ``(V1H, V2H)``.\n\n    References\n    ----------\n    .. [1] Brian D. Sutton. Computing the complete CS decomposition. Numer.\n           Algorithms, 50(1):33-65, 2009.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.linalg import cossin\n    >>> from scipy.stats import unitary_group\n    >>> x = unitary_group.rvs(4)\n    >>> u, cs, vdh = cossin(x, p=2, q=2)\n    >>> np.allclose(x, u @ cs @ vdh)\n    True\n\n    Same can be entered via subblocks without the need of ``p`` and ``q``. Also\n    let's skip the computation of ``u``\n\n    >>> ue, cs, vdh = cossin((x[:2, :2], x[:2, 2:], x[2:, :2], x[2:, 2:]),\n    ...                      compute_u=False)\n    >>> print(ue)\n    []\n    >>> np.allclose(x, u @ cs @ vdh)\n    True\n\n    \"\"\"\n    if p or q:\n        p = 1 if p is None else int(p)\n        q = 1 if q is None else int(q)\n        X = _asarray_validated(X, check_finite=True)\n        if not np.equal(*X.shape):\n            raise ValueError('Cosine Sine decomposition only supports square matrices, got {}'.format(X.shape))\n        m = X.shape[0]\n        if p >= m or p <= 0:\n            raise ValueError('invalid p={}, 0<p<{} must hold'.format(p, X.shape[0]))\n        if q >= m or q <= 0:\n            raise ValueError('invalid q={}, 0<q<{} must hold'.format(q, X.shape[0]))\n        (x11, x12, x21, x22) = (X[:p, :q], X[:p, q:], X[p:, :q], X[p:, q:])\n    elif not isinstance(X, Iterable):\n        raise ValueError('When p and q are None, X must be an Iterable containing the subblocks of X')\n    else:\n        if len(X) != 4:\n            raise ValueError('When p and q are None, exactly four arrays should be in X, got {}'.format(len(X)))\n        (x11, x12, x21, x22) = (np.atleast_2d(x) for x in X)\n        for (name, block) in zip(['x11', 'x12', 'x21', 'x22'], [x11, x12, x21, x22]):\n            if block.shape[1] == 0:\n                raise ValueError(f\"{name} can't be empty\")\n        (p, q) = x11.shape\n        (mmp, mmq) = x22.shape\n        if x12.shape != (p, mmq):\n            raise ValueError('Invalid x12 dimensions: desired {}, got {}'.format((p, mmq), x12.shape))\n        if x21.shape != (mmp, q):\n            raise ValueError('Invalid x21 dimensions: desired {}, got {}'.format((mmp, q), x21.shape))\n        if p + mmp != q + mmq:\n            raise ValueError(\"The subblocks have compatible sizes but don't form a square array (instead they form a {}x{} array). This might be due to missing p, q arguments.\".format(p + mmp, q + mmq))\n        m = p + mmp\n    cplx = any([np.iscomplexobj(x) for x in [x11, x12, x21, x22]])\n    driver = 'uncsd' if cplx else 'orcsd'\n    (csd, csd_lwork) = get_lapack_funcs([driver, driver + '_lwork'], [x11, x12, x21, x22])\n    lwork = _compute_lwork(csd_lwork, m=m, p=p, q=q)\n    lwork_args = {'lwork': lwork[0], 'lrwork': lwork[1]} if cplx else {'lwork': lwork}\n    (*_, theta, u1, u2, v1h, v2h, info) = csd(x11=x11, x12=x12, x21=x21, x22=x22, compute_u1=compute_u, compute_u2=compute_u, compute_v1t=compute_vh, compute_v2t=compute_vh, trans=False, signs=swap_sign, **lwork_args)\n    method_name = csd.typecode + driver\n    if info < 0:\n        raise ValueError('illegal value in argument {} of internal {}'.format(-info, method_name))\n    if info > 0:\n        raise LinAlgError(f'{method_name} did not converge: {info}')\n    if separate:\n        return ((u1, u2), theta, (v1h, v2h))\n    U = block_diag(u1, u2)\n    VDH = block_diag(v1h, v2h)\n    c = np.diag(np.cos(theta))\n    s = np.diag(np.sin(theta))\n    r = min(p, q, m - p, m - q)\n    n11 = min(p, q) - r\n    n12 = min(p, m - q) - r\n    n21 = min(m - p, q) - r\n    n22 = min(m - p, m - q) - r\n    Id = np.eye(np.max([n11, n12, n21, n22, r]), dtype=theta.dtype)\n    CS = np.zeros((m, m), dtype=theta.dtype)\n    CS[:n11, :n11] = Id[:n11, :n11]\n    xs = n11 + r\n    xe = n11 + r + n12\n    ys = n11 + n21 + n22 + 2 * r\n    ye = n11 + n21 + n22 + 2 * r + n12\n    CS[xs:xe, ys:ye] = Id[:n12, :n12] if swap_sign else -Id[:n12, :n12]\n    xs = p + n22 + r\n    xe = p + n22 + r + +n21\n    ys = n11 + r\n    ye = n11 + r + n21\n    CS[xs:xe, ys:ye] = -Id[:n21, :n21] if swap_sign else Id[:n21, :n21]\n    CS[p:p + n22, q:q + n22] = Id[:n22, :n22]\n    CS[n11:n11 + r, n11:n11 + r] = c\n    CS[p + n22:p + n22 + r, r + n21 + n22:2 * r + n21 + n22] = c\n    xs = n11\n    xe = n11 + r\n    ys = n11 + n21 + n22 + r\n    ye = n11 + n21 + n22 + 2 * r\n    CS[xs:xe, ys:ye] = s if swap_sign else -s\n    CS[p + n22:p + n22 + r, n11:n11 + r] = -s if swap_sign else s\n    return (U, CS, VDH)",
        "mutated": [
            "def cossin(X, p=None, q=None, separate=False, swap_sign=False, compute_u=True, compute_vh=True):\n    if False:\n        i = 10\n    \"\\n    Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.\\n\\n    X is an ``(m, m)`` orthogonal/unitary matrix, partitioned as the following\\n    where upper left block has the shape of ``(p, q)``::\\n\\n                                   \u250c                   \u2510\\n                                   \u2502 I  0  0 \u2502 0  0  0 \u2502\\n        \u250c           \u2510   \u250c         \u2510\u2502 0  C  0 \u2502 0 -S  0 \u2502\u250c         \u2510*\\n        \u2502 X11 \u2502 X12 \u2502   \u2502 U1 \u2502    \u2502\u2502 0  0  0 \u2502 0  0 -I \u2502\u2502 V1 \u2502    \u2502\\n        \u2502 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 \u2502 = \u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\\n        \u2502 X21 \u2502 X22 \u2502   \u2502    \u2502 U2 \u2502\u2502 0  0  0 \u2502 I  0  0 \u2502\u2502    \u2502 V2 \u2502\\n        \u2514           \u2518   \u2514         \u2518\u2502 0  S  0 \u2502 0  C  0 \u2502\u2514         \u2518\\n                                   \u2502 0  0  I \u2502 0  0  0 \u2502\\n                                   \u2514                   \u2518\\n\\n    ``U1``, ``U2``, ``V1``, ``V2`` are square orthogonal/unitary matrices of\\n    dimensions ``(p,p)``, ``(m-p,m-p)``, ``(q,q)``, and ``(m-q,m-q)``\\n    respectively, and ``C`` and ``S`` are ``(r, r)`` nonnegative diagonal\\n    matrices satisfying ``C^2 + S^2 = I`` where ``r = min(p, m-p, q, m-q)``.\\n\\n    Moreover, the rank of the identity matrices are ``min(p, q) - r``,\\n    ``min(p, m - q) - r``, ``min(m - p, q) - r``, and ``min(m - p, m - q) - r``\\n    respectively.\\n\\n    X can be supplied either by itself and block specifications p, q or its\\n    subblocks in an iterable from which the shapes would be derived. See the\\n    examples below.\\n\\n    Parameters\\n    ----------\\n    X : array_like, iterable\\n        complex unitary or real orthogonal matrix to be decomposed, or iterable\\n        of subblocks ``X11``, ``X12``, ``X21``, ``X22``, when ``p``, ``q`` are\\n        omitted.\\n    p : int, optional\\n        Number of rows of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    q : int, optional\\n        Number of columns of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    separate : bool, optional\\n        if ``True``, the low level components are returned instead of the\\n        matrix factors, i.e. ``(u1,u2)``, ``theta``, ``(v1h,v2h)`` instead of\\n        ``u``, ``cs``, ``vh``.\\n    swap_sign : bool, optional\\n        if ``True``, the ``-S``, ``-I`` block will be the bottom left,\\n        otherwise (by default) they will be in the upper right block.\\n    compute_u : bool, optional\\n        if ``False``, ``u`` won't be computed and an empty array is returned.\\n    compute_vh : bool, optional\\n        if ``False``, ``vh`` won't be computed and an empty array is returned.\\n\\n    Returns\\n    -------\\n    u : ndarray\\n        When ``compute_u=True``, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``U1`` (``p`` x ``p``) and ``U2``\\n        (``m-p`` x ``m-p``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(U1, U2)``.\\n    cs : ndarray\\n        The cosine-sine factor with the structure described above.\\n         If ``separate=True``, this contains the ``theta`` array containing the\\n         angles in radians.\\n    vh : ndarray\\n        When ``compute_vh=True`, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``V1H`` (``q`` x ``q``) and ``V2H``\\n        (``m-q`` x ``m-q``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(V1H, V2H)``.\\n\\n    References\\n    ----------\\n    .. [1] Brian D. Sutton. Computing the complete CS decomposition. Numer.\\n           Algorithms, 50(1):33-65, 2009.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import cossin\\n    >>> from scipy.stats import unitary_group\\n    >>> x = unitary_group.rvs(4)\\n    >>> u, cs, vdh = cossin(x, p=2, q=2)\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    Same can be entered via subblocks without the need of ``p`` and ``q``. Also\\n    let's skip the computation of ``u``\\n\\n    >>> ue, cs, vdh = cossin((x[:2, :2], x[:2, 2:], x[2:, :2], x[2:, 2:]),\\n    ...                      compute_u=False)\\n    >>> print(ue)\\n    []\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    \"\n    if p or q:\n        p = 1 if p is None else int(p)\n        q = 1 if q is None else int(q)\n        X = _asarray_validated(X, check_finite=True)\n        if not np.equal(*X.shape):\n            raise ValueError('Cosine Sine decomposition only supports square matrices, got {}'.format(X.shape))\n        m = X.shape[0]\n        if p >= m or p <= 0:\n            raise ValueError('invalid p={}, 0<p<{} must hold'.format(p, X.shape[0]))\n        if q >= m or q <= 0:\n            raise ValueError('invalid q={}, 0<q<{} must hold'.format(q, X.shape[0]))\n        (x11, x12, x21, x22) = (X[:p, :q], X[:p, q:], X[p:, :q], X[p:, q:])\n    elif not isinstance(X, Iterable):\n        raise ValueError('When p and q are None, X must be an Iterable containing the subblocks of X')\n    else:\n        if len(X) != 4:\n            raise ValueError('When p and q are None, exactly four arrays should be in X, got {}'.format(len(X)))\n        (x11, x12, x21, x22) = (np.atleast_2d(x) for x in X)\n        for (name, block) in zip(['x11', 'x12', 'x21', 'x22'], [x11, x12, x21, x22]):\n            if block.shape[1] == 0:\n                raise ValueError(f\"{name} can't be empty\")\n        (p, q) = x11.shape\n        (mmp, mmq) = x22.shape\n        if x12.shape != (p, mmq):\n            raise ValueError('Invalid x12 dimensions: desired {}, got {}'.format((p, mmq), x12.shape))\n        if x21.shape != (mmp, q):\n            raise ValueError('Invalid x21 dimensions: desired {}, got {}'.format((mmp, q), x21.shape))\n        if p + mmp != q + mmq:\n            raise ValueError(\"The subblocks have compatible sizes but don't form a square array (instead they form a {}x{} array). This might be due to missing p, q arguments.\".format(p + mmp, q + mmq))\n        m = p + mmp\n    cplx = any([np.iscomplexobj(x) for x in [x11, x12, x21, x22]])\n    driver = 'uncsd' if cplx else 'orcsd'\n    (csd, csd_lwork) = get_lapack_funcs([driver, driver + '_lwork'], [x11, x12, x21, x22])\n    lwork = _compute_lwork(csd_lwork, m=m, p=p, q=q)\n    lwork_args = {'lwork': lwork[0], 'lrwork': lwork[1]} if cplx else {'lwork': lwork}\n    (*_, theta, u1, u2, v1h, v2h, info) = csd(x11=x11, x12=x12, x21=x21, x22=x22, compute_u1=compute_u, compute_u2=compute_u, compute_v1t=compute_vh, compute_v2t=compute_vh, trans=False, signs=swap_sign, **lwork_args)\n    method_name = csd.typecode + driver\n    if info < 0:\n        raise ValueError('illegal value in argument {} of internal {}'.format(-info, method_name))\n    if info > 0:\n        raise LinAlgError(f'{method_name} did not converge: {info}')\n    if separate:\n        return ((u1, u2), theta, (v1h, v2h))\n    U = block_diag(u1, u2)\n    VDH = block_diag(v1h, v2h)\n    c = np.diag(np.cos(theta))\n    s = np.diag(np.sin(theta))\n    r = min(p, q, m - p, m - q)\n    n11 = min(p, q) - r\n    n12 = min(p, m - q) - r\n    n21 = min(m - p, q) - r\n    n22 = min(m - p, m - q) - r\n    Id = np.eye(np.max([n11, n12, n21, n22, r]), dtype=theta.dtype)\n    CS = np.zeros((m, m), dtype=theta.dtype)\n    CS[:n11, :n11] = Id[:n11, :n11]\n    xs = n11 + r\n    xe = n11 + r + n12\n    ys = n11 + n21 + n22 + 2 * r\n    ye = n11 + n21 + n22 + 2 * r + n12\n    CS[xs:xe, ys:ye] = Id[:n12, :n12] if swap_sign else -Id[:n12, :n12]\n    xs = p + n22 + r\n    xe = p + n22 + r + +n21\n    ys = n11 + r\n    ye = n11 + r + n21\n    CS[xs:xe, ys:ye] = -Id[:n21, :n21] if swap_sign else Id[:n21, :n21]\n    CS[p:p + n22, q:q + n22] = Id[:n22, :n22]\n    CS[n11:n11 + r, n11:n11 + r] = c\n    CS[p + n22:p + n22 + r, r + n21 + n22:2 * r + n21 + n22] = c\n    xs = n11\n    xe = n11 + r\n    ys = n11 + n21 + n22 + r\n    ye = n11 + n21 + n22 + 2 * r\n    CS[xs:xe, ys:ye] = s if swap_sign else -s\n    CS[p + n22:p + n22 + r, n11:n11 + r] = -s if swap_sign else s\n    return (U, CS, VDH)",
            "def cossin(X, p=None, q=None, separate=False, swap_sign=False, compute_u=True, compute_vh=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.\\n\\n    X is an ``(m, m)`` orthogonal/unitary matrix, partitioned as the following\\n    where upper left block has the shape of ``(p, q)``::\\n\\n                                   \u250c                   \u2510\\n                                   \u2502 I  0  0 \u2502 0  0  0 \u2502\\n        \u250c           \u2510   \u250c         \u2510\u2502 0  C  0 \u2502 0 -S  0 \u2502\u250c         \u2510*\\n        \u2502 X11 \u2502 X12 \u2502   \u2502 U1 \u2502    \u2502\u2502 0  0  0 \u2502 0  0 -I \u2502\u2502 V1 \u2502    \u2502\\n        \u2502 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 \u2502 = \u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\\n        \u2502 X21 \u2502 X22 \u2502   \u2502    \u2502 U2 \u2502\u2502 0  0  0 \u2502 I  0  0 \u2502\u2502    \u2502 V2 \u2502\\n        \u2514           \u2518   \u2514         \u2518\u2502 0  S  0 \u2502 0  C  0 \u2502\u2514         \u2518\\n                                   \u2502 0  0  I \u2502 0  0  0 \u2502\\n                                   \u2514                   \u2518\\n\\n    ``U1``, ``U2``, ``V1``, ``V2`` are square orthogonal/unitary matrices of\\n    dimensions ``(p,p)``, ``(m-p,m-p)``, ``(q,q)``, and ``(m-q,m-q)``\\n    respectively, and ``C`` and ``S`` are ``(r, r)`` nonnegative diagonal\\n    matrices satisfying ``C^2 + S^2 = I`` where ``r = min(p, m-p, q, m-q)``.\\n\\n    Moreover, the rank of the identity matrices are ``min(p, q) - r``,\\n    ``min(p, m - q) - r``, ``min(m - p, q) - r``, and ``min(m - p, m - q) - r``\\n    respectively.\\n\\n    X can be supplied either by itself and block specifications p, q or its\\n    subblocks in an iterable from which the shapes would be derived. See the\\n    examples below.\\n\\n    Parameters\\n    ----------\\n    X : array_like, iterable\\n        complex unitary or real orthogonal matrix to be decomposed, or iterable\\n        of subblocks ``X11``, ``X12``, ``X21``, ``X22``, when ``p``, ``q`` are\\n        omitted.\\n    p : int, optional\\n        Number of rows of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    q : int, optional\\n        Number of columns of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    separate : bool, optional\\n        if ``True``, the low level components are returned instead of the\\n        matrix factors, i.e. ``(u1,u2)``, ``theta``, ``(v1h,v2h)`` instead of\\n        ``u``, ``cs``, ``vh``.\\n    swap_sign : bool, optional\\n        if ``True``, the ``-S``, ``-I`` block will be the bottom left,\\n        otherwise (by default) they will be in the upper right block.\\n    compute_u : bool, optional\\n        if ``False``, ``u`` won't be computed and an empty array is returned.\\n    compute_vh : bool, optional\\n        if ``False``, ``vh`` won't be computed and an empty array is returned.\\n\\n    Returns\\n    -------\\n    u : ndarray\\n        When ``compute_u=True``, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``U1`` (``p`` x ``p``) and ``U2``\\n        (``m-p`` x ``m-p``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(U1, U2)``.\\n    cs : ndarray\\n        The cosine-sine factor with the structure described above.\\n         If ``separate=True``, this contains the ``theta`` array containing the\\n         angles in radians.\\n    vh : ndarray\\n        When ``compute_vh=True`, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``V1H`` (``q`` x ``q``) and ``V2H``\\n        (``m-q`` x ``m-q``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(V1H, V2H)``.\\n\\n    References\\n    ----------\\n    .. [1] Brian D. Sutton. Computing the complete CS decomposition. Numer.\\n           Algorithms, 50(1):33-65, 2009.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import cossin\\n    >>> from scipy.stats import unitary_group\\n    >>> x = unitary_group.rvs(4)\\n    >>> u, cs, vdh = cossin(x, p=2, q=2)\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    Same can be entered via subblocks without the need of ``p`` and ``q``. Also\\n    let's skip the computation of ``u``\\n\\n    >>> ue, cs, vdh = cossin((x[:2, :2], x[:2, 2:], x[2:, :2], x[2:, 2:]),\\n    ...                      compute_u=False)\\n    >>> print(ue)\\n    []\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    \"\n    if p or q:\n        p = 1 if p is None else int(p)\n        q = 1 if q is None else int(q)\n        X = _asarray_validated(X, check_finite=True)\n        if not np.equal(*X.shape):\n            raise ValueError('Cosine Sine decomposition only supports square matrices, got {}'.format(X.shape))\n        m = X.shape[0]\n        if p >= m or p <= 0:\n            raise ValueError('invalid p={}, 0<p<{} must hold'.format(p, X.shape[0]))\n        if q >= m or q <= 0:\n            raise ValueError('invalid q={}, 0<q<{} must hold'.format(q, X.shape[0]))\n        (x11, x12, x21, x22) = (X[:p, :q], X[:p, q:], X[p:, :q], X[p:, q:])\n    elif not isinstance(X, Iterable):\n        raise ValueError('When p and q are None, X must be an Iterable containing the subblocks of X')\n    else:\n        if len(X) != 4:\n            raise ValueError('When p and q are None, exactly four arrays should be in X, got {}'.format(len(X)))\n        (x11, x12, x21, x22) = (np.atleast_2d(x) for x in X)\n        for (name, block) in zip(['x11', 'x12', 'x21', 'x22'], [x11, x12, x21, x22]):\n            if block.shape[1] == 0:\n                raise ValueError(f\"{name} can't be empty\")\n        (p, q) = x11.shape\n        (mmp, mmq) = x22.shape\n        if x12.shape != (p, mmq):\n            raise ValueError('Invalid x12 dimensions: desired {}, got {}'.format((p, mmq), x12.shape))\n        if x21.shape != (mmp, q):\n            raise ValueError('Invalid x21 dimensions: desired {}, got {}'.format((mmp, q), x21.shape))\n        if p + mmp != q + mmq:\n            raise ValueError(\"The subblocks have compatible sizes but don't form a square array (instead they form a {}x{} array). This might be due to missing p, q arguments.\".format(p + mmp, q + mmq))\n        m = p + mmp\n    cplx = any([np.iscomplexobj(x) for x in [x11, x12, x21, x22]])\n    driver = 'uncsd' if cplx else 'orcsd'\n    (csd, csd_lwork) = get_lapack_funcs([driver, driver + '_lwork'], [x11, x12, x21, x22])\n    lwork = _compute_lwork(csd_lwork, m=m, p=p, q=q)\n    lwork_args = {'lwork': lwork[0], 'lrwork': lwork[1]} if cplx else {'lwork': lwork}\n    (*_, theta, u1, u2, v1h, v2h, info) = csd(x11=x11, x12=x12, x21=x21, x22=x22, compute_u1=compute_u, compute_u2=compute_u, compute_v1t=compute_vh, compute_v2t=compute_vh, trans=False, signs=swap_sign, **lwork_args)\n    method_name = csd.typecode + driver\n    if info < 0:\n        raise ValueError('illegal value in argument {} of internal {}'.format(-info, method_name))\n    if info > 0:\n        raise LinAlgError(f'{method_name} did not converge: {info}')\n    if separate:\n        return ((u1, u2), theta, (v1h, v2h))\n    U = block_diag(u1, u2)\n    VDH = block_diag(v1h, v2h)\n    c = np.diag(np.cos(theta))\n    s = np.diag(np.sin(theta))\n    r = min(p, q, m - p, m - q)\n    n11 = min(p, q) - r\n    n12 = min(p, m - q) - r\n    n21 = min(m - p, q) - r\n    n22 = min(m - p, m - q) - r\n    Id = np.eye(np.max([n11, n12, n21, n22, r]), dtype=theta.dtype)\n    CS = np.zeros((m, m), dtype=theta.dtype)\n    CS[:n11, :n11] = Id[:n11, :n11]\n    xs = n11 + r\n    xe = n11 + r + n12\n    ys = n11 + n21 + n22 + 2 * r\n    ye = n11 + n21 + n22 + 2 * r + n12\n    CS[xs:xe, ys:ye] = Id[:n12, :n12] if swap_sign else -Id[:n12, :n12]\n    xs = p + n22 + r\n    xe = p + n22 + r + +n21\n    ys = n11 + r\n    ye = n11 + r + n21\n    CS[xs:xe, ys:ye] = -Id[:n21, :n21] if swap_sign else Id[:n21, :n21]\n    CS[p:p + n22, q:q + n22] = Id[:n22, :n22]\n    CS[n11:n11 + r, n11:n11 + r] = c\n    CS[p + n22:p + n22 + r, r + n21 + n22:2 * r + n21 + n22] = c\n    xs = n11\n    xe = n11 + r\n    ys = n11 + n21 + n22 + r\n    ye = n11 + n21 + n22 + 2 * r\n    CS[xs:xe, ys:ye] = s if swap_sign else -s\n    CS[p + n22:p + n22 + r, n11:n11 + r] = -s if swap_sign else s\n    return (U, CS, VDH)",
            "def cossin(X, p=None, q=None, separate=False, swap_sign=False, compute_u=True, compute_vh=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.\\n\\n    X is an ``(m, m)`` orthogonal/unitary matrix, partitioned as the following\\n    where upper left block has the shape of ``(p, q)``::\\n\\n                                   \u250c                   \u2510\\n                                   \u2502 I  0  0 \u2502 0  0  0 \u2502\\n        \u250c           \u2510   \u250c         \u2510\u2502 0  C  0 \u2502 0 -S  0 \u2502\u250c         \u2510*\\n        \u2502 X11 \u2502 X12 \u2502   \u2502 U1 \u2502    \u2502\u2502 0  0  0 \u2502 0  0 -I \u2502\u2502 V1 \u2502    \u2502\\n        \u2502 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 \u2502 = \u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\\n        \u2502 X21 \u2502 X22 \u2502   \u2502    \u2502 U2 \u2502\u2502 0  0  0 \u2502 I  0  0 \u2502\u2502    \u2502 V2 \u2502\\n        \u2514           \u2518   \u2514         \u2518\u2502 0  S  0 \u2502 0  C  0 \u2502\u2514         \u2518\\n                                   \u2502 0  0  I \u2502 0  0  0 \u2502\\n                                   \u2514                   \u2518\\n\\n    ``U1``, ``U2``, ``V1``, ``V2`` are square orthogonal/unitary matrices of\\n    dimensions ``(p,p)``, ``(m-p,m-p)``, ``(q,q)``, and ``(m-q,m-q)``\\n    respectively, and ``C`` and ``S`` are ``(r, r)`` nonnegative diagonal\\n    matrices satisfying ``C^2 + S^2 = I`` where ``r = min(p, m-p, q, m-q)``.\\n\\n    Moreover, the rank of the identity matrices are ``min(p, q) - r``,\\n    ``min(p, m - q) - r``, ``min(m - p, q) - r``, and ``min(m - p, m - q) - r``\\n    respectively.\\n\\n    X can be supplied either by itself and block specifications p, q or its\\n    subblocks in an iterable from which the shapes would be derived. See the\\n    examples below.\\n\\n    Parameters\\n    ----------\\n    X : array_like, iterable\\n        complex unitary or real orthogonal matrix to be decomposed, or iterable\\n        of subblocks ``X11``, ``X12``, ``X21``, ``X22``, when ``p``, ``q`` are\\n        omitted.\\n    p : int, optional\\n        Number of rows of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    q : int, optional\\n        Number of columns of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    separate : bool, optional\\n        if ``True``, the low level components are returned instead of the\\n        matrix factors, i.e. ``(u1,u2)``, ``theta``, ``(v1h,v2h)`` instead of\\n        ``u``, ``cs``, ``vh``.\\n    swap_sign : bool, optional\\n        if ``True``, the ``-S``, ``-I`` block will be the bottom left,\\n        otherwise (by default) they will be in the upper right block.\\n    compute_u : bool, optional\\n        if ``False``, ``u`` won't be computed and an empty array is returned.\\n    compute_vh : bool, optional\\n        if ``False``, ``vh`` won't be computed and an empty array is returned.\\n\\n    Returns\\n    -------\\n    u : ndarray\\n        When ``compute_u=True``, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``U1`` (``p`` x ``p``) and ``U2``\\n        (``m-p`` x ``m-p``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(U1, U2)``.\\n    cs : ndarray\\n        The cosine-sine factor with the structure described above.\\n         If ``separate=True``, this contains the ``theta`` array containing the\\n         angles in radians.\\n    vh : ndarray\\n        When ``compute_vh=True`, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``V1H`` (``q`` x ``q``) and ``V2H``\\n        (``m-q`` x ``m-q``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(V1H, V2H)``.\\n\\n    References\\n    ----------\\n    .. [1] Brian D. Sutton. Computing the complete CS decomposition. Numer.\\n           Algorithms, 50(1):33-65, 2009.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import cossin\\n    >>> from scipy.stats import unitary_group\\n    >>> x = unitary_group.rvs(4)\\n    >>> u, cs, vdh = cossin(x, p=2, q=2)\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    Same can be entered via subblocks without the need of ``p`` and ``q``. Also\\n    let's skip the computation of ``u``\\n\\n    >>> ue, cs, vdh = cossin((x[:2, :2], x[:2, 2:], x[2:, :2], x[2:, 2:]),\\n    ...                      compute_u=False)\\n    >>> print(ue)\\n    []\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    \"\n    if p or q:\n        p = 1 if p is None else int(p)\n        q = 1 if q is None else int(q)\n        X = _asarray_validated(X, check_finite=True)\n        if not np.equal(*X.shape):\n            raise ValueError('Cosine Sine decomposition only supports square matrices, got {}'.format(X.shape))\n        m = X.shape[0]\n        if p >= m or p <= 0:\n            raise ValueError('invalid p={}, 0<p<{} must hold'.format(p, X.shape[0]))\n        if q >= m or q <= 0:\n            raise ValueError('invalid q={}, 0<q<{} must hold'.format(q, X.shape[0]))\n        (x11, x12, x21, x22) = (X[:p, :q], X[:p, q:], X[p:, :q], X[p:, q:])\n    elif not isinstance(X, Iterable):\n        raise ValueError('When p and q are None, X must be an Iterable containing the subblocks of X')\n    else:\n        if len(X) != 4:\n            raise ValueError('When p and q are None, exactly four arrays should be in X, got {}'.format(len(X)))\n        (x11, x12, x21, x22) = (np.atleast_2d(x) for x in X)\n        for (name, block) in zip(['x11', 'x12', 'x21', 'x22'], [x11, x12, x21, x22]):\n            if block.shape[1] == 0:\n                raise ValueError(f\"{name} can't be empty\")\n        (p, q) = x11.shape\n        (mmp, mmq) = x22.shape\n        if x12.shape != (p, mmq):\n            raise ValueError('Invalid x12 dimensions: desired {}, got {}'.format((p, mmq), x12.shape))\n        if x21.shape != (mmp, q):\n            raise ValueError('Invalid x21 dimensions: desired {}, got {}'.format((mmp, q), x21.shape))\n        if p + mmp != q + mmq:\n            raise ValueError(\"The subblocks have compatible sizes but don't form a square array (instead they form a {}x{} array). This might be due to missing p, q arguments.\".format(p + mmp, q + mmq))\n        m = p + mmp\n    cplx = any([np.iscomplexobj(x) for x in [x11, x12, x21, x22]])\n    driver = 'uncsd' if cplx else 'orcsd'\n    (csd, csd_lwork) = get_lapack_funcs([driver, driver + '_lwork'], [x11, x12, x21, x22])\n    lwork = _compute_lwork(csd_lwork, m=m, p=p, q=q)\n    lwork_args = {'lwork': lwork[0], 'lrwork': lwork[1]} if cplx else {'lwork': lwork}\n    (*_, theta, u1, u2, v1h, v2h, info) = csd(x11=x11, x12=x12, x21=x21, x22=x22, compute_u1=compute_u, compute_u2=compute_u, compute_v1t=compute_vh, compute_v2t=compute_vh, trans=False, signs=swap_sign, **lwork_args)\n    method_name = csd.typecode + driver\n    if info < 0:\n        raise ValueError('illegal value in argument {} of internal {}'.format(-info, method_name))\n    if info > 0:\n        raise LinAlgError(f'{method_name} did not converge: {info}')\n    if separate:\n        return ((u1, u2), theta, (v1h, v2h))\n    U = block_diag(u1, u2)\n    VDH = block_diag(v1h, v2h)\n    c = np.diag(np.cos(theta))\n    s = np.diag(np.sin(theta))\n    r = min(p, q, m - p, m - q)\n    n11 = min(p, q) - r\n    n12 = min(p, m - q) - r\n    n21 = min(m - p, q) - r\n    n22 = min(m - p, m - q) - r\n    Id = np.eye(np.max([n11, n12, n21, n22, r]), dtype=theta.dtype)\n    CS = np.zeros((m, m), dtype=theta.dtype)\n    CS[:n11, :n11] = Id[:n11, :n11]\n    xs = n11 + r\n    xe = n11 + r + n12\n    ys = n11 + n21 + n22 + 2 * r\n    ye = n11 + n21 + n22 + 2 * r + n12\n    CS[xs:xe, ys:ye] = Id[:n12, :n12] if swap_sign else -Id[:n12, :n12]\n    xs = p + n22 + r\n    xe = p + n22 + r + +n21\n    ys = n11 + r\n    ye = n11 + r + n21\n    CS[xs:xe, ys:ye] = -Id[:n21, :n21] if swap_sign else Id[:n21, :n21]\n    CS[p:p + n22, q:q + n22] = Id[:n22, :n22]\n    CS[n11:n11 + r, n11:n11 + r] = c\n    CS[p + n22:p + n22 + r, r + n21 + n22:2 * r + n21 + n22] = c\n    xs = n11\n    xe = n11 + r\n    ys = n11 + n21 + n22 + r\n    ye = n11 + n21 + n22 + 2 * r\n    CS[xs:xe, ys:ye] = s if swap_sign else -s\n    CS[p + n22:p + n22 + r, n11:n11 + r] = -s if swap_sign else s\n    return (U, CS, VDH)",
            "def cossin(X, p=None, q=None, separate=False, swap_sign=False, compute_u=True, compute_vh=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.\\n\\n    X is an ``(m, m)`` orthogonal/unitary matrix, partitioned as the following\\n    where upper left block has the shape of ``(p, q)``::\\n\\n                                   \u250c                   \u2510\\n                                   \u2502 I  0  0 \u2502 0  0  0 \u2502\\n        \u250c           \u2510   \u250c         \u2510\u2502 0  C  0 \u2502 0 -S  0 \u2502\u250c         \u2510*\\n        \u2502 X11 \u2502 X12 \u2502   \u2502 U1 \u2502    \u2502\u2502 0  0  0 \u2502 0  0 -I \u2502\u2502 V1 \u2502    \u2502\\n        \u2502 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 \u2502 = \u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\\n        \u2502 X21 \u2502 X22 \u2502   \u2502    \u2502 U2 \u2502\u2502 0  0  0 \u2502 I  0  0 \u2502\u2502    \u2502 V2 \u2502\\n        \u2514           \u2518   \u2514         \u2518\u2502 0  S  0 \u2502 0  C  0 \u2502\u2514         \u2518\\n                                   \u2502 0  0  I \u2502 0  0  0 \u2502\\n                                   \u2514                   \u2518\\n\\n    ``U1``, ``U2``, ``V1``, ``V2`` are square orthogonal/unitary matrices of\\n    dimensions ``(p,p)``, ``(m-p,m-p)``, ``(q,q)``, and ``(m-q,m-q)``\\n    respectively, and ``C`` and ``S`` are ``(r, r)`` nonnegative diagonal\\n    matrices satisfying ``C^2 + S^2 = I`` where ``r = min(p, m-p, q, m-q)``.\\n\\n    Moreover, the rank of the identity matrices are ``min(p, q) - r``,\\n    ``min(p, m - q) - r``, ``min(m - p, q) - r``, and ``min(m - p, m - q) - r``\\n    respectively.\\n\\n    X can be supplied either by itself and block specifications p, q or its\\n    subblocks in an iterable from which the shapes would be derived. See the\\n    examples below.\\n\\n    Parameters\\n    ----------\\n    X : array_like, iterable\\n        complex unitary or real orthogonal matrix to be decomposed, or iterable\\n        of subblocks ``X11``, ``X12``, ``X21``, ``X22``, when ``p``, ``q`` are\\n        omitted.\\n    p : int, optional\\n        Number of rows of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    q : int, optional\\n        Number of columns of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    separate : bool, optional\\n        if ``True``, the low level components are returned instead of the\\n        matrix factors, i.e. ``(u1,u2)``, ``theta``, ``(v1h,v2h)`` instead of\\n        ``u``, ``cs``, ``vh``.\\n    swap_sign : bool, optional\\n        if ``True``, the ``-S``, ``-I`` block will be the bottom left,\\n        otherwise (by default) they will be in the upper right block.\\n    compute_u : bool, optional\\n        if ``False``, ``u`` won't be computed and an empty array is returned.\\n    compute_vh : bool, optional\\n        if ``False``, ``vh`` won't be computed and an empty array is returned.\\n\\n    Returns\\n    -------\\n    u : ndarray\\n        When ``compute_u=True``, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``U1`` (``p`` x ``p``) and ``U2``\\n        (``m-p`` x ``m-p``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(U1, U2)``.\\n    cs : ndarray\\n        The cosine-sine factor with the structure described above.\\n         If ``separate=True``, this contains the ``theta`` array containing the\\n         angles in radians.\\n    vh : ndarray\\n        When ``compute_vh=True`, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``V1H`` (``q`` x ``q``) and ``V2H``\\n        (``m-q`` x ``m-q``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(V1H, V2H)``.\\n\\n    References\\n    ----------\\n    .. [1] Brian D. Sutton. Computing the complete CS decomposition. Numer.\\n           Algorithms, 50(1):33-65, 2009.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import cossin\\n    >>> from scipy.stats import unitary_group\\n    >>> x = unitary_group.rvs(4)\\n    >>> u, cs, vdh = cossin(x, p=2, q=2)\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    Same can be entered via subblocks without the need of ``p`` and ``q``. Also\\n    let's skip the computation of ``u``\\n\\n    >>> ue, cs, vdh = cossin((x[:2, :2], x[:2, 2:], x[2:, :2], x[2:, 2:]),\\n    ...                      compute_u=False)\\n    >>> print(ue)\\n    []\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    \"\n    if p or q:\n        p = 1 if p is None else int(p)\n        q = 1 if q is None else int(q)\n        X = _asarray_validated(X, check_finite=True)\n        if not np.equal(*X.shape):\n            raise ValueError('Cosine Sine decomposition only supports square matrices, got {}'.format(X.shape))\n        m = X.shape[0]\n        if p >= m or p <= 0:\n            raise ValueError('invalid p={}, 0<p<{} must hold'.format(p, X.shape[0]))\n        if q >= m or q <= 0:\n            raise ValueError('invalid q={}, 0<q<{} must hold'.format(q, X.shape[0]))\n        (x11, x12, x21, x22) = (X[:p, :q], X[:p, q:], X[p:, :q], X[p:, q:])\n    elif not isinstance(X, Iterable):\n        raise ValueError('When p and q are None, X must be an Iterable containing the subblocks of X')\n    else:\n        if len(X) != 4:\n            raise ValueError('When p and q are None, exactly four arrays should be in X, got {}'.format(len(X)))\n        (x11, x12, x21, x22) = (np.atleast_2d(x) for x in X)\n        for (name, block) in zip(['x11', 'x12', 'x21', 'x22'], [x11, x12, x21, x22]):\n            if block.shape[1] == 0:\n                raise ValueError(f\"{name} can't be empty\")\n        (p, q) = x11.shape\n        (mmp, mmq) = x22.shape\n        if x12.shape != (p, mmq):\n            raise ValueError('Invalid x12 dimensions: desired {}, got {}'.format((p, mmq), x12.shape))\n        if x21.shape != (mmp, q):\n            raise ValueError('Invalid x21 dimensions: desired {}, got {}'.format((mmp, q), x21.shape))\n        if p + mmp != q + mmq:\n            raise ValueError(\"The subblocks have compatible sizes but don't form a square array (instead they form a {}x{} array). This might be due to missing p, q arguments.\".format(p + mmp, q + mmq))\n        m = p + mmp\n    cplx = any([np.iscomplexobj(x) for x in [x11, x12, x21, x22]])\n    driver = 'uncsd' if cplx else 'orcsd'\n    (csd, csd_lwork) = get_lapack_funcs([driver, driver + '_lwork'], [x11, x12, x21, x22])\n    lwork = _compute_lwork(csd_lwork, m=m, p=p, q=q)\n    lwork_args = {'lwork': lwork[0], 'lrwork': lwork[1]} if cplx else {'lwork': lwork}\n    (*_, theta, u1, u2, v1h, v2h, info) = csd(x11=x11, x12=x12, x21=x21, x22=x22, compute_u1=compute_u, compute_u2=compute_u, compute_v1t=compute_vh, compute_v2t=compute_vh, trans=False, signs=swap_sign, **lwork_args)\n    method_name = csd.typecode + driver\n    if info < 0:\n        raise ValueError('illegal value in argument {} of internal {}'.format(-info, method_name))\n    if info > 0:\n        raise LinAlgError(f'{method_name} did not converge: {info}')\n    if separate:\n        return ((u1, u2), theta, (v1h, v2h))\n    U = block_diag(u1, u2)\n    VDH = block_diag(v1h, v2h)\n    c = np.diag(np.cos(theta))\n    s = np.diag(np.sin(theta))\n    r = min(p, q, m - p, m - q)\n    n11 = min(p, q) - r\n    n12 = min(p, m - q) - r\n    n21 = min(m - p, q) - r\n    n22 = min(m - p, m - q) - r\n    Id = np.eye(np.max([n11, n12, n21, n22, r]), dtype=theta.dtype)\n    CS = np.zeros((m, m), dtype=theta.dtype)\n    CS[:n11, :n11] = Id[:n11, :n11]\n    xs = n11 + r\n    xe = n11 + r + n12\n    ys = n11 + n21 + n22 + 2 * r\n    ye = n11 + n21 + n22 + 2 * r + n12\n    CS[xs:xe, ys:ye] = Id[:n12, :n12] if swap_sign else -Id[:n12, :n12]\n    xs = p + n22 + r\n    xe = p + n22 + r + +n21\n    ys = n11 + r\n    ye = n11 + r + n21\n    CS[xs:xe, ys:ye] = -Id[:n21, :n21] if swap_sign else Id[:n21, :n21]\n    CS[p:p + n22, q:q + n22] = Id[:n22, :n22]\n    CS[n11:n11 + r, n11:n11 + r] = c\n    CS[p + n22:p + n22 + r, r + n21 + n22:2 * r + n21 + n22] = c\n    xs = n11\n    xe = n11 + r\n    ys = n11 + n21 + n22 + r\n    ye = n11 + n21 + n22 + 2 * r\n    CS[xs:xe, ys:ye] = s if swap_sign else -s\n    CS[p + n22:p + n22 + r, n11:n11 + r] = -s if swap_sign else s\n    return (U, CS, VDH)",
            "def cossin(X, p=None, q=None, separate=False, swap_sign=False, compute_u=True, compute_vh=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.\\n\\n    X is an ``(m, m)`` orthogonal/unitary matrix, partitioned as the following\\n    where upper left block has the shape of ``(p, q)``::\\n\\n                                   \u250c                   \u2510\\n                                   \u2502 I  0  0 \u2502 0  0  0 \u2502\\n        \u250c           \u2510   \u250c         \u2510\u2502 0  C  0 \u2502 0 -S  0 \u2502\u250c         \u2510*\\n        \u2502 X11 \u2502 X12 \u2502   \u2502 U1 \u2502    \u2502\u2502 0  0  0 \u2502 0  0 -I \u2502\u2502 V1 \u2502    \u2502\\n        \u2502 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 \u2502 = \u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\\n        \u2502 X21 \u2502 X22 \u2502   \u2502    \u2502 U2 \u2502\u2502 0  0  0 \u2502 I  0  0 \u2502\u2502    \u2502 V2 \u2502\\n        \u2514           \u2518   \u2514         \u2518\u2502 0  S  0 \u2502 0  C  0 \u2502\u2514         \u2518\\n                                   \u2502 0  0  I \u2502 0  0  0 \u2502\\n                                   \u2514                   \u2518\\n\\n    ``U1``, ``U2``, ``V1``, ``V2`` are square orthogonal/unitary matrices of\\n    dimensions ``(p,p)``, ``(m-p,m-p)``, ``(q,q)``, and ``(m-q,m-q)``\\n    respectively, and ``C`` and ``S`` are ``(r, r)`` nonnegative diagonal\\n    matrices satisfying ``C^2 + S^2 = I`` where ``r = min(p, m-p, q, m-q)``.\\n\\n    Moreover, the rank of the identity matrices are ``min(p, q) - r``,\\n    ``min(p, m - q) - r``, ``min(m - p, q) - r``, and ``min(m - p, m - q) - r``\\n    respectively.\\n\\n    X can be supplied either by itself and block specifications p, q or its\\n    subblocks in an iterable from which the shapes would be derived. See the\\n    examples below.\\n\\n    Parameters\\n    ----------\\n    X : array_like, iterable\\n        complex unitary or real orthogonal matrix to be decomposed, or iterable\\n        of subblocks ``X11``, ``X12``, ``X21``, ``X22``, when ``p``, ``q`` are\\n        omitted.\\n    p : int, optional\\n        Number of rows of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    q : int, optional\\n        Number of columns of the upper left block ``X11``, used only when X is\\n        given as an array.\\n    separate : bool, optional\\n        if ``True``, the low level components are returned instead of the\\n        matrix factors, i.e. ``(u1,u2)``, ``theta``, ``(v1h,v2h)`` instead of\\n        ``u``, ``cs``, ``vh``.\\n    swap_sign : bool, optional\\n        if ``True``, the ``-S``, ``-I`` block will be the bottom left,\\n        otherwise (by default) they will be in the upper right block.\\n    compute_u : bool, optional\\n        if ``False``, ``u`` won't be computed and an empty array is returned.\\n    compute_vh : bool, optional\\n        if ``False``, ``vh`` won't be computed and an empty array is returned.\\n\\n    Returns\\n    -------\\n    u : ndarray\\n        When ``compute_u=True``, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``U1`` (``p`` x ``p``) and ``U2``\\n        (``m-p`` x ``m-p``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(U1, U2)``.\\n    cs : ndarray\\n        The cosine-sine factor with the structure described above.\\n         If ``separate=True``, this contains the ``theta`` array containing the\\n         angles in radians.\\n    vh : ndarray\\n        When ``compute_vh=True`, contains the block diagonal orthogonal/unitary\\n        matrix consisting of the blocks ``V1H`` (``q`` x ``q``) and ``V2H``\\n        (``m-q`` x ``m-q``) orthogonal/unitary matrices. If ``separate=True``,\\n        this contains the tuple of ``(V1H, V2H)``.\\n\\n    References\\n    ----------\\n    .. [1] Brian D. Sutton. Computing the complete CS decomposition. Numer.\\n           Algorithms, 50(1):33-65, 2009.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import cossin\\n    >>> from scipy.stats import unitary_group\\n    >>> x = unitary_group.rvs(4)\\n    >>> u, cs, vdh = cossin(x, p=2, q=2)\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    Same can be entered via subblocks without the need of ``p`` and ``q``. Also\\n    let's skip the computation of ``u``\\n\\n    >>> ue, cs, vdh = cossin((x[:2, :2], x[:2, 2:], x[2:, :2], x[2:, 2:]),\\n    ...                      compute_u=False)\\n    >>> print(ue)\\n    []\\n    >>> np.allclose(x, u @ cs @ vdh)\\n    True\\n\\n    \"\n    if p or q:\n        p = 1 if p is None else int(p)\n        q = 1 if q is None else int(q)\n        X = _asarray_validated(X, check_finite=True)\n        if not np.equal(*X.shape):\n            raise ValueError('Cosine Sine decomposition only supports square matrices, got {}'.format(X.shape))\n        m = X.shape[0]\n        if p >= m or p <= 0:\n            raise ValueError('invalid p={}, 0<p<{} must hold'.format(p, X.shape[0]))\n        if q >= m or q <= 0:\n            raise ValueError('invalid q={}, 0<q<{} must hold'.format(q, X.shape[0]))\n        (x11, x12, x21, x22) = (X[:p, :q], X[:p, q:], X[p:, :q], X[p:, q:])\n    elif not isinstance(X, Iterable):\n        raise ValueError('When p and q are None, X must be an Iterable containing the subblocks of X')\n    else:\n        if len(X) != 4:\n            raise ValueError('When p and q are None, exactly four arrays should be in X, got {}'.format(len(X)))\n        (x11, x12, x21, x22) = (np.atleast_2d(x) for x in X)\n        for (name, block) in zip(['x11', 'x12', 'x21', 'x22'], [x11, x12, x21, x22]):\n            if block.shape[1] == 0:\n                raise ValueError(f\"{name} can't be empty\")\n        (p, q) = x11.shape\n        (mmp, mmq) = x22.shape\n        if x12.shape != (p, mmq):\n            raise ValueError('Invalid x12 dimensions: desired {}, got {}'.format((p, mmq), x12.shape))\n        if x21.shape != (mmp, q):\n            raise ValueError('Invalid x21 dimensions: desired {}, got {}'.format((mmp, q), x21.shape))\n        if p + mmp != q + mmq:\n            raise ValueError(\"The subblocks have compatible sizes but don't form a square array (instead they form a {}x{} array). This might be due to missing p, q arguments.\".format(p + mmp, q + mmq))\n        m = p + mmp\n    cplx = any([np.iscomplexobj(x) for x in [x11, x12, x21, x22]])\n    driver = 'uncsd' if cplx else 'orcsd'\n    (csd, csd_lwork) = get_lapack_funcs([driver, driver + '_lwork'], [x11, x12, x21, x22])\n    lwork = _compute_lwork(csd_lwork, m=m, p=p, q=q)\n    lwork_args = {'lwork': lwork[0], 'lrwork': lwork[1]} if cplx else {'lwork': lwork}\n    (*_, theta, u1, u2, v1h, v2h, info) = csd(x11=x11, x12=x12, x21=x21, x22=x22, compute_u1=compute_u, compute_u2=compute_u, compute_v1t=compute_vh, compute_v2t=compute_vh, trans=False, signs=swap_sign, **lwork_args)\n    method_name = csd.typecode + driver\n    if info < 0:\n        raise ValueError('illegal value in argument {} of internal {}'.format(-info, method_name))\n    if info > 0:\n        raise LinAlgError(f'{method_name} did not converge: {info}')\n    if separate:\n        return ((u1, u2), theta, (v1h, v2h))\n    U = block_diag(u1, u2)\n    VDH = block_diag(v1h, v2h)\n    c = np.diag(np.cos(theta))\n    s = np.diag(np.sin(theta))\n    r = min(p, q, m - p, m - q)\n    n11 = min(p, q) - r\n    n12 = min(p, m - q) - r\n    n21 = min(m - p, q) - r\n    n22 = min(m - p, m - q) - r\n    Id = np.eye(np.max([n11, n12, n21, n22, r]), dtype=theta.dtype)\n    CS = np.zeros((m, m), dtype=theta.dtype)\n    CS[:n11, :n11] = Id[:n11, :n11]\n    xs = n11 + r\n    xe = n11 + r + n12\n    ys = n11 + n21 + n22 + 2 * r\n    ye = n11 + n21 + n22 + 2 * r + n12\n    CS[xs:xe, ys:ye] = Id[:n12, :n12] if swap_sign else -Id[:n12, :n12]\n    xs = p + n22 + r\n    xe = p + n22 + r + +n21\n    ys = n11 + r\n    ye = n11 + r + n21\n    CS[xs:xe, ys:ye] = -Id[:n21, :n21] if swap_sign else Id[:n21, :n21]\n    CS[p:p + n22, q:q + n22] = Id[:n22, :n22]\n    CS[n11:n11 + r, n11:n11 + r] = c\n    CS[p + n22:p + n22 + r, r + n21 + n22:2 * r + n21 + n22] = c\n    xs = n11\n    xe = n11 + r\n    ys = n11 + n21 + n22 + r\n    ye = n11 + n21 + n22 + 2 * r\n    CS[xs:xe, ys:ye] = s if swap_sign else -s\n    CS[p + n22:p + n22 + r, n11:n11 + r] = -s if swap_sign else s\n    return (U, CS, VDH)"
        ]
    }
]