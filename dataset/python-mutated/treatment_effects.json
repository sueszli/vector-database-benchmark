[
    {
        "func_name": "_mom_ate",
        "original": "def _mom_ate(params, endog, tind, prob, weighted=True):\n    \"\"\"moment condition for average treatment effect\n\n    This does not include a moment condition for potential outcome mean (POM).\n\n    \"\"\"\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return endog * wdiff - params",
        "mutated": [
            "def _mom_ate(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n    'moment condition for average treatment effect\\n\\n    This does not include a moment condition for potential outcome mean (POM).\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return endog * wdiff - params",
            "def _mom_ate(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'moment condition for average treatment effect\\n\\n    This does not include a moment condition for potential outcome mean (POM).\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return endog * wdiff - params",
            "def _mom_ate(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'moment condition for average treatment effect\\n\\n    This does not include a moment condition for potential outcome mean (POM).\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return endog * wdiff - params",
            "def _mom_ate(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'moment condition for average treatment effect\\n\\n    This does not include a moment condition for potential outcome mean (POM).\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return endog * wdiff - params",
            "def _mom_ate(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'moment condition for average treatment effect\\n\\n    This does not include a moment condition for potential outcome mean (POM).\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return endog * wdiff - params"
        ]
    },
    {
        "func_name": "_mom_atm",
        "original": "def _mom_atm(params, endog, tind, prob, weighted=True):\n    \"\"\"moment conditions for average treatment means (POM)\n\n    moment conditions are POM0 and POM1\n    \"\"\"\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w1 /= w1.mean()\n        w0 /= w0.mean()\n    return np.column_stack((endog * w0 - params[0], endog * w1 - params[1]))",
        "mutated": [
            "def _mom_atm(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n    'moment conditions for average treatment means (POM)\\n\\n    moment conditions are POM0 and POM1\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w1 /= w1.mean()\n        w0 /= w0.mean()\n    return np.column_stack((endog * w0 - params[0], endog * w1 - params[1]))",
            "def _mom_atm(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'moment conditions for average treatment means (POM)\\n\\n    moment conditions are POM0 and POM1\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w1 /= w1.mean()\n        w0 /= w0.mean()\n    return np.column_stack((endog * w0 - params[0], endog * w1 - params[1]))",
            "def _mom_atm(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'moment conditions for average treatment means (POM)\\n\\n    moment conditions are POM0 and POM1\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w1 /= w1.mean()\n        w0 /= w0.mean()\n    return np.column_stack((endog * w0 - params[0], endog * w1 - params[1]))",
            "def _mom_atm(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'moment conditions for average treatment means (POM)\\n\\n    moment conditions are POM0 and POM1\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w1 /= w1.mean()\n        w0 /= w0.mean()\n    return np.column_stack((endog * w0 - params[0], endog * w1 - params[1]))",
            "def _mom_atm(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'moment conditions for average treatment means (POM)\\n\\n    moment conditions are POM0 and POM1\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if weighted:\n        w1 /= w1.mean()\n        w0 /= w0.mean()\n    return np.column_stack((endog * w0 - params[0], endog * w1 - params[1]))"
        ]
    },
    {
        "func_name": "_mom_ols",
        "original": "def _mom_ols(params, endog, tind, prob, weighted=True):\n    \"\"\"\n    moment condition for average treatment mean based on OLS dummy regression\n\n    moment conditions are POM0 and POM1\n\n    \"\"\"\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((1 - tind, tind))\n    mom = (w * (endog - treat_ind.dot(params)))[:, None] * treat_ind\n    return mom",
        "mutated": [
            "def _mom_ols(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    moment conditions are POM0 and POM1\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((1 - tind, tind))\n    mom = (w * (endog - treat_ind.dot(params)))[:, None] * treat_ind\n    return mom",
            "def _mom_ols(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    moment conditions are POM0 and POM1\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((1 - tind, tind))\n    mom = (w * (endog - treat_ind.dot(params)))[:, None] * treat_ind\n    return mom",
            "def _mom_ols(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    moment conditions are POM0 and POM1\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((1 - tind, tind))\n    mom = (w * (endog - treat_ind.dot(params)))[:, None] * treat_ind\n    return mom",
            "def _mom_ols(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    moment conditions are POM0 and POM1\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((1 - tind, tind))\n    mom = (w * (endog - treat_ind.dot(params)))[:, None] * treat_ind\n    return mom",
            "def _mom_ols(params, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    moment conditions are POM0 and POM1\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((1 - tind, tind))\n    mom = (w * (endog - treat_ind.dot(params)))[:, None] * treat_ind\n    return mom"
        ]
    },
    {
        "func_name": "_mom_ols_te",
        "original": "def _mom_ols_te(tm, endog, tind, prob, weighted=True):\n    \"\"\"\n    moment condition for average treatment mean based on OLS dummy regression\n\n    first moment is ATE\n    second moment is POM0  (control)\n\n    \"\"\"\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mom = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    return mom",
        "mutated": [
            "def _mom_ols_te(tm, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    first moment is ATE\\n    second moment is POM0  (control)\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mom = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    return mom",
            "def _mom_ols_te(tm, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    first moment is ATE\\n    second moment is POM0  (control)\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mom = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    return mom",
            "def _mom_ols_te(tm, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    first moment is ATE\\n    second moment is POM0  (control)\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mom = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    return mom",
            "def _mom_ols_te(tm, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    first moment is ATE\\n    second moment is POM0  (control)\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mom = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    return mom",
            "def _mom_ols_te(tm, endog, tind, prob, weighted=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    moment condition for average treatment mean based on OLS dummy regression\\n\\n    first moment is ATE\\n    second moment is POM0  (control)\\n\\n    '\n    w = tind / prob + (1 - tind) / (1 - prob)\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mom = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    return mom"
        ]
    },
    {
        "func_name": "_mom_olsex",
        "original": "def _mom_olsex(params, model=None, exog=None, scale=None):\n    exog = exog if exog is not None else model.exog\n    fitted = model.predict(params, exog)\n    resid = model.endog - fitted\n    if scale is not None:\n        resid /= scale\n    mom = resid[:, None] * exog\n    return mom",
        "mutated": [
            "def _mom_olsex(params, model=None, exog=None, scale=None):\n    if False:\n        i = 10\n    exog = exog if exog is not None else model.exog\n    fitted = model.predict(params, exog)\n    resid = model.endog - fitted\n    if scale is not None:\n        resid /= scale\n    mom = resid[:, None] * exog\n    return mom",
            "def _mom_olsex(params, model=None, exog=None, scale=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    exog = exog if exog is not None else model.exog\n    fitted = model.predict(params, exog)\n    resid = model.endog - fitted\n    if scale is not None:\n        resid /= scale\n    mom = resid[:, None] * exog\n    return mom",
            "def _mom_olsex(params, model=None, exog=None, scale=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    exog = exog if exog is not None else model.exog\n    fitted = model.predict(params, exog)\n    resid = model.endog - fitted\n    if scale is not None:\n        resid /= scale\n    mom = resid[:, None] * exog\n    return mom",
            "def _mom_olsex(params, model=None, exog=None, scale=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    exog = exog if exog is not None else model.exog\n    fitted = model.predict(params, exog)\n    resid = model.endog - fitted\n    if scale is not None:\n        resid /= scale\n    mom = resid[:, None] * exog\n    return mom",
            "def _mom_olsex(params, model=None, exog=None, scale=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    exog = exog if exog is not None else model.exog\n    fitted = model.predict(params, exog)\n    resid = model.endog - fitted\n    if scale is not None:\n        resid /= scale\n    mom = resid[:, None] * exog\n    return mom"
        ]
    },
    {
        "func_name": "ate_ipw",
        "original": "def ate_ipw(endog, tind, prob, weighted=True, probt=None):\n    \"\"\"average treatment effect based on basic inverse propensity weighting.\n\n    \"\"\"\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if probt is not None:\n        w1 *= probt\n        w0 *= probt\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return ((endog * wdiff).mean(), (endog * w0).mean(), (endog * w1).mean())",
        "mutated": [
            "def ate_ipw(endog, tind, prob, weighted=True, probt=None):\n    if False:\n        i = 10\n    'average treatment effect based on basic inverse propensity weighting.\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if probt is not None:\n        w1 *= probt\n        w0 *= probt\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return ((endog * wdiff).mean(), (endog * w0).mean(), (endog * w1).mean())",
            "def ate_ipw(endog, tind, prob, weighted=True, probt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'average treatment effect based on basic inverse propensity weighting.\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if probt is not None:\n        w1 *= probt\n        w0 *= probt\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return ((endog * wdiff).mean(), (endog * w0).mean(), (endog * w1).mean())",
            "def ate_ipw(endog, tind, prob, weighted=True, probt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'average treatment effect based on basic inverse propensity weighting.\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if probt is not None:\n        w1 *= probt\n        w0 *= probt\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return ((endog * wdiff).mean(), (endog * w0).mean(), (endog * w1).mean())",
            "def ate_ipw(endog, tind, prob, weighted=True, probt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'average treatment effect based on basic inverse propensity weighting.\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if probt is not None:\n        w1 *= probt\n        w0 *= probt\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return ((endog * wdiff).mean(), (endog * w0).mean(), (endog * w1).mean())",
            "def ate_ipw(endog, tind, prob, weighted=True, probt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'average treatment effect based on basic inverse propensity weighting.\\n\\n    '\n    w1 = tind / prob\n    w0 = (1.0 - tind) / (1.0 - prob)\n    if probt is not None:\n        w1 *= probt\n        w0 *= probt\n    if weighted:\n        w0 /= w0.mean()\n        w1 /= w1.mean()\n    wdiff = w1 - w0\n    return ((endog * wdiff).mean(), (endog * w0).mean(), (endog * w1).mean())"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, endog, res_select, mom_outcome, exclude_tmoms=False, **kwargs):\n    super(_TEGMMGeneric1, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    self.exclude_tmoms = exclude_tmoms\n    self.__dict__.update(kwargs)\n    if self.data.xnames is None:\n        self.data.xnames = []\n    if exclude_tmoms:\n        self.k_select = 0\n    else:\n        self.k_select = len(res_select.model.data.param_names)\n    if exclude_tmoms:\n        self.prob = self.results_select.predict()\n    else:\n        self.prob = None",
        "mutated": [
            "def __init__(self, endog, res_select, mom_outcome, exclude_tmoms=False, **kwargs):\n    if False:\n        i = 10\n    super(_TEGMMGeneric1, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    self.exclude_tmoms = exclude_tmoms\n    self.__dict__.update(kwargs)\n    if self.data.xnames is None:\n        self.data.xnames = []\n    if exclude_tmoms:\n        self.k_select = 0\n    else:\n        self.k_select = len(res_select.model.data.param_names)\n    if exclude_tmoms:\n        self.prob = self.results_select.predict()\n    else:\n        self.prob = None",
            "def __init__(self, endog, res_select, mom_outcome, exclude_tmoms=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(_TEGMMGeneric1, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    self.exclude_tmoms = exclude_tmoms\n    self.__dict__.update(kwargs)\n    if self.data.xnames is None:\n        self.data.xnames = []\n    if exclude_tmoms:\n        self.k_select = 0\n    else:\n        self.k_select = len(res_select.model.data.param_names)\n    if exclude_tmoms:\n        self.prob = self.results_select.predict()\n    else:\n        self.prob = None",
            "def __init__(self, endog, res_select, mom_outcome, exclude_tmoms=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(_TEGMMGeneric1, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    self.exclude_tmoms = exclude_tmoms\n    self.__dict__.update(kwargs)\n    if self.data.xnames is None:\n        self.data.xnames = []\n    if exclude_tmoms:\n        self.k_select = 0\n    else:\n        self.k_select = len(res_select.model.data.param_names)\n    if exclude_tmoms:\n        self.prob = self.results_select.predict()\n    else:\n        self.prob = None",
            "def __init__(self, endog, res_select, mom_outcome, exclude_tmoms=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(_TEGMMGeneric1, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    self.exclude_tmoms = exclude_tmoms\n    self.__dict__.update(kwargs)\n    if self.data.xnames is None:\n        self.data.xnames = []\n    if exclude_tmoms:\n        self.k_select = 0\n    else:\n        self.k_select = len(res_select.model.data.param_names)\n    if exclude_tmoms:\n        self.prob = self.results_select.predict()\n    else:\n        self.prob = None",
            "def __init__(self, endog, res_select, mom_outcome, exclude_tmoms=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(_TEGMMGeneric1, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    self.exclude_tmoms = exclude_tmoms\n    self.__dict__.update(kwargs)\n    if self.data.xnames is None:\n        self.data.xnames = []\n    if exclude_tmoms:\n        self.k_select = 0\n    else:\n        self.k_select = len(res_select.model.data.param_names)\n    if exclude_tmoms:\n        self.prob = self.results_select.predict()\n    else:\n        self.prob = None"
        ]
    },
    {
        "func_name": "momcond",
        "original": "def momcond(self, params):\n    k_outcome = len(params) - self.k_select\n    tm = params[:k_outcome]\n    p_tm = params[k_outcome:]\n    tind = self.results_select.model.endog\n    if self.exclude_tmoms:\n        prob = self.prob\n    else:\n        prob = self.results_select.model.predict(p_tm)\n    moms_list = []\n    mom_o = self.mom_outcome(tm, self.endog, tind, prob, weighted=True)\n    moms_list.append(mom_o)\n    if not self.exclude_tmoms:\n        mom_t = self.results_select.model.score_obs(p_tm)\n        moms_list.append(mom_t)\n    moms = np.column_stack(moms_list)\n    return moms",
        "mutated": [
            "def momcond(self, params):\n    if False:\n        i = 10\n    k_outcome = len(params) - self.k_select\n    tm = params[:k_outcome]\n    p_tm = params[k_outcome:]\n    tind = self.results_select.model.endog\n    if self.exclude_tmoms:\n        prob = self.prob\n    else:\n        prob = self.results_select.model.predict(p_tm)\n    moms_list = []\n    mom_o = self.mom_outcome(tm, self.endog, tind, prob, weighted=True)\n    moms_list.append(mom_o)\n    if not self.exclude_tmoms:\n        mom_t = self.results_select.model.score_obs(p_tm)\n        moms_list.append(mom_t)\n    moms = np.column_stack(moms_list)\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    k_outcome = len(params) - self.k_select\n    tm = params[:k_outcome]\n    p_tm = params[k_outcome:]\n    tind = self.results_select.model.endog\n    if self.exclude_tmoms:\n        prob = self.prob\n    else:\n        prob = self.results_select.model.predict(p_tm)\n    moms_list = []\n    mom_o = self.mom_outcome(tm, self.endog, tind, prob, weighted=True)\n    moms_list.append(mom_o)\n    if not self.exclude_tmoms:\n        mom_t = self.results_select.model.score_obs(p_tm)\n        moms_list.append(mom_t)\n    moms = np.column_stack(moms_list)\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    k_outcome = len(params) - self.k_select\n    tm = params[:k_outcome]\n    p_tm = params[k_outcome:]\n    tind = self.results_select.model.endog\n    if self.exclude_tmoms:\n        prob = self.prob\n    else:\n        prob = self.results_select.model.predict(p_tm)\n    moms_list = []\n    mom_o = self.mom_outcome(tm, self.endog, tind, prob, weighted=True)\n    moms_list.append(mom_o)\n    if not self.exclude_tmoms:\n        mom_t = self.results_select.model.score_obs(p_tm)\n        moms_list.append(mom_t)\n    moms = np.column_stack(moms_list)\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    k_outcome = len(params) - self.k_select\n    tm = params[:k_outcome]\n    p_tm = params[k_outcome:]\n    tind = self.results_select.model.endog\n    if self.exclude_tmoms:\n        prob = self.prob\n    else:\n        prob = self.results_select.model.predict(p_tm)\n    moms_list = []\n    mom_o = self.mom_outcome(tm, self.endog, tind, prob, weighted=True)\n    moms_list.append(mom_o)\n    if not self.exclude_tmoms:\n        mom_t = self.results_select.model.score_obs(p_tm)\n        moms_list.append(mom_t)\n    moms = np.column_stack(moms_list)\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    k_outcome = len(params) - self.k_select\n    tm = params[:k_outcome]\n    p_tm = params[k_outcome:]\n    tind = self.results_select.model.endog\n    if self.exclude_tmoms:\n        prob = self.prob\n    else:\n        prob = self.results_select.model.predict(p_tm)\n    moms_list = []\n    mom_o = self.mom_outcome(tm, self.endog, tind, prob, weighted=True)\n    moms_list.append(mom_o)\n    if not self.exclude_tmoms:\n        mom_t = self.results_select.model.score_obs(p_tm)\n        moms_list.append(mom_t)\n    moms = np.column_stack(moms_list)\n    return moms"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, endog, res_select, mom_outcome):\n    super(_TEGMM, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    if self.data.xnames is None:\n        self.data.xnames = []",
        "mutated": [
            "def __init__(self, endog, res_select, mom_outcome):\n    if False:\n        i = 10\n    super(_TEGMM, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    if self.data.xnames is None:\n        self.data.xnames = []",
            "def __init__(self, endog, res_select, mom_outcome):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(_TEGMM, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    if self.data.xnames is None:\n        self.data.xnames = []",
            "def __init__(self, endog, res_select, mom_outcome):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(_TEGMM, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    if self.data.xnames is None:\n        self.data.xnames = []",
            "def __init__(self, endog, res_select, mom_outcome):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(_TEGMM, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    if self.data.xnames is None:\n        self.data.xnames = []",
            "def __init__(self, endog, res_select, mom_outcome):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(_TEGMM, self).__init__(endog, None, None)\n    self.results_select = res_select\n    self.mom_outcome = mom_outcome\n    if self.data.xnames is None:\n        self.data.xnames = []"
        ]
    },
    {
        "func_name": "momcond",
        "original": "def momcond(self, params):\n    tm = params[:2]\n    p_tm = params[2:]\n    tind = self.results_select.model.endog\n    prob = self.results_select.model.predict(p_tm)\n    momt = self.mom_outcome(tm, self.endog, tind, prob)\n    moms = np.column_stack((momt, self.results_select.model.score_obs(p_tm)))\n    return moms",
        "mutated": [
            "def momcond(self, params):\n    if False:\n        i = 10\n    tm = params[:2]\n    p_tm = params[2:]\n    tind = self.results_select.model.endog\n    prob = self.results_select.model.predict(p_tm)\n    momt = self.mom_outcome(tm, self.endog, tind, prob)\n    moms = np.column_stack((momt, self.results_select.model.score_obs(p_tm)))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    tm = params[:2]\n    p_tm = params[2:]\n    tind = self.results_select.model.endog\n    prob = self.results_select.model.predict(p_tm)\n    momt = self.mom_outcome(tm, self.endog, tind, prob)\n    moms = np.column_stack((momt, self.results_select.model.score_obs(p_tm)))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    tm = params[:2]\n    p_tm = params[2:]\n    tind = self.results_select.model.endog\n    prob = self.results_select.model.predict(p_tm)\n    momt = self.mom_outcome(tm, self.endog, tind, prob)\n    moms = np.column_stack((momt, self.results_select.model.score_obs(p_tm)))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    tm = params[:2]\n    p_tm = params[2:]\n    tind = self.results_select.model.endog\n    prob = self.results_select.model.predict(p_tm)\n    momt = self.mom_outcome(tm, self.endog, tind, prob)\n    moms = np.column_stack((momt, self.results_select.model.score_obs(p_tm)))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    tm = params[:2]\n    p_tm = params[2:]\n    tind = self.results_select.model.endog\n    prob = self.results_select.model.predict(p_tm)\n    momt = self.mom_outcome(tm, self.endog, tind, prob)\n    moms = np.column_stack((momt, self.results_select.model.score_obs(p_tm)))\n    return moms"
        ]
    },
    {
        "func_name": "momcond",
        "original": "def momcond(self, params):\n    ra = self.teff\n    res_select = ra.results_select\n    tind = ra.treatment\n    endog = ra.model_pool.endog\n    effect_group = self.effect_group\n    tm = params[:2]\n    ps = params[2:]\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob = prob_sel\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n    elif isinstance(effect_group, np.ndarray):\n        probt = probt\n    else:\n        raise ValueError('incorrect option for effect_group')\n    w = tind / prob + (1 - tind) / (1 - prob)\n    if probt is not None:\n        w *= probt\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mm = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    mom_select = res_select.model.score_obs(ps)\n    moms = np.column_stack((mm, mom_select))\n    return moms",
        "mutated": [
            "def momcond(self, params):\n    if False:\n        i = 10\n    ra = self.teff\n    res_select = ra.results_select\n    tind = ra.treatment\n    endog = ra.model_pool.endog\n    effect_group = self.effect_group\n    tm = params[:2]\n    ps = params[2:]\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob = prob_sel\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n    elif isinstance(effect_group, np.ndarray):\n        probt = probt\n    else:\n        raise ValueError('incorrect option for effect_group')\n    w = tind / prob + (1 - tind) / (1 - prob)\n    if probt is not None:\n        w *= probt\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mm = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    mom_select = res_select.model.score_obs(ps)\n    moms = np.column_stack((mm, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ra = self.teff\n    res_select = ra.results_select\n    tind = ra.treatment\n    endog = ra.model_pool.endog\n    effect_group = self.effect_group\n    tm = params[:2]\n    ps = params[2:]\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob = prob_sel\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n    elif isinstance(effect_group, np.ndarray):\n        probt = probt\n    else:\n        raise ValueError('incorrect option for effect_group')\n    w = tind / prob + (1 - tind) / (1 - prob)\n    if probt is not None:\n        w *= probt\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mm = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    mom_select = res_select.model.score_obs(ps)\n    moms = np.column_stack((mm, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ra = self.teff\n    res_select = ra.results_select\n    tind = ra.treatment\n    endog = ra.model_pool.endog\n    effect_group = self.effect_group\n    tm = params[:2]\n    ps = params[2:]\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob = prob_sel\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n    elif isinstance(effect_group, np.ndarray):\n        probt = probt\n    else:\n        raise ValueError('incorrect option for effect_group')\n    w = tind / prob + (1 - tind) / (1 - prob)\n    if probt is not None:\n        w *= probt\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mm = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    mom_select = res_select.model.score_obs(ps)\n    moms = np.column_stack((mm, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ra = self.teff\n    res_select = ra.results_select\n    tind = ra.treatment\n    endog = ra.model_pool.endog\n    effect_group = self.effect_group\n    tm = params[:2]\n    ps = params[2:]\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob = prob_sel\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n    elif isinstance(effect_group, np.ndarray):\n        probt = probt\n    else:\n        raise ValueError('incorrect option for effect_group')\n    w = tind / prob + (1 - tind) / (1 - prob)\n    if probt is not None:\n        w *= probt\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mm = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    mom_select = res_select.model.score_obs(ps)\n    moms = np.column_stack((mm, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ra = self.teff\n    res_select = ra.results_select\n    tind = ra.treatment\n    endog = ra.model_pool.endog\n    effect_group = self.effect_group\n    tm = params[:2]\n    ps = params[2:]\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob = prob_sel\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n    elif isinstance(effect_group, np.ndarray):\n        probt = probt\n    else:\n        raise ValueError('incorrect option for effect_group')\n    w = tind / prob + (1 - tind) / (1 - prob)\n    if probt is not None:\n        w *= probt\n    treat_ind = np.column_stack((tind, np.ones(len(tind))))\n    mm = (w * (endog - treat_ind.dot(tm)))[:, None] * treat_ind\n    mom_select = res_select.model.score_obs(ps)\n    moms = np.column_stack((mm, mom_select))\n    return moms"
        ]
    },
    {
        "func_name": "momcond",
        "original": "def momcond(self, params):\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[2 * k + 1:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
        "mutated": [
            "def momcond(self, params):\n    if False:\n        i = 10\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[2 * k + 1:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[2 * k + 1:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[2 * k + 1:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[2 * k + 1:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[2 * k + 1:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.01, 0.99)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms"
        ]
    },
    {
        "func_name": "momcond",
        "original": "def momcond(self, params):\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    tind = 0\n    ww0 = (1 - tind) / (1 - prob0) * ((1 - tind) / (1 - prob0) - 1)\n    tind = 1\n    ww1 = tind / prob1 * (tind / prob1 - 1)\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * ww0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * ww1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
        "mutated": [
            "def momcond(self, params):\n    if False:\n        i = 10\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    tind = 0\n    ww0 = (1 - tind) / (1 - prob0) * ((1 - tind) / (1 - prob0) - 1)\n    tind = 1\n    ww1 = tind / prob1 * (tind / prob1 - 1)\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * ww0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * ww1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    tind = 0\n    ww0 = (1 - tind) / (1 - prob0) * ((1 - tind) / (1 - prob0) - 1)\n    tind = 1\n    ww1 = tind / prob1 * (tind / prob1 - 1)\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * ww0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * ww1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    tind = 0\n    ww0 = (1 - tind) / (1 - prob0) * ((1 - tind) / (1 - prob0) - 1)\n    tind = 1\n    ww1 = tind / prob1 * (tind / prob1 - 1)\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * ww0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * ww1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    tind = 0\n    ww0 = (1 - tind) / (1 - prob0) * ((1 - tind) / (1 - prob0) - 1)\n    tind = 1\n    ww1 = tind / prob1 * (tind / prob1 - 1)\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * ww0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * ww1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    endog = ra.endog_grouped\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    prob = np.concatenate((prob0, prob1))\n    tind = 0\n    ww0 = (1 - tind) / (1 - prob0) * ((1 - tind) / (1 - prob0) - 1)\n    tind = 1\n    ww1 = tind / prob1 * (tind / prob1 - 1)\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * ww0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * ww1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    tind = ra.treatment\n    tind = np.concatenate((tind[~treat_mask], tind[treat_mask]))\n    correct0 = (endog - fitted0) / (1 - prob) * (1 - tind)\n    correct1 = (endog - fitted1) / prob * tind\n    tmean0 = fitted0 + correct0\n    tmean1 = fitted1 + correct1\n    ate = tmean1 - tmean0\n    mm = ate - pm\n    mpom = tmean0 - ppom\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms"
        ]
    },
    {
        "func_name": "momcond",
        "original": "def momcond(self, params):\n    ra = self.teff\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[-k:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    momout = block_diag(mom0, mom1)\n    mm = fitted1 - fitted0 - pm\n    mpom = fitted0 - ppom\n    mm = np.column_stack((mm, mpom))\n    if self.probt is not None:\n        mm *= (self.probt / self.probt.mean())[:, None]\n    moms = np.column_stack((mm, momout))\n    return moms",
        "mutated": [
            "def momcond(self, params):\n    if False:\n        i = 10\n    ra = self.teff\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[-k:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    momout = block_diag(mom0, mom1)\n    mm = fitted1 - fitted0 - pm\n    mpom = fitted0 - ppom\n    mm = np.column_stack((mm, mpom))\n    if self.probt is not None:\n        mm *= (self.probt / self.probt.mean())[:, None]\n    moms = np.column_stack((mm, momout))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ra = self.teff\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[-k:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    momout = block_diag(mom0, mom1)\n    mm = fitted1 - fitted0 - pm\n    mpom = fitted0 - ppom\n    mm = np.column_stack((mm, mpom))\n    if self.probt is not None:\n        mm *= (self.probt / self.probt.mean())[:, None]\n    moms = np.column_stack((mm, momout))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ra = self.teff\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[-k:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    momout = block_diag(mom0, mom1)\n    mm = fitted1 - fitted0 - pm\n    mpom = fitted0 - ppom\n    mm = np.column_stack((mm, mpom))\n    if self.probt is not None:\n        mm *= (self.probt / self.probt.mean())[:, None]\n    moms = np.column_stack((mm, momout))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ra = self.teff\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[-k:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    momout = block_diag(mom0, mom1)\n    mm = fitted1 - fitted0 - pm\n    mpom = fitted0 - ppom\n    mm = np.column_stack((mm, mpom))\n    if self.probt is not None:\n        mm *= (self.probt / self.probt.mean())[:, None]\n    moms = np.column_stack((mm, momout))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ra = self.teff\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[-k:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0)\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1)\n    momout = block_diag(mom0, mom1)\n    mm = fitted1 - fitted0 - pm\n    mpom = fitted0 - ppom\n    mm = np.column_stack((mm, mpom))\n    if self.probt is not None:\n        mm *= (self.probt / self.probt.mean())[:, None]\n    moms = np.column_stack((mm, momout))\n    return moms"
        ]
    },
    {
        "func_name": "momcond",
        "original": "def momcond(self, params):\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    tind = np.zeros(len(treat_mask))\n    tind[-treat_mask.sum():] = 1\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    effect_group = self.effect_group\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        sind = 1\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        sind = tind / tind.mean()\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        sind = 1 - tind\n        sind /= sind.mean()\n    else:\n        raise ValueError('incorrect option for effect_group')\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * w0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * w1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    mm = (fitted1 - fitted0 - pm) * sind\n    mpom = (fitted0 - ppom) * sind\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
        "mutated": [
            "def momcond(self, params):\n    if False:\n        i = 10\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    tind = np.zeros(len(treat_mask))\n    tind[-treat_mask.sum():] = 1\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    effect_group = self.effect_group\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        sind = 1\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        sind = tind / tind.mean()\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        sind = 1 - tind\n        sind /= sind.mean()\n    else:\n        raise ValueError('incorrect option for effect_group')\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * w0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * w1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    mm = (fitted1 - fitted0 - pm) * sind\n    mpom = (fitted0 - ppom) * sind\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    tind = np.zeros(len(treat_mask))\n    tind[-treat_mask.sum():] = 1\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    effect_group = self.effect_group\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        sind = 1\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        sind = tind / tind.mean()\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        sind = 1 - tind\n        sind /= sind.mean()\n    else:\n        raise ValueError('incorrect option for effect_group')\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * w0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * w1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    mm = (fitted1 - fitted0 - pm) * sind\n    mpom = (fitted0 - ppom) * sind\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    tind = np.zeros(len(treat_mask))\n    tind[-treat_mask.sum():] = 1\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    effect_group = self.effect_group\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        sind = 1\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        sind = tind / tind.mean()\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        sind = 1 - tind\n        sind /= sind.mean()\n    else:\n        raise ValueError('incorrect option for effect_group')\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * w0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * w1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    mm = (fitted1 - fitted0 - pm) * sind\n    mpom = (fitted0 - ppom) * sind\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    tind = np.zeros(len(treat_mask))\n    tind[-treat_mask.sum():] = 1\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    effect_group = self.effect_group\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        sind = 1\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        sind = tind / tind.mean()\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        sind = 1 - tind\n        sind /= sind.mean()\n    else:\n        raise ValueError('incorrect option for effect_group')\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * w0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * w1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    mm = (fitted1 - fitted0 - pm) * sind\n    mpom = (fitted0 - ppom) * sind\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms",
            "def momcond(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ra = self.teff\n    treat_mask = ra.treat_mask\n    res_select = ra.results_select\n    ppom = params[1]\n    mask = np.arange(len(params)) != 1\n    params = params[mask]\n    k = ra.results0.model.exog.shape[1]\n    pm = params[0]\n    p0 = params[1:k + 1]\n    p1 = params[k + 1:2 * k + 1]\n    ps = params[-6:]\n    mod0 = ra.results0.model\n    mod1 = ra.results1.model\n    exog = ra.exog_grouped\n    tind = np.zeros(len(treat_mask))\n    tind[-treat_mask.sum():] = 1\n    prob_sel = np.asarray(res_select.model.predict(ps))\n    prob_sel = np.clip(prob_sel, 0.001, 0.999)\n    prob0 = prob_sel[~treat_mask]\n    prob1 = prob_sel[treat_mask]\n    effect_group = self.effect_group\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        sind = 1\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        sind = tind / tind.mean()\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        sind = 1 - tind\n        sind /= sind.mean()\n    else:\n        raise ValueError('incorrect option for effect_group')\n    fitted0 = mod0.predict(p0, exog)\n    mom0 = _mom_olsex(p0, model=mod0) * w0[:, None]\n    fitted1 = mod1.predict(p1, exog)\n    mom1 = _mom_olsex(p1, model=mod1) * w1[:, None]\n    mom_outcome = block_diag(mom0, mom1)\n    mm = (fitted1 - fitted0 - pm) * sind\n    mpom = (fitted0 - ppom) * sind\n    mm = np.column_stack((mm, mpom))\n    mom_select = res_select.model.score_obs(ps)\n    mom_select = np.concatenate((mom_select[~treat_mask], mom_select[treat_mask]), axis=0)\n    moms = np.column_stack((mm, mom_outcome, mom_select))\n    return moms"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, teff, results_gmm, method, **kwds):\n    super().__init__()\n    k_params = len(results_gmm.params)\n    constraints = np.zeros((3, k_params))\n    constraints[0, 0] = 1\n    constraints[1, 1] = 1\n    constraints[2, :2] = [1, 1]\n    tt = results_gmm.t_test(constraints)\n    self.__dict__.update(tt.__dict__)\n    self.teff = teff\n    self.results_gmm = results_gmm\n    self.method = method\n    self.__dict__.update(kwds)\n    self.c_names = ['ATE', 'POM0', 'POM1']",
        "mutated": [
            "def __init__(self, teff, results_gmm, method, **kwds):\n    if False:\n        i = 10\n    super().__init__()\n    k_params = len(results_gmm.params)\n    constraints = np.zeros((3, k_params))\n    constraints[0, 0] = 1\n    constraints[1, 1] = 1\n    constraints[2, :2] = [1, 1]\n    tt = results_gmm.t_test(constraints)\n    self.__dict__.update(tt.__dict__)\n    self.teff = teff\n    self.results_gmm = results_gmm\n    self.method = method\n    self.__dict__.update(kwds)\n    self.c_names = ['ATE', 'POM0', 'POM1']",
            "def __init__(self, teff, results_gmm, method, **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__()\n    k_params = len(results_gmm.params)\n    constraints = np.zeros((3, k_params))\n    constraints[0, 0] = 1\n    constraints[1, 1] = 1\n    constraints[2, :2] = [1, 1]\n    tt = results_gmm.t_test(constraints)\n    self.__dict__.update(tt.__dict__)\n    self.teff = teff\n    self.results_gmm = results_gmm\n    self.method = method\n    self.__dict__.update(kwds)\n    self.c_names = ['ATE', 'POM0', 'POM1']",
            "def __init__(self, teff, results_gmm, method, **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__()\n    k_params = len(results_gmm.params)\n    constraints = np.zeros((3, k_params))\n    constraints[0, 0] = 1\n    constraints[1, 1] = 1\n    constraints[2, :2] = [1, 1]\n    tt = results_gmm.t_test(constraints)\n    self.__dict__.update(tt.__dict__)\n    self.teff = teff\n    self.results_gmm = results_gmm\n    self.method = method\n    self.__dict__.update(kwds)\n    self.c_names = ['ATE', 'POM0', 'POM1']",
            "def __init__(self, teff, results_gmm, method, **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__()\n    k_params = len(results_gmm.params)\n    constraints = np.zeros((3, k_params))\n    constraints[0, 0] = 1\n    constraints[1, 1] = 1\n    constraints[2, :2] = [1, 1]\n    tt = results_gmm.t_test(constraints)\n    self.__dict__.update(tt.__dict__)\n    self.teff = teff\n    self.results_gmm = results_gmm\n    self.method = method\n    self.__dict__.update(kwds)\n    self.c_names = ['ATE', 'POM0', 'POM1']",
            "def __init__(self, teff, results_gmm, method, **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__()\n    k_params = len(results_gmm.params)\n    constraints = np.zeros((3, k_params))\n    constraints[0, 0] = 1\n    constraints[1, 1] = 1\n    constraints[2, :2] = [1, 1]\n    tt = results_gmm.t_test(constraints)\n    self.__dict__.update(tt.__dict__)\n    self.teff = teff\n    self.results_gmm = results_gmm\n    self.method = method\n    self.__dict__.update(kwds)\n    self.c_names = ['ATE', 'POM0', 'POM1']"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, model, treatment, results_select=None, _cov_type='HC0', **kwds):\n    self.__dict__.update(kwds)\n    self.treatment = np.asarray(treatment)\n    self.treat_mask = treat_mask = treatment == 1\n    if results_select is not None:\n        self.results_select = results_select\n        self.prob_select = results_select.predict()\n    self.model_pool = model\n    endog = model.endog\n    exog = model.exog\n    self.nobs = endog.shape[0]\n    self._cov_type = _cov_type\n    mod0 = model.__class__(endog[~treat_mask], exog[~treat_mask])\n    self.results0 = mod0.fit(cov_type=_cov_type)\n    mod1 = model.__class__(endog[treat_mask], exog[treat_mask])\n    self.results1 = mod1.fit(cov_type=_cov_type)\n    self.exog_grouped = np.concatenate((mod0.exog, mod1.exog), axis=0)\n    self.endog_grouped = np.concatenate((mod0.endog, mod1.endog), axis=0)",
        "mutated": [
            "def __init__(self, model, treatment, results_select=None, _cov_type='HC0', **kwds):\n    if False:\n        i = 10\n    self.__dict__.update(kwds)\n    self.treatment = np.asarray(treatment)\n    self.treat_mask = treat_mask = treatment == 1\n    if results_select is not None:\n        self.results_select = results_select\n        self.prob_select = results_select.predict()\n    self.model_pool = model\n    endog = model.endog\n    exog = model.exog\n    self.nobs = endog.shape[0]\n    self._cov_type = _cov_type\n    mod0 = model.__class__(endog[~treat_mask], exog[~treat_mask])\n    self.results0 = mod0.fit(cov_type=_cov_type)\n    mod1 = model.__class__(endog[treat_mask], exog[treat_mask])\n    self.results1 = mod1.fit(cov_type=_cov_type)\n    self.exog_grouped = np.concatenate((mod0.exog, mod1.exog), axis=0)\n    self.endog_grouped = np.concatenate((mod0.endog, mod1.endog), axis=0)",
            "def __init__(self, model, treatment, results_select=None, _cov_type='HC0', **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__dict__.update(kwds)\n    self.treatment = np.asarray(treatment)\n    self.treat_mask = treat_mask = treatment == 1\n    if results_select is not None:\n        self.results_select = results_select\n        self.prob_select = results_select.predict()\n    self.model_pool = model\n    endog = model.endog\n    exog = model.exog\n    self.nobs = endog.shape[0]\n    self._cov_type = _cov_type\n    mod0 = model.__class__(endog[~treat_mask], exog[~treat_mask])\n    self.results0 = mod0.fit(cov_type=_cov_type)\n    mod1 = model.__class__(endog[treat_mask], exog[treat_mask])\n    self.results1 = mod1.fit(cov_type=_cov_type)\n    self.exog_grouped = np.concatenate((mod0.exog, mod1.exog), axis=0)\n    self.endog_grouped = np.concatenate((mod0.endog, mod1.endog), axis=0)",
            "def __init__(self, model, treatment, results_select=None, _cov_type='HC0', **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__dict__.update(kwds)\n    self.treatment = np.asarray(treatment)\n    self.treat_mask = treat_mask = treatment == 1\n    if results_select is not None:\n        self.results_select = results_select\n        self.prob_select = results_select.predict()\n    self.model_pool = model\n    endog = model.endog\n    exog = model.exog\n    self.nobs = endog.shape[0]\n    self._cov_type = _cov_type\n    mod0 = model.__class__(endog[~treat_mask], exog[~treat_mask])\n    self.results0 = mod0.fit(cov_type=_cov_type)\n    mod1 = model.__class__(endog[treat_mask], exog[treat_mask])\n    self.results1 = mod1.fit(cov_type=_cov_type)\n    self.exog_grouped = np.concatenate((mod0.exog, mod1.exog), axis=0)\n    self.endog_grouped = np.concatenate((mod0.endog, mod1.endog), axis=0)",
            "def __init__(self, model, treatment, results_select=None, _cov_type='HC0', **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__dict__.update(kwds)\n    self.treatment = np.asarray(treatment)\n    self.treat_mask = treat_mask = treatment == 1\n    if results_select is not None:\n        self.results_select = results_select\n        self.prob_select = results_select.predict()\n    self.model_pool = model\n    endog = model.endog\n    exog = model.exog\n    self.nobs = endog.shape[0]\n    self._cov_type = _cov_type\n    mod0 = model.__class__(endog[~treat_mask], exog[~treat_mask])\n    self.results0 = mod0.fit(cov_type=_cov_type)\n    mod1 = model.__class__(endog[treat_mask], exog[treat_mask])\n    self.results1 = mod1.fit(cov_type=_cov_type)\n    self.exog_grouped = np.concatenate((mod0.exog, mod1.exog), axis=0)\n    self.endog_grouped = np.concatenate((mod0.endog, mod1.endog), axis=0)",
            "def __init__(self, model, treatment, results_select=None, _cov_type='HC0', **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__dict__.update(kwds)\n    self.treatment = np.asarray(treatment)\n    self.treat_mask = treat_mask = treatment == 1\n    if results_select is not None:\n        self.results_select = results_select\n        self.prob_select = results_select.predict()\n    self.model_pool = model\n    endog = model.endog\n    exog = model.exog\n    self.nobs = endog.shape[0]\n    self._cov_type = _cov_type\n    mod0 = model.__class__(endog[~treat_mask], exog[~treat_mask])\n    self.results0 = mod0.fit(cov_type=_cov_type)\n    mod1 = model.__class__(endog[treat_mask], exog[treat_mask])\n    self.results1 = mod1.fit(cov_type=_cov_type)\n    self.exog_grouped = np.concatenate((mod0.exog, mod1.exog), axis=0)\n    self.endog_grouped = np.concatenate((mod0.endog, mod1.endog), axis=0)"
        ]
    },
    {
        "func_name": "from_data",
        "original": "@classmethod\ndef from_data(cls, endog, exog, treatment, model='ols', **kwds):\n    \"\"\"create models from data\n\n        not yet implemented\n\n        \"\"\"\n    raise NotImplementedError",
        "mutated": [
            "@classmethod\ndef from_data(cls, endog, exog, treatment, model='ols', **kwds):\n    if False:\n        i = 10\n    'create models from data\\n\\n        not yet implemented\\n\\n        '\n    raise NotImplementedError",
            "@classmethod\ndef from_data(cls, endog, exog, treatment, model='ols', **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'create models from data\\n\\n        not yet implemented\\n\\n        '\n    raise NotImplementedError",
            "@classmethod\ndef from_data(cls, endog, exog, treatment, model='ols', **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'create models from data\\n\\n        not yet implemented\\n\\n        '\n    raise NotImplementedError",
            "@classmethod\ndef from_data(cls, endog, exog, treatment, model='ols', **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'create models from data\\n\\n        not yet implemented\\n\\n        '\n    raise NotImplementedError",
            "@classmethod\ndef from_data(cls, endog, exog, treatment, model='ols', **kwds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'create models from data\\n\\n        not yet implemented\\n\\n        '\n    raise NotImplementedError"
        ]
    },
    {
        "func_name": "ipw",
        "original": "def ipw(self, return_results=True, effect_group='all', disp=False):\n    \"\"\"Inverse Probability Weighted treatment effect estimation.\n\n        Parameters\n        ----------\n        return_results : bool\n            If True, then a results instance is returned.\n            If False, just ATE, POM0 and POM1 are returned.\n        effect_group : {\"all\", 0, 1}\n            ``effectgroup`` determines for which population the effects are\n            estimated.\n            If effect_group is \"all\", then sample average treatment effect and\n            potential outcomes are returned.\n            If effect_group is 1 or \"treated\", then effects on treated are\n            returned.\n            If effect_group is 0, \"treated\" or \"control\", then effects on\n            untreated, i.e. control group, are returned.\n        disp : bool\n            Indicates whether the scipy optimizer should display the\n            optimization results\n\n        Returns\n        -------\n        TreatmentEffectsResults instance or tuple (ATE, POM0, POM1)\n\n        See Also\n        --------\n        TreatmentEffectsResults\n        \"\"\"\n    endog = self.model_pool.endog\n    tind = self.treatment\n    prob = self.prob_select\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    res_ipw = ate_ipw(endog, tind, prob, weighted=True, probt=probt)\n    if not return_results:\n        return res_ipw\n    gmm = _IPWGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate((res_ipw[:2], self.results_select.params))\n    res_gmm = gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
        "mutated": [
            "def ipw(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n    'Inverse Probability Weighted treatment effect estimation.\\n\\n        Parameters\\n        ----------\\n        return_results : bool\\n            If True, then a results instance is returned.\\n            If False, just ATE, POM0 and POM1 are returned.\\n        effect_group : {\"all\", 0, 1}\\n            ``effectgroup`` determines for which population the effects are\\n            estimated.\\n            If effect_group is \"all\", then sample average treatment effect and\\n            potential outcomes are returned.\\n            If effect_group is 1 or \"treated\", then effects on treated are\\n            returned.\\n            If effect_group is 0, \"treated\" or \"control\", then effects on\\n            untreated, i.e. control group, are returned.\\n        disp : bool\\n            Indicates whether the scipy optimizer should display the\\n            optimization results\\n\\n        Returns\\n        -------\\n        TreatmentEffectsResults instance or tuple (ATE, POM0, POM1)\\n\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    endog = self.model_pool.endog\n    tind = self.treatment\n    prob = self.prob_select\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    res_ipw = ate_ipw(endog, tind, prob, weighted=True, probt=probt)\n    if not return_results:\n        return res_ipw\n    gmm = _IPWGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate((res_ipw[:2], self.results_select.params))\n    res_gmm = gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "def ipw(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Inverse Probability Weighted treatment effect estimation.\\n\\n        Parameters\\n        ----------\\n        return_results : bool\\n            If True, then a results instance is returned.\\n            If False, just ATE, POM0 and POM1 are returned.\\n        effect_group : {\"all\", 0, 1}\\n            ``effectgroup`` determines for which population the effects are\\n            estimated.\\n            If effect_group is \"all\", then sample average treatment effect and\\n            potential outcomes are returned.\\n            If effect_group is 1 or \"treated\", then effects on treated are\\n            returned.\\n            If effect_group is 0, \"treated\" or \"control\", then effects on\\n            untreated, i.e. control group, are returned.\\n        disp : bool\\n            Indicates whether the scipy optimizer should display the\\n            optimization results\\n\\n        Returns\\n        -------\\n        TreatmentEffectsResults instance or tuple (ATE, POM0, POM1)\\n\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    endog = self.model_pool.endog\n    tind = self.treatment\n    prob = self.prob_select\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    res_ipw = ate_ipw(endog, tind, prob, weighted=True, probt=probt)\n    if not return_results:\n        return res_ipw\n    gmm = _IPWGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate((res_ipw[:2], self.results_select.params))\n    res_gmm = gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "def ipw(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Inverse Probability Weighted treatment effect estimation.\\n\\n        Parameters\\n        ----------\\n        return_results : bool\\n            If True, then a results instance is returned.\\n            If False, just ATE, POM0 and POM1 are returned.\\n        effect_group : {\"all\", 0, 1}\\n            ``effectgroup`` determines for which population the effects are\\n            estimated.\\n            If effect_group is \"all\", then sample average treatment effect and\\n            potential outcomes are returned.\\n            If effect_group is 1 or \"treated\", then effects on treated are\\n            returned.\\n            If effect_group is 0, \"treated\" or \"control\", then effects on\\n            untreated, i.e. control group, are returned.\\n        disp : bool\\n            Indicates whether the scipy optimizer should display the\\n            optimization results\\n\\n        Returns\\n        -------\\n        TreatmentEffectsResults instance or tuple (ATE, POM0, POM1)\\n\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    endog = self.model_pool.endog\n    tind = self.treatment\n    prob = self.prob_select\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    res_ipw = ate_ipw(endog, tind, prob, weighted=True, probt=probt)\n    if not return_results:\n        return res_ipw\n    gmm = _IPWGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate((res_ipw[:2], self.results_select.params))\n    res_gmm = gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "def ipw(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Inverse Probability Weighted treatment effect estimation.\\n\\n        Parameters\\n        ----------\\n        return_results : bool\\n            If True, then a results instance is returned.\\n            If False, just ATE, POM0 and POM1 are returned.\\n        effect_group : {\"all\", 0, 1}\\n            ``effectgroup`` determines for which population the effects are\\n            estimated.\\n            If effect_group is \"all\", then sample average treatment effect and\\n            potential outcomes are returned.\\n            If effect_group is 1 or \"treated\", then effects on treated are\\n            returned.\\n            If effect_group is 0, \"treated\" or \"control\", then effects on\\n            untreated, i.e. control group, are returned.\\n        disp : bool\\n            Indicates whether the scipy optimizer should display the\\n            optimization results\\n\\n        Returns\\n        -------\\n        TreatmentEffectsResults instance or tuple (ATE, POM0, POM1)\\n\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    endog = self.model_pool.endog\n    tind = self.treatment\n    prob = self.prob_select\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    res_ipw = ate_ipw(endog, tind, prob, weighted=True, probt=probt)\n    if not return_results:\n        return res_ipw\n    gmm = _IPWGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate((res_ipw[:2], self.results_select.params))\n    res_gmm = gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "def ipw(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Inverse Probability Weighted treatment effect estimation.\\n\\n        Parameters\\n        ----------\\n        return_results : bool\\n            If True, then a results instance is returned.\\n            If False, just ATE, POM0 and POM1 are returned.\\n        effect_group : {\"all\", 0, 1}\\n            ``effectgroup`` determines for which population the effects are\\n            estimated.\\n            If effect_group is \"all\", then sample average treatment effect and\\n            potential outcomes are returned.\\n            If effect_group is 1 or \"treated\", then effects on treated are\\n            returned.\\n            If effect_group is 0, \"treated\" or \"control\", then effects on\\n            untreated, i.e. control group, are returned.\\n        disp : bool\\n            Indicates whether the scipy optimizer should display the\\n            optimization results\\n\\n        Returns\\n        -------\\n        TreatmentEffectsResults instance or tuple (ATE, POM0, POM1)\\n\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    endog = self.model_pool.endog\n    tind = self.treatment\n    prob = self.prob_select\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = prob\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - prob\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    res_ipw = ate_ipw(endog, tind, prob, weighted=True, probt=probt)\n    if not return_results:\n        return res_ipw\n    gmm = _IPWGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate((res_ipw[:2], self.results_select.params))\n    res_gmm = gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res"
        ]
    },
    {
        "func_name": "ra",
        "original": "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ra(self, return_results=True, effect_group='all', disp=False):\n    \"\"\"\n        Regression Adjustment treatment effect estimation.\n        \n%(params_returns)s\n        See Also\n        --------\n        TreatmentEffectsResults\n        \"\"\"\n    tind = np.zeros(len(self.treatment))\n    tind[-self.treatment.sum():] = 1\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = tind\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - tind\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    exog = self.exog_grouped\n    if probt is not None:\n        cw = probt / probt.mean()\n    else:\n        cw = 1\n    pom0 = (self.results0.predict(exog) * cw).mean()\n    pom1 = (self.results1.predict(exog) * cw).mean()\n    if not return_results:\n        return (pom1 - pom0, pom0, pom1)\n    endog = self.model_pool.endog\n    mod_gmm = _RAGMM(endog, self.results_select, None, teff=self, probt=probt)\n    start_params = np.concatenate(([pom1 - pom0, pom0], self.results0.params, self.results1.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
        "mutated": [
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n    '\\n        Regression Adjustment treatment effect estimation.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    tind = np.zeros(len(self.treatment))\n    tind[-self.treatment.sum():] = 1\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = tind\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - tind\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    exog = self.exog_grouped\n    if probt is not None:\n        cw = probt / probt.mean()\n    else:\n        cw = 1\n    pom0 = (self.results0.predict(exog) * cw).mean()\n    pom1 = (self.results1.predict(exog) * cw).mean()\n    if not return_results:\n        return (pom1 - pom0, pom0, pom1)\n    endog = self.model_pool.endog\n    mod_gmm = _RAGMM(endog, self.results_select, None, teff=self, probt=probt)\n    start_params = np.concatenate(([pom1 - pom0, pom0], self.results0.params, self.results1.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Regression Adjustment treatment effect estimation.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    tind = np.zeros(len(self.treatment))\n    tind[-self.treatment.sum():] = 1\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = tind\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - tind\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    exog = self.exog_grouped\n    if probt is not None:\n        cw = probt / probt.mean()\n    else:\n        cw = 1\n    pom0 = (self.results0.predict(exog) * cw).mean()\n    pom1 = (self.results1.predict(exog) * cw).mean()\n    if not return_results:\n        return (pom1 - pom0, pom0, pom1)\n    endog = self.model_pool.endog\n    mod_gmm = _RAGMM(endog, self.results_select, None, teff=self, probt=probt)\n    start_params = np.concatenate(([pom1 - pom0, pom0], self.results0.params, self.results1.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Regression Adjustment treatment effect estimation.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    tind = np.zeros(len(self.treatment))\n    tind[-self.treatment.sum():] = 1\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = tind\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - tind\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    exog = self.exog_grouped\n    if probt is not None:\n        cw = probt / probt.mean()\n    else:\n        cw = 1\n    pom0 = (self.results0.predict(exog) * cw).mean()\n    pom1 = (self.results1.predict(exog) * cw).mean()\n    if not return_results:\n        return (pom1 - pom0, pom0, pom1)\n    endog = self.model_pool.endog\n    mod_gmm = _RAGMM(endog, self.results_select, None, teff=self, probt=probt)\n    start_params = np.concatenate(([pom1 - pom0, pom0], self.results0.params, self.results1.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Regression Adjustment treatment effect estimation.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    tind = np.zeros(len(self.treatment))\n    tind[-self.treatment.sum():] = 1\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = tind\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - tind\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    exog = self.exog_grouped\n    if probt is not None:\n        cw = probt / probt.mean()\n    else:\n        cw = 1\n    pom0 = (self.results0.predict(exog) * cw).mean()\n    pom1 = (self.results1.predict(exog) * cw).mean()\n    if not return_results:\n        return (pom1 - pom0, pom0, pom1)\n    endog = self.model_pool.endog\n    mod_gmm = _RAGMM(endog, self.results_select, None, teff=self, probt=probt)\n    start_params = np.concatenate(([pom1 - pom0, pom0], self.results0.params, self.results1.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Regression Adjustment treatment effect estimation.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n        '\n    tind = np.zeros(len(self.treatment))\n    tind[-self.treatment.sum():] = 1\n    if effect_group == 'all':\n        probt = None\n    elif effect_group in [1, 'treated']:\n        probt = tind\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        probt = 1 - tind\n        effect_group = 0\n    elif isinstance(effect_group, np.ndarray):\n        probt = effect_group\n        effect_group = 'user'\n    else:\n        raise ValueError('incorrect option for effect_group')\n    exog = self.exog_grouped\n    if probt is not None:\n        cw = probt / probt.mean()\n    else:\n        cw = 1\n    pom0 = (self.results0.predict(exog) * cw).mean()\n    pom1 = (self.results1.predict(exog) * cw).mean()\n    if not return_results:\n        return (pom1 - pom0, pom0, pom1)\n    endog = self.model_pool.endog\n    mod_gmm = _RAGMM(endog, self.results_select, None, teff=self, probt=probt)\n    start_params = np.concatenate(([pom1 - pom0, pom0], self.results0.params, self.results1.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res"
        ]
    },
    {
        "func_name": "aipw",
        "original": "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw(self, return_results=True, disp=False):\n    \"\"\"\n        ATE and POM from double robust augmented inverse probability weighting\n        \n%(params_returns)s\n        See Also\n        --------\n        TreatmentEffectsResults\n\n        \"\"\"\n    nobs = self.nobs\n    prob = self.prob_select\n    tind = self.treatment\n    exog = self.model_pool.exog\n    correct0 = (self.results0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (self.results1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = self.results0.predict(exog).mean() + correct0\n    tmean1 = self.results1.predict(exog).mean() + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    endog = self.model_pool.endog\n    p2_aipw = np.asarray([ate, tmean0])\n    mag_aipw1 = _AIPWGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw, self.results0.params, self.results1.params, self.results_select.params))\n    res_gmm = mag_aipw1.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
        "mutated": [
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw(self, return_results=True, disp=False):\n    if False:\n        i = 10\n    '\\n        ATE and POM from double robust augmented inverse probability weighting\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    tind = self.treatment\n    exog = self.model_pool.exog\n    correct0 = (self.results0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (self.results1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = self.results0.predict(exog).mean() + correct0\n    tmean1 = self.results1.predict(exog).mean() + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    endog = self.model_pool.endog\n    p2_aipw = np.asarray([ate, tmean0])\n    mag_aipw1 = _AIPWGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw, self.results0.params, self.results1.params, self.results_select.params))\n    res_gmm = mag_aipw1.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw(self, return_results=True, disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        ATE and POM from double robust augmented inverse probability weighting\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    tind = self.treatment\n    exog = self.model_pool.exog\n    correct0 = (self.results0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (self.results1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = self.results0.predict(exog).mean() + correct0\n    tmean1 = self.results1.predict(exog).mean() + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    endog = self.model_pool.endog\n    p2_aipw = np.asarray([ate, tmean0])\n    mag_aipw1 = _AIPWGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw, self.results0.params, self.results1.params, self.results_select.params))\n    res_gmm = mag_aipw1.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw(self, return_results=True, disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        ATE and POM from double robust augmented inverse probability weighting\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    tind = self.treatment\n    exog = self.model_pool.exog\n    correct0 = (self.results0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (self.results1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = self.results0.predict(exog).mean() + correct0\n    tmean1 = self.results1.predict(exog).mean() + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    endog = self.model_pool.endog\n    p2_aipw = np.asarray([ate, tmean0])\n    mag_aipw1 = _AIPWGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw, self.results0.params, self.results1.params, self.results_select.params))\n    res_gmm = mag_aipw1.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw(self, return_results=True, disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        ATE and POM from double robust augmented inverse probability weighting\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    tind = self.treatment\n    exog = self.model_pool.exog\n    correct0 = (self.results0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (self.results1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = self.results0.predict(exog).mean() + correct0\n    tmean1 = self.results1.predict(exog).mean() + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    endog = self.model_pool.endog\n    p2_aipw = np.asarray([ate, tmean0])\n    mag_aipw1 = _AIPWGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw, self.results0.params, self.results1.params, self.results_select.params))\n    res_gmm = mag_aipw1.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw(self, return_results=True, disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        ATE and POM from double robust augmented inverse probability weighting\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    tind = self.treatment\n    exog = self.model_pool.exog\n    correct0 = (self.results0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (self.results1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = self.results0.predict(exog).mean() + correct0\n    tmean1 = self.results1.predict(exog).mean() + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    endog = self.model_pool.endog\n    p2_aipw = np.asarray([ate, tmean0])\n    mag_aipw1 = _AIPWGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw, self.results0.params, self.results1.params, self.results_select.params))\n    res_gmm = mag_aipw1.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res"
        ]
    },
    {
        "func_name": "aipw_wls",
        "original": "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw_wls(self, return_results=True, disp=False):\n    \"\"\"\n        ATE and POM from double robust augmented inverse probability weighting.\n\n        This uses weighted outcome regression, while `aipw` uses unweighted\n        outcome regression.\n        Option for effect on treated or on untreated is not available.\n        \n%(params_returns)s\n        See Also\n        --------\n        TreatmentEffectsResults\n\n        \"\"\"\n    nobs = self.nobs\n    prob = self.prob_select\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    tind = self.treatment\n    treat_mask = self.treat_mask\n    ww1 = tind / prob * (tind / prob - 1)\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=ww1[treat_mask])\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipw2 = result1.predict(exog).mean()\n    ww0 = (1 - tind) / (1 - prob) * ((1 - tind) / (1 - prob) - 1)\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=ww0[~treat_mask])\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipw2 = result0.predict(exog).mean()\n    self.results_ipwwls0 = result0\n    self.results_ipwwls1 = result1\n    correct0 = (result0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (result1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = mean0_ipw2 + correct0\n    tmean1 = mean1_ipw2 + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    p2_aipw_wls = np.asarray([ate, tmean0]).squeeze()\n    mod_gmm = _AIPWWLSGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw_wls, result0.params, result1.params, self.results_select.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
        "mutated": [
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw_wls(self, return_results=True, disp=False):\n    if False:\n        i = 10\n    '\\n        ATE and POM from double robust augmented inverse probability weighting.\\n\\n        This uses weighted outcome regression, while `aipw` uses unweighted\\n        outcome regression.\\n        Option for effect on treated or on untreated is not available.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    tind = self.treatment\n    treat_mask = self.treat_mask\n    ww1 = tind / prob * (tind / prob - 1)\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=ww1[treat_mask])\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipw2 = result1.predict(exog).mean()\n    ww0 = (1 - tind) / (1 - prob) * ((1 - tind) / (1 - prob) - 1)\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=ww0[~treat_mask])\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipw2 = result0.predict(exog).mean()\n    self.results_ipwwls0 = result0\n    self.results_ipwwls1 = result1\n    correct0 = (result0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (result1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = mean0_ipw2 + correct0\n    tmean1 = mean1_ipw2 + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    p2_aipw_wls = np.asarray([ate, tmean0]).squeeze()\n    mod_gmm = _AIPWWLSGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw_wls, result0.params, result1.params, self.results_select.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw_wls(self, return_results=True, disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        ATE and POM from double robust augmented inverse probability weighting.\\n\\n        This uses weighted outcome regression, while `aipw` uses unweighted\\n        outcome regression.\\n        Option for effect on treated or on untreated is not available.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    tind = self.treatment\n    treat_mask = self.treat_mask\n    ww1 = tind / prob * (tind / prob - 1)\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=ww1[treat_mask])\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipw2 = result1.predict(exog).mean()\n    ww0 = (1 - tind) / (1 - prob) * ((1 - tind) / (1 - prob) - 1)\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=ww0[~treat_mask])\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipw2 = result0.predict(exog).mean()\n    self.results_ipwwls0 = result0\n    self.results_ipwwls1 = result1\n    correct0 = (result0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (result1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = mean0_ipw2 + correct0\n    tmean1 = mean1_ipw2 + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    p2_aipw_wls = np.asarray([ate, tmean0]).squeeze()\n    mod_gmm = _AIPWWLSGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw_wls, result0.params, result1.params, self.results_select.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw_wls(self, return_results=True, disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        ATE and POM from double robust augmented inverse probability weighting.\\n\\n        This uses weighted outcome regression, while `aipw` uses unweighted\\n        outcome regression.\\n        Option for effect on treated or on untreated is not available.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    tind = self.treatment\n    treat_mask = self.treat_mask\n    ww1 = tind / prob * (tind / prob - 1)\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=ww1[treat_mask])\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipw2 = result1.predict(exog).mean()\n    ww0 = (1 - tind) / (1 - prob) * ((1 - tind) / (1 - prob) - 1)\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=ww0[~treat_mask])\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipw2 = result0.predict(exog).mean()\n    self.results_ipwwls0 = result0\n    self.results_ipwwls1 = result1\n    correct0 = (result0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (result1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = mean0_ipw2 + correct0\n    tmean1 = mean1_ipw2 + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    p2_aipw_wls = np.asarray([ate, tmean0]).squeeze()\n    mod_gmm = _AIPWWLSGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw_wls, result0.params, result1.params, self.results_select.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw_wls(self, return_results=True, disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        ATE and POM from double robust augmented inverse probability weighting.\\n\\n        This uses weighted outcome regression, while `aipw` uses unweighted\\n        outcome regression.\\n        Option for effect on treated or on untreated is not available.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    tind = self.treatment\n    treat_mask = self.treat_mask\n    ww1 = tind / prob * (tind / prob - 1)\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=ww1[treat_mask])\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipw2 = result1.predict(exog).mean()\n    ww0 = (1 - tind) / (1 - prob) * ((1 - tind) / (1 - prob) - 1)\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=ww0[~treat_mask])\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipw2 = result0.predict(exog).mean()\n    self.results_ipwwls0 = result0\n    self.results_ipwwls1 = result1\n    correct0 = (result0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (result1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = mean0_ipw2 + correct0\n    tmean1 = mean1_ipw2 + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    p2_aipw_wls = np.asarray([ate, tmean0]).squeeze()\n    mod_gmm = _AIPWWLSGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw_wls, result0.params, result1.params, self.results_select.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns2, ' ' * 8))\ndef aipw_wls(self, return_results=True, disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        ATE and POM from double robust augmented inverse probability weighting.\\n\\n        This uses weighted outcome regression, while `aipw` uses unweighted\\n        outcome regression.\\n        Option for effect on treated or on untreated is not available.\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    nobs = self.nobs\n    prob = self.prob_select\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    tind = self.treatment\n    treat_mask = self.treat_mask\n    ww1 = tind / prob * (tind / prob - 1)\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=ww1[treat_mask])\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipw2 = result1.predict(exog).mean()\n    ww0 = (1 - tind) / (1 - prob) * ((1 - tind) / (1 - prob) - 1)\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=ww0[~treat_mask])\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipw2 = result0.predict(exog).mean()\n    self.results_ipwwls0 = result0\n    self.results_ipwwls1 = result1\n    correct0 = (result0.resid / (1 - prob[tind == 0])).sum() / nobs\n    correct1 = (result1.resid / prob[tind == 1]).sum() / nobs\n    tmean0 = mean0_ipw2 + correct0\n    tmean1 = mean1_ipw2 + correct1\n    ate = tmean1 - tmean0\n    if not return_results:\n        return (ate, tmean0, tmean1)\n    p2_aipw_wls = np.asarray([ate, tmean0]).squeeze()\n    mod_gmm = _AIPWWLSGMM(endog, self.results_select, None, teff=self)\n    start_params = np.concatenate((p2_aipw_wls, result0.params, result1.params, self.results_select.params))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 5000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group='all')\n    return res"
        ]
    },
    {
        "func_name": "ipw_ra",
        "original": "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ipw_ra(self, return_results=True, effect_group='all', disp=False):\n    \"\"\"\n        ATE and POM from inverse probability weighted regression adjustment.\n\n        \n%(params_returns)s\n        See Also\n        --------\n        TreatmentEffectsResults\n\n        \"\"\"\n    treat_mask = self.treat_mask\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    prob = self.prob_select\n    prob0 = prob[~treat_mask]\n    prob1 = prob[treat_mask]\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        exogt = exog\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        exogt = exog[treat_mask]\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        exogt = exog[~treat_mask]\n        effect_group = 0\n    else:\n        raise ValueError('incorrect option for effect_group')\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=w0)\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipwra = result0.predict(exogt).mean()\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=w1)\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipwra = result1.predict(exogt).mean()\n    if not return_results:\n        return (mean1_ipwra - mean0_ipwra, mean0_ipwra, mean1_ipwra)\n    mod_gmm = _IPWRAGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate(([mean1_ipwra - mean0_ipwra, mean0_ipwra], result0.params, result1.params, np.asarray(self.results_select.params)))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 2000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
        "mutated": [
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ipw_ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n    '\\n        ATE and POM from inverse probability weighted regression adjustment.\\n\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    treat_mask = self.treat_mask\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    prob = self.prob_select\n    prob0 = prob[~treat_mask]\n    prob1 = prob[treat_mask]\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        exogt = exog\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        exogt = exog[treat_mask]\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        exogt = exog[~treat_mask]\n        effect_group = 0\n    else:\n        raise ValueError('incorrect option for effect_group')\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=w0)\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipwra = result0.predict(exogt).mean()\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=w1)\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipwra = result1.predict(exogt).mean()\n    if not return_results:\n        return (mean1_ipwra - mean0_ipwra, mean0_ipwra, mean1_ipwra)\n    mod_gmm = _IPWRAGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate(([mean1_ipwra - mean0_ipwra, mean0_ipwra], result0.params, result1.params, np.asarray(self.results_select.params)))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 2000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ipw_ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        ATE and POM from inverse probability weighted regression adjustment.\\n\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    treat_mask = self.treat_mask\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    prob = self.prob_select\n    prob0 = prob[~treat_mask]\n    prob1 = prob[treat_mask]\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        exogt = exog\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        exogt = exog[treat_mask]\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        exogt = exog[~treat_mask]\n        effect_group = 0\n    else:\n        raise ValueError('incorrect option for effect_group')\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=w0)\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipwra = result0.predict(exogt).mean()\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=w1)\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipwra = result1.predict(exogt).mean()\n    if not return_results:\n        return (mean1_ipwra - mean0_ipwra, mean0_ipwra, mean1_ipwra)\n    mod_gmm = _IPWRAGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate(([mean1_ipwra - mean0_ipwra, mean0_ipwra], result0.params, result1.params, np.asarray(self.results_select.params)))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 2000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ipw_ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        ATE and POM from inverse probability weighted regression adjustment.\\n\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    treat_mask = self.treat_mask\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    prob = self.prob_select\n    prob0 = prob[~treat_mask]\n    prob1 = prob[treat_mask]\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        exogt = exog\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        exogt = exog[treat_mask]\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        exogt = exog[~treat_mask]\n        effect_group = 0\n    else:\n        raise ValueError('incorrect option for effect_group')\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=w0)\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipwra = result0.predict(exogt).mean()\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=w1)\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipwra = result1.predict(exogt).mean()\n    if not return_results:\n        return (mean1_ipwra - mean0_ipwra, mean0_ipwra, mean1_ipwra)\n    mod_gmm = _IPWRAGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate(([mean1_ipwra - mean0_ipwra, mean0_ipwra], result0.params, result1.params, np.asarray(self.results_select.params)))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 2000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ipw_ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        ATE and POM from inverse probability weighted regression adjustment.\\n\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    treat_mask = self.treat_mask\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    prob = self.prob_select\n    prob0 = prob[~treat_mask]\n    prob1 = prob[treat_mask]\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        exogt = exog\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        exogt = exog[treat_mask]\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        exogt = exog[~treat_mask]\n        effect_group = 0\n    else:\n        raise ValueError('incorrect option for effect_group')\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=w0)\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipwra = result0.predict(exogt).mean()\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=w1)\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipwra = result1.predict(exogt).mean()\n    if not return_results:\n        return (mean1_ipwra - mean0_ipwra, mean0_ipwra, mean1_ipwra)\n    mod_gmm = _IPWRAGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate(([mean1_ipwra - mean0_ipwra, mean0_ipwra], result0.params, result1.params, np.asarray(self.results_select.params)))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 2000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res",
            "@Substitution(params_returns=indent(doc_params_returns, ' ' * 8))\ndef ipw_ra(self, return_results=True, effect_group='all', disp=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        ATE and POM from inverse probability weighted regression adjustment.\\n\\n        \\n%(params_returns)s\\n        See Also\\n        --------\\n        TreatmentEffectsResults\\n\\n        '\n    treat_mask = self.treat_mask\n    endog = self.model_pool.endog\n    exog = self.model_pool.exog\n    prob = self.prob_select\n    prob0 = prob[~treat_mask]\n    prob1 = prob[treat_mask]\n    if effect_group == 'all':\n        w0 = 1 / (1 - prob0)\n        w1 = 1 / prob1\n        exogt = exog\n    elif effect_group in [1, 'treated']:\n        w0 = prob0 / (1 - prob0)\n        w1 = prob1 / prob1\n        exogt = exog[treat_mask]\n        effect_group = 1\n    elif effect_group in [0, 'untreated', 'control']:\n        w0 = (1 - prob0) / (1 - prob0)\n        w1 = (1 - prob1) / prob1\n        exogt = exog[~treat_mask]\n        effect_group = 0\n    else:\n        raise ValueError('incorrect option for effect_group')\n    mod0 = WLS(endog[~treat_mask], exog[~treat_mask], weights=w0)\n    result0 = mod0.fit(cov_type='HC1')\n    mean0_ipwra = result0.predict(exogt).mean()\n    mod1 = WLS(endog[treat_mask], exog[treat_mask], weights=w1)\n    result1 = mod1.fit(cov_type='HC1')\n    mean1_ipwra = result1.predict(exogt).mean()\n    if not return_results:\n        return (mean1_ipwra - mean0_ipwra, mean0_ipwra, mean1_ipwra)\n    mod_gmm = _IPWRAGMM(endog, self.results_select, None, teff=self, effect_group=effect_group)\n    start_params = np.concatenate(([mean1_ipwra - mean0_ipwra, mean0_ipwra], result0.params, result1.params, np.asarray(self.results_select.params)))\n    res_gmm = mod_gmm.fit(start_params=start_params, inv_weights=np.eye(len(start_params)), optim_method='nm', optim_args={'maxiter': 2000, 'disp': disp}, maxiter=1)\n    res = TreatmentEffectResults(self, res_gmm, 'IPW', start_params=start_params, effect_group=effect_group)\n    return res"
        ]
    }
]