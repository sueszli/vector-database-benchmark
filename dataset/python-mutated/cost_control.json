[
    {
        "func_name": "__init__",
        "original": "def __init__(self, model, dataset, topk, order_generator_cls_or_obj=OrderGenWInteract, max_sold_weight=1.0, risk_degree=0.95, buy_method='first_fill', trade_exchange=None, level_infra=None, common_infra=None, **kwargs):\n    \"\"\"\n        Parameters\n        ----------\n        topk : int\n            top-N stocks to buy\n        risk_degree : float\n            position percentage of total value buy_method:\n\n                rank_fill: assign the weight stocks that rank high first(1/topk max)\n                average_fill: assign the weight to the stocks rank high averagely.\n        \"\"\"\n    super(SoftTopkStrategy, self).__init__(model, dataset, order_generator_cls_or_obj, trade_exchange, level_infra, common_infra, **kwargs)\n    self.topk = topk\n    self.max_sold_weight = max_sold_weight\n    self.risk_degree = risk_degree\n    self.buy_method = buy_method",
        "mutated": [
            "def __init__(self, model, dataset, topk, order_generator_cls_or_obj=OrderGenWInteract, max_sold_weight=1.0, risk_degree=0.95, buy_method='first_fill', trade_exchange=None, level_infra=None, common_infra=None, **kwargs):\n    if False:\n        i = 10\n    '\\n        Parameters\\n        ----------\\n        topk : int\\n            top-N stocks to buy\\n        risk_degree : float\\n            position percentage of total value buy_method:\\n\\n                rank_fill: assign the weight stocks that rank high first(1/topk max)\\n                average_fill: assign the weight to the stocks rank high averagely.\\n        '\n    super(SoftTopkStrategy, self).__init__(model, dataset, order_generator_cls_or_obj, trade_exchange, level_infra, common_infra, **kwargs)\n    self.topk = topk\n    self.max_sold_weight = max_sold_weight\n    self.risk_degree = risk_degree\n    self.buy_method = buy_method",
            "def __init__(self, model, dataset, topk, order_generator_cls_or_obj=OrderGenWInteract, max_sold_weight=1.0, risk_degree=0.95, buy_method='first_fill', trade_exchange=None, level_infra=None, common_infra=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Parameters\\n        ----------\\n        topk : int\\n            top-N stocks to buy\\n        risk_degree : float\\n            position percentage of total value buy_method:\\n\\n                rank_fill: assign the weight stocks that rank high first(1/topk max)\\n                average_fill: assign the weight to the stocks rank high averagely.\\n        '\n    super(SoftTopkStrategy, self).__init__(model, dataset, order_generator_cls_or_obj, trade_exchange, level_infra, common_infra, **kwargs)\n    self.topk = topk\n    self.max_sold_weight = max_sold_weight\n    self.risk_degree = risk_degree\n    self.buy_method = buy_method",
            "def __init__(self, model, dataset, topk, order_generator_cls_or_obj=OrderGenWInteract, max_sold_weight=1.0, risk_degree=0.95, buy_method='first_fill', trade_exchange=None, level_infra=None, common_infra=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Parameters\\n        ----------\\n        topk : int\\n            top-N stocks to buy\\n        risk_degree : float\\n            position percentage of total value buy_method:\\n\\n                rank_fill: assign the weight stocks that rank high first(1/topk max)\\n                average_fill: assign the weight to the stocks rank high averagely.\\n        '\n    super(SoftTopkStrategy, self).__init__(model, dataset, order_generator_cls_or_obj, trade_exchange, level_infra, common_infra, **kwargs)\n    self.topk = topk\n    self.max_sold_weight = max_sold_weight\n    self.risk_degree = risk_degree\n    self.buy_method = buy_method",
            "def __init__(self, model, dataset, topk, order_generator_cls_or_obj=OrderGenWInteract, max_sold_weight=1.0, risk_degree=0.95, buy_method='first_fill', trade_exchange=None, level_infra=None, common_infra=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Parameters\\n        ----------\\n        topk : int\\n            top-N stocks to buy\\n        risk_degree : float\\n            position percentage of total value buy_method:\\n\\n                rank_fill: assign the weight stocks that rank high first(1/topk max)\\n                average_fill: assign the weight to the stocks rank high averagely.\\n        '\n    super(SoftTopkStrategy, self).__init__(model, dataset, order_generator_cls_or_obj, trade_exchange, level_infra, common_infra, **kwargs)\n    self.topk = topk\n    self.max_sold_weight = max_sold_weight\n    self.risk_degree = risk_degree\n    self.buy_method = buy_method",
            "def __init__(self, model, dataset, topk, order_generator_cls_or_obj=OrderGenWInteract, max_sold_weight=1.0, risk_degree=0.95, buy_method='first_fill', trade_exchange=None, level_infra=None, common_infra=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Parameters\\n        ----------\\n        topk : int\\n            top-N stocks to buy\\n        risk_degree : float\\n            position percentage of total value buy_method:\\n\\n                rank_fill: assign the weight stocks that rank high first(1/topk max)\\n                average_fill: assign the weight to the stocks rank high averagely.\\n        '\n    super(SoftTopkStrategy, self).__init__(model, dataset, order_generator_cls_or_obj, trade_exchange, level_infra, common_infra, **kwargs)\n    self.topk = topk\n    self.max_sold_weight = max_sold_weight\n    self.risk_degree = risk_degree\n    self.buy_method = buy_method"
        ]
    },
    {
        "func_name": "get_risk_degree",
        "original": "def get_risk_degree(self, trade_step=None):\n    \"\"\"get_risk_degree\n        Return the proportion of your total value you will used in investment.\n        Dynamically risk_degree will result in Market timing\n        \"\"\"\n    return self.risk_degree",
        "mutated": [
            "def get_risk_degree(self, trade_step=None):\n    if False:\n        i = 10\n    'get_risk_degree\\n        Return the proportion of your total value you will used in investment.\\n        Dynamically risk_degree will result in Market timing\\n        '\n    return self.risk_degree",
            "def get_risk_degree(self, trade_step=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'get_risk_degree\\n        Return the proportion of your total value you will used in investment.\\n        Dynamically risk_degree will result in Market timing\\n        '\n    return self.risk_degree",
            "def get_risk_degree(self, trade_step=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'get_risk_degree\\n        Return the proportion of your total value you will used in investment.\\n        Dynamically risk_degree will result in Market timing\\n        '\n    return self.risk_degree",
            "def get_risk_degree(self, trade_step=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'get_risk_degree\\n        Return the proportion of your total value you will used in investment.\\n        Dynamically risk_degree will result in Market timing\\n        '\n    return self.risk_degree",
            "def get_risk_degree(self, trade_step=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'get_risk_degree\\n        Return the proportion of your total value you will used in investment.\\n        Dynamically risk_degree will result in Market timing\\n        '\n    return self.risk_degree"
        ]
    },
    {
        "func_name": "generate_target_weight_position",
        "original": "def generate_target_weight_position(self, score, current, trade_start_time, trade_end_time):\n    \"\"\"\n        Parameters\n        ----------\n        score:\n            pred score for this trade date, pd.Series, index is stock_id, contain 'score' column\n        current:\n            current position, use Position() class\n        trade_date:\n            trade date\n\n            generate target position from score for this date and the current position\n\n            The cache is not considered in the position\n        \"\"\"\n    buy_signal_stocks = set(score.sort_values(ascending=False).iloc[:self.topk].index)\n    cur_stock_weight = current.get_stock_weight_dict(only_stock=True)\n    if len(cur_stock_weight) == 0:\n        final_stock_weight = {code: 1 / self.topk for code in buy_signal_stocks}\n    else:\n        final_stock_weight = copy.deepcopy(cur_stock_weight)\n        sold_stock_weight = 0.0\n        for stock_id in final_stock_weight:\n            if stock_id not in buy_signal_stocks:\n                sw = min(self.max_sold_weight, final_stock_weight[stock_id])\n                sold_stock_weight += sw\n                final_stock_weight[stock_id] -= sw\n        if self.buy_method == 'first_fill':\n            for stock_id in buy_signal_stocks:\n                add_weight = min(max(1 / self.topk - final_stock_weight.get(stock_id, 0), 0.0), sold_stock_weight)\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + add_weight\n                sold_stock_weight -= add_weight\n        elif self.buy_method == 'average_fill':\n            for stock_id in buy_signal_stocks:\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + sold_stock_weight / len(buy_signal_stocks)\n        else:\n            raise ValueError('Buy method not found')\n    return final_stock_weight",
        "mutated": [
            "def generate_target_weight_position(self, score, current, trade_start_time, trade_end_time):\n    if False:\n        i = 10\n    \"\\n        Parameters\\n        ----------\\n        score:\\n            pred score for this trade date, pd.Series, index is stock_id, contain 'score' column\\n        current:\\n            current position, use Position() class\\n        trade_date:\\n            trade date\\n\\n            generate target position from score for this date and the current position\\n\\n            The cache is not considered in the position\\n        \"\n    buy_signal_stocks = set(score.sort_values(ascending=False).iloc[:self.topk].index)\n    cur_stock_weight = current.get_stock_weight_dict(only_stock=True)\n    if len(cur_stock_weight) == 0:\n        final_stock_weight = {code: 1 / self.topk for code in buy_signal_stocks}\n    else:\n        final_stock_weight = copy.deepcopy(cur_stock_weight)\n        sold_stock_weight = 0.0\n        for stock_id in final_stock_weight:\n            if stock_id not in buy_signal_stocks:\n                sw = min(self.max_sold_weight, final_stock_weight[stock_id])\n                sold_stock_weight += sw\n                final_stock_weight[stock_id] -= sw\n        if self.buy_method == 'first_fill':\n            for stock_id in buy_signal_stocks:\n                add_weight = min(max(1 / self.topk - final_stock_weight.get(stock_id, 0), 0.0), sold_stock_weight)\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + add_weight\n                sold_stock_weight -= add_weight\n        elif self.buy_method == 'average_fill':\n            for stock_id in buy_signal_stocks:\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + sold_stock_weight / len(buy_signal_stocks)\n        else:\n            raise ValueError('Buy method not found')\n    return final_stock_weight",
            "def generate_target_weight_position(self, score, current, trade_start_time, trade_end_time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Parameters\\n        ----------\\n        score:\\n            pred score for this trade date, pd.Series, index is stock_id, contain 'score' column\\n        current:\\n            current position, use Position() class\\n        trade_date:\\n            trade date\\n\\n            generate target position from score for this date and the current position\\n\\n            The cache is not considered in the position\\n        \"\n    buy_signal_stocks = set(score.sort_values(ascending=False).iloc[:self.topk].index)\n    cur_stock_weight = current.get_stock_weight_dict(only_stock=True)\n    if len(cur_stock_weight) == 0:\n        final_stock_weight = {code: 1 / self.topk for code in buy_signal_stocks}\n    else:\n        final_stock_weight = copy.deepcopy(cur_stock_weight)\n        sold_stock_weight = 0.0\n        for stock_id in final_stock_weight:\n            if stock_id not in buy_signal_stocks:\n                sw = min(self.max_sold_weight, final_stock_weight[stock_id])\n                sold_stock_weight += sw\n                final_stock_weight[stock_id] -= sw\n        if self.buy_method == 'first_fill':\n            for stock_id in buy_signal_stocks:\n                add_weight = min(max(1 / self.topk - final_stock_weight.get(stock_id, 0), 0.0), sold_stock_weight)\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + add_weight\n                sold_stock_weight -= add_weight\n        elif self.buy_method == 'average_fill':\n            for stock_id in buy_signal_stocks:\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + sold_stock_weight / len(buy_signal_stocks)\n        else:\n            raise ValueError('Buy method not found')\n    return final_stock_weight",
            "def generate_target_weight_position(self, score, current, trade_start_time, trade_end_time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Parameters\\n        ----------\\n        score:\\n            pred score for this trade date, pd.Series, index is stock_id, contain 'score' column\\n        current:\\n            current position, use Position() class\\n        trade_date:\\n            trade date\\n\\n            generate target position from score for this date and the current position\\n\\n            The cache is not considered in the position\\n        \"\n    buy_signal_stocks = set(score.sort_values(ascending=False).iloc[:self.topk].index)\n    cur_stock_weight = current.get_stock_weight_dict(only_stock=True)\n    if len(cur_stock_weight) == 0:\n        final_stock_weight = {code: 1 / self.topk for code in buy_signal_stocks}\n    else:\n        final_stock_weight = copy.deepcopy(cur_stock_weight)\n        sold_stock_weight = 0.0\n        for stock_id in final_stock_weight:\n            if stock_id not in buy_signal_stocks:\n                sw = min(self.max_sold_weight, final_stock_weight[stock_id])\n                sold_stock_weight += sw\n                final_stock_weight[stock_id] -= sw\n        if self.buy_method == 'first_fill':\n            for stock_id in buy_signal_stocks:\n                add_weight = min(max(1 / self.topk - final_stock_weight.get(stock_id, 0), 0.0), sold_stock_weight)\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + add_weight\n                sold_stock_weight -= add_weight\n        elif self.buy_method == 'average_fill':\n            for stock_id in buy_signal_stocks:\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + sold_stock_weight / len(buy_signal_stocks)\n        else:\n            raise ValueError('Buy method not found')\n    return final_stock_weight",
            "def generate_target_weight_position(self, score, current, trade_start_time, trade_end_time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Parameters\\n        ----------\\n        score:\\n            pred score for this trade date, pd.Series, index is stock_id, contain 'score' column\\n        current:\\n            current position, use Position() class\\n        trade_date:\\n            trade date\\n\\n            generate target position from score for this date and the current position\\n\\n            The cache is not considered in the position\\n        \"\n    buy_signal_stocks = set(score.sort_values(ascending=False).iloc[:self.topk].index)\n    cur_stock_weight = current.get_stock_weight_dict(only_stock=True)\n    if len(cur_stock_weight) == 0:\n        final_stock_weight = {code: 1 / self.topk for code in buy_signal_stocks}\n    else:\n        final_stock_weight = copy.deepcopy(cur_stock_weight)\n        sold_stock_weight = 0.0\n        for stock_id in final_stock_weight:\n            if stock_id not in buy_signal_stocks:\n                sw = min(self.max_sold_weight, final_stock_weight[stock_id])\n                sold_stock_weight += sw\n                final_stock_weight[stock_id] -= sw\n        if self.buy_method == 'first_fill':\n            for stock_id in buy_signal_stocks:\n                add_weight = min(max(1 / self.topk - final_stock_weight.get(stock_id, 0), 0.0), sold_stock_weight)\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + add_weight\n                sold_stock_weight -= add_weight\n        elif self.buy_method == 'average_fill':\n            for stock_id in buy_signal_stocks:\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + sold_stock_weight / len(buy_signal_stocks)\n        else:\n            raise ValueError('Buy method not found')\n    return final_stock_weight",
            "def generate_target_weight_position(self, score, current, trade_start_time, trade_end_time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Parameters\\n        ----------\\n        score:\\n            pred score for this trade date, pd.Series, index is stock_id, contain 'score' column\\n        current:\\n            current position, use Position() class\\n        trade_date:\\n            trade date\\n\\n            generate target position from score for this date and the current position\\n\\n            The cache is not considered in the position\\n        \"\n    buy_signal_stocks = set(score.sort_values(ascending=False).iloc[:self.topk].index)\n    cur_stock_weight = current.get_stock_weight_dict(only_stock=True)\n    if len(cur_stock_weight) == 0:\n        final_stock_weight = {code: 1 / self.topk for code in buy_signal_stocks}\n    else:\n        final_stock_weight = copy.deepcopy(cur_stock_weight)\n        sold_stock_weight = 0.0\n        for stock_id in final_stock_weight:\n            if stock_id not in buy_signal_stocks:\n                sw = min(self.max_sold_weight, final_stock_weight[stock_id])\n                sold_stock_weight += sw\n                final_stock_weight[stock_id] -= sw\n        if self.buy_method == 'first_fill':\n            for stock_id in buy_signal_stocks:\n                add_weight = min(max(1 / self.topk - final_stock_weight.get(stock_id, 0), 0.0), sold_stock_weight)\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + add_weight\n                sold_stock_weight -= add_weight\n        elif self.buy_method == 'average_fill':\n            for stock_id in buy_signal_stocks:\n                final_stock_weight[stock_id] = final_stock_weight.get(stock_id, 0.0) + sold_stock_weight / len(buy_signal_stocks)\n        else:\n            raise ValueError('Buy method not found')\n    return final_stock_weight"
        ]
    }
]