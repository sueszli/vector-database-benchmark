[
    {
        "func_name": "record",
        "original": "def record(output_dir):\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(0)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 0\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time = None\n        stop_timer = False\n        while True:\n            (ret, frame) = cap.read()\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer:\n                        start_time = time.time()\n                        stop_timer = True\n                    else:\n                        elapsed_time = time.time() - start_time\n                        if elapsed_time >= 2:\n                            if is_recording:\n                                is_recording = False\n                                out.release()\n                                print(f'Stopped recording output{recording_count}.mp4')\n                                no_hand_count = 0\n                            break\n                else:\n                    stop_timer = False\n                if not is_recording:\n                    is_recording = True\n                    recording_count += 1\n                    output_path = os.path.join(output_dir, f'output{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording output{recording_count}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
        "mutated": [
            "def record(output_dir):\n    if False:\n        i = 10\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(0)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 0\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time = None\n        stop_timer = False\n        while True:\n            (ret, frame) = cap.read()\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer:\n                        start_time = time.time()\n                        stop_timer = True\n                    else:\n                        elapsed_time = time.time() - start_time\n                        if elapsed_time >= 2:\n                            if is_recording:\n                                is_recording = False\n                                out.release()\n                                print(f'Stopped recording output{recording_count}.mp4')\n                                no_hand_count = 0\n                            break\n                else:\n                    stop_timer = False\n                if not is_recording:\n                    is_recording = True\n                    recording_count += 1\n                    output_path = os.path.join(output_dir, f'output{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording output{recording_count}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
            "def record(output_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(0)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 0\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time = None\n        stop_timer = False\n        while True:\n            (ret, frame) = cap.read()\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer:\n                        start_time = time.time()\n                        stop_timer = True\n                    else:\n                        elapsed_time = time.time() - start_time\n                        if elapsed_time >= 2:\n                            if is_recording:\n                                is_recording = False\n                                out.release()\n                                print(f'Stopped recording output{recording_count}.mp4')\n                                no_hand_count = 0\n                            break\n                else:\n                    stop_timer = False\n                if not is_recording:\n                    is_recording = True\n                    recording_count += 1\n                    output_path = os.path.join(output_dir, f'output{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording output{recording_count}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
            "def record(output_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(0)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 0\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time = None\n        stop_timer = False\n        while True:\n            (ret, frame) = cap.read()\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer:\n                        start_time = time.time()\n                        stop_timer = True\n                    else:\n                        elapsed_time = time.time() - start_time\n                        if elapsed_time >= 2:\n                            if is_recording:\n                                is_recording = False\n                                out.release()\n                                print(f'Stopped recording output{recording_count}.mp4')\n                                no_hand_count = 0\n                            break\n                else:\n                    stop_timer = False\n                if not is_recording:\n                    is_recording = True\n                    recording_count += 1\n                    output_path = os.path.join(output_dir, f'output{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording output{recording_count}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
            "def record(output_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(0)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 0\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time = None\n        stop_timer = False\n        while True:\n            (ret, frame) = cap.read()\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer:\n                        start_time = time.time()\n                        stop_timer = True\n                    else:\n                        elapsed_time = time.time() - start_time\n                        if elapsed_time >= 2:\n                            if is_recording:\n                                is_recording = False\n                                out.release()\n                                print(f'Stopped recording output{recording_count}.mp4')\n                                no_hand_count = 0\n                            break\n                else:\n                    stop_timer = False\n                if not is_recording:\n                    is_recording = True\n                    recording_count += 1\n                    output_path = os.path.join(output_dir, f'output{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording output{recording_count}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
            "def record(output_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(0)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 0\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time = None\n        stop_timer = False\n        while True:\n            (ret, frame) = cap.read()\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer:\n                        start_time = time.time()\n                        stop_timer = True\n                    else:\n                        elapsed_time = time.time() - start_time\n                        if elapsed_time >= 2:\n                            if is_recording:\n                                is_recording = False\n                                out.release()\n                                print(f'Stopped recording output{recording_count}.mp4')\n                                no_hand_count = 0\n                            break\n                else:\n                    stop_timer = False\n                if not is_recording:\n                    is_recording = True\n                    recording_count += 1\n                    output_path = os.path.join(output_dir, f'output{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording output{recording_count}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                break\n        cap.release()\n        cv2.destroyAllWindows()"
        ]
    }
]