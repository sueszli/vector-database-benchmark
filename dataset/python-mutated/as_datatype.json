[
    {
        "func_name": "datetime_",
        "original": "def datetime_(year: int | IntoExpr, month: int | IntoExpr, day: int | IntoExpr, hour: int | IntoExpr | None=None, minute: int | IntoExpr | None=None, second: int | IntoExpr | None=None, microsecond: int | IntoExpr | None=None, *, time_unit: TimeUnit='us', time_zone: str | None=None, use_earliest: bool | None=None, ambiguous: Ambiguous | Expr='raise') -> Expr:\n    \"\"\"\n    Create a Polars literal expression of type Datetime.\n\n    Parameters\n    ----------\n    year\n        Column or literal.\n    month\n        Column or literal, ranging from 1-12.\n    day\n        Column or literal, ranging from 1-31.\n    hour\n        Column or literal, ranging from 0-23.\n    minute\n        Column or literal, ranging from 0-59.\n    second\n        Column or literal, ranging from 0-59.\n    microsecond\n        Column or literal, ranging from 0-999999.\n    time_unit : {'us', 'ms', 'ns'}\n        Time unit of the resulting expression.\n    time_zone\n        Time zone of the resulting expression.\n    use_earliest\n        Determine how to deal with ambiguous datetimes:\n\n        - `None` (default): raise\n        - `True`: use the earliest datetime\n        - `False`: use the latest datetime\n\n        .. deprecated:: 0.19.0\n            Use `ambiguous` instead\n    ambiguous\n        Determine how to deal with ambiguous datetimes:\n\n        - `'raise'` (default): raise\n        - `'earliest'`: use the earliest datetime\n        - `'latest'`: use the latest datetime\n\n\n    Returns\n    -------\n    Expr\n        Expression of data type :class:`Datetime`.\n\n    \"\"\"\n    ambiguous = parse_as_expression(rename_use_earliest_to_ambiguous(use_earliest, ambiguous), str_as_lit=True)\n    year_expr = parse_as_expression(year)\n    month_expr = parse_as_expression(month)\n    day_expr = parse_as_expression(day)\n    if hour is not None:\n        hour = parse_as_expression(hour)\n    if minute is not None:\n        minute = parse_as_expression(minute)\n    if second is not None:\n        second = parse_as_expression(second)\n    if microsecond is not None:\n        microsecond = parse_as_expression(microsecond)\n    return wrap_expr(plr.datetime(year_expr, month_expr, day_expr, hour, minute, second, microsecond, time_unit, time_zone, ambiguous))",
        "mutated": [
            "def datetime_(year: int | IntoExpr, month: int | IntoExpr, day: int | IntoExpr, hour: int | IntoExpr | None=None, minute: int | IntoExpr | None=None, second: int | IntoExpr | None=None, microsecond: int | IntoExpr | None=None, *, time_unit: TimeUnit='us', time_zone: str | None=None, use_earliest: bool | None=None, ambiguous: Ambiguous | Expr='raise') -> Expr:\n    if False:\n        i = 10\n    \"\\n    Create a Polars literal expression of type Datetime.\\n\\n    Parameters\\n    ----------\\n    year\\n        Column or literal.\\n    month\\n        Column or literal, ranging from 1-12.\\n    day\\n        Column or literal, ranging from 1-31.\\n    hour\\n        Column or literal, ranging from 0-23.\\n    minute\\n        Column or literal, ranging from 0-59.\\n    second\\n        Column or literal, ranging from 0-59.\\n    microsecond\\n        Column or literal, ranging from 0-999999.\\n    time_unit : {'us', 'ms', 'ns'}\\n        Time unit of the resulting expression.\\n    time_zone\\n        Time zone of the resulting expression.\\n    use_earliest\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `None` (default): raise\\n        - `True`: use the earliest datetime\\n        - `False`: use the latest datetime\\n\\n        .. deprecated:: 0.19.0\\n            Use `ambiguous` instead\\n    ambiguous\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `'raise'` (default): raise\\n        - `'earliest'`: use the earliest datetime\\n        - `'latest'`: use the latest datetime\\n\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Datetime`.\\n\\n    \"\n    ambiguous = parse_as_expression(rename_use_earliest_to_ambiguous(use_earliest, ambiguous), str_as_lit=True)\n    year_expr = parse_as_expression(year)\n    month_expr = parse_as_expression(month)\n    day_expr = parse_as_expression(day)\n    if hour is not None:\n        hour = parse_as_expression(hour)\n    if minute is not None:\n        minute = parse_as_expression(minute)\n    if second is not None:\n        second = parse_as_expression(second)\n    if microsecond is not None:\n        microsecond = parse_as_expression(microsecond)\n    return wrap_expr(plr.datetime(year_expr, month_expr, day_expr, hour, minute, second, microsecond, time_unit, time_zone, ambiguous))",
            "def datetime_(year: int | IntoExpr, month: int | IntoExpr, day: int | IntoExpr, hour: int | IntoExpr | None=None, minute: int | IntoExpr | None=None, second: int | IntoExpr | None=None, microsecond: int | IntoExpr | None=None, *, time_unit: TimeUnit='us', time_zone: str | None=None, use_earliest: bool | None=None, ambiguous: Ambiguous | Expr='raise') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Create a Polars literal expression of type Datetime.\\n\\n    Parameters\\n    ----------\\n    year\\n        Column or literal.\\n    month\\n        Column or literal, ranging from 1-12.\\n    day\\n        Column or literal, ranging from 1-31.\\n    hour\\n        Column or literal, ranging from 0-23.\\n    minute\\n        Column or literal, ranging from 0-59.\\n    second\\n        Column or literal, ranging from 0-59.\\n    microsecond\\n        Column or literal, ranging from 0-999999.\\n    time_unit : {'us', 'ms', 'ns'}\\n        Time unit of the resulting expression.\\n    time_zone\\n        Time zone of the resulting expression.\\n    use_earliest\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `None` (default): raise\\n        - `True`: use the earliest datetime\\n        - `False`: use the latest datetime\\n\\n        .. deprecated:: 0.19.0\\n            Use `ambiguous` instead\\n    ambiguous\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `'raise'` (default): raise\\n        - `'earliest'`: use the earliest datetime\\n        - `'latest'`: use the latest datetime\\n\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Datetime`.\\n\\n    \"\n    ambiguous = parse_as_expression(rename_use_earliest_to_ambiguous(use_earliest, ambiguous), str_as_lit=True)\n    year_expr = parse_as_expression(year)\n    month_expr = parse_as_expression(month)\n    day_expr = parse_as_expression(day)\n    if hour is not None:\n        hour = parse_as_expression(hour)\n    if minute is not None:\n        minute = parse_as_expression(minute)\n    if second is not None:\n        second = parse_as_expression(second)\n    if microsecond is not None:\n        microsecond = parse_as_expression(microsecond)\n    return wrap_expr(plr.datetime(year_expr, month_expr, day_expr, hour, minute, second, microsecond, time_unit, time_zone, ambiguous))",
            "def datetime_(year: int | IntoExpr, month: int | IntoExpr, day: int | IntoExpr, hour: int | IntoExpr | None=None, minute: int | IntoExpr | None=None, second: int | IntoExpr | None=None, microsecond: int | IntoExpr | None=None, *, time_unit: TimeUnit='us', time_zone: str | None=None, use_earliest: bool | None=None, ambiguous: Ambiguous | Expr='raise') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Create a Polars literal expression of type Datetime.\\n\\n    Parameters\\n    ----------\\n    year\\n        Column or literal.\\n    month\\n        Column or literal, ranging from 1-12.\\n    day\\n        Column or literal, ranging from 1-31.\\n    hour\\n        Column or literal, ranging from 0-23.\\n    minute\\n        Column or literal, ranging from 0-59.\\n    second\\n        Column or literal, ranging from 0-59.\\n    microsecond\\n        Column or literal, ranging from 0-999999.\\n    time_unit : {'us', 'ms', 'ns'}\\n        Time unit of the resulting expression.\\n    time_zone\\n        Time zone of the resulting expression.\\n    use_earliest\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `None` (default): raise\\n        - `True`: use the earliest datetime\\n        - `False`: use the latest datetime\\n\\n        .. deprecated:: 0.19.0\\n            Use `ambiguous` instead\\n    ambiguous\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `'raise'` (default): raise\\n        - `'earliest'`: use the earliest datetime\\n        - `'latest'`: use the latest datetime\\n\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Datetime`.\\n\\n    \"\n    ambiguous = parse_as_expression(rename_use_earliest_to_ambiguous(use_earliest, ambiguous), str_as_lit=True)\n    year_expr = parse_as_expression(year)\n    month_expr = parse_as_expression(month)\n    day_expr = parse_as_expression(day)\n    if hour is not None:\n        hour = parse_as_expression(hour)\n    if minute is not None:\n        minute = parse_as_expression(minute)\n    if second is not None:\n        second = parse_as_expression(second)\n    if microsecond is not None:\n        microsecond = parse_as_expression(microsecond)\n    return wrap_expr(plr.datetime(year_expr, month_expr, day_expr, hour, minute, second, microsecond, time_unit, time_zone, ambiguous))",
            "def datetime_(year: int | IntoExpr, month: int | IntoExpr, day: int | IntoExpr, hour: int | IntoExpr | None=None, minute: int | IntoExpr | None=None, second: int | IntoExpr | None=None, microsecond: int | IntoExpr | None=None, *, time_unit: TimeUnit='us', time_zone: str | None=None, use_earliest: bool | None=None, ambiguous: Ambiguous | Expr='raise') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Create a Polars literal expression of type Datetime.\\n\\n    Parameters\\n    ----------\\n    year\\n        Column or literal.\\n    month\\n        Column or literal, ranging from 1-12.\\n    day\\n        Column or literal, ranging from 1-31.\\n    hour\\n        Column or literal, ranging from 0-23.\\n    minute\\n        Column or literal, ranging from 0-59.\\n    second\\n        Column or literal, ranging from 0-59.\\n    microsecond\\n        Column or literal, ranging from 0-999999.\\n    time_unit : {'us', 'ms', 'ns'}\\n        Time unit of the resulting expression.\\n    time_zone\\n        Time zone of the resulting expression.\\n    use_earliest\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `None` (default): raise\\n        - `True`: use the earliest datetime\\n        - `False`: use the latest datetime\\n\\n        .. deprecated:: 0.19.0\\n            Use `ambiguous` instead\\n    ambiguous\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `'raise'` (default): raise\\n        - `'earliest'`: use the earliest datetime\\n        - `'latest'`: use the latest datetime\\n\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Datetime`.\\n\\n    \"\n    ambiguous = parse_as_expression(rename_use_earliest_to_ambiguous(use_earliest, ambiguous), str_as_lit=True)\n    year_expr = parse_as_expression(year)\n    month_expr = parse_as_expression(month)\n    day_expr = parse_as_expression(day)\n    if hour is not None:\n        hour = parse_as_expression(hour)\n    if minute is not None:\n        minute = parse_as_expression(minute)\n    if second is not None:\n        second = parse_as_expression(second)\n    if microsecond is not None:\n        microsecond = parse_as_expression(microsecond)\n    return wrap_expr(plr.datetime(year_expr, month_expr, day_expr, hour, minute, second, microsecond, time_unit, time_zone, ambiguous))",
            "def datetime_(year: int | IntoExpr, month: int | IntoExpr, day: int | IntoExpr, hour: int | IntoExpr | None=None, minute: int | IntoExpr | None=None, second: int | IntoExpr | None=None, microsecond: int | IntoExpr | None=None, *, time_unit: TimeUnit='us', time_zone: str | None=None, use_earliest: bool | None=None, ambiguous: Ambiguous | Expr='raise') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Create a Polars literal expression of type Datetime.\\n\\n    Parameters\\n    ----------\\n    year\\n        Column or literal.\\n    month\\n        Column or literal, ranging from 1-12.\\n    day\\n        Column or literal, ranging from 1-31.\\n    hour\\n        Column or literal, ranging from 0-23.\\n    minute\\n        Column or literal, ranging from 0-59.\\n    second\\n        Column or literal, ranging from 0-59.\\n    microsecond\\n        Column or literal, ranging from 0-999999.\\n    time_unit : {'us', 'ms', 'ns'}\\n        Time unit of the resulting expression.\\n    time_zone\\n        Time zone of the resulting expression.\\n    use_earliest\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `None` (default): raise\\n        - `True`: use the earliest datetime\\n        - `False`: use the latest datetime\\n\\n        .. deprecated:: 0.19.0\\n            Use `ambiguous` instead\\n    ambiguous\\n        Determine how to deal with ambiguous datetimes:\\n\\n        - `'raise'` (default): raise\\n        - `'earliest'`: use the earliest datetime\\n        - `'latest'`: use the latest datetime\\n\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Datetime`.\\n\\n    \"\n    ambiguous = parse_as_expression(rename_use_earliest_to_ambiguous(use_earliest, ambiguous), str_as_lit=True)\n    year_expr = parse_as_expression(year)\n    month_expr = parse_as_expression(month)\n    day_expr = parse_as_expression(day)\n    if hour is not None:\n        hour = parse_as_expression(hour)\n    if minute is not None:\n        minute = parse_as_expression(minute)\n    if second is not None:\n        second = parse_as_expression(second)\n    if microsecond is not None:\n        microsecond = parse_as_expression(microsecond)\n    return wrap_expr(plr.datetime(year_expr, month_expr, day_expr, hour, minute, second, microsecond, time_unit, time_zone, ambiguous))"
        ]
    },
    {
        "func_name": "date_",
        "original": "def date_(year: Expr | str | int, month: Expr | str | int, day: Expr | str | int) -> Expr:\n    \"\"\"\n    Create a Polars literal expression of type Date.\n\n    Parameters\n    ----------\n    year\n        column or literal.\n    month\n        column or literal, ranging from 1-12.\n    day\n        column or literal, ranging from 1-31.\n\n    Returns\n    -------\n    Expr\n        Expression of data type :class:`Date`.\n\n    \"\"\"\n    return datetime_(year, month, day).cast(Date).alias('date')",
        "mutated": [
            "def date_(year: Expr | str | int, month: Expr | str | int, day: Expr | str | int) -> Expr:\n    if False:\n        i = 10\n    '\\n    Create a Polars literal expression of type Date.\\n\\n    Parameters\\n    ----------\\n    year\\n        column or literal.\\n    month\\n        column or literal, ranging from 1-12.\\n    day\\n        column or literal, ranging from 1-31.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    return datetime_(year, month, day).cast(Date).alias('date')",
            "def date_(year: Expr | str | int, month: Expr | str | int, day: Expr | str | int) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create a Polars literal expression of type Date.\\n\\n    Parameters\\n    ----------\\n    year\\n        column or literal.\\n    month\\n        column or literal, ranging from 1-12.\\n    day\\n        column or literal, ranging from 1-31.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    return datetime_(year, month, day).cast(Date).alias('date')",
            "def date_(year: Expr | str | int, month: Expr | str | int, day: Expr | str | int) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create a Polars literal expression of type Date.\\n\\n    Parameters\\n    ----------\\n    year\\n        column or literal.\\n    month\\n        column or literal, ranging from 1-12.\\n    day\\n        column or literal, ranging from 1-31.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    return datetime_(year, month, day).cast(Date).alias('date')",
            "def date_(year: Expr | str | int, month: Expr | str | int, day: Expr | str | int) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create a Polars literal expression of type Date.\\n\\n    Parameters\\n    ----------\\n    year\\n        column or literal.\\n    month\\n        column or literal, ranging from 1-12.\\n    day\\n        column or literal, ranging from 1-31.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    return datetime_(year, month, day).cast(Date).alias('date')",
            "def date_(year: Expr | str | int, month: Expr | str | int, day: Expr | str | int) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create a Polars literal expression of type Date.\\n\\n    Parameters\\n    ----------\\n    year\\n        column or literal.\\n    month\\n        column or literal, ranging from 1-12.\\n    day\\n        column or literal, ranging from 1-31.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    return datetime_(year, month, day).cast(Date).alias('date')"
        ]
    },
    {
        "func_name": "time_",
        "original": "def time_(hour: Expr | str | int | None=None, minute: Expr | str | int | None=None, second: Expr | str | int | None=None, microsecond: Expr | str | int | None=None) -> Expr:\n    \"\"\"\n    Create a Polars literal expression of type Time.\n\n    Parameters\n    ----------\n    hour\n        column or literal, ranging from 0-23.\n    minute\n        column or literal, ranging from 0-59.\n    second\n        column or literal, ranging from 0-59.\n    microsecond\n        column or literal, ranging from 0-999999.\n\n    Returns\n    -------\n    Expr\n        Expression of data type :class:`Date`.\n\n    \"\"\"\n    epoch_start = (1970, 1, 1)\n    return datetime_(*epoch_start, hour, minute, second, microsecond).cast(Time).alias('time')",
        "mutated": [
            "def time_(hour: Expr | str | int | None=None, minute: Expr | str | int | None=None, second: Expr | str | int | None=None, microsecond: Expr | str | int | None=None) -> Expr:\n    if False:\n        i = 10\n    '\\n    Create a Polars literal expression of type Time.\\n\\n    Parameters\\n    ----------\\n    hour\\n        column or literal, ranging from 0-23.\\n    minute\\n        column or literal, ranging from 0-59.\\n    second\\n        column or literal, ranging from 0-59.\\n    microsecond\\n        column or literal, ranging from 0-999999.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    epoch_start = (1970, 1, 1)\n    return datetime_(*epoch_start, hour, minute, second, microsecond).cast(Time).alias('time')",
            "def time_(hour: Expr | str | int | None=None, minute: Expr | str | int | None=None, second: Expr | str | int | None=None, microsecond: Expr | str | int | None=None) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create a Polars literal expression of type Time.\\n\\n    Parameters\\n    ----------\\n    hour\\n        column or literal, ranging from 0-23.\\n    minute\\n        column or literal, ranging from 0-59.\\n    second\\n        column or literal, ranging from 0-59.\\n    microsecond\\n        column or literal, ranging from 0-999999.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    epoch_start = (1970, 1, 1)\n    return datetime_(*epoch_start, hour, minute, second, microsecond).cast(Time).alias('time')",
            "def time_(hour: Expr | str | int | None=None, minute: Expr | str | int | None=None, second: Expr | str | int | None=None, microsecond: Expr | str | int | None=None) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create a Polars literal expression of type Time.\\n\\n    Parameters\\n    ----------\\n    hour\\n        column or literal, ranging from 0-23.\\n    minute\\n        column or literal, ranging from 0-59.\\n    second\\n        column or literal, ranging from 0-59.\\n    microsecond\\n        column or literal, ranging from 0-999999.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    epoch_start = (1970, 1, 1)\n    return datetime_(*epoch_start, hour, minute, second, microsecond).cast(Time).alias('time')",
            "def time_(hour: Expr | str | int | None=None, minute: Expr | str | int | None=None, second: Expr | str | int | None=None, microsecond: Expr | str | int | None=None) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create a Polars literal expression of type Time.\\n\\n    Parameters\\n    ----------\\n    hour\\n        column or literal, ranging from 0-23.\\n    minute\\n        column or literal, ranging from 0-59.\\n    second\\n        column or literal, ranging from 0-59.\\n    microsecond\\n        column or literal, ranging from 0-999999.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    epoch_start = (1970, 1, 1)\n    return datetime_(*epoch_start, hour, minute, second, microsecond).cast(Time).alias('time')",
            "def time_(hour: Expr | str | int | None=None, minute: Expr | str | int | None=None, second: Expr | str | int | None=None, microsecond: Expr | str | int | None=None) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create a Polars literal expression of type Time.\\n\\n    Parameters\\n    ----------\\n    hour\\n        column or literal, ranging from 0-23.\\n    minute\\n        column or literal, ranging from 0-59.\\n    second\\n        column or literal, ranging from 0-59.\\n    microsecond\\n        column or literal, ranging from 0-999999.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Date`.\\n\\n    '\n    epoch_start = (1970, 1, 1)\n    return datetime_(*epoch_start, hour, minute, second, microsecond).cast(Time).alias('time')"
        ]
    },
    {
        "func_name": "duration",
        "original": "def duration(*, weeks: Expr | str | int | None=None, days: Expr | str | int | None=None, hours: Expr | str | int | None=None, minutes: Expr | str | int | None=None, seconds: Expr | str | int | None=None, milliseconds: Expr | str | int | None=None, microseconds: Expr | str | int | None=None, nanoseconds: Expr | str | int | None=None, time_unit: TimeUnit='us') -> Expr:\n    \"\"\"\n    Create polars `Duration` from distinct time components.\n\n    Parameters\n    ----------\n    weeks\n        Number of weeks.\n    days\n        Number of days.\n    hours\n        Number of hours.\n    minutes\n        Number of minutes.\n    seconds\n        Number of seconds.\n    milliseconds\n        Number of milliseconds.\n    microseconds\n        Number of microseconds.\n    nanoseconds\n        Number of nanoseconds.\n    time_unit : {'us', 'ms', 'ns'}\n        Time unit of the resulting expression.\n\n    Returns\n    -------\n    Expr\n        Expression of data type :class:`Duration`.\n\n    Notes\n    -----\n    A `duration` represents a fixed amount of time. For example,\n    `pl.duration(days=1)` means \"exactly 24 hours\". By contrast,\n    `Expr.dt.offset_by('1d')` means \"1 calendar day\", which could sometimes be\n    23 hours or 25 hours depending on Daylight Savings Time.\n    For non-fixed durations such as \"calendar month\" or \"calendar day\",\n    please use :meth:`polars.Expr.dt.offset_by` instead.\n\n    Examples\n    --------\n    >>> from datetime import datetime\n    >>> df = pl.DataFrame(\n    ...     {\n    ...         \"dt\": [datetime(2022, 1, 1), datetime(2022, 1, 2)],\n    ...         \"add\": [1, 2],\n    ...     }\n    ... )\n    >>> df\n    shape: (2, 2)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 dt                  \u2506 add \u2502\n    \u2502 ---                 \u2506 --- \u2502\n    \u2502 datetime[\u03bcs]        \u2506 i64 \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 2022-01-01 00:00:00 \u2506 1   \u2502\n    \u2502 2022-01-02 00:00:00 \u2506 2   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n    >>> with pl.Config(tbl_width_chars=120):\n    ...     df.select(\n    ...         (pl.col(\"dt\") + pl.duration(weeks=\"add\")).alias(\"add_weeks\"),\n    ...         (pl.col(\"dt\") + pl.duration(days=\"add\")).alias(\"add_days\"),\n    ...         (pl.col(\"dt\") + pl.duration(seconds=\"add\")).alias(\"add_seconds\"),\n    ...         (pl.col(\"dt\") + pl.duration(milliseconds=\"add\")).alias(\"add_millis\"),\n    ...         (pl.col(\"dt\") + pl.duration(hours=\"add\")).alias(\"add_hours\"),\n    ...     )\n    ...\n    shape: (2, 5)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 add_weeks           \u2506 add_days            \u2506 add_seconds         \u2506 add_millis              \u2506 add_hours           \u2502\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2506 ---                     \u2506 ---                 \u2502\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]            \u2506 datetime[\u03bcs]        \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 2022-01-08 00:00:00 \u2506 2022-01-02 00:00:00 \u2506 2022-01-01 00:00:01 \u2506 2022-01-01 00:00:00.001 \u2506 2022-01-01 01:00:00 \u2502\n    \u2502 2022-01-16 00:00:00 \u2506 2022-01-04 00:00:00 \u2506 2022-01-02 00:00:02 \u2506 2022-01-02 00:00:00.002 \u2506 2022-01-02 02:00:00 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    If you need to add non-fixed durations, you should use :meth:`polars.Expr.dt.offset_by` instead:\n\n    >>> with pl.Config(tbl_width_chars=120):\n    ...     df.select(\n    ...         add_calendar_days=pl.col(\"dt\").dt.offset_by(\n    ...             pl.format(\"{}d\", pl.col(\"add\"))\n    ...         ),\n    ...         add_calendar_months=pl.col(\"dt\").dt.offset_by(\n    ...             pl.format(\"{}mo\", pl.col(\"add\"))\n    ...         ),\n    ...         add_calendar_years=pl.col(\"dt\").dt.offset_by(\n    ...             pl.format(\"{}y\", pl.col(\"add\"))\n    ...         ),\n    ...     )\n    ...\n    shape: (2, 3)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 add_calendar_days   \u2506 add_calendar_months \u2506 add_calendar_years  \u2502\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2502\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 2022-01-02 00:00:00 \u2506 2022-02-01 00:00:00 \u2506 2023-01-01 00:00:00 \u2502\n    \u2502 2022-01-04 00:00:00 \u2506 2022-03-02 00:00:00 \u2506 2024-01-02 00:00:00 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    if weeks is not None:\n        weeks = parse_as_expression(weeks)\n    if days is not None:\n        days = parse_as_expression(days)\n    if hours is not None:\n        hours = parse_as_expression(hours)\n    if minutes is not None:\n        minutes = parse_as_expression(minutes)\n    if seconds is not None:\n        seconds = parse_as_expression(seconds)\n    if milliseconds is not None:\n        milliseconds = parse_as_expression(milliseconds)\n    if microseconds is not None:\n        microseconds = parse_as_expression(microseconds)\n    if nanoseconds is not None:\n        nanoseconds = parse_as_expression(nanoseconds)\n    return wrap_expr(plr.duration(weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, time_unit))",
        "mutated": [
            "def duration(*, weeks: Expr | str | int | None=None, days: Expr | str | int | None=None, hours: Expr | str | int | None=None, minutes: Expr | str | int | None=None, seconds: Expr | str | int | None=None, milliseconds: Expr | str | int | None=None, microseconds: Expr | str | int | None=None, nanoseconds: Expr | str | int | None=None, time_unit: TimeUnit='us') -> Expr:\n    if False:\n        i = 10\n    '\\n    Create polars `Duration` from distinct time components.\\n\\n    Parameters\\n    ----------\\n    weeks\\n        Number of weeks.\\n    days\\n        Number of days.\\n    hours\\n        Number of hours.\\n    minutes\\n        Number of minutes.\\n    seconds\\n        Number of seconds.\\n    milliseconds\\n        Number of milliseconds.\\n    microseconds\\n        Number of microseconds.\\n    nanoseconds\\n        Number of nanoseconds.\\n    time_unit : {\\'us\\', \\'ms\\', \\'ns\\'}\\n        Time unit of the resulting expression.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Duration`.\\n\\n    Notes\\n    -----\\n    A `duration` represents a fixed amount of time. For example,\\n    `pl.duration(days=1)` means \"exactly 24 hours\". By contrast,\\n    `Expr.dt.offset_by(\\'1d\\')` means \"1 calendar day\", which could sometimes be\\n    23 hours or 25 hours depending on Daylight Savings Time.\\n    For non-fixed durations such as \"calendar month\" or \"calendar day\",\\n    please use :meth:`polars.Expr.dt.offset_by` instead.\\n\\n    Examples\\n    --------\\n    >>> from datetime import datetime\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [datetime(2022, 1, 1), datetime(2022, 1, 2)],\\n    ...         \"add\": [1, 2],\\n    ...     }\\n    ... )\\n    >>> df\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dt                  \u2506 add \u2502\\n    \u2502 ---                 \u2506 --- \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 00:00:00 \u2506 1   \u2502\\n    \u2502 2022-01-02 00:00:00 \u2506 2   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         (pl.col(\"dt\") + pl.duration(weeks=\"add\")).alias(\"add_weeks\"),\\n    ...         (pl.col(\"dt\") + pl.duration(days=\"add\")).alias(\"add_days\"),\\n    ...         (pl.col(\"dt\") + pl.duration(seconds=\"add\")).alias(\"add_seconds\"),\\n    ...         (pl.col(\"dt\") + pl.duration(milliseconds=\"add\")).alias(\"add_millis\"),\\n    ...         (pl.col(\"dt\") + pl.duration(hours=\"add\")).alias(\"add_hours\"),\\n    ...     )\\n    ...\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_weeks           \u2506 add_days            \u2506 add_seconds         \u2506 add_millis              \u2506 add_hours           \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2506 ---                     \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]            \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-08 00:00:00 \u2506 2022-01-02 00:00:00 \u2506 2022-01-01 00:00:01 \u2506 2022-01-01 00:00:00.001 \u2506 2022-01-01 01:00:00 \u2502\\n    \u2502 2022-01-16 00:00:00 \u2506 2022-01-04 00:00:00 \u2506 2022-01-02 00:00:02 \u2506 2022-01-02 00:00:00.002 \u2506 2022-01-02 02:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    If you need to add non-fixed durations, you should use :meth:`polars.Expr.dt.offset_by` instead:\\n\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         add_calendar_days=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}d\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_months=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}mo\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_years=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}y\", pl.col(\"add\"))\\n    ...         ),\\n    ...     )\\n    ...\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_calendar_days   \u2506 add_calendar_months \u2506 add_calendar_years  \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-02 00:00:00 \u2506 2022-02-01 00:00:00 \u2506 2023-01-01 00:00:00 \u2502\\n    \u2502 2022-01-04 00:00:00 \u2506 2022-03-02 00:00:00 \u2506 2024-01-02 00:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if weeks is not None:\n        weeks = parse_as_expression(weeks)\n    if days is not None:\n        days = parse_as_expression(days)\n    if hours is not None:\n        hours = parse_as_expression(hours)\n    if minutes is not None:\n        minutes = parse_as_expression(minutes)\n    if seconds is not None:\n        seconds = parse_as_expression(seconds)\n    if milliseconds is not None:\n        milliseconds = parse_as_expression(milliseconds)\n    if microseconds is not None:\n        microseconds = parse_as_expression(microseconds)\n    if nanoseconds is not None:\n        nanoseconds = parse_as_expression(nanoseconds)\n    return wrap_expr(plr.duration(weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, time_unit))",
            "def duration(*, weeks: Expr | str | int | None=None, days: Expr | str | int | None=None, hours: Expr | str | int | None=None, minutes: Expr | str | int | None=None, seconds: Expr | str | int | None=None, milliseconds: Expr | str | int | None=None, microseconds: Expr | str | int | None=None, nanoseconds: Expr | str | int | None=None, time_unit: TimeUnit='us') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create polars `Duration` from distinct time components.\\n\\n    Parameters\\n    ----------\\n    weeks\\n        Number of weeks.\\n    days\\n        Number of days.\\n    hours\\n        Number of hours.\\n    minutes\\n        Number of minutes.\\n    seconds\\n        Number of seconds.\\n    milliseconds\\n        Number of milliseconds.\\n    microseconds\\n        Number of microseconds.\\n    nanoseconds\\n        Number of nanoseconds.\\n    time_unit : {\\'us\\', \\'ms\\', \\'ns\\'}\\n        Time unit of the resulting expression.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Duration`.\\n\\n    Notes\\n    -----\\n    A `duration` represents a fixed amount of time. For example,\\n    `pl.duration(days=1)` means \"exactly 24 hours\". By contrast,\\n    `Expr.dt.offset_by(\\'1d\\')` means \"1 calendar day\", which could sometimes be\\n    23 hours or 25 hours depending on Daylight Savings Time.\\n    For non-fixed durations such as \"calendar month\" or \"calendar day\",\\n    please use :meth:`polars.Expr.dt.offset_by` instead.\\n\\n    Examples\\n    --------\\n    >>> from datetime import datetime\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [datetime(2022, 1, 1), datetime(2022, 1, 2)],\\n    ...         \"add\": [1, 2],\\n    ...     }\\n    ... )\\n    >>> df\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dt                  \u2506 add \u2502\\n    \u2502 ---                 \u2506 --- \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 00:00:00 \u2506 1   \u2502\\n    \u2502 2022-01-02 00:00:00 \u2506 2   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         (pl.col(\"dt\") + pl.duration(weeks=\"add\")).alias(\"add_weeks\"),\\n    ...         (pl.col(\"dt\") + pl.duration(days=\"add\")).alias(\"add_days\"),\\n    ...         (pl.col(\"dt\") + pl.duration(seconds=\"add\")).alias(\"add_seconds\"),\\n    ...         (pl.col(\"dt\") + pl.duration(milliseconds=\"add\")).alias(\"add_millis\"),\\n    ...         (pl.col(\"dt\") + pl.duration(hours=\"add\")).alias(\"add_hours\"),\\n    ...     )\\n    ...\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_weeks           \u2506 add_days            \u2506 add_seconds         \u2506 add_millis              \u2506 add_hours           \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2506 ---                     \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]            \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-08 00:00:00 \u2506 2022-01-02 00:00:00 \u2506 2022-01-01 00:00:01 \u2506 2022-01-01 00:00:00.001 \u2506 2022-01-01 01:00:00 \u2502\\n    \u2502 2022-01-16 00:00:00 \u2506 2022-01-04 00:00:00 \u2506 2022-01-02 00:00:02 \u2506 2022-01-02 00:00:00.002 \u2506 2022-01-02 02:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    If you need to add non-fixed durations, you should use :meth:`polars.Expr.dt.offset_by` instead:\\n\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         add_calendar_days=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}d\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_months=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}mo\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_years=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}y\", pl.col(\"add\"))\\n    ...         ),\\n    ...     )\\n    ...\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_calendar_days   \u2506 add_calendar_months \u2506 add_calendar_years  \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-02 00:00:00 \u2506 2022-02-01 00:00:00 \u2506 2023-01-01 00:00:00 \u2502\\n    \u2502 2022-01-04 00:00:00 \u2506 2022-03-02 00:00:00 \u2506 2024-01-02 00:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if weeks is not None:\n        weeks = parse_as_expression(weeks)\n    if days is not None:\n        days = parse_as_expression(days)\n    if hours is not None:\n        hours = parse_as_expression(hours)\n    if minutes is not None:\n        minutes = parse_as_expression(minutes)\n    if seconds is not None:\n        seconds = parse_as_expression(seconds)\n    if milliseconds is not None:\n        milliseconds = parse_as_expression(milliseconds)\n    if microseconds is not None:\n        microseconds = parse_as_expression(microseconds)\n    if nanoseconds is not None:\n        nanoseconds = parse_as_expression(nanoseconds)\n    return wrap_expr(plr.duration(weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, time_unit))",
            "def duration(*, weeks: Expr | str | int | None=None, days: Expr | str | int | None=None, hours: Expr | str | int | None=None, minutes: Expr | str | int | None=None, seconds: Expr | str | int | None=None, milliseconds: Expr | str | int | None=None, microseconds: Expr | str | int | None=None, nanoseconds: Expr | str | int | None=None, time_unit: TimeUnit='us') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create polars `Duration` from distinct time components.\\n\\n    Parameters\\n    ----------\\n    weeks\\n        Number of weeks.\\n    days\\n        Number of days.\\n    hours\\n        Number of hours.\\n    minutes\\n        Number of minutes.\\n    seconds\\n        Number of seconds.\\n    milliseconds\\n        Number of milliseconds.\\n    microseconds\\n        Number of microseconds.\\n    nanoseconds\\n        Number of nanoseconds.\\n    time_unit : {\\'us\\', \\'ms\\', \\'ns\\'}\\n        Time unit of the resulting expression.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Duration`.\\n\\n    Notes\\n    -----\\n    A `duration` represents a fixed amount of time. For example,\\n    `pl.duration(days=1)` means \"exactly 24 hours\". By contrast,\\n    `Expr.dt.offset_by(\\'1d\\')` means \"1 calendar day\", which could sometimes be\\n    23 hours or 25 hours depending on Daylight Savings Time.\\n    For non-fixed durations such as \"calendar month\" or \"calendar day\",\\n    please use :meth:`polars.Expr.dt.offset_by` instead.\\n\\n    Examples\\n    --------\\n    >>> from datetime import datetime\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [datetime(2022, 1, 1), datetime(2022, 1, 2)],\\n    ...         \"add\": [1, 2],\\n    ...     }\\n    ... )\\n    >>> df\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dt                  \u2506 add \u2502\\n    \u2502 ---                 \u2506 --- \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 00:00:00 \u2506 1   \u2502\\n    \u2502 2022-01-02 00:00:00 \u2506 2   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         (pl.col(\"dt\") + pl.duration(weeks=\"add\")).alias(\"add_weeks\"),\\n    ...         (pl.col(\"dt\") + pl.duration(days=\"add\")).alias(\"add_days\"),\\n    ...         (pl.col(\"dt\") + pl.duration(seconds=\"add\")).alias(\"add_seconds\"),\\n    ...         (pl.col(\"dt\") + pl.duration(milliseconds=\"add\")).alias(\"add_millis\"),\\n    ...         (pl.col(\"dt\") + pl.duration(hours=\"add\")).alias(\"add_hours\"),\\n    ...     )\\n    ...\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_weeks           \u2506 add_days            \u2506 add_seconds         \u2506 add_millis              \u2506 add_hours           \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2506 ---                     \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]            \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-08 00:00:00 \u2506 2022-01-02 00:00:00 \u2506 2022-01-01 00:00:01 \u2506 2022-01-01 00:00:00.001 \u2506 2022-01-01 01:00:00 \u2502\\n    \u2502 2022-01-16 00:00:00 \u2506 2022-01-04 00:00:00 \u2506 2022-01-02 00:00:02 \u2506 2022-01-02 00:00:00.002 \u2506 2022-01-02 02:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    If you need to add non-fixed durations, you should use :meth:`polars.Expr.dt.offset_by` instead:\\n\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         add_calendar_days=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}d\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_months=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}mo\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_years=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}y\", pl.col(\"add\"))\\n    ...         ),\\n    ...     )\\n    ...\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_calendar_days   \u2506 add_calendar_months \u2506 add_calendar_years  \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-02 00:00:00 \u2506 2022-02-01 00:00:00 \u2506 2023-01-01 00:00:00 \u2502\\n    \u2502 2022-01-04 00:00:00 \u2506 2022-03-02 00:00:00 \u2506 2024-01-02 00:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if weeks is not None:\n        weeks = parse_as_expression(weeks)\n    if days is not None:\n        days = parse_as_expression(days)\n    if hours is not None:\n        hours = parse_as_expression(hours)\n    if minutes is not None:\n        minutes = parse_as_expression(minutes)\n    if seconds is not None:\n        seconds = parse_as_expression(seconds)\n    if milliseconds is not None:\n        milliseconds = parse_as_expression(milliseconds)\n    if microseconds is not None:\n        microseconds = parse_as_expression(microseconds)\n    if nanoseconds is not None:\n        nanoseconds = parse_as_expression(nanoseconds)\n    return wrap_expr(plr.duration(weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, time_unit))",
            "def duration(*, weeks: Expr | str | int | None=None, days: Expr | str | int | None=None, hours: Expr | str | int | None=None, minutes: Expr | str | int | None=None, seconds: Expr | str | int | None=None, milliseconds: Expr | str | int | None=None, microseconds: Expr | str | int | None=None, nanoseconds: Expr | str | int | None=None, time_unit: TimeUnit='us') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create polars `Duration` from distinct time components.\\n\\n    Parameters\\n    ----------\\n    weeks\\n        Number of weeks.\\n    days\\n        Number of days.\\n    hours\\n        Number of hours.\\n    minutes\\n        Number of minutes.\\n    seconds\\n        Number of seconds.\\n    milliseconds\\n        Number of milliseconds.\\n    microseconds\\n        Number of microseconds.\\n    nanoseconds\\n        Number of nanoseconds.\\n    time_unit : {\\'us\\', \\'ms\\', \\'ns\\'}\\n        Time unit of the resulting expression.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Duration`.\\n\\n    Notes\\n    -----\\n    A `duration` represents a fixed amount of time. For example,\\n    `pl.duration(days=1)` means \"exactly 24 hours\". By contrast,\\n    `Expr.dt.offset_by(\\'1d\\')` means \"1 calendar day\", which could sometimes be\\n    23 hours or 25 hours depending on Daylight Savings Time.\\n    For non-fixed durations such as \"calendar month\" or \"calendar day\",\\n    please use :meth:`polars.Expr.dt.offset_by` instead.\\n\\n    Examples\\n    --------\\n    >>> from datetime import datetime\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [datetime(2022, 1, 1), datetime(2022, 1, 2)],\\n    ...         \"add\": [1, 2],\\n    ...     }\\n    ... )\\n    >>> df\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dt                  \u2506 add \u2502\\n    \u2502 ---                 \u2506 --- \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 00:00:00 \u2506 1   \u2502\\n    \u2502 2022-01-02 00:00:00 \u2506 2   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         (pl.col(\"dt\") + pl.duration(weeks=\"add\")).alias(\"add_weeks\"),\\n    ...         (pl.col(\"dt\") + pl.duration(days=\"add\")).alias(\"add_days\"),\\n    ...         (pl.col(\"dt\") + pl.duration(seconds=\"add\")).alias(\"add_seconds\"),\\n    ...         (pl.col(\"dt\") + pl.duration(milliseconds=\"add\")).alias(\"add_millis\"),\\n    ...         (pl.col(\"dt\") + pl.duration(hours=\"add\")).alias(\"add_hours\"),\\n    ...     )\\n    ...\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_weeks           \u2506 add_days            \u2506 add_seconds         \u2506 add_millis              \u2506 add_hours           \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2506 ---                     \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]            \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-08 00:00:00 \u2506 2022-01-02 00:00:00 \u2506 2022-01-01 00:00:01 \u2506 2022-01-01 00:00:00.001 \u2506 2022-01-01 01:00:00 \u2502\\n    \u2502 2022-01-16 00:00:00 \u2506 2022-01-04 00:00:00 \u2506 2022-01-02 00:00:02 \u2506 2022-01-02 00:00:00.002 \u2506 2022-01-02 02:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    If you need to add non-fixed durations, you should use :meth:`polars.Expr.dt.offset_by` instead:\\n\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         add_calendar_days=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}d\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_months=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}mo\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_years=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}y\", pl.col(\"add\"))\\n    ...         ),\\n    ...     )\\n    ...\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_calendar_days   \u2506 add_calendar_months \u2506 add_calendar_years  \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-02 00:00:00 \u2506 2022-02-01 00:00:00 \u2506 2023-01-01 00:00:00 \u2502\\n    \u2502 2022-01-04 00:00:00 \u2506 2022-03-02 00:00:00 \u2506 2024-01-02 00:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if weeks is not None:\n        weeks = parse_as_expression(weeks)\n    if days is not None:\n        days = parse_as_expression(days)\n    if hours is not None:\n        hours = parse_as_expression(hours)\n    if minutes is not None:\n        minutes = parse_as_expression(minutes)\n    if seconds is not None:\n        seconds = parse_as_expression(seconds)\n    if milliseconds is not None:\n        milliseconds = parse_as_expression(milliseconds)\n    if microseconds is not None:\n        microseconds = parse_as_expression(microseconds)\n    if nanoseconds is not None:\n        nanoseconds = parse_as_expression(nanoseconds)\n    return wrap_expr(plr.duration(weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, time_unit))",
            "def duration(*, weeks: Expr | str | int | None=None, days: Expr | str | int | None=None, hours: Expr | str | int | None=None, minutes: Expr | str | int | None=None, seconds: Expr | str | int | None=None, milliseconds: Expr | str | int | None=None, microseconds: Expr | str | int | None=None, nanoseconds: Expr | str | int | None=None, time_unit: TimeUnit='us') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create polars `Duration` from distinct time components.\\n\\n    Parameters\\n    ----------\\n    weeks\\n        Number of weeks.\\n    days\\n        Number of days.\\n    hours\\n        Number of hours.\\n    minutes\\n        Number of minutes.\\n    seconds\\n        Number of seconds.\\n    milliseconds\\n        Number of milliseconds.\\n    microseconds\\n        Number of microseconds.\\n    nanoseconds\\n        Number of nanoseconds.\\n    time_unit : {\\'us\\', \\'ms\\', \\'ns\\'}\\n        Time unit of the resulting expression.\\n\\n    Returns\\n    -------\\n    Expr\\n        Expression of data type :class:`Duration`.\\n\\n    Notes\\n    -----\\n    A `duration` represents a fixed amount of time. For example,\\n    `pl.duration(days=1)` means \"exactly 24 hours\". By contrast,\\n    `Expr.dt.offset_by(\\'1d\\')` means \"1 calendar day\", which could sometimes be\\n    23 hours or 25 hours depending on Daylight Savings Time.\\n    For non-fixed durations such as \"calendar month\" or \"calendar day\",\\n    please use :meth:`polars.Expr.dt.offset_by` instead.\\n\\n    Examples\\n    --------\\n    >>> from datetime import datetime\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"dt\": [datetime(2022, 1, 1), datetime(2022, 1, 2)],\\n    ...         \"add\": [1, 2],\\n    ...     }\\n    ... )\\n    >>> df\\n    shape: (2, 2)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 dt                  \u2506 add \u2502\\n    \u2502 ---                 \u2506 --- \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 i64 \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 00:00:00 \u2506 1   \u2502\\n    \u2502 2022-01-02 00:00:00 \u2506 2   \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         (pl.col(\"dt\") + pl.duration(weeks=\"add\")).alias(\"add_weeks\"),\\n    ...         (pl.col(\"dt\") + pl.duration(days=\"add\")).alias(\"add_days\"),\\n    ...         (pl.col(\"dt\") + pl.duration(seconds=\"add\")).alias(\"add_seconds\"),\\n    ...         (pl.col(\"dt\") + pl.duration(milliseconds=\"add\")).alias(\"add_millis\"),\\n    ...         (pl.col(\"dt\") + pl.duration(hours=\"add\")).alias(\"add_hours\"),\\n    ...     )\\n    ...\\n    shape: (2, 5)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_weeks           \u2506 add_days            \u2506 add_seconds         \u2506 add_millis              \u2506 add_hours           \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2506 ---                     \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]            \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-08 00:00:00 \u2506 2022-01-02 00:00:00 \u2506 2022-01-01 00:00:01 \u2506 2022-01-01 00:00:00.001 \u2506 2022-01-01 01:00:00 \u2502\\n    \u2502 2022-01-16 00:00:00 \u2506 2022-01-04 00:00:00 \u2506 2022-01-02 00:00:02 \u2506 2022-01-02 00:00:00.002 \u2506 2022-01-02 02:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    If you need to add non-fixed durations, you should use :meth:`polars.Expr.dt.offset_by` instead:\\n\\n    >>> with pl.Config(tbl_width_chars=120):\\n    ...     df.select(\\n    ...         add_calendar_days=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}d\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_months=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}mo\", pl.col(\"add\"))\\n    ...         ),\\n    ...         add_calendar_years=pl.col(\"dt\").dt.offset_by(\\n    ...             pl.format(\"{}y\", pl.col(\"add\"))\\n    ...         ),\\n    ...     )\\n    ...\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 add_calendar_days   \u2506 add_calendar_months \u2506 add_calendar_years  \u2502\\n    \u2502 ---                 \u2506 ---                 \u2506 ---                 \u2502\\n    \u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-02 00:00:00 \u2506 2022-02-01 00:00:00 \u2506 2023-01-01 00:00:00 \u2502\\n    \u2502 2022-01-04 00:00:00 \u2506 2022-03-02 00:00:00 \u2506 2024-01-02 00:00:00 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if weeks is not None:\n        weeks = parse_as_expression(weeks)\n    if days is not None:\n        days = parse_as_expression(days)\n    if hours is not None:\n        hours = parse_as_expression(hours)\n    if minutes is not None:\n        minutes = parse_as_expression(minutes)\n    if seconds is not None:\n        seconds = parse_as_expression(seconds)\n    if milliseconds is not None:\n        milliseconds = parse_as_expression(milliseconds)\n    if microseconds is not None:\n        microseconds = parse_as_expression(microseconds)\n    if nanoseconds is not None:\n        nanoseconds = parse_as_expression(nanoseconds)\n    return wrap_expr(plr.duration(weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, time_unit))"
        ]
    },
    {
        "func_name": "concat_list",
        "original": "def concat_list(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:\n    \"\"\"\n    Horizontally concatenate columns into a single list column.\n\n    Operates in linear time.\n\n    Parameters\n    ----------\n    exprs\n        Columns to concatenate into a single list column. Accepts expression input.\n        Strings are parsed as column names, other non-expression inputs are parsed as\n        literals.\n    *more_exprs\n        Additional columns to concatenate into a single list column, specified as\n        positional arguments.\n\n    Examples\n    --------\n    Create lagged columns and collect them into a list. This mimics a rolling window.\n\n    >>> df = pl.DataFrame({\"A\": [1.0, 2.0, 9.0, 2.0, 13.0]})\n    >>> df = df.select([pl.col(\"A\").shift(i).alias(f\"A_lag_{i}\") for i in range(3)])\n    >>> df.select(\n    ...     pl.concat_list([f\"A_lag_{i}\" for i in range(3)][::-1]).alias(\"A_rolling\")\n    ... )\n    shape: (5, 1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 A_rolling         \u2502\n    \u2502 ---               \u2502\n    \u2502 list[f64]         \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 [null, null, 1.0] \u2502\n    \u2502 [null, 1.0, 2.0]  \u2502\n    \u2502 [1.0, 2.0, 9.0]   \u2502\n    \u2502 [2.0, 9.0, 2.0]   \u2502\n    \u2502 [9.0, 2.0, 13.0]  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_list(exprs))",
        "mutated": [
            "def concat_list(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n    '\\n    Horizontally concatenate columns into a single list column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single list column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals.\\n    *more_exprs\\n        Additional columns to concatenate into a single list column, specified as\\n        positional arguments.\\n\\n    Examples\\n    --------\\n    Create lagged columns and collect them into a list. This mimics a rolling window.\\n\\n    >>> df = pl.DataFrame({\"A\": [1.0, 2.0, 9.0, 2.0, 13.0]})\\n    >>> df = df.select([pl.col(\"A\").shift(i).alias(f\"A_lag_{i}\") for i in range(3)])\\n    >>> df.select(\\n    ...     pl.concat_list([f\"A_lag_{i}\" for i in range(3)][::-1]).alias(\"A_rolling\")\\n    ... )\\n    shape: (5, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 A_rolling         \u2502\\n    \u2502 ---               \u2502\\n    \u2502 list[f64]         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 [null, null, 1.0] \u2502\\n    \u2502 [null, 1.0, 2.0]  \u2502\\n    \u2502 [1.0, 2.0, 9.0]   \u2502\\n    \u2502 [2.0, 9.0, 2.0]   \u2502\\n    \u2502 [9.0, 2.0, 13.0]  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_list(exprs))",
            "def concat_list(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Horizontally concatenate columns into a single list column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single list column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals.\\n    *more_exprs\\n        Additional columns to concatenate into a single list column, specified as\\n        positional arguments.\\n\\n    Examples\\n    --------\\n    Create lagged columns and collect them into a list. This mimics a rolling window.\\n\\n    >>> df = pl.DataFrame({\"A\": [1.0, 2.0, 9.0, 2.0, 13.0]})\\n    >>> df = df.select([pl.col(\"A\").shift(i).alias(f\"A_lag_{i}\") for i in range(3)])\\n    >>> df.select(\\n    ...     pl.concat_list([f\"A_lag_{i}\" for i in range(3)][::-1]).alias(\"A_rolling\")\\n    ... )\\n    shape: (5, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 A_rolling         \u2502\\n    \u2502 ---               \u2502\\n    \u2502 list[f64]         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 [null, null, 1.0] \u2502\\n    \u2502 [null, 1.0, 2.0]  \u2502\\n    \u2502 [1.0, 2.0, 9.0]   \u2502\\n    \u2502 [2.0, 9.0, 2.0]   \u2502\\n    \u2502 [9.0, 2.0, 13.0]  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_list(exprs))",
            "def concat_list(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Horizontally concatenate columns into a single list column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single list column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals.\\n    *more_exprs\\n        Additional columns to concatenate into a single list column, specified as\\n        positional arguments.\\n\\n    Examples\\n    --------\\n    Create lagged columns and collect them into a list. This mimics a rolling window.\\n\\n    >>> df = pl.DataFrame({\"A\": [1.0, 2.0, 9.0, 2.0, 13.0]})\\n    >>> df = df.select([pl.col(\"A\").shift(i).alias(f\"A_lag_{i}\") for i in range(3)])\\n    >>> df.select(\\n    ...     pl.concat_list([f\"A_lag_{i}\" for i in range(3)][::-1]).alias(\"A_rolling\")\\n    ... )\\n    shape: (5, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 A_rolling         \u2502\\n    \u2502 ---               \u2502\\n    \u2502 list[f64]         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 [null, null, 1.0] \u2502\\n    \u2502 [null, 1.0, 2.0]  \u2502\\n    \u2502 [1.0, 2.0, 9.0]   \u2502\\n    \u2502 [2.0, 9.0, 2.0]   \u2502\\n    \u2502 [9.0, 2.0, 13.0]  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_list(exprs))",
            "def concat_list(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Horizontally concatenate columns into a single list column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single list column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals.\\n    *more_exprs\\n        Additional columns to concatenate into a single list column, specified as\\n        positional arguments.\\n\\n    Examples\\n    --------\\n    Create lagged columns and collect them into a list. This mimics a rolling window.\\n\\n    >>> df = pl.DataFrame({\"A\": [1.0, 2.0, 9.0, 2.0, 13.0]})\\n    >>> df = df.select([pl.col(\"A\").shift(i).alias(f\"A_lag_{i}\") for i in range(3)])\\n    >>> df.select(\\n    ...     pl.concat_list([f\"A_lag_{i}\" for i in range(3)][::-1]).alias(\"A_rolling\")\\n    ... )\\n    shape: (5, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 A_rolling         \u2502\\n    \u2502 ---               \u2502\\n    \u2502 list[f64]         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 [null, null, 1.0] \u2502\\n    \u2502 [null, 1.0, 2.0]  \u2502\\n    \u2502 [1.0, 2.0, 9.0]   \u2502\\n    \u2502 [2.0, 9.0, 2.0]   \u2502\\n    \u2502 [9.0, 2.0, 13.0]  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_list(exprs))",
            "def concat_list(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Horizontally concatenate columns into a single list column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single list column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals.\\n    *more_exprs\\n        Additional columns to concatenate into a single list column, specified as\\n        positional arguments.\\n\\n    Examples\\n    --------\\n    Create lagged columns and collect them into a list. This mimics a rolling window.\\n\\n    >>> df = pl.DataFrame({\"A\": [1.0, 2.0, 9.0, 2.0, 13.0]})\\n    >>> df = df.select([pl.col(\"A\").shift(i).alias(f\"A_lag_{i}\") for i in range(3)])\\n    >>> df.select(\\n    ...     pl.concat_list([f\"A_lag_{i}\" for i in range(3)][::-1]).alias(\"A_rolling\")\\n    ... )\\n    shape: (5, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 A_rolling         \u2502\\n    \u2502 ---               \u2502\\n    \u2502 list[f64]         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 [null, null, 1.0] \u2502\\n    \u2502 [null, 1.0, 2.0]  \u2502\\n    \u2502 [1.0, 2.0, 9.0]   \u2502\\n    \u2502 [2.0, 9.0, 2.0]   \u2502\\n    \u2502 [9.0, 2.0, 13.0]  \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_list(exprs))"
        ]
    },
    {
        "func_name": "struct",
        "original": "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[False]=..., **named_exprs: IntoExpr) -> Expr:\n    ...",
        "mutated": [
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[False]=..., **named_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[False]=..., **named_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[False]=..., **named_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[False]=..., **named_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[False]=..., **named_exprs: IntoExpr) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "struct",
        "original": "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[True], **named_exprs: IntoExpr) -> Series:\n    ...",
        "mutated": [
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[True], **named_exprs: IntoExpr) -> Series:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[True], **named_exprs: IntoExpr) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[True], **named_exprs: IntoExpr) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[True], **named_exprs: IntoExpr) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: Literal[True], **named_exprs: IntoExpr) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "struct",
        "original": "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: bool, **named_exprs: IntoExpr) -> Expr | Series:\n    ...",
        "mutated": [
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: bool, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: bool, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: bool, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: bool, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=..., eager: bool, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "struct",
        "original": "def struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=None, eager: bool=False, **named_exprs: IntoExpr) -> Expr | Series:\n    \"\"\"\n    Collect columns into a struct column.\n\n    Parameters\n    ----------\n    *exprs\n        Column(s) to collect into a struct column, specified as positional arguments.\n        Accepts expression input. Strings are parsed as column names,\n        other non-expression inputs are parsed as literals.\n    schema\n        Optional schema that explicitly defines the struct field dtypes. If no columns\n        or expressions are provided, schema keys are used to define columns.\n    eager\n        Evaluate immediately and return a `Series`. If set to `False` (default),\n        return an expression instead.\n    **named_exprs\n        Additional columns to collect into the struct column, specified as keyword\n        arguments. The columns will be renamed to the keyword used.\n\n    Examples\n    --------\n    Collect all columns of a dataframe into a struct by passing `pl.all()`.\n\n    >>> df = pl.DataFrame(\n    ...     {\n    ...         \"int\": [1, 2],\n    ...         \"str\": [\"a\", \"b\"],\n    ...         \"bool\": [True, None],\n    ...         \"list\": [[1, 2], [3]],\n    ...     }\n    ... )\n    >>> df.select(pl.struct(pl.all()).alias(\"my_struct\"))\n    shape: (2, 1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 my_struct           \u2502\n    \u2502 ---                 \u2502\n    \u2502 struct[4]           \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 {1,\"a\",true,[1, 2]} \u2502\n    \u2502 {2,\"b\",null,[3]}    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Collect selected columns into a struct by either passing a list of columns, or by\n    specifying each column as a positional argument.\n\n    >>> df.select(pl.struct(\"int\", False).alias(\"my_struct\"))\n    shape: (2, 1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 my_struct \u2502\n    \u2502 ---       \u2502\n    \u2502 struct[2] \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 {1,false} \u2502\n    \u2502 {2,false} \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Use keyword arguments to easily name each struct field.\n\n    >>> df.select(pl.struct(p=\"int\", q=\"bool\").alias(\"my_struct\")).schema\n    OrderedDict([('my_struct', Struct([Field('p', Int64), Field('q', Boolean)]))])\n\n    \"\"\"\n    pyexprs = parse_as_list_of_expressions(*exprs, **named_exprs)\n    expr = wrap_expr(plr.as_struct(pyexprs))\n    if schema:\n        if not exprs:\n            expr = wrap_expr(plr.as_struct(parse_as_list_of_expressions(list(schema.keys()))))\n        expr = expr.cast(Struct(schema), strict=False)\n    if eager:\n        return F.select(expr).to_series()\n    else:\n        return expr",
        "mutated": [
            "def struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=None, eager: bool=False, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n    '\\n    Collect columns into a struct column.\\n\\n    Parameters\\n    ----------\\n    *exprs\\n        Column(s) to collect into a struct column, specified as positional arguments.\\n        Accepts expression input. Strings are parsed as column names,\\n        other non-expression inputs are parsed as literals.\\n    schema\\n        Optional schema that explicitly defines the struct field dtypes. If no columns\\n        or expressions are provided, schema keys are used to define columns.\\n    eager\\n        Evaluate immediately and return a `Series`. If set to `False` (default),\\n        return an expression instead.\\n    **named_exprs\\n        Additional columns to collect into the struct column, specified as keyword\\n        arguments. The columns will be renamed to the keyword used.\\n\\n    Examples\\n    --------\\n    Collect all columns of a dataframe into a struct by passing `pl.all()`.\\n\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"int\": [1, 2],\\n    ...         \"str\": [\"a\", \"b\"],\\n    ...         \"bool\": [True, None],\\n    ...         \"list\": [[1, 2], [3]],\\n    ...     }\\n    ... )\\n    >>> df.select(pl.struct(pl.all()).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct           \u2502\\n    \u2502 ---                 \u2502\\n    \u2502 struct[4]           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,\"a\",true,[1, 2]} \u2502\\n    \u2502 {2,\"b\",null,[3]}    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Collect selected columns into a struct by either passing a list of columns, or by\\n    specifying each column as a positional argument.\\n\\n    >>> df.select(pl.struct(\"int\", False).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct \u2502\\n    \u2502 ---       \u2502\\n    \u2502 struct[2] \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,false} \u2502\\n    \u2502 {2,false} \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Use keyword arguments to easily name each struct field.\\n\\n    >>> df.select(pl.struct(p=\"int\", q=\"bool\").alias(\"my_struct\")).schema\\n    OrderedDict([(\\'my_struct\\', Struct([Field(\\'p\\', Int64), Field(\\'q\\', Boolean)]))])\\n\\n    '\n    pyexprs = parse_as_list_of_expressions(*exprs, **named_exprs)\n    expr = wrap_expr(plr.as_struct(pyexprs))\n    if schema:\n        if not exprs:\n            expr = wrap_expr(plr.as_struct(parse_as_list_of_expressions(list(schema.keys()))))\n        expr = expr.cast(Struct(schema), strict=False)\n    if eager:\n        return F.select(expr).to_series()\n    else:\n        return expr",
            "def struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=None, eager: bool=False, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Collect columns into a struct column.\\n\\n    Parameters\\n    ----------\\n    *exprs\\n        Column(s) to collect into a struct column, specified as positional arguments.\\n        Accepts expression input. Strings are parsed as column names,\\n        other non-expression inputs are parsed as literals.\\n    schema\\n        Optional schema that explicitly defines the struct field dtypes. If no columns\\n        or expressions are provided, schema keys are used to define columns.\\n    eager\\n        Evaluate immediately and return a `Series`. If set to `False` (default),\\n        return an expression instead.\\n    **named_exprs\\n        Additional columns to collect into the struct column, specified as keyword\\n        arguments. The columns will be renamed to the keyword used.\\n\\n    Examples\\n    --------\\n    Collect all columns of a dataframe into a struct by passing `pl.all()`.\\n\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"int\": [1, 2],\\n    ...         \"str\": [\"a\", \"b\"],\\n    ...         \"bool\": [True, None],\\n    ...         \"list\": [[1, 2], [3]],\\n    ...     }\\n    ... )\\n    >>> df.select(pl.struct(pl.all()).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct           \u2502\\n    \u2502 ---                 \u2502\\n    \u2502 struct[4]           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,\"a\",true,[1, 2]} \u2502\\n    \u2502 {2,\"b\",null,[3]}    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Collect selected columns into a struct by either passing a list of columns, or by\\n    specifying each column as a positional argument.\\n\\n    >>> df.select(pl.struct(\"int\", False).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct \u2502\\n    \u2502 ---       \u2502\\n    \u2502 struct[2] \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,false} \u2502\\n    \u2502 {2,false} \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Use keyword arguments to easily name each struct field.\\n\\n    >>> df.select(pl.struct(p=\"int\", q=\"bool\").alias(\"my_struct\")).schema\\n    OrderedDict([(\\'my_struct\\', Struct([Field(\\'p\\', Int64), Field(\\'q\\', Boolean)]))])\\n\\n    '\n    pyexprs = parse_as_list_of_expressions(*exprs, **named_exprs)\n    expr = wrap_expr(plr.as_struct(pyexprs))\n    if schema:\n        if not exprs:\n            expr = wrap_expr(plr.as_struct(parse_as_list_of_expressions(list(schema.keys()))))\n        expr = expr.cast(Struct(schema), strict=False)\n    if eager:\n        return F.select(expr).to_series()\n    else:\n        return expr",
            "def struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=None, eager: bool=False, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Collect columns into a struct column.\\n\\n    Parameters\\n    ----------\\n    *exprs\\n        Column(s) to collect into a struct column, specified as positional arguments.\\n        Accepts expression input. Strings are parsed as column names,\\n        other non-expression inputs are parsed as literals.\\n    schema\\n        Optional schema that explicitly defines the struct field dtypes. If no columns\\n        or expressions are provided, schema keys are used to define columns.\\n    eager\\n        Evaluate immediately and return a `Series`. If set to `False` (default),\\n        return an expression instead.\\n    **named_exprs\\n        Additional columns to collect into the struct column, specified as keyword\\n        arguments. The columns will be renamed to the keyword used.\\n\\n    Examples\\n    --------\\n    Collect all columns of a dataframe into a struct by passing `pl.all()`.\\n\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"int\": [1, 2],\\n    ...         \"str\": [\"a\", \"b\"],\\n    ...         \"bool\": [True, None],\\n    ...         \"list\": [[1, 2], [3]],\\n    ...     }\\n    ... )\\n    >>> df.select(pl.struct(pl.all()).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct           \u2502\\n    \u2502 ---                 \u2502\\n    \u2502 struct[4]           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,\"a\",true,[1, 2]} \u2502\\n    \u2502 {2,\"b\",null,[3]}    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Collect selected columns into a struct by either passing a list of columns, or by\\n    specifying each column as a positional argument.\\n\\n    >>> df.select(pl.struct(\"int\", False).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct \u2502\\n    \u2502 ---       \u2502\\n    \u2502 struct[2] \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,false} \u2502\\n    \u2502 {2,false} \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Use keyword arguments to easily name each struct field.\\n\\n    >>> df.select(pl.struct(p=\"int\", q=\"bool\").alias(\"my_struct\")).schema\\n    OrderedDict([(\\'my_struct\\', Struct([Field(\\'p\\', Int64), Field(\\'q\\', Boolean)]))])\\n\\n    '\n    pyexprs = parse_as_list_of_expressions(*exprs, **named_exprs)\n    expr = wrap_expr(plr.as_struct(pyexprs))\n    if schema:\n        if not exprs:\n            expr = wrap_expr(plr.as_struct(parse_as_list_of_expressions(list(schema.keys()))))\n        expr = expr.cast(Struct(schema), strict=False)\n    if eager:\n        return F.select(expr).to_series()\n    else:\n        return expr",
            "def struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=None, eager: bool=False, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Collect columns into a struct column.\\n\\n    Parameters\\n    ----------\\n    *exprs\\n        Column(s) to collect into a struct column, specified as positional arguments.\\n        Accepts expression input. Strings are parsed as column names,\\n        other non-expression inputs are parsed as literals.\\n    schema\\n        Optional schema that explicitly defines the struct field dtypes. If no columns\\n        or expressions are provided, schema keys are used to define columns.\\n    eager\\n        Evaluate immediately and return a `Series`. If set to `False` (default),\\n        return an expression instead.\\n    **named_exprs\\n        Additional columns to collect into the struct column, specified as keyword\\n        arguments. The columns will be renamed to the keyword used.\\n\\n    Examples\\n    --------\\n    Collect all columns of a dataframe into a struct by passing `pl.all()`.\\n\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"int\": [1, 2],\\n    ...         \"str\": [\"a\", \"b\"],\\n    ...         \"bool\": [True, None],\\n    ...         \"list\": [[1, 2], [3]],\\n    ...     }\\n    ... )\\n    >>> df.select(pl.struct(pl.all()).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct           \u2502\\n    \u2502 ---                 \u2502\\n    \u2502 struct[4]           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,\"a\",true,[1, 2]} \u2502\\n    \u2502 {2,\"b\",null,[3]}    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Collect selected columns into a struct by either passing a list of columns, or by\\n    specifying each column as a positional argument.\\n\\n    >>> df.select(pl.struct(\"int\", False).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct \u2502\\n    \u2502 ---       \u2502\\n    \u2502 struct[2] \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,false} \u2502\\n    \u2502 {2,false} \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Use keyword arguments to easily name each struct field.\\n\\n    >>> df.select(pl.struct(p=\"int\", q=\"bool\").alias(\"my_struct\")).schema\\n    OrderedDict([(\\'my_struct\\', Struct([Field(\\'p\\', Int64), Field(\\'q\\', Boolean)]))])\\n\\n    '\n    pyexprs = parse_as_list_of_expressions(*exprs, **named_exprs)\n    expr = wrap_expr(plr.as_struct(pyexprs))\n    if schema:\n        if not exprs:\n            expr = wrap_expr(plr.as_struct(parse_as_list_of_expressions(list(schema.keys()))))\n        expr = expr.cast(Struct(schema), strict=False)\n    if eager:\n        return F.select(expr).to_series()\n    else:\n        return expr",
            "def struct(*exprs: IntoExpr | Iterable[IntoExpr], schema: SchemaDict | None=None, eager: bool=False, **named_exprs: IntoExpr) -> Expr | Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Collect columns into a struct column.\\n\\n    Parameters\\n    ----------\\n    *exprs\\n        Column(s) to collect into a struct column, specified as positional arguments.\\n        Accepts expression input. Strings are parsed as column names,\\n        other non-expression inputs are parsed as literals.\\n    schema\\n        Optional schema that explicitly defines the struct field dtypes. If no columns\\n        or expressions are provided, schema keys are used to define columns.\\n    eager\\n        Evaluate immediately and return a `Series`. If set to `False` (default),\\n        return an expression instead.\\n    **named_exprs\\n        Additional columns to collect into the struct column, specified as keyword\\n        arguments. The columns will be renamed to the keyword used.\\n\\n    Examples\\n    --------\\n    Collect all columns of a dataframe into a struct by passing `pl.all()`.\\n\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"int\": [1, 2],\\n    ...         \"str\": [\"a\", \"b\"],\\n    ...         \"bool\": [True, None],\\n    ...         \"list\": [[1, 2], [3]],\\n    ...     }\\n    ... )\\n    >>> df.select(pl.struct(pl.all()).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct           \u2502\\n    \u2502 ---                 \u2502\\n    \u2502 struct[4]           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,\"a\",true,[1, 2]} \u2502\\n    \u2502 {2,\"b\",null,[3]}    \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Collect selected columns into a struct by either passing a list of columns, or by\\n    specifying each column as a positional argument.\\n\\n    >>> df.select(pl.struct(\"int\", False).alias(\"my_struct\"))\\n    shape: (2, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 my_struct \u2502\\n    \u2502 ---       \u2502\\n    \u2502 struct[2] \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 {1,false} \u2502\\n    \u2502 {2,false} \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Use keyword arguments to easily name each struct field.\\n\\n    >>> df.select(pl.struct(p=\"int\", q=\"bool\").alias(\"my_struct\")).schema\\n    OrderedDict([(\\'my_struct\\', Struct([Field(\\'p\\', Int64), Field(\\'q\\', Boolean)]))])\\n\\n    '\n    pyexprs = parse_as_list_of_expressions(*exprs, **named_exprs)\n    expr = wrap_expr(plr.as_struct(pyexprs))\n    if schema:\n        if not exprs:\n            expr = wrap_expr(plr.as_struct(parse_as_list_of_expressions(list(schema.keys()))))\n        expr = expr.cast(Struct(schema), strict=False)\n    if eager:\n        return F.select(expr).to_series()\n    else:\n        return expr"
        ]
    },
    {
        "func_name": "concat_str",
        "original": "def concat_str(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr, separator: str='') -> Expr:\n    \"\"\"\n    Horizontally concatenate columns into a single string column.\n\n    Operates in linear time.\n\n    Parameters\n    ----------\n    exprs\n        Columns to concatenate into a single string column. Accepts expression input.\n        Strings are parsed as column names, other non-expression inputs are parsed as\n        literals. Non-`Utf8` columns are cast to `Utf8`.\n    *more_exprs\n        Additional columns to concatenate into a single string column, specified as\n        positional arguments.\n    separator\n        String that will be used to separate the values of each column.\n\n    Examples\n    --------\n    >>> df = pl.DataFrame(\n    ...     {\n    ...         \"a\": [1, 2, 3],\n    ...         \"b\": [\"dogs\", \"cats\", None],\n    ...         \"c\": [\"play\", \"swim\", \"walk\"],\n    ...     }\n    ... )\n    >>> df.with_columns(\n    ...     pl.concat_str(\n    ...         [\n    ...             pl.col(\"a\") * 2,\n    ...             pl.col(\"b\"),\n    ...             pl.col(\"c\"),\n    ...         ],\n    ...         separator=\" \",\n    ...     ).alias(\"full_sentence\"),\n    ... )\n    shape: (3, 4)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 a   \u2506 b    \u2506 c    \u2506 full_sentence \u2502\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---           \u2502\n    \u2502 i64 \u2506 str  \u2506 str  \u2506 str           \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 1   \u2506 dogs \u2506 play \u2506 2 dogs play   \u2502\n    \u2502 2   \u2506 cats \u2506 swim \u2506 4 cats swim   \u2502\n    \u2502 3   \u2506 null \u2506 walk \u2506 null          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_str(exprs, separator))",
        "mutated": [
            "def concat_str(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr, separator: str='') -> Expr:\n    if False:\n        i = 10\n    '\\n    Horizontally concatenate columns into a single string column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single string column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals. Non-`Utf8` columns are cast to `Utf8`.\\n    *more_exprs\\n        Additional columns to concatenate into a single string column, specified as\\n        positional arguments.\\n    separator\\n        String that will be used to separate the values of each column.\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [1, 2, 3],\\n    ...         \"b\": [\"dogs\", \"cats\", None],\\n    ...         \"c\": [\"play\", \"swim\", \"walk\"],\\n    ...     }\\n    ... )\\n    >>> df.with_columns(\\n    ...     pl.concat_str(\\n    ...         [\\n    ...             pl.col(\"a\") * 2,\\n    ...             pl.col(\"b\"),\\n    ...             pl.col(\"c\"),\\n    ...         ],\\n    ...         separator=\" \",\\n    ...     ).alias(\"full_sentence\"),\\n    ... )\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2506 full_sentence \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---           \u2502\\n    \u2502 i64 \u2506 str  \u2506 str  \u2506 str           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 dogs \u2506 play \u2506 2 dogs play   \u2502\\n    \u2502 2   \u2506 cats \u2506 swim \u2506 4 cats swim   \u2502\\n    \u2502 3   \u2506 null \u2506 walk \u2506 null          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_str(exprs, separator))",
            "def concat_str(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr, separator: str='') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Horizontally concatenate columns into a single string column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single string column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals. Non-`Utf8` columns are cast to `Utf8`.\\n    *more_exprs\\n        Additional columns to concatenate into a single string column, specified as\\n        positional arguments.\\n    separator\\n        String that will be used to separate the values of each column.\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [1, 2, 3],\\n    ...         \"b\": [\"dogs\", \"cats\", None],\\n    ...         \"c\": [\"play\", \"swim\", \"walk\"],\\n    ...     }\\n    ... )\\n    >>> df.with_columns(\\n    ...     pl.concat_str(\\n    ...         [\\n    ...             pl.col(\"a\") * 2,\\n    ...             pl.col(\"b\"),\\n    ...             pl.col(\"c\"),\\n    ...         ],\\n    ...         separator=\" \",\\n    ...     ).alias(\"full_sentence\"),\\n    ... )\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2506 full_sentence \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---           \u2502\\n    \u2502 i64 \u2506 str  \u2506 str  \u2506 str           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 dogs \u2506 play \u2506 2 dogs play   \u2502\\n    \u2502 2   \u2506 cats \u2506 swim \u2506 4 cats swim   \u2502\\n    \u2502 3   \u2506 null \u2506 walk \u2506 null          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_str(exprs, separator))",
            "def concat_str(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr, separator: str='') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Horizontally concatenate columns into a single string column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single string column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals. Non-`Utf8` columns are cast to `Utf8`.\\n    *more_exprs\\n        Additional columns to concatenate into a single string column, specified as\\n        positional arguments.\\n    separator\\n        String that will be used to separate the values of each column.\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [1, 2, 3],\\n    ...         \"b\": [\"dogs\", \"cats\", None],\\n    ...         \"c\": [\"play\", \"swim\", \"walk\"],\\n    ...     }\\n    ... )\\n    >>> df.with_columns(\\n    ...     pl.concat_str(\\n    ...         [\\n    ...             pl.col(\"a\") * 2,\\n    ...             pl.col(\"b\"),\\n    ...             pl.col(\"c\"),\\n    ...         ],\\n    ...         separator=\" \",\\n    ...     ).alias(\"full_sentence\"),\\n    ... )\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2506 full_sentence \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---           \u2502\\n    \u2502 i64 \u2506 str  \u2506 str  \u2506 str           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 dogs \u2506 play \u2506 2 dogs play   \u2502\\n    \u2502 2   \u2506 cats \u2506 swim \u2506 4 cats swim   \u2502\\n    \u2502 3   \u2506 null \u2506 walk \u2506 null          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_str(exprs, separator))",
            "def concat_str(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr, separator: str='') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Horizontally concatenate columns into a single string column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single string column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals. Non-`Utf8` columns are cast to `Utf8`.\\n    *more_exprs\\n        Additional columns to concatenate into a single string column, specified as\\n        positional arguments.\\n    separator\\n        String that will be used to separate the values of each column.\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [1, 2, 3],\\n    ...         \"b\": [\"dogs\", \"cats\", None],\\n    ...         \"c\": [\"play\", \"swim\", \"walk\"],\\n    ...     }\\n    ... )\\n    >>> df.with_columns(\\n    ...     pl.concat_str(\\n    ...         [\\n    ...             pl.col(\"a\") * 2,\\n    ...             pl.col(\"b\"),\\n    ...             pl.col(\"c\"),\\n    ...         ],\\n    ...         separator=\" \",\\n    ...     ).alias(\"full_sentence\"),\\n    ... )\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2506 full_sentence \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---           \u2502\\n    \u2502 i64 \u2506 str  \u2506 str  \u2506 str           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 dogs \u2506 play \u2506 2 dogs play   \u2502\\n    \u2502 2   \u2506 cats \u2506 swim \u2506 4 cats swim   \u2502\\n    \u2502 3   \u2506 null \u2506 walk \u2506 null          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_str(exprs, separator))",
            "def concat_str(exprs: IntoExpr | Iterable[IntoExpr], *more_exprs: IntoExpr, separator: str='') -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Horizontally concatenate columns into a single string column.\\n\\n    Operates in linear time.\\n\\n    Parameters\\n    ----------\\n    exprs\\n        Columns to concatenate into a single string column. Accepts expression input.\\n        Strings are parsed as column names, other non-expression inputs are parsed as\\n        literals. Non-`Utf8` columns are cast to `Utf8`.\\n    *more_exprs\\n        Additional columns to concatenate into a single string column, specified as\\n        positional arguments.\\n    separator\\n        String that will be used to separate the values of each column.\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [1, 2, 3],\\n    ...         \"b\": [\"dogs\", \"cats\", None],\\n    ...         \"c\": [\"play\", \"swim\", \"walk\"],\\n    ...     }\\n    ... )\\n    >>> df.with_columns(\\n    ...     pl.concat_str(\\n    ...         [\\n    ...             pl.col(\"a\") * 2,\\n    ...             pl.col(\"b\"),\\n    ...             pl.col(\"c\"),\\n    ...         ],\\n    ...         separator=\" \",\\n    ...     ).alias(\"full_sentence\"),\\n    ... )\\n    shape: (3, 4)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 a   \u2506 b    \u2506 c    \u2506 full_sentence \u2502\\n    \u2502 --- \u2506 ---  \u2506 ---  \u2506 ---           \u2502\\n    \u2502 i64 \u2506 str  \u2506 str  \u2506 str           \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 1   \u2506 dogs \u2506 play \u2506 2 dogs play   \u2502\\n    \u2502 2   \u2506 cats \u2506 swim \u2506 4 cats swim   \u2502\\n    \u2502 3   \u2506 null \u2506 walk \u2506 null          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    exprs = parse_as_list_of_expressions(exprs, *more_exprs)\n    return wrap_expr(plr.concat_str(exprs, separator))"
        ]
    },
    {
        "func_name": "format",
        "original": "def format(f_string: str, *args: Expr | str) -> Expr:\n    \"\"\"\n    Format expressions as a string.\n\n    Parameters\n    ----------\n    f_string\n        A string that with placeholders.\n        For example: \"hello_{}\" or \"{}_world\n    args\n        Expression(s) that fill the placeholders\n\n    Examples\n    --------\n    >>> df = pl.DataFrame(\n    ...     {\n    ...         \"a\": [\"a\", \"b\", \"c\"],\n    ...         \"b\": [1, 2, 3],\n    ...     }\n    ... )\n    >>> df.select(\n    ...     [\n    ...         pl.format(\"foo_{}_bar_{}\", pl.col(\"a\"), \"b\").alias(\"fmt\"),\n    ...     ]\n    ... )\n    shape: (3, 1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 fmt         \u2502\n    \u2502 ---         \u2502\n    \u2502 str         \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 foo_a_bar_1 \u2502\n    \u2502 foo_b_bar_2 \u2502\n    \u2502 foo_c_bar_3 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    if f_string.count('{}') != len(args):\n        raise ValueError('number of placeholders should equal the number of arguments')\n    exprs = []\n    arguments = iter(args)\n    for (i, s) in enumerate(f_string.split('{}')):\n        if i > 0:\n            e = wrap_expr(parse_as_expression(next(arguments)))\n            exprs.append(e)\n        if len(s) > 0:\n            exprs.append(F.lit(s))\n    return concat_str(exprs, separator='')",
        "mutated": [
            "def format(f_string: str, *args: Expr | str) -> Expr:\n    if False:\n        i = 10\n    '\\n    Format expressions as a string.\\n\\n    Parameters\\n    ----------\\n    f_string\\n        A string that with placeholders.\\n        For example: \"hello_{}\" or \"{}_world\\n    args\\n        Expression(s) that fill the placeholders\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [\"a\", \"b\", \"c\"],\\n    ...         \"b\": [1, 2, 3],\\n    ...     }\\n    ... )\\n    >>> df.select(\\n    ...     [\\n    ...         pl.format(\"foo_{}_bar_{}\", pl.col(\"a\"), \"b\").alias(\"fmt\"),\\n    ...     ]\\n    ... )\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 fmt         \u2502\\n    \u2502 ---         \u2502\\n    \u2502 str         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 foo_a_bar_1 \u2502\\n    \u2502 foo_b_bar_2 \u2502\\n    \u2502 foo_c_bar_3 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if f_string.count('{}') != len(args):\n        raise ValueError('number of placeholders should equal the number of arguments')\n    exprs = []\n    arguments = iter(args)\n    for (i, s) in enumerate(f_string.split('{}')):\n        if i > 0:\n            e = wrap_expr(parse_as_expression(next(arguments)))\n            exprs.append(e)\n        if len(s) > 0:\n            exprs.append(F.lit(s))\n    return concat_str(exprs, separator='')",
            "def format(f_string: str, *args: Expr | str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Format expressions as a string.\\n\\n    Parameters\\n    ----------\\n    f_string\\n        A string that with placeholders.\\n        For example: \"hello_{}\" or \"{}_world\\n    args\\n        Expression(s) that fill the placeholders\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [\"a\", \"b\", \"c\"],\\n    ...         \"b\": [1, 2, 3],\\n    ...     }\\n    ... )\\n    >>> df.select(\\n    ...     [\\n    ...         pl.format(\"foo_{}_bar_{}\", pl.col(\"a\"), \"b\").alias(\"fmt\"),\\n    ...     ]\\n    ... )\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 fmt         \u2502\\n    \u2502 ---         \u2502\\n    \u2502 str         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 foo_a_bar_1 \u2502\\n    \u2502 foo_b_bar_2 \u2502\\n    \u2502 foo_c_bar_3 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if f_string.count('{}') != len(args):\n        raise ValueError('number of placeholders should equal the number of arguments')\n    exprs = []\n    arguments = iter(args)\n    for (i, s) in enumerate(f_string.split('{}')):\n        if i > 0:\n            e = wrap_expr(parse_as_expression(next(arguments)))\n            exprs.append(e)\n        if len(s) > 0:\n            exprs.append(F.lit(s))\n    return concat_str(exprs, separator='')",
            "def format(f_string: str, *args: Expr | str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Format expressions as a string.\\n\\n    Parameters\\n    ----------\\n    f_string\\n        A string that with placeholders.\\n        For example: \"hello_{}\" or \"{}_world\\n    args\\n        Expression(s) that fill the placeholders\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [\"a\", \"b\", \"c\"],\\n    ...         \"b\": [1, 2, 3],\\n    ...     }\\n    ... )\\n    >>> df.select(\\n    ...     [\\n    ...         pl.format(\"foo_{}_bar_{}\", pl.col(\"a\"), \"b\").alias(\"fmt\"),\\n    ...     ]\\n    ... )\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 fmt         \u2502\\n    \u2502 ---         \u2502\\n    \u2502 str         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 foo_a_bar_1 \u2502\\n    \u2502 foo_b_bar_2 \u2502\\n    \u2502 foo_c_bar_3 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if f_string.count('{}') != len(args):\n        raise ValueError('number of placeholders should equal the number of arguments')\n    exprs = []\n    arguments = iter(args)\n    for (i, s) in enumerate(f_string.split('{}')):\n        if i > 0:\n            e = wrap_expr(parse_as_expression(next(arguments)))\n            exprs.append(e)\n        if len(s) > 0:\n            exprs.append(F.lit(s))\n    return concat_str(exprs, separator='')",
            "def format(f_string: str, *args: Expr | str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Format expressions as a string.\\n\\n    Parameters\\n    ----------\\n    f_string\\n        A string that with placeholders.\\n        For example: \"hello_{}\" or \"{}_world\\n    args\\n        Expression(s) that fill the placeholders\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [\"a\", \"b\", \"c\"],\\n    ...         \"b\": [1, 2, 3],\\n    ...     }\\n    ... )\\n    >>> df.select(\\n    ...     [\\n    ...         pl.format(\"foo_{}_bar_{}\", pl.col(\"a\"), \"b\").alias(\"fmt\"),\\n    ...     ]\\n    ... )\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 fmt         \u2502\\n    \u2502 ---         \u2502\\n    \u2502 str         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 foo_a_bar_1 \u2502\\n    \u2502 foo_b_bar_2 \u2502\\n    \u2502 foo_c_bar_3 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if f_string.count('{}') != len(args):\n        raise ValueError('number of placeholders should equal the number of arguments')\n    exprs = []\n    arguments = iter(args)\n    for (i, s) in enumerate(f_string.split('{}')):\n        if i > 0:\n            e = wrap_expr(parse_as_expression(next(arguments)))\n            exprs.append(e)\n        if len(s) > 0:\n            exprs.append(F.lit(s))\n    return concat_str(exprs, separator='')",
            "def format(f_string: str, *args: Expr | str) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Format expressions as a string.\\n\\n    Parameters\\n    ----------\\n    f_string\\n        A string that with placeholders.\\n        For example: \"hello_{}\" or \"{}_world\\n    args\\n        Expression(s) that fill the placeholders\\n\\n    Examples\\n    --------\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"a\": [\"a\", \"b\", \"c\"],\\n    ...         \"b\": [1, 2, 3],\\n    ...     }\\n    ... )\\n    >>> df.select(\\n    ...     [\\n    ...         pl.format(\"foo_{}_bar_{}\", pl.col(\"a\"), \"b\").alias(\"fmt\"),\\n    ...     ]\\n    ... )\\n    shape: (3, 1)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 fmt         \u2502\\n    \u2502 ---         \u2502\\n    \u2502 str         \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 foo_a_bar_1 \u2502\\n    \u2502 foo_b_bar_2 \u2502\\n    \u2502 foo_c_bar_3 \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    if f_string.count('{}') != len(args):\n        raise ValueError('number of placeholders should equal the number of arguments')\n    exprs = []\n    arguments = iter(args)\n    for (i, s) in enumerate(f_string.split('{}')):\n        if i > 0:\n            e = wrap_expr(parse_as_expression(next(arguments)))\n            exprs.append(e)\n        if len(s) > 0:\n            exprs.append(F.lit(s))\n    return concat_str(exprs, separator='')"
        ]
    }
]