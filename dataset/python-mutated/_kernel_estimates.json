[
    {
        "func_name": "_kernel_cumincidence",
        "original": "def _kernel_cumincidence(time, status, exog, kfunc, freq_weights, dimred=True):\n    \"\"\"\n    Calculates cumulative incidence functions using kernels.\n\n    Parameters\n    ----------\n    time : array_like\n        The observed time values\n    status : array_like\n        The status values.  status == 0 indicates censoring,\n        status == 1, 2, ... are the events.\n    exog : array_like\n        Covariates such that censoring becomes independent of\n        outcome times conditioned on the covariate values.\n    kfunc : function\n        A kernel function\n    freq_weights : array_like\n        Optional frequency weights\n    dimred : bool\n        If True, proportional hazards regression models are used to\n        reduce exog to two columns by predicting overall events and\n        censoring in two separate models.  If False, exog is used\n        directly for calculating kernel weights without dimension\n        reduction.\n    \"\"\"\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog = exog[ii, :]\n    nobs = len(time)\n    (utime, rtime) = np.unique(time, return_inverse=True)\n    ie = np.searchsorted(time, utime, side='right') - 1\n    ngrp = int(status.max())\n    statusa = (status >= 1).astype(np.float64)\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    ip = []\n    sp = [None] * nobs\n    n_risk = [None] * nobs\n    kd = [None] * nobs\n    for k in range(ngrp):\n        status0 = (status == k + 1).astype(np.float64)\n        if dimred:\n            sfe = PHReg(time, exog, status0).fit()\n            fitval_e = sfe.predict().predicted_values\n            sfc = PHReg(time, exog, 1 - status0).fit()\n            fitval_c = sfc.predict().predicted_values\n            exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n            exog2d -= exog2d.mean(0)\n            exog2d /= exog2d.std(0)\n        else:\n            exog2d = exog\n        ip0 = 0\n        for i in range(nobs):\n            if k == 0:\n                kd1 = exog2d - exog2d[i, :]\n                kd1 = kfunc(kd1)\n                kd[i] = kd1\n            if k == 0:\n                denom = np.cumsum(kd[i][::-1])[::-1]\n                num = kd[i] * statusa\n                rat = num / denom\n                tr = 1e-15\n                ii = np.flatnonzero((denom < tr) & (num < tr))\n                rat[ii] = 0\n                ratc = 1 - rat\n                ratc = np.clip(ratc, 1e-10, np.inf)\n                lrat = np.log(ratc)\n                prat = np.cumsum(lrat)[ie]\n                sf = np.exp(prat)\n                sp[i] = np.r_[1, sf[:-1]]\n                n_risk[i] = denom[ie]\n            d0 = np.bincount(rtime, weights=status0 * kd[i], minlength=len(utime))\n            ip1 = np.cumsum(sp[i] * d0 / n_risk[i])\n            jj = len(ip1) - np.searchsorted(n_risk[i][::-1], 1)\n            if jj < len(ip1):\n                ip1[jj:] = ip1[jj - 1]\n            if freq_weights is None:\n                ip0 += ip1\n            else:\n                ip0 += freq_weights[i] * ip1\n        if freq_weights is None:\n            ip0 /= nobs\n        ip.append(ip0)\n    return (utime, ip)",
        "mutated": [
            "def _kernel_cumincidence(time, status, exog, kfunc, freq_weights, dimred=True):\n    if False:\n        i = 10\n    '\\n    Calculates cumulative incidence functions using kernels.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed time values\\n    status : array_like\\n        The status values.  status == 0 indicates censoring,\\n        status == 1, 2, ... are the events.\\n    exog : array_like\\n        Covariates such that censoring becomes independent of\\n        outcome times conditioned on the covariate values.\\n    kfunc : function\\n        A kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n    dimred : bool\\n        If True, proportional hazards regression models are used to\\n        reduce exog to two columns by predicting overall events and\\n        censoring in two separate models.  If False, exog is used\\n        directly for calculating kernel weights without dimension\\n        reduction.\\n    '\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog = exog[ii, :]\n    nobs = len(time)\n    (utime, rtime) = np.unique(time, return_inverse=True)\n    ie = np.searchsorted(time, utime, side='right') - 1\n    ngrp = int(status.max())\n    statusa = (status >= 1).astype(np.float64)\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    ip = []\n    sp = [None] * nobs\n    n_risk = [None] * nobs\n    kd = [None] * nobs\n    for k in range(ngrp):\n        status0 = (status == k + 1).astype(np.float64)\n        if dimred:\n            sfe = PHReg(time, exog, status0).fit()\n            fitval_e = sfe.predict().predicted_values\n            sfc = PHReg(time, exog, 1 - status0).fit()\n            fitval_c = sfc.predict().predicted_values\n            exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n            exog2d -= exog2d.mean(0)\n            exog2d /= exog2d.std(0)\n        else:\n            exog2d = exog\n        ip0 = 0\n        for i in range(nobs):\n            if k == 0:\n                kd1 = exog2d - exog2d[i, :]\n                kd1 = kfunc(kd1)\n                kd[i] = kd1\n            if k == 0:\n                denom = np.cumsum(kd[i][::-1])[::-1]\n                num = kd[i] * statusa\n                rat = num / denom\n                tr = 1e-15\n                ii = np.flatnonzero((denom < tr) & (num < tr))\n                rat[ii] = 0\n                ratc = 1 - rat\n                ratc = np.clip(ratc, 1e-10, np.inf)\n                lrat = np.log(ratc)\n                prat = np.cumsum(lrat)[ie]\n                sf = np.exp(prat)\n                sp[i] = np.r_[1, sf[:-1]]\n                n_risk[i] = denom[ie]\n            d0 = np.bincount(rtime, weights=status0 * kd[i], minlength=len(utime))\n            ip1 = np.cumsum(sp[i] * d0 / n_risk[i])\n            jj = len(ip1) - np.searchsorted(n_risk[i][::-1], 1)\n            if jj < len(ip1):\n                ip1[jj:] = ip1[jj - 1]\n            if freq_weights is None:\n                ip0 += ip1\n            else:\n                ip0 += freq_weights[i] * ip1\n        if freq_weights is None:\n            ip0 /= nobs\n        ip.append(ip0)\n    return (utime, ip)",
            "def _kernel_cumincidence(time, status, exog, kfunc, freq_weights, dimred=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculates cumulative incidence functions using kernels.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed time values\\n    status : array_like\\n        The status values.  status == 0 indicates censoring,\\n        status == 1, 2, ... are the events.\\n    exog : array_like\\n        Covariates such that censoring becomes independent of\\n        outcome times conditioned on the covariate values.\\n    kfunc : function\\n        A kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n    dimred : bool\\n        If True, proportional hazards regression models are used to\\n        reduce exog to two columns by predicting overall events and\\n        censoring in two separate models.  If False, exog is used\\n        directly for calculating kernel weights without dimension\\n        reduction.\\n    '\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog = exog[ii, :]\n    nobs = len(time)\n    (utime, rtime) = np.unique(time, return_inverse=True)\n    ie = np.searchsorted(time, utime, side='right') - 1\n    ngrp = int(status.max())\n    statusa = (status >= 1).astype(np.float64)\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    ip = []\n    sp = [None] * nobs\n    n_risk = [None] * nobs\n    kd = [None] * nobs\n    for k in range(ngrp):\n        status0 = (status == k + 1).astype(np.float64)\n        if dimred:\n            sfe = PHReg(time, exog, status0).fit()\n            fitval_e = sfe.predict().predicted_values\n            sfc = PHReg(time, exog, 1 - status0).fit()\n            fitval_c = sfc.predict().predicted_values\n            exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n            exog2d -= exog2d.mean(0)\n            exog2d /= exog2d.std(0)\n        else:\n            exog2d = exog\n        ip0 = 0\n        for i in range(nobs):\n            if k == 0:\n                kd1 = exog2d - exog2d[i, :]\n                kd1 = kfunc(kd1)\n                kd[i] = kd1\n            if k == 0:\n                denom = np.cumsum(kd[i][::-1])[::-1]\n                num = kd[i] * statusa\n                rat = num / denom\n                tr = 1e-15\n                ii = np.flatnonzero((denom < tr) & (num < tr))\n                rat[ii] = 0\n                ratc = 1 - rat\n                ratc = np.clip(ratc, 1e-10, np.inf)\n                lrat = np.log(ratc)\n                prat = np.cumsum(lrat)[ie]\n                sf = np.exp(prat)\n                sp[i] = np.r_[1, sf[:-1]]\n                n_risk[i] = denom[ie]\n            d0 = np.bincount(rtime, weights=status0 * kd[i], minlength=len(utime))\n            ip1 = np.cumsum(sp[i] * d0 / n_risk[i])\n            jj = len(ip1) - np.searchsorted(n_risk[i][::-1], 1)\n            if jj < len(ip1):\n                ip1[jj:] = ip1[jj - 1]\n            if freq_weights is None:\n                ip0 += ip1\n            else:\n                ip0 += freq_weights[i] * ip1\n        if freq_weights is None:\n            ip0 /= nobs\n        ip.append(ip0)\n    return (utime, ip)",
            "def _kernel_cumincidence(time, status, exog, kfunc, freq_weights, dimred=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculates cumulative incidence functions using kernels.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed time values\\n    status : array_like\\n        The status values.  status == 0 indicates censoring,\\n        status == 1, 2, ... are the events.\\n    exog : array_like\\n        Covariates such that censoring becomes independent of\\n        outcome times conditioned on the covariate values.\\n    kfunc : function\\n        A kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n    dimred : bool\\n        If True, proportional hazards regression models are used to\\n        reduce exog to two columns by predicting overall events and\\n        censoring in two separate models.  If False, exog is used\\n        directly for calculating kernel weights without dimension\\n        reduction.\\n    '\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog = exog[ii, :]\n    nobs = len(time)\n    (utime, rtime) = np.unique(time, return_inverse=True)\n    ie = np.searchsorted(time, utime, side='right') - 1\n    ngrp = int(status.max())\n    statusa = (status >= 1).astype(np.float64)\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    ip = []\n    sp = [None] * nobs\n    n_risk = [None] * nobs\n    kd = [None] * nobs\n    for k in range(ngrp):\n        status0 = (status == k + 1).astype(np.float64)\n        if dimred:\n            sfe = PHReg(time, exog, status0).fit()\n            fitval_e = sfe.predict().predicted_values\n            sfc = PHReg(time, exog, 1 - status0).fit()\n            fitval_c = sfc.predict().predicted_values\n            exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n            exog2d -= exog2d.mean(0)\n            exog2d /= exog2d.std(0)\n        else:\n            exog2d = exog\n        ip0 = 0\n        for i in range(nobs):\n            if k == 0:\n                kd1 = exog2d - exog2d[i, :]\n                kd1 = kfunc(kd1)\n                kd[i] = kd1\n            if k == 0:\n                denom = np.cumsum(kd[i][::-1])[::-1]\n                num = kd[i] * statusa\n                rat = num / denom\n                tr = 1e-15\n                ii = np.flatnonzero((denom < tr) & (num < tr))\n                rat[ii] = 0\n                ratc = 1 - rat\n                ratc = np.clip(ratc, 1e-10, np.inf)\n                lrat = np.log(ratc)\n                prat = np.cumsum(lrat)[ie]\n                sf = np.exp(prat)\n                sp[i] = np.r_[1, sf[:-1]]\n                n_risk[i] = denom[ie]\n            d0 = np.bincount(rtime, weights=status0 * kd[i], minlength=len(utime))\n            ip1 = np.cumsum(sp[i] * d0 / n_risk[i])\n            jj = len(ip1) - np.searchsorted(n_risk[i][::-1], 1)\n            if jj < len(ip1):\n                ip1[jj:] = ip1[jj - 1]\n            if freq_weights is None:\n                ip0 += ip1\n            else:\n                ip0 += freq_weights[i] * ip1\n        if freq_weights is None:\n            ip0 /= nobs\n        ip.append(ip0)\n    return (utime, ip)",
            "def _kernel_cumincidence(time, status, exog, kfunc, freq_weights, dimred=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculates cumulative incidence functions using kernels.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed time values\\n    status : array_like\\n        The status values.  status == 0 indicates censoring,\\n        status == 1, 2, ... are the events.\\n    exog : array_like\\n        Covariates such that censoring becomes independent of\\n        outcome times conditioned on the covariate values.\\n    kfunc : function\\n        A kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n    dimred : bool\\n        If True, proportional hazards regression models are used to\\n        reduce exog to two columns by predicting overall events and\\n        censoring in two separate models.  If False, exog is used\\n        directly for calculating kernel weights without dimension\\n        reduction.\\n    '\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog = exog[ii, :]\n    nobs = len(time)\n    (utime, rtime) = np.unique(time, return_inverse=True)\n    ie = np.searchsorted(time, utime, side='right') - 1\n    ngrp = int(status.max())\n    statusa = (status >= 1).astype(np.float64)\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    ip = []\n    sp = [None] * nobs\n    n_risk = [None] * nobs\n    kd = [None] * nobs\n    for k in range(ngrp):\n        status0 = (status == k + 1).astype(np.float64)\n        if dimred:\n            sfe = PHReg(time, exog, status0).fit()\n            fitval_e = sfe.predict().predicted_values\n            sfc = PHReg(time, exog, 1 - status0).fit()\n            fitval_c = sfc.predict().predicted_values\n            exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n            exog2d -= exog2d.mean(0)\n            exog2d /= exog2d.std(0)\n        else:\n            exog2d = exog\n        ip0 = 0\n        for i in range(nobs):\n            if k == 0:\n                kd1 = exog2d - exog2d[i, :]\n                kd1 = kfunc(kd1)\n                kd[i] = kd1\n            if k == 0:\n                denom = np.cumsum(kd[i][::-1])[::-1]\n                num = kd[i] * statusa\n                rat = num / denom\n                tr = 1e-15\n                ii = np.flatnonzero((denom < tr) & (num < tr))\n                rat[ii] = 0\n                ratc = 1 - rat\n                ratc = np.clip(ratc, 1e-10, np.inf)\n                lrat = np.log(ratc)\n                prat = np.cumsum(lrat)[ie]\n                sf = np.exp(prat)\n                sp[i] = np.r_[1, sf[:-1]]\n                n_risk[i] = denom[ie]\n            d0 = np.bincount(rtime, weights=status0 * kd[i], minlength=len(utime))\n            ip1 = np.cumsum(sp[i] * d0 / n_risk[i])\n            jj = len(ip1) - np.searchsorted(n_risk[i][::-1], 1)\n            if jj < len(ip1):\n                ip1[jj:] = ip1[jj - 1]\n            if freq_weights is None:\n                ip0 += ip1\n            else:\n                ip0 += freq_weights[i] * ip1\n        if freq_weights is None:\n            ip0 /= nobs\n        ip.append(ip0)\n    return (utime, ip)",
            "def _kernel_cumincidence(time, status, exog, kfunc, freq_weights, dimred=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculates cumulative incidence functions using kernels.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed time values\\n    status : array_like\\n        The status values.  status == 0 indicates censoring,\\n        status == 1, 2, ... are the events.\\n    exog : array_like\\n        Covariates such that censoring becomes independent of\\n        outcome times conditioned on the covariate values.\\n    kfunc : function\\n        A kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n    dimred : bool\\n        If True, proportional hazards regression models are used to\\n        reduce exog to two columns by predicting overall events and\\n        censoring in two separate models.  If False, exog is used\\n        directly for calculating kernel weights without dimension\\n        reduction.\\n    '\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog = exog[ii, :]\n    nobs = len(time)\n    (utime, rtime) = np.unique(time, return_inverse=True)\n    ie = np.searchsorted(time, utime, side='right') - 1\n    ngrp = int(status.max())\n    statusa = (status >= 1).astype(np.float64)\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    ip = []\n    sp = [None] * nobs\n    n_risk = [None] * nobs\n    kd = [None] * nobs\n    for k in range(ngrp):\n        status0 = (status == k + 1).astype(np.float64)\n        if dimred:\n            sfe = PHReg(time, exog, status0).fit()\n            fitval_e = sfe.predict().predicted_values\n            sfc = PHReg(time, exog, 1 - status0).fit()\n            fitval_c = sfc.predict().predicted_values\n            exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n            exog2d -= exog2d.mean(0)\n            exog2d /= exog2d.std(0)\n        else:\n            exog2d = exog\n        ip0 = 0\n        for i in range(nobs):\n            if k == 0:\n                kd1 = exog2d - exog2d[i, :]\n                kd1 = kfunc(kd1)\n                kd[i] = kd1\n            if k == 0:\n                denom = np.cumsum(kd[i][::-1])[::-1]\n                num = kd[i] * statusa\n                rat = num / denom\n                tr = 1e-15\n                ii = np.flatnonzero((denom < tr) & (num < tr))\n                rat[ii] = 0\n                ratc = 1 - rat\n                ratc = np.clip(ratc, 1e-10, np.inf)\n                lrat = np.log(ratc)\n                prat = np.cumsum(lrat)[ie]\n                sf = np.exp(prat)\n                sp[i] = np.r_[1, sf[:-1]]\n                n_risk[i] = denom[ie]\n            d0 = np.bincount(rtime, weights=status0 * kd[i], minlength=len(utime))\n            ip1 = np.cumsum(sp[i] * d0 / n_risk[i])\n            jj = len(ip1) - np.searchsorted(n_risk[i][::-1], 1)\n            if jj < len(ip1):\n                ip1[jj:] = ip1[jj - 1]\n            if freq_weights is None:\n                ip0 += ip1\n            else:\n                ip0 += freq_weights[i] * ip1\n        if freq_weights is None:\n            ip0 /= nobs\n        ip.append(ip0)\n    return (utime, ip)"
        ]
    },
    {
        "func_name": "_kernel_survfunc",
        "original": "def _kernel_survfunc(time, status, exog, kfunc, freq_weights):\n    \"\"\"\n    Estimate the marginal survival function under dependent censoring.\n\n    Parameters\n    ----------\n    time : array_like\n        The observed times for each subject\n    status : array_like\n        The status for each subject (1 indicates event, 0 indicates\n        censoring)\n    exog : array_like\n        Covariates such that censoring is independent conditional on\n        exog\n    kfunc : function\n        Kernel function\n    freq_weights : array_like\n        Optional frequency weights\n\n    Returns\n    -------\n    probs : array_like\n        The estimated survival probabilities\n    times : array_like\n        The times at which the survival probabilities are estimated\n\n    References\n    ----------\n    Zeng, Donglin 2004. Estimating Marginal Survival Function by\n    Adjusting for Dependent Censoring Using Many Covariates. The\n    Annals of Statistics 32 (4): 1533 55.\n    doi:10.1214/009053604000000508.\n    https://arxiv.org/pdf/math/0409180.pdf\n    \"\"\"\n    sfe = PHReg(time, exog, status).fit()\n    fitval_e = sfe.predict().predicted_values\n    sfc = PHReg(time, exog, 1 - status).fit()\n    fitval_c = sfc.predict().predicted_values\n    exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n    n = len(time)\n    ixd = np.flatnonzero(status == 1)\n    utime = np.unique(time[ixd])\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog2d = exog2d[ii, :]\n    ie = np.searchsorted(time, utime, side='right') - 1\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    sprob = 0.0\n    for i in range(n):\n        kd = exog2d - exog2d[i, :]\n        kd = kfunc(kd)\n        denom = np.cumsum(kd[::-1])[::-1]\n        num = kd * status\n        rat = num / denom\n        tr = 1e-15\n        ii = np.flatnonzero((denom < tr) & (num < tr))\n        rat[ii] = 0\n        ratc = 1 - rat\n        ratc = np.clip(ratc, 1e-12, np.inf)\n        lrat = np.log(ratc)\n        prat = np.cumsum(lrat)[ie]\n        prat = np.exp(prat)\n        if freq_weights is None:\n            sprob += prat\n        else:\n            sprob += prat * freq_weights[i]\n    if freq_weights is None:\n        sprob /= n\n    return (sprob, utime)",
        "mutated": [
            "def _kernel_survfunc(time, status, exog, kfunc, freq_weights):\n    if False:\n        i = 10\n    '\\n    Estimate the marginal survival function under dependent censoring.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed times for each subject\\n    status : array_like\\n        The status for each subject (1 indicates event, 0 indicates\\n        censoring)\\n    exog : array_like\\n        Covariates such that censoring is independent conditional on\\n        exog\\n    kfunc : function\\n        Kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n\\n    Returns\\n    -------\\n    probs : array_like\\n        The estimated survival probabilities\\n    times : array_like\\n        The times at which the survival probabilities are estimated\\n\\n    References\\n    ----------\\n    Zeng, Donglin 2004. Estimating Marginal Survival Function by\\n    Adjusting for Dependent Censoring Using Many Covariates. The\\n    Annals of Statistics 32 (4): 1533 55.\\n    doi:10.1214/009053604000000508.\\n    https://arxiv.org/pdf/math/0409180.pdf\\n    '\n    sfe = PHReg(time, exog, status).fit()\n    fitval_e = sfe.predict().predicted_values\n    sfc = PHReg(time, exog, 1 - status).fit()\n    fitval_c = sfc.predict().predicted_values\n    exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n    n = len(time)\n    ixd = np.flatnonzero(status == 1)\n    utime = np.unique(time[ixd])\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog2d = exog2d[ii, :]\n    ie = np.searchsorted(time, utime, side='right') - 1\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    sprob = 0.0\n    for i in range(n):\n        kd = exog2d - exog2d[i, :]\n        kd = kfunc(kd)\n        denom = np.cumsum(kd[::-1])[::-1]\n        num = kd * status\n        rat = num / denom\n        tr = 1e-15\n        ii = np.flatnonzero((denom < tr) & (num < tr))\n        rat[ii] = 0\n        ratc = 1 - rat\n        ratc = np.clip(ratc, 1e-12, np.inf)\n        lrat = np.log(ratc)\n        prat = np.cumsum(lrat)[ie]\n        prat = np.exp(prat)\n        if freq_weights is None:\n            sprob += prat\n        else:\n            sprob += prat * freq_weights[i]\n    if freq_weights is None:\n        sprob /= n\n    return (sprob, utime)",
            "def _kernel_survfunc(time, status, exog, kfunc, freq_weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Estimate the marginal survival function under dependent censoring.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed times for each subject\\n    status : array_like\\n        The status for each subject (1 indicates event, 0 indicates\\n        censoring)\\n    exog : array_like\\n        Covariates such that censoring is independent conditional on\\n        exog\\n    kfunc : function\\n        Kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n\\n    Returns\\n    -------\\n    probs : array_like\\n        The estimated survival probabilities\\n    times : array_like\\n        The times at which the survival probabilities are estimated\\n\\n    References\\n    ----------\\n    Zeng, Donglin 2004. Estimating Marginal Survival Function by\\n    Adjusting for Dependent Censoring Using Many Covariates. The\\n    Annals of Statistics 32 (4): 1533 55.\\n    doi:10.1214/009053604000000508.\\n    https://arxiv.org/pdf/math/0409180.pdf\\n    '\n    sfe = PHReg(time, exog, status).fit()\n    fitval_e = sfe.predict().predicted_values\n    sfc = PHReg(time, exog, 1 - status).fit()\n    fitval_c = sfc.predict().predicted_values\n    exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n    n = len(time)\n    ixd = np.flatnonzero(status == 1)\n    utime = np.unique(time[ixd])\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog2d = exog2d[ii, :]\n    ie = np.searchsorted(time, utime, side='right') - 1\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    sprob = 0.0\n    for i in range(n):\n        kd = exog2d - exog2d[i, :]\n        kd = kfunc(kd)\n        denom = np.cumsum(kd[::-1])[::-1]\n        num = kd * status\n        rat = num / denom\n        tr = 1e-15\n        ii = np.flatnonzero((denom < tr) & (num < tr))\n        rat[ii] = 0\n        ratc = 1 - rat\n        ratc = np.clip(ratc, 1e-12, np.inf)\n        lrat = np.log(ratc)\n        prat = np.cumsum(lrat)[ie]\n        prat = np.exp(prat)\n        if freq_weights is None:\n            sprob += prat\n        else:\n            sprob += prat * freq_weights[i]\n    if freq_weights is None:\n        sprob /= n\n    return (sprob, utime)",
            "def _kernel_survfunc(time, status, exog, kfunc, freq_weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Estimate the marginal survival function under dependent censoring.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed times for each subject\\n    status : array_like\\n        The status for each subject (1 indicates event, 0 indicates\\n        censoring)\\n    exog : array_like\\n        Covariates such that censoring is independent conditional on\\n        exog\\n    kfunc : function\\n        Kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n\\n    Returns\\n    -------\\n    probs : array_like\\n        The estimated survival probabilities\\n    times : array_like\\n        The times at which the survival probabilities are estimated\\n\\n    References\\n    ----------\\n    Zeng, Donglin 2004. Estimating Marginal Survival Function by\\n    Adjusting for Dependent Censoring Using Many Covariates. The\\n    Annals of Statistics 32 (4): 1533 55.\\n    doi:10.1214/009053604000000508.\\n    https://arxiv.org/pdf/math/0409180.pdf\\n    '\n    sfe = PHReg(time, exog, status).fit()\n    fitval_e = sfe.predict().predicted_values\n    sfc = PHReg(time, exog, 1 - status).fit()\n    fitval_c = sfc.predict().predicted_values\n    exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n    n = len(time)\n    ixd = np.flatnonzero(status == 1)\n    utime = np.unique(time[ixd])\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog2d = exog2d[ii, :]\n    ie = np.searchsorted(time, utime, side='right') - 1\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    sprob = 0.0\n    for i in range(n):\n        kd = exog2d - exog2d[i, :]\n        kd = kfunc(kd)\n        denom = np.cumsum(kd[::-1])[::-1]\n        num = kd * status\n        rat = num / denom\n        tr = 1e-15\n        ii = np.flatnonzero((denom < tr) & (num < tr))\n        rat[ii] = 0\n        ratc = 1 - rat\n        ratc = np.clip(ratc, 1e-12, np.inf)\n        lrat = np.log(ratc)\n        prat = np.cumsum(lrat)[ie]\n        prat = np.exp(prat)\n        if freq_weights is None:\n            sprob += prat\n        else:\n            sprob += prat * freq_weights[i]\n    if freq_weights is None:\n        sprob /= n\n    return (sprob, utime)",
            "def _kernel_survfunc(time, status, exog, kfunc, freq_weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Estimate the marginal survival function under dependent censoring.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed times for each subject\\n    status : array_like\\n        The status for each subject (1 indicates event, 0 indicates\\n        censoring)\\n    exog : array_like\\n        Covariates such that censoring is independent conditional on\\n        exog\\n    kfunc : function\\n        Kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n\\n    Returns\\n    -------\\n    probs : array_like\\n        The estimated survival probabilities\\n    times : array_like\\n        The times at which the survival probabilities are estimated\\n\\n    References\\n    ----------\\n    Zeng, Donglin 2004. Estimating Marginal Survival Function by\\n    Adjusting for Dependent Censoring Using Many Covariates. The\\n    Annals of Statistics 32 (4): 1533 55.\\n    doi:10.1214/009053604000000508.\\n    https://arxiv.org/pdf/math/0409180.pdf\\n    '\n    sfe = PHReg(time, exog, status).fit()\n    fitval_e = sfe.predict().predicted_values\n    sfc = PHReg(time, exog, 1 - status).fit()\n    fitval_c = sfc.predict().predicted_values\n    exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n    n = len(time)\n    ixd = np.flatnonzero(status == 1)\n    utime = np.unique(time[ixd])\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog2d = exog2d[ii, :]\n    ie = np.searchsorted(time, utime, side='right') - 1\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    sprob = 0.0\n    for i in range(n):\n        kd = exog2d - exog2d[i, :]\n        kd = kfunc(kd)\n        denom = np.cumsum(kd[::-1])[::-1]\n        num = kd * status\n        rat = num / denom\n        tr = 1e-15\n        ii = np.flatnonzero((denom < tr) & (num < tr))\n        rat[ii] = 0\n        ratc = 1 - rat\n        ratc = np.clip(ratc, 1e-12, np.inf)\n        lrat = np.log(ratc)\n        prat = np.cumsum(lrat)[ie]\n        prat = np.exp(prat)\n        if freq_weights is None:\n            sprob += prat\n        else:\n            sprob += prat * freq_weights[i]\n    if freq_weights is None:\n        sprob /= n\n    return (sprob, utime)",
            "def _kernel_survfunc(time, status, exog, kfunc, freq_weights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Estimate the marginal survival function under dependent censoring.\\n\\n    Parameters\\n    ----------\\n    time : array_like\\n        The observed times for each subject\\n    status : array_like\\n        The status for each subject (1 indicates event, 0 indicates\\n        censoring)\\n    exog : array_like\\n        Covariates such that censoring is independent conditional on\\n        exog\\n    kfunc : function\\n        Kernel function\\n    freq_weights : array_like\\n        Optional frequency weights\\n\\n    Returns\\n    -------\\n    probs : array_like\\n        The estimated survival probabilities\\n    times : array_like\\n        The times at which the survival probabilities are estimated\\n\\n    References\\n    ----------\\n    Zeng, Donglin 2004. Estimating Marginal Survival Function by\\n    Adjusting for Dependent Censoring Using Many Covariates. The\\n    Annals of Statistics 32 (4): 1533 55.\\n    doi:10.1214/009053604000000508.\\n    https://arxiv.org/pdf/math/0409180.pdf\\n    '\n    sfe = PHReg(time, exog, status).fit()\n    fitval_e = sfe.predict().predicted_values\n    sfc = PHReg(time, exog, 1 - status).fit()\n    fitval_c = sfc.predict().predicted_values\n    exog2d = np.hstack((fitval_e[:, None], fitval_c[:, None]))\n    n = len(time)\n    ixd = np.flatnonzero(status == 1)\n    utime = np.unique(time[ixd])\n    ii = np.argsort(time)\n    time = time[ii]\n    status = status[ii]\n    exog2d = exog2d[ii, :]\n    ie = np.searchsorted(time, utime, side='right') - 1\n    if freq_weights is not None:\n        freq_weights = freq_weights / freq_weights.sum()\n    sprob = 0.0\n    for i in range(n):\n        kd = exog2d - exog2d[i, :]\n        kd = kfunc(kd)\n        denom = np.cumsum(kd[::-1])[::-1]\n        num = kd * status\n        rat = num / denom\n        tr = 1e-15\n        ii = np.flatnonzero((denom < tr) & (num < tr))\n        rat[ii] = 0\n        ratc = 1 - rat\n        ratc = np.clip(ratc, 1e-12, np.inf)\n        lrat = np.log(ratc)\n        prat = np.cumsum(lrat)[ie]\n        prat = np.exp(prat)\n        if freq_weights is None:\n            sprob += prat\n        else:\n            sprob += prat * freq_weights[i]\n    if freq_weights is None:\n        sprob /= n\n    return (sprob, utime)"
        ]
    }
]