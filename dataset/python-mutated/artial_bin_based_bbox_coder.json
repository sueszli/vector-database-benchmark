[
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True):\n    super(PartialBinBasedBBoxCoder, self).__init__()\n    assert len(mean_sizes) == num_sizes\n    self.num_dir_bins = num_dir_bins\n    self.num_sizes = num_sizes\n    self.mean_sizes = mean_sizes\n    self.with_rot = with_rot",
        "mutated": [
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True):\n    if False:\n        i = 10\n    super(PartialBinBasedBBoxCoder, self).__init__()\n    assert len(mean_sizes) == num_sizes\n    self.num_dir_bins = num_dir_bins\n    self.num_sizes = num_sizes\n    self.mean_sizes = mean_sizes\n    self.with_rot = with_rot",
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(PartialBinBasedBBoxCoder, self).__init__()\n    assert len(mean_sizes) == num_sizes\n    self.num_dir_bins = num_dir_bins\n    self.num_sizes = num_sizes\n    self.mean_sizes = mean_sizes\n    self.with_rot = with_rot",
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(PartialBinBasedBBoxCoder, self).__init__()\n    assert len(mean_sizes) == num_sizes\n    self.num_dir_bins = num_dir_bins\n    self.num_sizes = num_sizes\n    self.mean_sizes = mean_sizes\n    self.with_rot = with_rot",
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(PartialBinBasedBBoxCoder, self).__init__()\n    assert len(mean_sizes) == num_sizes\n    self.num_dir_bins = num_dir_bins\n    self.num_sizes = num_sizes\n    self.mean_sizes = mean_sizes\n    self.with_rot = with_rot",
            "def __init__(self, num_dir_bins, num_sizes, mean_sizes, with_rot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(PartialBinBasedBBoxCoder, self).__init__()\n    assert len(mean_sizes) == num_sizes\n    self.num_dir_bins = num_dir_bins\n    self.num_sizes = num_sizes\n    self.mean_sizes = mean_sizes\n    self.with_rot = with_rot"
        ]
    },
    {
        "func_name": "encode",
        "original": "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    \"\"\"Encode ground truth to prediction targets.\n\n        Args:\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\n                with shape (n, 7).\n            gt_labels_3d (torch.Tensor): Ground truth classes.\n\n        Returns:\n            tuple: Targets of center, size and direction.\n        \"\"\"\n    center_target = gt_bboxes_3d.gravity_center\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
        "mutated": [
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_class_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_class_target = gt_labels_3d\n    size_res_target = gt_bboxes_3d.dims - gt_bboxes_3d.tensor.new_tensor(self.mean_sizes)[size_class_target]\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_class_target, size_res_target, dir_class_target, dir_res_target)"
        ]
    },
    {
        "func_name": "decode",
        "original": "def decode(self, bbox_out, suffix=''):\n    \"\"\"Decode predicted parts to bbox3d.\n\n        Args:\n            bbox_out (dict): Predictions from model, should contain keys below.\n\n                - center: predicted bottom center of bboxes.\n                - dir_class: predicted bbox direction class.\n                - dir_res: predicted bbox direction residual.\n                - size_class: predicted bbox size class.\n                - size_res: predicted bbox size residual.\n            suffix (str): Decode predictions with specific suffix.\n\n        Returns:\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\n        \"\"\"\n    center = bbox_out['center' + suffix]\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class' + suffix], -1)\n        dir_res = torch.gather(bbox_out['dir_res' + suffix], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    size_class = torch.argmax(bbox_out['size_class' + suffix], -1, keepdim=True)\n    size_res = torch.gather(bbox_out['size_res' + suffix], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n    mean_sizes = center.new_tensor(self.mean_sizes)\n    size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n    bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
        "mutated": [
            "def decode(self, bbox_out, suffix=''):\n    if False:\n        i = 10\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n            suffix (str): Decode predictions with specific suffix.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center' + suffix]\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class' + suffix], -1)\n        dir_res = torch.gather(bbox_out['dir_res' + suffix], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    size_class = torch.argmax(bbox_out['size_class' + suffix], -1, keepdim=True)\n    size_res = torch.gather(bbox_out['size_res' + suffix], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n    mean_sizes = center.new_tensor(self.mean_sizes)\n    size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n    bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out, suffix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n            suffix (str): Decode predictions with specific suffix.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center' + suffix]\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class' + suffix], -1)\n        dir_res = torch.gather(bbox_out['dir_res' + suffix], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    size_class = torch.argmax(bbox_out['size_class' + suffix], -1, keepdim=True)\n    size_res = torch.gather(bbox_out['size_res' + suffix], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n    mean_sizes = center.new_tensor(self.mean_sizes)\n    size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n    bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out, suffix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n            suffix (str): Decode predictions with specific suffix.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center' + suffix]\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class' + suffix], -1)\n        dir_res = torch.gather(bbox_out['dir_res' + suffix], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    size_class = torch.argmax(bbox_out['size_class' + suffix], -1, keepdim=True)\n    size_res = torch.gather(bbox_out['size_res' + suffix], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n    mean_sizes = center.new_tensor(self.mean_sizes)\n    size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n    bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out, suffix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n            suffix (str): Decode predictions with specific suffix.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center' + suffix]\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class' + suffix], -1)\n        dir_res = torch.gather(bbox_out['dir_res' + suffix], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    size_class = torch.argmax(bbox_out['size_class' + suffix], -1, keepdim=True)\n    size_res = torch.gather(bbox_out['size_res' + suffix], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n    mean_sizes = center.new_tensor(self.mean_sizes)\n    size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n    bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out, suffix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size_class: predicted bbox size class.\\n                - size_res: predicted bbox size residual.\\n            suffix (str): Decode predictions with specific suffix.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center' + suffix]\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class' + suffix], -1)\n        dir_res = torch.gather(bbox_out['dir_res' + suffix], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    size_class = torch.argmax(bbox_out['size_class' + suffix], -1, keepdim=True)\n    size_res = torch.gather(bbox_out['size_res' + suffix], 2, size_class.unsqueeze(-1).repeat(1, 1, 1, 3))\n    mean_sizes = center.new_tensor(self.mean_sizes)\n    size_base = torch.index_select(mean_sizes, 0, size_class.reshape(-1))\n    bbox_size = size_base.reshape(batch_size, num_proposal, -1) + size_res.squeeze(2)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d"
        ]
    },
    {
        "func_name": "decode_corners",
        "original": "def decode_corners(self, center, size_res, size_class):\n    \"\"\"Decode center, size residuals and class to corners. Only useful for\n        axis-aligned bounding boxes, so angle isn't considered.\n\n        Args:\n            center (torch.Tensor): Shape [B, N, 3]\n            size_res (torch.Tensor): Shape [B, N, 3] or [B, N, C, 3]\n            size_class (torch.Tensor): Shape: [B, N] or [B, N, 1]\n            or [B, N, C, 3]\n\n        Returns:\n            torch.Tensor: Corners with shape [B, N, 6]\n        \"\"\"\n    if len(size_class.shape) == 2 or size_class.shape[-1] == 1:\n        (batch_size, proposal_num) = size_class.shape[:2]\n        one_hot_size_class = size_res.new_zeros((batch_size, proposal_num, self.num_sizes))\n        if len(size_class.shape) == 2:\n            size_class = size_class.unsqueeze(-1)\n        one_hot_size_class.scatter_(2, size_class, 1)\n        one_hot_size_class_expand = one_hot_size_class.unsqueeze(-1).repeat(1, 1, 1, 3).contiguous()\n    else:\n        one_hot_size_class_expand = size_class\n    if len(size_res.shape) == 4:\n        size_res = torch.sum(size_res * one_hot_size_class_expand, 2)\n    mean_sizes = size_res.new_tensor(self.mean_sizes)\n    mean_sizes = torch.sum(mean_sizes * one_hot_size_class_expand, 2)\n    size_full = (size_res + 1) * mean_sizes\n    size_full = torch.clamp(size_full, 0)\n    half_size_full = size_full / 2\n    corner1 = center - half_size_full\n    corner2 = center + half_size_full\n    corners = torch.cat([corner1, corner2], dim=-1)\n    return corners",
        "mutated": [
            "def decode_corners(self, center, size_res, size_class):\n    if False:\n        i = 10\n    \"Decode center, size residuals and class to corners. Only useful for\\n        axis-aligned bounding boxes, so angle isn't considered.\\n\\n        Args:\\n            center (torch.Tensor): Shape [B, N, 3]\\n            size_res (torch.Tensor): Shape [B, N, 3] or [B, N, C, 3]\\n            size_class (torch.Tensor): Shape: [B, N] or [B, N, 1]\\n            or [B, N, C, 3]\\n\\n        Returns:\\n            torch.Tensor: Corners with shape [B, N, 6]\\n        \"\n    if len(size_class.shape) == 2 or size_class.shape[-1] == 1:\n        (batch_size, proposal_num) = size_class.shape[:2]\n        one_hot_size_class = size_res.new_zeros((batch_size, proposal_num, self.num_sizes))\n        if len(size_class.shape) == 2:\n            size_class = size_class.unsqueeze(-1)\n        one_hot_size_class.scatter_(2, size_class, 1)\n        one_hot_size_class_expand = one_hot_size_class.unsqueeze(-1).repeat(1, 1, 1, 3).contiguous()\n    else:\n        one_hot_size_class_expand = size_class\n    if len(size_res.shape) == 4:\n        size_res = torch.sum(size_res * one_hot_size_class_expand, 2)\n    mean_sizes = size_res.new_tensor(self.mean_sizes)\n    mean_sizes = torch.sum(mean_sizes * one_hot_size_class_expand, 2)\n    size_full = (size_res + 1) * mean_sizes\n    size_full = torch.clamp(size_full, 0)\n    half_size_full = size_full / 2\n    corner1 = center - half_size_full\n    corner2 = center + half_size_full\n    corners = torch.cat([corner1, corner2], dim=-1)\n    return corners",
            "def decode_corners(self, center, size_res, size_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Decode center, size residuals and class to corners. Only useful for\\n        axis-aligned bounding boxes, so angle isn't considered.\\n\\n        Args:\\n            center (torch.Tensor): Shape [B, N, 3]\\n            size_res (torch.Tensor): Shape [B, N, 3] or [B, N, C, 3]\\n            size_class (torch.Tensor): Shape: [B, N] or [B, N, 1]\\n            or [B, N, C, 3]\\n\\n        Returns:\\n            torch.Tensor: Corners with shape [B, N, 6]\\n        \"\n    if len(size_class.shape) == 2 or size_class.shape[-1] == 1:\n        (batch_size, proposal_num) = size_class.shape[:2]\n        one_hot_size_class = size_res.new_zeros((batch_size, proposal_num, self.num_sizes))\n        if len(size_class.shape) == 2:\n            size_class = size_class.unsqueeze(-1)\n        one_hot_size_class.scatter_(2, size_class, 1)\n        one_hot_size_class_expand = one_hot_size_class.unsqueeze(-1).repeat(1, 1, 1, 3).contiguous()\n    else:\n        one_hot_size_class_expand = size_class\n    if len(size_res.shape) == 4:\n        size_res = torch.sum(size_res * one_hot_size_class_expand, 2)\n    mean_sizes = size_res.new_tensor(self.mean_sizes)\n    mean_sizes = torch.sum(mean_sizes * one_hot_size_class_expand, 2)\n    size_full = (size_res + 1) * mean_sizes\n    size_full = torch.clamp(size_full, 0)\n    half_size_full = size_full / 2\n    corner1 = center - half_size_full\n    corner2 = center + half_size_full\n    corners = torch.cat([corner1, corner2], dim=-1)\n    return corners",
            "def decode_corners(self, center, size_res, size_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Decode center, size residuals and class to corners. Only useful for\\n        axis-aligned bounding boxes, so angle isn't considered.\\n\\n        Args:\\n            center (torch.Tensor): Shape [B, N, 3]\\n            size_res (torch.Tensor): Shape [B, N, 3] or [B, N, C, 3]\\n            size_class (torch.Tensor): Shape: [B, N] or [B, N, 1]\\n            or [B, N, C, 3]\\n\\n        Returns:\\n            torch.Tensor: Corners with shape [B, N, 6]\\n        \"\n    if len(size_class.shape) == 2 or size_class.shape[-1] == 1:\n        (batch_size, proposal_num) = size_class.shape[:2]\n        one_hot_size_class = size_res.new_zeros((batch_size, proposal_num, self.num_sizes))\n        if len(size_class.shape) == 2:\n            size_class = size_class.unsqueeze(-1)\n        one_hot_size_class.scatter_(2, size_class, 1)\n        one_hot_size_class_expand = one_hot_size_class.unsqueeze(-1).repeat(1, 1, 1, 3).contiguous()\n    else:\n        one_hot_size_class_expand = size_class\n    if len(size_res.shape) == 4:\n        size_res = torch.sum(size_res * one_hot_size_class_expand, 2)\n    mean_sizes = size_res.new_tensor(self.mean_sizes)\n    mean_sizes = torch.sum(mean_sizes * one_hot_size_class_expand, 2)\n    size_full = (size_res + 1) * mean_sizes\n    size_full = torch.clamp(size_full, 0)\n    half_size_full = size_full / 2\n    corner1 = center - half_size_full\n    corner2 = center + half_size_full\n    corners = torch.cat([corner1, corner2], dim=-1)\n    return corners",
            "def decode_corners(self, center, size_res, size_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Decode center, size residuals and class to corners. Only useful for\\n        axis-aligned bounding boxes, so angle isn't considered.\\n\\n        Args:\\n            center (torch.Tensor): Shape [B, N, 3]\\n            size_res (torch.Tensor): Shape [B, N, 3] or [B, N, C, 3]\\n            size_class (torch.Tensor): Shape: [B, N] or [B, N, 1]\\n            or [B, N, C, 3]\\n\\n        Returns:\\n            torch.Tensor: Corners with shape [B, N, 6]\\n        \"\n    if len(size_class.shape) == 2 or size_class.shape[-1] == 1:\n        (batch_size, proposal_num) = size_class.shape[:2]\n        one_hot_size_class = size_res.new_zeros((batch_size, proposal_num, self.num_sizes))\n        if len(size_class.shape) == 2:\n            size_class = size_class.unsqueeze(-1)\n        one_hot_size_class.scatter_(2, size_class, 1)\n        one_hot_size_class_expand = one_hot_size_class.unsqueeze(-1).repeat(1, 1, 1, 3).contiguous()\n    else:\n        one_hot_size_class_expand = size_class\n    if len(size_res.shape) == 4:\n        size_res = torch.sum(size_res * one_hot_size_class_expand, 2)\n    mean_sizes = size_res.new_tensor(self.mean_sizes)\n    mean_sizes = torch.sum(mean_sizes * one_hot_size_class_expand, 2)\n    size_full = (size_res + 1) * mean_sizes\n    size_full = torch.clamp(size_full, 0)\n    half_size_full = size_full / 2\n    corner1 = center - half_size_full\n    corner2 = center + half_size_full\n    corners = torch.cat([corner1, corner2], dim=-1)\n    return corners",
            "def decode_corners(self, center, size_res, size_class):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Decode center, size residuals and class to corners. Only useful for\\n        axis-aligned bounding boxes, so angle isn't considered.\\n\\n        Args:\\n            center (torch.Tensor): Shape [B, N, 3]\\n            size_res (torch.Tensor): Shape [B, N, 3] or [B, N, C, 3]\\n            size_class (torch.Tensor): Shape: [B, N] or [B, N, 1]\\n            or [B, N, C, 3]\\n\\n        Returns:\\n            torch.Tensor: Corners with shape [B, N, 6]\\n        \"\n    if len(size_class.shape) == 2 or size_class.shape[-1] == 1:\n        (batch_size, proposal_num) = size_class.shape[:2]\n        one_hot_size_class = size_res.new_zeros((batch_size, proposal_num, self.num_sizes))\n        if len(size_class.shape) == 2:\n            size_class = size_class.unsqueeze(-1)\n        one_hot_size_class.scatter_(2, size_class, 1)\n        one_hot_size_class_expand = one_hot_size_class.unsqueeze(-1).repeat(1, 1, 1, 3).contiguous()\n    else:\n        one_hot_size_class_expand = size_class\n    if len(size_res.shape) == 4:\n        size_res = torch.sum(size_res * one_hot_size_class_expand, 2)\n    mean_sizes = size_res.new_tensor(self.mean_sizes)\n    mean_sizes = torch.sum(mean_sizes * one_hot_size_class_expand, 2)\n    size_full = (size_res + 1) * mean_sizes\n    size_full = torch.clamp(size_full, 0)\n    half_size_full = size_full / 2\n    corner1 = center - half_size_full\n    corner2 = center + half_size_full\n    corners = torch.cat([corner1, corner2], dim=-1)\n    return corners"
        ]
    },
    {
        "func_name": "split_pred",
        "original": "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    \"\"\"Split predicted features to specific parts.\n\n        Args:\n            cls_preds (torch.Tensor): Class predicted features to split.\n            reg_preds (torch.Tensor): Regression predicted features to split.\n            base_xyz (torch.Tensor): Coordinates of points.\n\n        Returns:\n            dict[str, torch.Tensor]: Split results.\n        \"\"\"\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    end += self.num_sizes\n    results['size_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_sizes * 3\n    size_res_norm = reg_preds_trans[..., start:end]\n    (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n    size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n    start = end\n    results['size_res_norm'] = size_res_norm.contiguous()\n    mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n    results['size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    start = 0\n    end = 2\n    results['obj_scores'] = cls_preds_trans[..., start:end].contiguous()\n    start = end\n    results['sem_scores'] = cls_preds_trans[..., start:].contiguous()\n    return results",
        "mutated": [
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    end += self.num_sizes\n    results['size_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_sizes * 3\n    size_res_norm = reg_preds_trans[..., start:end]\n    (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n    size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n    start = end\n    results['size_res_norm'] = size_res_norm.contiguous()\n    mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n    results['size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    start = 0\n    end = 2\n    results['obj_scores'] = cls_preds_trans[..., start:end].contiguous()\n    start = end\n    results['sem_scores'] = cls_preds_trans[..., start:].contiguous()\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    end += self.num_sizes\n    results['size_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_sizes * 3\n    size_res_norm = reg_preds_trans[..., start:end]\n    (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n    size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n    start = end\n    results['size_res_norm'] = size_res_norm.contiguous()\n    mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n    results['size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    start = 0\n    end = 2\n    results['obj_scores'] = cls_preds_trans[..., start:end].contiguous()\n    start = end\n    results['sem_scores'] = cls_preds_trans[..., start:].contiguous()\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    end += self.num_sizes\n    results['size_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_sizes * 3\n    size_res_norm = reg_preds_trans[..., start:end]\n    (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n    size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n    start = end\n    results['size_res_norm'] = size_res_norm.contiguous()\n    mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n    results['size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    start = 0\n    end = 2\n    results['obj_scores'] = cls_preds_trans[..., start:end].contiguous()\n    start = end\n    results['sem_scores'] = cls_preds_trans[..., start:].contiguous()\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    end += self.num_sizes\n    results['size_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_sizes * 3\n    size_res_norm = reg_preds_trans[..., start:end]\n    (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n    size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n    start = end\n    results['size_res_norm'] = size_res_norm.contiguous()\n    mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n    results['size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    start = 0\n    end = 2\n    results['obj_scores'] = cls_preds_trans[..., start:end].contiguous()\n    start = end\n    results['sem_scores'] = cls_preds_trans[..., start:].contiguous()\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    (start, end) = (0, 0)\n    cls_preds_trans = cls_preds.transpose(2, 1)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center'] = base_xyz + reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (np.pi / self.num_dir_bins)\n    end += self.num_sizes\n    results['size_class'] = reg_preds_trans[..., start:end].contiguous()\n    start = end\n    end += self.num_sizes * 3\n    size_res_norm = reg_preds_trans[..., start:end]\n    (batch_size, num_proposal) = reg_preds_trans.shape[:2]\n    size_res_norm = size_res_norm.view([batch_size, num_proposal, self.num_sizes, 3])\n    start = end\n    results['size_res_norm'] = size_res_norm.contiguous()\n    mean_sizes = reg_preds.new_tensor(self.mean_sizes)\n    results['size_res'] = size_res_norm * mean_sizes.unsqueeze(0).unsqueeze(0)\n    start = 0\n    end = 2\n    results['obj_scores'] = cls_preds_trans[..., start:end].contiguous()\n    start = end\n    results['sem_scores'] = cls_preds_trans[..., start:].contiguous()\n    return results"
        ]
    },
    {
        "func_name": "angle2class",
        "original": "def angle2class(self, angle):\n    \"\"\"Convert continuous angle to a discrete class and a residual.\n\n        Convert continuous angle to a discrete class and a small\n        regression number from class center angle to current angle.\n\n        Args:\n            angle (torch.Tensor): Angle is from 0-2pi (or -pi~pi),\n                class center at 0, 1*(2pi/N), 2*(2pi/N) ...  (N-1)*(2pi/N).\n\n        Returns:\n            tuple: Encoded discrete class and residual.\n        \"\"\"\n    angle = angle % (2 * np.pi)\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    shifted_angle = (angle + angle_per_class / 2) % (2 * np.pi)\n    angle_cls = shifted_angle // angle_per_class\n    angle_res = shifted_angle - (angle_cls * angle_per_class + angle_per_class / 2)\n    return (angle_cls.long(), angle_res)",
        "mutated": [
            "def angle2class(self, angle):\n    if False:\n        i = 10\n    'Convert continuous angle to a discrete class and a residual.\\n\\n        Convert continuous angle to a discrete class and a small\\n        regression number from class center angle to current angle.\\n\\n        Args:\\n            angle (torch.Tensor): Angle is from 0-2pi (or -pi~pi),\\n                class center at 0, 1*(2pi/N), 2*(2pi/N) ...  (N-1)*(2pi/N).\\n\\n        Returns:\\n            tuple: Encoded discrete class and residual.\\n        '\n    angle = angle % (2 * np.pi)\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    shifted_angle = (angle + angle_per_class / 2) % (2 * np.pi)\n    angle_cls = shifted_angle // angle_per_class\n    angle_res = shifted_angle - (angle_cls * angle_per_class + angle_per_class / 2)\n    return (angle_cls.long(), angle_res)",
            "def angle2class(self, angle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert continuous angle to a discrete class and a residual.\\n\\n        Convert continuous angle to a discrete class and a small\\n        regression number from class center angle to current angle.\\n\\n        Args:\\n            angle (torch.Tensor): Angle is from 0-2pi (or -pi~pi),\\n                class center at 0, 1*(2pi/N), 2*(2pi/N) ...  (N-1)*(2pi/N).\\n\\n        Returns:\\n            tuple: Encoded discrete class and residual.\\n        '\n    angle = angle % (2 * np.pi)\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    shifted_angle = (angle + angle_per_class / 2) % (2 * np.pi)\n    angle_cls = shifted_angle // angle_per_class\n    angle_res = shifted_angle - (angle_cls * angle_per_class + angle_per_class / 2)\n    return (angle_cls.long(), angle_res)",
            "def angle2class(self, angle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert continuous angle to a discrete class and a residual.\\n\\n        Convert continuous angle to a discrete class and a small\\n        regression number from class center angle to current angle.\\n\\n        Args:\\n            angle (torch.Tensor): Angle is from 0-2pi (or -pi~pi),\\n                class center at 0, 1*(2pi/N), 2*(2pi/N) ...  (N-1)*(2pi/N).\\n\\n        Returns:\\n            tuple: Encoded discrete class and residual.\\n        '\n    angle = angle % (2 * np.pi)\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    shifted_angle = (angle + angle_per_class / 2) % (2 * np.pi)\n    angle_cls = shifted_angle // angle_per_class\n    angle_res = shifted_angle - (angle_cls * angle_per_class + angle_per_class / 2)\n    return (angle_cls.long(), angle_res)",
            "def angle2class(self, angle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert continuous angle to a discrete class and a residual.\\n\\n        Convert continuous angle to a discrete class and a small\\n        regression number from class center angle to current angle.\\n\\n        Args:\\n            angle (torch.Tensor): Angle is from 0-2pi (or -pi~pi),\\n                class center at 0, 1*(2pi/N), 2*(2pi/N) ...  (N-1)*(2pi/N).\\n\\n        Returns:\\n            tuple: Encoded discrete class and residual.\\n        '\n    angle = angle % (2 * np.pi)\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    shifted_angle = (angle + angle_per_class / 2) % (2 * np.pi)\n    angle_cls = shifted_angle // angle_per_class\n    angle_res = shifted_angle - (angle_cls * angle_per_class + angle_per_class / 2)\n    return (angle_cls.long(), angle_res)",
            "def angle2class(self, angle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert continuous angle to a discrete class and a residual.\\n\\n        Convert continuous angle to a discrete class and a small\\n        regression number from class center angle to current angle.\\n\\n        Args:\\n            angle (torch.Tensor): Angle is from 0-2pi (or -pi~pi),\\n                class center at 0, 1*(2pi/N), 2*(2pi/N) ...  (N-1)*(2pi/N).\\n\\n        Returns:\\n            tuple: Encoded discrete class and residual.\\n        '\n    angle = angle % (2 * np.pi)\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    shifted_angle = (angle + angle_per_class / 2) % (2 * np.pi)\n    angle_cls = shifted_angle // angle_per_class\n    angle_res = shifted_angle - (angle_cls * angle_per_class + angle_per_class / 2)\n    return (angle_cls.long(), angle_res)"
        ]
    },
    {
        "func_name": "class2angle",
        "original": "def class2angle(self, angle_cls, angle_res, limit_period=True):\n    \"\"\"Inverse function to angle2class.\n\n        Args:\n            angle_cls (torch.Tensor): Angle class to decode.\n            angle_res (torch.Tensor): Angle residual to decode.\n            limit_period (bool): Whether to limit angle to [-pi, pi].\n\n        Returns:\n            torch.Tensor: Angle decoded from angle_cls and angle_res.\n        \"\"\"\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    angle_center = angle_cls.float() * angle_per_class\n    angle = angle_center + angle_res\n    if limit_period:\n        angle[angle > np.pi] -= 2 * np.pi\n    return angle",
        "mutated": [
            "def class2angle(self, angle_cls, angle_res, limit_period=True):\n    if False:\n        i = 10\n    'Inverse function to angle2class.\\n\\n        Args:\\n            angle_cls (torch.Tensor): Angle class to decode.\\n            angle_res (torch.Tensor): Angle residual to decode.\\n            limit_period (bool): Whether to limit angle to [-pi, pi].\\n\\n        Returns:\\n            torch.Tensor: Angle decoded from angle_cls and angle_res.\\n        '\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    angle_center = angle_cls.float() * angle_per_class\n    angle = angle_center + angle_res\n    if limit_period:\n        angle[angle > np.pi] -= 2 * np.pi\n    return angle",
            "def class2angle(self, angle_cls, angle_res, limit_period=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Inverse function to angle2class.\\n\\n        Args:\\n            angle_cls (torch.Tensor): Angle class to decode.\\n            angle_res (torch.Tensor): Angle residual to decode.\\n            limit_period (bool): Whether to limit angle to [-pi, pi].\\n\\n        Returns:\\n            torch.Tensor: Angle decoded from angle_cls and angle_res.\\n        '\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    angle_center = angle_cls.float() * angle_per_class\n    angle = angle_center + angle_res\n    if limit_period:\n        angle[angle > np.pi] -= 2 * np.pi\n    return angle",
            "def class2angle(self, angle_cls, angle_res, limit_period=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Inverse function to angle2class.\\n\\n        Args:\\n            angle_cls (torch.Tensor): Angle class to decode.\\n            angle_res (torch.Tensor): Angle residual to decode.\\n            limit_period (bool): Whether to limit angle to [-pi, pi].\\n\\n        Returns:\\n            torch.Tensor: Angle decoded from angle_cls and angle_res.\\n        '\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    angle_center = angle_cls.float() * angle_per_class\n    angle = angle_center + angle_res\n    if limit_period:\n        angle[angle > np.pi] -= 2 * np.pi\n    return angle",
            "def class2angle(self, angle_cls, angle_res, limit_period=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Inverse function to angle2class.\\n\\n        Args:\\n            angle_cls (torch.Tensor): Angle class to decode.\\n            angle_res (torch.Tensor): Angle residual to decode.\\n            limit_period (bool): Whether to limit angle to [-pi, pi].\\n\\n        Returns:\\n            torch.Tensor: Angle decoded from angle_cls and angle_res.\\n        '\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    angle_center = angle_cls.float() * angle_per_class\n    angle = angle_center + angle_res\n    if limit_period:\n        angle[angle > np.pi] -= 2 * np.pi\n    return angle",
            "def class2angle(self, angle_cls, angle_res, limit_period=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Inverse function to angle2class.\\n\\n        Args:\\n            angle_cls (torch.Tensor): Angle class to decode.\\n            angle_res (torch.Tensor): Angle residual to decode.\\n            limit_period (bool): Whether to limit angle to [-pi, pi].\\n\\n        Returns:\\n            torch.Tensor: Angle decoded from angle_cls and angle_res.\\n        '\n    angle_per_class = 2 * np.pi / float(self.num_dir_bins)\n    angle_center = angle_cls.float() * angle_per_class\n    angle = angle_center + angle_res\n    if limit_period:\n        angle[angle > np.pi] -= 2 * np.pi\n    return angle"
        ]
    }
]