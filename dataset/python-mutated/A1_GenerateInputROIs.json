[
    {
        "func_name": "generate_input_rois",
        "original": "def generate_input_rois(testing=False):\n    p = PARAMETERS.get_parameters_for_dataset()\n    if not p.datasetName.startswith('pascalVoc'):\n        makeDirectory(p.roiDir)\n        roi_minDim = p.roi_minDimRel * p.roi_maxImgDim\n        roi_maxDim = p.roi_maxDimRel * p.roi_maxImgDim\n        roi_minNrPixels = p.roi_minNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        roi_maxNrPixels = p.roi_maxNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        for subdir in subDirs:\n            makeDirectory(os.path.join(p.roiDir, subdir))\n            imgFilenames = getFilesInDirectory(os.path.join(p.imgDir, subdir), '.jpg')\n            for (imgIndex, imgFilename) in enumerate(imgFilenames):\n                roiPath = '{}/{}/{}.roi.txt'.format(p.roiDir, subdir, imgFilename[:-4])\n                print(imgIndex, len(imgFilenames), subdir, imgFilename)\n                tstart = datetime.datetime.now()\n                imgPath = os.path.join(p.imgDir, subdir, imgFilename)\n                imgOrig = imread(imgPath)\n                if imWidth(imgPath) > imHeight(imgPath):\n                    print(imWidth(imgPath), imHeight(imgPath))\n                if boAddSelectiveSearchROIs:\n                    print('Calling selective search..')\n                    (rects, img, scale) = getSelectiveSearchRois(imgOrig, p.ss_scale, p.ss_sigma, p.ss_minSize, p.roi_maxImgDim)\n                    print('   Number of rois detected using selective search: ' + str(len(rects)))\n                else:\n                    rects = []\n                    (img, scale) = imresizeMaxDim(imgOrig, p.roi_maxImgDim, boUpscale=True, interpolation=cv2.INTER_AREA)\n                (imgWidth, imgHeight) = imArrayWidthHeight(img)\n                if boAddRoisOnGrid:\n                    rectsGrid = getGridRois(imgWidth, imgHeight, p.grid_nrScales, p.grid_aspectRatios)\n                    print('   Number of rois on grid added: ' + str(len(rectsGrid)))\n                    rects += rectsGrid\n                print('   Number of rectangles before filtering  = ' + str(len(rects)))\n                rois = filterRois(rects, imgWidth, imgHeight, roi_minNrPixels, roi_maxNrPixels, roi_minDim, roi_maxDim, p.roi_maxAspectRatio)\n                if len(rois) == 0:\n                    rois = [[5, 5, imgWidth - 5, imgHeight - 5]]\n                print('   Number of rectangles after filtering  = ' + str(len(rois)))\n                rois = np.int32(np.array(rois) / scale)\n                assert np.min(rois) >= 0\n                assert np.max(rois[:, [0, 2]]) < imArrayWidth(imgOrig)\n                assert np.max(rois[:, [1, 3]]) < imArrayHeight(imgOrig)\n                np.savetxt(roiPath, rois, fmt='%d')\n                print('   Time [ms]: ' + str((datetime.datetime.now() - tstart).total_seconds() * 1000))\n    if os.path.exists(p.cntkFilesDir):\n        assert p.cntkFilesDir.endswith('cntkFiles')\n        if not testing:\n            userInput = input('--> INPUT: Press \"y\" to delete directory ' + p.cntkFilesDir + ': ')\n            if userInput.lower() not in ['y', 'yes']:\n                print('User input is %s: exiting now.' % userInput)\n                exit(-1)\n        shutil.rmtree(p.cntkFilesDir)\n        time.sleep(0.1)\n    for image_set in image_sets:\n        imdb = p.imdbs[image_set]\n        print('Number of images in set {} = {}'.format(image_set, imdb.num_images))\n        makeDirectory(p.cntkFilesDir)\n        (cntkImgsPath, cntkRoiCoordsPath, cntkRoiLabelsPath, nrRoisPath) = getCntkInputPaths(p.cntkFilesDir, image_set)\n        with open(nrRoisPath, 'w') as nrRoisFile, open(cntkImgsPath, 'w') as cntkImgsFile, open(cntkRoiCoordsPath, 'w') as cntkRoiCoordsFile, open(cntkRoiLabelsPath, 'w') as cntkRoiLabelsFile:\n            for imgIndex in range(0, imdb.num_images):\n                if imgIndex % 50 == 0:\n                    print(\"Processing image set '{}', image {} of {}\".format(image_set, imgIndex, imdb.num_images))\n                currBoxes = imdb.roidb[imgIndex]['boxes']\n                currGtOverlaps = imdb.roidb[imgIndex]['gt_overlaps']\n                imgPath = imdb.image_path_at(imgIndex)\n                (imgWidth, imgHeight) = imWidthHeight(imgPath)\n                (targetw, targeth, w_offset, h_offset, scale) = roiTransformPadScaleParams(imgWidth, imgHeight, p.cntk_padWidth, p.cntk_padHeight)\n                boxesStr = ''\n                labelsStr = ''\n                nrBoxes = len(currBoxes)\n                for (boxIndex, box) in enumerate(currBoxes):\n                    rect = roiTransformPadScale(box, w_offset, h_offset, scale)\n                    boxesStr += getCntkRoiCoordsLine(rect, p.cntk_padWidth, p.cntk_padHeight)\n                    labelsStr += getCntkRoiLabelsLine(currGtOverlaps[boxIndex, :].toarray()[0], p.train_posOverlapThres, p.nrClasses)\n                (boxesStr, labelsStr) = cntkPadInputs(nrBoxes, p.cntk_nrRois, p.nrClasses, boxesStr, labelsStr)\n                nrRoisFile.write('{}\\n'.format(nrBoxes))\n                cntkImgsFile.write('{}\\t{}\\t0\\n'.format(imgIndex, imgPath))\n                cntkRoiCoordsFile.write('{} |rois{}\\n'.format(imgIndex, boxesStr))\n                cntkRoiLabelsFile.write('{} |roiLabels{}\\n'.format(imgIndex, labelsStr))\n    print('DONE.')\n    return True",
        "mutated": [
            "def generate_input_rois(testing=False):\n    if False:\n        i = 10\n    p = PARAMETERS.get_parameters_for_dataset()\n    if not p.datasetName.startswith('pascalVoc'):\n        makeDirectory(p.roiDir)\n        roi_minDim = p.roi_minDimRel * p.roi_maxImgDim\n        roi_maxDim = p.roi_maxDimRel * p.roi_maxImgDim\n        roi_minNrPixels = p.roi_minNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        roi_maxNrPixels = p.roi_maxNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        for subdir in subDirs:\n            makeDirectory(os.path.join(p.roiDir, subdir))\n            imgFilenames = getFilesInDirectory(os.path.join(p.imgDir, subdir), '.jpg')\n            for (imgIndex, imgFilename) in enumerate(imgFilenames):\n                roiPath = '{}/{}/{}.roi.txt'.format(p.roiDir, subdir, imgFilename[:-4])\n                print(imgIndex, len(imgFilenames), subdir, imgFilename)\n                tstart = datetime.datetime.now()\n                imgPath = os.path.join(p.imgDir, subdir, imgFilename)\n                imgOrig = imread(imgPath)\n                if imWidth(imgPath) > imHeight(imgPath):\n                    print(imWidth(imgPath), imHeight(imgPath))\n                if boAddSelectiveSearchROIs:\n                    print('Calling selective search..')\n                    (rects, img, scale) = getSelectiveSearchRois(imgOrig, p.ss_scale, p.ss_sigma, p.ss_minSize, p.roi_maxImgDim)\n                    print('   Number of rois detected using selective search: ' + str(len(rects)))\n                else:\n                    rects = []\n                    (img, scale) = imresizeMaxDim(imgOrig, p.roi_maxImgDim, boUpscale=True, interpolation=cv2.INTER_AREA)\n                (imgWidth, imgHeight) = imArrayWidthHeight(img)\n                if boAddRoisOnGrid:\n                    rectsGrid = getGridRois(imgWidth, imgHeight, p.grid_nrScales, p.grid_aspectRatios)\n                    print('   Number of rois on grid added: ' + str(len(rectsGrid)))\n                    rects += rectsGrid\n                print('   Number of rectangles before filtering  = ' + str(len(rects)))\n                rois = filterRois(rects, imgWidth, imgHeight, roi_minNrPixels, roi_maxNrPixels, roi_minDim, roi_maxDim, p.roi_maxAspectRatio)\n                if len(rois) == 0:\n                    rois = [[5, 5, imgWidth - 5, imgHeight - 5]]\n                print('   Number of rectangles after filtering  = ' + str(len(rois)))\n                rois = np.int32(np.array(rois) / scale)\n                assert np.min(rois) >= 0\n                assert np.max(rois[:, [0, 2]]) < imArrayWidth(imgOrig)\n                assert np.max(rois[:, [1, 3]]) < imArrayHeight(imgOrig)\n                np.savetxt(roiPath, rois, fmt='%d')\n                print('   Time [ms]: ' + str((datetime.datetime.now() - tstart).total_seconds() * 1000))\n    if os.path.exists(p.cntkFilesDir):\n        assert p.cntkFilesDir.endswith('cntkFiles')\n        if not testing:\n            userInput = input('--> INPUT: Press \"y\" to delete directory ' + p.cntkFilesDir + ': ')\n            if userInput.lower() not in ['y', 'yes']:\n                print('User input is %s: exiting now.' % userInput)\n                exit(-1)\n        shutil.rmtree(p.cntkFilesDir)\n        time.sleep(0.1)\n    for image_set in image_sets:\n        imdb = p.imdbs[image_set]\n        print('Number of images in set {} = {}'.format(image_set, imdb.num_images))\n        makeDirectory(p.cntkFilesDir)\n        (cntkImgsPath, cntkRoiCoordsPath, cntkRoiLabelsPath, nrRoisPath) = getCntkInputPaths(p.cntkFilesDir, image_set)\n        with open(nrRoisPath, 'w') as nrRoisFile, open(cntkImgsPath, 'w') as cntkImgsFile, open(cntkRoiCoordsPath, 'w') as cntkRoiCoordsFile, open(cntkRoiLabelsPath, 'w') as cntkRoiLabelsFile:\n            for imgIndex in range(0, imdb.num_images):\n                if imgIndex % 50 == 0:\n                    print(\"Processing image set '{}', image {} of {}\".format(image_set, imgIndex, imdb.num_images))\n                currBoxes = imdb.roidb[imgIndex]['boxes']\n                currGtOverlaps = imdb.roidb[imgIndex]['gt_overlaps']\n                imgPath = imdb.image_path_at(imgIndex)\n                (imgWidth, imgHeight) = imWidthHeight(imgPath)\n                (targetw, targeth, w_offset, h_offset, scale) = roiTransformPadScaleParams(imgWidth, imgHeight, p.cntk_padWidth, p.cntk_padHeight)\n                boxesStr = ''\n                labelsStr = ''\n                nrBoxes = len(currBoxes)\n                for (boxIndex, box) in enumerate(currBoxes):\n                    rect = roiTransformPadScale(box, w_offset, h_offset, scale)\n                    boxesStr += getCntkRoiCoordsLine(rect, p.cntk_padWidth, p.cntk_padHeight)\n                    labelsStr += getCntkRoiLabelsLine(currGtOverlaps[boxIndex, :].toarray()[0], p.train_posOverlapThres, p.nrClasses)\n                (boxesStr, labelsStr) = cntkPadInputs(nrBoxes, p.cntk_nrRois, p.nrClasses, boxesStr, labelsStr)\n                nrRoisFile.write('{}\\n'.format(nrBoxes))\n                cntkImgsFile.write('{}\\t{}\\t0\\n'.format(imgIndex, imgPath))\n                cntkRoiCoordsFile.write('{} |rois{}\\n'.format(imgIndex, boxesStr))\n                cntkRoiLabelsFile.write('{} |roiLabels{}\\n'.format(imgIndex, labelsStr))\n    print('DONE.')\n    return True",
            "def generate_input_rois(testing=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    p = PARAMETERS.get_parameters_for_dataset()\n    if not p.datasetName.startswith('pascalVoc'):\n        makeDirectory(p.roiDir)\n        roi_minDim = p.roi_minDimRel * p.roi_maxImgDim\n        roi_maxDim = p.roi_maxDimRel * p.roi_maxImgDim\n        roi_minNrPixels = p.roi_minNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        roi_maxNrPixels = p.roi_maxNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        for subdir in subDirs:\n            makeDirectory(os.path.join(p.roiDir, subdir))\n            imgFilenames = getFilesInDirectory(os.path.join(p.imgDir, subdir), '.jpg')\n            for (imgIndex, imgFilename) in enumerate(imgFilenames):\n                roiPath = '{}/{}/{}.roi.txt'.format(p.roiDir, subdir, imgFilename[:-4])\n                print(imgIndex, len(imgFilenames), subdir, imgFilename)\n                tstart = datetime.datetime.now()\n                imgPath = os.path.join(p.imgDir, subdir, imgFilename)\n                imgOrig = imread(imgPath)\n                if imWidth(imgPath) > imHeight(imgPath):\n                    print(imWidth(imgPath), imHeight(imgPath))\n                if boAddSelectiveSearchROIs:\n                    print('Calling selective search..')\n                    (rects, img, scale) = getSelectiveSearchRois(imgOrig, p.ss_scale, p.ss_sigma, p.ss_minSize, p.roi_maxImgDim)\n                    print('   Number of rois detected using selective search: ' + str(len(rects)))\n                else:\n                    rects = []\n                    (img, scale) = imresizeMaxDim(imgOrig, p.roi_maxImgDim, boUpscale=True, interpolation=cv2.INTER_AREA)\n                (imgWidth, imgHeight) = imArrayWidthHeight(img)\n                if boAddRoisOnGrid:\n                    rectsGrid = getGridRois(imgWidth, imgHeight, p.grid_nrScales, p.grid_aspectRatios)\n                    print('   Number of rois on grid added: ' + str(len(rectsGrid)))\n                    rects += rectsGrid\n                print('   Number of rectangles before filtering  = ' + str(len(rects)))\n                rois = filterRois(rects, imgWidth, imgHeight, roi_minNrPixels, roi_maxNrPixels, roi_minDim, roi_maxDim, p.roi_maxAspectRatio)\n                if len(rois) == 0:\n                    rois = [[5, 5, imgWidth - 5, imgHeight - 5]]\n                print('   Number of rectangles after filtering  = ' + str(len(rois)))\n                rois = np.int32(np.array(rois) / scale)\n                assert np.min(rois) >= 0\n                assert np.max(rois[:, [0, 2]]) < imArrayWidth(imgOrig)\n                assert np.max(rois[:, [1, 3]]) < imArrayHeight(imgOrig)\n                np.savetxt(roiPath, rois, fmt='%d')\n                print('   Time [ms]: ' + str((datetime.datetime.now() - tstart).total_seconds() * 1000))\n    if os.path.exists(p.cntkFilesDir):\n        assert p.cntkFilesDir.endswith('cntkFiles')\n        if not testing:\n            userInput = input('--> INPUT: Press \"y\" to delete directory ' + p.cntkFilesDir + ': ')\n            if userInput.lower() not in ['y', 'yes']:\n                print('User input is %s: exiting now.' % userInput)\n                exit(-1)\n        shutil.rmtree(p.cntkFilesDir)\n        time.sleep(0.1)\n    for image_set in image_sets:\n        imdb = p.imdbs[image_set]\n        print('Number of images in set {} = {}'.format(image_set, imdb.num_images))\n        makeDirectory(p.cntkFilesDir)\n        (cntkImgsPath, cntkRoiCoordsPath, cntkRoiLabelsPath, nrRoisPath) = getCntkInputPaths(p.cntkFilesDir, image_set)\n        with open(nrRoisPath, 'w') as nrRoisFile, open(cntkImgsPath, 'w') as cntkImgsFile, open(cntkRoiCoordsPath, 'w') as cntkRoiCoordsFile, open(cntkRoiLabelsPath, 'w') as cntkRoiLabelsFile:\n            for imgIndex in range(0, imdb.num_images):\n                if imgIndex % 50 == 0:\n                    print(\"Processing image set '{}', image {} of {}\".format(image_set, imgIndex, imdb.num_images))\n                currBoxes = imdb.roidb[imgIndex]['boxes']\n                currGtOverlaps = imdb.roidb[imgIndex]['gt_overlaps']\n                imgPath = imdb.image_path_at(imgIndex)\n                (imgWidth, imgHeight) = imWidthHeight(imgPath)\n                (targetw, targeth, w_offset, h_offset, scale) = roiTransformPadScaleParams(imgWidth, imgHeight, p.cntk_padWidth, p.cntk_padHeight)\n                boxesStr = ''\n                labelsStr = ''\n                nrBoxes = len(currBoxes)\n                for (boxIndex, box) in enumerate(currBoxes):\n                    rect = roiTransformPadScale(box, w_offset, h_offset, scale)\n                    boxesStr += getCntkRoiCoordsLine(rect, p.cntk_padWidth, p.cntk_padHeight)\n                    labelsStr += getCntkRoiLabelsLine(currGtOverlaps[boxIndex, :].toarray()[0], p.train_posOverlapThres, p.nrClasses)\n                (boxesStr, labelsStr) = cntkPadInputs(nrBoxes, p.cntk_nrRois, p.nrClasses, boxesStr, labelsStr)\n                nrRoisFile.write('{}\\n'.format(nrBoxes))\n                cntkImgsFile.write('{}\\t{}\\t0\\n'.format(imgIndex, imgPath))\n                cntkRoiCoordsFile.write('{} |rois{}\\n'.format(imgIndex, boxesStr))\n                cntkRoiLabelsFile.write('{} |roiLabels{}\\n'.format(imgIndex, labelsStr))\n    print('DONE.')\n    return True",
            "def generate_input_rois(testing=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    p = PARAMETERS.get_parameters_for_dataset()\n    if not p.datasetName.startswith('pascalVoc'):\n        makeDirectory(p.roiDir)\n        roi_minDim = p.roi_minDimRel * p.roi_maxImgDim\n        roi_maxDim = p.roi_maxDimRel * p.roi_maxImgDim\n        roi_minNrPixels = p.roi_minNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        roi_maxNrPixels = p.roi_maxNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        for subdir in subDirs:\n            makeDirectory(os.path.join(p.roiDir, subdir))\n            imgFilenames = getFilesInDirectory(os.path.join(p.imgDir, subdir), '.jpg')\n            for (imgIndex, imgFilename) in enumerate(imgFilenames):\n                roiPath = '{}/{}/{}.roi.txt'.format(p.roiDir, subdir, imgFilename[:-4])\n                print(imgIndex, len(imgFilenames), subdir, imgFilename)\n                tstart = datetime.datetime.now()\n                imgPath = os.path.join(p.imgDir, subdir, imgFilename)\n                imgOrig = imread(imgPath)\n                if imWidth(imgPath) > imHeight(imgPath):\n                    print(imWidth(imgPath), imHeight(imgPath))\n                if boAddSelectiveSearchROIs:\n                    print('Calling selective search..')\n                    (rects, img, scale) = getSelectiveSearchRois(imgOrig, p.ss_scale, p.ss_sigma, p.ss_minSize, p.roi_maxImgDim)\n                    print('   Number of rois detected using selective search: ' + str(len(rects)))\n                else:\n                    rects = []\n                    (img, scale) = imresizeMaxDim(imgOrig, p.roi_maxImgDim, boUpscale=True, interpolation=cv2.INTER_AREA)\n                (imgWidth, imgHeight) = imArrayWidthHeight(img)\n                if boAddRoisOnGrid:\n                    rectsGrid = getGridRois(imgWidth, imgHeight, p.grid_nrScales, p.grid_aspectRatios)\n                    print('   Number of rois on grid added: ' + str(len(rectsGrid)))\n                    rects += rectsGrid\n                print('   Number of rectangles before filtering  = ' + str(len(rects)))\n                rois = filterRois(rects, imgWidth, imgHeight, roi_minNrPixels, roi_maxNrPixels, roi_minDim, roi_maxDim, p.roi_maxAspectRatio)\n                if len(rois) == 0:\n                    rois = [[5, 5, imgWidth - 5, imgHeight - 5]]\n                print('   Number of rectangles after filtering  = ' + str(len(rois)))\n                rois = np.int32(np.array(rois) / scale)\n                assert np.min(rois) >= 0\n                assert np.max(rois[:, [0, 2]]) < imArrayWidth(imgOrig)\n                assert np.max(rois[:, [1, 3]]) < imArrayHeight(imgOrig)\n                np.savetxt(roiPath, rois, fmt='%d')\n                print('   Time [ms]: ' + str((datetime.datetime.now() - tstart).total_seconds() * 1000))\n    if os.path.exists(p.cntkFilesDir):\n        assert p.cntkFilesDir.endswith('cntkFiles')\n        if not testing:\n            userInput = input('--> INPUT: Press \"y\" to delete directory ' + p.cntkFilesDir + ': ')\n            if userInput.lower() not in ['y', 'yes']:\n                print('User input is %s: exiting now.' % userInput)\n                exit(-1)\n        shutil.rmtree(p.cntkFilesDir)\n        time.sleep(0.1)\n    for image_set in image_sets:\n        imdb = p.imdbs[image_set]\n        print('Number of images in set {} = {}'.format(image_set, imdb.num_images))\n        makeDirectory(p.cntkFilesDir)\n        (cntkImgsPath, cntkRoiCoordsPath, cntkRoiLabelsPath, nrRoisPath) = getCntkInputPaths(p.cntkFilesDir, image_set)\n        with open(nrRoisPath, 'w') as nrRoisFile, open(cntkImgsPath, 'w') as cntkImgsFile, open(cntkRoiCoordsPath, 'w') as cntkRoiCoordsFile, open(cntkRoiLabelsPath, 'w') as cntkRoiLabelsFile:\n            for imgIndex in range(0, imdb.num_images):\n                if imgIndex % 50 == 0:\n                    print(\"Processing image set '{}', image {} of {}\".format(image_set, imgIndex, imdb.num_images))\n                currBoxes = imdb.roidb[imgIndex]['boxes']\n                currGtOverlaps = imdb.roidb[imgIndex]['gt_overlaps']\n                imgPath = imdb.image_path_at(imgIndex)\n                (imgWidth, imgHeight) = imWidthHeight(imgPath)\n                (targetw, targeth, w_offset, h_offset, scale) = roiTransformPadScaleParams(imgWidth, imgHeight, p.cntk_padWidth, p.cntk_padHeight)\n                boxesStr = ''\n                labelsStr = ''\n                nrBoxes = len(currBoxes)\n                for (boxIndex, box) in enumerate(currBoxes):\n                    rect = roiTransformPadScale(box, w_offset, h_offset, scale)\n                    boxesStr += getCntkRoiCoordsLine(rect, p.cntk_padWidth, p.cntk_padHeight)\n                    labelsStr += getCntkRoiLabelsLine(currGtOverlaps[boxIndex, :].toarray()[0], p.train_posOverlapThres, p.nrClasses)\n                (boxesStr, labelsStr) = cntkPadInputs(nrBoxes, p.cntk_nrRois, p.nrClasses, boxesStr, labelsStr)\n                nrRoisFile.write('{}\\n'.format(nrBoxes))\n                cntkImgsFile.write('{}\\t{}\\t0\\n'.format(imgIndex, imgPath))\n                cntkRoiCoordsFile.write('{} |rois{}\\n'.format(imgIndex, boxesStr))\n                cntkRoiLabelsFile.write('{} |roiLabels{}\\n'.format(imgIndex, labelsStr))\n    print('DONE.')\n    return True",
            "def generate_input_rois(testing=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    p = PARAMETERS.get_parameters_for_dataset()\n    if not p.datasetName.startswith('pascalVoc'):\n        makeDirectory(p.roiDir)\n        roi_minDim = p.roi_minDimRel * p.roi_maxImgDim\n        roi_maxDim = p.roi_maxDimRel * p.roi_maxImgDim\n        roi_minNrPixels = p.roi_minNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        roi_maxNrPixels = p.roi_maxNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        for subdir in subDirs:\n            makeDirectory(os.path.join(p.roiDir, subdir))\n            imgFilenames = getFilesInDirectory(os.path.join(p.imgDir, subdir), '.jpg')\n            for (imgIndex, imgFilename) in enumerate(imgFilenames):\n                roiPath = '{}/{}/{}.roi.txt'.format(p.roiDir, subdir, imgFilename[:-4])\n                print(imgIndex, len(imgFilenames), subdir, imgFilename)\n                tstart = datetime.datetime.now()\n                imgPath = os.path.join(p.imgDir, subdir, imgFilename)\n                imgOrig = imread(imgPath)\n                if imWidth(imgPath) > imHeight(imgPath):\n                    print(imWidth(imgPath), imHeight(imgPath))\n                if boAddSelectiveSearchROIs:\n                    print('Calling selective search..')\n                    (rects, img, scale) = getSelectiveSearchRois(imgOrig, p.ss_scale, p.ss_sigma, p.ss_minSize, p.roi_maxImgDim)\n                    print('   Number of rois detected using selective search: ' + str(len(rects)))\n                else:\n                    rects = []\n                    (img, scale) = imresizeMaxDim(imgOrig, p.roi_maxImgDim, boUpscale=True, interpolation=cv2.INTER_AREA)\n                (imgWidth, imgHeight) = imArrayWidthHeight(img)\n                if boAddRoisOnGrid:\n                    rectsGrid = getGridRois(imgWidth, imgHeight, p.grid_nrScales, p.grid_aspectRatios)\n                    print('   Number of rois on grid added: ' + str(len(rectsGrid)))\n                    rects += rectsGrid\n                print('   Number of rectangles before filtering  = ' + str(len(rects)))\n                rois = filterRois(rects, imgWidth, imgHeight, roi_minNrPixels, roi_maxNrPixels, roi_minDim, roi_maxDim, p.roi_maxAspectRatio)\n                if len(rois) == 0:\n                    rois = [[5, 5, imgWidth - 5, imgHeight - 5]]\n                print('   Number of rectangles after filtering  = ' + str(len(rois)))\n                rois = np.int32(np.array(rois) / scale)\n                assert np.min(rois) >= 0\n                assert np.max(rois[:, [0, 2]]) < imArrayWidth(imgOrig)\n                assert np.max(rois[:, [1, 3]]) < imArrayHeight(imgOrig)\n                np.savetxt(roiPath, rois, fmt='%d')\n                print('   Time [ms]: ' + str((datetime.datetime.now() - tstart).total_seconds() * 1000))\n    if os.path.exists(p.cntkFilesDir):\n        assert p.cntkFilesDir.endswith('cntkFiles')\n        if not testing:\n            userInput = input('--> INPUT: Press \"y\" to delete directory ' + p.cntkFilesDir + ': ')\n            if userInput.lower() not in ['y', 'yes']:\n                print('User input is %s: exiting now.' % userInput)\n                exit(-1)\n        shutil.rmtree(p.cntkFilesDir)\n        time.sleep(0.1)\n    for image_set in image_sets:\n        imdb = p.imdbs[image_set]\n        print('Number of images in set {} = {}'.format(image_set, imdb.num_images))\n        makeDirectory(p.cntkFilesDir)\n        (cntkImgsPath, cntkRoiCoordsPath, cntkRoiLabelsPath, nrRoisPath) = getCntkInputPaths(p.cntkFilesDir, image_set)\n        with open(nrRoisPath, 'w') as nrRoisFile, open(cntkImgsPath, 'w') as cntkImgsFile, open(cntkRoiCoordsPath, 'w') as cntkRoiCoordsFile, open(cntkRoiLabelsPath, 'w') as cntkRoiLabelsFile:\n            for imgIndex in range(0, imdb.num_images):\n                if imgIndex % 50 == 0:\n                    print(\"Processing image set '{}', image {} of {}\".format(image_set, imgIndex, imdb.num_images))\n                currBoxes = imdb.roidb[imgIndex]['boxes']\n                currGtOverlaps = imdb.roidb[imgIndex]['gt_overlaps']\n                imgPath = imdb.image_path_at(imgIndex)\n                (imgWidth, imgHeight) = imWidthHeight(imgPath)\n                (targetw, targeth, w_offset, h_offset, scale) = roiTransformPadScaleParams(imgWidth, imgHeight, p.cntk_padWidth, p.cntk_padHeight)\n                boxesStr = ''\n                labelsStr = ''\n                nrBoxes = len(currBoxes)\n                for (boxIndex, box) in enumerate(currBoxes):\n                    rect = roiTransformPadScale(box, w_offset, h_offset, scale)\n                    boxesStr += getCntkRoiCoordsLine(rect, p.cntk_padWidth, p.cntk_padHeight)\n                    labelsStr += getCntkRoiLabelsLine(currGtOverlaps[boxIndex, :].toarray()[0], p.train_posOverlapThres, p.nrClasses)\n                (boxesStr, labelsStr) = cntkPadInputs(nrBoxes, p.cntk_nrRois, p.nrClasses, boxesStr, labelsStr)\n                nrRoisFile.write('{}\\n'.format(nrBoxes))\n                cntkImgsFile.write('{}\\t{}\\t0\\n'.format(imgIndex, imgPath))\n                cntkRoiCoordsFile.write('{} |rois{}\\n'.format(imgIndex, boxesStr))\n                cntkRoiLabelsFile.write('{} |roiLabels{}\\n'.format(imgIndex, labelsStr))\n    print('DONE.')\n    return True",
            "def generate_input_rois(testing=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    p = PARAMETERS.get_parameters_for_dataset()\n    if not p.datasetName.startswith('pascalVoc'):\n        makeDirectory(p.roiDir)\n        roi_minDim = p.roi_minDimRel * p.roi_maxImgDim\n        roi_maxDim = p.roi_maxDimRel * p.roi_maxImgDim\n        roi_minNrPixels = p.roi_minNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        roi_maxNrPixels = p.roi_maxNrPixelsRel * p.roi_maxImgDim * p.roi_maxImgDim\n        for subdir in subDirs:\n            makeDirectory(os.path.join(p.roiDir, subdir))\n            imgFilenames = getFilesInDirectory(os.path.join(p.imgDir, subdir), '.jpg')\n            for (imgIndex, imgFilename) in enumerate(imgFilenames):\n                roiPath = '{}/{}/{}.roi.txt'.format(p.roiDir, subdir, imgFilename[:-4])\n                print(imgIndex, len(imgFilenames), subdir, imgFilename)\n                tstart = datetime.datetime.now()\n                imgPath = os.path.join(p.imgDir, subdir, imgFilename)\n                imgOrig = imread(imgPath)\n                if imWidth(imgPath) > imHeight(imgPath):\n                    print(imWidth(imgPath), imHeight(imgPath))\n                if boAddSelectiveSearchROIs:\n                    print('Calling selective search..')\n                    (rects, img, scale) = getSelectiveSearchRois(imgOrig, p.ss_scale, p.ss_sigma, p.ss_minSize, p.roi_maxImgDim)\n                    print('   Number of rois detected using selective search: ' + str(len(rects)))\n                else:\n                    rects = []\n                    (img, scale) = imresizeMaxDim(imgOrig, p.roi_maxImgDim, boUpscale=True, interpolation=cv2.INTER_AREA)\n                (imgWidth, imgHeight) = imArrayWidthHeight(img)\n                if boAddRoisOnGrid:\n                    rectsGrid = getGridRois(imgWidth, imgHeight, p.grid_nrScales, p.grid_aspectRatios)\n                    print('   Number of rois on grid added: ' + str(len(rectsGrid)))\n                    rects += rectsGrid\n                print('   Number of rectangles before filtering  = ' + str(len(rects)))\n                rois = filterRois(rects, imgWidth, imgHeight, roi_minNrPixels, roi_maxNrPixels, roi_minDim, roi_maxDim, p.roi_maxAspectRatio)\n                if len(rois) == 0:\n                    rois = [[5, 5, imgWidth - 5, imgHeight - 5]]\n                print('   Number of rectangles after filtering  = ' + str(len(rois)))\n                rois = np.int32(np.array(rois) / scale)\n                assert np.min(rois) >= 0\n                assert np.max(rois[:, [0, 2]]) < imArrayWidth(imgOrig)\n                assert np.max(rois[:, [1, 3]]) < imArrayHeight(imgOrig)\n                np.savetxt(roiPath, rois, fmt='%d')\n                print('   Time [ms]: ' + str((datetime.datetime.now() - tstart).total_seconds() * 1000))\n    if os.path.exists(p.cntkFilesDir):\n        assert p.cntkFilesDir.endswith('cntkFiles')\n        if not testing:\n            userInput = input('--> INPUT: Press \"y\" to delete directory ' + p.cntkFilesDir + ': ')\n            if userInput.lower() not in ['y', 'yes']:\n                print('User input is %s: exiting now.' % userInput)\n                exit(-1)\n        shutil.rmtree(p.cntkFilesDir)\n        time.sleep(0.1)\n    for image_set in image_sets:\n        imdb = p.imdbs[image_set]\n        print('Number of images in set {} = {}'.format(image_set, imdb.num_images))\n        makeDirectory(p.cntkFilesDir)\n        (cntkImgsPath, cntkRoiCoordsPath, cntkRoiLabelsPath, nrRoisPath) = getCntkInputPaths(p.cntkFilesDir, image_set)\n        with open(nrRoisPath, 'w') as nrRoisFile, open(cntkImgsPath, 'w') as cntkImgsFile, open(cntkRoiCoordsPath, 'w') as cntkRoiCoordsFile, open(cntkRoiLabelsPath, 'w') as cntkRoiLabelsFile:\n            for imgIndex in range(0, imdb.num_images):\n                if imgIndex % 50 == 0:\n                    print(\"Processing image set '{}', image {} of {}\".format(image_set, imgIndex, imdb.num_images))\n                currBoxes = imdb.roidb[imgIndex]['boxes']\n                currGtOverlaps = imdb.roidb[imgIndex]['gt_overlaps']\n                imgPath = imdb.image_path_at(imgIndex)\n                (imgWidth, imgHeight) = imWidthHeight(imgPath)\n                (targetw, targeth, w_offset, h_offset, scale) = roiTransformPadScaleParams(imgWidth, imgHeight, p.cntk_padWidth, p.cntk_padHeight)\n                boxesStr = ''\n                labelsStr = ''\n                nrBoxes = len(currBoxes)\n                for (boxIndex, box) in enumerate(currBoxes):\n                    rect = roiTransformPadScale(box, w_offset, h_offset, scale)\n                    boxesStr += getCntkRoiCoordsLine(rect, p.cntk_padWidth, p.cntk_padHeight)\n                    labelsStr += getCntkRoiLabelsLine(currGtOverlaps[boxIndex, :].toarray()[0], p.train_posOverlapThres, p.nrClasses)\n                (boxesStr, labelsStr) = cntkPadInputs(nrBoxes, p.cntk_nrRois, p.nrClasses, boxesStr, labelsStr)\n                nrRoisFile.write('{}\\n'.format(nrBoxes))\n                cntkImgsFile.write('{}\\t{}\\t0\\n'.format(imgIndex, imgPath))\n                cntkRoiCoordsFile.write('{} |rois{}\\n'.format(imgIndex, boxesStr))\n                cntkRoiLabelsFile.write('{} |roiLabels{}\\n'.format(imgIndex, labelsStr))\n    print('DONE.')\n    return True"
        ]
    }
]