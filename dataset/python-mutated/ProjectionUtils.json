[
    {
        "func_name": "HomoCalc",
        "original": "def HomoCalc(grids, new_grids_loc):\n    \"\"\"\n    @param: grids the location of origin grid vertices [2, H, W]\n    @param: new_grids_loc the location of desired grid vertices [2, H, W]\n\n    @return: homo_t homograph projection matrix for each grid [3, 3, H-1, W-1]\n    \"\"\"\n    (_, H, W) = grids.shape\n    new_grids = new_grids_loc.unsqueeze(0)\n    Homo = torch.zeros(1, 3, 3, H - 1, W - 1).to(grids.device)\n    grids = grids.unsqueeze(0)\n    try:\n        one = torch.ones_like(grids[:, 0:1, :-1, :-1], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, :-1, :-1], device=grids.device)\n        A = torch.cat([torch.stack([grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 0:1, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 0:1, :-1, :-1]], 2), torch.stack([grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 0:1, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 0:1, 1:, :-1]], 2), torch.stack([grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 0:1, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 0:1, :-1, 1:]], 2), torch.stack([grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 0:1, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 0:1, 1:, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 1:2, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 1:2, :-1, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 1:2, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 1:2, 1:, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 1:2, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 1:2, :-1, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 1:2, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 1:2, 1:, 1:]], 2)], 1).view(8, 8, -1).permute(2, 0, 1)\n        B_ = torch.stack([new_grids[:, 0, :-1, :-1], new_grids[:, 0, 1:, :-1], new_grids[:, 0, :-1, 1:], new_grids[:, 0, 1:, 1:], new_grids[:, 1, :-1, :-1], new_grids[:, 1, 1:, :-1], new_grids[:, 1, :-1, 1:], new_grids[:, 1, 1:, 1:]], 1).view(8, -1).permute(1, 0)\n        A_inverse = torch.inverse(A)\n        H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n        H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :], device=H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n        H_ = H_.permute(1, 2, 0)\n        H_ = H_.view(Homo.shape)\n        Homo = H_\n    except Exception:\n        one = torch.ones_like(grids[:, 0:1, 0, 0], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, 0, 0], device=grids.device)\n        H_ = torch.eye(3, device=grids.device)\n        for i in range(H - 1):\n            for j in range(W - 1):\n                A = torch.cat([torch.stack([grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, zero, zero, zero, -1 * grids[:, 0:1, i, j] * new_grids[:, 0:1, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 0:1, i, j]], 2), torch.stack([grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 0:1, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 0:1, i + 1, j]], 2), torch.stack([grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 0:1, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 0:1, i, j + 1]], 2), torch.stack([grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, -1 * grids[:, 0:1, i, j] * new_grids[:, 1:2, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 1:2, i, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 1:2, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 1:2, i + 1, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 1:2, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 1:2, i, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1]], 2)], 1)\n                B_ = torch.stack([new_grids[:, 0, i, j], new_grids[:, 0, i + 1, j], new_grids[:, 0, i, j + 1], new_grids[:, 0, i + 1, j + 1], new_grids[:, 1, i, j], new_grids[:, 1, i + 1, j], new_grids[:, 1, i, j + 1], new_grids[:, 1, i + 1, j + 1]], 1)\n                try:\n                    A_inverse = torch.inverse(A)\n                    H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n                    H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :]).to(H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n                except Exception:\n                    pass\n                Homo[:, :, :, i, j] = H_\n    homo_t = Homo.view(3, 3, H - 1, W - 1)\n    return homo_t",
        "mutated": [
            "def HomoCalc(grids, new_grids_loc):\n    if False:\n        i = 10\n    '\\n    @param: grids the location of origin grid vertices [2, H, W]\\n    @param: new_grids_loc the location of desired grid vertices [2, H, W]\\n\\n    @return: homo_t homograph projection matrix for each grid [3, 3, H-1, W-1]\\n    '\n    (_, H, W) = grids.shape\n    new_grids = new_grids_loc.unsqueeze(0)\n    Homo = torch.zeros(1, 3, 3, H - 1, W - 1).to(grids.device)\n    grids = grids.unsqueeze(0)\n    try:\n        one = torch.ones_like(grids[:, 0:1, :-1, :-1], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, :-1, :-1], device=grids.device)\n        A = torch.cat([torch.stack([grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 0:1, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 0:1, :-1, :-1]], 2), torch.stack([grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 0:1, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 0:1, 1:, :-1]], 2), torch.stack([grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 0:1, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 0:1, :-1, 1:]], 2), torch.stack([grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 0:1, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 0:1, 1:, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 1:2, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 1:2, :-1, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 1:2, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 1:2, 1:, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 1:2, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 1:2, :-1, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 1:2, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 1:2, 1:, 1:]], 2)], 1).view(8, 8, -1).permute(2, 0, 1)\n        B_ = torch.stack([new_grids[:, 0, :-1, :-1], new_grids[:, 0, 1:, :-1], new_grids[:, 0, :-1, 1:], new_grids[:, 0, 1:, 1:], new_grids[:, 1, :-1, :-1], new_grids[:, 1, 1:, :-1], new_grids[:, 1, :-1, 1:], new_grids[:, 1, 1:, 1:]], 1).view(8, -1).permute(1, 0)\n        A_inverse = torch.inverse(A)\n        H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n        H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :], device=H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n        H_ = H_.permute(1, 2, 0)\n        H_ = H_.view(Homo.shape)\n        Homo = H_\n    except Exception:\n        one = torch.ones_like(grids[:, 0:1, 0, 0], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, 0, 0], device=grids.device)\n        H_ = torch.eye(3, device=grids.device)\n        for i in range(H - 1):\n            for j in range(W - 1):\n                A = torch.cat([torch.stack([grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, zero, zero, zero, -1 * grids[:, 0:1, i, j] * new_grids[:, 0:1, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 0:1, i, j]], 2), torch.stack([grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 0:1, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 0:1, i + 1, j]], 2), torch.stack([grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 0:1, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 0:1, i, j + 1]], 2), torch.stack([grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, -1 * grids[:, 0:1, i, j] * new_grids[:, 1:2, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 1:2, i, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 1:2, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 1:2, i + 1, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 1:2, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 1:2, i, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1]], 2)], 1)\n                B_ = torch.stack([new_grids[:, 0, i, j], new_grids[:, 0, i + 1, j], new_grids[:, 0, i, j + 1], new_grids[:, 0, i + 1, j + 1], new_grids[:, 1, i, j], new_grids[:, 1, i + 1, j], new_grids[:, 1, i, j + 1], new_grids[:, 1, i + 1, j + 1]], 1)\n                try:\n                    A_inverse = torch.inverse(A)\n                    H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n                    H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :]).to(H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n                except Exception:\n                    pass\n                Homo[:, :, :, i, j] = H_\n    homo_t = Homo.view(3, 3, H - 1, W - 1)\n    return homo_t",
            "def HomoCalc(grids, new_grids_loc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    @param: grids the location of origin grid vertices [2, H, W]\\n    @param: new_grids_loc the location of desired grid vertices [2, H, W]\\n\\n    @return: homo_t homograph projection matrix for each grid [3, 3, H-1, W-1]\\n    '\n    (_, H, W) = grids.shape\n    new_grids = new_grids_loc.unsqueeze(0)\n    Homo = torch.zeros(1, 3, 3, H - 1, W - 1).to(grids.device)\n    grids = grids.unsqueeze(0)\n    try:\n        one = torch.ones_like(grids[:, 0:1, :-1, :-1], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, :-1, :-1], device=grids.device)\n        A = torch.cat([torch.stack([grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 0:1, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 0:1, :-1, :-1]], 2), torch.stack([grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 0:1, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 0:1, 1:, :-1]], 2), torch.stack([grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 0:1, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 0:1, :-1, 1:]], 2), torch.stack([grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 0:1, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 0:1, 1:, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 1:2, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 1:2, :-1, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 1:2, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 1:2, 1:, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 1:2, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 1:2, :-1, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 1:2, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 1:2, 1:, 1:]], 2)], 1).view(8, 8, -1).permute(2, 0, 1)\n        B_ = torch.stack([new_grids[:, 0, :-1, :-1], new_grids[:, 0, 1:, :-1], new_grids[:, 0, :-1, 1:], new_grids[:, 0, 1:, 1:], new_grids[:, 1, :-1, :-1], new_grids[:, 1, 1:, :-1], new_grids[:, 1, :-1, 1:], new_grids[:, 1, 1:, 1:]], 1).view(8, -1).permute(1, 0)\n        A_inverse = torch.inverse(A)\n        H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n        H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :], device=H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n        H_ = H_.permute(1, 2, 0)\n        H_ = H_.view(Homo.shape)\n        Homo = H_\n    except Exception:\n        one = torch.ones_like(grids[:, 0:1, 0, 0], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, 0, 0], device=grids.device)\n        H_ = torch.eye(3, device=grids.device)\n        for i in range(H - 1):\n            for j in range(W - 1):\n                A = torch.cat([torch.stack([grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, zero, zero, zero, -1 * grids[:, 0:1, i, j] * new_grids[:, 0:1, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 0:1, i, j]], 2), torch.stack([grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 0:1, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 0:1, i + 1, j]], 2), torch.stack([grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 0:1, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 0:1, i, j + 1]], 2), torch.stack([grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, -1 * grids[:, 0:1, i, j] * new_grids[:, 1:2, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 1:2, i, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 1:2, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 1:2, i + 1, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 1:2, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 1:2, i, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1]], 2)], 1)\n                B_ = torch.stack([new_grids[:, 0, i, j], new_grids[:, 0, i + 1, j], new_grids[:, 0, i, j + 1], new_grids[:, 0, i + 1, j + 1], new_grids[:, 1, i, j], new_grids[:, 1, i + 1, j], new_grids[:, 1, i, j + 1], new_grids[:, 1, i + 1, j + 1]], 1)\n                try:\n                    A_inverse = torch.inverse(A)\n                    H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n                    H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :]).to(H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n                except Exception:\n                    pass\n                Homo[:, :, :, i, j] = H_\n    homo_t = Homo.view(3, 3, H - 1, W - 1)\n    return homo_t",
            "def HomoCalc(grids, new_grids_loc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    @param: grids the location of origin grid vertices [2, H, W]\\n    @param: new_grids_loc the location of desired grid vertices [2, H, W]\\n\\n    @return: homo_t homograph projection matrix for each grid [3, 3, H-1, W-1]\\n    '\n    (_, H, W) = grids.shape\n    new_grids = new_grids_loc.unsqueeze(0)\n    Homo = torch.zeros(1, 3, 3, H - 1, W - 1).to(grids.device)\n    grids = grids.unsqueeze(0)\n    try:\n        one = torch.ones_like(grids[:, 0:1, :-1, :-1], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, :-1, :-1], device=grids.device)\n        A = torch.cat([torch.stack([grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 0:1, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 0:1, :-1, :-1]], 2), torch.stack([grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 0:1, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 0:1, 1:, :-1]], 2), torch.stack([grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 0:1, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 0:1, :-1, 1:]], 2), torch.stack([grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 0:1, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 0:1, 1:, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 1:2, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 1:2, :-1, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 1:2, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 1:2, 1:, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 1:2, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 1:2, :-1, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 1:2, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 1:2, 1:, 1:]], 2)], 1).view(8, 8, -1).permute(2, 0, 1)\n        B_ = torch.stack([new_grids[:, 0, :-1, :-1], new_grids[:, 0, 1:, :-1], new_grids[:, 0, :-1, 1:], new_grids[:, 0, 1:, 1:], new_grids[:, 1, :-1, :-1], new_grids[:, 1, 1:, :-1], new_grids[:, 1, :-1, 1:], new_grids[:, 1, 1:, 1:]], 1).view(8, -1).permute(1, 0)\n        A_inverse = torch.inverse(A)\n        H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n        H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :], device=H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n        H_ = H_.permute(1, 2, 0)\n        H_ = H_.view(Homo.shape)\n        Homo = H_\n    except Exception:\n        one = torch.ones_like(grids[:, 0:1, 0, 0], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, 0, 0], device=grids.device)\n        H_ = torch.eye(3, device=grids.device)\n        for i in range(H - 1):\n            for j in range(W - 1):\n                A = torch.cat([torch.stack([grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, zero, zero, zero, -1 * grids[:, 0:1, i, j] * new_grids[:, 0:1, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 0:1, i, j]], 2), torch.stack([grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 0:1, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 0:1, i + 1, j]], 2), torch.stack([grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 0:1, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 0:1, i, j + 1]], 2), torch.stack([grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, -1 * grids[:, 0:1, i, j] * new_grids[:, 1:2, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 1:2, i, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 1:2, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 1:2, i + 1, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 1:2, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 1:2, i, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1]], 2)], 1)\n                B_ = torch.stack([new_grids[:, 0, i, j], new_grids[:, 0, i + 1, j], new_grids[:, 0, i, j + 1], new_grids[:, 0, i + 1, j + 1], new_grids[:, 1, i, j], new_grids[:, 1, i + 1, j], new_grids[:, 1, i, j + 1], new_grids[:, 1, i + 1, j + 1]], 1)\n                try:\n                    A_inverse = torch.inverse(A)\n                    H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n                    H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :]).to(H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n                except Exception:\n                    pass\n                Homo[:, :, :, i, j] = H_\n    homo_t = Homo.view(3, 3, H - 1, W - 1)\n    return homo_t",
            "def HomoCalc(grids, new_grids_loc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    @param: grids the location of origin grid vertices [2, H, W]\\n    @param: new_grids_loc the location of desired grid vertices [2, H, W]\\n\\n    @return: homo_t homograph projection matrix for each grid [3, 3, H-1, W-1]\\n    '\n    (_, H, W) = grids.shape\n    new_grids = new_grids_loc.unsqueeze(0)\n    Homo = torch.zeros(1, 3, 3, H - 1, W - 1).to(grids.device)\n    grids = grids.unsqueeze(0)\n    try:\n        one = torch.ones_like(grids[:, 0:1, :-1, :-1], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, :-1, :-1], device=grids.device)\n        A = torch.cat([torch.stack([grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 0:1, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 0:1, :-1, :-1]], 2), torch.stack([grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 0:1, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 0:1, 1:, :-1]], 2), torch.stack([grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 0:1, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 0:1, :-1, 1:]], 2), torch.stack([grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 0:1, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 0:1, 1:, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 1:2, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 1:2, :-1, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 1:2, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 1:2, 1:, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 1:2, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 1:2, :-1, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 1:2, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 1:2, 1:, 1:]], 2)], 1).view(8, 8, -1).permute(2, 0, 1)\n        B_ = torch.stack([new_grids[:, 0, :-1, :-1], new_grids[:, 0, 1:, :-1], new_grids[:, 0, :-1, 1:], new_grids[:, 0, 1:, 1:], new_grids[:, 1, :-1, :-1], new_grids[:, 1, 1:, :-1], new_grids[:, 1, :-1, 1:], new_grids[:, 1, 1:, 1:]], 1).view(8, -1).permute(1, 0)\n        A_inverse = torch.inverse(A)\n        H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n        H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :], device=H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n        H_ = H_.permute(1, 2, 0)\n        H_ = H_.view(Homo.shape)\n        Homo = H_\n    except Exception:\n        one = torch.ones_like(grids[:, 0:1, 0, 0], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, 0, 0], device=grids.device)\n        H_ = torch.eye(3, device=grids.device)\n        for i in range(H - 1):\n            for j in range(W - 1):\n                A = torch.cat([torch.stack([grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, zero, zero, zero, -1 * grids[:, 0:1, i, j] * new_grids[:, 0:1, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 0:1, i, j]], 2), torch.stack([grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 0:1, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 0:1, i + 1, j]], 2), torch.stack([grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 0:1, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 0:1, i, j + 1]], 2), torch.stack([grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, -1 * grids[:, 0:1, i, j] * new_grids[:, 1:2, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 1:2, i, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 1:2, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 1:2, i + 1, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 1:2, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 1:2, i, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1]], 2)], 1)\n                B_ = torch.stack([new_grids[:, 0, i, j], new_grids[:, 0, i + 1, j], new_grids[:, 0, i, j + 1], new_grids[:, 0, i + 1, j + 1], new_grids[:, 1, i, j], new_grids[:, 1, i + 1, j], new_grids[:, 1, i, j + 1], new_grids[:, 1, i + 1, j + 1]], 1)\n                try:\n                    A_inverse = torch.inverse(A)\n                    H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n                    H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :]).to(H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n                except Exception:\n                    pass\n                Homo[:, :, :, i, j] = H_\n    homo_t = Homo.view(3, 3, H - 1, W - 1)\n    return homo_t",
            "def HomoCalc(grids, new_grids_loc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    @param: grids the location of origin grid vertices [2, H, W]\\n    @param: new_grids_loc the location of desired grid vertices [2, H, W]\\n\\n    @return: homo_t homograph projection matrix for each grid [3, 3, H-1, W-1]\\n    '\n    (_, H, W) = grids.shape\n    new_grids = new_grids_loc.unsqueeze(0)\n    Homo = torch.zeros(1, 3, 3, H - 1, W - 1).to(grids.device)\n    grids = grids.unsqueeze(0)\n    try:\n        one = torch.ones_like(grids[:, 0:1, :-1, :-1], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, :-1, :-1], device=grids.device)\n        A = torch.cat([torch.stack([grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 0:1, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 0:1, :-1, :-1]], 2), torch.stack([grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 0:1, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 0:1, 1:, :-1]], 2), torch.stack([grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 0:1, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 0:1, :-1, 1:]], 2), torch.stack([grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, zero, zero, zero, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 0:1, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 0:1, 1:, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, :-1], grids[:, 1:2, :-1, :-1], one, -1 * grids[:, 0:1, :-1, :-1] * new_grids[:, 1:2, :-1, :-1], -1 * grids[:, 1:2, :-1, :-1] * new_grids[:, 1:2, :-1, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, :-1], grids[:, 1:2, 1:, :-1], one, -1 * grids[:, 0:1, 1:, :-1] * new_grids[:, 1:2, 1:, :-1], -1 * grids[:, 1:2, 1:, :-1] * new_grids[:, 1:2, 1:, :-1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, :-1, 1:], grids[:, 1:2, :-1, 1:], one, -1 * grids[:, 0:1, :-1, 1:] * new_grids[:, 1:2, :-1, 1:], -1 * grids[:, 1:2, :-1, 1:] * new_grids[:, 1:2, :-1, 1:]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, 1:, 1:], grids[:, 1:2, 1:, 1:], one, -1 * grids[:, 0:1, 1:, 1:] * new_grids[:, 1:2, 1:, 1:], -1 * grids[:, 1:2, 1:, 1:] * new_grids[:, 1:2, 1:, 1:]], 2)], 1).view(8, 8, -1).permute(2, 0, 1)\n        B_ = torch.stack([new_grids[:, 0, :-1, :-1], new_grids[:, 0, 1:, :-1], new_grids[:, 0, :-1, 1:], new_grids[:, 0, 1:, 1:], new_grids[:, 1, :-1, :-1], new_grids[:, 1, 1:, :-1], new_grids[:, 1, :-1, 1:], new_grids[:, 1, 1:, 1:]], 1).view(8, -1).permute(1, 0)\n        A_inverse = torch.inverse(A)\n        H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n        H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :], device=H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n        H_ = H_.permute(1, 2, 0)\n        H_ = H_.view(Homo.shape)\n        Homo = H_\n    except Exception:\n        one = torch.ones_like(grids[:, 0:1, 0, 0], device=grids.device)\n        zero = torch.zeros_like(grids[:, 1:2, 0, 0], device=grids.device)\n        H_ = torch.eye(3, device=grids.device)\n        for i in range(H - 1):\n            for j in range(W - 1):\n                A = torch.cat([torch.stack([grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, zero, zero, zero, -1 * grids[:, 0:1, i, j] * new_grids[:, 0:1, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 0:1, i, j]], 2), torch.stack([grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 0:1, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 0:1, i + 1, j]], 2), torch.stack([grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 0:1, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 0:1, i, j + 1]], 2), torch.stack([grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, zero, zero, zero, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 0:1, i + 1, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j], grids[:, 1:2, i, j], one, -1 * grids[:, 0:1, i, j] * new_grids[:, 1:2, i, j], -1 * grids[:, 1:2, i, j] * new_grids[:, 1:2, i, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j], grids[:, 1:2, i + 1, j], one, -1 * grids[:, 0:1, i + 1, j] * new_grids[:, 1:2, i + 1, j], -1 * grids[:, 1:2, i + 1, j] * new_grids[:, 1:2, i + 1, j]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i, j + 1], grids[:, 1:2, i, j + 1], one, -1 * grids[:, 0:1, i, j + 1] * new_grids[:, 1:2, i, j + 1], -1 * grids[:, 1:2, i, j + 1] * new_grids[:, 1:2, i, j + 1]], 2), torch.stack([zero, zero, zero, grids[:, 0:1, i + 1, j + 1], grids[:, 1:2, i + 1, j + 1], one, -1 * grids[:, 0:1, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1], -1 * grids[:, 1:2, i + 1, j + 1] * new_grids[:, 1:2, i + 1, j + 1]], 2)], 1)\n                B_ = torch.stack([new_grids[:, 0, i, j], new_grids[:, 0, i + 1, j], new_grids[:, 0, i, j + 1], new_grids[:, 0, i + 1, j + 1], new_grids[:, 1, i, j], new_grids[:, 1, i + 1, j], new_grids[:, 1, i, j + 1], new_grids[:, 1, i + 1, j + 1]], 1)\n                try:\n                    A_inverse = torch.inverse(A)\n                    H_recovered = torch.bmm(A_inverse, B_.unsqueeze(2))\n                    H_ = torch.cat([H_recovered, torch.ones_like(H_recovered[:, 0:1, :]).to(H_recovered.device)], 1).view(H_recovered.shape[0], 3, 3)\n                except Exception:\n                    pass\n                Homo[:, :, :, i, j] = H_\n    homo_t = Homo.view(3, 3, H - 1, W - 1)\n    return homo_t"
        ]
    },
    {
        "func_name": "HomoProj",
        "original": "def HomoProj(homo, pts):\n    \"\"\"\n    @param: homo [3, 3, G_H-1, G_W-1]\n    @param: pts  [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\n\n    @return: projected pts [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\n    \"\"\"\n    pts_location_x = torch.div(pts[:, 0:1], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    pts_location_y = torch.div(pts[:, 1:2], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    maxWidth = cfg.MODEL.WIDTH // cfg.MODEL.PIXELS - 1\n    maxHeight = cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS - 1\n    index = (pts_location_x[:, 0] >= maxWidth).nonzero().long()\n    pts_location_x[index, :] = maxWidth - 1\n    index = (pts_location_y[:, 0] >= maxHeight).nonzero().long()\n    pts_location_y[index, :] = maxHeight - 1\n    homo = homo.to(pts.device)\n    x_dominator = pts[:, 0] * homo[0, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[0, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[0, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    y_dominator = pts[:, 0] * homo[1, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[1, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[1, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = pts[:, 0] * homo[2, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[2, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[2, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = noiminator\n    new_kp_x = x_dominator / noiminator\n    new_kp_y = y_dominator / noiminator\n    return torch.stack([new_kp_x, new_kp_y], 1)",
        "mutated": [
            "def HomoProj(homo, pts):\n    if False:\n        i = 10\n    '\\n    @param: homo [3, 3, G_H-1, G_W-1]\\n    @param: pts  [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n\\n    @return: projected pts [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n    '\n    pts_location_x = torch.div(pts[:, 0:1], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    pts_location_y = torch.div(pts[:, 1:2], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    maxWidth = cfg.MODEL.WIDTH // cfg.MODEL.PIXELS - 1\n    maxHeight = cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS - 1\n    index = (pts_location_x[:, 0] >= maxWidth).nonzero().long()\n    pts_location_x[index, :] = maxWidth - 1\n    index = (pts_location_y[:, 0] >= maxHeight).nonzero().long()\n    pts_location_y[index, :] = maxHeight - 1\n    homo = homo.to(pts.device)\n    x_dominator = pts[:, 0] * homo[0, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[0, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[0, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    y_dominator = pts[:, 0] * homo[1, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[1, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[1, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = pts[:, 0] * homo[2, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[2, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[2, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = noiminator\n    new_kp_x = x_dominator / noiminator\n    new_kp_y = y_dominator / noiminator\n    return torch.stack([new_kp_x, new_kp_y], 1)",
            "def HomoProj(homo, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    @param: homo [3, 3, G_H-1, G_W-1]\\n    @param: pts  [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n\\n    @return: projected pts [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n    '\n    pts_location_x = torch.div(pts[:, 0:1], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    pts_location_y = torch.div(pts[:, 1:2], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    maxWidth = cfg.MODEL.WIDTH // cfg.MODEL.PIXELS - 1\n    maxHeight = cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS - 1\n    index = (pts_location_x[:, 0] >= maxWidth).nonzero().long()\n    pts_location_x[index, :] = maxWidth - 1\n    index = (pts_location_y[:, 0] >= maxHeight).nonzero().long()\n    pts_location_y[index, :] = maxHeight - 1\n    homo = homo.to(pts.device)\n    x_dominator = pts[:, 0] * homo[0, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[0, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[0, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    y_dominator = pts[:, 0] * homo[1, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[1, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[1, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = pts[:, 0] * homo[2, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[2, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[2, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = noiminator\n    new_kp_x = x_dominator / noiminator\n    new_kp_y = y_dominator / noiminator\n    return torch.stack([new_kp_x, new_kp_y], 1)",
            "def HomoProj(homo, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    @param: homo [3, 3, G_H-1, G_W-1]\\n    @param: pts  [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n\\n    @return: projected pts [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n    '\n    pts_location_x = torch.div(pts[:, 0:1], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    pts_location_y = torch.div(pts[:, 1:2], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    maxWidth = cfg.MODEL.WIDTH // cfg.MODEL.PIXELS - 1\n    maxHeight = cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS - 1\n    index = (pts_location_x[:, 0] >= maxWidth).nonzero().long()\n    pts_location_x[index, :] = maxWidth - 1\n    index = (pts_location_y[:, 0] >= maxHeight).nonzero().long()\n    pts_location_y[index, :] = maxHeight - 1\n    homo = homo.to(pts.device)\n    x_dominator = pts[:, 0] * homo[0, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[0, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[0, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    y_dominator = pts[:, 0] * homo[1, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[1, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[1, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = pts[:, 0] * homo[2, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[2, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[2, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = noiminator\n    new_kp_x = x_dominator / noiminator\n    new_kp_y = y_dominator / noiminator\n    return torch.stack([new_kp_x, new_kp_y], 1)",
            "def HomoProj(homo, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    @param: homo [3, 3, G_H-1, G_W-1]\\n    @param: pts  [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n\\n    @return: projected pts [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n    '\n    pts_location_x = torch.div(pts[:, 0:1], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    pts_location_y = torch.div(pts[:, 1:2], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    maxWidth = cfg.MODEL.WIDTH // cfg.MODEL.PIXELS - 1\n    maxHeight = cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS - 1\n    index = (pts_location_x[:, 0] >= maxWidth).nonzero().long()\n    pts_location_x[index, :] = maxWidth - 1\n    index = (pts_location_y[:, 0] >= maxHeight).nonzero().long()\n    pts_location_y[index, :] = maxHeight - 1\n    homo = homo.to(pts.device)\n    x_dominator = pts[:, 0] * homo[0, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[0, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[0, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    y_dominator = pts[:, 0] * homo[1, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[1, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[1, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = pts[:, 0] * homo[2, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[2, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[2, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = noiminator\n    new_kp_x = x_dominator / noiminator\n    new_kp_y = y_dominator / noiminator\n    return torch.stack([new_kp_x, new_kp_y], 1)",
            "def HomoProj(homo, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    @param: homo [3, 3, G_H-1, G_W-1]\\n    @param: pts  [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n\\n    @return: projected pts [N, 2(W, H)] - [:, 0] for width and [:, 1] for height\\n    '\n    pts_location_x = torch.div(pts[:, 0:1], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    pts_location_y = torch.div(pts[:, 1:2], cfg.MODEL.PIXELS, rounding_mode='floor').long()\n    maxWidth = cfg.MODEL.WIDTH // cfg.MODEL.PIXELS - 1\n    maxHeight = cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS - 1\n    index = (pts_location_x[:, 0] >= maxWidth).nonzero().long()\n    pts_location_x[index, :] = maxWidth - 1\n    index = (pts_location_y[:, 0] >= maxHeight).nonzero().long()\n    pts_location_y[index, :] = maxHeight - 1\n    homo = homo.to(pts.device)\n    x_dominator = pts[:, 0] * homo[0, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[0, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[0, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    y_dominator = pts[:, 0] * homo[1, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[1, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[1, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = pts[:, 0] * homo[2, 0, pts_location_y[:, 0], pts_location_x[:, 0]] + pts[:, 1] * homo[2, 1, pts_location_y[:, 0], pts_location_x[:, 0]] + homo[2, 2, pts_location_y[:, 0], pts_location_x[:, 0]]\n    noiminator = noiminator\n    new_kp_x = x_dominator / noiminator\n    new_kp_y = y_dominator / noiminator\n    return torch.stack([new_kp_x, new_kp_y], 1)"
        ]
    },
    {
        "func_name": "multiHomoEstimate",
        "original": "def multiHomoEstimate(motion, kp):\n    \"\"\"\n    @param: motion [4, N]\n    @param: kp     [2, N]\n    \"\"\"\n    from sklearn.cluster import KMeans\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    cluster2_old_points = old_points_numpy[index, :]\n    cluster2_new_points = new_points_numpy[index, :]\n    attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = cluster2_new_points - cluster2_old_points\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    threhold = np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure\n    if threhold:\n        (Homo_2, _) = cv2.findHomography(cluster2_old_points, cluster2_new_points, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), np.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(old_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts.to(old_points.device).permute(1, 0)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
        "mutated": [
            "def multiHomoEstimate(motion, kp):\n    if False:\n        i = 10\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    from sklearn.cluster import KMeans\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    cluster2_old_points = old_points_numpy[index, :]\n    cluster2_new_points = new_points_numpy[index, :]\n    attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = cluster2_new_points - cluster2_old_points\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    threhold = np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure\n    if threhold:\n        (Homo_2, _) = cv2.findHomography(cluster2_old_points, cluster2_new_points, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), np.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(old_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts.to(old_points.device).permute(1, 0)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
            "def multiHomoEstimate(motion, kp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    from sklearn.cluster import KMeans\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    cluster2_old_points = old_points_numpy[index, :]\n    cluster2_new_points = new_points_numpy[index, :]\n    attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = cluster2_new_points - cluster2_old_points\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    threhold = np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure\n    if threhold:\n        (Homo_2, _) = cv2.findHomography(cluster2_old_points, cluster2_new_points, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), np.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(old_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts.to(old_points.device).permute(1, 0)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
            "def multiHomoEstimate(motion, kp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    from sklearn.cluster import KMeans\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    cluster2_old_points = old_points_numpy[index, :]\n    cluster2_new_points = new_points_numpy[index, :]\n    attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = cluster2_new_points - cluster2_old_points\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    threhold = np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure\n    if threhold:\n        (Homo_2, _) = cv2.findHomography(cluster2_old_points, cluster2_new_points, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), np.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(old_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts.to(old_points.device).permute(1, 0)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
            "def multiHomoEstimate(motion, kp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    from sklearn.cluster import KMeans\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    cluster2_old_points = old_points_numpy[index, :]\n    cluster2_new_points = new_points_numpy[index, :]\n    attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = cluster2_new_points - cluster2_old_points\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    threhold = np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure\n    if threhold:\n        (Homo_2, _) = cv2.findHomography(cluster2_old_points, cluster2_new_points, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), np.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(old_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts.to(old_points.device).permute(1, 0)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
            "def multiHomoEstimate(motion, kp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    from sklearn.cluster import KMeans\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    cluster2_old_points = old_points_numpy[index, :]\n    cluster2_new_points = new_points_numpy[index, :]\n    attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = cluster2_new_points - cluster2_old_points\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    threhold = np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure\n    if threhold:\n        (Homo_2, _) = cv2.findHomography(cluster2_old_points, cluster2_new_points, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), np.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(old_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts.to(old_points.device).permute(1, 0)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)"
        ]
    },
    {
        "func_name": "singleHomoEstimate",
        "original": "def singleHomoEstimate(motion, kp):\n    \"\"\"\n    @param: motion [4, N]\n    @param: kp     [2, N]\n    \"\"\"\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    cluster1_old_points = old_points_numpy\n    cluster1_new_points = new_points_numpy\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
        "mutated": [
            "def singleHomoEstimate(motion, kp):\n    if False:\n        i = 10\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    cluster1_old_points = old_points_numpy\n    cluster1_new_points = new_points_numpy\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
            "def singleHomoEstimate(motion, kp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    cluster1_old_points = old_points_numpy\n    cluster1_new_points = new_points_numpy\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
            "def singleHomoEstimate(motion, kp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    cluster1_old_points = old_points_numpy\n    cluster1_new_points = new_points_numpy\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
            "def singleHomoEstimate(motion, kp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    cluster1_old_points = old_points_numpy\n    cluster1_new_points = new_points_numpy\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)",
            "def singleHomoEstimate(motion, kp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    @param: motion [4, N]\\n    @param: kp     [2, N]\\n    '\n    new_kp = torch.cat([kp[1:2, :], kp[0:1, :]], 0) + motion[2:, :]\n    new_points_numpy = new_kp.cpu().detach().numpy().transpose(1, 0)\n    old_points = torch.stack([kp[1, :], kp[0, :]], 1).to(motion.device)\n    old_points_numpy = torch.cat([kp[1:2, :], kp[0:1, :]], 0).cpu().detach().numpy().transpose(1, 0)\n    cluster1_old_points = old_points_numpy\n    cluster1_new_points = new_points_numpy\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = torch.from_numpy(np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1).astype(np.float32)).to(old_points.device).permute(1, 0)\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n    grids = torch.stack(torch.meshgrid(torch.arange(0, cfg.MODEL.WIDTH, cfg.MODEL.PIXELS), torch.arange(0, cfg.MODEL.HEIGHT, cfg.MODEL.PIXELS)), 0).to(motion.device).permute(0, 2, 1).reshape(2, -1).permute(1, 0)\n    grids = grids.unsqueeze(2).float()\n    projected_motion = torch.stack([x_motions, y_motions], 2).view(-1, 2, 1).to(motion.device)\n    redisual_kp_motion = new_points_projected - torch.cat([kp[1:2, :], kp[0:1, :]], 0)\n    motion[:2, :] = motion[:2, :] + motion[2:, :]\n    motion = motion.unsqueeze(0).repeat(grids.shape[0], 1, 1)\n    motion[:, :2, :] = (motion[:, :2, :] - grids) / cfg.MODEL.WIDTH\n    origin_motion = motion[:, 2:, :] / cfg.MODEL.FLOWC\n    motion[:, 2:, :] = (redisual_kp_motion.unsqueeze(0) - motion[:, 2:, :]) / cfg.MODEL.FLOWC\n    return (motion, projected_motion / cfg.MODEL.FLOWC, origin_motion)"
        ]
    },
    {
        "func_name": "f_rot",
        "original": "def f_rot(x):\n    return math.atan2(x[1], x[0]) / math.pi * 180",
        "mutated": [
            "def f_rot(x):\n    if False:\n        i = 10\n    return math.atan2(x[1], x[0]) / math.pi * 180",
            "def f_rot(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return math.atan2(x[1], x[0]) / math.pi * 180",
            "def f_rot(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return math.atan2(x[1], x[0]) / math.pi * 180",
            "def f_rot(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return math.atan2(x[1], x[0]) / math.pi * 180",
            "def f_rot(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return math.atan2(x[1], x[0]) / math.pi * 180"
        ]
    },
    {
        "func_name": "MotionDistanceMeasure",
        "original": "def MotionDistanceMeasure(motion1, motion2):\n    \"\"\"\n    MotionDistanceMeasure\n    @params motion1 np.array(2) (w, h)\n    @params motion2 np.array(2) (w, h)\n\n    @return bool describe whether the two motion are close or not, True for far and False for close\n    \"\"\"\n    mangnitue_motion1 = np.sqrt(np.sum(motion1 ** 2))\n    mangnitue_motion2 = np.sqrt(np.sum(motion2 ** 2))\n    diff_mangnitude = np.abs(mangnitue_motion1 - mangnitue_motion2)\n    rot_motion1 = f_rot(motion1)\n    rot_motion2 = f_rot(motion2)\n    diff_rot = np.abs(rot_motion1 - rot_motion2)\n    if diff_rot > 180:\n        diff_rot = 360 - diff_rot\n    temp_value_12 = diff_mangnitude >= cfg.Threshold.MANG\n    temp_value_13 = diff_rot >= cfg.Threshold.ROT\n    return temp_value_12 or temp_value_13",
        "mutated": [
            "def MotionDistanceMeasure(motion1, motion2):\n    if False:\n        i = 10\n    '\\n    MotionDistanceMeasure\\n    @params motion1 np.array(2) (w, h)\\n    @params motion2 np.array(2) (w, h)\\n\\n    @return bool describe whether the two motion are close or not, True for far and False for close\\n    '\n    mangnitue_motion1 = np.sqrt(np.sum(motion1 ** 2))\n    mangnitue_motion2 = np.sqrt(np.sum(motion2 ** 2))\n    diff_mangnitude = np.abs(mangnitue_motion1 - mangnitue_motion2)\n    rot_motion1 = f_rot(motion1)\n    rot_motion2 = f_rot(motion2)\n    diff_rot = np.abs(rot_motion1 - rot_motion2)\n    if diff_rot > 180:\n        diff_rot = 360 - diff_rot\n    temp_value_12 = diff_mangnitude >= cfg.Threshold.MANG\n    temp_value_13 = diff_rot >= cfg.Threshold.ROT\n    return temp_value_12 or temp_value_13",
            "def MotionDistanceMeasure(motion1, motion2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    MotionDistanceMeasure\\n    @params motion1 np.array(2) (w, h)\\n    @params motion2 np.array(2) (w, h)\\n\\n    @return bool describe whether the two motion are close or not, True for far and False for close\\n    '\n    mangnitue_motion1 = np.sqrt(np.sum(motion1 ** 2))\n    mangnitue_motion2 = np.sqrt(np.sum(motion2 ** 2))\n    diff_mangnitude = np.abs(mangnitue_motion1 - mangnitue_motion2)\n    rot_motion1 = f_rot(motion1)\n    rot_motion2 = f_rot(motion2)\n    diff_rot = np.abs(rot_motion1 - rot_motion2)\n    if diff_rot > 180:\n        diff_rot = 360 - diff_rot\n    temp_value_12 = diff_mangnitude >= cfg.Threshold.MANG\n    temp_value_13 = diff_rot >= cfg.Threshold.ROT\n    return temp_value_12 or temp_value_13",
            "def MotionDistanceMeasure(motion1, motion2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    MotionDistanceMeasure\\n    @params motion1 np.array(2) (w, h)\\n    @params motion2 np.array(2) (w, h)\\n\\n    @return bool describe whether the two motion are close or not, True for far and False for close\\n    '\n    mangnitue_motion1 = np.sqrt(np.sum(motion1 ** 2))\n    mangnitue_motion2 = np.sqrt(np.sum(motion2 ** 2))\n    diff_mangnitude = np.abs(mangnitue_motion1 - mangnitue_motion2)\n    rot_motion1 = f_rot(motion1)\n    rot_motion2 = f_rot(motion2)\n    diff_rot = np.abs(rot_motion1 - rot_motion2)\n    if diff_rot > 180:\n        diff_rot = 360 - diff_rot\n    temp_value_12 = diff_mangnitude >= cfg.Threshold.MANG\n    temp_value_13 = diff_rot >= cfg.Threshold.ROT\n    return temp_value_12 or temp_value_13",
            "def MotionDistanceMeasure(motion1, motion2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    MotionDistanceMeasure\\n    @params motion1 np.array(2) (w, h)\\n    @params motion2 np.array(2) (w, h)\\n\\n    @return bool describe whether the two motion are close or not, True for far and False for close\\n    '\n    mangnitue_motion1 = np.sqrt(np.sum(motion1 ** 2))\n    mangnitue_motion2 = np.sqrt(np.sum(motion2 ** 2))\n    diff_mangnitude = np.abs(mangnitue_motion1 - mangnitue_motion2)\n    rot_motion1 = f_rot(motion1)\n    rot_motion2 = f_rot(motion2)\n    diff_rot = np.abs(rot_motion1 - rot_motion2)\n    if diff_rot > 180:\n        diff_rot = 360 - diff_rot\n    temp_value_12 = diff_mangnitude >= cfg.Threshold.MANG\n    temp_value_13 = diff_rot >= cfg.Threshold.ROT\n    return temp_value_12 or temp_value_13",
            "def MotionDistanceMeasure(motion1, motion2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    MotionDistanceMeasure\\n    @params motion1 np.array(2) (w, h)\\n    @params motion2 np.array(2) (w, h)\\n\\n    @return bool describe whether the two motion are close or not, True for far and False for close\\n    '\n    mangnitue_motion1 = np.sqrt(np.sum(motion1 ** 2))\n    mangnitue_motion2 = np.sqrt(np.sum(motion2 ** 2))\n    diff_mangnitude = np.abs(mangnitue_motion1 - mangnitue_motion2)\n    rot_motion1 = f_rot(motion1)\n    rot_motion2 = f_rot(motion2)\n    diff_rot = np.abs(rot_motion1 - rot_motion2)\n    if diff_rot > 180:\n        diff_rot = 360 - diff_rot\n    temp_value_12 = diff_mangnitude >= cfg.Threshold.MANG\n    temp_value_13 = diff_rot >= cfg.Threshold.ROT\n    return temp_value_12 or temp_value_13"
        ]
    }
]