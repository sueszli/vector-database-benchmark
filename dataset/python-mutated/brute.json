[
    {
        "func_name": "_addPageTextWords",
        "original": "def _addPageTextWords():\n    wordsList = []\n    infoMsg = 'adding words used on web page to the check list'\n    logger.info(infoMsg)\n    pageWords = getPageWordSet(kb.originalPage)\n    for word in pageWords:\n        word = word.lower()\n        if len(word) > 2 and (not word[0].isdigit()) and (word not in wordsList):\n            wordsList.append(word)\n    return wordsList",
        "mutated": [
            "def _addPageTextWords():\n    if False:\n        i = 10\n    wordsList = []\n    infoMsg = 'adding words used on web page to the check list'\n    logger.info(infoMsg)\n    pageWords = getPageWordSet(kb.originalPage)\n    for word in pageWords:\n        word = word.lower()\n        if len(word) > 2 and (not word[0].isdigit()) and (word not in wordsList):\n            wordsList.append(word)\n    return wordsList",
            "def _addPageTextWords():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    wordsList = []\n    infoMsg = 'adding words used on web page to the check list'\n    logger.info(infoMsg)\n    pageWords = getPageWordSet(kb.originalPage)\n    for word in pageWords:\n        word = word.lower()\n        if len(word) > 2 and (not word[0].isdigit()) and (word not in wordsList):\n            wordsList.append(word)\n    return wordsList",
            "def _addPageTextWords():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    wordsList = []\n    infoMsg = 'adding words used on web page to the check list'\n    logger.info(infoMsg)\n    pageWords = getPageWordSet(kb.originalPage)\n    for word in pageWords:\n        word = word.lower()\n        if len(word) > 2 and (not word[0].isdigit()) and (word not in wordsList):\n            wordsList.append(word)\n    return wordsList",
            "def _addPageTextWords():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    wordsList = []\n    infoMsg = 'adding words used on web page to the check list'\n    logger.info(infoMsg)\n    pageWords = getPageWordSet(kb.originalPage)\n    for word in pageWords:\n        word = word.lower()\n        if len(word) > 2 and (not word[0].isdigit()) and (word not in wordsList):\n            wordsList.append(word)\n    return wordsList",
            "def _addPageTextWords():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    wordsList = []\n    infoMsg = 'adding words used on web page to the check list'\n    logger.info(infoMsg)\n    pageWords = getPageWordSet(kb.originalPage)\n    for word in pageWords:\n        word = word.lower()\n        if len(word) > 2 and (not word[0].isdigit()) and (word not in wordsList):\n            wordsList.append(word)\n    return wordsList"
        ]
    },
    {
        "func_name": "tableExistsThread",
        "original": "def tableExistsThread():\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n            fullTableName = '%s.%s' % (conf.db, table)\n        else:\n            fullTableName = table\n        if Backend.isDbms(DBMS.MCKOI):\n            _ = randomInt(1)\n            result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n        else:\n            result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n        kb.locks.io.acquire()\n        if result and table.lower() not in threadData.shared.unique:\n            threadData.shared.files.append(table)\n            threadData.shared.unique.add(table.lower())\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
        "mutated": [
            "def tableExistsThread():\n    if False:\n        i = 10\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n            fullTableName = '%s.%s' % (conf.db, table)\n        else:\n            fullTableName = table\n        if Backend.isDbms(DBMS.MCKOI):\n            _ = randomInt(1)\n            result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n        else:\n            result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n        kb.locks.io.acquire()\n        if result and table.lower() not in threadData.shared.unique:\n            threadData.shared.files.append(table)\n            threadData.shared.unique.add(table.lower())\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def tableExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n            fullTableName = '%s.%s' % (conf.db, table)\n        else:\n            fullTableName = table\n        if Backend.isDbms(DBMS.MCKOI):\n            _ = randomInt(1)\n            result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n        else:\n            result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n        kb.locks.io.acquire()\n        if result and table.lower() not in threadData.shared.unique:\n            threadData.shared.files.append(table)\n            threadData.shared.unique.add(table.lower())\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def tableExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n            fullTableName = '%s.%s' % (conf.db, table)\n        else:\n            fullTableName = table\n        if Backend.isDbms(DBMS.MCKOI):\n            _ = randomInt(1)\n            result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n        else:\n            result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n        kb.locks.io.acquire()\n        if result and table.lower() not in threadData.shared.unique:\n            threadData.shared.files.append(table)\n            threadData.shared.unique.add(table.lower())\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def tableExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n            fullTableName = '%s.%s' % (conf.db, table)\n        else:\n            fullTableName = table\n        if Backend.isDbms(DBMS.MCKOI):\n            _ = randomInt(1)\n            result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n        else:\n            result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n        kb.locks.io.acquire()\n        if result and table.lower() not in threadData.shared.unique:\n            threadData.shared.files.append(table)\n            threadData.shared.unique.add(table.lower())\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def tableExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n            fullTableName = '%s.%s' % (conf.db, table)\n        else:\n            fullTableName = table\n        if Backend.isDbms(DBMS.MCKOI):\n            _ = randomInt(1)\n            result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n        else:\n            result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n        kb.locks.io.acquire()\n        if result and table.lower() not in threadData.shared.unique:\n            threadData.shared.files.append(table)\n            threadData.shared.unique.add(table.lower())\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()"
        ]
    },
    {
        "func_name": "tableExists",
        "original": "@stackedmethod\ndef tableExists(tableFile, regex=None):\n    if kb.choices.tableExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common table existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.tableExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.tableExists:\n            return None\n    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), randomStr())))\n    if result:\n        errMsg = \"can't use table existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    pushValue(conf.db)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    message = 'which common tables (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % tableFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common tables file location?\\n\"\n        tableFile = readInput(message) or tableFile\n    infoMsg = \"performing table existence using items from '%s'\" % tableFile\n    logger.info(infoMsg)\n    tables = getFileItems(tableFile, lowercase=Backend.getIdentifiedDbms() in (DBMS.ACCESS,), unique=True)\n    tables.extend(_addPageTextWords())\n    tables = filterListValue(tables, regex)\n    for conf.db in conf.db.split(',') if conf.db else [conf.db]:\n        if conf.db and METADB_SUFFIX not in conf.db:\n            infoMsg = \"checking database '%s'\" % conf.db\n            logger.info(infoMsg)\n        threadData = getCurrentThreadData()\n        threadData.shared.count = 0\n        threadData.shared.limit = len(tables)\n        threadData.shared.files = []\n        threadData.shared.unique = set()\n\n        def tableExistsThread():\n            threadData = getCurrentThreadData()\n            while kb.threadContinue:\n                kb.locks.count.acquire()\n                if threadData.shared.count < threadData.shared.limit:\n                    table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n                    threadData.shared.count += 1\n                    kb.locks.count.release()\n                else:\n                    kb.locks.count.release()\n                    break\n                if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n                    fullTableName = '%s.%s' % (conf.db, table)\n                else:\n                    fullTableName = table\n                if Backend.isDbms(DBMS.MCKOI):\n                    _ = randomInt(1)\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n                else:\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n                kb.locks.io.acquire()\n                if result and table.lower() not in threadData.shared.unique:\n                    threadData.shared.files.append(table)\n                    threadData.shared.unique.add(table.lower())\n                    if conf.verbose in (1, 2) and (not conf.api):\n                        clearConsoleLine(True)\n                        infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                        dataToStdout(infoMsg, True)\n                if conf.verbose in (1, 2):\n                    status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                    dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n                kb.locks.io.release()\n        try:\n            runThreads(conf.threads, tableExistsThread, threadChoice=True)\n        except KeyboardInterrupt:\n            warnMsg = 'user aborted during table existence '\n            warnMsg += 'check. sqlmap will display partial output'\n            logger.warning(warnMsg)\n        clearConsoleLine(True)\n        dataToStdout('\\n')\n        if not threadData.shared.files:\n            warnMsg = 'no table(s) found'\n            if conf.db:\n                warnMsg += \" for database '%s'\" % conf.db\n            logger.warning(warnMsg)\n        else:\n            for item in threadData.shared.files:\n                if conf.db not in kb.data.cachedTables:\n                    kb.data.cachedTables[conf.db] = [item]\n                else:\n                    kb.data.cachedTables[conf.db].append(item)\n        for _ in ((conf.db, item) for item in threadData.shared.files):\n            if _ not in kb.brute.tables:\n                kb.brute.tables.append(_)\n    conf.db = popValue()\n    hashDBWrite(HASHDB_KEYS.KB_BRUTE_TABLES, kb.brute.tables, True)\n    return kb.data.cachedTables",
        "mutated": [
            "@stackedmethod\ndef tableExists(tableFile, regex=None):\n    if False:\n        i = 10\n    if kb.choices.tableExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common table existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.tableExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.tableExists:\n            return None\n    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), randomStr())))\n    if result:\n        errMsg = \"can't use table existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    pushValue(conf.db)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    message = 'which common tables (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % tableFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common tables file location?\\n\"\n        tableFile = readInput(message) or tableFile\n    infoMsg = \"performing table existence using items from '%s'\" % tableFile\n    logger.info(infoMsg)\n    tables = getFileItems(tableFile, lowercase=Backend.getIdentifiedDbms() in (DBMS.ACCESS,), unique=True)\n    tables.extend(_addPageTextWords())\n    tables = filterListValue(tables, regex)\n    for conf.db in conf.db.split(',') if conf.db else [conf.db]:\n        if conf.db and METADB_SUFFIX not in conf.db:\n            infoMsg = \"checking database '%s'\" % conf.db\n            logger.info(infoMsg)\n        threadData = getCurrentThreadData()\n        threadData.shared.count = 0\n        threadData.shared.limit = len(tables)\n        threadData.shared.files = []\n        threadData.shared.unique = set()\n\n        def tableExistsThread():\n            threadData = getCurrentThreadData()\n            while kb.threadContinue:\n                kb.locks.count.acquire()\n                if threadData.shared.count < threadData.shared.limit:\n                    table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n                    threadData.shared.count += 1\n                    kb.locks.count.release()\n                else:\n                    kb.locks.count.release()\n                    break\n                if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n                    fullTableName = '%s.%s' % (conf.db, table)\n                else:\n                    fullTableName = table\n                if Backend.isDbms(DBMS.MCKOI):\n                    _ = randomInt(1)\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n                else:\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n                kb.locks.io.acquire()\n                if result and table.lower() not in threadData.shared.unique:\n                    threadData.shared.files.append(table)\n                    threadData.shared.unique.add(table.lower())\n                    if conf.verbose in (1, 2) and (not conf.api):\n                        clearConsoleLine(True)\n                        infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                        dataToStdout(infoMsg, True)\n                if conf.verbose in (1, 2):\n                    status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                    dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n                kb.locks.io.release()\n        try:\n            runThreads(conf.threads, tableExistsThread, threadChoice=True)\n        except KeyboardInterrupt:\n            warnMsg = 'user aborted during table existence '\n            warnMsg += 'check. sqlmap will display partial output'\n            logger.warning(warnMsg)\n        clearConsoleLine(True)\n        dataToStdout('\\n')\n        if not threadData.shared.files:\n            warnMsg = 'no table(s) found'\n            if conf.db:\n                warnMsg += \" for database '%s'\" % conf.db\n            logger.warning(warnMsg)\n        else:\n            for item in threadData.shared.files:\n                if conf.db not in kb.data.cachedTables:\n                    kb.data.cachedTables[conf.db] = [item]\n                else:\n                    kb.data.cachedTables[conf.db].append(item)\n        for _ in ((conf.db, item) for item in threadData.shared.files):\n            if _ not in kb.brute.tables:\n                kb.brute.tables.append(_)\n    conf.db = popValue()\n    hashDBWrite(HASHDB_KEYS.KB_BRUTE_TABLES, kb.brute.tables, True)\n    return kb.data.cachedTables",
            "@stackedmethod\ndef tableExists(tableFile, regex=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if kb.choices.tableExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common table existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.tableExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.tableExists:\n            return None\n    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), randomStr())))\n    if result:\n        errMsg = \"can't use table existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    pushValue(conf.db)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    message = 'which common tables (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % tableFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common tables file location?\\n\"\n        tableFile = readInput(message) or tableFile\n    infoMsg = \"performing table existence using items from '%s'\" % tableFile\n    logger.info(infoMsg)\n    tables = getFileItems(tableFile, lowercase=Backend.getIdentifiedDbms() in (DBMS.ACCESS,), unique=True)\n    tables.extend(_addPageTextWords())\n    tables = filterListValue(tables, regex)\n    for conf.db in conf.db.split(',') if conf.db else [conf.db]:\n        if conf.db and METADB_SUFFIX not in conf.db:\n            infoMsg = \"checking database '%s'\" % conf.db\n            logger.info(infoMsg)\n        threadData = getCurrentThreadData()\n        threadData.shared.count = 0\n        threadData.shared.limit = len(tables)\n        threadData.shared.files = []\n        threadData.shared.unique = set()\n\n        def tableExistsThread():\n            threadData = getCurrentThreadData()\n            while kb.threadContinue:\n                kb.locks.count.acquire()\n                if threadData.shared.count < threadData.shared.limit:\n                    table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n                    threadData.shared.count += 1\n                    kb.locks.count.release()\n                else:\n                    kb.locks.count.release()\n                    break\n                if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n                    fullTableName = '%s.%s' % (conf.db, table)\n                else:\n                    fullTableName = table\n                if Backend.isDbms(DBMS.MCKOI):\n                    _ = randomInt(1)\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n                else:\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n                kb.locks.io.acquire()\n                if result and table.lower() not in threadData.shared.unique:\n                    threadData.shared.files.append(table)\n                    threadData.shared.unique.add(table.lower())\n                    if conf.verbose in (1, 2) and (not conf.api):\n                        clearConsoleLine(True)\n                        infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                        dataToStdout(infoMsg, True)\n                if conf.verbose in (1, 2):\n                    status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                    dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n                kb.locks.io.release()\n        try:\n            runThreads(conf.threads, tableExistsThread, threadChoice=True)\n        except KeyboardInterrupt:\n            warnMsg = 'user aborted during table existence '\n            warnMsg += 'check. sqlmap will display partial output'\n            logger.warning(warnMsg)\n        clearConsoleLine(True)\n        dataToStdout('\\n')\n        if not threadData.shared.files:\n            warnMsg = 'no table(s) found'\n            if conf.db:\n                warnMsg += \" for database '%s'\" % conf.db\n            logger.warning(warnMsg)\n        else:\n            for item in threadData.shared.files:\n                if conf.db not in kb.data.cachedTables:\n                    kb.data.cachedTables[conf.db] = [item]\n                else:\n                    kb.data.cachedTables[conf.db].append(item)\n        for _ in ((conf.db, item) for item in threadData.shared.files):\n            if _ not in kb.brute.tables:\n                kb.brute.tables.append(_)\n    conf.db = popValue()\n    hashDBWrite(HASHDB_KEYS.KB_BRUTE_TABLES, kb.brute.tables, True)\n    return kb.data.cachedTables",
            "@stackedmethod\ndef tableExists(tableFile, regex=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if kb.choices.tableExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common table existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.tableExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.tableExists:\n            return None\n    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), randomStr())))\n    if result:\n        errMsg = \"can't use table existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    pushValue(conf.db)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    message = 'which common tables (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % tableFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common tables file location?\\n\"\n        tableFile = readInput(message) or tableFile\n    infoMsg = \"performing table existence using items from '%s'\" % tableFile\n    logger.info(infoMsg)\n    tables = getFileItems(tableFile, lowercase=Backend.getIdentifiedDbms() in (DBMS.ACCESS,), unique=True)\n    tables.extend(_addPageTextWords())\n    tables = filterListValue(tables, regex)\n    for conf.db in conf.db.split(',') if conf.db else [conf.db]:\n        if conf.db and METADB_SUFFIX not in conf.db:\n            infoMsg = \"checking database '%s'\" % conf.db\n            logger.info(infoMsg)\n        threadData = getCurrentThreadData()\n        threadData.shared.count = 0\n        threadData.shared.limit = len(tables)\n        threadData.shared.files = []\n        threadData.shared.unique = set()\n\n        def tableExistsThread():\n            threadData = getCurrentThreadData()\n            while kb.threadContinue:\n                kb.locks.count.acquire()\n                if threadData.shared.count < threadData.shared.limit:\n                    table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n                    threadData.shared.count += 1\n                    kb.locks.count.release()\n                else:\n                    kb.locks.count.release()\n                    break\n                if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n                    fullTableName = '%s.%s' % (conf.db, table)\n                else:\n                    fullTableName = table\n                if Backend.isDbms(DBMS.MCKOI):\n                    _ = randomInt(1)\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n                else:\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n                kb.locks.io.acquire()\n                if result and table.lower() not in threadData.shared.unique:\n                    threadData.shared.files.append(table)\n                    threadData.shared.unique.add(table.lower())\n                    if conf.verbose in (1, 2) and (not conf.api):\n                        clearConsoleLine(True)\n                        infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                        dataToStdout(infoMsg, True)\n                if conf.verbose in (1, 2):\n                    status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                    dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n                kb.locks.io.release()\n        try:\n            runThreads(conf.threads, tableExistsThread, threadChoice=True)\n        except KeyboardInterrupt:\n            warnMsg = 'user aborted during table existence '\n            warnMsg += 'check. sqlmap will display partial output'\n            logger.warning(warnMsg)\n        clearConsoleLine(True)\n        dataToStdout('\\n')\n        if not threadData.shared.files:\n            warnMsg = 'no table(s) found'\n            if conf.db:\n                warnMsg += \" for database '%s'\" % conf.db\n            logger.warning(warnMsg)\n        else:\n            for item in threadData.shared.files:\n                if conf.db not in kb.data.cachedTables:\n                    kb.data.cachedTables[conf.db] = [item]\n                else:\n                    kb.data.cachedTables[conf.db].append(item)\n        for _ in ((conf.db, item) for item in threadData.shared.files):\n            if _ not in kb.brute.tables:\n                kb.brute.tables.append(_)\n    conf.db = popValue()\n    hashDBWrite(HASHDB_KEYS.KB_BRUTE_TABLES, kb.brute.tables, True)\n    return kb.data.cachedTables",
            "@stackedmethod\ndef tableExists(tableFile, regex=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if kb.choices.tableExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common table existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.tableExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.tableExists:\n            return None\n    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), randomStr())))\n    if result:\n        errMsg = \"can't use table existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    pushValue(conf.db)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    message = 'which common tables (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % tableFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common tables file location?\\n\"\n        tableFile = readInput(message) or tableFile\n    infoMsg = \"performing table existence using items from '%s'\" % tableFile\n    logger.info(infoMsg)\n    tables = getFileItems(tableFile, lowercase=Backend.getIdentifiedDbms() in (DBMS.ACCESS,), unique=True)\n    tables.extend(_addPageTextWords())\n    tables = filterListValue(tables, regex)\n    for conf.db in conf.db.split(',') if conf.db else [conf.db]:\n        if conf.db and METADB_SUFFIX not in conf.db:\n            infoMsg = \"checking database '%s'\" % conf.db\n            logger.info(infoMsg)\n        threadData = getCurrentThreadData()\n        threadData.shared.count = 0\n        threadData.shared.limit = len(tables)\n        threadData.shared.files = []\n        threadData.shared.unique = set()\n\n        def tableExistsThread():\n            threadData = getCurrentThreadData()\n            while kb.threadContinue:\n                kb.locks.count.acquire()\n                if threadData.shared.count < threadData.shared.limit:\n                    table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n                    threadData.shared.count += 1\n                    kb.locks.count.release()\n                else:\n                    kb.locks.count.release()\n                    break\n                if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n                    fullTableName = '%s.%s' % (conf.db, table)\n                else:\n                    fullTableName = table\n                if Backend.isDbms(DBMS.MCKOI):\n                    _ = randomInt(1)\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n                else:\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n                kb.locks.io.acquire()\n                if result and table.lower() not in threadData.shared.unique:\n                    threadData.shared.files.append(table)\n                    threadData.shared.unique.add(table.lower())\n                    if conf.verbose in (1, 2) and (not conf.api):\n                        clearConsoleLine(True)\n                        infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                        dataToStdout(infoMsg, True)\n                if conf.verbose in (1, 2):\n                    status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                    dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n                kb.locks.io.release()\n        try:\n            runThreads(conf.threads, tableExistsThread, threadChoice=True)\n        except KeyboardInterrupt:\n            warnMsg = 'user aborted during table existence '\n            warnMsg += 'check. sqlmap will display partial output'\n            logger.warning(warnMsg)\n        clearConsoleLine(True)\n        dataToStdout('\\n')\n        if not threadData.shared.files:\n            warnMsg = 'no table(s) found'\n            if conf.db:\n                warnMsg += \" for database '%s'\" % conf.db\n            logger.warning(warnMsg)\n        else:\n            for item in threadData.shared.files:\n                if conf.db not in kb.data.cachedTables:\n                    kb.data.cachedTables[conf.db] = [item]\n                else:\n                    kb.data.cachedTables[conf.db].append(item)\n        for _ in ((conf.db, item) for item in threadData.shared.files):\n            if _ not in kb.brute.tables:\n                kb.brute.tables.append(_)\n    conf.db = popValue()\n    hashDBWrite(HASHDB_KEYS.KB_BRUTE_TABLES, kb.brute.tables, True)\n    return kb.data.cachedTables",
            "@stackedmethod\ndef tableExists(tableFile, regex=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if kb.choices.tableExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common table existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.tableExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.tableExists:\n            return None\n    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), randomStr())))\n    if result:\n        errMsg = \"can't use table existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    pushValue(conf.db)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    message = 'which common tables (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % tableFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common tables file location?\\n\"\n        tableFile = readInput(message) or tableFile\n    infoMsg = \"performing table existence using items from '%s'\" % tableFile\n    logger.info(infoMsg)\n    tables = getFileItems(tableFile, lowercase=Backend.getIdentifiedDbms() in (DBMS.ACCESS,), unique=True)\n    tables.extend(_addPageTextWords())\n    tables = filterListValue(tables, regex)\n    for conf.db in conf.db.split(',') if conf.db else [conf.db]:\n        if conf.db and METADB_SUFFIX not in conf.db:\n            infoMsg = \"checking database '%s'\" % conf.db\n            logger.info(infoMsg)\n        threadData = getCurrentThreadData()\n        threadData.shared.count = 0\n        threadData.shared.limit = len(tables)\n        threadData.shared.files = []\n        threadData.shared.unique = set()\n\n        def tableExistsThread():\n            threadData = getCurrentThreadData()\n            while kb.threadContinue:\n                kb.locks.count.acquire()\n                if threadData.shared.count < threadData.shared.limit:\n                    table = safeSQLIdentificatorNaming(tables[threadData.shared.count], True)\n                    threadData.shared.count += 1\n                    kb.locks.count.release()\n                else:\n                    kb.locks.count.release()\n                    break\n                if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n                    fullTableName = '%s.%s' % (conf.db, table)\n                else:\n                    fullTableName = table\n                if Backend.isDbms(DBMS.MCKOI):\n                    _ = randomInt(1)\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat('%d=(SELECT %d FROM %s)', (_, _, fullTableName)))\n                else:\n                    result = inject.checkBooleanExpression('%s' % safeStringFormat(BRUTE_TABLE_EXISTS_TEMPLATE, (randomInt(1), fullTableName)))\n                kb.locks.io.acquire()\n                if result and table.lower() not in threadData.shared.unique:\n                    threadData.shared.files.append(table)\n                    threadData.shared.unique.add(table.lower())\n                    if conf.verbose in (1, 2) and (not conf.api):\n                        clearConsoleLine(True)\n                        infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(table))\n                        dataToStdout(infoMsg, True)\n                if conf.verbose in (1, 2):\n                    status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                    dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n                kb.locks.io.release()\n        try:\n            runThreads(conf.threads, tableExistsThread, threadChoice=True)\n        except KeyboardInterrupt:\n            warnMsg = 'user aborted during table existence '\n            warnMsg += 'check. sqlmap will display partial output'\n            logger.warning(warnMsg)\n        clearConsoleLine(True)\n        dataToStdout('\\n')\n        if not threadData.shared.files:\n            warnMsg = 'no table(s) found'\n            if conf.db:\n                warnMsg += \" for database '%s'\" % conf.db\n            logger.warning(warnMsg)\n        else:\n            for item in threadData.shared.files:\n                if conf.db not in kb.data.cachedTables:\n                    kb.data.cachedTables[conf.db] = [item]\n                else:\n                    kb.data.cachedTables[conf.db].append(item)\n        for _ in ((conf.db, item) for item in threadData.shared.files):\n            if _ not in kb.brute.tables:\n                kb.brute.tables.append(_)\n    conf.db = popValue()\n    hashDBWrite(HASHDB_KEYS.KB_BRUTE_TABLES, kb.brute.tables, True)\n    return kb.data.cachedTables"
        ]
    },
    {
        "func_name": "columnExistsThread",
        "original": "def columnExistsThread():\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if Backend.isDbms(DBMS.MCKOI):\n            result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n        else:\n            result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n        kb.locks.io.acquire()\n        if result:\n            threadData.shared.files.append(column)\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
        "mutated": [
            "def columnExistsThread():\n    if False:\n        i = 10\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if Backend.isDbms(DBMS.MCKOI):\n            result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n        else:\n            result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n        kb.locks.io.acquire()\n        if result:\n            threadData.shared.files.append(column)\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def columnExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if Backend.isDbms(DBMS.MCKOI):\n            result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n        else:\n            result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n        kb.locks.io.acquire()\n        if result:\n            threadData.shared.files.append(column)\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def columnExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if Backend.isDbms(DBMS.MCKOI):\n            result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n        else:\n            result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n        kb.locks.io.acquire()\n        if result:\n            threadData.shared.files.append(column)\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def columnExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if Backend.isDbms(DBMS.MCKOI):\n            result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n        else:\n            result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n        kb.locks.io.acquire()\n        if result:\n            threadData.shared.files.append(column)\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def columnExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        if Backend.isDbms(DBMS.MCKOI):\n            result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n        else:\n            result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n        kb.locks.io.acquire()\n        if result:\n            threadData.shared.files.append(column)\n            if conf.verbose in (1, 2) and (not conf.api):\n                clearConsoleLine(True)\n                infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()"
        ]
    },
    {
        "func_name": "columnExists",
        "original": "def columnExists(columnFile, regex=None):\n    if kb.choices.columnExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common column existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.columnExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.columnExists:\n            return None\n    if not conf.tbl:\n        errMsg = 'missing table parameter'\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (randomStr(), randomStr())))\n    if result:\n        errMsg = \"can't use column existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    message = 'which common columns (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % columnFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common columns file location?\\n\"\n        columnFile = readInput(message) or columnFile\n    infoMsg = \"checking column existence using items from '%s'\" % columnFile\n    logger.info(infoMsg)\n    columns = getFileItems(columnFile, unique=True)\n    columns.extend(_addPageTextWords())\n    columns = filterListValue(columns, regex)\n    table = safeSQLIdentificatorNaming(conf.tbl, True)\n    if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n        table = '%s.%s' % (safeSQLIdentificatorNaming(conf.db), table)\n    kb.threadContinue = True\n    kb.bruteMode = True\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(columns)\n    threadData.shared.files = []\n\n    def columnExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            if Backend.isDbms(DBMS.MCKOI):\n                result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n            else:\n                result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n            kb.locks.io.acquire()\n            if result:\n                threadData.shared.files.append(column)\n                if conf.verbose in (1, 2) and (not conf.api):\n                    clearConsoleLine(True)\n                    infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, columnExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during column existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no column(s) found'\n        logger.warning(warnMsg)\n    else:\n        columns = {}\n        for column in threadData.shared.files:\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                result = not inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s REGEXP '[^0-9]')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s NOT GLOB '*[^0-9]*')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.MCKOI,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('0=(SELECT MAX(%s)-MAX(%s) FROM %s)', (column, column, table)))\n            else:\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('EXISTS(SELECT %s FROM %s WHERE ROUND(%s)=ROUND(%s))', (column, table, column, column)))\n            if result:\n                columns[column] = 'numeric'\n            else:\n                columns[column] = 'non-numeric'\n        kb.data.cachedColumns[conf.db] = {conf.tbl: columns}\n        for _ in ((conf.db, conf.tbl, item[0], item[1]) for item in columns.items()):\n            if _ not in kb.brute.columns:\n                kb.brute.columns.append(_)\n        hashDBWrite(HASHDB_KEYS.KB_BRUTE_COLUMNS, kb.brute.columns, True)\n    return kb.data.cachedColumns",
        "mutated": [
            "def columnExists(columnFile, regex=None):\n    if False:\n        i = 10\n    if kb.choices.columnExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common column existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.columnExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.columnExists:\n            return None\n    if not conf.tbl:\n        errMsg = 'missing table parameter'\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (randomStr(), randomStr())))\n    if result:\n        errMsg = \"can't use column existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    message = 'which common columns (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % columnFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common columns file location?\\n\"\n        columnFile = readInput(message) or columnFile\n    infoMsg = \"checking column existence using items from '%s'\" % columnFile\n    logger.info(infoMsg)\n    columns = getFileItems(columnFile, unique=True)\n    columns.extend(_addPageTextWords())\n    columns = filterListValue(columns, regex)\n    table = safeSQLIdentificatorNaming(conf.tbl, True)\n    if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n        table = '%s.%s' % (safeSQLIdentificatorNaming(conf.db), table)\n    kb.threadContinue = True\n    kb.bruteMode = True\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(columns)\n    threadData.shared.files = []\n\n    def columnExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            if Backend.isDbms(DBMS.MCKOI):\n                result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n            else:\n                result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n            kb.locks.io.acquire()\n            if result:\n                threadData.shared.files.append(column)\n                if conf.verbose in (1, 2) and (not conf.api):\n                    clearConsoleLine(True)\n                    infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, columnExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during column existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no column(s) found'\n        logger.warning(warnMsg)\n    else:\n        columns = {}\n        for column in threadData.shared.files:\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                result = not inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s REGEXP '[^0-9]')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s NOT GLOB '*[^0-9]*')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.MCKOI,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('0=(SELECT MAX(%s)-MAX(%s) FROM %s)', (column, column, table)))\n            else:\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('EXISTS(SELECT %s FROM %s WHERE ROUND(%s)=ROUND(%s))', (column, table, column, column)))\n            if result:\n                columns[column] = 'numeric'\n            else:\n                columns[column] = 'non-numeric'\n        kb.data.cachedColumns[conf.db] = {conf.tbl: columns}\n        for _ in ((conf.db, conf.tbl, item[0], item[1]) for item in columns.items()):\n            if _ not in kb.brute.columns:\n                kb.brute.columns.append(_)\n        hashDBWrite(HASHDB_KEYS.KB_BRUTE_COLUMNS, kb.brute.columns, True)\n    return kb.data.cachedColumns",
            "def columnExists(columnFile, regex=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if kb.choices.columnExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common column existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.columnExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.columnExists:\n            return None\n    if not conf.tbl:\n        errMsg = 'missing table parameter'\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (randomStr(), randomStr())))\n    if result:\n        errMsg = \"can't use column existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    message = 'which common columns (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % columnFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common columns file location?\\n\"\n        columnFile = readInput(message) or columnFile\n    infoMsg = \"checking column existence using items from '%s'\" % columnFile\n    logger.info(infoMsg)\n    columns = getFileItems(columnFile, unique=True)\n    columns.extend(_addPageTextWords())\n    columns = filterListValue(columns, regex)\n    table = safeSQLIdentificatorNaming(conf.tbl, True)\n    if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n        table = '%s.%s' % (safeSQLIdentificatorNaming(conf.db), table)\n    kb.threadContinue = True\n    kb.bruteMode = True\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(columns)\n    threadData.shared.files = []\n\n    def columnExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            if Backend.isDbms(DBMS.MCKOI):\n                result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n            else:\n                result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n            kb.locks.io.acquire()\n            if result:\n                threadData.shared.files.append(column)\n                if conf.verbose in (1, 2) and (not conf.api):\n                    clearConsoleLine(True)\n                    infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, columnExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during column existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no column(s) found'\n        logger.warning(warnMsg)\n    else:\n        columns = {}\n        for column in threadData.shared.files:\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                result = not inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s REGEXP '[^0-9]')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s NOT GLOB '*[^0-9]*')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.MCKOI,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('0=(SELECT MAX(%s)-MAX(%s) FROM %s)', (column, column, table)))\n            else:\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('EXISTS(SELECT %s FROM %s WHERE ROUND(%s)=ROUND(%s))', (column, table, column, column)))\n            if result:\n                columns[column] = 'numeric'\n            else:\n                columns[column] = 'non-numeric'\n        kb.data.cachedColumns[conf.db] = {conf.tbl: columns}\n        for _ in ((conf.db, conf.tbl, item[0], item[1]) for item in columns.items()):\n            if _ not in kb.brute.columns:\n                kb.brute.columns.append(_)\n        hashDBWrite(HASHDB_KEYS.KB_BRUTE_COLUMNS, kb.brute.columns, True)\n    return kb.data.cachedColumns",
            "def columnExists(columnFile, regex=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if kb.choices.columnExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common column existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.columnExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.columnExists:\n            return None\n    if not conf.tbl:\n        errMsg = 'missing table parameter'\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (randomStr(), randomStr())))\n    if result:\n        errMsg = \"can't use column existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    message = 'which common columns (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % columnFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common columns file location?\\n\"\n        columnFile = readInput(message) or columnFile\n    infoMsg = \"checking column existence using items from '%s'\" % columnFile\n    logger.info(infoMsg)\n    columns = getFileItems(columnFile, unique=True)\n    columns.extend(_addPageTextWords())\n    columns = filterListValue(columns, regex)\n    table = safeSQLIdentificatorNaming(conf.tbl, True)\n    if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n        table = '%s.%s' % (safeSQLIdentificatorNaming(conf.db), table)\n    kb.threadContinue = True\n    kb.bruteMode = True\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(columns)\n    threadData.shared.files = []\n\n    def columnExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            if Backend.isDbms(DBMS.MCKOI):\n                result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n            else:\n                result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n            kb.locks.io.acquire()\n            if result:\n                threadData.shared.files.append(column)\n                if conf.verbose in (1, 2) and (not conf.api):\n                    clearConsoleLine(True)\n                    infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, columnExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during column existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no column(s) found'\n        logger.warning(warnMsg)\n    else:\n        columns = {}\n        for column in threadData.shared.files:\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                result = not inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s REGEXP '[^0-9]')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s NOT GLOB '*[^0-9]*')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.MCKOI,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('0=(SELECT MAX(%s)-MAX(%s) FROM %s)', (column, column, table)))\n            else:\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('EXISTS(SELECT %s FROM %s WHERE ROUND(%s)=ROUND(%s))', (column, table, column, column)))\n            if result:\n                columns[column] = 'numeric'\n            else:\n                columns[column] = 'non-numeric'\n        kb.data.cachedColumns[conf.db] = {conf.tbl: columns}\n        for _ in ((conf.db, conf.tbl, item[0], item[1]) for item in columns.items()):\n            if _ not in kb.brute.columns:\n                kb.brute.columns.append(_)\n        hashDBWrite(HASHDB_KEYS.KB_BRUTE_COLUMNS, kb.brute.columns, True)\n    return kb.data.cachedColumns",
            "def columnExists(columnFile, regex=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if kb.choices.columnExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common column existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.columnExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.columnExists:\n            return None\n    if not conf.tbl:\n        errMsg = 'missing table parameter'\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (randomStr(), randomStr())))\n    if result:\n        errMsg = \"can't use column existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    message = 'which common columns (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % columnFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common columns file location?\\n\"\n        columnFile = readInput(message) or columnFile\n    infoMsg = \"checking column existence using items from '%s'\" % columnFile\n    logger.info(infoMsg)\n    columns = getFileItems(columnFile, unique=True)\n    columns.extend(_addPageTextWords())\n    columns = filterListValue(columns, regex)\n    table = safeSQLIdentificatorNaming(conf.tbl, True)\n    if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n        table = '%s.%s' % (safeSQLIdentificatorNaming(conf.db), table)\n    kb.threadContinue = True\n    kb.bruteMode = True\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(columns)\n    threadData.shared.files = []\n\n    def columnExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            if Backend.isDbms(DBMS.MCKOI):\n                result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n            else:\n                result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n            kb.locks.io.acquire()\n            if result:\n                threadData.shared.files.append(column)\n                if conf.verbose in (1, 2) and (not conf.api):\n                    clearConsoleLine(True)\n                    infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, columnExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during column existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no column(s) found'\n        logger.warning(warnMsg)\n    else:\n        columns = {}\n        for column in threadData.shared.files:\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                result = not inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s REGEXP '[^0-9]')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s NOT GLOB '*[^0-9]*')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.MCKOI,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('0=(SELECT MAX(%s)-MAX(%s) FROM %s)', (column, column, table)))\n            else:\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('EXISTS(SELECT %s FROM %s WHERE ROUND(%s)=ROUND(%s))', (column, table, column, column)))\n            if result:\n                columns[column] = 'numeric'\n            else:\n                columns[column] = 'non-numeric'\n        kb.data.cachedColumns[conf.db] = {conf.tbl: columns}\n        for _ in ((conf.db, conf.tbl, item[0], item[1]) for item in columns.items()):\n            if _ not in kb.brute.columns:\n                kb.brute.columns.append(_)\n        hashDBWrite(HASHDB_KEYS.KB_BRUTE_COLUMNS, kb.brute.columns, True)\n    return kb.data.cachedColumns",
            "def columnExists(columnFile, regex=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if kb.choices.columnExists is None and (not any((_ for _ in kb.injection.data if _ not in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)))) and (not conf.direct):\n        warnMsg = \"it's not recommended to use '%s' and/or '%s' \" % (PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.TIME], PAYLOAD.SQLINJECTION[PAYLOAD.TECHNIQUE.STACKED])\n        warnMsg += 'for common column existence check'\n        logger.warning(warnMsg)\n        message = 'are you sure you want to continue? [y/N] '\n        kb.choices.columnExists = readInput(message, default='N', boolean=True)\n        if not kb.choices.columnExists:\n            return None\n    if not conf.tbl:\n        errMsg = 'missing table parameter'\n        raise SqlmapMissingMandatoryOptionException(errMsg)\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (randomStr(), randomStr())))\n    if result:\n        errMsg = \"can't use column existence check because of detected invalid results \"\n        errMsg += '(most likely caused by inability of the used injection '\n        errMsg += 'to distinguish erroneous results)'\n        raise SqlmapDataException(errMsg)\n    message = 'which common columns (wordlist) file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % columnFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common columns file location?\\n\"\n        columnFile = readInput(message) or columnFile\n    infoMsg = \"checking column existence using items from '%s'\" % columnFile\n    logger.info(infoMsg)\n    columns = getFileItems(columnFile, unique=True)\n    columns.extend(_addPageTextWords())\n    columns = filterListValue(columns, regex)\n    table = safeSQLIdentificatorNaming(conf.tbl, True)\n    if conf.db and METADB_SUFFIX not in conf.db and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD)):\n        table = '%s.%s' % (safeSQLIdentificatorNaming(conf.db), table)\n    kb.threadContinue = True\n    kb.bruteMode = True\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(columns)\n    threadData.shared.files = []\n\n    def columnExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                column = safeSQLIdentificatorNaming(columns[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            if Backend.isDbms(DBMS.MCKOI):\n                result = inject.checkBooleanExpression(safeStringFormat('0<(SELECT COUNT(%s) FROM %s)', (column, table)))\n            else:\n                result = inject.checkBooleanExpression(safeStringFormat(BRUTE_COLUMN_EXISTS_TEMPLATE, (column, table)))\n            kb.locks.io.acquire()\n            if result:\n                threadData.shared.files.append(column)\n                if conf.verbose in (1, 2) and (not conf.api):\n                    clearConsoleLine(True)\n                    infoMsg = '[%s] [INFO] retrieved: %s\\n' % (time.strftime('%X'), unsafeSQLIdentificatorNaming(column))\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, columnExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during column existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no column(s) found'\n        logger.warning(warnMsg)\n    else:\n        columns = {}\n        for column in threadData.shared.files:\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                result = not inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s REGEXP '[^0-9]')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat(\"EXISTS(SELECT %s FROM %s WHERE %s NOT GLOB '*[^0-9]*')\", (column, table, column)))\n            elif Backend.getIdentifiedDbms() in (DBMS.MCKOI,):\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('0=(SELECT MAX(%s)-MAX(%s) FROM %s)', (column, column, table)))\n            else:\n                result = inject.checkBooleanExpression('%s' % safeStringFormat('EXISTS(SELECT %s FROM %s WHERE ROUND(%s)=ROUND(%s))', (column, table, column, column)))\n            if result:\n                columns[column] = 'numeric'\n            else:\n                columns[column] = 'non-numeric'\n        kb.data.cachedColumns[conf.db] = {conf.tbl: columns}\n        for _ in ((conf.db, conf.tbl, item[0], item[1]) for item in columns.items()):\n            if _ not in kb.brute.columns:\n                kb.brute.columns.append(_)\n        hashDBWrite(HASHDB_KEYS.KB_BRUTE_COLUMNS, kb.brute.columns, True)\n    return kb.data.cachedColumns"
        ]
    },
    {
        "func_name": "fileExistsThread",
        "original": "def fileExistsThread():\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            path = ntToPosixSlashes(paths[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        try:\n            result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n        except SqlmapNoneDataException:\n            result = None\n        kb.locks.io.acquire()\n        if not isNoneValue(result):\n            threadData.shared.files.append(result)\n            if not conf.api:\n                clearConsoleLine(True)\n                infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
        "mutated": [
            "def fileExistsThread():\n    if False:\n        i = 10\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            path = ntToPosixSlashes(paths[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        try:\n            result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n        except SqlmapNoneDataException:\n            result = None\n        kb.locks.io.acquire()\n        if not isNoneValue(result):\n            threadData.shared.files.append(result)\n            if not conf.api:\n                clearConsoleLine(True)\n                infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def fileExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            path = ntToPosixSlashes(paths[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        try:\n            result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n        except SqlmapNoneDataException:\n            result = None\n        kb.locks.io.acquire()\n        if not isNoneValue(result):\n            threadData.shared.files.append(result)\n            if not conf.api:\n                clearConsoleLine(True)\n                infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def fileExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            path = ntToPosixSlashes(paths[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        try:\n            result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n        except SqlmapNoneDataException:\n            result = None\n        kb.locks.io.acquire()\n        if not isNoneValue(result):\n            threadData.shared.files.append(result)\n            if not conf.api:\n                clearConsoleLine(True)\n                infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def fileExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            path = ntToPosixSlashes(paths[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        try:\n            result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n        except SqlmapNoneDataException:\n            result = None\n        kb.locks.io.acquire()\n        if not isNoneValue(result):\n            threadData.shared.files.append(result)\n            if not conf.api:\n                clearConsoleLine(True)\n                infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()",
            "def fileExistsThread():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    threadData = getCurrentThreadData()\n    while kb.threadContinue:\n        kb.locks.count.acquire()\n        if threadData.shared.count < threadData.shared.limit:\n            path = ntToPosixSlashes(paths[threadData.shared.count])\n            threadData.shared.count += 1\n            kb.locks.count.release()\n        else:\n            kb.locks.count.release()\n            break\n        try:\n            result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n        except SqlmapNoneDataException:\n            result = None\n        kb.locks.io.acquire()\n        if not isNoneValue(result):\n            threadData.shared.files.append(result)\n            if not conf.api:\n                clearConsoleLine(True)\n                infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                dataToStdout(infoMsg, True)\n        if conf.verbose in (1, 2):\n            status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n            dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n        kb.locks.io.release()"
        ]
    },
    {
        "func_name": "fileExists",
        "original": "@stackedmethod\ndef fileExists(pathFile):\n    retVal = []\n    message = 'which common files file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % pathFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common files file location?\\n\"\n        pathFile = readInput(message) or pathFile\n    infoMsg = \"checking files existence using items from '%s'\" % pathFile\n    logger.info(infoMsg)\n    paths = getFileItems(pathFile, unique=True)\n    kb.bruteMode = True\n    try:\n        conf.dbmsHandler.readFile(randomStr())\n    except SqlmapNoneDataException:\n        pass\n    except:\n        kb.bruteMode = False\n        raise\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(paths)\n    threadData.shared.files = []\n\n    def fileExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                path = ntToPosixSlashes(paths[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            try:\n                result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n            except SqlmapNoneDataException:\n                result = None\n            kb.locks.io.acquire()\n            if not isNoneValue(result):\n                threadData.shared.files.append(result)\n                if not conf.api:\n                    clearConsoleLine(True)\n                    infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, fileExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during file existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no file(s) found'\n        logger.warning(warnMsg)\n    else:\n        retVal = threadData.shared.files\n    return retVal",
        "mutated": [
            "@stackedmethod\ndef fileExists(pathFile):\n    if False:\n        i = 10\n    retVal = []\n    message = 'which common files file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % pathFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common files file location?\\n\"\n        pathFile = readInput(message) or pathFile\n    infoMsg = \"checking files existence using items from '%s'\" % pathFile\n    logger.info(infoMsg)\n    paths = getFileItems(pathFile, unique=True)\n    kb.bruteMode = True\n    try:\n        conf.dbmsHandler.readFile(randomStr())\n    except SqlmapNoneDataException:\n        pass\n    except:\n        kb.bruteMode = False\n        raise\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(paths)\n    threadData.shared.files = []\n\n    def fileExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                path = ntToPosixSlashes(paths[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            try:\n                result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n            except SqlmapNoneDataException:\n                result = None\n            kb.locks.io.acquire()\n            if not isNoneValue(result):\n                threadData.shared.files.append(result)\n                if not conf.api:\n                    clearConsoleLine(True)\n                    infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, fileExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during file existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no file(s) found'\n        logger.warning(warnMsg)\n    else:\n        retVal = threadData.shared.files\n    return retVal",
            "@stackedmethod\ndef fileExists(pathFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    retVal = []\n    message = 'which common files file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % pathFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common files file location?\\n\"\n        pathFile = readInput(message) or pathFile\n    infoMsg = \"checking files existence using items from '%s'\" % pathFile\n    logger.info(infoMsg)\n    paths = getFileItems(pathFile, unique=True)\n    kb.bruteMode = True\n    try:\n        conf.dbmsHandler.readFile(randomStr())\n    except SqlmapNoneDataException:\n        pass\n    except:\n        kb.bruteMode = False\n        raise\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(paths)\n    threadData.shared.files = []\n\n    def fileExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                path = ntToPosixSlashes(paths[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            try:\n                result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n            except SqlmapNoneDataException:\n                result = None\n            kb.locks.io.acquire()\n            if not isNoneValue(result):\n                threadData.shared.files.append(result)\n                if not conf.api:\n                    clearConsoleLine(True)\n                    infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, fileExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during file existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no file(s) found'\n        logger.warning(warnMsg)\n    else:\n        retVal = threadData.shared.files\n    return retVal",
            "@stackedmethod\ndef fileExists(pathFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    retVal = []\n    message = 'which common files file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % pathFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common files file location?\\n\"\n        pathFile = readInput(message) or pathFile\n    infoMsg = \"checking files existence using items from '%s'\" % pathFile\n    logger.info(infoMsg)\n    paths = getFileItems(pathFile, unique=True)\n    kb.bruteMode = True\n    try:\n        conf.dbmsHandler.readFile(randomStr())\n    except SqlmapNoneDataException:\n        pass\n    except:\n        kb.bruteMode = False\n        raise\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(paths)\n    threadData.shared.files = []\n\n    def fileExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                path = ntToPosixSlashes(paths[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            try:\n                result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n            except SqlmapNoneDataException:\n                result = None\n            kb.locks.io.acquire()\n            if not isNoneValue(result):\n                threadData.shared.files.append(result)\n                if not conf.api:\n                    clearConsoleLine(True)\n                    infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, fileExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during file existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no file(s) found'\n        logger.warning(warnMsg)\n    else:\n        retVal = threadData.shared.files\n    return retVal",
            "@stackedmethod\ndef fileExists(pathFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    retVal = []\n    message = 'which common files file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % pathFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common files file location?\\n\"\n        pathFile = readInput(message) or pathFile\n    infoMsg = \"checking files existence using items from '%s'\" % pathFile\n    logger.info(infoMsg)\n    paths = getFileItems(pathFile, unique=True)\n    kb.bruteMode = True\n    try:\n        conf.dbmsHandler.readFile(randomStr())\n    except SqlmapNoneDataException:\n        pass\n    except:\n        kb.bruteMode = False\n        raise\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(paths)\n    threadData.shared.files = []\n\n    def fileExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                path = ntToPosixSlashes(paths[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            try:\n                result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n            except SqlmapNoneDataException:\n                result = None\n            kb.locks.io.acquire()\n            if not isNoneValue(result):\n                threadData.shared.files.append(result)\n                if not conf.api:\n                    clearConsoleLine(True)\n                    infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, fileExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during file existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no file(s) found'\n        logger.warning(warnMsg)\n    else:\n        retVal = threadData.shared.files\n    return retVal",
            "@stackedmethod\ndef fileExists(pathFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    retVal = []\n    message = 'which common files file do you want to use?\\n'\n    message += \"[1] default '%s' (press Enter)\\n\" % pathFile\n    message += '[2] custom'\n    choice = readInput(message, default='1')\n    if choice == '2':\n        message = \"what's the custom common files file location?\\n\"\n        pathFile = readInput(message) or pathFile\n    infoMsg = \"checking files existence using items from '%s'\" % pathFile\n    logger.info(infoMsg)\n    paths = getFileItems(pathFile, unique=True)\n    kb.bruteMode = True\n    try:\n        conf.dbmsHandler.readFile(randomStr())\n    except SqlmapNoneDataException:\n        pass\n    except:\n        kb.bruteMode = False\n        raise\n    threadData = getCurrentThreadData()\n    threadData.shared.count = 0\n    threadData.shared.limit = len(paths)\n    threadData.shared.files = []\n\n    def fileExistsThread():\n        threadData = getCurrentThreadData()\n        while kb.threadContinue:\n            kb.locks.count.acquire()\n            if threadData.shared.count < threadData.shared.limit:\n                path = ntToPosixSlashes(paths[threadData.shared.count])\n                threadData.shared.count += 1\n                kb.locks.count.release()\n            else:\n                kb.locks.count.release()\n                break\n            try:\n                result = unArrayizeValue(conf.dbmsHandler.readFile(path))\n            except SqlmapNoneDataException:\n                result = None\n            kb.locks.io.acquire()\n            if not isNoneValue(result):\n                threadData.shared.files.append(result)\n                if not conf.api:\n                    clearConsoleLine(True)\n                    infoMsg = \"[%s] [INFO] retrieved: '%s'\\n\" % (time.strftime('%X'), path)\n                    dataToStdout(infoMsg, True)\n            if conf.verbose in (1, 2):\n                status = '%d/%d items (%d%%)' % (threadData.shared.count, threadData.shared.limit, round(100.0 * threadData.shared.count / threadData.shared.limit))\n                dataToStdout('\\r[%s] [INFO] tried %s' % (time.strftime('%X'), status), True)\n            kb.locks.io.release()\n    try:\n        runThreads(conf.threads, fileExistsThread, threadChoice=True)\n    except KeyboardInterrupt:\n        warnMsg = 'user aborted during file existence '\n        warnMsg += 'check. sqlmap will display partial output'\n        logger.warning(warnMsg)\n    finally:\n        kb.bruteMode = False\n    clearConsoleLine(True)\n    dataToStdout('\\n')\n    if not threadData.shared.files:\n        warnMsg = 'no file(s) found'\n        logger.warning(warnMsg)\n    else:\n        retVal = threadData.shared.files\n    return retVal"
        ]
    }
]