[
    {
        "func_name": "__init__",
        "original": "def __init__(self, show_asm=False):\n    super(Scanner26, self).__init__((2, 6), show_asm)\n    self.setup_ops = frozenset([self.opc.SETUP_EXCEPT, self.opc.SETUP_FINALLY])\n    return",
        "mutated": [
            "def __init__(self, show_asm=False):\n    if False:\n        i = 10\n    super(Scanner26, self).__init__((2, 6), show_asm)\n    self.setup_ops = frozenset([self.opc.SETUP_EXCEPT, self.opc.SETUP_FINALLY])\n    return",
            "def __init__(self, show_asm=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(Scanner26, self).__init__((2, 6), show_asm)\n    self.setup_ops = frozenset([self.opc.SETUP_EXCEPT, self.opc.SETUP_FINALLY])\n    return",
            "def __init__(self, show_asm=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(Scanner26, self).__init__((2, 6), show_asm)\n    self.setup_ops = frozenset([self.opc.SETUP_EXCEPT, self.opc.SETUP_FINALLY])\n    return",
            "def __init__(self, show_asm=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(Scanner26, self).__init__((2, 6), show_asm)\n    self.setup_ops = frozenset([self.opc.SETUP_EXCEPT, self.opc.SETUP_FINALLY])\n    return",
            "def __init__(self, show_asm=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(Scanner26, self).__init__((2, 6), show_asm)\n    self.setup_ops = frozenset([self.opc.SETUP_EXCEPT, self.opc.SETUP_FINALLY])\n    return"
        ]
    },
    {
        "func_name": "ingest",
        "original": "def ingest(self, co, classname=None, code_objects={}, show_asm=None):\n    \"\"\"Create \"tokens\" the bytecode of an Python code object. Largely these\n        are the opcode name, but in some cases that has been modified to make parsing\n        easier.\n        returning a list of uncompyle6 Token's.\n\n        Some transformations are made to assist the deparsing grammar:\n           -  various types of LOAD_CONST's are categorized in terms of what they load\n           -  COME_FROM instructions are added to assist parsing control structures\n           -  operands with stack argument counts or flag masks are appended to the\n              opcode name, e.g.:\n              *  BUILD_LIST, BUILD_SET\n              *  MAKE_FUNCTION and FUNCTION_CALLS append the number of positional\n                 arguments\n           -  EXTENDED_ARGS instructions are removed\n\n        Also, when we encounter certain tokens, we add them to a set\n        which will cause custom grammar rules. Specifically, variable\n        arg tokens like MAKE_FUNCTION or BUILD_LIST cause specific\n        rules for the specific number of arguments they take.\n        \"\"\"\n    if not show_asm:\n        show_asm = self.show_asm\n    bytecode = self.build_instructions(co)\n    if show_asm in ('both', 'before'):\n        for instr in bytecode.get_instructions(co):\n            print(instr.disassemble())\n    tokens = []\n    customize = {}\n    if self.is_pypy:\n        customize['PyPy'] = 0\n    codelen = len(self.code)\n    (free, names, varnames) = self.unmangle_code_names(co, classname)\n    self.names = names\n    self.load_asserts = set()\n    for i in self.op_range(0, codelen):\n        if self.code[i] == self.opc.JUMP_IF_TRUE and i + 4 < codelen and (self.code[i + 3] == self.opc.POP_TOP) and (self.code[i + 4] == self.opc.LOAD_GLOBAL):\n            if names[self.get_argument(i + 4)] == 'AssertionError':\n                self.load_asserts.add(i + 4)\n    jump_targets = self.find_jump_targets(show_asm)\n    last_stmt = self.next_stmt[0]\n    i = self.next_stmt[last_stmt]\n    replace = {}\n    while i < codelen - 1:\n        if self.lines and self.lines[last_stmt].next > i:\n            if self.code[last_stmt] == self.opc.PRINT_ITEM:\n                if self.code[i] == self.opc.PRINT_ITEM:\n                    replace[i] = 'PRINT_ITEM_CONT'\n                elif self.code[i] == self.opc.PRINT_NEWLINE:\n                    replace[i] = 'PRINT_NEWLINE_CONT'\n        last_stmt = i\n        i = self.next_stmt[i]\n    extended_arg = 0\n    i = -1\n    for offset in self.op_range(0, codelen):\n        i += 1\n        op = self.code[offset]\n        op_name = self.opname[op]\n        oparg = None\n        pattr = None\n        if offset in jump_targets:\n            jump_idx = 0\n            last_jump_offset = -1\n            for jump_offset in sorted(jump_targets[offset], reverse=True):\n                if jump_offset != last_jump_offset:\n                    tokens.append(Token('COME_FROM', jump_offset, repr(jump_offset), offset='%s_%d' % (offset, jump_idx), has_arg=True))\n                    jump_idx += 1\n                    last_jump_offset = jump_offset\n        elif offset in self.thens:\n            tokens.append(Token('THEN', None, self.thens[offset], offset='%s_0' % offset, has_arg=True))\n        has_arg = op >= self.opc.HAVE_ARGUMENT\n        if has_arg:\n            oparg = self.get_argument(offset) + extended_arg\n            extended_arg = 0\n            if op == self.opc.EXTENDED_ARG:\n                extended_arg += self.extended_arg_val(oparg)\n                continue\n            if op_name in ('BUILD_LIST', 'BUILD_SET'):\n                t = Token(op_name, oparg, pattr, offset, self.linestarts.get(offset, None), op, has_arg, self.opc)\n                collection_type = op_name.split('_')[1]\n                next_tokens = self.bound_collection_from_tokens(tokens, t, len(tokens), 'CONST_%s' % collection_type)\n                if next_tokens is not None:\n                    tokens = next_tokens\n                    continue\n            if op in self.opc.CONST_OPS:\n                const = co.co_consts[oparg]\n                if iscode(const):\n                    oparg = const\n                    if const.co_name == '<lambda>':\n                        assert op_name == 'LOAD_CONST'\n                        op_name = 'LOAD_LAMBDA'\n                    elif const.co_name == self.genexpr_name:\n                        op_name = 'LOAD_GENEXPR'\n                    elif const.co_name == '<dictcomp>':\n                        op_name = 'LOAD_DICTCOMP'\n                    elif const.co_name == '<setcomp>':\n                        op_name = 'LOAD_SETCOMP'\n                    else:\n                        op_name = 'LOAD_CODE'\n                    pattr = '<code_object ' + const.co_name + '>'\n                else:\n                    if oparg < len(co.co_consts):\n                        (argval, _) = _get_const_info(oparg, co.co_consts)\n                    pattr = const\n                    pass\n            elif op in self.opc.NAME_OPS:\n                pattr = names[oparg]\n            elif op in self.opc.JREL_OPS:\n                pattr = repr(offset + 3 + oparg)\n                if op == self.opc.JUMP_FORWARD:\n                    target = self.get_target(offset)\n                    if len(tokens) and tokens[-1].kind == 'JUMP_BACK':\n                        tokens[-1].kind = intern('CONTINUE')\n            elif op in self.opc.JABS_OPS:\n                pattr = repr(oparg)\n            elif op in self.opc.LOCAL_OPS:\n                if self.version < (1, 5):\n                    pattr = names[oparg]\n                else:\n                    pattr = varnames[oparg]\n            elif op in self.opc.COMPARE_OPS:\n                pattr = self.opc.cmp_op[oparg]\n            elif op in self.opc.FREE_OPS:\n                pattr = free[oparg]\n        if op in self.varargs_ops:\n            if self.version >= (2, 5) and op == self.opc.BUILD_TUPLE and (self.code[self.prev[offset]] == self.opc.LOAD_CLOSURE):\n                continue\n            else:\n                op_name = '%s_%d' % (op_name, oparg)\n                customize[op_name] = oparg\n        elif self.version > (2, 0) and op == self.opc.CONTINUE_LOOP:\n            customize[op_name] = 0\n        elif op_name in '\\n                 CONTINUE_LOOP EXEC_STMT LOAD_LISTCOMP LOAD_SETCOMP\\n                  '.split():\n            customize[op_name] = 0\n        elif op == self.opc.JUMP_ABSOLUTE:\n            target = self.get_target(offset)\n            if target <= offset:\n                op_name = 'JUMP_BACK'\n                if offset in self.stmts and self.code[offset + 3] not in (self.opc.END_FINALLY, self.opc.POP_BLOCK):\n                    if offset in self.linestarts and tokens[-1].kind == 'JUMP_BACK' or offset not in self.not_continue:\n                        op_name = 'CONTINUE'\n                elif tokens[-1].kind == 'JUMP_BACK':\n                    tokens[-1].kind = intern('CONTINUE')\n        elif op == self.opc.LOAD_GLOBAL:\n            if offset in self.load_asserts:\n                op_name = 'LOAD_ASSERT'\n        elif op == self.opc.RETURN_VALUE:\n            if offset in self.return_end_ifs:\n                op_name = 'RETURN_END_IF'\n        linestart = self.linestarts.get(offset, None)\n        if offset not in replace:\n            tokens.append(Token(op_name, oparg, pattr, offset, linestart, op, has_arg, self.opc))\n        else:\n            tokens.append(Token(replace[offset], oparg, pattr, offset, linestart, op, has_arg, self.opc))\n            pass\n        pass\n    if show_asm in ('both', 'after'):\n        for t in tokens:\n            print(t.format(line_prefix=''))\n        print()\n    return (tokens, customize)",
        "mutated": [
            "def ingest(self, co, classname=None, code_objects={}, show_asm=None):\n    if False:\n        i = 10\n    'Create \"tokens\" the bytecode of an Python code object. Largely these\\n        are the opcode name, but in some cases that has been modified to make parsing\\n        easier.\\n        returning a list of uncompyle6 Token\\'s.\\n\\n        Some transformations are made to assist the deparsing grammar:\\n           -  various types of LOAD_CONST\\'s are categorized in terms of what they load\\n           -  COME_FROM instructions are added to assist parsing control structures\\n           -  operands with stack argument counts or flag masks are appended to the\\n              opcode name, e.g.:\\n              *  BUILD_LIST, BUILD_SET\\n              *  MAKE_FUNCTION and FUNCTION_CALLS append the number of positional\\n                 arguments\\n           -  EXTENDED_ARGS instructions are removed\\n\\n        Also, when we encounter certain tokens, we add them to a set\\n        which will cause custom grammar rules. Specifically, variable\\n        arg tokens like MAKE_FUNCTION or BUILD_LIST cause specific\\n        rules for the specific number of arguments they take.\\n        '\n    if not show_asm:\n        show_asm = self.show_asm\n    bytecode = self.build_instructions(co)\n    if show_asm in ('both', 'before'):\n        for instr in bytecode.get_instructions(co):\n            print(instr.disassemble())\n    tokens = []\n    customize = {}\n    if self.is_pypy:\n        customize['PyPy'] = 0\n    codelen = len(self.code)\n    (free, names, varnames) = self.unmangle_code_names(co, classname)\n    self.names = names\n    self.load_asserts = set()\n    for i in self.op_range(0, codelen):\n        if self.code[i] == self.opc.JUMP_IF_TRUE and i + 4 < codelen and (self.code[i + 3] == self.opc.POP_TOP) and (self.code[i + 4] == self.opc.LOAD_GLOBAL):\n            if names[self.get_argument(i + 4)] == 'AssertionError':\n                self.load_asserts.add(i + 4)\n    jump_targets = self.find_jump_targets(show_asm)\n    last_stmt = self.next_stmt[0]\n    i = self.next_stmt[last_stmt]\n    replace = {}\n    while i < codelen - 1:\n        if self.lines and self.lines[last_stmt].next > i:\n            if self.code[last_stmt] == self.opc.PRINT_ITEM:\n                if self.code[i] == self.opc.PRINT_ITEM:\n                    replace[i] = 'PRINT_ITEM_CONT'\n                elif self.code[i] == self.opc.PRINT_NEWLINE:\n                    replace[i] = 'PRINT_NEWLINE_CONT'\n        last_stmt = i\n        i = self.next_stmt[i]\n    extended_arg = 0\n    i = -1\n    for offset in self.op_range(0, codelen):\n        i += 1\n        op = self.code[offset]\n        op_name = self.opname[op]\n        oparg = None\n        pattr = None\n        if offset in jump_targets:\n            jump_idx = 0\n            last_jump_offset = -1\n            for jump_offset in sorted(jump_targets[offset], reverse=True):\n                if jump_offset != last_jump_offset:\n                    tokens.append(Token('COME_FROM', jump_offset, repr(jump_offset), offset='%s_%d' % (offset, jump_idx), has_arg=True))\n                    jump_idx += 1\n                    last_jump_offset = jump_offset\n        elif offset in self.thens:\n            tokens.append(Token('THEN', None, self.thens[offset], offset='%s_0' % offset, has_arg=True))\n        has_arg = op >= self.opc.HAVE_ARGUMENT\n        if has_arg:\n            oparg = self.get_argument(offset) + extended_arg\n            extended_arg = 0\n            if op == self.opc.EXTENDED_ARG:\n                extended_arg += self.extended_arg_val(oparg)\n                continue\n            if op_name in ('BUILD_LIST', 'BUILD_SET'):\n                t = Token(op_name, oparg, pattr, offset, self.linestarts.get(offset, None), op, has_arg, self.opc)\n                collection_type = op_name.split('_')[1]\n                next_tokens = self.bound_collection_from_tokens(tokens, t, len(tokens), 'CONST_%s' % collection_type)\n                if next_tokens is not None:\n                    tokens = next_tokens\n                    continue\n            if op in self.opc.CONST_OPS:\n                const = co.co_consts[oparg]\n                if iscode(const):\n                    oparg = const\n                    if const.co_name == '<lambda>':\n                        assert op_name == 'LOAD_CONST'\n                        op_name = 'LOAD_LAMBDA'\n                    elif const.co_name == self.genexpr_name:\n                        op_name = 'LOAD_GENEXPR'\n                    elif const.co_name == '<dictcomp>':\n                        op_name = 'LOAD_DICTCOMP'\n                    elif const.co_name == '<setcomp>':\n                        op_name = 'LOAD_SETCOMP'\n                    else:\n                        op_name = 'LOAD_CODE'\n                    pattr = '<code_object ' + const.co_name + '>'\n                else:\n                    if oparg < len(co.co_consts):\n                        (argval, _) = _get_const_info(oparg, co.co_consts)\n                    pattr = const\n                    pass\n            elif op in self.opc.NAME_OPS:\n                pattr = names[oparg]\n            elif op in self.opc.JREL_OPS:\n                pattr = repr(offset + 3 + oparg)\n                if op == self.opc.JUMP_FORWARD:\n                    target = self.get_target(offset)\n                    if len(tokens) and tokens[-1].kind == 'JUMP_BACK':\n                        tokens[-1].kind = intern('CONTINUE')\n            elif op in self.opc.JABS_OPS:\n                pattr = repr(oparg)\n            elif op in self.opc.LOCAL_OPS:\n                if self.version < (1, 5):\n                    pattr = names[oparg]\n                else:\n                    pattr = varnames[oparg]\n            elif op in self.opc.COMPARE_OPS:\n                pattr = self.opc.cmp_op[oparg]\n            elif op in self.opc.FREE_OPS:\n                pattr = free[oparg]\n        if op in self.varargs_ops:\n            if self.version >= (2, 5) and op == self.opc.BUILD_TUPLE and (self.code[self.prev[offset]] == self.opc.LOAD_CLOSURE):\n                continue\n            else:\n                op_name = '%s_%d' % (op_name, oparg)\n                customize[op_name] = oparg\n        elif self.version > (2, 0) and op == self.opc.CONTINUE_LOOP:\n            customize[op_name] = 0\n        elif op_name in '\\n                 CONTINUE_LOOP EXEC_STMT LOAD_LISTCOMP LOAD_SETCOMP\\n                  '.split():\n            customize[op_name] = 0\n        elif op == self.opc.JUMP_ABSOLUTE:\n            target = self.get_target(offset)\n            if target <= offset:\n                op_name = 'JUMP_BACK'\n                if offset in self.stmts and self.code[offset + 3] not in (self.opc.END_FINALLY, self.opc.POP_BLOCK):\n                    if offset in self.linestarts and tokens[-1].kind == 'JUMP_BACK' or offset not in self.not_continue:\n                        op_name = 'CONTINUE'\n                elif tokens[-1].kind == 'JUMP_BACK':\n                    tokens[-1].kind = intern('CONTINUE')\n        elif op == self.opc.LOAD_GLOBAL:\n            if offset in self.load_asserts:\n                op_name = 'LOAD_ASSERT'\n        elif op == self.opc.RETURN_VALUE:\n            if offset in self.return_end_ifs:\n                op_name = 'RETURN_END_IF'\n        linestart = self.linestarts.get(offset, None)\n        if offset not in replace:\n            tokens.append(Token(op_name, oparg, pattr, offset, linestart, op, has_arg, self.opc))\n        else:\n            tokens.append(Token(replace[offset], oparg, pattr, offset, linestart, op, has_arg, self.opc))\n            pass\n        pass\n    if show_asm in ('both', 'after'):\n        for t in tokens:\n            print(t.format(line_prefix=''))\n        print()\n    return (tokens, customize)",
            "def ingest(self, co, classname=None, code_objects={}, show_asm=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create \"tokens\" the bytecode of an Python code object. Largely these\\n        are the opcode name, but in some cases that has been modified to make parsing\\n        easier.\\n        returning a list of uncompyle6 Token\\'s.\\n\\n        Some transformations are made to assist the deparsing grammar:\\n           -  various types of LOAD_CONST\\'s are categorized in terms of what they load\\n           -  COME_FROM instructions are added to assist parsing control structures\\n           -  operands with stack argument counts or flag masks are appended to the\\n              opcode name, e.g.:\\n              *  BUILD_LIST, BUILD_SET\\n              *  MAKE_FUNCTION and FUNCTION_CALLS append the number of positional\\n                 arguments\\n           -  EXTENDED_ARGS instructions are removed\\n\\n        Also, when we encounter certain tokens, we add them to a set\\n        which will cause custom grammar rules. Specifically, variable\\n        arg tokens like MAKE_FUNCTION or BUILD_LIST cause specific\\n        rules for the specific number of arguments they take.\\n        '\n    if not show_asm:\n        show_asm = self.show_asm\n    bytecode = self.build_instructions(co)\n    if show_asm in ('both', 'before'):\n        for instr in bytecode.get_instructions(co):\n            print(instr.disassemble())\n    tokens = []\n    customize = {}\n    if self.is_pypy:\n        customize['PyPy'] = 0\n    codelen = len(self.code)\n    (free, names, varnames) = self.unmangle_code_names(co, classname)\n    self.names = names\n    self.load_asserts = set()\n    for i in self.op_range(0, codelen):\n        if self.code[i] == self.opc.JUMP_IF_TRUE and i + 4 < codelen and (self.code[i + 3] == self.opc.POP_TOP) and (self.code[i + 4] == self.opc.LOAD_GLOBAL):\n            if names[self.get_argument(i + 4)] == 'AssertionError':\n                self.load_asserts.add(i + 4)\n    jump_targets = self.find_jump_targets(show_asm)\n    last_stmt = self.next_stmt[0]\n    i = self.next_stmt[last_stmt]\n    replace = {}\n    while i < codelen - 1:\n        if self.lines and self.lines[last_stmt].next > i:\n            if self.code[last_stmt] == self.opc.PRINT_ITEM:\n                if self.code[i] == self.opc.PRINT_ITEM:\n                    replace[i] = 'PRINT_ITEM_CONT'\n                elif self.code[i] == self.opc.PRINT_NEWLINE:\n                    replace[i] = 'PRINT_NEWLINE_CONT'\n        last_stmt = i\n        i = self.next_stmt[i]\n    extended_arg = 0\n    i = -1\n    for offset in self.op_range(0, codelen):\n        i += 1\n        op = self.code[offset]\n        op_name = self.opname[op]\n        oparg = None\n        pattr = None\n        if offset in jump_targets:\n            jump_idx = 0\n            last_jump_offset = -1\n            for jump_offset in sorted(jump_targets[offset], reverse=True):\n                if jump_offset != last_jump_offset:\n                    tokens.append(Token('COME_FROM', jump_offset, repr(jump_offset), offset='%s_%d' % (offset, jump_idx), has_arg=True))\n                    jump_idx += 1\n                    last_jump_offset = jump_offset\n        elif offset in self.thens:\n            tokens.append(Token('THEN', None, self.thens[offset], offset='%s_0' % offset, has_arg=True))\n        has_arg = op >= self.opc.HAVE_ARGUMENT\n        if has_arg:\n            oparg = self.get_argument(offset) + extended_arg\n            extended_arg = 0\n            if op == self.opc.EXTENDED_ARG:\n                extended_arg += self.extended_arg_val(oparg)\n                continue\n            if op_name in ('BUILD_LIST', 'BUILD_SET'):\n                t = Token(op_name, oparg, pattr, offset, self.linestarts.get(offset, None), op, has_arg, self.opc)\n                collection_type = op_name.split('_')[1]\n                next_tokens = self.bound_collection_from_tokens(tokens, t, len(tokens), 'CONST_%s' % collection_type)\n                if next_tokens is not None:\n                    tokens = next_tokens\n                    continue\n            if op in self.opc.CONST_OPS:\n                const = co.co_consts[oparg]\n                if iscode(const):\n                    oparg = const\n                    if const.co_name == '<lambda>':\n                        assert op_name == 'LOAD_CONST'\n                        op_name = 'LOAD_LAMBDA'\n                    elif const.co_name == self.genexpr_name:\n                        op_name = 'LOAD_GENEXPR'\n                    elif const.co_name == '<dictcomp>':\n                        op_name = 'LOAD_DICTCOMP'\n                    elif const.co_name == '<setcomp>':\n                        op_name = 'LOAD_SETCOMP'\n                    else:\n                        op_name = 'LOAD_CODE'\n                    pattr = '<code_object ' + const.co_name + '>'\n                else:\n                    if oparg < len(co.co_consts):\n                        (argval, _) = _get_const_info(oparg, co.co_consts)\n                    pattr = const\n                    pass\n            elif op in self.opc.NAME_OPS:\n                pattr = names[oparg]\n            elif op in self.opc.JREL_OPS:\n                pattr = repr(offset + 3 + oparg)\n                if op == self.opc.JUMP_FORWARD:\n                    target = self.get_target(offset)\n                    if len(tokens) and tokens[-1].kind == 'JUMP_BACK':\n                        tokens[-1].kind = intern('CONTINUE')\n            elif op in self.opc.JABS_OPS:\n                pattr = repr(oparg)\n            elif op in self.opc.LOCAL_OPS:\n                if self.version < (1, 5):\n                    pattr = names[oparg]\n                else:\n                    pattr = varnames[oparg]\n            elif op in self.opc.COMPARE_OPS:\n                pattr = self.opc.cmp_op[oparg]\n            elif op in self.opc.FREE_OPS:\n                pattr = free[oparg]\n        if op in self.varargs_ops:\n            if self.version >= (2, 5) and op == self.opc.BUILD_TUPLE and (self.code[self.prev[offset]] == self.opc.LOAD_CLOSURE):\n                continue\n            else:\n                op_name = '%s_%d' % (op_name, oparg)\n                customize[op_name] = oparg\n        elif self.version > (2, 0) and op == self.opc.CONTINUE_LOOP:\n            customize[op_name] = 0\n        elif op_name in '\\n                 CONTINUE_LOOP EXEC_STMT LOAD_LISTCOMP LOAD_SETCOMP\\n                  '.split():\n            customize[op_name] = 0\n        elif op == self.opc.JUMP_ABSOLUTE:\n            target = self.get_target(offset)\n            if target <= offset:\n                op_name = 'JUMP_BACK'\n                if offset in self.stmts and self.code[offset + 3] not in (self.opc.END_FINALLY, self.opc.POP_BLOCK):\n                    if offset in self.linestarts and tokens[-1].kind == 'JUMP_BACK' or offset not in self.not_continue:\n                        op_name = 'CONTINUE'\n                elif tokens[-1].kind == 'JUMP_BACK':\n                    tokens[-1].kind = intern('CONTINUE')\n        elif op == self.opc.LOAD_GLOBAL:\n            if offset in self.load_asserts:\n                op_name = 'LOAD_ASSERT'\n        elif op == self.opc.RETURN_VALUE:\n            if offset in self.return_end_ifs:\n                op_name = 'RETURN_END_IF'\n        linestart = self.linestarts.get(offset, None)\n        if offset not in replace:\n            tokens.append(Token(op_name, oparg, pattr, offset, linestart, op, has_arg, self.opc))\n        else:\n            tokens.append(Token(replace[offset], oparg, pattr, offset, linestart, op, has_arg, self.opc))\n            pass\n        pass\n    if show_asm in ('both', 'after'):\n        for t in tokens:\n            print(t.format(line_prefix=''))\n        print()\n    return (tokens, customize)",
            "def ingest(self, co, classname=None, code_objects={}, show_asm=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create \"tokens\" the bytecode of an Python code object. Largely these\\n        are the opcode name, but in some cases that has been modified to make parsing\\n        easier.\\n        returning a list of uncompyle6 Token\\'s.\\n\\n        Some transformations are made to assist the deparsing grammar:\\n           -  various types of LOAD_CONST\\'s are categorized in terms of what they load\\n           -  COME_FROM instructions are added to assist parsing control structures\\n           -  operands with stack argument counts or flag masks are appended to the\\n              opcode name, e.g.:\\n              *  BUILD_LIST, BUILD_SET\\n              *  MAKE_FUNCTION and FUNCTION_CALLS append the number of positional\\n                 arguments\\n           -  EXTENDED_ARGS instructions are removed\\n\\n        Also, when we encounter certain tokens, we add them to a set\\n        which will cause custom grammar rules. Specifically, variable\\n        arg tokens like MAKE_FUNCTION or BUILD_LIST cause specific\\n        rules for the specific number of arguments they take.\\n        '\n    if not show_asm:\n        show_asm = self.show_asm\n    bytecode = self.build_instructions(co)\n    if show_asm in ('both', 'before'):\n        for instr in bytecode.get_instructions(co):\n            print(instr.disassemble())\n    tokens = []\n    customize = {}\n    if self.is_pypy:\n        customize['PyPy'] = 0\n    codelen = len(self.code)\n    (free, names, varnames) = self.unmangle_code_names(co, classname)\n    self.names = names\n    self.load_asserts = set()\n    for i in self.op_range(0, codelen):\n        if self.code[i] == self.opc.JUMP_IF_TRUE and i + 4 < codelen and (self.code[i + 3] == self.opc.POP_TOP) and (self.code[i + 4] == self.opc.LOAD_GLOBAL):\n            if names[self.get_argument(i + 4)] == 'AssertionError':\n                self.load_asserts.add(i + 4)\n    jump_targets = self.find_jump_targets(show_asm)\n    last_stmt = self.next_stmt[0]\n    i = self.next_stmt[last_stmt]\n    replace = {}\n    while i < codelen - 1:\n        if self.lines and self.lines[last_stmt].next > i:\n            if self.code[last_stmt] == self.opc.PRINT_ITEM:\n                if self.code[i] == self.opc.PRINT_ITEM:\n                    replace[i] = 'PRINT_ITEM_CONT'\n                elif self.code[i] == self.opc.PRINT_NEWLINE:\n                    replace[i] = 'PRINT_NEWLINE_CONT'\n        last_stmt = i\n        i = self.next_stmt[i]\n    extended_arg = 0\n    i = -1\n    for offset in self.op_range(0, codelen):\n        i += 1\n        op = self.code[offset]\n        op_name = self.opname[op]\n        oparg = None\n        pattr = None\n        if offset in jump_targets:\n            jump_idx = 0\n            last_jump_offset = -1\n            for jump_offset in sorted(jump_targets[offset], reverse=True):\n                if jump_offset != last_jump_offset:\n                    tokens.append(Token('COME_FROM', jump_offset, repr(jump_offset), offset='%s_%d' % (offset, jump_idx), has_arg=True))\n                    jump_idx += 1\n                    last_jump_offset = jump_offset\n        elif offset in self.thens:\n            tokens.append(Token('THEN', None, self.thens[offset], offset='%s_0' % offset, has_arg=True))\n        has_arg = op >= self.opc.HAVE_ARGUMENT\n        if has_arg:\n            oparg = self.get_argument(offset) + extended_arg\n            extended_arg = 0\n            if op == self.opc.EXTENDED_ARG:\n                extended_arg += self.extended_arg_val(oparg)\n                continue\n            if op_name in ('BUILD_LIST', 'BUILD_SET'):\n                t = Token(op_name, oparg, pattr, offset, self.linestarts.get(offset, None), op, has_arg, self.opc)\n                collection_type = op_name.split('_')[1]\n                next_tokens = self.bound_collection_from_tokens(tokens, t, len(tokens), 'CONST_%s' % collection_type)\n                if next_tokens is not None:\n                    tokens = next_tokens\n                    continue\n            if op in self.opc.CONST_OPS:\n                const = co.co_consts[oparg]\n                if iscode(const):\n                    oparg = const\n                    if const.co_name == '<lambda>':\n                        assert op_name == 'LOAD_CONST'\n                        op_name = 'LOAD_LAMBDA'\n                    elif const.co_name == self.genexpr_name:\n                        op_name = 'LOAD_GENEXPR'\n                    elif const.co_name == '<dictcomp>':\n                        op_name = 'LOAD_DICTCOMP'\n                    elif const.co_name == '<setcomp>':\n                        op_name = 'LOAD_SETCOMP'\n                    else:\n                        op_name = 'LOAD_CODE'\n                    pattr = '<code_object ' + const.co_name + '>'\n                else:\n                    if oparg < len(co.co_consts):\n                        (argval, _) = _get_const_info(oparg, co.co_consts)\n                    pattr = const\n                    pass\n            elif op in self.opc.NAME_OPS:\n                pattr = names[oparg]\n            elif op in self.opc.JREL_OPS:\n                pattr = repr(offset + 3 + oparg)\n                if op == self.opc.JUMP_FORWARD:\n                    target = self.get_target(offset)\n                    if len(tokens) and tokens[-1].kind == 'JUMP_BACK':\n                        tokens[-1].kind = intern('CONTINUE')\n            elif op in self.opc.JABS_OPS:\n                pattr = repr(oparg)\n            elif op in self.opc.LOCAL_OPS:\n                if self.version < (1, 5):\n                    pattr = names[oparg]\n                else:\n                    pattr = varnames[oparg]\n            elif op in self.opc.COMPARE_OPS:\n                pattr = self.opc.cmp_op[oparg]\n            elif op in self.opc.FREE_OPS:\n                pattr = free[oparg]\n        if op in self.varargs_ops:\n            if self.version >= (2, 5) and op == self.opc.BUILD_TUPLE and (self.code[self.prev[offset]] == self.opc.LOAD_CLOSURE):\n                continue\n            else:\n                op_name = '%s_%d' % (op_name, oparg)\n                customize[op_name] = oparg\n        elif self.version > (2, 0) and op == self.opc.CONTINUE_LOOP:\n            customize[op_name] = 0\n        elif op_name in '\\n                 CONTINUE_LOOP EXEC_STMT LOAD_LISTCOMP LOAD_SETCOMP\\n                  '.split():\n            customize[op_name] = 0\n        elif op == self.opc.JUMP_ABSOLUTE:\n            target = self.get_target(offset)\n            if target <= offset:\n                op_name = 'JUMP_BACK'\n                if offset in self.stmts and self.code[offset + 3] not in (self.opc.END_FINALLY, self.opc.POP_BLOCK):\n                    if offset in self.linestarts and tokens[-1].kind == 'JUMP_BACK' or offset not in self.not_continue:\n                        op_name = 'CONTINUE'\n                elif tokens[-1].kind == 'JUMP_BACK':\n                    tokens[-1].kind = intern('CONTINUE')\n        elif op == self.opc.LOAD_GLOBAL:\n            if offset in self.load_asserts:\n                op_name = 'LOAD_ASSERT'\n        elif op == self.opc.RETURN_VALUE:\n            if offset in self.return_end_ifs:\n                op_name = 'RETURN_END_IF'\n        linestart = self.linestarts.get(offset, None)\n        if offset not in replace:\n            tokens.append(Token(op_name, oparg, pattr, offset, linestart, op, has_arg, self.opc))\n        else:\n            tokens.append(Token(replace[offset], oparg, pattr, offset, linestart, op, has_arg, self.opc))\n            pass\n        pass\n    if show_asm in ('both', 'after'):\n        for t in tokens:\n            print(t.format(line_prefix=''))\n        print()\n    return (tokens, customize)",
            "def ingest(self, co, classname=None, code_objects={}, show_asm=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create \"tokens\" the bytecode of an Python code object. Largely these\\n        are the opcode name, but in some cases that has been modified to make parsing\\n        easier.\\n        returning a list of uncompyle6 Token\\'s.\\n\\n        Some transformations are made to assist the deparsing grammar:\\n           -  various types of LOAD_CONST\\'s are categorized in terms of what they load\\n           -  COME_FROM instructions are added to assist parsing control structures\\n           -  operands with stack argument counts or flag masks are appended to the\\n              opcode name, e.g.:\\n              *  BUILD_LIST, BUILD_SET\\n              *  MAKE_FUNCTION and FUNCTION_CALLS append the number of positional\\n                 arguments\\n           -  EXTENDED_ARGS instructions are removed\\n\\n        Also, when we encounter certain tokens, we add them to a set\\n        which will cause custom grammar rules. Specifically, variable\\n        arg tokens like MAKE_FUNCTION or BUILD_LIST cause specific\\n        rules for the specific number of arguments they take.\\n        '\n    if not show_asm:\n        show_asm = self.show_asm\n    bytecode = self.build_instructions(co)\n    if show_asm in ('both', 'before'):\n        for instr in bytecode.get_instructions(co):\n            print(instr.disassemble())\n    tokens = []\n    customize = {}\n    if self.is_pypy:\n        customize['PyPy'] = 0\n    codelen = len(self.code)\n    (free, names, varnames) = self.unmangle_code_names(co, classname)\n    self.names = names\n    self.load_asserts = set()\n    for i in self.op_range(0, codelen):\n        if self.code[i] == self.opc.JUMP_IF_TRUE and i + 4 < codelen and (self.code[i + 3] == self.opc.POP_TOP) and (self.code[i + 4] == self.opc.LOAD_GLOBAL):\n            if names[self.get_argument(i + 4)] == 'AssertionError':\n                self.load_asserts.add(i + 4)\n    jump_targets = self.find_jump_targets(show_asm)\n    last_stmt = self.next_stmt[0]\n    i = self.next_stmt[last_stmt]\n    replace = {}\n    while i < codelen - 1:\n        if self.lines and self.lines[last_stmt].next > i:\n            if self.code[last_stmt] == self.opc.PRINT_ITEM:\n                if self.code[i] == self.opc.PRINT_ITEM:\n                    replace[i] = 'PRINT_ITEM_CONT'\n                elif self.code[i] == self.opc.PRINT_NEWLINE:\n                    replace[i] = 'PRINT_NEWLINE_CONT'\n        last_stmt = i\n        i = self.next_stmt[i]\n    extended_arg = 0\n    i = -1\n    for offset in self.op_range(0, codelen):\n        i += 1\n        op = self.code[offset]\n        op_name = self.opname[op]\n        oparg = None\n        pattr = None\n        if offset in jump_targets:\n            jump_idx = 0\n            last_jump_offset = -1\n            for jump_offset in sorted(jump_targets[offset], reverse=True):\n                if jump_offset != last_jump_offset:\n                    tokens.append(Token('COME_FROM', jump_offset, repr(jump_offset), offset='%s_%d' % (offset, jump_idx), has_arg=True))\n                    jump_idx += 1\n                    last_jump_offset = jump_offset\n        elif offset in self.thens:\n            tokens.append(Token('THEN', None, self.thens[offset], offset='%s_0' % offset, has_arg=True))\n        has_arg = op >= self.opc.HAVE_ARGUMENT\n        if has_arg:\n            oparg = self.get_argument(offset) + extended_arg\n            extended_arg = 0\n            if op == self.opc.EXTENDED_ARG:\n                extended_arg += self.extended_arg_val(oparg)\n                continue\n            if op_name in ('BUILD_LIST', 'BUILD_SET'):\n                t = Token(op_name, oparg, pattr, offset, self.linestarts.get(offset, None), op, has_arg, self.opc)\n                collection_type = op_name.split('_')[1]\n                next_tokens = self.bound_collection_from_tokens(tokens, t, len(tokens), 'CONST_%s' % collection_type)\n                if next_tokens is not None:\n                    tokens = next_tokens\n                    continue\n            if op in self.opc.CONST_OPS:\n                const = co.co_consts[oparg]\n                if iscode(const):\n                    oparg = const\n                    if const.co_name == '<lambda>':\n                        assert op_name == 'LOAD_CONST'\n                        op_name = 'LOAD_LAMBDA'\n                    elif const.co_name == self.genexpr_name:\n                        op_name = 'LOAD_GENEXPR'\n                    elif const.co_name == '<dictcomp>':\n                        op_name = 'LOAD_DICTCOMP'\n                    elif const.co_name == '<setcomp>':\n                        op_name = 'LOAD_SETCOMP'\n                    else:\n                        op_name = 'LOAD_CODE'\n                    pattr = '<code_object ' + const.co_name + '>'\n                else:\n                    if oparg < len(co.co_consts):\n                        (argval, _) = _get_const_info(oparg, co.co_consts)\n                    pattr = const\n                    pass\n            elif op in self.opc.NAME_OPS:\n                pattr = names[oparg]\n            elif op in self.opc.JREL_OPS:\n                pattr = repr(offset + 3 + oparg)\n                if op == self.opc.JUMP_FORWARD:\n                    target = self.get_target(offset)\n                    if len(tokens) and tokens[-1].kind == 'JUMP_BACK':\n                        tokens[-1].kind = intern('CONTINUE')\n            elif op in self.opc.JABS_OPS:\n                pattr = repr(oparg)\n            elif op in self.opc.LOCAL_OPS:\n                if self.version < (1, 5):\n                    pattr = names[oparg]\n                else:\n                    pattr = varnames[oparg]\n            elif op in self.opc.COMPARE_OPS:\n                pattr = self.opc.cmp_op[oparg]\n            elif op in self.opc.FREE_OPS:\n                pattr = free[oparg]\n        if op in self.varargs_ops:\n            if self.version >= (2, 5) and op == self.opc.BUILD_TUPLE and (self.code[self.prev[offset]] == self.opc.LOAD_CLOSURE):\n                continue\n            else:\n                op_name = '%s_%d' % (op_name, oparg)\n                customize[op_name] = oparg\n        elif self.version > (2, 0) and op == self.opc.CONTINUE_LOOP:\n            customize[op_name] = 0\n        elif op_name in '\\n                 CONTINUE_LOOP EXEC_STMT LOAD_LISTCOMP LOAD_SETCOMP\\n                  '.split():\n            customize[op_name] = 0\n        elif op == self.opc.JUMP_ABSOLUTE:\n            target = self.get_target(offset)\n            if target <= offset:\n                op_name = 'JUMP_BACK'\n                if offset in self.stmts and self.code[offset + 3] not in (self.opc.END_FINALLY, self.opc.POP_BLOCK):\n                    if offset in self.linestarts and tokens[-1].kind == 'JUMP_BACK' or offset not in self.not_continue:\n                        op_name = 'CONTINUE'\n                elif tokens[-1].kind == 'JUMP_BACK':\n                    tokens[-1].kind = intern('CONTINUE')\n        elif op == self.opc.LOAD_GLOBAL:\n            if offset in self.load_asserts:\n                op_name = 'LOAD_ASSERT'\n        elif op == self.opc.RETURN_VALUE:\n            if offset in self.return_end_ifs:\n                op_name = 'RETURN_END_IF'\n        linestart = self.linestarts.get(offset, None)\n        if offset not in replace:\n            tokens.append(Token(op_name, oparg, pattr, offset, linestart, op, has_arg, self.opc))\n        else:\n            tokens.append(Token(replace[offset], oparg, pattr, offset, linestart, op, has_arg, self.opc))\n            pass\n        pass\n    if show_asm in ('both', 'after'):\n        for t in tokens:\n            print(t.format(line_prefix=''))\n        print()\n    return (tokens, customize)",
            "def ingest(self, co, classname=None, code_objects={}, show_asm=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create \"tokens\" the bytecode of an Python code object. Largely these\\n        are the opcode name, but in some cases that has been modified to make parsing\\n        easier.\\n        returning a list of uncompyle6 Token\\'s.\\n\\n        Some transformations are made to assist the deparsing grammar:\\n           -  various types of LOAD_CONST\\'s are categorized in terms of what they load\\n           -  COME_FROM instructions are added to assist parsing control structures\\n           -  operands with stack argument counts or flag masks are appended to the\\n              opcode name, e.g.:\\n              *  BUILD_LIST, BUILD_SET\\n              *  MAKE_FUNCTION and FUNCTION_CALLS append the number of positional\\n                 arguments\\n           -  EXTENDED_ARGS instructions are removed\\n\\n        Also, when we encounter certain tokens, we add them to a set\\n        which will cause custom grammar rules. Specifically, variable\\n        arg tokens like MAKE_FUNCTION or BUILD_LIST cause specific\\n        rules for the specific number of arguments they take.\\n        '\n    if not show_asm:\n        show_asm = self.show_asm\n    bytecode = self.build_instructions(co)\n    if show_asm in ('both', 'before'):\n        for instr in bytecode.get_instructions(co):\n            print(instr.disassemble())\n    tokens = []\n    customize = {}\n    if self.is_pypy:\n        customize['PyPy'] = 0\n    codelen = len(self.code)\n    (free, names, varnames) = self.unmangle_code_names(co, classname)\n    self.names = names\n    self.load_asserts = set()\n    for i in self.op_range(0, codelen):\n        if self.code[i] == self.opc.JUMP_IF_TRUE and i + 4 < codelen and (self.code[i + 3] == self.opc.POP_TOP) and (self.code[i + 4] == self.opc.LOAD_GLOBAL):\n            if names[self.get_argument(i + 4)] == 'AssertionError':\n                self.load_asserts.add(i + 4)\n    jump_targets = self.find_jump_targets(show_asm)\n    last_stmt = self.next_stmt[0]\n    i = self.next_stmt[last_stmt]\n    replace = {}\n    while i < codelen - 1:\n        if self.lines and self.lines[last_stmt].next > i:\n            if self.code[last_stmt] == self.opc.PRINT_ITEM:\n                if self.code[i] == self.opc.PRINT_ITEM:\n                    replace[i] = 'PRINT_ITEM_CONT'\n                elif self.code[i] == self.opc.PRINT_NEWLINE:\n                    replace[i] = 'PRINT_NEWLINE_CONT'\n        last_stmt = i\n        i = self.next_stmt[i]\n    extended_arg = 0\n    i = -1\n    for offset in self.op_range(0, codelen):\n        i += 1\n        op = self.code[offset]\n        op_name = self.opname[op]\n        oparg = None\n        pattr = None\n        if offset in jump_targets:\n            jump_idx = 0\n            last_jump_offset = -1\n            for jump_offset in sorted(jump_targets[offset], reverse=True):\n                if jump_offset != last_jump_offset:\n                    tokens.append(Token('COME_FROM', jump_offset, repr(jump_offset), offset='%s_%d' % (offset, jump_idx), has_arg=True))\n                    jump_idx += 1\n                    last_jump_offset = jump_offset\n        elif offset in self.thens:\n            tokens.append(Token('THEN', None, self.thens[offset], offset='%s_0' % offset, has_arg=True))\n        has_arg = op >= self.opc.HAVE_ARGUMENT\n        if has_arg:\n            oparg = self.get_argument(offset) + extended_arg\n            extended_arg = 0\n            if op == self.opc.EXTENDED_ARG:\n                extended_arg += self.extended_arg_val(oparg)\n                continue\n            if op_name in ('BUILD_LIST', 'BUILD_SET'):\n                t = Token(op_name, oparg, pattr, offset, self.linestarts.get(offset, None), op, has_arg, self.opc)\n                collection_type = op_name.split('_')[1]\n                next_tokens = self.bound_collection_from_tokens(tokens, t, len(tokens), 'CONST_%s' % collection_type)\n                if next_tokens is not None:\n                    tokens = next_tokens\n                    continue\n            if op in self.opc.CONST_OPS:\n                const = co.co_consts[oparg]\n                if iscode(const):\n                    oparg = const\n                    if const.co_name == '<lambda>':\n                        assert op_name == 'LOAD_CONST'\n                        op_name = 'LOAD_LAMBDA'\n                    elif const.co_name == self.genexpr_name:\n                        op_name = 'LOAD_GENEXPR'\n                    elif const.co_name == '<dictcomp>':\n                        op_name = 'LOAD_DICTCOMP'\n                    elif const.co_name == '<setcomp>':\n                        op_name = 'LOAD_SETCOMP'\n                    else:\n                        op_name = 'LOAD_CODE'\n                    pattr = '<code_object ' + const.co_name + '>'\n                else:\n                    if oparg < len(co.co_consts):\n                        (argval, _) = _get_const_info(oparg, co.co_consts)\n                    pattr = const\n                    pass\n            elif op in self.opc.NAME_OPS:\n                pattr = names[oparg]\n            elif op in self.opc.JREL_OPS:\n                pattr = repr(offset + 3 + oparg)\n                if op == self.opc.JUMP_FORWARD:\n                    target = self.get_target(offset)\n                    if len(tokens) and tokens[-1].kind == 'JUMP_BACK':\n                        tokens[-1].kind = intern('CONTINUE')\n            elif op in self.opc.JABS_OPS:\n                pattr = repr(oparg)\n            elif op in self.opc.LOCAL_OPS:\n                if self.version < (1, 5):\n                    pattr = names[oparg]\n                else:\n                    pattr = varnames[oparg]\n            elif op in self.opc.COMPARE_OPS:\n                pattr = self.opc.cmp_op[oparg]\n            elif op in self.opc.FREE_OPS:\n                pattr = free[oparg]\n        if op in self.varargs_ops:\n            if self.version >= (2, 5) and op == self.opc.BUILD_TUPLE and (self.code[self.prev[offset]] == self.opc.LOAD_CLOSURE):\n                continue\n            else:\n                op_name = '%s_%d' % (op_name, oparg)\n                customize[op_name] = oparg\n        elif self.version > (2, 0) and op == self.opc.CONTINUE_LOOP:\n            customize[op_name] = 0\n        elif op_name in '\\n                 CONTINUE_LOOP EXEC_STMT LOAD_LISTCOMP LOAD_SETCOMP\\n                  '.split():\n            customize[op_name] = 0\n        elif op == self.opc.JUMP_ABSOLUTE:\n            target = self.get_target(offset)\n            if target <= offset:\n                op_name = 'JUMP_BACK'\n                if offset in self.stmts and self.code[offset + 3] not in (self.opc.END_FINALLY, self.opc.POP_BLOCK):\n                    if offset in self.linestarts and tokens[-1].kind == 'JUMP_BACK' or offset not in self.not_continue:\n                        op_name = 'CONTINUE'\n                elif tokens[-1].kind == 'JUMP_BACK':\n                    tokens[-1].kind = intern('CONTINUE')\n        elif op == self.opc.LOAD_GLOBAL:\n            if offset in self.load_asserts:\n                op_name = 'LOAD_ASSERT'\n        elif op == self.opc.RETURN_VALUE:\n            if offset in self.return_end_ifs:\n                op_name = 'RETURN_END_IF'\n        linestart = self.linestarts.get(offset, None)\n        if offset not in replace:\n            tokens.append(Token(op_name, oparg, pattr, offset, linestart, op, has_arg, self.opc))\n        else:\n            tokens.append(Token(replace[offset], oparg, pattr, offset, linestart, op, has_arg, self.opc))\n            pass\n        pass\n    if show_asm in ('both', 'after'):\n        for t in tokens:\n            print(t.format(line_prefix=''))\n        print()\n    return (tokens, customize)"
        ]
    }
]