[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Check for required version of boto and make this pillar available\n    depending on outcome.\n    \"\"\"\n    if not HAS_BOTO:\n        return False\n    boto_version = Version(boto.__version__)\n    required_boto_version = Version('2.8.0')\n    if boto_version < required_boto_version:\n        log.error(\"%s: installed boto version %s < %s, can't retrieve instance data\", __name__, boto_version, required_boto_version)\n        return False\n    return True",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Check for required version of boto and make this pillar available\\n    depending on outcome.\\n    '\n    if not HAS_BOTO:\n        return False\n    boto_version = Version(boto.__version__)\n    required_boto_version = Version('2.8.0')\n    if boto_version < required_boto_version:\n        log.error(\"%s: installed boto version %s < %s, can't retrieve instance data\", __name__, boto_version, required_boto_version)\n        return False\n    return True",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check for required version of boto and make this pillar available\\n    depending on outcome.\\n    '\n    if not HAS_BOTO:\n        return False\n    boto_version = Version(boto.__version__)\n    required_boto_version = Version('2.8.0')\n    if boto_version < required_boto_version:\n        log.error(\"%s: installed boto version %s < %s, can't retrieve instance data\", __name__, boto_version, required_boto_version)\n        return False\n    return True",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check for required version of boto and make this pillar available\\n    depending on outcome.\\n    '\n    if not HAS_BOTO:\n        return False\n    boto_version = Version(boto.__version__)\n    required_boto_version = Version('2.8.0')\n    if boto_version < required_boto_version:\n        log.error(\"%s: installed boto version %s < %s, can't retrieve instance data\", __name__, boto_version, required_boto_version)\n        return False\n    return True",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check for required version of boto and make this pillar available\\n    depending on outcome.\\n    '\n    if not HAS_BOTO:\n        return False\n    boto_version = Version(boto.__version__)\n    required_boto_version = Version('2.8.0')\n    if boto_version < required_boto_version:\n        log.error(\"%s: installed boto version %s < %s, can't retrieve instance data\", __name__, boto_version, required_boto_version)\n        return False\n    return True",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check for required version of boto and make this pillar available\\n    depending on outcome.\\n    '\n    if not HAS_BOTO:\n        return False\n    boto_version = Version(boto.__version__)\n    required_boto_version = Version('2.8.0')\n    if boto_version < required_boto_version:\n        log.error(\"%s: installed boto version %s < %s, can't retrieve instance data\", __name__, boto_version, required_boto_version)\n        return False\n    return True"
        ]
    },
    {
        "func_name": "_get_instance_info",
        "original": "def _get_instance_info():\n    \"\"\"\n    Helper function to return the instance ID and region of the master where\n    this pillar is run.\n    \"\"\"\n    identity = boto.utils.get_instance_identity()['document']\n    return (identity['instanceId'], identity['region'])",
        "mutated": [
            "def _get_instance_info():\n    if False:\n        i = 10\n    '\\n    Helper function to return the instance ID and region of the master where\\n    this pillar is run.\\n    '\n    identity = boto.utils.get_instance_identity()['document']\n    return (identity['instanceId'], identity['region'])",
            "def _get_instance_info():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function to return the instance ID and region of the master where\\n    this pillar is run.\\n    '\n    identity = boto.utils.get_instance_identity()['document']\n    return (identity['instanceId'], identity['region'])",
            "def _get_instance_info():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function to return the instance ID and region of the master where\\n    this pillar is run.\\n    '\n    identity = boto.utils.get_instance_identity()['document']\n    return (identity['instanceId'], identity['region'])",
            "def _get_instance_info():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function to return the instance ID and region of the master where\\n    this pillar is run.\\n    '\n    identity = boto.utils.get_instance_identity()['document']\n    return (identity['instanceId'], identity['region'])",
            "def _get_instance_info():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function to return the instance ID and region of the master where\\n    this pillar is run.\\n    '\n    identity = boto.utils.get_instance_identity()['document']\n    return (identity['instanceId'], identity['region'])"
        ]
    },
    {
        "func_name": "ext_pillar",
        "original": "def ext_pillar(minion_id, pillar, use_grain=False, minion_ids=None, tag_match_key=None, tag_match_value='asis', tag_list_key=None, tag_list_sep=';'):\n    \"\"\"\n    Execute a command and read the output as YAML\n    \"\"\"\n    valid_tag_match_value = ['uqdn', 'asis']\n    grain_instance_id = __grains__.get('meta-data', {}).get('instance-id', None)\n    if not grain_instance_id:\n        grain_instance_id = __grains__.get('dynamic', {}).get('instance-identity', {}).get('document', {}).get('instance-id', None)\n    if grain_instance_id and re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', grain_instance_id) is None:\n        log.error(\"External pillar %s, instance-id '%s' is not valid for '%s'\", __name__, grain_instance_id, minion_id)\n        grain_instance_id = None\n    if tag_match_key and re.match('[\\\\w=.:/@-]+$', tag_match_key) is None:\n        log.error(\"External pillar %s, tag_match_key '%s' is not valid \", __name__, tag_match_key if isinstance(tag_match_key, str) else 'non-string')\n        return {}\n    if tag_match_key and tag_match_value not in valid_tag_match_value:\n        log.error(\"External pillar %s, tag_value '%s' is not valid must be one of %s\", __name__, tag_match_value, ' '.join(valid_tag_match_value))\n        return {}\n    if not tag_match_key:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id\", __name__, minion_id)\n    else:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s'\", __name__, minion_id, tag_match_key, tag_match_value)\n    log.debug(base_msg)\n    find_filter = None\n    find_id = None\n    if re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', minion_id) is not None:\n        find_filter = None\n        find_id = minion_id\n    elif tag_match_key:\n        if tag_match_value == 'uqdn':\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id.split('.', 1)[0]}\n        else:\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id}\n        if grain_instance_id:\n            find_filter.update({'instance-id': grain_instance_id})\n    if not find_filter and (not find_id) and use_grain:\n        if not grain_instance_id:\n            log.debug('Minion-id is not in AWS instance-id formation, and there is no instance-id grain for minion %s', minion_id)\n            return {}\n        if minion_ids is not None and minion_id not in minion_ids:\n            log.debug('Minion-id is not in AWS instance ID format, and minion_ids is set in the ec2_pillar configuration, but minion %s is not in the list of allowed minions %s', minion_id, minion_ids)\n            return {}\n        find_id = grain_instance_id\n    if not (find_filter or find_id):\n        log.debug(\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s' noughthing to match against\", __name__, minion_id, tag_match_key, tag_match_value)\n        return {}\n    myself = boto.utils.get_instance_metadata(timeout=0.1, num_retries=1)\n    if len(myself.keys()) < 1:\n        log.info('%s: salt master not an EC2 instance, skipping', __name__)\n        return {}\n    (_, region) = _get_instance_info()\n    if use_grain:\n        region = __grains__.get('ec2', {}).get('region', region)\n    try:\n        conn = boto.ec2.connect_to_region(region)\n    except boto.exception.AWSConnectionError as exc:\n        log.error('%s: invalid AWS credentials, %s', __name__, exc)\n        return {}\n    if conn is None:\n        log.error('%s: Could not connect to region %s', __name__, region)\n        return {}\n    try:\n        if find_id:\n            instance_data = conn.get_only_instances(instance_ids=[find_id], dry_run=False)\n        else:\n            instance_data = conn.get_only_instances(filters=find_filter, dry_run=False)\n    except boto.exception.EC2ResponseError as exc:\n        log.error(\"%s failed with '%s'\", base_msg, exc)\n        return {}\n    if not instance_data:\n        log.debug(\"%s no match using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    active_inst = []\n    for (idx, inst_data) in enumerate(instance_data):\n        if inst_data.state not in ['terminated', 'stopped']:\n            active_inst.append(idx)\n    valid_inst = len(active_inst)\n    if not valid_inst:\n        log.debug(\"%s match found but not active '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    if valid_inst > 1:\n        log.error(\"%s multiple matches, ignored, using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    instance = instance_data[active_inst[0]]\n    if instance.tags:\n        ec2_tags = instance.tags\n        ec2_tags_list = {}\n        log.debug(\"External pillar %s, for minion id '%s', tags: %s\", __name__, minion_id, instance.tags)\n        if tag_list_key and isinstance(tag_list_key, list):\n            for item in tag_list_key:\n                if item in ec2_tags:\n                    ec2_tags_list[item] = ec2_tags[item].split(tag_list_sep)\n                    del ec2_tags[item]\n                else:\n                    ec2_tags_list[item] = []\n        return {'ec2_tags': ec2_tags, 'ec2_tags_list': ec2_tags_list}\n    return {}",
        "mutated": [
            "def ext_pillar(minion_id, pillar, use_grain=False, minion_ids=None, tag_match_key=None, tag_match_value='asis', tag_list_key=None, tag_list_sep=';'):\n    if False:\n        i = 10\n    '\\n    Execute a command and read the output as YAML\\n    '\n    valid_tag_match_value = ['uqdn', 'asis']\n    grain_instance_id = __grains__.get('meta-data', {}).get('instance-id', None)\n    if not grain_instance_id:\n        grain_instance_id = __grains__.get('dynamic', {}).get('instance-identity', {}).get('document', {}).get('instance-id', None)\n    if grain_instance_id and re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', grain_instance_id) is None:\n        log.error(\"External pillar %s, instance-id '%s' is not valid for '%s'\", __name__, grain_instance_id, minion_id)\n        grain_instance_id = None\n    if tag_match_key and re.match('[\\\\w=.:/@-]+$', tag_match_key) is None:\n        log.error(\"External pillar %s, tag_match_key '%s' is not valid \", __name__, tag_match_key if isinstance(tag_match_key, str) else 'non-string')\n        return {}\n    if tag_match_key and tag_match_value not in valid_tag_match_value:\n        log.error(\"External pillar %s, tag_value '%s' is not valid must be one of %s\", __name__, tag_match_value, ' '.join(valid_tag_match_value))\n        return {}\n    if not tag_match_key:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id\", __name__, minion_id)\n    else:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s'\", __name__, minion_id, tag_match_key, tag_match_value)\n    log.debug(base_msg)\n    find_filter = None\n    find_id = None\n    if re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', minion_id) is not None:\n        find_filter = None\n        find_id = minion_id\n    elif tag_match_key:\n        if tag_match_value == 'uqdn':\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id.split('.', 1)[0]}\n        else:\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id}\n        if grain_instance_id:\n            find_filter.update({'instance-id': grain_instance_id})\n    if not find_filter and (not find_id) and use_grain:\n        if not grain_instance_id:\n            log.debug('Minion-id is not in AWS instance-id formation, and there is no instance-id grain for minion %s', minion_id)\n            return {}\n        if minion_ids is not None and minion_id not in minion_ids:\n            log.debug('Minion-id is not in AWS instance ID format, and minion_ids is set in the ec2_pillar configuration, but minion %s is not in the list of allowed minions %s', minion_id, minion_ids)\n            return {}\n        find_id = grain_instance_id\n    if not (find_filter or find_id):\n        log.debug(\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s' noughthing to match against\", __name__, minion_id, tag_match_key, tag_match_value)\n        return {}\n    myself = boto.utils.get_instance_metadata(timeout=0.1, num_retries=1)\n    if len(myself.keys()) < 1:\n        log.info('%s: salt master not an EC2 instance, skipping', __name__)\n        return {}\n    (_, region) = _get_instance_info()\n    if use_grain:\n        region = __grains__.get('ec2', {}).get('region', region)\n    try:\n        conn = boto.ec2.connect_to_region(region)\n    except boto.exception.AWSConnectionError as exc:\n        log.error('%s: invalid AWS credentials, %s', __name__, exc)\n        return {}\n    if conn is None:\n        log.error('%s: Could not connect to region %s', __name__, region)\n        return {}\n    try:\n        if find_id:\n            instance_data = conn.get_only_instances(instance_ids=[find_id], dry_run=False)\n        else:\n            instance_data = conn.get_only_instances(filters=find_filter, dry_run=False)\n    except boto.exception.EC2ResponseError as exc:\n        log.error(\"%s failed with '%s'\", base_msg, exc)\n        return {}\n    if not instance_data:\n        log.debug(\"%s no match using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    active_inst = []\n    for (idx, inst_data) in enumerate(instance_data):\n        if inst_data.state not in ['terminated', 'stopped']:\n            active_inst.append(idx)\n    valid_inst = len(active_inst)\n    if not valid_inst:\n        log.debug(\"%s match found but not active '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    if valid_inst > 1:\n        log.error(\"%s multiple matches, ignored, using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    instance = instance_data[active_inst[0]]\n    if instance.tags:\n        ec2_tags = instance.tags\n        ec2_tags_list = {}\n        log.debug(\"External pillar %s, for minion id '%s', tags: %s\", __name__, minion_id, instance.tags)\n        if tag_list_key and isinstance(tag_list_key, list):\n            for item in tag_list_key:\n                if item in ec2_tags:\n                    ec2_tags_list[item] = ec2_tags[item].split(tag_list_sep)\n                    del ec2_tags[item]\n                else:\n                    ec2_tags_list[item] = []\n        return {'ec2_tags': ec2_tags, 'ec2_tags_list': ec2_tags_list}\n    return {}",
            "def ext_pillar(minion_id, pillar, use_grain=False, minion_ids=None, tag_match_key=None, tag_match_value='asis', tag_list_key=None, tag_list_sep=';'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Execute a command and read the output as YAML\\n    '\n    valid_tag_match_value = ['uqdn', 'asis']\n    grain_instance_id = __grains__.get('meta-data', {}).get('instance-id', None)\n    if not grain_instance_id:\n        grain_instance_id = __grains__.get('dynamic', {}).get('instance-identity', {}).get('document', {}).get('instance-id', None)\n    if grain_instance_id and re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', grain_instance_id) is None:\n        log.error(\"External pillar %s, instance-id '%s' is not valid for '%s'\", __name__, grain_instance_id, minion_id)\n        grain_instance_id = None\n    if tag_match_key and re.match('[\\\\w=.:/@-]+$', tag_match_key) is None:\n        log.error(\"External pillar %s, tag_match_key '%s' is not valid \", __name__, tag_match_key if isinstance(tag_match_key, str) else 'non-string')\n        return {}\n    if tag_match_key and tag_match_value not in valid_tag_match_value:\n        log.error(\"External pillar %s, tag_value '%s' is not valid must be one of %s\", __name__, tag_match_value, ' '.join(valid_tag_match_value))\n        return {}\n    if not tag_match_key:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id\", __name__, minion_id)\n    else:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s'\", __name__, minion_id, tag_match_key, tag_match_value)\n    log.debug(base_msg)\n    find_filter = None\n    find_id = None\n    if re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', minion_id) is not None:\n        find_filter = None\n        find_id = minion_id\n    elif tag_match_key:\n        if tag_match_value == 'uqdn':\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id.split('.', 1)[0]}\n        else:\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id}\n        if grain_instance_id:\n            find_filter.update({'instance-id': grain_instance_id})\n    if not find_filter and (not find_id) and use_grain:\n        if not grain_instance_id:\n            log.debug('Minion-id is not in AWS instance-id formation, and there is no instance-id grain for minion %s', minion_id)\n            return {}\n        if minion_ids is not None and minion_id not in minion_ids:\n            log.debug('Minion-id is not in AWS instance ID format, and minion_ids is set in the ec2_pillar configuration, but minion %s is not in the list of allowed minions %s', minion_id, minion_ids)\n            return {}\n        find_id = grain_instance_id\n    if not (find_filter or find_id):\n        log.debug(\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s' noughthing to match against\", __name__, minion_id, tag_match_key, tag_match_value)\n        return {}\n    myself = boto.utils.get_instance_metadata(timeout=0.1, num_retries=1)\n    if len(myself.keys()) < 1:\n        log.info('%s: salt master not an EC2 instance, skipping', __name__)\n        return {}\n    (_, region) = _get_instance_info()\n    if use_grain:\n        region = __grains__.get('ec2', {}).get('region', region)\n    try:\n        conn = boto.ec2.connect_to_region(region)\n    except boto.exception.AWSConnectionError as exc:\n        log.error('%s: invalid AWS credentials, %s', __name__, exc)\n        return {}\n    if conn is None:\n        log.error('%s: Could not connect to region %s', __name__, region)\n        return {}\n    try:\n        if find_id:\n            instance_data = conn.get_only_instances(instance_ids=[find_id], dry_run=False)\n        else:\n            instance_data = conn.get_only_instances(filters=find_filter, dry_run=False)\n    except boto.exception.EC2ResponseError as exc:\n        log.error(\"%s failed with '%s'\", base_msg, exc)\n        return {}\n    if not instance_data:\n        log.debug(\"%s no match using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    active_inst = []\n    for (idx, inst_data) in enumerate(instance_data):\n        if inst_data.state not in ['terminated', 'stopped']:\n            active_inst.append(idx)\n    valid_inst = len(active_inst)\n    if not valid_inst:\n        log.debug(\"%s match found but not active '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    if valid_inst > 1:\n        log.error(\"%s multiple matches, ignored, using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    instance = instance_data[active_inst[0]]\n    if instance.tags:\n        ec2_tags = instance.tags\n        ec2_tags_list = {}\n        log.debug(\"External pillar %s, for minion id '%s', tags: %s\", __name__, minion_id, instance.tags)\n        if tag_list_key and isinstance(tag_list_key, list):\n            for item in tag_list_key:\n                if item in ec2_tags:\n                    ec2_tags_list[item] = ec2_tags[item].split(tag_list_sep)\n                    del ec2_tags[item]\n                else:\n                    ec2_tags_list[item] = []\n        return {'ec2_tags': ec2_tags, 'ec2_tags_list': ec2_tags_list}\n    return {}",
            "def ext_pillar(minion_id, pillar, use_grain=False, minion_ids=None, tag_match_key=None, tag_match_value='asis', tag_list_key=None, tag_list_sep=';'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Execute a command and read the output as YAML\\n    '\n    valid_tag_match_value = ['uqdn', 'asis']\n    grain_instance_id = __grains__.get('meta-data', {}).get('instance-id', None)\n    if not grain_instance_id:\n        grain_instance_id = __grains__.get('dynamic', {}).get('instance-identity', {}).get('document', {}).get('instance-id', None)\n    if grain_instance_id and re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', grain_instance_id) is None:\n        log.error(\"External pillar %s, instance-id '%s' is not valid for '%s'\", __name__, grain_instance_id, minion_id)\n        grain_instance_id = None\n    if tag_match_key and re.match('[\\\\w=.:/@-]+$', tag_match_key) is None:\n        log.error(\"External pillar %s, tag_match_key '%s' is not valid \", __name__, tag_match_key if isinstance(tag_match_key, str) else 'non-string')\n        return {}\n    if tag_match_key and tag_match_value not in valid_tag_match_value:\n        log.error(\"External pillar %s, tag_value '%s' is not valid must be one of %s\", __name__, tag_match_value, ' '.join(valid_tag_match_value))\n        return {}\n    if not tag_match_key:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id\", __name__, minion_id)\n    else:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s'\", __name__, minion_id, tag_match_key, tag_match_value)\n    log.debug(base_msg)\n    find_filter = None\n    find_id = None\n    if re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', minion_id) is not None:\n        find_filter = None\n        find_id = minion_id\n    elif tag_match_key:\n        if tag_match_value == 'uqdn':\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id.split('.', 1)[0]}\n        else:\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id}\n        if grain_instance_id:\n            find_filter.update({'instance-id': grain_instance_id})\n    if not find_filter and (not find_id) and use_grain:\n        if not grain_instance_id:\n            log.debug('Minion-id is not in AWS instance-id formation, and there is no instance-id grain for minion %s', minion_id)\n            return {}\n        if minion_ids is not None and minion_id not in minion_ids:\n            log.debug('Minion-id is not in AWS instance ID format, and minion_ids is set in the ec2_pillar configuration, but minion %s is not in the list of allowed minions %s', minion_id, minion_ids)\n            return {}\n        find_id = grain_instance_id\n    if not (find_filter or find_id):\n        log.debug(\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s' noughthing to match against\", __name__, minion_id, tag_match_key, tag_match_value)\n        return {}\n    myself = boto.utils.get_instance_metadata(timeout=0.1, num_retries=1)\n    if len(myself.keys()) < 1:\n        log.info('%s: salt master not an EC2 instance, skipping', __name__)\n        return {}\n    (_, region) = _get_instance_info()\n    if use_grain:\n        region = __grains__.get('ec2', {}).get('region', region)\n    try:\n        conn = boto.ec2.connect_to_region(region)\n    except boto.exception.AWSConnectionError as exc:\n        log.error('%s: invalid AWS credentials, %s', __name__, exc)\n        return {}\n    if conn is None:\n        log.error('%s: Could not connect to region %s', __name__, region)\n        return {}\n    try:\n        if find_id:\n            instance_data = conn.get_only_instances(instance_ids=[find_id], dry_run=False)\n        else:\n            instance_data = conn.get_only_instances(filters=find_filter, dry_run=False)\n    except boto.exception.EC2ResponseError as exc:\n        log.error(\"%s failed with '%s'\", base_msg, exc)\n        return {}\n    if not instance_data:\n        log.debug(\"%s no match using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    active_inst = []\n    for (idx, inst_data) in enumerate(instance_data):\n        if inst_data.state not in ['terminated', 'stopped']:\n            active_inst.append(idx)\n    valid_inst = len(active_inst)\n    if not valid_inst:\n        log.debug(\"%s match found but not active '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    if valid_inst > 1:\n        log.error(\"%s multiple matches, ignored, using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    instance = instance_data[active_inst[0]]\n    if instance.tags:\n        ec2_tags = instance.tags\n        ec2_tags_list = {}\n        log.debug(\"External pillar %s, for minion id '%s', tags: %s\", __name__, minion_id, instance.tags)\n        if tag_list_key and isinstance(tag_list_key, list):\n            for item in tag_list_key:\n                if item in ec2_tags:\n                    ec2_tags_list[item] = ec2_tags[item].split(tag_list_sep)\n                    del ec2_tags[item]\n                else:\n                    ec2_tags_list[item] = []\n        return {'ec2_tags': ec2_tags, 'ec2_tags_list': ec2_tags_list}\n    return {}",
            "def ext_pillar(minion_id, pillar, use_grain=False, minion_ids=None, tag_match_key=None, tag_match_value='asis', tag_list_key=None, tag_list_sep=';'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Execute a command and read the output as YAML\\n    '\n    valid_tag_match_value = ['uqdn', 'asis']\n    grain_instance_id = __grains__.get('meta-data', {}).get('instance-id', None)\n    if not grain_instance_id:\n        grain_instance_id = __grains__.get('dynamic', {}).get('instance-identity', {}).get('document', {}).get('instance-id', None)\n    if grain_instance_id and re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', grain_instance_id) is None:\n        log.error(\"External pillar %s, instance-id '%s' is not valid for '%s'\", __name__, grain_instance_id, minion_id)\n        grain_instance_id = None\n    if tag_match_key and re.match('[\\\\w=.:/@-]+$', tag_match_key) is None:\n        log.error(\"External pillar %s, tag_match_key '%s' is not valid \", __name__, tag_match_key if isinstance(tag_match_key, str) else 'non-string')\n        return {}\n    if tag_match_key and tag_match_value not in valid_tag_match_value:\n        log.error(\"External pillar %s, tag_value '%s' is not valid must be one of %s\", __name__, tag_match_value, ' '.join(valid_tag_match_value))\n        return {}\n    if not tag_match_key:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id\", __name__, minion_id)\n    else:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s'\", __name__, minion_id, tag_match_key, tag_match_value)\n    log.debug(base_msg)\n    find_filter = None\n    find_id = None\n    if re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', minion_id) is not None:\n        find_filter = None\n        find_id = minion_id\n    elif tag_match_key:\n        if tag_match_value == 'uqdn':\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id.split('.', 1)[0]}\n        else:\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id}\n        if grain_instance_id:\n            find_filter.update({'instance-id': grain_instance_id})\n    if not find_filter and (not find_id) and use_grain:\n        if not grain_instance_id:\n            log.debug('Minion-id is not in AWS instance-id formation, and there is no instance-id grain for minion %s', minion_id)\n            return {}\n        if minion_ids is not None and minion_id not in minion_ids:\n            log.debug('Minion-id is not in AWS instance ID format, and minion_ids is set in the ec2_pillar configuration, but minion %s is not in the list of allowed minions %s', minion_id, minion_ids)\n            return {}\n        find_id = grain_instance_id\n    if not (find_filter or find_id):\n        log.debug(\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s' noughthing to match against\", __name__, minion_id, tag_match_key, tag_match_value)\n        return {}\n    myself = boto.utils.get_instance_metadata(timeout=0.1, num_retries=1)\n    if len(myself.keys()) < 1:\n        log.info('%s: salt master not an EC2 instance, skipping', __name__)\n        return {}\n    (_, region) = _get_instance_info()\n    if use_grain:\n        region = __grains__.get('ec2', {}).get('region', region)\n    try:\n        conn = boto.ec2.connect_to_region(region)\n    except boto.exception.AWSConnectionError as exc:\n        log.error('%s: invalid AWS credentials, %s', __name__, exc)\n        return {}\n    if conn is None:\n        log.error('%s: Could not connect to region %s', __name__, region)\n        return {}\n    try:\n        if find_id:\n            instance_data = conn.get_only_instances(instance_ids=[find_id], dry_run=False)\n        else:\n            instance_data = conn.get_only_instances(filters=find_filter, dry_run=False)\n    except boto.exception.EC2ResponseError as exc:\n        log.error(\"%s failed with '%s'\", base_msg, exc)\n        return {}\n    if not instance_data:\n        log.debug(\"%s no match using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    active_inst = []\n    for (idx, inst_data) in enumerate(instance_data):\n        if inst_data.state not in ['terminated', 'stopped']:\n            active_inst.append(idx)\n    valid_inst = len(active_inst)\n    if not valid_inst:\n        log.debug(\"%s match found but not active '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    if valid_inst > 1:\n        log.error(\"%s multiple matches, ignored, using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    instance = instance_data[active_inst[0]]\n    if instance.tags:\n        ec2_tags = instance.tags\n        ec2_tags_list = {}\n        log.debug(\"External pillar %s, for minion id '%s', tags: %s\", __name__, minion_id, instance.tags)\n        if tag_list_key and isinstance(tag_list_key, list):\n            for item in tag_list_key:\n                if item in ec2_tags:\n                    ec2_tags_list[item] = ec2_tags[item].split(tag_list_sep)\n                    del ec2_tags[item]\n                else:\n                    ec2_tags_list[item] = []\n        return {'ec2_tags': ec2_tags, 'ec2_tags_list': ec2_tags_list}\n    return {}",
            "def ext_pillar(minion_id, pillar, use_grain=False, minion_ids=None, tag_match_key=None, tag_match_value='asis', tag_list_key=None, tag_list_sep=';'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Execute a command and read the output as YAML\\n    '\n    valid_tag_match_value = ['uqdn', 'asis']\n    grain_instance_id = __grains__.get('meta-data', {}).get('instance-id', None)\n    if not grain_instance_id:\n        grain_instance_id = __grains__.get('dynamic', {}).get('instance-identity', {}).get('document', {}).get('instance-id', None)\n    if grain_instance_id and re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', grain_instance_id) is None:\n        log.error(\"External pillar %s, instance-id '%s' is not valid for '%s'\", __name__, grain_instance_id, minion_id)\n        grain_instance_id = None\n    if tag_match_key and re.match('[\\\\w=.:/@-]+$', tag_match_key) is None:\n        log.error(\"External pillar %s, tag_match_key '%s' is not valid \", __name__, tag_match_key if isinstance(tag_match_key, str) else 'non-string')\n        return {}\n    if tag_match_key and tag_match_value not in valid_tag_match_value:\n        log.error(\"External pillar %s, tag_value '%s' is not valid must be one of %s\", __name__, tag_match_value, ' '.join(valid_tag_match_value))\n        return {}\n    if not tag_match_key:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id\", __name__, minion_id)\n    else:\n        base_msg = (\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s'\", __name__, minion_id, tag_match_key, tag_match_value)\n    log.debug(base_msg)\n    find_filter = None\n    find_id = None\n    if re.search('^i-([0-9a-z]{17}|[0-9a-z]{8})$', minion_id) is not None:\n        find_filter = None\n        find_id = minion_id\n    elif tag_match_key:\n        if tag_match_value == 'uqdn':\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id.split('.', 1)[0]}\n        else:\n            find_filter = {'tag:{}'.format(tag_match_key): minion_id}\n        if grain_instance_id:\n            find_filter.update({'instance-id': grain_instance_id})\n    if not find_filter and (not find_id) and use_grain:\n        if not grain_instance_id:\n            log.debug('Minion-id is not in AWS instance-id formation, and there is no instance-id grain for minion %s', minion_id)\n            return {}\n        if minion_ids is not None and minion_id not in minion_ids:\n            log.debug('Minion-id is not in AWS instance ID format, and minion_ids is set in the ec2_pillar configuration, but minion %s is not in the list of allowed minions %s', minion_id, minion_ids)\n            return {}\n        find_id = grain_instance_id\n    if not (find_filter or find_id):\n        log.debug(\"External pillar %s, querying EC2 tags for minion id '%s' against instance-id or '%s' against '%s' noughthing to match against\", __name__, minion_id, tag_match_key, tag_match_value)\n        return {}\n    myself = boto.utils.get_instance_metadata(timeout=0.1, num_retries=1)\n    if len(myself.keys()) < 1:\n        log.info('%s: salt master not an EC2 instance, skipping', __name__)\n        return {}\n    (_, region) = _get_instance_info()\n    if use_grain:\n        region = __grains__.get('ec2', {}).get('region', region)\n    try:\n        conn = boto.ec2.connect_to_region(region)\n    except boto.exception.AWSConnectionError as exc:\n        log.error('%s: invalid AWS credentials, %s', __name__, exc)\n        return {}\n    if conn is None:\n        log.error('%s: Could not connect to region %s', __name__, region)\n        return {}\n    try:\n        if find_id:\n            instance_data = conn.get_only_instances(instance_ids=[find_id], dry_run=False)\n        else:\n            instance_data = conn.get_only_instances(filters=find_filter, dry_run=False)\n    except boto.exception.EC2ResponseError as exc:\n        log.error(\"%s failed with '%s'\", base_msg, exc)\n        return {}\n    if not instance_data:\n        log.debug(\"%s no match using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    active_inst = []\n    for (idx, inst_data) in enumerate(instance_data):\n        if inst_data.state not in ['terminated', 'stopped']:\n            active_inst.append(idx)\n    valid_inst = len(active_inst)\n    if not valid_inst:\n        log.debug(\"%s match found but not active '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    if valid_inst > 1:\n        log.error(\"%s multiple matches, ignored, using '%s'\", base_msg, find_id if find_id else find_filter)\n        return {}\n    instance = instance_data[active_inst[0]]\n    if instance.tags:\n        ec2_tags = instance.tags\n        ec2_tags_list = {}\n        log.debug(\"External pillar %s, for minion id '%s', tags: %s\", __name__, minion_id, instance.tags)\n        if tag_list_key and isinstance(tag_list_key, list):\n            for item in tag_list_key:\n                if item in ec2_tags:\n                    ec2_tags_list[item] = ec2_tags[item].split(tag_list_sep)\n                    del ec2_tags[item]\n                else:\n                    ec2_tags_list[item] = []\n        return {'ec2_tags': ec2_tags, 'ec2_tags_list': ec2_tags_list}\n    return {}"
        ]
    }
]