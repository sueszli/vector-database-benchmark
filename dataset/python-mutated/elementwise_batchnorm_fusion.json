[
    {
        "func_name": "match_pattern",
        "original": "def match_pattern(op):\n    if op.outputs[0] in op.enclosing_block.outputs:\n        return None\n    if op.op_type == 'mul':\n        child_ops = op.outputs[0].child_ops\n        if len(child_ops) == 1:\n            add_op_candidate = list(child_ops)[0]\n            if add_op_candidate.op_type == 'add':\n                return add_op_candidate\n    return None",
        "mutated": [
            "def match_pattern(op):\n    if False:\n        i = 10\n    if op.outputs[0] in op.enclosing_block.outputs:\n        return None\n    if op.op_type == 'mul':\n        child_ops = op.outputs[0].child_ops\n        if len(child_ops) == 1:\n            add_op_candidate = list(child_ops)[0]\n            if add_op_candidate.op_type == 'add':\n                return add_op_candidate\n    return None",
            "def match_pattern(op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if op.outputs[0] in op.enclosing_block.outputs:\n        return None\n    if op.op_type == 'mul':\n        child_ops = op.outputs[0].child_ops\n        if len(child_ops) == 1:\n            add_op_candidate = list(child_ops)[0]\n            if add_op_candidate.op_type == 'add':\n                return add_op_candidate\n    return None",
            "def match_pattern(op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if op.outputs[0] in op.enclosing_block.outputs:\n        return None\n    if op.op_type == 'mul':\n        child_ops = op.outputs[0].child_ops\n        if len(child_ops) == 1:\n            add_op_candidate = list(child_ops)[0]\n            if add_op_candidate.op_type == 'add':\n                return add_op_candidate\n    return None",
            "def match_pattern(op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if op.outputs[0] in op.enclosing_block.outputs:\n        return None\n    if op.op_type == 'mul':\n        child_ops = op.outputs[0].child_ops\n        if len(child_ops) == 1:\n            add_op_candidate = list(child_ops)[0]\n            if add_op_candidate.op_type == 'add':\n                return add_op_candidate\n    return None",
            "def match_pattern(op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if op.outputs[0] in op.enclosing_block.outputs:\n        return None\n    if op.op_type == 'mul':\n        child_ops = op.outputs[0].child_ops\n        if len(child_ops) == 1:\n            add_op_candidate = list(child_ops)[0]\n            if add_op_candidate.op_type == 'add':\n                return add_op_candidate\n    return None"
        ]
    },
    {
        "func_name": "_find_const_input_val",
        "original": "def _find_const_input_val(op):\n    if op.x.val is not None:\n        return op.x.val\n    if op.y.val is not None:\n        return op.y.val\n    return None",
        "mutated": [
            "def _find_const_input_val(op):\n    if False:\n        i = 10\n    if op.x.val is not None:\n        return op.x.val\n    if op.y.val is not None:\n        return op.y.val\n    return None",
            "def _find_const_input_val(op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if op.x.val is not None:\n        return op.x.val\n    if op.y.val is not None:\n        return op.y.val\n    return None",
            "def _find_const_input_val(op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if op.x.val is not None:\n        return op.x.val\n    if op.y.val is not None:\n        return op.y.val\n    return None",
            "def _find_const_input_val(op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if op.x.val is not None:\n        return op.x.val\n    if op.y.val is not None:\n        return op.y.val\n    return None",
            "def _find_const_input_val(op):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if op.x.val is not None:\n        return op.x.val\n    if op.y.val is not None:\n        return op.y.val\n    return None"
        ]
    },
    {
        "func_name": "_check_shape",
        "original": "def _check_shape(arr):\n    \"\"\"\n    return True if shape is of form\n    (1,C,1,1) or (C,1,1)\n    \"\"\"\n    rank = len(arr.shape)\n    if not (rank == 3 or rank == 4):\n        return False\n    C = arr.shape[-3]\n    if not (arr.shape == (1, C, 1, 1) or arr.shape == (C, 1, 1)):\n        return False\n    return True",
        "mutated": [
            "def _check_shape(arr):\n    if False:\n        i = 10\n    '\\n    return True if shape is of form\\n    (1,C,1,1) or (C,1,1)\\n    '\n    rank = len(arr.shape)\n    if not (rank == 3 or rank == 4):\n        return False\n    C = arr.shape[-3]\n    if not (arr.shape == (1, C, 1, 1) or arr.shape == (C, 1, 1)):\n        return False\n    return True",
            "def _check_shape(arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    return True if shape is of form\\n    (1,C,1,1) or (C,1,1)\\n    '\n    rank = len(arr.shape)\n    if not (rank == 3 or rank == 4):\n        return False\n    C = arr.shape[-3]\n    if not (arr.shape == (1, C, 1, 1) or arr.shape == (C, 1, 1)):\n        return False\n    return True",
            "def _check_shape(arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    return True if shape is of form\\n    (1,C,1,1) or (C,1,1)\\n    '\n    rank = len(arr.shape)\n    if not (rank == 3 or rank == 4):\n        return False\n    C = arr.shape[-3]\n    if not (arr.shape == (1, C, 1, 1) or arr.shape == (C, 1, 1)):\n        return False\n    return True",
            "def _check_shape(arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    return True if shape is of form\\n    (1,C,1,1) or (C,1,1)\\n    '\n    rank = len(arr.shape)\n    if not (rank == 3 or rank == 4):\n        return False\n    C = arr.shape[-3]\n    if not (arr.shape == (1, C, 1, 1) or arr.shape == (C, 1, 1)):\n        return False\n    return True",
            "def _check_shape(arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    return True if shape is of form\\n    (1,C,1,1) or (C,1,1)\\n    '\n    rank = len(arr.shape)\n    if not (rank == 3 or rank == 4):\n        return False\n    C = arr.shape[-3]\n    if not (arr.shape == (1, C, 1, 1) or arr.shape == (C, 1, 1)):\n        return False\n    return True"
        ]
    },
    {
        "func_name": "try_to_transform",
        "original": "def try_to_transform(mul_op, add_op, block):\n    non_const_input_mul = mul_op.x if mul_op.x.val is None else mul_op.y\n    if non_const_input_mul.rank != 4:\n        return False\n    gamma = _find_const_input_val(mul_op)\n    beta = _find_const_input_val(add_op)\n    if gamma is None or beta is None:\n        return False\n    if not (isinstance(gamma, np.ndarray) and isinstance(beta, np.ndarray)):\n        return False\n    if not (_check_shape(gamma) and _check_shape(beta)):\n        return False\n    C = gamma.shape[-3]\n    if C == 1:\n        return False\n    out_name = add_op.outputs[0].name\n    x = mb.batch_norm(x=non_const_input_mul, mean=np.zeros((C,), np.float32), variance=np.ones((C,), np.float32), gamma=np.squeeze(gamma), beta=np.squeeze(beta), name=out_name, before_op=mul_op)\n    add_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=add_op, old_var=add_op.outputs[0], new_var=x)\n    block.remove_ops([mul_op, add_op])\n    return True",
        "mutated": [
            "def try_to_transform(mul_op, add_op, block):\n    if False:\n        i = 10\n    non_const_input_mul = mul_op.x if mul_op.x.val is None else mul_op.y\n    if non_const_input_mul.rank != 4:\n        return False\n    gamma = _find_const_input_val(mul_op)\n    beta = _find_const_input_val(add_op)\n    if gamma is None or beta is None:\n        return False\n    if not (isinstance(gamma, np.ndarray) and isinstance(beta, np.ndarray)):\n        return False\n    if not (_check_shape(gamma) and _check_shape(beta)):\n        return False\n    C = gamma.shape[-3]\n    if C == 1:\n        return False\n    out_name = add_op.outputs[0].name\n    x = mb.batch_norm(x=non_const_input_mul, mean=np.zeros((C,), np.float32), variance=np.ones((C,), np.float32), gamma=np.squeeze(gamma), beta=np.squeeze(beta), name=out_name, before_op=mul_op)\n    add_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=add_op, old_var=add_op.outputs[0], new_var=x)\n    block.remove_ops([mul_op, add_op])\n    return True",
            "def try_to_transform(mul_op, add_op, block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    non_const_input_mul = mul_op.x if mul_op.x.val is None else mul_op.y\n    if non_const_input_mul.rank != 4:\n        return False\n    gamma = _find_const_input_val(mul_op)\n    beta = _find_const_input_val(add_op)\n    if gamma is None or beta is None:\n        return False\n    if not (isinstance(gamma, np.ndarray) and isinstance(beta, np.ndarray)):\n        return False\n    if not (_check_shape(gamma) and _check_shape(beta)):\n        return False\n    C = gamma.shape[-3]\n    if C == 1:\n        return False\n    out_name = add_op.outputs[0].name\n    x = mb.batch_norm(x=non_const_input_mul, mean=np.zeros((C,), np.float32), variance=np.ones((C,), np.float32), gamma=np.squeeze(gamma), beta=np.squeeze(beta), name=out_name, before_op=mul_op)\n    add_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=add_op, old_var=add_op.outputs[0], new_var=x)\n    block.remove_ops([mul_op, add_op])\n    return True",
            "def try_to_transform(mul_op, add_op, block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    non_const_input_mul = mul_op.x if mul_op.x.val is None else mul_op.y\n    if non_const_input_mul.rank != 4:\n        return False\n    gamma = _find_const_input_val(mul_op)\n    beta = _find_const_input_val(add_op)\n    if gamma is None or beta is None:\n        return False\n    if not (isinstance(gamma, np.ndarray) and isinstance(beta, np.ndarray)):\n        return False\n    if not (_check_shape(gamma) and _check_shape(beta)):\n        return False\n    C = gamma.shape[-3]\n    if C == 1:\n        return False\n    out_name = add_op.outputs[0].name\n    x = mb.batch_norm(x=non_const_input_mul, mean=np.zeros((C,), np.float32), variance=np.ones((C,), np.float32), gamma=np.squeeze(gamma), beta=np.squeeze(beta), name=out_name, before_op=mul_op)\n    add_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=add_op, old_var=add_op.outputs[0], new_var=x)\n    block.remove_ops([mul_op, add_op])\n    return True",
            "def try_to_transform(mul_op, add_op, block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    non_const_input_mul = mul_op.x if mul_op.x.val is None else mul_op.y\n    if non_const_input_mul.rank != 4:\n        return False\n    gamma = _find_const_input_val(mul_op)\n    beta = _find_const_input_val(add_op)\n    if gamma is None or beta is None:\n        return False\n    if not (isinstance(gamma, np.ndarray) and isinstance(beta, np.ndarray)):\n        return False\n    if not (_check_shape(gamma) and _check_shape(beta)):\n        return False\n    C = gamma.shape[-3]\n    if C == 1:\n        return False\n    out_name = add_op.outputs[0].name\n    x = mb.batch_norm(x=non_const_input_mul, mean=np.zeros((C,), np.float32), variance=np.ones((C,), np.float32), gamma=np.squeeze(gamma), beta=np.squeeze(beta), name=out_name, before_op=mul_op)\n    add_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=add_op, old_var=add_op.outputs[0], new_var=x)\n    block.remove_ops([mul_op, add_op])\n    return True",
            "def try_to_transform(mul_op, add_op, block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    non_const_input_mul = mul_op.x if mul_op.x.val is None else mul_op.y\n    if non_const_input_mul.rank != 4:\n        return False\n    gamma = _find_const_input_val(mul_op)\n    beta = _find_const_input_val(add_op)\n    if gamma is None or beta is None:\n        return False\n    if not (isinstance(gamma, np.ndarray) and isinstance(beta, np.ndarray)):\n        return False\n    if not (_check_shape(gamma) and _check_shape(beta)):\n        return False\n    C = gamma.shape[-3]\n    if C == 1:\n        return False\n    out_name = add_op.outputs[0].name\n    x = mb.batch_norm(x=non_const_input_mul, mean=np.zeros((C,), np.float32), variance=np.ones((C,), np.float32), gamma=np.squeeze(gamma), beta=np.squeeze(beta), name=out_name, before_op=mul_op)\n    add_op.enclosing_block.replace_uses_of_var_after_op(anchor_op=add_op, old_var=add_op.outputs[0], new_var=x)\n    block.remove_ops([mul_op, add_op])\n    return True"
        ]
    },
    {
        "func_name": "fuse_elementwise_to_batchnorm_block",
        "original": "def fuse_elementwise_to_batchnorm_block(block):\n    fusion_status = False\n    for op in list(block.operations):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_elementwise_to_batchnorm_block(b)\n        if len(op.blocks) > 0:\n            continue\n        add_op = match_pattern(op)\n        if add_op is not None:\n            with block:\n                fusion_status = try_to_transform(op, add_op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
        "mutated": [
            "def fuse_elementwise_to_batchnorm_block(block):\n    if False:\n        i = 10\n    fusion_status = False\n    for op in list(block.operations):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_elementwise_to_batchnorm_block(b)\n        if len(op.blocks) > 0:\n            continue\n        add_op = match_pattern(op)\n        if add_op is not None:\n            with block:\n                fusion_status = try_to_transform(op, add_op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
            "def fuse_elementwise_to_batchnorm_block(block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    fusion_status = False\n    for op in list(block.operations):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_elementwise_to_batchnorm_block(b)\n        if len(op.blocks) > 0:\n            continue\n        add_op = match_pattern(op)\n        if add_op is not None:\n            with block:\n                fusion_status = try_to_transform(op, add_op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
            "def fuse_elementwise_to_batchnorm_block(block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    fusion_status = False\n    for op in list(block.operations):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_elementwise_to_batchnorm_block(b)\n        if len(op.blocks) > 0:\n            continue\n        add_op = match_pattern(op)\n        if add_op is not None:\n            with block:\n                fusion_status = try_to_transform(op, add_op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
            "def fuse_elementwise_to_batchnorm_block(block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    fusion_status = False\n    for op in list(block.operations):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_elementwise_to_batchnorm_block(b)\n        if len(op.blocks) > 0:\n            continue\n        add_op = match_pattern(op)\n        if add_op is not None:\n            with block:\n                fusion_status = try_to_transform(op, add_op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status",
            "def fuse_elementwise_to_batchnorm_block(block):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    fusion_status = False\n    for op in list(block.operations):\n        for b in op.blocks:\n            block_changed = True\n            while block_changed:\n                block_changed = fuse_elementwise_to_batchnorm_block(b)\n        if len(op.blocks) > 0:\n            continue\n        add_op = match_pattern(op)\n        if add_op is not None:\n            with block:\n                fusion_status = try_to_transform(op, add_op, block)\n            if fusion_status:\n                return fusion_status\n    return fusion_status"
        ]
    },
    {
        "func_name": "fuse_elementwise_to_batchnorm",
        "original": "@register_pass(namespace='common')\ndef fuse_elementwise_to_batchnorm(prog):\n    \"\"\"\n    Fold mul + add into a batch norm,\n    if the const feeding into the mul/add is of shape (1,C,1,1) or (C,1,1)\n    and input to mul is of rank 4.\n\n    Given:\n             [Const]   [Const]\n                |         |\n                V         V\n    [...] --> [Mul] --> [Add] --> [...]\n\n    That is,\n\n        %2 = op1(%1)\n        %3 = mul(%2, constant)\n        %4 = add(%3, constant)\n        %5 = op2(%4)\n        ...\n\n    Result:\n\n    [...] --> [BatchNorm] --> [...]\n\n    That is,\n        %2 = op1(%1)\n        %4 = batchnorm(%2)\n        %5 = op2(%4)\n        ...\n\n    \"\"\"\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_elementwise_to_batchnorm_block(f)",
        "mutated": [
            "@register_pass(namespace='common')\ndef fuse_elementwise_to_batchnorm(prog):\n    if False:\n        i = 10\n    '\\n    Fold mul + add into a batch norm,\\n    if the const feeding into the mul/add is of shape (1,C,1,1) or (C,1,1)\\n    and input to mul is of rank 4.\\n\\n    Given:\\n             [Const]   [Const]\\n                |         |\\n                V         V\\n    [...] --> [Mul] --> [Add] --> [...]\\n\\n    That is,\\n\\n        %2 = op1(%1)\\n        %3 = mul(%2, constant)\\n        %4 = add(%3, constant)\\n        %5 = op2(%4)\\n        ...\\n\\n    Result:\\n\\n    [...] --> [BatchNorm] --> [...]\\n\\n    That is,\\n        %2 = op1(%1)\\n        %4 = batchnorm(%2)\\n        %5 = op2(%4)\\n        ...\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_elementwise_to_batchnorm_block(f)",
            "@register_pass(namespace='common')\ndef fuse_elementwise_to_batchnorm(prog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Fold mul + add into a batch norm,\\n    if the const feeding into the mul/add is of shape (1,C,1,1) or (C,1,1)\\n    and input to mul is of rank 4.\\n\\n    Given:\\n             [Const]   [Const]\\n                |         |\\n                V         V\\n    [...] --> [Mul] --> [Add] --> [...]\\n\\n    That is,\\n\\n        %2 = op1(%1)\\n        %3 = mul(%2, constant)\\n        %4 = add(%3, constant)\\n        %5 = op2(%4)\\n        ...\\n\\n    Result:\\n\\n    [...] --> [BatchNorm] --> [...]\\n\\n    That is,\\n        %2 = op1(%1)\\n        %4 = batchnorm(%2)\\n        %5 = op2(%4)\\n        ...\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_elementwise_to_batchnorm_block(f)",
            "@register_pass(namespace='common')\ndef fuse_elementwise_to_batchnorm(prog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Fold mul + add into a batch norm,\\n    if the const feeding into the mul/add is of shape (1,C,1,1) or (C,1,1)\\n    and input to mul is of rank 4.\\n\\n    Given:\\n             [Const]   [Const]\\n                |         |\\n                V         V\\n    [...] --> [Mul] --> [Add] --> [...]\\n\\n    That is,\\n\\n        %2 = op1(%1)\\n        %3 = mul(%2, constant)\\n        %4 = add(%3, constant)\\n        %5 = op2(%4)\\n        ...\\n\\n    Result:\\n\\n    [...] --> [BatchNorm] --> [...]\\n\\n    That is,\\n        %2 = op1(%1)\\n        %4 = batchnorm(%2)\\n        %5 = op2(%4)\\n        ...\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_elementwise_to_batchnorm_block(f)",
            "@register_pass(namespace='common')\ndef fuse_elementwise_to_batchnorm(prog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Fold mul + add into a batch norm,\\n    if the const feeding into the mul/add is of shape (1,C,1,1) or (C,1,1)\\n    and input to mul is of rank 4.\\n\\n    Given:\\n             [Const]   [Const]\\n                |         |\\n                V         V\\n    [...] --> [Mul] --> [Add] --> [...]\\n\\n    That is,\\n\\n        %2 = op1(%1)\\n        %3 = mul(%2, constant)\\n        %4 = add(%3, constant)\\n        %5 = op2(%4)\\n        ...\\n\\n    Result:\\n\\n    [...] --> [BatchNorm] --> [...]\\n\\n    That is,\\n        %2 = op1(%1)\\n        %4 = batchnorm(%2)\\n        %5 = op2(%4)\\n        ...\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_elementwise_to_batchnorm_block(f)",
            "@register_pass(namespace='common')\ndef fuse_elementwise_to_batchnorm(prog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Fold mul + add into a batch norm,\\n    if the const feeding into the mul/add is of shape (1,C,1,1) or (C,1,1)\\n    and input to mul is of rank 4.\\n\\n    Given:\\n             [Const]   [Const]\\n                |         |\\n                V         V\\n    [...] --> [Mul] --> [Add] --> [...]\\n\\n    That is,\\n\\n        %2 = op1(%1)\\n        %3 = mul(%2, constant)\\n        %4 = add(%3, constant)\\n        %5 = op2(%4)\\n        ...\\n\\n    Result:\\n\\n    [...] --> [BatchNorm] --> [...]\\n\\n    That is,\\n        %2 = op1(%1)\\n        %4 = batchnorm(%2)\\n        %5 = op2(%4)\\n        ...\\n\\n    '\n    for (f_name, f) in prog.functions.items():\n        block_changed = True\n        while block_changed:\n            block_changed = fuse_elementwise_to_batchnorm_block(f)"
        ]
    }
]