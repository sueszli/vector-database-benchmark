"""Rhythmic feature extraction"""
import numpy as np
import scipy
from .. import util
from .._cache import cache
from ..core.audio import autocorrelate
from ..core.spectrum import stft
from ..core.convert import tempo_frequencies, time_to_frames
from ..core.harmonic import f0_harmonics
from ..util.exceptions import ParameterError
from ..filters import get_window
from typing import Optional, Callable, Any
from .._typing import _WindowSpec
__all__ = ['tempogram', 'fourier_tempogram', 'tempo', 'tempogram_ratio']

def tempogram(*, y: Optional[np.ndarray]=None, sr: float=22050, onset_envelope: Optional[np.ndarray]=None, hop_length: int=512, win_length: int=384, center: bool=True, window: _WindowSpec='hann', norm: Optional[float]=np.inf) -> np.ndarray:
    if False:
        while True:
            i = 10
    'Compute the tempogram: local autocorrelation of the onset strength envelope. [#]_\n\n    .. [#] Grosche, Peter, Meinard Müller, and Frank Kurth.\n        "Cyclic tempogram - A mid-level tempo representation for music signals."\n        ICASSP, 2010.\n\n    Parameters\n    ----------\n    y : np.ndarray [shape=(..., n)] or None\n        Audio time series.  Multi-channel is supported.\n\n    sr : number > 0 [scalar]\n        sampling rate of ``y``\n\n    onset_envelope : np.ndarray [shape=(..., n) or (..., m, n)] or None\n        Optional pre-computed onset strength envelope as provided by\n        `librosa.onset.onset_strength`.\n\n        If multi-dimensional, tempograms are computed independently for each\n        band (first dimension).\n\n    hop_length : int > 0\n        number of audio samples between successive onset measurements\n\n    win_length : int > 0\n        length of the onset autocorrelation window (in frames/onset measurements)\n        The default settings (384) corresponds to ``384 * hop_length / sr ~= 8.9s``.\n\n    center : bool\n        If `True`, onset autocorrelation windows are centered.\n        If `False`, windows are left-aligned.\n\n    window : string, function, number, tuple, or np.ndarray [shape=(win_length,)]\n        A window specification as in `stft`.\n\n    norm : {np.inf, -np.inf, 0, float > 0, None}\n        Normalization mode.  Set to `None` to disable normalization.\n\n    Returns\n    -------\n    tempogram : np.ndarray [shape=(..., win_length, n)]\n        Localized autocorrelation of the onset strength envelope.\n\n        If given multi-band input (``onset_envelope.shape==(m,n)``) then\n        ``tempogram[i]`` is the tempogram of ``onset_envelope[i]``.\n\n    Raises\n    ------\n    ParameterError\n        if neither ``y`` nor ``onset_envelope`` are provided\n\n        if ``win_length < 1``\n\n    See Also\n    --------\n    fourier_tempogram\n    librosa.onset.onset_strength\n    librosa.util.normalize\n    librosa.stft\n\n    Examples\n    --------\n    >>> # Compute local onset autocorrelation\n    >>> y, sr = librosa.load(librosa.ex(\'nutcracker\'), duration=30)\n    >>> hop_length = 512\n    >>> oenv = librosa.onset.onset_strength(y=y, sr=sr, hop_length=hop_length)\n    >>> tempogram = librosa.feature.tempogram(onset_envelope=oenv, sr=sr,\n    ...                                       hop_length=hop_length)\n    >>> # Compute global onset autocorrelation\n    >>> ac_global = librosa.autocorrelate(oenv, max_size=tempogram.shape[0])\n    >>> ac_global = librosa.util.normalize(ac_global)\n    >>> # Estimate the global tempo for display purposes\n    >>> tempo = librosa.feature.tempo(onset_envelope=oenv, sr=sr,\n    ...                               hop_length=hop_length)[0]\n\n    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots(nrows=4, figsize=(10, 10))\n    >>> times = librosa.times_like(oenv, sr=sr, hop_length=hop_length)\n    >>> ax[0].plot(times, oenv, label=\'Onset strength\')\n    >>> ax[0].label_outer()\n    >>> ax[0].legend(frameon=True)\n    >>> librosa.display.specshow(tempogram, sr=sr, hop_length=hop_length,\n    >>>                          x_axis=\'time\', y_axis=\'tempo\', cmap=\'magma\',\n    ...                          ax=ax[1])\n    >>> ax[1].axhline(tempo, color=\'w\', linestyle=\'--\', alpha=1,\n    ...             label=\'Estimated tempo={:g}\'.format(tempo))\n    >>> ax[1].legend(loc=\'upper right\')\n    >>> ax[1].set(title=\'Tempogram\')\n    >>> x = np.linspace(0, tempogram.shape[0] * float(hop_length) / sr,\n    ...                 num=tempogram.shape[0])\n    >>> ax[2].plot(x, np.mean(tempogram, axis=1), label=\'Mean local autocorrelation\')\n    >>> ax[2].plot(x, ac_global, \'--\', alpha=0.75, label=\'Global autocorrelation\')\n    >>> ax[2].set(xlabel=\'Lag (seconds)\')\n    >>> ax[2].legend(frameon=True)\n    >>> freqs = librosa.tempo_frequencies(tempogram.shape[0], hop_length=hop_length, sr=sr)\n    >>> ax[3].semilogx(freqs[1:], np.mean(tempogram[1:], axis=1),\n    ...              label=\'Mean local autocorrelation\', base=2)\n    >>> ax[3].semilogx(freqs[1:], ac_global[1:], \'--\', alpha=0.75,\n    ...              label=\'Global autocorrelation\', base=2)\n    >>> ax[3].axvline(tempo, color=\'black\', linestyle=\'--\', alpha=.8,\n    ...             label=\'Estimated tempo={:g}\'.format(tempo))\n    >>> ax[3].legend(frameon=True)\n    >>> ax[3].set(xlabel=\'BPM\')\n    >>> ax[3].grid(True)\n    '
    from ..onset import onset_strength
    if win_length < 1:
        raise ParameterError('win_length must be a positive integer')
    ac_window = get_window(window, win_length, fftbins=True)
    if onset_envelope is None:
        if y is None:
            raise ParameterError('Either y or onset_envelope must be provided')
        onset_envelope = onset_strength(y=y, sr=sr, hop_length=hop_length)
    n = onset_envelope.shape[-1]
    if center:
        padding = [(0, 0) for _ in onset_envelope.shape]
        padding[-1] = (int(win_length // 2),) * 2
        onset_envelope = np.pad(onset_envelope, padding, mode='linear_ramp', end_values=[0, 0])
    odf_frame = util.frame(onset_envelope, frame_length=win_length, hop_length=1)
    if center:
        odf_frame = odf_frame[..., :n]
    ac_window = util.expand_to(ac_window, ndim=odf_frame.ndim, axes=-2)
    return util.normalize(autocorrelate(odf_frame * ac_window, axis=-2), norm=norm, axis=-2)

def fourier_tempogram(*, y: Optional[np.ndarray]=None, sr: float=22050, onset_envelope: Optional[np.ndarray]=None, hop_length: int=512, win_length: int=384, center: bool=True, window: _WindowSpec='hann') -> np.ndarray:
    if False:
        while True:
            i = 10
    'Compute the Fourier tempogram: the short-time Fourier transform of the\n    onset strength envelope. [#]_\n\n    .. [#] Grosche, Peter, Meinard Müller, and Frank Kurth.\n        "Cyclic tempogram - A mid-level tempo representation for music signals."\n        ICASSP, 2010.\n\n    Parameters\n    ----------\n    y : np.ndarray [shape=(..., n)] or None\n        Audio time series.  Multi-channel is supported.\n    sr : number > 0 [scalar]\n        sampling rate of ``y``\n    onset_envelope : np.ndarray [shape=(..., n)] or None\n        Optional pre-computed onset strength envelope as provided by\n        ``librosa.onset.onset_strength``.\n        Multi-channel is supported.\n    hop_length : int > 0\n        number of audio samples between successive onset measurements\n    win_length : int > 0\n        length of the onset window (in frames/onset measurements)\n        The default settings (384) corresponds to ``384 * hop_length / sr ~= 8.9s``.\n    center : bool\n        If `True`, onset windows are centered.\n        If `False`, windows are left-aligned.\n    window : string, function, number, tuple, or np.ndarray [shape=(win_length,)]\n        A window specification as in `stft`.\n\n    Returns\n    -------\n    tempogram : np.ndarray [shape=(..., win_length // 2 + 1, n)]\n        Complex short-time Fourier transform of the onset envelope.\n\n    Raises\n    ------\n    ParameterError\n        if neither ``y`` nor ``onset_envelope`` are provided\n\n        if ``win_length < 1``\n\n    See Also\n    --------\n    tempogram\n    librosa.onset.onset_strength\n    librosa.util.normalize\n    librosa.stft\n\n    Examples\n    --------\n    >>> # Compute local onset autocorrelation\n    >>> y, sr = librosa.load(librosa.ex(\'nutcracker\'))\n    >>> hop_length = 512\n    >>> oenv = librosa.onset.onset_strength(y=y, sr=sr, hop_length=hop_length)\n    >>> tempogram = librosa.feature.fourier_tempogram(onset_envelope=oenv, sr=sr,\n    ...                                               hop_length=hop_length)\n    >>> # Compute the auto-correlation tempogram, unnormalized to make comparison easier\n    >>> ac_tempogram = librosa.feature.tempogram(onset_envelope=oenv, sr=sr,\n    ...                                          hop_length=hop_length, norm=None)\n\n    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots(nrows=3, sharex=True)\n    >>> ax[0].plot(librosa.times_like(oenv), oenv, label=\'Onset strength\')\n    >>> ax[0].legend(frameon=True)\n    >>> ax[0].label_outer()\n    >>> librosa.display.specshow(np.abs(tempogram), sr=sr, hop_length=hop_length,\n    >>>                          x_axis=\'time\', y_axis=\'fourier_tempo\', cmap=\'magma\',\n    ...                          ax=ax[1])\n    >>> ax[1].set(title=\'Fourier tempogram\')\n    >>> ax[1].label_outer()\n    >>> librosa.display.specshow(ac_tempogram, sr=sr, hop_length=hop_length,\n    >>>                          x_axis=\'time\', y_axis=\'tempo\', cmap=\'magma\',\n    ...                          ax=ax[2])\n    >>> ax[2].set(title=\'Autocorrelation tempogram\')\n    '
    from ..onset import onset_strength
    if win_length < 1:
        raise ParameterError('win_length must be a positive integer')
    if onset_envelope is None:
        if y is None:
            raise ParameterError('Either y or onset_envelope must be provided')
        onset_envelope = onset_strength(y=y, sr=sr, hop_length=hop_length)
    return stft(onset_envelope, n_fft=win_length, hop_length=1, center=center, window=window)

@cache(level=30)
def tempo(*, y: Optional[np.ndarray]=None, sr: float=22050, onset_envelope: Optional[np.ndarray]=None, tg: Optional[np.ndarray]=None, hop_length: int=512, start_bpm: float=120, std_bpm: float=1.0, ac_size: float=8.0, max_tempo: Optional[float]=320.0, aggregate: Optional[Callable[..., Any]]=np.mean, prior: Optional[scipy.stats.rv_continuous]=None) -> np.ndarray:
    if False:
        while True:
            i = 10
    "Estimate the tempo (beats per minute)\n\n    Parameters\n    ----------\n    y : np.ndarray [shape=(..., n)] or None\n        audio time series. Multi-channel is supported.\n    sr : number > 0 [scalar]\n        sampling rate of the time series\n    onset_envelope : np.ndarray [shape=(..., n)]\n        pre-computed onset strength envelope\n    tg : np.ndarray\n        pre-computed tempogram.  If provided, then `y` and\n        `onset_envelope` are ignored, and `win_length` is\n        inferred from the shape of the tempogram.\n    hop_length : int > 0 [scalar]\n        hop length of the time series\n    start_bpm : float [scalar]\n        initial guess of the BPM\n    std_bpm : float > 0 [scalar]\n        standard deviation of tempo distribution\n    ac_size : float > 0 [scalar]\n        length (in seconds) of the auto-correlation window\n    max_tempo : float > 0 [scalar, optional]\n        If provided, only estimate tempo below this threshold\n    aggregate : callable [optional]\n        Aggregation function for estimating global tempo.\n        If `None`, then tempo is estimated independently for each frame.\n    prior : scipy.stats.rv_continuous [optional]\n        A prior distribution over tempo (in beats per minute).\n        By default, a pseudo-log-normal prior is used.\n        If given, ``start_bpm`` and ``std_bpm`` will be ignored.\n\n    Returns\n    -------\n    tempo : np.ndarray\n        estimated tempo (beats per minute).\n        If input is multi-channel, one tempo estimate per channel is provided.\n\n    See Also\n    --------\n    librosa.onset.onset_strength\n    librosa.feature.tempogram\n\n    Notes\n    -----\n    This function caches at level 30.\n\n    Examples\n    --------\n    >>> # Estimate a static tempo\n    >>> y, sr = librosa.load(librosa.ex('nutcracker'), duration=30)\n    >>> onset_env = librosa.onset.onset_strength(y=y, sr=sr)\n    >>> tempo = librosa.feature.tempo(onset_envelope=onset_env, sr=sr)\n    >>> tempo\n    array([143.555])\n\n    >>> # Or a static tempo with a uniform prior instead\n    >>> import scipy.stats\n    >>> prior = scipy.stats.uniform(30, 300)  # uniform over 30-300 BPM\n    >>> utempo = librosa.feature.tempo(onset_envelope=onset_env, sr=sr, prior=prior)\n    >>> utempo\n    array([161.499])\n\n    >>> # Or a dynamic tempo\n    >>> dtempo = librosa.feature.tempo(onset_envelope=onset_env, sr=sr,\n    ...                                aggregate=None)\n    >>> dtempo\n    array([ 89.103,  89.103,  89.103, ..., 123.047, 123.047, 123.047])\n\n    >>> # Dynamic tempo with a proper log-normal prior\n    >>> prior_lognorm = scipy.stats.lognorm(loc=np.log(120), scale=120, s=1)\n    >>> dtempo_lognorm = librosa.feature.tempo(onset_envelope=onset_env, sr=sr,\n    ...                                        aggregate=None,\n    ...                                        prior=prior_lognorm)\n    >>> dtempo_lognorm\n    array([ 89.103,  89.103,  89.103, ..., 123.047, 123.047, 123.047])\n\n    Plot the estimated tempo against the onset autocorrelation\n\n    >>> import matplotlib.pyplot as plt\n    >>> # Convert to scalar\n    >>> tempo = tempo.item()\n    >>> utempo = utempo.item()\n    >>> # Compute 2-second windowed autocorrelation\n    >>> hop_length = 512\n    >>> ac = librosa.autocorrelate(onset_env, max_size=2 * sr // hop_length)\n    >>> freqs = librosa.tempo_frequencies(len(ac), sr=sr,\n    ...                                   hop_length=hop_length)\n    >>> # Plot on a BPM axis.  We skip the first (0-lag) bin.\n    >>> fig, ax = plt.subplots()\n    >>> ax.semilogx(freqs[1:], librosa.util.normalize(ac)[1:],\n    ...              label='Onset autocorrelation', base=2)\n    >>> ax.axvline(tempo, 0, 1, alpha=0.75, linestyle='--', color='r',\n    ...             label='Tempo (default prior): {:.2f} BPM'.format(tempo))\n    >>> ax.axvline(utempo, 0, 1, alpha=0.75, linestyle=':', color='g',\n    ...             label='Tempo (uniform prior): {:.2f} BPM'.format(utempo))\n    >>> ax.set(xlabel='Tempo (BPM)', title='Static tempo estimation')\n    >>> ax.grid(True)\n    >>> ax.legend()\n\n    Plot dynamic tempo estimates over a tempogram\n\n    >>> fig, ax = plt.subplots()\n    >>> tg = librosa.feature.tempogram(onset_envelope=onset_env, sr=sr,\n    ...                                hop_length=hop_length)\n    >>> librosa.display.specshow(tg, x_axis='time', y_axis='tempo', cmap='magma', ax=ax)\n    >>> ax.plot(librosa.times_like(dtempo), dtempo,\n    ...          color='c', linewidth=1.5, label='Tempo estimate (default prior)')\n    >>> ax.plot(librosa.times_like(dtempo_lognorm), dtempo_lognorm,\n    ...          color='c', linewidth=1.5, linestyle='--',\n    ...          label='Tempo estimate (lognorm prior)')\n    >>> ax.set(title='Dynamic tempo estimation')\n    >>> ax.legend()\n    "
    if start_bpm <= 0:
        raise ParameterError('start_bpm must be strictly positive')
    if tg is None:
        win_length = time_to_frames(ac_size, sr=sr, hop_length=hop_length).item()
        tg = tempogram(y=y, sr=sr, onset_envelope=onset_envelope, hop_length=hop_length, win_length=win_length)
    else:
        win_length = tg.shape[-2]
    if aggregate is not None:
        tg = aggregate(tg, axis=-1, keepdims=True)
    assert tg is not None
    bpms = tempo_frequencies(win_length, hop_length=hop_length, sr=sr)
    if prior is None:
        logprior = -0.5 * ((np.log2(bpms) - np.log2(start_bpm)) / std_bpm) ** 2
    else:
        logprior = prior.logpdf(bpms)
    if max_tempo is not None:
        max_idx = int(np.argmax(bpms < max_tempo))
        logprior[:max_idx] = -np.inf
    logprior = util.expand_to(logprior, ndim=tg.ndim, axes=-2)
    best_period = np.argmax(np.log1p(1000000.0 * tg) + logprior, axis=-2)
    tempo_est: np.ndarray = np.take(bpms, best_period)
    return tempo_est

@cache(level=40)
def tempogram_ratio(*, y: Optional[np.ndarray]=None, sr: float=22050, onset_envelope: Optional[np.ndarray]=None, tg: Optional[np.ndarray]=None, bpm: Optional[np.ndarray]=None, hop_length: int=512, win_length: int=384, start_bpm: float=120, std_bpm: float=1.0, max_tempo: Optional[float]=320.0, freqs: Optional[np.ndarray]=None, factors: Optional[np.ndarray]=None, aggregate: Optional[Callable[..., Any]]=None, prior: Optional[scipy.stats.rv_continuous]=None, center: bool=True, window: _WindowSpec='hann', kind: str='linear', fill_value: float=0, norm: Optional[float]=np.inf) -> np.ndarray:
    if False:
        i = 10
        return i + 15
    'Tempogram ratio features, also known as spectral rhythm patterns. [1]_\n\n    This function summarizes the energy at metrically important multiples\n    of the tempo.  For example, if the tempo corresponds to the quarter-note\n    period, the tempogram ratio will measure the energy at the eighth note,\n    sixteenth note, half note, whole note, etc. periods, as well as dotted\n    and triplet ratios.\n\n    By default, the multiplicative factors used here are as specified by\n    [2]_.  If the estimated tempo corresponds to a quarter note, these factors\n    will measure relative energy at the following metrical subdivisions:\n\n    +-------+--------+------------------+\n    | Index | Factor | Description      |\n    +=======+========+==================+\n    |     0 |    4   | Sixteenth note   |\n    +-------+--------+------------------+\n    |     1 |    8/3 | Dotted sixteenth |\n    +-------+--------+------------------+\n    |     2 |    3   | Eighth triplet   |\n    +-------+--------+------------------+\n    |     3 |    2   | Eighth note      |\n    +-------+--------+------------------+\n    |     4 |    4/3 | Dotted eighth    |\n    +-------+--------+------------------+\n    |     5 |    3/2 | Quarter triplet  |\n    +-------+--------+------------------+\n    |     6 |    1   | Quarter note     |\n    +-------+--------+------------------+\n    |     7 |    2/3 | Dotted quarter   |\n    +-------+--------+------------------+\n    |     8 |    3/4 | Half triplet     |\n    +-------+--------+------------------+\n    |     9 |    1/2 | Half note        |\n    +-------+--------+------------------+\n    |    10 |    1/3 | Dotted half note |\n    +-------+--------+------------------+\n    |    11 |    3/8 | Whole triplet    |\n    +-------+--------+------------------+\n    |    12 |    1/4 | Whole note       |\n    +-------+--------+------------------+\n\n    .. [1] Peeters, Geoffroy.\n        "Rhythm Classification Using Spectral Rhythm Patterns."\n        In ISMIR, pp. 644-647. 2005.\n\n    .. [2] Prockup, Matthew, Andreas F. Ehmann, Fabien Gouyon, Erik M. Schmidt, and Youngmoo E. Kim.\n        "Modeling musical rhythm at scale with the music genome project."\n        In 2015 IEEE workshop on applications of signal processing to audio and acoustics (WASPAA), pp. 1-5. IEEE, 2015.\n\n    Parameters\n    ----------\n    y : np.ndarray [shape=(..., n)] or None\n        audio time series\n    sr : number > 0 [scalar]\n        sampling rate of the time series\n    onset_envelope : np.ndarray [shape=(..., n)]\n        pre-computed onset strength envelope\n    tg : np.ndarray\n        pre-computed tempogram.  If provided, then `y` and\n        `onset_envelope` are ignored, and `win_length` is\n        inferred from the shape of the tempogram.\n    bpm : np.ndarray\n        pre-computed tempo estimate.  This must be a per-frame\n        estimate, and have dimension compatible with `tg`.\n    hop_length : int > 0 [scalar]\n        hop length of the time series\n    win_length : int > 0 [scalar]\n        window length of the autocorrelation window for tempogram\n        calculation\n    start_bpm : float [scalar]\n        initial guess of the BPM if `bpm` is not provided\n    std_bpm : float > 0 [scalar]\n        standard deviation of tempo distribution\n    max_tempo : float > 0 [scalar, optional]\n        If provided, only estimate tempo below this threshold\n    freqs : np.ndarray\n        Frequencies (in BPM) of the tempogram axis.\n    factors : np.ndarray\n        Multiples of the fundamental tempo (bpm) to estimate.\n        If not provided, the factors are as specified above.\n    prior : scipy.stats.rv_continuous [optional]\n        A prior distribution over tempo (in beats per minute).\n        By default, a pseudo-log-normal prior is used.\n        If given, ``start_bpm`` and ``std_bpm`` will be ignored.\n    center : bool\n        If `True`, onset windows are centered.\n        If `False`, windows are left-aligned.\n    aggregate : callable [optional]\n        Aggregation function for estimating global tempogram ratio.\n        If `None`, then ratios are estimated independently for each frame.\n    window : string, function, number, tuple, or np.ndarray [shape=(win_length,)]\n        A window specification as in `stft`.\n    kind : str\n        Interpolation mode for measuring tempogram ratios\n    fill_value : float\n        The value to fill when extrapolating beyond the observed\n        frequency range.\n    norm : {np.inf, -np.inf, 0, float > 0, None}\n        Normalization mode.  Set to `None` to disable normalization.\n\n    Returns\n    -------\n    tgr : np.ndarray\n        The tempogram ratio for the specified factors.\n        If `aggregate` is provided, the trailing time axis\n        will be removed.\n        If `aggregate` is not provided (default), ratios\n        will be estimated for each frame.\n\n    See Also\n    --------\n    tempogram\n    tempo\n    librosa.f0_harmonics\n    librosa.tempo_frequencies\n\n    Examples\n    --------\n    Compute tempogram ratio features using the default factors\n    for a waltz (3/4 time)\n\n    >>> import matplotlib.pyplot as plt\n    >>> y, sr = librosa.load(librosa.ex(\'sweetwaltz\'))\n    >>> tempogram = librosa.feature.tempogram(y=y, sr=sr)\n    >>> tgr = librosa.feature.tempogram_ratio(tg=tempogram, sr=sr)\n    >>> fig, ax = plt.subplots(nrows=2, sharex=True)\n    >>> librosa.display.specshow(tempogram, x_axis=\'time\', y_axis=\'tempo\',\n    ...                          ax=ax[0])\n    >>> librosa.display.specshow(tgr, x_axis=\'time\', ax=ax[1])\n    >>> ax[0].label_outer()\n    >>> ax[0].set(title="Tempogram")\n    >>> ax[1].set(title="Tempogram ratio")\n    '
    if tg is None:
        tg = tempogram(y=y, sr=sr, onset_envelope=onset_envelope, hop_length=hop_length, win_length=win_length, center=center, window=window, norm=norm)
    if freqs is None:
        freqs = tempo_frequencies(sr=sr, n_bins=len(tg), hop_length=hop_length)
    if bpm is None:
        bpm = tempo(sr=sr, tg=tg, hop_length=hop_length, start_bpm=start_bpm, std_bpm=std_bpm, max_tempo=max_tempo, aggregate=None, prior=prior)
    if factors is None:
        factors = np.array([4, 8 / 3, 3, 2, 4 / 3, 3 / 2, 1, 2 / 3, 3 / 4, 1 / 2, 1 / 3, 3 / 8, 1 / 4])
    tgr = f0_harmonics(tg, freqs=freqs, f0=bpm, harmonics=factors, kind=kind, fill_value=fill_value)
    if aggregate is not None:
        return aggregate(tgr, axis=-1)
    return tgr