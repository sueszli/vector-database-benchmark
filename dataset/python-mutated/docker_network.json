[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Only load if the docker execution module is available\n    \"\"\"\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Only load if the docker execution module is available\\n    '\n    if 'docker.version' in __salt__:\n        return __virtualname__\n    return (False, __salt__.missing_fun_string('docker.version'))"
        ]
    },
    {
        "func_name": "_normalize_pools",
        "original": "def _normalize_pools(existing, desired):\n    pools = {'existing': {4: None, 6: None}, 'desired': {4: None, 6: None}}\n    for pool in existing['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        pools['existing'][subnet.version] = pool\n    for pool in desired['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        if pools['desired'][subnet.version] is not None:\n            raise ValueError(f'Only one IPv{subnet.version} pool is permitted')\n        else:\n            pools['desired'][subnet.version] = pool\n    if pools['desired'][6] and (not pools['desired'][4]):\n        raise ValueError('An IPv4 pool is required when an IPv6 pool is used. See the documentation for details.')\n    existing['Config'] = [pools['existing'][x] for x in (4, 6) if pools['existing'][x] is not None]\n    desired['Config'] = [pools['desired'][x] for x in (4, 6) if pools['desired'][x] is not None]",
        "mutated": [
            "def _normalize_pools(existing, desired):\n    if False:\n        i = 10\n    pools = {'existing': {4: None, 6: None}, 'desired': {4: None, 6: None}}\n    for pool in existing['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        pools['existing'][subnet.version] = pool\n    for pool in desired['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        if pools['desired'][subnet.version] is not None:\n            raise ValueError(f'Only one IPv{subnet.version} pool is permitted')\n        else:\n            pools['desired'][subnet.version] = pool\n    if pools['desired'][6] and (not pools['desired'][4]):\n        raise ValueError('An IPv4 pool is required when an IPv6 pool is used. See the documentation for details.')\n    existing['Config'] = [pools['existing'][x] for x in (4, 6) if pools['existing'][x] is not None]\n    desired['Config'] = [pools['desired'][x] for x in (4, 6) if pools['desired'][x] is not None]",
            "def _normalize_pools(existing, desired):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pools = {'existing': {4: None, 6: None}, 'desired': {4: None, 6: None}}\n    for pool in existing['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        pools['existing'][subnet.version] = pool\n    for pool in desired['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        if pools['desired'][subnet.version] is not None:\n            raise ValueError(f'Only one IPv{subnet.version} pool is permitted')\n        else:\n            pools['desired'][subnet.version] = pool\n    if pools['desired'][6] and (not pools['desired'][4]):\n        raise ValueError('An IPv4 pool is required when an IPv6 pool is used. See the documentation for details.')\n    existing['Config'] = [pools['existing'][x] for x in (4, 6) if pools['existing'][x] is not None]\n    desired['Config'] = [pools['desired'][x] for x in (4, 6) if pools['desired'][x] is not None]",
            "def _normalize_pools(existing, desired):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pools = {'existing': {4: None, 6: None}, 'desired': {4: None, 6: None}}\n    for pool in existing['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        pools['existing'][subnet.version] = pool\n    for pool in desired['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        if pools['desired'][subnet.version] is not None:\n            raise ValueError(f'Only one IPv{subnet.version} pool is permitted')\n        else:\n            pools['desired'][subnet.version] = pool\n    if pools['desired'][6] and (not pools['desired'][4]):\n        raise ValueError('An IPv4 pool is required when an IPv6 pool is used. See the documentation for details.')\n    existing['Config'] = [pools['existing'][x] for x in (4, 6) if pools['existing'][x] is not None]\n    desired['Config'] = [pools['desired'][x] for x in (4, 6) if pools['desired'][x] is not None]",
            "def _normalize_pools(existing, desired):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pools = {'existing': {4: None, 6: None}, 'desired': {4: None, 6: None}}\n    for pool in existing['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        pools['existing'][subnet.version] = pool\n    for pool in desired['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        if pools['desired'][subnet.version] is not None:\n            raise ValueError(f'Only one IPv{subnet.version} pool is permitted')\n        else:\n            pools['desired'][subnet.version] = pool\n    if pools['desired'][6] and (not pools['desired'][4]):\n        raise ValueError('An IPv4 pool is required when an IPv6 pool is used. See the documentation for details.')\n    existing['Config'] = [pools['existing'][x] for x in (4, 6) if pools['existing'][x] is not None]\n    desired['Config'] = [pools['desired'][x] for x in (4, 6) if pools['desired'][x] is not None]",
            "def _normalize_pools(existing, desired):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pools = {'existing': {4: None, 6: None}, 'desired': {4: None, 6: None}}\n    for pool in existing['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        pools['existing'][subnet.version] = pool\n    for pool in desired['Config']:\n        subnet = ipaddress.ip_network(pool.get('Subnet'))\n        if pools['desired'][subnet.version] is not None:\n            raise ValueError(f'Only one IPv{subnet.version} pool is permitted')\n        else:\n            pools['desired'][subnet.version] = pool\n    if pools['desired'][6] and (not pools['desired'][4]):\n        raise ValueError('An IPv4 pool is required when an IPv6 pool is used. See the documentation for details.')\n    existing['Config'] = [pools['existing'][x] for x in (4, 6) if pools['existing'][x] is not None]\n    desired['Config'] = [pools['desired'][x] for x in (4, 6) if pools['desired'][x] is not None]"
        ]
    },
    {
        "func_name": "present",
        "original": "def present(name, skip_translate=None, ignore_collisions=False, validate_ip_addrs=True, containers=None, reconnect=True, **kwargs):\n    \"\"\"\n    .. versionchanged:: 2018.3.0\n        Support added for network configuration options other than ``driver``\n        and ``driver_opts``, as well as IPAM configuration.\n\n    Ensure that a network is present\n\n    .. note::\n        This state supports all arguments for network and IPAM pool\n        configuration which are available for the release of docker-py\n        installed on the minion. For that reason, the arguments described below\n        in the :ref:`NETWORK CONFIGURATION\n        <salt-states-docker-network-present-netconf>` and :ref:`IP ADDRESS\n        MANAGEMENT (IPAM) <salt-states-docker-network-present-ipam>` sections\n        may not accurately reflect what is available on the minion. The\n        :py:func:`docker.get_client_args\n        <salt.modules.dockermod.get_client_args>` function can be used to check\n        the available arguments for the installed version of docker-py (they\n        are found in the ``network_config`` and ``ipam_config`` sections of the\n        return data), but Salt will not prevent a user from attempting to use\n        an argument which is unsupported in the release of Docker which is\n        installed. In those cases, network creation be attempted but will fail.\n\n    name\n        Network name\n\n    skip_translate\n        This function translates Salt SLS input into the format which\n        docker-py expects. However, in the event that Salt's translation logic\n        fails (due to potential changes in the Docker Remote API, or to bugs in\n        the translation code), this argument can be used to exert granular\n        control over which arguments are translated and which are not.\n\n        Pass this argument as a comma-separated list (or Python list) of\n        arguments, and translation for each passed argument name will be\n        skipped. Alternatively, pass ``True`` and *all* translation will be\n        skipped.\n\n        Skipping tranlsation allows for arguments to be formatted directly in\n        the format which docker-py expects. This allows for API changes and\n        other issues to be more easily worked around. See the following links\n        for more information:\n\n        - `docker-py Low-level API`_\n        - `Docker Engine API`_\n\n        .. versionadded:: 2018.3.0\n\n    .. _`docker-py Low-level API`: http://docker-py.readthedocs.io/en/stable/api.html#docker.api.container.ContainerApiMixin.create_container\n    .. _`Docker Engine API`: https://docs.docker.com/engine/api/v1.33/#operation/ContainerCreate\n\n    ignore_collisions : False\n        Since many of docker-py's arguments differ in name from their CLI\n        counterparts (with which most Docker users are more familiar), Salt\n        detects usage of these and aliases them to the docker-py version of\n        that argument. However, if both the alias and the docker-py version of\n        the same argument (e.g. ``options`` and ``driver_opts``) are used, an error\n        will be raised. Set this argument to ``True`` to suppress these errors\n        and keep the docker-py version of the argument.\n\n        .. versionadded:: 2018.3.0\n\n    validate_ip_addrs : True\n        For parameters which accept IP addresses/subnets as input, validation\n        will be performed. To disable, set this to ``False``.\n\n        .. versionadded:: 2018.3.0\n\n    containers\n        A list of containers which should be connected to this network.\n\n        .. note::\n            As of the 2018.3.0 release, this is not the recommended way of\n            managing a container's membership in a network, for a couple\n            reasons:\n\n            1. It does not support setting static IPs, aliases, or links in the\n               container's IP configuration.\n            2. If a :py:func:`docker_container.running\n               <salt.states.docker_container.running>` state replaces a\n               container, it will not be reconnected to the network until the\n               ``docker_network.present`` state is run again. Since containers\n               often have ``require`` requisites to ensure that the network\n               is present, this means that the ``docker_network.present`` state\n               ends up being run *before* the :py:func:`docker_container.running\n               <salt.states.docker_container.running>`, leaving the container\n               unattached at the end of the Salt run.\n\n            For these reasons, it is recommended to use\n            :ref:`docker_container.running's network management support\n            <salt-states-docker-container-network-management>`.\n\n    reconnect : True\n        If ``containers`` is not used, and the network is replaced, then Salt\n        will keep track of the containers which were connected to the network\n        and reconnect them to the network after it is replaced. Salt will first\n        attempt to reconnect using the same IP the container had before the\n        network was replaced. If that fails (for instance, if the network was\n        replaced because the subnet was modified), then the container will be\n        reconnected without an explicit IP address, and its IP will be assigned\n        by Docker.\n\n        Set this option to ``False`` to keep Salt from trying to reconnect\n        containers. This can be useful in some cases when :ref:`managing static\n        IPs in docker_container.running\n        <salt-states-docker-container-network-management>`. For instance, if a\n        network's subnet is modified, it is likely that the static IP will need\n        to be updated in the ``docker_container.running`` state as well. When\n        the network is replaced, the initial reconnect attempt would fail, and\n        the container would be reconnected with an automatically-assigned IP\n        address. Then, when the ``docker_container.running`` state executes, it\n        would disconnect the network *again* and reconnect using the new static\n        IP. Disabling the reconnect behavior in these cases would prevent the\n        unnecessary extra reconnection.\n\n        .. versionadded:: 2018.3.0\n\n    .. _salt-states-docker-network-present-netconf:\n\n    **NETWORK CONFIGURATION ARGUMENTS**\n\n    driver\n        Network driver\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - driver: macvlan\n\n    driver_opts (or *driver_opt*, or *options*)\n        Options for the network driver. Either a dictionary of option names and\n        values or a Python list of strings in the format ``varname=value``. The\n        below three examples are equivalent:\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - driver: macvlan\n                - driver_opts: macvlan_mode=bridge,parent=eth0\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - driver: macvlan\n                - driver_opts:\n                  - macvlan_mode=bridge\n                  - parent=eth0\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - driver: macvlan\n                - driver_opts:\n                  - macvlan_mode: bridge\n                  - parent: eth0\n\n        The options can also simply be passed as a dictionary, though this can\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\n        with how PyYAML loads nested data structures:\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - driver: macvlan\n                - driver_opts:\n                    macvlan_mode: bridge\n                    parent: eth0\n\n    check_duplicate : True\n        If ``True``, checks for networks with duplicate names. Since networks\n        are primarily keyed based on a random ID and not on the name, and\n        network name is strictly a user-friendly alias to the network which is\n        uniquely identified using ID, there is no guaranteed way to check for\n        duplicates. This option providess a best effort, checking for any\n        networks which have the same name, but it is not guaranteed to catch\n        all name collisions.\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - check_duplicate: False\n\n    internal : False\n        If ``True``, restricts external access to the network\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - internal: True\n\n    labels\n        Add metadata to the network. Labels can be set both with and without\n        values, and labels with values can be passed either as ``key=value`` or\n        ``key: value`` pairs. For example, while the below would be very\n        confusing to read, it is technically valid, and demonstrates the\n        different ways in which labels can be passed:\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - labels:\n                  - foo\n                  - bar=baz\n                  - hello: world\n\n        The labels can also simply be passed as a YAML dictionary, though this\n        can be error-prone due to some :ref:`idiosyncrasies\n        <yaml-idiosyncrasies>` with how PyYAML loads nested data structures:\n\n        .. code-block:: yaml\n\n            foo:\n              docker_network.present:\n                - labels:\n                    foo: ''\n                    bar: baz\n                    hello: world\n\n        .. versionchanged:: 2018.3.0\n            Methods for specifying labels can now be mixed. Earlier releases\n            required either labels with or without values.\n\n    enable_ipv6 (or *ipv6*) : False\n        Enable IPv6 on the network\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - enable_ipv6: True\n\n        .. note::\n            While it should go without saying, this argument must be set to\n            ``True`` to :ref:`configure an IPv6 subnet\n            <salt-states-docker-network-present-ipam>`. Also, if this option is\n            turned on without an IPv6 subnet explicitly configured, you will\n            get an error unless you have set up a fixed IPv6 subnet. Consult\n            the `Docker IPv6 docs`_ for information on how to do this.\n\n            .. _`Docker IPv6 docs`: https://docs.docker.com/v17.09/engine/userguide/networking/default_network/ipv6/\n\n    attachable : False\n        If ``True``, and the network is in the global scope, non-service\n        containers on worker nodes will be able to connect to the network.\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - attachable: True\n\n        .. note::\n            This option cannot be reliably managed on CentOS 7. This is because\n            while support for this option was added in API version 1.24, its\n            value was not added to the inpsect results until API version 1.26.\n            The version of Docker which is available for CentOS 7 runs API\n            version 1.24, meaning that while Salt can pass this argument to the\n            API, it has no way of knowing the value of this config option in an\n            existing Docker network.\n\n    scope\n        Specify the network's scope (``local``, ``global`` or ``swarm``)\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - scope: local\n\n    ingress : False\n        If ``True``, create an ingress network which provides the routing-mesh in\n        swarm mode\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - ingress: True\n\n    .. _salt-states-docker-network-present-ipam:\n\n    **IP ADDRESS MANAGEMENT (IPAM)**\n\n    This state supports networks with either IPv4, or both IPv4 and IPv6. If\n    configuring IPv4, then you can pass the :ref:`IPAM pool arguments\n    <salt-states-docker-network-present-ipam-pool-arguments>` below as\n    individual arguments. However, if configuring IPv4 and IPv6, the arguments\n    must be passed as a list of dictionaries, in the ``ipam_pools`` argument\n    (click :ref:`here <salt-states-docker-network-present-ipam-examples>` for\n    some examples). `These docs`_ also have more information on these\n    arguments.\n\n    .. _`These docs`: http://docker-py.readthedocs.io/en/stable/api.html#docker.types.IPAMPool\n\n    *IPAM ARGUMENTS*\n\n    ipam_driver\n        IPAM driver to use, if different from the default one\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - ipam_driver: foo\n\n    ipam_opts\n        Options for the IPAM driver. Either a dictionary of option names and\n        values or a Python list of strings in the format ``varname=value``. The\n        below three examples are equivalent:\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - ipam_driver: foo\n                - ipam_opts: foo=bar,baz=qux\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - ipam_driver: foo\n                - ipam_opts:\n                  - foo=bar\n                  - baz=qux\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - ipam_driver: foo\n                - ipam_opts:\n                  - foo: bar\n                  - baz: qux\n\n        The options can also simply be passed as a dictionary, though this can\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\n        with how PyYAML loads nested data structures:\n\n        .. code-block:: yaml\n\n            mynet:\n              docker_network.present:\n                - ipam_driver: macvlan\n                - ipam_opts:\n                    foo: bar\n                    baz: qux\n\n    .. _salt-states-docker-network-present-ipam-pool-arguments:\n\n    *IPAM POOL ARGUMENTS*\n\n    subnet\n        Subnet in CIDR format that represents a network segment\n\n    iprange (or *ip_range*)\n        Allocate container IP from a sub-range within the subnet\n\n        Subnet in CIDR format that represents a network segment\n\n    gateway\n        IPv4 or IPv6 gateway for the master subnet\n\n    aux_addresses (or *aux_address*)\n        A dictionary of mapping container names to IP addresses which should be\n        allocated for them should they connect to the network. Either a\n        dictionary of option names and values or a Python list of strings in\n        the format ``host=ipaddr``.\n\n    .. _salt-states-docker-network-present-ipam-examples:\n\n    *IPAM CONFIGURATION EXAMPLES*\n\n    Below is an example of an IPv4-only network (keep in mind that ``subnet``\n    is the only required argument).\n\n    .. code-block:: yaml\n\n        mynet:\n          docker_network.present:\n            - subnet: 10.0.20.0/24\n            - iprange: 10.0.20.128/25\n            - gateway: 10.0.20.254\n            - aux_addresses:\n              - foo.bar.tld: 10.0.20.50\n              - hello.world.tld: 10.0.20.51\n\n    .. note::\n        The ``aux_addresses`` can be passed differently, in the same way that\n        ``driver_opts`` and ``ipam_opts`` can.\n\n    This same network could also be configured this way:\n\n    .. code-block:: yaml\n\n        mynet:\n          docker_network.present:\n            - ipam_pools:\n              - subnet: 10.0.20.0/24\n                iprange: 10.0.20.128/25\n                gateway: 10.0.20.254\n                aux_addresses:\n                  foo.bar.tld: 10.0.20.50\n                  hello.world.tld: 10.0.20.51\n\n    Here is an example of a mixed IPv4/IPv6 subnet.\n\n    .. code-block:: yaml\n\n        mynet:\n          docker_network.present:\n            - ipam_pools:\n              - subnet: 10.0.20.0/24\n                gateway: 10.0.20.1\n              - subnet: fe3f:2180:26:1::/123\n                gateway: fe3f:2180:26:1::1\n    \"\"\"\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    to_connect = {}\n    missing_containers = []\n    stopped_containers = []\n    for cname in __utils__['args.split_input'](containers or []):\n        try:\n            cinfo = __salt__['docker.inspect_container'](cname)\n        except CommandExecutionError:\n            missing_containers.append(cname)\n        else:\n            try:\n                cid = cinfo['Id']\n            except KeyError:\n                missing_containers.append(cname)\n            else:\n                if not cinfo.get('State', {}).get('Running', False):\n                    stopped_containers.append(cname)\n                else:\n                    to_connect[cid] = {'Name': cname}\n    if missing_containers:\n        ret.setdefault('warnings', []).append('The following containers do not exist: {}.'.format(', '.join(missing_containers)))\n    if stopped_containers:\n        ret.setdefault('warnings', []).append('The following containers are not running: {}.'.format(', '.join(stopped_containers)))\n    disconnected_containers = {}\n    try:\n        kwargs = __utils__['docker.translate_input'](salt.utils.dockermod.translate.network, skip_translate=skip_translate, ignore_collisions=ignore_collisions, validate_ip_addrs=validate_ip_addrs, **__utils__['args.clean_kwargs'](**kwargs))\n    except Exception as exc:\n        ret['comment'] = exc.__str__()\n        return ret\n    ipam_kwargs = {}\n    ipam_kwarg_names = ['ipam', 'ipam_driver', 'ipam_opts', 'ipam_pools']\n    ipam_kwarg_names.extend(__salt__['docker.get_client_args']('ipam_config')['ipam_config'])\n    for key in ipam_kwarg_names:\n        try:\n            ipam_kwargs[key] = kwargs.pop(key)\n        except KeyError:\n            pass\n    if 'ipam' in ipam_kwargs:\n        if len(ipam_kwargs) > 1:\n            ret['comment'] = \"Cannot mix the 'ipam' argument with any of the IPAM config arguments. See documentation for details.\"\n            return ret\n        ipam_config = ipam_kwargs['ipam']\n    else:\n        ipam_pools = ipam_kwargs.pop('ipam_pools', ())\n        try:\n            ipam_config = __utils__['docker.create_ipam_config'](*ipam_pools, **ipam_kwargs)\n        except Exception as exc:\n            ret['comment'] = exc.__str__()\n            return ret\n    create_network = True\n    if network is not None:\n        log.debug(\"Docker network '%s' already exists\", name)\n        ret['comment'] = f\"Network '{name}' already exists, and is configured as specified\"\n        log.trace(\"Details of docker network '%s': %s\", name, network)\n        temp_net_name = ''.join((random.choice(string.ascii_lowercase) for _ in range(20)))\n        try:\n            enable_ipv6 = kwargs.pop('enable_ipv6', None)\n            kwargs_tmp = kwargs\n            driver = kwargs.get('driver')\n            driver_opts = kwargs.get('options', {})\n            bridge_name = driver_opts.get('com.docker.network.bridge.name', None)\n            if driver == 'bridge' and bridge_name is not None:\n                tmp_name = str(bridge_name) + 'comp'\n                kwargs_tmp['options']['com.docker.network.bridge.name'] = tmp_name[-14:]\n            __salt__['docker.create_network'](temp_net_name, skip_translate=True, enable_ipv6=False, **kwargs_tmp)\n        except CommandExecutionError as exc:\n            ret['comment'] = 'Failed to create temp network for comparison: {}'.format(exc.__str__())\n            return ret\n        else:\n            if enable_ipv6 is not None:\n                kwargs['enable_ipv6'] = enable_ipv6\n        try:\n            try:\n                temp_net_info = __salt__['docker.inspect_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret['comment'] = 'Failed to inspect temp network: {}'.format(exc.__str__())\n                return ret\n            else:\n                temp_net_info['EnableIPv6'] = bool(enable_ipv6)\n            temp_net_info['IPAM'] = ipam_config\n            existing_pool_count = len(network['IPAM']['Config'])\n            desired_pool_count = len(temp_net_info['IPAM']['Config'])\n            is_default_pool = lambda x: True if sorted(x) == ['Gateway', 'Subnet'] else False\n            if desired_pool_count == 0 and existing_pool_count == 1 and is_default_pool(network['IPAM']['Config'][0]):\n                network['IPAM']['Config'] = []\n            changes = __salt__['docker.compare_networks'](network, temp_net_info, ignore='Name,Id,Created,Containers')\n            if not changes:\n                create_network = False\n            else:\n                ret['changes'][name] = changes\n                if __opts__['test']:\n                    ret['result'] = None\n                    ret['comment'] = 'Network would be recreated with new config'\n                    return ret\n                if network['Containers']:\n                    disconnected_containers = copy.deepcopy(network['Containers'])\n                    if not containers and reconnect:\n                        for cid in disconnected_containers:\n                            try:\n                                cinfo = __salt__['docker.inspect_container'](cid)\n                                netinfo = cinfo['NetworkSettings']['Networks'][name]\n                                net_links = netinfo.get('Links') or []\n                                net_aliases = netinfo.get('Aliases') or []\n                                if net_links:\n                                    disconnected_containers[cid]['Links'] = net_links\n                                if net_aliases:\n                                    disconnected_containers[cid]['Aliases'] = net_aliases\n                            except (CommandExecutionError, KeyError, ValueError):\n                                continue\n                remove_result = _remove_network(network)\n                if not remove_result['result']:\n                    return remove_result\n                network['Containers'] = {}\n        finally:\n            try:\n                __salt__['docker.remove_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret.setdefault('warnings', []).append(\"Failed to remove temp network '{}': {}.\".format(temp_net_name, exc.__str__()))\n    if create_network:\n        log.debug(\"Network '%s' will be created\", name)\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'Network will be created'\n            return ret\n        kwargs['ipam'] = ipam_config\n        try:\n            __salt__['docker.create_network'](name, skip_translate=True, **kwargs)\n        except Exception as exc:\n            ret['comment'] = \"Failed to create network '{}': {}\".format(name, exc.__str__())\n            return ret\n        else:\n            action = 'recreated' if network is not None else 'created'\n            ret['changes'][action] = True\n            ret['comment'] = \"Network '{}' {}\".format(name, 'created' if network is None else 'was replaced with updated config')\n            network = {'Containers': {}}\n    if containers is None and reconnect and disconnected_containers:\n        to_connect = disconnected_containers\n    for cid in list(to_connect):\n        if cid in network['Containers']:\n            del to_connect[cid]\n    errors = []\n    if to_connect:\n        for (cid, connect_info) in to_connect.items():\n            connect_kwargs = {}\n            if cid in disconnected_containers:\n                for (key_name, arg_name) in (('IPv4Address', 'ipv4_address'), ('IPV6Address', 'ipv6_address'), ('Links', 'links'), ('Aliases', 'aliases')):\n                    try:\n                        connect_kwargs[arg_name] = connect_info[key_name]\n                    except (KeyError, AttributeError):\n                        continue\n                    else:\n                        if key_name.endswith('Address'):\n                            connect_kwargs[arg_name] = connect_kwargs[arg_name].rsplit('/', 1)[0]\n            try:\n                __salt__['docker.connect_container_to_network'](cid, name, **connect_kwargs)\n            except CommandExecutionError as exc:\n                if not connect_kwargs:\n                    errors.append(exc.__str__())\n                else:\n                    try:\n                        __salt__['docker.connect_container_to_network'](cid, name)\n                    except CommandExecutionError as exc:\n                        errors.append(exc.__str__())\n                    else:\n                        ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n            else:\n                ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n    if errors:\n        if ret['comment']:\n            ret['comment'] += '. '\n        ret['comment'] += '. '.join(errors) + '.'\n    else:\n        ret['result'] = True\n    for (cid, c_info) in disconnected_containers.items():\n        if cid not in to_connect:\n            ret['changes'].setdefault('disconnected', []).append(c_info['Name'])\n    return ret",
        "mutated": [
            "def present(name, skip_translate=None, ignore_collisions=False, validate_ip_addrs=True, containers=None, reconnect=True, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionchanged:: 2018.3.0\\n        Support added for network configuration options other than ``driver``\\n        and ``driver_opts``, as well as IPAM configuration.\\n\\n    Ensure that a network is present\\n\\n    .. note::\\n        This state supports all arguments for network and IPAM pool\\n        configuration which are available for the release of docker-py\\n        installed on the minion. For that reason, the arguments described below\\n        in the :ref:`NETWORK CONFIGURATION\\n        <salt-states-docker-network-present-netconf>` and :ref:`IP ADDRESS\\n        MANAGEMENT (IPAM) <salt-states-docker-network-present-ipam>` sections\\n        may not accurately reflect what is available on the minion. The\\n        :py:func:`docker.get_client_args\\n        <salt.modules.dockermod.get_client_args>` function can be used to check\\n        the available arguments for the installed version of docker-py (they\\n        are found in the ``network_config`` and ``ipam_config`` sections of the\\n        return data), but Salt will not prevent a user from attempting to use\\n        an argument which is unsupported in the release of Docker which is\\n        installed. In those cases, network creation be attempted but will fail.\\n\\n    name\\n        Network name\\n\\n    skip_translate\\n        This function translates Salt SLS input into the format which\\n        docker-py expects. However, in the event that Salt's translation logic\\n        fails (due to potential changes in the Docker Remote API, or to bugs in\\n        the translation code), this argument can be used to exert granular\\n        control over which arguments are translated and which are not.\\n\\n        Pass this argument as a comma-separated list (or Python list) of\\n        arguments, and translation for each passed argument name will be\\n        skipped. Alternatively, pass ``True`` and *all* translation will be\\n        skipped.\\n\\n        Skipping tranlsation allows for arguments to be formatted directly in\\n        the format which docker-py expects. This allows for API changes and\\n        other issues to be more easily worked around. See the following links\\n        for more information:\\n\\n        - `docker-py Low-level API`_\\n        - `Docker Engine API`_\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _`docker-py Low-level API`: http://docker-py.readthedocs.io/en/stable/api.html#docker.api.container.ContainerApiMixin.create_container\\n    .. _`Docker Engine API`: https://docs.docker.com/engine/api/v1.33/#operation/ContainerCreate\\n\\n    ignore_collisions : False\\n        Since many of docker-py's arguments differ in name from their CLI\\n        counterparts (with which most Docker users are more familiar), Salt\\n        detects usage of these and aliases them to the docker-py version of\\n        that argument. However, if both the alias and the docker-py version of\\n        the same argument (e.g. ``options`` and ``driver_opts``) are used, an error\\n        will be raised. Set this argument to ``True`` to suppress these errors\\n        and keep the docker-py version of the argument.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    validate_ip_addrs : True\\n        For parameters which accept IP addresses/subnets as input, validation\\n        will be performed. To disable, set this to ``False``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    containers\\n        A list of containers which should be connected to this network.\\n\\n        .. note::\\n            As of the 2018.3.0 release, this is not the recommended way of\\n            managing a container's membership in a network, for a couple\\n            reasons:\\n\\n            1. It does not support setting static IPs, aliases, or links in the\\n               container's IP configuration.\\n            2. If a :py:func:`docker_container.running\\n               <salt.states.docker_container.running>` state replaces a\\n               container, it will not be reconnected to the network until the\\n               ``docker_network.present`` state is run again. Since containers\\n               often have ``require`` requisites to ensure that the network\\n               is present, this means that the ``docker_network.present`` state\\n               ends up being run *before* the :py:func:`docker_container.running\\n               <salt.states.docker_container.running>`, leaving the container\\n               unattached at the end of the Salt run.\\n\\n            For these reasons, it is recommended to use\\n            :ref:`docker_container.running's network management support\\n            <salt-states-docker-container-network-management>`.\\n\\n    reconnect : True\\n        If ``containers`` is not used, and the network is replaced, then Salt\\n        will keep track of the containers which were connected to the network\\n        and reconnect them to the network after it is replaced. Salt will first\\n        attempt to reconnect using the same IP the container had before the\\n        network was replaced. If that fails (for instance, if the network was\\n        replaced because the subnet was modified), then the container will be\\n        reconnected without an explicit IP address, and its IP will be assigned\\n        by Docker.\\n\\n        Set this option to ``False`` to keep Salt from trying to reconnect\\n        containers. This can be useful in some cases when :ref:`managing static\\n        IPs in docker_container.running\\n        <salt-states-docker-container-network-management>`. For instance, if a\\n        network's subnet is modified, it is likely that the static IP will need\\n        to be updated in the ``docker_container.running`` state as well. When\\n        the network is replaced, the initial reconnect attempt would fail, and\\n        the container would be reconnected with an automatically-assigned IP\\n        address. Then, when the ``docker_container.running`` state executes, it\\n        would disconnect the network *again* and reconnect using the new static\\n        IP. Disabling the reconnect behavior in these cases would prevent the\\n        unnecessary extra reconnection.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _salt-states-docker-network-present-netconf:\\n\\n    **NETWORK CONFIGURATION ARGUMENTS**\\n\\n    driver\\n        Network driver\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n\\n    driver_opts (or *driver_opt*, or *options*)\\n        Options for the network driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts: macvlan_mode=bridge,parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode=bridge\\n                  - parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode: bridge\\n                  - parent: eth0\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                    macvlan_mode: bridge\\n                    parent: eth0\\n\\n    check_duplicate : True\\n        If ``True``, checks for networks with duplicate names. Since networks\\n        are primarily keyed based on a random ID and not on the name, and\\n        network name is strictly a user-friendly alias to the network which is\\n        uniquely identified using ID, there is no guaranteed way to check for\\n        duplicates. This option providess a best effort, checking for any\\n        networks which have the same name, but it is not guaranteed to catch\\n        all name collisions.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - check_duplicate: False\\n\\n    internal : False\\n        If ``True``, restricts external access to the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - internal: True\\n\\n    labels\\n        Add metadata to the network. Labels can be set both with and without\\n        values, and labels with values can be passed either as ``key=value`` or\\n        ``key: value`` pairs. For example, while the below would be very\\n        confusing to read, it is technically valid, and demonstrates the\\n        different ways in which labels can be passed:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - labels:\\n                  - foo\\n                  - bar=baz\\n                  - hello: world\\n\\n        The labels can also simply be passed as a YAML dictionary, though this\\n        can be error-prone due to some :ref:`idiosyncrasies\\n        <yaml-idiosyncrasies>` with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            foo:\\n              docker_network.present:\\n                - labels:\\n                    foo: ''\\n                    bar: baz\\n                    hello: world\\n\\n        .. versionchanged:: 2018.3.0\\n            Methods for specifying labels can now be mixed. Earlier releases\\n            required either labels with or without values.\\n\\n    enable_ipv6 (or *ipv6*) : False\\n        Enable IPv6 on the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - enable_ipv6: True\\n\\n        .. note::\\n            While it should go without saying, this argument must be set to\\n            ``True`` to :ref:`configure an IPv6 subnet\\n            <salt-states-docker-network-present-ipam>`. Also, if this option is\\n            turned on without an IPv6 subnet explicitly configured, you will\\n            get an error unless you have set up a fixed IPv6 subnet. Consult\\n            the `Docker IPv6 docs`_ for information on how to do this.\\n\\n            .. _`Docker IPv6 docs`: https://docs.docker.com/v17.09/engine/userguide/networking/default_network/ipv6/\\n\\n    attachable : False\\n        If ``True``, and the network is in the global scope, non-service\\n        containers on worker nodes will be able to connect to the network.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - attachable: True\\n\\n        .. note::\\n            This option cannot be reliably managed on CentOS 7. This is because\\n            while support for this option was added in API version 1.24, its\\n            value was not added to the inpsect results until API version 1.26.\\n            The version of Docker which is available for CentOS 7 runs API\\n            version 1.24, meaning that while Salt can pass this argument to the\\n            API, it has no way of knowing the value of this config option in an\\n            existing Docker network.\\n\\n    scope\\n        Specify the network's scope (``local``, ``global`` or ``swarm``)\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - scope: local\\n\\n    ingress : False\\n        If ``True``, create an ingress network which provides the routing-mesh in\\n        swarm mode\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ingress: True\\n\\n    .. _salt-states-docker-network-present-ipam:\\n\\n    **IP ADDRESS MANAGEMENT (IPAM)**\\n\\n    This state supports networks with either IPv4, or both IPv4 and IPv6. If\\n    configuring IPv4, then you can pass the :ref:`IPAM pool arguments\\n    <salt-states-docker-network-present-ipam-pool-arguments>` below as\\n    individual arguments. However, if configuring IPv4 and IPv6, the arguments\\n    must be passed as a list of dictionaries, in the ``ipam_pools`` argument\\n    (click :ref:`here <salt-states-docker-network-present-ipam-examples>` for\\n    some examples). `These docs`_ also have more information on these\\n    arguments.\\n\\n    .. _`These docs`: http://docker-py.readthedocs.io/en/stable/api.html#docker.types.IPAMPool\\n\\n    *IPAM ARGUMENTS*\\n\\n    ipam_driver\\n        IPAM driver to use, if different from the default one\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n\\n    ipam_opts\\n        Options for the IPAM driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts: foo=bar,baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo=bar\\n                  - baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo: bar\\n                  - baz: qux\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: macvlan\\n                - ipam_opts:\\n                    foo: bar\\n                    baz: qux\\n\\n    .. _salt-states-docker-network-present-ipam-pool-arguments:\\n\\n    *IPAM POOL ARGUMENTS*\\n\\n    subnet\\n        Subnet in CIDR format that represents a network segment\\n\\n    iprange (or *ip_range*)\\n        Allocate container IP from a sub-range within the subnet\\n\\n        Subnet in CIDR format that represents a network segment\\n\\n    gateway\\n        IPv4 or IPv6 gateway for the master subnet\\n\\n    aux_addresses (or *aux_address*)\\n        A dictionary of mapping container names to IP addresses which should be\\n        allocated for them should they connect to the network. Either a\\n        dictionary of option names and values or a Python list of strings in\\n        the format ``host=ipaddr``.\\n\\n    .. _salt-states-docker-network-present-ipam-examples:\\n\\n    *IPAM CONFIGURATION EXAMPLES*\\n\\n    Below is an example of an IPv4-only network (keep in mind that ``subnet``\\n    is the only required argument).\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - subnet: 10.0.20.0/24\\n            - iprange: 10.0.20.128/25\\n            - gateway: 10.0.20.254\\n            - aux_addresses:\\n              - foo.bar.tld: 10.0.20.50\\n              - hello.world.tld: 10.0.20.51\\n\\n    .. note::\\n        The ``aux_addresses`` can be passed differently, in the same way that\\n        ``driver_opts`` and ``ipam_opts`` can.\\n\\n    This same network could also be configured this way:\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                iprange: 10.0.20.128/25\\n                gateway: 10.0.20.254\\n                aux_addresses:\\n                  foo.bar.tld: 10.0.20.50\\n                  hello.world.tld: 10.0.20.51\\n\\n    Here is an example of a mixed IPv4/IPv6 subnet.\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                gateway: 10.0.20.1\\n              - subnet: fe3f:2180:26:1::/123\\n                gateway: fe3f:2180:26:1::1\\n    \"\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    to_connect = {}\n    missing_containers = []\n    stopped_containers = []\n    for cname in __utils__['args.split_input'](containers or []):\n        try:\n            cinfo = __salt__['docker.inspect_container'](cname)\n        except CommandExecutionError:\n            missing_containers.append(cname)\n        else:\n            try:\n                cid = cinfo['Id']\n            except KeyError:\n                missing_containers.append(cname)\n            else:\n                if not cinfo.get('State', {}).get('Running', False):\n                    stopped_containers.append(cname)\n                else:\n                    to_connect[cid] = {'Name': cname}\n    if missing_containers:\n        ret.setdefault('warnings', []).append('The following containers do not exist: {}.'.format(', '.join(missing_containers)))\n    if stopped_containers:\n        ret.setdefault('warnings', []).append('The following containers are not running: {}.'.format(', '.join(stopped_containers)))\n    disconnected_containers = {}\n    try:\n        kwargs = __utils__['docker.translate_input'](salt.utils.dockermod.translate.network, skip_translate=skip_translate, ignore_collisions=ignore_collisions, validate_ip_addrs=validate_ip_addrs, **__utils__['args.clean_kwargs'](**kwargs))\n    except Exception as exc:\n        ret['comment'] = exc.__str__()\n        return ret\n    ipam_kwargs = {}\n    ipam_kwarg_names = ['ipam', 'ipam_driver', 'ipam_opts', 'ipam_pools']\n    ipam_kwarg_names.extend(__salt__['docker.get_client_args']('ipam_config')['ipam_config'])\n    for key in ipam_kwarg_names:\n        try:\n            ipam_kwargs[key] = kwargs.pop(key)\n        except KeyError:\n            pass\n    if 'ipam' in ipam_kwargs:\n        if len(ipam_kwargs) > 1:\n            ret['comment'] = \"Cannot mix the 'ipam' argument with any of the IPAM config arguments. See documentation for details.\"\n            return ret\n        ipam_config = ipam_kwargs['ipam']\n    else:\n        ipam_pools = ipam_kwargs.pop('ipam_pools', ())\n        try:\n            ipam_config = __utils__['docker.create_ipam_config'](*ipam_pools, **ipam_kwargs)\n        except Exception as exc:\n            ret['comment'] = exc.__str__()\n            return ret\n    create_network = True\n    if network is not None:\n        log.debug(\"Docker network '%s' already exists\", name)\n        ret['comment'] = f\"Network '{name}' already exists, and is configured as specified\"\n        log.trace(\"Details of docker network '%s': %s\", name, network)\n        temp_net_name = ''.join((random.choice(string.ascii_lowercase) for _ in range(20)))\n        try:\n            enable_ipv6 = kwargs.pop('enable_ipv6', None)\n            kwargs_tmp = kwargs\n            driver = kwargs.get('driver')\n            driver_opts = kwargs.get('options', {})\n            bridge_name = driver_opts.get('com.docker.network.bridge.name', None)\n            if driver == 'bridge' and bridge_name is not None:\n                tmp_name = str(bridge_name) + 'comp'\n                kwargs_tmp['options']['com.docker.network.bridge.name'] = tmp_name[-14:]\n            __salt__['docker.create_network'](temp_net_name, skip_translate=True, enable_ipv6=False, **kwargs_tmp)\n        except CommandExecutionError as exc:\n            ret['comment'] = 'Failed to create temp network for comparison: {}'.format(exc.__str__())\n            return ret\n        else:\n            if enable_ipv6 is not None:\n                kwargs['enable_ipv6'] = enable_ipv6\n        try:\n            try:\n                temp_net_info = __salt__['docker.inspect_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret['comment'] = 'Failed to inspect temp network: {}'.format(exc.__str__())\n                return ret\n            else:\n                temp_net_info['EnableIPv6'] = bool(enable_ipv6)\n            temp_net_info['IPAM'] = ipam_config\n            existing_pool_count = len(network['IPAM']['Config'])\n            desired_pool_count = len(temp_net_info['IPAM']['Config'])\n            is_default_pool = lambda x: True if sorted(x) == ['Gateway', 'Subnet'] else False\n            if desired_pool_count == 0 and existing_pool_count == 1 and is_default_pool(network['IPAM']['Config'][0]):\n                network['IPAM']['Config'] = []\n            changes = __salt__['docker.compare_networks'](network, temp_net_info, ignore='Name,Id,Created,Containers')\n            if not changes:\n                create_network = False\n            else:\n                ret['changes'][name] = changes\n                if __opts__['test']:\n                    ret['result'] = None\n                    ret['comment'] = 'Network would be recreated with new config'\n                    return ret\n                if network['Containers']:\n                    disconnected_containers = copy.deepcopy(network['Containers'])\n                    if not containers and reconnect:\n                        for cid in disconnected_containers:\n                            try:\n                                cinfo = __salt__['docker.inspect_container'](cid)\n                                netinfo = cinfo['NetworkSettings']['Networks'][name]\n                                net_links = netinfo.get('Links') or []\n                                net_aliases = netinfo.get('Aliases') or []\n                                if net_links:\n                                    disconnected_containers[cid]['Links'] = net_links\n                                if net_aliases:\n                                    disconnected_containers[cid]['Aliases'] = net_aliases\n                            except (CommandExecutionError, KeyError, ValueError):\n                                continue\n                remove_result = _remove_network(network)\n                if not remove_result['result']:\n                    return remove_result\n                network['Containers'] = {}\n        finally:\n            try:\n                __salt__['docker.remove_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret.setdefault('warnings', []).append(\"Failed to remove temp network '{}': {}.\".format(temp_net_name, exc.__str__()))\n    if create_network:\n        log.debug(\"Network '%s' will be created\", name)\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'Network will be created'\n            return ret\n        kwargs['ipam'] = ipam_config\n        try:\n            __salt__['docker.create_network'](name, skip_translate=True, **kwargs)\n        except Exception as exc:\n            ret['comment'] = \"Failed to create network '{}': {}\".format(name, exc.__str__())\n            return ret\n        else:\n            action = 'recreated' if network is not None else 'created'\n            ret['changes'][action] = True\n            ret['comment'] = \"Network '{}' {}\".format(name, 'created' if network is None else 'was replaced with updated config')\n            network = {'Containers': {}}\n    if containers is None and reconnect and disconnected_containers:\n        to_connect = disconnected_containers\n    for cid in list(to_connect):\n        if cid in network['Containers']:\n            del to_connect[cid]\n    errors = []\n    if to_connect:\n        for (cid, connect_info) in to_connect.items():\n            connect_kwargs = {}\n            if cid in disconnected_containers:\n                for (key_name, arg_name) in (('IPv4Address', 'ipv4_address'), ('IPV6Address', 'ipv6_address'), ('Links', 'links'), ('Aliases', 'aliases')):\n                    try:\n                        connect_kwargs[arg_name] = connect_info[key_name]\n                    except (KeyError, AttributeError):\n                        continue\n                    else:\n                        if key_name.endswith('Address'):\n                            connect_kwargs[arg_name] = connect_kwargs[arg_name].rsplit('/', 1)[0]\n            try:\n                __salt__['docker.connect_container_to_network'](cid, name, **connect_kwargs)\n            except CommandExecutionError as exc:\n                if not connect_kwargs:\n                    errors.append(exc.__str__())\n                else:\n                    try:\n                        __salt__['docker.connect_container_to_network'](cid, name)\n                    except CommandExecutionError as exc:\n                        errors.append(exc.__str__())\n                    else:\n                        ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n            else:\n                ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n    if errors:\n        if ret['comment']:\n            ret['comment'] += '. '\n        ret['comment'] += '. '.join(errors) + '.'\n    else:\n        ret['result'] = True\n    for (cid, c_info) in disconnected_containers.items():\n        if cid not in to_connect:\n            ret['changes'].setdefault('disconnected', []).append(c_info['Name'])\n    return ret",
            "def present(name, skip_translate=None, ignore_collisions=False, validate_ip_addrs=True, containers=None, reconnect=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionchanged:: 2018.3.0\\n        Support added for network configuration options other than ``driver``\\n        and ``driver_opts``, as well as IPAM configuration.\\n\\n    Ensure that a network is present\\n\\n    .. note::\\n        This state supports all arguments for network and IPAM pool\\n        configuration which are available for the release of docker-py\\n        installed on the minion. For that reason, the arguments described below\\n        in the :ref:`NETWORK CONFIGURATION\\n        <salt-states-docker-network-present-netconf>` and :ref:`IP ADDRESS\\n        MANAGEMENT (IPAM) <salt-states-docker-network-present-ipam>` sections\\n        may not accurately reflect what is available on the minion. The\\n        :py:func:`docker.get_client_args\\n        <salt.modules.dockermod.get_client_args>` function can be used to check\\n        the available arguments for the installed version of docker-py (they\\n        are found in the ``network_config`` and ``ipam_config`` sections of the\\n        return data), but Salt will not prevent a user from attempting to use\\n        an argument which is unsupported in the release of Docker which is\\n        installed. In those cases, network creation be attempted but will fail.\\n\\n    name\\n        Network name\\n\\n    skip_translate\\n        This function translates Salt SLS input into the format which\\n        docker-py expects. However, in the event that Salt's translation logic\\n        fails (due to potential changes in the Docker Remote API, or to bugs in\\n        the translation code), this argument can be used to exert granular\\n        control over which arguments are translated and which are not.\\n\\n        Pass this argument as a comma-separated list (or Python list) of\\n        arguments, and translation for each passed argument name will be\\n        skipped. Alternatively, pass ``True`` and *all* translation will be\\n        skipped.\\n\\n        Skipping tranlsation allows for arguments to be formatted directly in\\n        the format which docker-py expects. This allows for API changes and\\n        other issues to be more easily worked around. See the following links\\n        for more information:\\n\\n        - `docker-py Low-level API`_\\n        - `Docker Engine API`_\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _`docker-py Low-level API`: http://docker-py.readthedocs.io/en/stable/api.html#docker.api.container.ContainerApiMixin.create_container\\n    .. _`Docker Engine API`: https://docs.docker.com/engine/api/v1.33/#operation/ContainerCreate\\n\\n    ignore_collisions : False\\n        Since many of docker-py's arguments differ in name from their CLI\\n        counterparts (with which most Docker users are more familiar), Salt\\n        detects usage of these and aliases them to the docker-py version of\\n        that argument. However, if both the alias and the docker-py version of\\n        the same argument (e.g. ``options`` and ``driver_opts``) are used, an error\\n        will be raised. Set this argument to ``True`` to suppress these errors\\n        and keep the docker-py version of the argument.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    validate_ip_addrs : True\\n        For parameters which accept IP addresses/subnets as input, validation\\n        will be performed. To disable, set this to ``False``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    containers\\n        A list of containers which should be connected to this network.\\n\\n        .. note::\\n            As of the 2018.3.0 release, this is not the recommended way of\\n            managing a container's membership in a network, for a couple\\n            reasons:\\n\\n            1. It does not support setting static IPs, aliases, or links in the\\n               container's IP configuration.\\n            2. If a :py:func:`docker_container.running\\n               <salt.states.docker_container.running>` state replaces a\\n               container, it will not be reconnected to the network until the\\n               ``docker_network.present`` state is run again. Since containers\\n               often have ``require`` requisites to ensure that the network\\n               is present, this means that the ``docker_network.present`` state\\n               ends up being run *before* the :py:func:`docker_container.running\\n               <salt.states.docker_container.running>`, leaving the container\\n               unattached at the end of the Salt run.\\n\\n            For these reasons, it is recommended to use\\n            :ref:`docker_container.running's network management support\\n            <salt-states-docker-container-network-management>`.\\n\\n    reconnect : True\\n        If ``containers`` is not used, and the network is replaced, then Salt\\n        will keep track of the containers which were connected to the network\\n        and reconnect them to the network after it is replaced. Salt will first\\n        attempt to reconnect using the same IP the container had before the\\n        network was replaced. If that fails (for instance, if the network was\\n        replaced because the subnet was modified), then the container will be\\n        reconnected without an explicit IP address, and its IP will be assigned\\n        by Docker.\\n\\n        Set this option to ``False`` to keep Salt from trying to reconnect\\n        containers. This can be useful in some cases when :ref:`managing static\\n        IPs in docker_container.running\\n        <salt-states-docker-container-network-management>`. For instance, if a\\n        network's subnet is modified, it is likely that the static IP will need\\n        to be updated in the ``docker_container.running`` state as well. When\\n        the network is replaced, the initial reconnect attempt would fail, and\\n        the container would be reconnected with an automatically-assigned IP\\n        address. Then, when the ``docker_container.running`` state executes, it\\n        would disconnect the network *again* and reconnect using the new static\\n        IP. Disabling the reconnect behavior in these cases would prevent the\\n        unnecessary extra reconnection.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _salt-states-docker-network-present-netconf:\\n\\n    **NETWORK CONFIGURATION ARGUMENTS**\\n\\n    driver\\n        Network driver\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n\\n    driver_opts (or *driver_opt*, or *options*)\\n        Options for the network driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts: macvlan_mode=bridge,parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode=bridge\\n                  - parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode: bridge\\n                  - parent: eth0\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                    macvlan_mode: bridge\\n                    parent: eth0\\n\\n    check_duplicate : True\\n        If ``True``, checks for networks with duplicate names. Since networks\\n        are primarily keyed based on a random ID and not on the name, and\\n        network name is strictly a user-friendly alias to the network which is\\n        uniquely identified using ID, there is no guaranteed way to check for\\n        duplicates. This option providess a best effort, checking for any\\n        networks which have the same name, but it is not guaranteed to catch\\n        all name collisions.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - check_duplicate: False\\n\\n    internal : False\\n        If ``True``, restricts external access to the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - internal: True\\n\\n    labels\\n        Add metadata to the network. Labels can be set both with and without\\n        values, and labels with values can be passed either as ``key=value`` or\\n        ``key: value`` pairs. For example, while the below would be very\\n        confusing to read, it is technically valid, and demonstrates the\\n        different ways in which labels can be passed:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - labels:\\n                  - foo\\n                  - bar=baz\\n                  - hello: world\\n\\n        The labels can also simply be passed as a YAML dictionary, though this\\n        can be error-prone due to some :ref:`idiosyncrasies\\n        <yaml-idiosyncrasies>` with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            foo:\\n              docker_network.present:\\n                - labels:\\n                    foo: ''\\n                    bar: baz\\n                    hello: world\\n\\n        .. versionchanged:: 2018.3.0\\n            Methods for specifying labels can now be mixed. Earlier releases\\n            required either labels with or without values.\\n\\n    enable_ipv6 (or *ipv6*) : False\\n        Enable IPv6 on the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - enable_ipv6: True\\n\\n        .. note::\\n            While it should go without saying, this argument must be set to\\n            ``True`` to :ref:`configure an IPv6 subnet\\n            <salt-states-docker-network-present-ipam>`. Also, if this option is\\n            turned on without an IPv6 subnet explicitly configured, you will\\n            get an error unless you have set up a fixed IPv6 subnet. Consult\\n            the `Docker IPv6 docs`_ for information on how to do this.\\n\\n            .. _`Docker IPv6 docs`: https://docs.docker.com/v17.09/engine/userguide/networking/default_network/ipv6/\\n\\n    attachable : False\\n        If ``True``, and the network is in the global scope, non-service\\n        containers on worker nodes will be able to connect to the network.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - attachable: True\\n\\n        .. note::\\n            This option cannot be reliably managed on CentOS 7. This is because\\n            while support for this option was added in API version 1.24, its\\n            value was not added to the inpsect results until API version 1.26.\\n            The version of Docker which is available for CentOS 7 runs API\\n            version 1.24, meaning that while Salt can pass this argument to the\\n            API, it has no way of knowing the value of this config option in an\\n            existing Docker network.\\n\\n    scope\\n        Specify the network's scope (``local``, ``global`` or ``swarm``)\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - scope: local\\n\\n    ingress : False\\n        If ``True``, create an ingress network which provides the routing-mesh in\\n        swarm mode\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ingress: True\\n\\n    .. _salt-states-docker-network-present-ipam:\\n\\n    **IP ADDRESS MANAGEMENT (IPAM)**\\n\\n    This state supports networks with either IPv4, or both IPv4 and IPv6. If\\n    configuring IPv4, then you can pass the :ref:`IPAM pool arguments\\n    <salt-states-docker-network-present-ipam-pool-arguments>` below as\\n    individual arguments. However, if configuring IPv4 and IPv6, the arguments\\n    must be passed as a list of dictionaries, in the ``ipam_pools`` argument\\n    (click :ref:`here <salt-states-docker-network-present-ipam-examples>` for\\n    some examples). `These docs`_ also have more information on these\\n    arguments.\\n\\n    .. _`These docs`: http://docker-py.readthedocs.io/en/stable/api.html#docker.types.IPAMPool\\n\\n    *IPAM ARGUMENTS*\\n\\n    ipam_driver\\n        IPAM driver to use, if different from the default one\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n\\n    ipam_opts\\n        Options for the IPAM driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts: foo=bar,baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo=bar\\n                  - baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo: bar\\n                  - baz: qux\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: macvlan\\n                - ipam_opts:\\n                    foo: bar\\n                    baz: qux\\n\\n    .. _salt-states-docker-network-present-ipam-pool-arguments:\\n\\n    *IPAM POOL ARGUMENTS*\\n\\n    subnet\\n        Subnet in CIDR format that represents a network segment\\n\\n    iprange (or *ip_range*)\\n        Allocate container IP from a sub-range within the subnet\\n\\n        Subnet in CIDR format that represents a network segment\\n\\n    gateway\\n        IPv4 or IPv6 gateway for the master subnet\\n\\n    aux_addresses (or *aux_address*)\\n        A dictionary of mapping container names to IP addresses which should be\\n        allocated for them should they connect to the network. Either a\\n        dictionary of option names and values or a Python list of strings in\\n        the format ``host=ipaddr``.\\n\\n    .. _salt-states-docker-network-present-ipam-examples:\\n\\n    *IPAM CONFIGURATION EXAMPLES*\\n\\n    Below is an example of an IPv4-only network (keep in mind that ``subnet``\\n    is the only required argument).\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - subnet: 10.0.20.0/24\\n            - iprange: 10.0.20.128/25\\n            - gateway: 10.0.20.254\\n            - aux_addresses:\\n              - foo.bar.tld: 10.0.20.50\\n              - hello.world.tld: 10.0.20.51\\n\\n    .. note::\\n        The ``aux_addresses`` can be passed differently, in the same way that\\n        ``driver_opts`` and ``ipam_opts`` can.\\n\\n    This same network could also be configured this way:\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                iprange: 10.0.20.128/25\\n                gateway: 10.0.20.254\\n                aux_addresses:\\n                  foo.bar.tld: 10.0.20.50\\n                  hello.world.tld: 10.0.20.51\\n\\n    Here is an example of a mixed IPv4/IPv6 subnet.\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                gateway: 10.0.20.1\\n              - subnet: fe3f:2180:26:1::/123\\n                gateway: fe3f:2180:26:1::1\\n    \"\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    to_connect = {}\n    missing_containers = []\n    stopped_containers = []\n    for cname in __utils__['args.split_input'](containers or []):\n        try:\n            cinfo = __salt__['docker.inspect_container'](cname)\n        except CommandExecutionError:\n            missing_containers.append(cname)\n        else:\n            try:\n                cid = cinfo['Id']\n            except KeyError:\n                missing_containers.append(cname)\n            else:\n                if not cinfo.get('State', {}).get('Running', False):\n                    stopped_containers.append(cname)\n                else:\n                    to_connect[cid] = {'Name': cname}\n    if missing_containers:\n        ret.setdefault('warnings', []).append('The following containers do not exist: {}.'.format(', '.join(missing_containers)))\n    if stopped_containers:\n        ret.setdefault('warnings', []).append('The following containers are not running: {}.'.format(', '.join(stopped_containers)))\n    disconnected_containers = {}\n    try:\n        kwargs = __utils__['docker.translate_input'](salt.utils.dockermod.translate.network, skip_translate=skip_translate, ignore_collisions=ignore_collisions, validate_ip_addrs=validate_ip_addrs, **__utils__['args.clean_kwargs'](**kwargs))\n    except Exception as exc:\n        ret['comment'] = exc.__str__()\n        return ret\n    ipam_kwargs = {}\n    ipam_kwarg_names = ['ipam', 'ipam_driver', 'ipam_opts', 'ipam_pools']\n    ipam_kwarg_names.extend(__salt__['docker.get_client_args']('ipam_config')['ipam_config'])\n    for key in ipam_kwarg_names:\n        try:\n            ipam_kwargs[key] = kwargs.pop(key)\n        except KeyError:\n            pass\n    if 'ipam' in ipam_kwargs:\n        if len(ipam_kwargs) > 1:\n            ret['comment'] = \"Cannot mix the 'ipam' argument with any of the IPAM config arguments. See documentation for details.\"\n            return ret\n        ipam_config = ipam_kwargs['ipam']\n    else:\n        ipam_pools = ipam_kwargs.pop('ipam_pools', ())\n        try:\n            ipam_config = __utils__['docker.create_ipam_config'](*ipam_pools, **ipam_kwargs)\n        except Exception as exc:\n            ret['comment'] = exc.__str__()\n            return ret\n    create_network = True\n    if network is not None:\n        log.debug(\"Docker network '%s' already exists\", name)\n        ret['comment'] = f\"Network '{name}' already exists, and is configured as specified\"\n        log.trace(\"Details of docker network '%s': %s\", name, network)\n        temp_net_name = ''.join((random.choice(string.ascii_lowercase) for _ in range(20)))\n        try:\n            enable_ipv6 = kwargs.pop('enable_ipv6', None)\n            kwargs_tmp = kwargs\n            driver = kwargs.get('driver')\n            driver_opts = kwargs.get('options', {})\n            bridge_name = driver_opts.get('com.docker.network.bridge.name', None)\n            if driver == 'bridge' and bridge_name is not None:\n                tmp_name = str(bridge_name) + 'comp'\n                kwargs_tmp['options']['com.docker.network.bridge.name'] = tmp_name[-14:]\n            __salt__['docker.create_network'](temp_net_name, skip_translate=True, enable_ipv6=False, **kwargs_tmp)\n        except CommandExecutionError as exc:\n            ret['comment'] = 'Failed to create temp network for comparison: {}'.format(exc.__str__())\n            return ret\n        else:\n            if enable_ipv6 is not None:\n                kwargs['enable_ipv6'] = enable_ipv6\n        try:\n            try:\n                temp_net_info = __salt__['docker.inspect_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret['comment'] = 'Failed to inspect temp network: {}'.format(exc.__str__())\n                return ret\n            else:\n                temp_net_info['EnableIPv6'] = bool(enable_ipv6)\n            temp_net_info['IPAM'] = ipam_config\n            existing_pool_count = len(network['IPAM']['Config'])\n            desired_pool_count = len(temp_net_info['IPAM']['Config'])\n            is_default_pool = lambda x: True if sorted(x) == ['Gateway', 'Subnet'] else False\n            if desired_pool_count == 0 and existing_pool_count == 1 and is_default_pool(network['IPAM']['Config'][0]):\n                network['IPAM']['Config'] = []\n            changes = __salt__['docker.compare_networks'](network, temp_net_info, ignore='Name,Id,Created,Containers')\n            if not changes:\n                create_network = False\n            else:\n                ret['changes'][name] = changes\n                if __opts__['test']:\n                    ret['result'] = None\n                    ret['comment'] = 'Network would be recreated with new config'\n                    return ret\n                if network['Containers']:\n                    disconnected_containers = copy.deepcopy(network['Containers'])\n                    if not containers and reconnect:\n                        for cid in disconnected_containers:\n                            try:\n                                cinfo = __salt__['docker.inspect_container'](cid)\n                                netinfo = cinfo['NetworkSettings']['Networks'][name]\n                                net_links = netinfo.get('Links') or []\n                                net_aliases = netinfo.get('Aliases') or []\n                                if net_links:\n                                    disconnected_containers[cid]['Links'] = net_links\n                                if net_aliases:\n                                    disconnected_containers[cid]['Aliases'] = net_aliases\n                            except (CommandExecutionError, KeyError, ValueError):\n                                continue\n                remove_result = _remove_network(network)\n                if not remove_result['result']:\n                    return remove_result\n                network['Containers'] = {}\n        finally:\n            try:\n                __salt__['docker.remove_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret.setdefault('warnings', []).append(\"Failed to remove temp network '{}': {}.\".format(temp_net_name, exc.__str__()))\n    if create_network:\n        log.debug(\"Network '%s' will be created\", name)\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'Network will be created'\n            return ret\n        kwargs['ipam'] = ipam_config\n        try:\n            __salt__['docker.create_network'](name, skip_translate=True, **kwargs)\n        except Exception as exc:\n            ret['comment'] = \"Failed to create network '{}': {}\".format(name, exc.__str__())\n            return ret\n        else:\n            action = 'recreated' if network is not None else 'created'\n            ret['changes'][action] = True\n            ret['comment'] = \"Network '{}' {}\".format(name, 'created' if network is None else 'was replaced with updated config')\n            network = {'Containers': {}}\n    if containers is None and reconnect and disconnected_containers:\n        to_connect = disconnected_containers\n    for cid in list(to_connect):\n        if cid in network['Containers']:\n            del to_connect[cid]\n    errors = []\n    if to_connect:\n        for (cid, connect_info) in to_connect.items():\n            connect_kwargs = {}\n            if cid in disconnected_containers:\n                for (key_name, arg_name) in (('IPv4Address', 'ipv4_address'), ('IPV6Address', 'ipv6_address'), ('Links', 'links'), ('Aliases', 'aliases')):\n                    try:\n                        connect_kwargs[arg_name] = connect_info[key_name]\n                    except (KeyError, AttributeError):\n                        continue\n                    else:\n                        if key_name.endswith('Address'):\n                            connect_kwargs[arg_name] = connect_kwargs[arg_name].rsplit('/', 1)[0]\n            try:\n                __salt__['docker.connect_container_to_network'](cid, name, **connect_kwargs)\n            except CommandExecutionError as exc:\n                if not connect_kwargs:\n                    errors.append(exc.__str__())\n                else:\n                    try:\n                        __salt__['docker.connect_container_to_network'](cid, name)\n                    except CommandExecutionError as exc:\n                        errors.append(exc.__str__())\n                    else:\n                        ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n            else:\n                ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n    if errors:\n        if ret['comment']:\n            ret['comment'] += '. '\n        ret['comment'] += '. '.join(errors) + '.'\n    else:\n        ret['result'] = True\n    for (cid, c_info) in disconnected_containers.items():\n        if cid not in to_connect:\n            ret['changes'].setdefault('disconnected', []).append(c_info['Name'])\n    return ret",
            "def present(name, skip_translate=None, ignore_collisions=False, validate_ip_addrs=True, containers=None, reconnect=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionchanged:: 2018.3.0\\n        Support added for network configuration options other than ``driver``\\n        and ``driver_opts``, as well as IPAM configuration.\\n\\n    Ensure that a network is present\\n\\n    .. note::\\n        This state supports all arguments for network and IPAM pool\\n        configuration which are available for the release of docker-py\\n        installed on the minion. For that reason, the arguments described below\\n        in the :ref:`NETWORK CONFIGURATION\\n        <salt-states-docker-network-present-netconf>` and :ref:`IP ADDRESS\\n        MANAGEMENT (IPAM) <salt-states-docker-network-present-ipam>` sections\\n        may not accurately reflect what is available on the minion. The\\n        :py:func:`docker.get_client_args\\n        <salt.modules.dockermod.get_client_args>` function can be used to check\\n        the available arguments for the installed version of docker-py (they\\n        are found in the ``network_config`` and ``ipam_config`` sections of the\\n        return data), but Salt will not prevent a user from attempting to use\\n        an argument which is unsupported in the release of Docker which is\\n        installed. In those cases, network creation be attempted but will fail.\\n\\n    name\\n        Network name\\n\\n    skip_translate\\n        This function translates Salt SLS input into the format which\\n        docker-py expects. However, in the event that Salt's translation logic\\n        fails (due to potential changes in the Docker Remote API, or to bugs in\\n        the translation code), this argument can be used to exert granular\\n        control over which arguments are translated and which are not.\\n\\n        Pass this argument as a comma-separated list (or Python list) of\\n        arguments, and translation for each passed argument name will be\\n        skipped. Alternatively, pass ``True`` and *all* translation will be\\n        skipped.\\n\\n        Skipping tranlsation allows for arguments to be formatted directly in\\n        the format which docker-py expects. This allows for API changes and\\n        other issues to be more easily worked around. See the following links\\n        for more information:\\n\\n        - `docker-py Low-level API`_\\n        - `Docker Engine API`_\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _`docker-py Low-level API`: http://docker-py.readthedocs.io/en/stable/api.html#docker.api.container.ContainerApiMixin.create_container\\n    .. _`Docker Engine API`: https://docs.docker.com/engine/api/v1.33/#operation/ContainerCreate\\n\\n    ignore_collisions : False\\n        Since many of docker-py's arguments differ in name from their CLI\\n        counterparts (with which most Docker users are more familiar), Salt\\n        detects usage of these and aliases them to the docker-py version of\\n        that argument. However, if both the alias and the docker-py version of\\n        the same argument (e.g. ``options`` and ``driver_opts``) are used, an error\\n        will be raised. Set this argument to ``True`` to suppress these errors\\n        and keep the docker-py version of the argument.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    validate_ip_addrs : True\\n        For parameters which accept IP addresses/subnets as input, validation\\n        will be performed. To disable, set this to ``False``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    containers\\n        A list of containers which should be connected to this network.\\n\\n        .. note::\\n            As of the 2018.3.0 release, this is not the recommended way of\\n            managing a container's membership in a network, for a couple\\n            reasons:\\n\\n            1. It does not support setting static IPs, aliases, or links in the\\n               container's IP configuration.\\n            2. If a :py:func:`docker_container.running\\n               <salt.states.docker_container.running>` state replaces a\\n               container, it will not be reconnected to the network until the\\n               ``docker_network.present`` state is run again. Since containers\\n               often have ``require`` requisites to ensure that the network\\n               is present, this means that the ``docker_network.present`` state\\n               ends up being run *before* the :py:func:`docker_container.running\\n               <salt.states.docker_container.running>`, leaving the container\\n               unattached at the end of the Salt run.\\n\\n            For these reasons, it is recommended to use\\n            :ref:`docker_container.running's network management support\\n            <salt-states-docker-container-network-management>`.\\n\\n    reconnect : True\\n        If ``containers`` is not used, and the network is replaced, then Salt\\n        will keep track of the containers which were connected to the network\\n        and reconnect them to the network after it is replaced. Salt will first\\n        attempt to reconnect using the same IP the container had before the\\n        network was replaced. If that fails (for instance, if the network was\\n        replaced because the subnet was modified), then the container will be\\n        reconnected without an explicit IP address, and its IP will be assigned\\n        by Docker.\\n\\n        Set this option to ``False`` to keep Salt from trying to reconnect\\n        containers. This can be useful in some cases when :ref:`managing static\\n        IPs in docker_container.running\\n        <salt-states-docker-container-network-management>`. For instance, if a\\n        network's subnet is modified, it is likely that the static IP will need\\n        to be updated in the ``docker_container.running`` state as well. When\\n        the network is replaced, the initial reconnect attempt would fail, and\\n        the container would be reconnected with an automatically-assigned IP\\n        address. Then, when the ``docker_container.running`` state executes, it\\n        would disconnect the network *again* and reconnect using the new static\\n        IP. Disabling the reconnect behavior in these cases would prevent the\\n        unnecessary extra reconnection.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _salt-states-docker-network-present-netconf:\\n\\n    **NETWORK CONFIGURATION ARGUMENTS**\\n\\n    driver\\n        Network driver\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n\\n    driver_opts (or *driver_opt*, or *options*)\\n        Options for the network driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts: macvlan_mode=bridge,parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode=bridge\\n                  - parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode: bridge\\n                  - parent: eth0\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                    macvlan_mode: bridge\\n                    parent: eth0\\n\\n    check_duplicate : True\\n        If ``True``, checks for networks with duplicate names. Since networks\\n        are primarily keyed based on a random ID and not on the name, and\\n        network name is strictly a user-friendly alias to the network which is\\n        uniquely identified using ID, there is no guaranteed way to check for\\n        duplicates. This option providess a best effort, checking for any\\n        networks which have the same name, but it is not guaranteed to catch\\n        all name collisions.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - check_duplicate: False\\n\\n    internal : False\\n        If ``True``, restricts external access to the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - internal: True\\n\\n    labels\\n        Add metadata to the network. Labels can be set both with and without\\n        values, and labels with values can be passed either as ``key=value`` or\\n        ``key: value`` pairs. For example, while the below would be very\\n        confusing to read, it is technically valid, and demonstrates the\\n        different ways in which labels can be passed:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - labels:\\n                  - foo\\n                  - bar=baz\\n                  - hello: world\\n\\n        The labels can also simply be passed as a YAML dictionary, though this\\n        can be error-prone due to some :ref:`idiosyncrasies\\n        <yaml-idiosyncrasies>` with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            foo:\\n              docker_network.present:\\n                - labels:\\n                    foo: ''\\n                    bar: baz\\n                    hello: world\\n\\n        .. versionchanged:: 2018.3.0\\n            Methods for specifying labels can now be mixed. Earlier releases\\n            required either labels with or without values.\\n\\n    enable_ipv6 (or *ipv6*) : False\\n        Enable IPv6 on the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - enable_ipv6: True\\n\\n        .. note::\\n            While it should go without saying, this argument must be set to\\n            ``True`` to :ref:`configure an IPv6 subnet\\n            <salt-states-docker-network-present-ipam>`. Also, if this option is\\n            turned on without an IPv6 subnet explicitly configured, you will\\n            get an error unless you have set up a fixed IPv6 subnet. Consult\\n            the `Docker IPv6 docs`_ for information on how to do this.\\n\\n            .. _`Docker IPv6 docs`: https://docs.docker.com/v17.09/engine/userguide/networking/default_network/ipv6/\\n\\n    attachable : False\\n        If ``True``, and the network is in the global scope, non-service\\n        containers on worker nodes will be able to connect to the network.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - attachable: True\\n\\n        .. note::\\n            This option cannot be reliably managed on CentOS 7. This is because\\n            while support for this option was added in API version 1.24, its\\n            value was not added to the inpsect results until API version 1.26.\\n            The version of Docker which is available for CentOS 7 runs API\\n            version 1.24, meaning that while Salt can pass this argument to the\\n            API, it has no way of knowing the value of this config option in an\\n            existing Docker network.\\n\\n    scope\\n        Specify the network's scope (``local``, ``global`` or ``swarm``)\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - scope: local\\n\\n    ingress : False\\n        If ``True``, create an ingress network which provides the routing-mesh in\\n        swarm mode\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ingress: True\\n\\n    .. _salt-states-docker-network-present-ipam:\\n\\n    **IP ADDRESS MANAGEMENT (IPAM)**\\n\\n    This state supports networks with either IPv4, or both IPv4 and IPv6. If\\n    configuring IPv4, then you can pass the :ref:`IPAM pool arguments\\n    <salt-states-docker-network-present-ipam-pool-arguments>` below as\\n    individual arguments. However, if configuring IPv4 and IPv6, the arguments\\n    must be passed as a list of dictionaries, in the ``ipam_pools`` argument\\n    (click :ref:`here <salt-states-docker-network-present-ipam-examples>` for\\n    some examples). `These docs`_ also have more information on these\\n    arguments.\\n\\n    .. _`These docs`: http://docker-py.readthedocs.io/en/stable/api.html#docker.types.IPAMPool\\n\\n    *IPAM ARGUMENTS*\\n\\n    ipam_driver\\n        IPAM driver to use, if different from the default one\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n\\n    ipam_opts\\n        Options for the IPAM driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts: foo=bar,baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo=bar\\n                  - baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo: bar\\n                  - baz: qux\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: macvlan\\n                - ipam_opts:\\n                    foo: bar\\n                    baz: qux\\n\\n    .. _salt-states-docker-network-present-ipam-pool-arguments:\\n\\n    *IPAM POOL ARGUMENTS*\\n\\n    subnet\\n        Subnet in CIDR format that represents a network segment\\n\\n    iprange (or *ip_range*)\\n        Allocate container IP from a sub-range within the subnet\\n\\n        Subnet in CIDR format that represents a network segment\\n\\n    gateway\\n        IPv4 or IPv6 gateway for the master subnet\\n\\n    aux_addresses (or *aux_address*)\\n        A dictionary of mapping container names to IP addresses which should be\\n        allocated for them should they connect to the network. Either a\\n        dictionary of option names and values or a Python list of strings in\\n        the format ``host=ipaddr``.\\n\\n    .. _salt-states-docker-network-present-ipam-examples:\\n\\n    *IPAM CONFIGURATION EXAMPLES*\\n\\n    Below is an example of an IPv4-only network (keep in mind that ``subnet``\\n    is the only required argument).\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - subnet: 10.0.20.0/24\\n            - iprange: 10.0.20.128/25\\n            - gateway: 10.0.20.254\\n            - aux_addresses:\\n              - foo.bar.tld: 10.0.20.50\\n              - hello.world.tld: 10.0.20.51\\n\\n    .. note::\\n        The ``aux_addresses`` can be passed differently, in the same way that\\n        ``driver_opts`` and ``ipam_opts`` can.\\n\\n    This same network could also be configured this way:\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                iprange: 10.0.20.128/25\\n                gateway: 10.0.20.254\\n                aux_addresses:\\n                  foo.bar.tld: 10.0.20.50\\n                  hello.world.tld: 10.0.20.51\\n\\n    Here is an example of a mixed IPv4/IPv6 subnet.\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                gateway: 10.0.20.1\\n              - subnet: fe3f:2180:26:1::/123\\n                gateway: fe3f:2180:26:1::1\\n    \"\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    to_connect = {}\n    missing_containers = []\n    stopped_containers = []\n    for cname in __utils__['args.split_input'](containers or []):\n        try:\n            cinfo = __salt__['docker.inspect_container'](cname)\n        except CommandExecutionError:\n            missing_containers.append(cname)\n        else:\n            try:\n                cid = cinfo['Id']\n            except KeyError:\n                missing_containers.append(cname)\n            else:\n                if not cinfo.get('State', {}).get('Running', False):\n                    stopped_containers.append(cname)\n                else:\n                    to_connect[cid] = {'Name': cname}\n    if missing_containers:\n        ret.setdefault('warnings', []).append('The following containers do not exist: {}.'.format(', '.join(missing_containers)))\n    if stopped_containers:\n        ret.setdefault('warnings', []).append('The following containers are not running: {}.'.format(', '.join(stopped_containers)))\n    disconnected_containers = {}\n    try:\n        kwargs = __utils__['docker.translate_input'](salt.utils.dockermod.translate.network, skip_translate=skip_translate, ignore_collisions=ignore_collisions, validate_ip_addrs=validate_ip_addrs, **__utils__['args.clean_kwargs'](**kwargs))\n    except Exception as exc:\n        ret['comment'] = exc.__str__()\n        return ret\n    ipam_kwargs = {}\n    ipam_kwarg_names = ['ipam', 'ipam_driver', 'ipam_opts', 'ipam_pools']\n    ipam_kwarg_names.extend(__salt__['docker.get_client_args']('ipam_config')['ipam_config'])\n    for key in ipam_kwarg_names:\n        try:\n            ipam_kwargs[key] = kwargs.pop(key)\n        except KeyError:\n            pass\n    if 'ipam' in ipam_kwargs:\n        if len(ipam_kwargs) > 1:\n            ret['comment'] = \"Cannot mix the 'ipam' argument with any of the IPAM config arguments. See documentation for details.\"\n            return ret\n        ipam_config = ipam_kwargs['ipam']\n    else:\n        ipam_pools = ipam_kwargs.pop('ipam_pools', ())\n        try:\n            ipam_config = __utils__['docker.create_ipam_config'](*ipam_pools, **ipam_kwargs)\n        except Exception as exc:\n            ret['comment'] = exc.__str__()\n            return ret\n    create_network = True\n    if network is not None:\n        log.debug(\"Docker network '%s' already exists\", name)\n        ret['comment'] = f\"Network '{name}' already exists, and is configured as specified\"\n        log.trace(\"Details of docker network '%s': %s\", name, network)\n        temp_net_name = ''.join((random.choice(string.ascii_lowercase) for _ in range(20)))\n        try:\n            enable_ipv6 = kwargs.pop('enable_ipv6', None)\n            kwargs_tmp = kwargs\n            driver = kwargs.get('driver')\n            driver_opts = kwargs.get('options', {})\n            bridge_name = driver_opts.get('com.docker.network.bridge.name', None)\n            if driver == 'bridge' and bridge_name is not None:\n                tmp_name = str(bridge_name) + 'comp'\n                kwargs_tmp['options']['com.docker.network.bridge.name'] = tmp_name[-14:]\n            __salt__['docker.create_network'](temp_net_name, skip_translate=True, enable_ipv6=False, **kwargs_tmp)\n        except CommandExecutionError as exc:\n            ret['comment'] = 'Failed to create temp network for comparison: {}'.format(exc.__str__())\n            return ret\n        else:\n            if enable_ipv6 is not None:\n                kwargs['enable_ipv6'] = enable_ipv6\n        try:\n            try:\n                temp_net_info = __salt__['docker.inspect_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret['comment'] = 'Failed to inspect temp network: {}'.format(exc.__str__())\n                return ret\n            else:\n                temp_net_info['EnableIPv6'] = bool(enable_ipv6)\n            temp_net_info['IPAM'] = ipam_config\n            existing_pool_count = len(network['IPAM']['Config'])\n            desired_pool_count = len(temp_net_info['IPAM']['Config'])\n            is_default_pool = lambda x: True if sorted(x) == ['Gateway', 'Subnet'] else False\n            if desired_pool_count == 0 and existing_pool_count == 1 and is_default_pool(network['IPAM']['Config'][0]):\n                network['IPAM']['Config'] = []\n            changes = __salt__['docker.compare_networks'](network, temp_net_info, ignore='Name,Id,Created,Containers')\n            if not changes:\n                create_network = False\n            else:\n                ret['changes'][name] = changes\n                if __opts__['test']:\n                    ret['result'] = None\n                    ret['comment'] = 'Network would be recreated with new config'\n                    return ret\n                if network['Containers']:\n                    disconnected_containers = copy.deepcopy(network['Containers'])\n                    if not containers and reconnect:\n                        for cid in disconnected_containers:\n                            try:\n                                cinfo = __salt__['docker.inspect_container'](cid)\n                                netinfo = cinfo['NetworkSettings']['Networks'][name]\n                                net_links = netinfo.get('Links') or []\n                                net_aliases = netinfo.get('Aliases') or []\n                                if net_links:\n                                    disconnected_containers[cid]['Links'] = net_links\n                                if net_aliases:\n                                    disconnected_containers[cid]['Aliases'] = net_aliases\n                            except (CommandExecutionError, KeyError, ValueError):\n                                continue\n                remove_result = _remove_network(network)\n                if not remove_result['result']:\n                    return remove_result\n                network['Containers'] = {}\n        finally:\n            try:\n                __salt__['docker.remove_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret.setdefault('warnings', []).append(\"Failed to remove temp network '{}': {}.\".format(temp_net_name, exc.__str__()))\n    if create_network:\n        log.debug(\"Network '%s' will be created\", name)\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'Network will be created'\n            return ret\n        kwargs['ipam'] = ipam_config\n        try:\n            __salt__['docker.create_network'](name, skip_translate=True, **kwargs)\n        except Exception as exc:\n            ret['comment'] = \"Failed to create network '{}': {}\".format(name, exc.__str__())\n            return ret\n        else:\n            action = 'recreated' if network is not None else 'created'\n            ret['changes'][action] = True\n            ret['comment'] = \"Network '{}' {}\".format(name, 'created' if network is None else 'was replaced with updated config')\n            network = {'Containers': {}}\n    if containers is None and reconnect and disconnected_containers:\n        to_connect = disconnected_containers\n    for cid in list(to_connect):\n        if cid in network['Containers']:\n            del to_connect[cid]\n    errors = []\n    if to_connect:\n        for (cid, connect_info) in to_connect.items():\n            connect_kwargs = {}\n            if cid in disconnected_containers:\n                for (key_name, arg_name) in (('IPv4Address', 'ipv4_address'), ('IPV6Address', 'ipv6_address'), ('Links', 'links'), ('Aliases', 'aliases')):\n                    try:\n                        connect_kwargs[arg_name] = connect_info[key_name]\n                    except (KeyError, AttributeError):\n                        continue\n                    else:\n                        if key_name.endswith('Address'):\n                            connect_kwargs[arg_name] = connect_kwargs[arg_name].rsplit('/', 1)[0]\n            try:\n                __salt__['docker.connect_container_to_network'](cid, name, **connect_kwargs)\n            except CommandExecutionError as exc:\n                if not connect_kwargs:\n                    errors.append(exc.__str__())\n                else:\n                    try:\n                        __salt__['docker.connect_container_to_network'](cid, name)\n                    except CommandExecutionError as exc:\n                        errors.append(exc.__str__())\n                    else:\n                        ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n            else:\n                ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n    if errors:\n        if ret['comment']:\n            ret['comment'] += '. '\n        ret['comment'] += '. '.join(errors) + '.'\n    else:\n        ret['result'] = True\n    for (cid, c_info) in disconnected_containers.items():\n        if cid not in to_connect:\n            ret['changes'].setdefault('disconnected', []).append(c_info['Name'])\n    return ret",
            "def present(name, skip_translate=None, ignore_collisions=False, validate_ip_addrs=True, containers=None, reconnect=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionchanged:: 2018.3.0\\n        Support added for network configuration options other than ``driver``\\n        and ``driver_opts``, as well as IPAM configuration.\\n\\n    Ensure that a network is present\\n\\n    .. note::\\n        This state supports all arguments for network and IPAM pool\\n        configuration which are available for the release of docker-py\\n        installed on the minion. For that reason, the arguments described below\\n        in the :ref:`NETWORK CONFIGURATION\\n        <salt-states-docker-network-present-netconf>` and :ref:`IP ADDRESS\\n        MANAGEMENT (IPAM) <salt-states-docker-network-present-ipam>` sections\\n        may not accurately reflect what is available on the minion. The\\n        :py:func:`docker.get_client_args\\n        <salt.modules.dockermod.get_client_args>` function can be used to check\\n        the available arguments for the installed version of docker-py (they\\n        are found in the ``network_config`` and ``ipam_config`` sections of the\\n        return data), but Salt will not prevent a user from attempting to use\\n        an argument which is unsupported in the release of Docker which is\\n        installed. In those cases, network creation be attempted but will fail.\\n\\n    name\\n        Network name\\n\\n    skip_translate\\n        This function translates Salt SLS input into the format which\\n        docker-py expects. However, in the event that Salt's translation logic\\n        fails (due to potential changes in the Docker Remote API, or to bugs in\\n        the translation code), this argument can be used to exert granular\\n        control over which arguments are translated and which are not.\\n\\n        Pass this argument as a comma-separated list (or Python list) of\\n        arguments, and translation for each passed argument name will be\\n        skipped. Alternatively, pass ``True`` and *all* translation will be\\n        skipped.\\n\\n        Skipping tranlsation allows for arguments to be formatted directly in\\n        the format which docker-py expects. This allows for API changes and\\n        other issues to be more easily worked around. See the following links\\n        for more information:\\n\\n        - `docker-py Low-level API`_\\n        - `Docker Engine API`_\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _`docker-py Low-level API`: http://docker-py.readthedocs.io/en/stable/api.html#docker.api.container.ContainerApiMixin.create_container\\n    .. _`Docker Engine API`: https://docs.docker.com/engine/api/v1.33/#operation/ContainerCreate\\n\\n    ignore_collisions : False\\n        Since many of docker-py's arguments differ in name from their CLI\\n        counterparts (with which most Docker users are more familiar), Salt\\n        detects usage of these and aliases them to the docker-py version of\\n        that argument. However, if both the alias and the docker-py version of\\n        the same argument (e.g. ``options`` and ``driver_opts``) are used, an error\\n        will be raised. Set this argument to ``True`` to suppress these errors\\n        and keep the docker-py version of the argument.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    validate_ip_addrs : True\\n        For parameters which accept IP addresses/subnets as input, validation\\n        will be performed. To disable, set this to ``False``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    containers\\n        A list of containers which should be connected to this network.\\n\\n        .. note::\\n            As of the 2018.3.0 release, this is not the recommended way of\\n            managing a container's membership in a network, for a couple\\n            reasons:\\n\\n            1. It does not support setting static IPs, aliases, or links in the\\n               container's IP configuration.\\n            2. If a :py:func:`docker_container.running\\n               <salt.states.docker_container.running>` state replaces a\\n               container, it will not be reconnected to the network until the\\n               ``docker_network.present`` state is run again. Since containers\\n               often have ``require`` requisites to ensure that the network\\n               is present, this means that the ``docker_network.present`` state\\n               ends up being run *before* the :py:func:`docker_container.running\\n               <salt.states.docker_container.running>`, leaving the container\\n               unattached at the end of the Salt run.\\n\\n            For these reasons, it is recommended to use\\n            :ref:`docker_container.running's network management support\\n            <salt-states-docker-container-network-management>`.\\n\\n    reconnect : True\\n        If ``containers`` is not used, and the network is replaced, then Salt\\n        will keep track of the containers which were connected to the network\\n        and reconnect them to the network after it is replaced. Salt will first\\n        attempt to reconnect using the same IP the container had before the\\n        network was replaced. If that fails (for instance, if the network was\\n        replaced because the subnet was modified), then the container will be\\n        reconnected without an explicit IP address, and its IP will be assigned\\n        by Docker.\\n\\n        Set this option to ``False`` to keep Salt from trying to reconnect\\n        containers. This can be useful in some cases when :ref:`managing static\\n        IPs in docker_container.running\\n        <salt-states-docker-container-network-management>`. For instance, if a\\n        network's subnet is modified, it is likely that the static IP will need\\n        to be updated in the ``docker_container.running`` state as well. When\\n        the network is replaced, the initial reconnect attempt would fail, and\\n        the container would be reconnected with an automatically-assigned IP\\n        address. Then, when the ``docker_container.running`` state executes, it\\n        would disconnect the network *again* and reconnect using the new static\\n        IP. Disabling the reconnect behavior in these cases would prevent the\\n        unnecessary extra reconnection.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _salt-states-docker-network-present-netconf:\\n\\n    **NETWORK CONFIGURATION ARGUMENTS**\\n\\n    driver\\n        Network driver\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n\\n    driver_opts (or *driver_opt*, or *options*)\\n        Options for the network driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts: macvlan_mode=bridge,parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode=bridge\\n                  - parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode: bridge\\n                  - parent: eth0\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                    macvlan_mode: bridge\\n                    parent: eth0\\n\\n    check_duplicate : True\\n        If ``True``, checks for networks with duplicate names. Since networks\\n        are primarily keyed based on a random ID and not on the name, and\\n        network name is strictly a user-friendly alias to the network which is\\n        uniquely identified using ID, there is no guaranteed way to check for\\n        duplicates. This option providess a best effort, checking for any\\n        networks which have the same name, but it is not guaranteed to catch\\n        all name collisions.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - check_duplicate: False\\n\\n    internal : False\\n        If ``True``, restricts external access to the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - internal: True\\n\\n    labels\\n        Add metadata to the network. Labels can be set both with and without\\n        values, and labels with values can be passed either as ``key=value`` or\\n        ``key: value`` pairs. For example, while the below would be very\\n        confusing to read, it is technically valid, and demonstrates the\\n        different ways in which labels can be passed:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - labels:\\n                  - foo\\n                  - bar=baz\\n                  - hello: world\\n\\n        The labels can also simply be passed as a YAML dictionary, though this\\n        can be error-prone due to some :ref:`idiosyncrasies\\n        <yaml-idiosyncrasies>` with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            foo:\\n              docker_network.present:\\n                - labels:\\n                    foo: ''\\n                    bar: baz\\n                    hello: world\\n\\n        .. versionchanged:: 2018.3.0\\n            Methods for specifying labels can now be mixed. Earlier releases\\n            required either labels with or without values.\\n\\n    enable_ipv6 (or *ipv6*) : False\\n        Enable IPv6 on the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - enable_ipv6: True\\n\\n        .. note::\\n            While it should go without saying, this argument must be set to\\n            ``True`` to :ref:`configure an IPv6 subnet\\n            <salt-states-docker-network-present-ipam>`. Also, if this option is\\n            turned on without an IPv6 subnet explicitly configured, you will\\n            get an error unless you have set up a fixed IPv6 subnet. Consult\\n            the `Docker IPv6 docs`_ for information on how to do this.\\n\\n            .. _`Docker IPv6 docs`: https://docs.docker.com/v17.09/engine/userguide/networking/default_network/ipv6/\\n\\n    attachable : False\\n        If ``True``, and the network is in the global scope, non-service\\n        containers on worker nodes will be able to connect to the network.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - attachable: True\\n\\n        .. note::\\n            This option cannot be reliably managed on CentOS 7. This is because\\n            while support for this option was added in API version 1.24, its\\n            value was not added to the inpsect results until API version 1.26.\\n            The version of Docker which is available for CentOS 7 runs API\\n            version 1.24, meaning that while Salt can pass this argument to the\\n            API, it has no way of knowing the value of this config option in an\\n            existing Docker network.\\n\\n    scope\\n        Specify the network's scope (``local``, ``global`` or ``swarm``)\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - scope: local\\n\\n    ingress : False\\n        If ``True``, create an ingress network which provides the routing-mesh in\\n        swarm mode\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ingress: True\\n\\n    .. _salt-states-docker-network-present-ipam:\\n\\n    **IP ADDRESS MANAGEMENT (IPAM)**\\n\\n    This state supports networks with either IPv4, or both IPv4 and IPv6. If\\n    configuring IPv4, then you can pass the :ref:`IPAM pool arguments\\n    <salt-states-docker-network-present-ipam-pool-arguments>` below as\\n    individual arguments. However, if configuring IPv4 and IPv6, the arguments\\n    must be passed as a list of dictionaries, in the ``ipam_pools`` argument\\n    (click :ref:`here <salt-states-docker-network-present-ipam-examples>` for\\n    some examples). `These docs`_ also have more information on these\\n    arguments.\\n\\n    .. _`These docs`: http://docker-py.readthedocs.io/en/stable/api.html#docker.types.IPAMPool\\n\\n    *IPAM ARGUMENTS*\\n\\n    ipam_driver\\n        IPAM driver to use, if different from the default one\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n\\n    ipam_opts\\n        Options for the IPAM driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts: foo=bar,baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo=bar\\n                  - baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo: bar\\n                  - baz: qux\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: macvlan\\n                - ipam_opts:\\n                    foo: bar\\n                    baz: qux\\n\\n    .. _salt-states-docker-network-present-ipam-pool-arguments:\\n\\n    *IPAM POOL ARGUMENTS*\\n\\n    subnet\\n        Subnet in CIDR format that represents a network segment\\n\\n    iprange (or *ip_range*)\\n        Allocate container IP from a sub-range within the subnet\\n\\n        Subnet in CIDR format that represents a network segment\\n\\n    gateway\\n        IPv4 or IPv6 gateway for the master subnet\\n\\n    aux_addresses (or *aux_address*)\\n        A dictionary of mapping container names to IP addresses which should be\\n        allocated for them should they connect to the network. Either a\\n        dictionary of option names and values or a Python list of strings in\\n        the format ``host=ipaddr``.\\n\\n    .. _salt-states-docker-network-present-ipam-examples:\\n\\n    *IPAM CONFIGURATION EXAMPLES*\\n\\n    Below is an example of an IPv4-only network (keep in mind that ``subnet``\\n    is the only required argument).\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - subnet: 10.0.20.0/24\\n            - iprange: 10.0.20.128/25\\n            - gateway: 10.0.20.254\\n            - aux_addresses:\\n              - foo.bar.tld: 10.0.20.50\\n              - hello.world.tld: 10.0.20.51\\n\\n    .. note::\\n        The ``aux_addresses`` can be passed differently, in the same way that\\n        ``driver_opts`` and ``ipam_opts`` can.\\n\\n    This same network could also be configured this way:\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                iprange: 10.0.20.128/25\\n                gateway: 10.0.20.254\\n                aux_addresses:\\n                  foo.bar.tld: 10.0.20.50\\n                  hello.world.tld: 10.0.20.51\\n\\n    Here is an example of a mixed IPv4/IPv6 subnet.\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                gateway: 10.0.20.1\\n              - subnet: fe3f:2180:26:1::/123\\n                gateway: fe3f:2180:26:1::1\\n    \"\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    to_connect = {}\n    missing_containers = []\n    stopped_containers = []\n    for cname in __utils__['args.split_input'](containers or []):\n        try:\n            cinfo = __salt__['docker.inspect_container'](cname)\n        except CommandExecutionError:\n            missing_containers.append(cname)\n        else:\n            try:\n                cid = cinfo['Id']\n            except KeyError:\n                missing_containers.append(cname)\n            else:\n                if not cinfo.get('State', {}).get('Running', False):\n                    stopped_containers.append(cname)\n                else:\n                    to_connect[cid] = {'Name': cname}\n    if missing_containers:\n        ret.setdefault('warnings', []).append('The following containers do not exist: {}.'.format(', '.join(missing_containers)))\n    if stopped_containers:\n        ret.setdefault('warnings', []).append('The following containers are not running: {}.'.format(', '.join(stopped_containers)))\n    disconnected_containers = {}\n    try:\n        kwargs = __utils__['docker.translate_input'](salt.utils.dockermod.translate.network, skip_translate=skip_translate, ignore_collisions=ignore_collisions, validate_ip_addrs=validate_ip_addrs, **__utils__['args.clean_kwargs'](**kwargs))\n    except Exception as exc:\n        ret['comment'] = exc.__str__()\n        return ret\n    ipam_kwargs = {}\n    ipam_kwarg_names = ['ipam', 'ipam_driver', 'ipam_opts', 'ipam_pools']\n    ipam_kwarg_names.extend(__salt__['docker.get_client_args']('ipam_config')['ipam_config'])\n    for key in ipam_kwarg_names:\n        try:\n            ipam_kwargs[key] = kwargs.pop(key)\n        except KeyError:\n            pass\n    if 'ipam' in ipam_kwargs:\n        if len(ipam_kwargs) > 1:\n            ret['comment'] = \"Cannot mix the 'ipam' argument with any of the IPAM config arguments. See documentation for details.\"\n            return ret\n        ipam_config = ipam_kwargs['ipam']\n    else:\n        ipam_pools = ipam_kwargs.pop('ipam_pools', ())\n        try:\n            ipam_config = __utils__['docker.create_ipam_config'](*ipam_pools, **ipam_kwargs)\n        except Exception as exc:\n            ret['comment'] = exc.__str__()\n            return ret\n    create_network = True\n    if network is not None:\n        log.debug(\"Docker network '%s' already exists\", name)\n        ret['comment'] = f\"Network '{name}' already exists, and is configured as specified\"\n        log.trace(\"Details of docker network '%s': %s\", name, network)\n        temp_net_name = ''.join((random.choice(string.ascii_lowercase) for _ in range(20)))\n        try:\n            enable_ipv6 = kwargs.pop('enable_ipv6', None)\n            kwargs_tmp = kwargs\n            driver = kwargs.get('driver')\n            driver_opts = kwargs.get('options', {})\n            bridge_name = driver_opts.get('com.docker.network.bridge.name', None)\n            if driver == 'bridge' and bridge_name is not None:\n                tmp_name = str(bridge_name) + 'comp'\n                kwargs_tmp['options']['com.docker.network.bridge.name'] = tmp_name[-14:]\n            __salt__['docker.create_network'](temp_net_name, skip_translate=True, enable_ipv6=False, **kwargs_tmp)\n        except CommandExecutionError as exc:\n            ret['comment'] = 'Failed to create temp network for comparison: {}'.format(exc.__str__())\n            return ret\n        else:\n            if enable_ipv6 is not None:\n                kwargs['enable_ipv6'] = enable_ipv6\n        try:\n            try:\n                temp_net_info = __salt__['docker.inspect_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret['comment'] = 'Failed to inspect temp network: {}'.format(exc.__str__())\n                return ret\n            else:\n                temp_net_info['EnableIPv6'] = bool(enable_ipv6)\n            temp_net_info['IPAM'] = ipam_config\n            existing_pool_count = len(network['IPAM']['Config'])\n            desired_pool_count = len(temp_net_info['IPAM']['Config'])\n            is_default_pool = lambda x: True if sorted(x) == ['Gateway', 'Subnet'] else False\n            if desired_pool_count == 0 and existing_pool_count == 1 and is_default_pool(network['IPAM']['Config'][0]):\n                network['IPAM']['Config'] = []\n            changes = __salt__['docker.compare_networks'](network, temp_net_info, ignore='Name,Id,Created,Containers')\n            if not changes:\n                create_network = False\n            else:\n                ret['changes'][name] = changes\n                if __opts__['test']:\n                    ret['result'] = None\n                    ret['comment'] = 'Network would be recreated with new config'\n                    return ret\n                if network['Containers']:\n                    disconnected_containers = copy.deepcopy(network['Containers'])\n                    if not containers and reconnect:\n                        for cid in disconnected_containers:\n                            try:\n                                cinfo = __salt__['docker.inspect_container'](cid)\n                                netinfo = cinfo['NetworkSettings']['Networks'][name]\n                                net_links = netinfo.get('Links') or []\n                                net_aliases = netinfo.get('Aliases') or []\n                                if net_links:\n                                    disconnected_containers[cid]['Links'] = net_links\n                                if net_aliases:\n                                    disconnected_containers[cid]['Aliases'] = net_aliases\n                            except (CommandExecutionError, KeyError, ValueError):\n                                continue\n                remove_result = _remove_network(network)\n                if not remove_result['result']:\n                    return remove_result\n                network['Containers'] = {}\n        finally:\n            try:\n                __salt__['docker.remove_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret.setdefault('warnings', []).append(\"Failed to remove temp network '{}': {}.\".format(temp_net_name, exc.__str__()))\n    if create_network:\n        log.debug(\"Network '%s' will be created\", name)\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'Network will be created'\n            return ret\n        kwargs['ipam'] = ipam_config\n        try:\n            __salt__['docker.create_network'](name, skip_translate=True, **kwargs)\n        except Exception as exc:\n            ret['comment'] = \"Failed to create network '{}': {}\".format(name, exc.__str__())\n            return ret\n        else:\n            action = 'recreated' if network is not None else 'created'\n            ret['changes'][action] = True\n            ret['comment'] = \"Network '{}' {}\".format(name, 'created' if network is None else 'was replaced with updated config')\n            network = {'Containers': {}}\n    if containers is None and reconnect and disconnected_containers:\n        to_connect = disconnected_containers\n    for cid in list(to_connect):\n        if cid in network['Containers']:\n            del to_connect[cid]\n    errors = []\n    if to_connect:\n        for (cid, connect_info) in to_connect.items():\n            connect_kwargs = {}\n            if cid in disconnected_containers:\n                for (key_name, arg_name) in (('IPv4Address', 'ipv4_address'), ('IPV6Address', 'ipv6_address'), ('Links', 'links'), ('Aliases', 'aliases')):\n                    try:\n                        connect_kwargs[arg_name] = connect_info[key_name]\n                    except (KeyError, AttributeError):\n                        continue\n                    else:\n                        if key_name.endswith('Address'):\n                            connect_kwargs[arg_name] = connect_kwargs[arg_name].rsplit('/', 1)[0]\n            try:\n                __salt__['docker.connect_container_to_network'](cid, name, **connect_kwargs)\n            except CommandExecutionError as exc:\n                if not connect_kwargs:\n                    errors.append(exc.__str__())\n                else:\n                    try:\n                        __salt__['docker.connect_container_to_network'](cid, name)\n                    except CommandExecutionError as exc:\n                        errors.append(exc.__str__())\n                    else:\n                        ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n            else:\n                ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n    if errors:\n        if ret['comment']:\n            ret['comment'] += '. '\n        ret['comment'] += '. '.join(errors) + '.'\n    else:\n        ret['result'] = True\n    for (cid, c_info) in disconnected_containers.items():\n        if cid not in to_connect:\n            ret['changes'].setdefault('disconnected', []).append(c_info['Name'])\n    return ret",
            "def present(name, skip_translate=None, ignore_collisions=False, validate_ip_addrs=True, containers=None, reconnect=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionchanged:: 2018.3.0\\n        Support added for network configuration options other than ``driver``\\n        and ``driver_opts``, as well as IPAM configuration.\\n\\n    Ensure that a network is present\\n\\n    .. note::\\n        This state supports all arguments for network and IPAM pool\\n        configuration which are available for the release of docker-py\\n        installed on the minion. For that reason, the arguments described below\\n        in the :ref:`NETWORK CONFIGURATION\\n        <salt-states-docker-network-present-netconf>` and :ref:`IP ADDRESS\\n        MANAGEMENT (IPAM) <salt-states-docker-network-present-ipam>` sections\\n        may not accurately reflect what is available on the minion. The\\n        :py:func:`docker.get_client_args\\n        <salt.modules.dockermod.get_client_args>` function can be used to check\\n        the available arguments for the installed version of docker-py (they\\n        are found in the ``network_config`` and ``ipam_config`` sections of the\\n        return data), but Salt will not prevent a user from attempting to use\\n        an argument which is unsupported in the release of Docker which is\\n        installed. In those cases, network creation be attempted but will fail.\\n\\n    name\\n        Network name\\n\\n    skip_translate\\n        This function translates Salt SLS input into the format which\\n        docker-py expects. However, in the event that Salt's translation logic\\n        fails (due to potential changes in the Docker Remote API, or to bugs in\\n        the translation code), this argument can be used to exert granular\\n        control over which arguments are translated and which are not.\\n\\n        Pass this argument as a comma-separated list (or Python list) of\\n        arguments, and translation for each passed argument name will be\\n        skipped. Alternatively, pass ``True`` and *all* translation will be\\n        skipped.\\n\\n        Skipping tranlsation allows for arguments to be formatted directly in\\n        the format which docker-py expects. This allows for API changes and\\n        other issues to be more easily worked around. See the following links\\n        for more information:\\n\\n        - `docker-py Low-level API`_\\n        - `Docker Engine API`_\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _`docker-py Low-level API`: http://docker-py.readthedocs.io/en/stable/api.html#docker.api.container.ContainerApiMixin.create_container\\n    .. _`Docker Engine API`: https://docs.docker.com/engine/api/v1.33/#operation/ContainerCreate\\n\\n    ignore_collisions : False\\n        Since many of docker-py's arguments differ in name from their CLI\\n        counterparts (with which most Docker users are more familiar), Salt\\n        detects usage of these and aliases them to the docker-py version of\\n        that argument. However, if both the alias and the docker-py version of\\n        the same argument (e.g. ``options`` and ``driver_opts``) are used, an error\\n        will be raised. Set this argument to ``True`` to suppress these errors\\n        and keep the docker-py version of the argument.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    validate_ip_addrs : True\\n        For parameters which accept IP addresses/subnets as input, validation\\n        will be performed. To disable, set this to ``False``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    containers\\n        A list of containers which should be connected to this network.\\n\\n        .. note::\\n            As of the 2018.3.0 release, this is not the recommended way of\\n            managing a container's membership in a network, for a couple\\n            reasons:\\n\\n            1. It does not support setting static IPs, aliases, or links in the\\n               container's IP configuration.\\n            2. If a :py:func:`docker_container.running\\n               <salt.states.docker_container.running>` state replaces a\\n               container, it will not be reconnected to the network until the\\n               ``docker_network.present`` state is run again. Since containers\\n               often have ``require`` requisites to ensure that the network\\n               is present, this means that the ``docker_network.present`` state\\n               ends up being run *before* the :py:func:`docker_container.running\\n               <salt.states.docker_container.running>`, leaving the container\\n               unattached at the end of the Salt run.\\n\\n            For these reasons, it is recommended to use\\n            :ref:`docker_container.running's network management support\\n            <salt-states-docker-container-network-management>`.\\n\\n    reconnect : True\\n        If ``containers`` is not used, and the network is replaced, then Salt\\n        will keep track of the containers which were connected to the network\\n        and reconnect them to the network after it is replaced. Salt will first\\n        attempt to reconnect using the same IP the container had before the\\n        network was replaced. If that fails (for instance, if the network was\\n        replaced because the subnet was modified), then the container will be\\n        reconnected without an explicit IP address, and its IP will be assigned\\n        by Docker.\\n\\n        Set this option to ``False`` to keep Salt from trying to reconnect\\n        containers. This can be useful in some cases when :ref:`managing static\\n        IPs in docker_container.running\\n        <salt-states-docker-container-network-management>`. For instance, if a\\n        network's subnet is modified, it is likely that the static IP will need\\n        to be updated in the ``docker_container.running`` state as well. When\\n        the network is replaced, the initial reconnect attempt would fail, and\\n        the container would be reconnected with an automatically-assigned IP\\n        address. Then, when the ``docker_container.running`` state executes, it\\n        would disconnect the network *again* and reconnect using the new static\\n        IP. Disabling the reconnect behavior in these cases would prevent the\\n        unnecessary extra reconnection.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    .. _salt-states-docker-network-present-netconf:\\n\\n    **NETWORK CONFIGURATION ARGUMENTS**\\n\\n    driver\\n        Network driver\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n\\n    driver_opts (or *driver_opt*, or *options*)\\n        Options for the network driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts: macvlan_mode=bridge,parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode=bridge\\n                  - parent=eth0\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                  - macvlan_mode: bridge\\n                  - parent: eth0\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - driver: macvlan\\n                - driver_opts:\\n                    macvlan_mode: bridge\\n                    parent: eth0\\n\\n    check_duplicate : True\\n        If ``True``, checks for networks with duplicate names. Since networks\\n        are primarily keyed based on a random ID and not on the name, and\\n        network name is strictly a user-friendly alias to the network which is\\n        uniquely identified using ID, there is no guaranteed way to check for\\n        duplicates. This option providess a best effort, checking for any\\n        networks which have the same name, but it is not guaranteed to catch\\n        all name collisions.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - check_duplicate: False\\n\\n    internal : False\\n        If ``True``, restricts external access to the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - internal: True\\n\\n    labels\\n        Add metadata to the network. Labels can be set both with and without\\n        values, and labels with values can be passed either as ``key=value`` or\\n        ``key: value`` pairs. For example, while the below would be very\\n        confusing to read, it is technically valid, and demonstrates the\\n        different ways in which labels can be passed:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - labels:\\n                  - foo\\n                  - bar=baz\\n                  - hello: world\\n\\n        The labels can also simply be passed as a YAML dictionary, though this\\n        can be error-prone due to some :ref:`idiosyncrasies\\n        <yaml-idiosyncrasies>` with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            foo:\\n              docker_network.present:\\n                - labels:\\n                    foo: ''\\n                    bar: baz\\n                    hello: world\\n\\n        .. versionchanged:: 2018.3.0\\n            Methods for specifying labels can now be mixed. Earlier releases\\n            required either labels with or without values.\\n\\n    enable_ipv6 (or *ipv6*) : False\\n        Enable IPv6 on the network\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - enable_ipv6: True\\n\\n        .. note::\\n            While it should go without saying, this argument must be set to\\n            ``True`` to :ref:`configure an IPv6 subnet\\n            <salt-states-docker-network-present-ipam>`. Also, if this option is\\n            turned on without an IPv6 subnet explicitly configured, you will\\n            get an error unless you have set up a fixed IPv6 subnet. Consult\\n            the `Docker IPv6 docs`_ for information on how to do this.\\n\\n            .. _`Docker IPv6 docs`: https://docs.docker.com/v17.09/engine/userguide/networking/default_network/ipv6/\\n\\n    attachable : False\\n        If ``True``, and the network is in the global scope, non-service\\n        containers on worker nodes will be able to connect to the network.\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - attachable: True\\n\\n        .. note::\\n            This option cannot be reliably managed on CentOS 7. This is because\\n            while support for this option was added in API version 1.24, its\\n            value was not added to the inpsect results until API version 1.26.\\n            The version of Docker which is available for CentOS 7 runs API\\n            version 1.24, meaning that while Salt can pass this argument to the\\n            API, it has no way of knowing the value of this config option in an\\n            existing Docker network.\\n\\n    scope\\n        Specify the network's scope (``local``, ``global`` or ``swarm``)\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - scope: local\\n\\n    ingress : False\\n        If ``True``, create an ingress network which provides the routing-mesh in\\n        swarm mode\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ingress: True\\n\\n    .. _salt-states-docker-network-present-ipam:\\n\\n    **IP ADDRESS MANAGEMENT (IPAM)**\\n\\n    This state supports networks with either IPv4, or both IPv4 and IPv6. If\\n    configuring IPv4, then you can pass the :ref:`IPAM pool arguments\\n    <salt-states-docker-network-present-ipam-pool-arguments>` below as\\n    individual arguments. However, if configuring IPv4 and IPv6, the arguments\\n    must be passed as a list of dictionaries, in the ``ipam_pools`` argument\\n    (click :ref:`here <salt-states-docker-network-present-ipam-examples>` for\\n    some examples). `These docs`_ also have more information on these\\n    arguments.\\n\\n    .. _`These docs`: http://docker-py.readthedocs.io/en/stable/api.html#docker.types.IPAMPool\\n\\n    *IPAM ARGUMENTS*\\n\\n    ipam_driver\\n        IPAM driver to use, if different from the default one\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n\\n    ipam_opts\\n        Options for the IPAM driver. Either a dictionary of option names and\\n        values or a Python list of strings in the format ``varname=value``. The\\n        below three examples are equivalent:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts: foo=bar,baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo=bar\\n                  - baz=qux\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: foo\\n                - ipam_opts:\\n                  - foo: bar\\n                  - baz: qux\\n\\n        The options can also simply be passed as a dictionary, though this can\\n        be error-prone due to some :ref:`idiosyncrasies <yaml-idiosyncrasies>`\\n        with how PyYAML loads nested data structures:\\n\\n        .. code-block:: yaml\\n\\n            mynet:\\n              docker_network.present:\\n                - ipam_driver: macvlan\\n                - ipam_opts:\\n                    foo: bar\\n                    baz: qux\\n\\n    .. _salt-states-docker-network-present-ipam-pool-arguments:\\n\\n    *IPAM POOL ARGUMENTS*\\n\\n    subnet\\n        Subnet in CIDR format that represents a network segment\\n\\n    iprange (or *ip_range*)\\n        Allocate container IP from a sub-range within the subnet\\n\\n        Subnet in CIDR format that represents a network segment\\n\\n    gateway\\n        IPv4 or IPv6 gateway for the master subnet\\n\\n    aux_addresses (or *aux_address*)\\n        A dictionary of mapping container names to IP addresses which should be\\n        allocated for them should they connect to the network. Either a\\n        dictionary of option names and values or a Python list of strings in\\n        the format ``host=ipaddr``.\\n\\n    .. _salt-states-docker-network-present-ipam-examples:\\n\\n    *IPAM CONFIGURATION EXAMPLES*\\n\\n    Below is an example of an IPv4-only network (keep in mind that ``subnet``\\n    is the only required argument).\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - subnet: 10.0.20.0/24\\n            - iprange: 10.0.20.128/25\\n            - gateway: 10.0.20.254\\n            - aux_addresses:\\n              - foo.bar.tld: 10.0.20.50\\n              - hello.world.tld: 10.0.20.51\\n\\n    .. note::\\n        The ``aux_addresses`` can be passed differently, in the same way that\\n        ``driver_opts`` and ``ipam_opts`` can.\\n\\n    This same network could also be configured this way:\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                iprange: 10.0.20.128/25\\n                gateway: 10.0.20.254\\n                aux_addresses:\\n                  foo.bar.tld: 10.0.20.50\\n                  hello.world.tld: 10.0.20.51\\n\\n    Here is an example of a mixed IPv4/IPv6 subnet.\\n\\n    .. code-block:: yaml\\n\\n        mynet:\\n          docker_network.present:\\n            - ipam_pools:\\n              - subnet: 10.0.20.0/24\\n                gateway: 10.0.20.1\\n              - subnet: fe3f:2180:26:1::/123\\n                gateway: fe3f:2180:26:1::1\\n    \"\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    to_connect = {}\n    missing_containers = []\n    stopped_containers = []\n    for cname in __utils__['args.split_input'](containers or []):\n        try:\n            cinfo = __salt__['docker.inspect_container'](cname)\n        except CommandExecutionError:\n            missing_containers.append(cname)\n        else:\n            try:\n                cid = cinfo['Id']\n            except KeyError:\n                missing_containers.append(cname)\n            else:\n                if not cinfo.get('State', {}).get('Running', False):\n                    stopped_containers.append(cname)\n                else:\n                    to_connect[cid] = {'Name': cname}\n    if missing_containers:\n        ret.setdefault('warnings', []).append('The following containers do not exist: {}.'.format(', '.join(missing_containers)))\n    if stopped_containers:\n        ret.setdefault('warnings', []).append('The following containers are not running: {}.'.format(', '.join(stopped_containers)))\n    disconnected_containers = {}\n    try:\n        kwargs = __utils__['docker.translate_input'](salt.utils.dockermod.translate.network, skip_translate=skip_translate, ignore_collisions=ignore_collisions, validate_ip_addrs=validate_ip_addrs, **__utils__['args.clean_kwargs'](**kwargs))\n    except Exception as exc:\n        ret['comment'] = exc.__str__()\n        return ret\n    ipam_kwargs = {}\n    ipam_kwarg_names = ['ipam', 'ipam_driver', 'ipam_opts', 'ipam_pools']\n    ipam_kwarg_names.extend(__salt__['docker.get_client_args']('ipam_config')['ipam_config'])\n    for key in ipam_kwarg_names:\n        try:\n            ipam_kwargs[key] = kwargs.pop(key)\n        except KeyError:\n            pass\n    if 'ipam' in ipam_kwargs:\n        if len(ipam_kwargs) > 1:\n            ret['comment'] = \"Cannot mix the 'ipam' argument with any of the IPAM config arguments. See documentation for details.\"\n            return ret\n        ipam_config = ipam_kwargs['ipam']\n    else:\n        ipam_pools = ipam_kwargs.pop('ipam_pools', ())\n        try:\n            ipam_config = __utils__['docker.create_ipam_config'](*ipam_pools, **ipam_kwargs)\n        except Exception as exc:\n            ret['comment'] = exc.__str__()\n            return ret\n    create_network = True\n    if network is not None:\n        log.debug(\"Docker network '%s' already exists\", name)\n        ret['comment'] = f\"Network '{name}' already exists, and is configured as specified\"\n        log.trace(\"Details of docker network '%s': %s\", name, network)\n        temp_net_name = ''.join((random.choice(string.ascii_lowercase) for _ in range(20)))\n        try:\n            enable_ipv6 = kwargs.pop('enable_ipv6', None)\n            kwargs_tmp = kwargs\n            driver = kwargs.get('driver')\n            driver_opts = kwargs.get('options', {})\n            bridge_name = driver_opts.get('com.docker.network.bridge.name', None)\n            if driver == 'bridge' and bridge_name is not None:\n                tmp_name = str(bridge_name) + 'comp'\n                kwargs_tmp['options']['com.docker.network.bridge.name'] = tmp_name[-14:]\n            __salt__['docker.create_network'](temp_net_name, skip_translate=True, enable_ipv6=False, **kwargs_tmp)\n        except CommandExecutionError as exc:\n            ret['comment'] = 'Failed to create temp network for comparison: {}'.format(exc.__str__())\n            return ret\n        else:\n            if enable_ipv6 is not None:\n                kwargs['enable_ipv6'] = enable_ipv6\n        try:\n            try:\n                temp_net_info = __salt__['docker.inspect_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret['comment'] = 'Failed to inspect temp network: {}'.format(exc.__str__())\n                return ret\n            else:\n                temp_net_info['EnableIPv6'] = bool(enable_ipv6)\n            temp_net_info['IPAM'] = ipam_config\n            existing_pool_count = len(network['IPAM']['Config'])\n            desired_pool_count = len(temp_net_info['IPAM']['Config'])\n            is_default_pool = lambda x: True if sorted(x) == ['Gateway', 'Subnet'] else False\n            if desired_pool_count == 0 and existing_pool_count == 1 and is_default_pool(network['IPAM']['Config'][0]):\n                network['IPAM']['Config'] = []\n            changes = __salt__['docker.compare_networks'](network, temp_net_info, ignore='Name,Id,Created,Containers')\n            if not changes:\n                create_network = False\n            else:\n                ret['changes'][name] = changes\n                if __opts__['test']:\n                    ret['result'] = None\n                    ret['comment'] = 'Network would be recreated with new config'\n                    return ret\n                if network['Containers']:\n                    disconnected_containers = copy.deepcopy(network['Containers'])\n                    if not containers and reconnect:\n                        for cid in disconnected_containers:\n                            try:\n                                cinfo = __salt__['docker.inspect_container'](cid)\n                                netinfo = cinfo['NetworkSettings']['Networks'][name]\n                                net_links = netinfo.get('Links') or []\n                                net_aliases = netinfo.get('Aliases') or []\n                                if net_links:\n                                    disconnected_containers[cid]['Links'] = net_links\n                                if net_aliases:\n                                    disconnected_containers[cid]['Aliases'] = net_aliases\n                            except (CommandExecutionError, KeyError, ValueError):\n                                continue\n                remove_result = _remove_network(network)\n                if not remove_result['result']:\n                    return remove_result\n                network['Containers'] = {}\n        finally:\n            try:\n                __salt__['docker.remove_network'](temp_net_name)\n            except CommandExecutionError as exc:\n                ret.setdefault('warnings', []).append(\"Failed to remove temp network '{}': {}.\".format(temp_net_name, exc.__str__()))\n    if create_network:\n        log.debug(\"Network '%s' will be created\", name)\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'Network will be created'\n            return ret\n        kwargs['ipam'] = ipam_config\n        try:\n            __salt__['docker.create_network'](name, skip_translate=True, **kwargs)\n        except Exception as exc:\n            ret['comment'] = \"Failed to create network '{}': {}\".format(name, exc.__str__())\n            return ret\n        else:\n            action = 'recreated' if network is not None else 'created'\n            ret['changes'][action] = True\n            ret['comment'] = \"Network '{}' {}\".format(name, 'created' if network is None else 'was replaced with updated config')\n            network = {'Containers': {}}\n    if containers is None and reconnect and disconnected_containers:\n        to_connect = disconnected_containers\n    for cid in list(to_connect):\n        if cid in network['Containers']:\n            del to_connect[cid]\n    errors = []\n    if to_connect:\n        for (cid, connect_info) in to_connect.items():\n            connect_kwargs = {}\n            if cid in disconnected_containers:\n                for (key_name, arg_name) in (('IPv4Address', 'ipv4_address'), ('IPV6Address', 'ipv6_address'), ('Links', 'links'), ('Aliases', 'aliases')):\n                    try:\n                        connect_kwargs[arg_name] = connect_info[key_name]\n                    except (KeyError, AttributeError):\n                        continue\n                    else:\n                        if key_name.endswith('Address'):\n                            connect_kwargs[arg_name] = connect_kwargs[arg_name].rsplit('/', 1)[0]\n            try:\n                __salt__['docker.connect_container_to_network'](cid, name, **connect_kwargs)\n            except CommandExecutionError as exc:\n                if not connect_kwargs:\n                    errors.append(exc.__str__())\n                else:\n                    try:\n                        __salt__['docker.connect_container_to_network'](cid, name)\n                    except CommandExecutionError as exc:\n                        errors.append(exc.__str__())\n                    else:\n                        ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n            else:\n                ret['changes'].setdefault('reconnected' if cid in disconnected_containers else 'connected', []).append(connect_info['Name'])\n    if errors:\n        if ret['comment']:\n            ret['comment'] += '. '\n        ret['comment'] += '. '.join(errors) + '.'\n    else:\n        ret['result'] = True\n    for (cid, c_info) in disconnected_containers.items():\n        if cid not in to_connect:\n            ret['changes'].setdefault('disconnected', []).append(c_info['Name'])\n    return ret"
        ]
    },
    {
        "func_name": "absent",
        "original": "def absent(name):\n    \"\"\"\n    Ensure that a network is absent.\n\n    name\n        Name of the network\n\n    Usage Example:\n\n    .. code-block:: yaml\n\n        network_foo:\n          docker_network.absent\n    \"\"\"\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if network is None:\n        ret['result'] = True\n        ret['comment'] = f\"Network '{name}' already absent\"\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = f\"Network '{name}' will be removed\"\n        return ret\n    return _remove_network(network)",
        "mutated": [
            "def absent(name):\n    if False:\n        i = 10\n    '\\n    Ensure that a network is absent.\\n\\n    name\\n        Name of the network\\n\\n    Usage Example:\\n\\n    .. code-block:: yaml\\n\\n        network_foo:\\n          docker_network.absent\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if network is None:\n        ret['result'] = True\n        ret['comment'] = f\"Network '{name}' already absent\"\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = f\"Network '{name}' will be removed\"\n        return ret\n    return _remove_network(network)",
            "def absent(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Ensure that a network is absent.\\n\\n    name\\n        Name of the network\\n\\n    Usage Example:\\n\\n    .. code-block:: yaml\\n\\n        network_foo:\\n          docker_network.absent\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if network is None:\n        ret['result'] = True\n        ret['comment'] = f\"Network '{name}' already absent\"\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = f\"Network '{name}' will be removed\"\n        return ret\n    return _remove_network(network)",
            "def absent(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Ensure that a network is absent.\\n\\n    name\\n        Name of the network\\n\\n    Usage Example:\\n\\n    .. code-block:: yaml\\n\\n        network_foo:\\n          docker_network.absent\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if network is None:\n        ret['result'] = True\n        ret['comment'] = f\"Network '{name}' already absent\"\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = f\"Network '{name}' will be removed\"\n        return ret\n    return _remove_network(network)",
            "def absent(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Ensure that a network is absent.\\n\\n    name\\n        Name of the network\\n\\n    Usage Example:\\n\\n    .. code-block:: yaml\\n\\n        network_foo:\\n          docker_network.absent\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if network is None:\n        ret['result'] = True\n        ret['comment'] = f\"Network '{name}' already absent\"\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = f\"Network '{name}' will be removed\"\n        return ret\n    return _remove_network(network)",
            "def absent(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Ensure that a network is absent.\\n\\n    name\\n        Name of the network\\n\\n    Usage Example:\\n\\n    .. code-block:: yaml\\n\\n        network_foo:\\n          docker_network.absent\\n    '\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n    try:\n        network = __salt__['docker.inspect_network'](name)\n    except CommandExecutionError as exc:\n        msg = exc.__str__()\n        if '404' in msg:\n            network = None\n        else:\n            ret['comment'] = msg\n            return ret\n    if network is None:\n        ret['result'] = True\n        ret['comment'] = f\"Network '{name}' already absent\"\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = f\"Network '{name}' will be removed\"\n        return ret\n    return _remove_network(network)"
        ]
    },
    {
        "func_name": "_remove_network",
        "original": "def _remove_network(network):\n    \"\"\"\n    Remove network, including all connected containers\n    \"\"\"\n    ret = {'name': network['Name'], 'changes': {}, 'result': False, 'comment': ''}\n    errors = []\n    for cid in network['Containers']:\n        try:\n            cinfo = __salt__['docker.inspect_container'](cid)\n        except CommandExecutionError:\n            cname = cid\n        else:\n            cname = cinfo.get('Name', '').lstrip('/')\n        try:\n            __salt__['docker.disconnect_container_from_network'](cid, network['Name'])\n        except CommandExecutionError as exc:\n            errors = f\"Failed to disconnect container '{cname}' : {exc}\"\n        else:\n            ret['changes'].setdefault('disconnected', []).append(cname)\n    if errors:\n        ret['comment'] = '\\n'.join(errors)\n        return ret\n    try:\n        __salt__['docker.remove_network'](network['Name'])\n    except CommandExecutionError as exc:\n        ret['comment'] = f'Failed to remove network: {exc}'\n    else:\n        ret['changes']['removed'] = True\n        ret['result'] = True\n        ret['comment'] = \"Removed network '{}'\".format(network['Name'])\n    return ret",
        "mutated": [
            "def _remove_network(network):\n    if False:\n        i = 10\n    '\\n    Remove network, including all connected containers\\n    '\n    ret = {'name': network['Name'], 'changes': {}, 'result': False, 'comment': ''}\n    errors = []\n    for cid in network['Containers']:\n        try:\n            cinfo = __salt__['docker.inspect_container'](cid)\n        except CommandExecutionError:\n            cname = cid\n        else:\n            cname = cinfo.get('Name', '').lstrip('/')\n        try:\n            __salt__['docker.disconnect_container_from_network'](cid, network['Name'])\n        except CommandExecutionError as exc:\n            errors = f\"Failed to disconnect container '{cname}' : {exc}\"\n        else:\n            ret['changes'].setdefault('disconnected', []).append(cname)\n    if errors:\n        ret['comment'] = '\\n'.join(errors)\n        return ret\n    try:\n        __salt__['docker.remove_network'](network['Name'])\n    except CommandExecutionError as exc:\n        ret['comment'] = f'Failed to remove network: {exc}'\n    else:\n        ret['changes']['removed'] = True\n        ret['result'] = True\n        ret['comment'] = \"Removed network '{}'\".format(network['Name'])\n    return ret",
            "def _remove_network(network):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Remove network, including all connected containers\\n    '\n    ret = {'name': network['Name'], 'changes': {}, 'result': False, 'comment': ''}\n    errors = []\n    for cid in network['Containers']:\n        try:\n            cinfo = __salt__['docker.inspect_container'](cid)\n        except CommandExecutionError:\n            cname = cid\n        else:\n            cname = cinfo.get('Name', '').lstrip('/')\n        try:\n            __salt__['docker.disconnect_container_from_network'](cid, network['Name'])\n        except CommandExecutionError as exc:\n            errors = f\"Failed to disconnect container '{cname}' : {exc}\"\n        else:\n            ret['changes'].setdefault('disconnected', []).append(cname)\n    if errors:\n        ret['comment'] = '\\n'.join(errors)\n        return ret\n    try:\n        __salt__['docker.remove_network'](network['Name'])\n    except CommandExecutionError as exc:\n        ret['comment'] = f'Failed to remove network: {exc}'\n    else:\n        ret['changes']['removed'] = True\n        ret['result'] = True\n        ret['comment'] = \"Removed network '{}'\".format(network['Name'])\n    return ret",
            "def _remove_network(network):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Remove network, including all connected containers\\n    '\n    ret = {'name': network['Name'], 'changes': {}, 'result': False, 'comment': ''}\n    errors = []\n    for cid in network['Containers']:\n        try:\n            cinfo = __salt__['docker.inspect_container'](cid)\n        except CommandExecutionError:\n            cname = cid\n        else:\n            cname = cinfo.get('Name', '').lstrip('/')\n        try:\n            __salt__['docker.disconnect_container_from_network'](cid, network['Name'])\n        except CommandExecutionError as exc:\n            errors = f\"Failed to disconnect container '{cname}' : {exc}\"\n        else:\n            ret['changes'].setdefault('disconnected', []).append(cname)\n    if errors:\n        ret['comment'] = '\\n'.join(errors)\n        return ret\n    try:\n        __salt__['docker.remove_network'](network['Name'])\n    except CommandExecutionError as exc:\n        ret['comment'] = f'Failed to remove network: {exc}'\n    else:\n        ret['changes']['removed'] = True\n        ret['result'] = True\n        ret['comment'] = \"Removed network '{}'\".format(network['Name'])\n    return ret",
            "def _remove_network(network):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Remove network, including all connected containers\\n    '\n    ret = {'name': network['Name'], 'changes': {}, 'result': False, 'comment': ''}\n    errors = []\n    for cid in network['Containers']:\n        try:\n            cinfo = __salt__['docker.inspect_container'](cid)\n        except CommandExecutionError:\n            cname = cid\n        else:\n            cname = cinfo.get('Name', '').lstrip('/')\n        try:\n            __salt__['docker.disconnect_container_from_network'](cid, network['Name'])\n        except CommandExecutionError as exc:\n            errors = f\"Failed to disconnect container '{cname}' : {exc}\"\n        else:\n            ret['changes'].setdefault('disconnected', []).append(cname)\n    if errors:\n        ret['comment'] = '\\n'.join(errors)\n        return ret\n    try:\n        __salt__['docker.remove_network'](network['Name'])\n    except CommandExecutionError as exc:\n        ret['comment'] = f'Failed to remove network: {exc}'\n    else:\n        ret['changes']['removed'] = True\n        ret['result'] = True\n        ret['comment'] = \"Removed network '{}'\".format(network['Name'])\n    return ret",
            "def _remove_network(network):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Remove network, including all connected containers\\n    '\n    ret = {'name': network['Name'], 'changes': {}, 'result': False, 'comment': ''}\n    errors = []\n    for cid in network['Containers']:\n        try:\n            cinfo = __salt__['docker.inspect_container'](cid)\n        except CommandExecutionError:\n            cname = cid\n        else:\n            cname = cinfo.get('Name', '').lstrip('/')\n        try:\n            __salt__['docker.disconnect_container_from_network'](cid, network['Name'])\n        except CommandExecutionError as exc:\n            errors = f\"Failed to disconnect container '{cname}' : {exc}\"\n        else:\n            ret['changes'].setdefault('disconnected', []).append(cname)\n    if errors:\n        ret['comment'] = '\\n'.join(errors)\n        return ret\n    try:\n        __salt__['docker.remove_network'](network['Name'])\n    except CommandExecutionError as exc:\n        ret['comment'] = f'Failed to remove network: {exc}'\n    else:\n        ret['changes']['removed'] = True\n        ret['result'] = True\n        ret['comment'] = \"Removed network '{}'\".format(network['Name'])\n    return ret"
        ]
    }
]