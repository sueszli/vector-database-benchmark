[
    {
        "func_name": "convert",
        "original": "def convert(args: Namespace) -> None:\n    \"\"\"\n    args must hold srcdir and targetdir (FS-like objects),\n    plus any additional configuration options.\n    \"\"\"\n    convert_metadata(args)\n    del args.palettes\n    info(f'asset conversion complete; asset version: {ASSET_VERSION}')",
        "mutated": [
            "def convert(args: Namespace) -> None:\n    if False:\n        i = 10\n    '\\n    args must hold srcdir and targetdir (FS-like objects),\\n    plus any additional configuration options.\\n    '\n    convert_metadata(args)\n    del args.palettes\n    info(f'asset conversion complete; asset version: {ASSET_VERSION}')",
            "def convert(args: Namespace) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    args must hold srcdir and targetdir (FS-like objects),\\n    plus any additional configuration options.\\n    '\n    convert_metadata(args)\n    del args.palettes\n    info(f'asset conversion complete; asset version: {ASSET_VERSION}')",
            "def convert(args: Namespace) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    args must hold srcdir and targetdir (FS-like objects),\\n    plus any additional configuration options.\\n    '\n    convert_metadata(args)\n    del args.palettes\n    info(f'asset conversion complete; asset version: {ASSET_VERSION}')",
            "def convert(args: Namespace) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    args must hold srcdir and targetdir (FS-like objects),\\n    plus any additional configuration options.\\n    '\n    convert_metadata(args)\n    del args.palettes\n    info(f'asset conversion complete; asset version: {ASSET_VERSION}')",
            "def convert(args: Namespace) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    args must hold srcdir and targetdir (FS-like objects),\\n    plus any additional configuration options.\\n    '\n    convert_metadata(args)\n    del args.palettes\n    info(f'asset conversion complete; asset version: {ASSET_VERSION}')"
        ]
    },
    {
        "func_name": "convert_metadata",
        "original": "def convert_metadata(args: Namespace) -> None:\n    \"\"\"\n    Converts the metadata part.\n    \"\"\"\n    if not args.flag('no_metadata'):\n        info('converting metadata')\n    args.converter = get_converter(args.game_version)\n    palettes = get_palettes(args.srcdir, args.game_version)\n    args.palettes = palettes\n    if args.flag('no_metadata'):\n        return\n    gamedata_path = args.targetdir.joinpath('gamedata')\n    if gamedata_path.exists():\n        gamedata_path.removerecursive()\n    read_start = timeit.default_timer()\n    debug_gamedata_format(args.debugdir, args.debug_info, args.game_version)\n    gamespec = get_gamespec(args.srcdir, args.game_version, not args.flag('no_pickle_cache'))\n    if args.game_version.edition.game_id == 'SWGB':\n        args.blend_mode_count = gamespec[0]['blend_mode_count_swgb'].value\n    else:\n        args.blend_mode_count = None\n    string_resources = get_string_resources(args)\n    debug_string_resources(args.debugdir, args.debug_info, string_resources)\n    existing_graphics = get_existing_graphics(args)\n    debug_registered_graphics(args.debugdir, args.debug_info, existing_graphics)\n    read_end = timeit.default_timer()\n    conversion_start = timeit.default_timer()\n    modpacks = args.converter.convert(gamespec, args, string_resources, existing_graphics)\n    conversion_end = timeit.default_timer()\n    export_start = timeit.default_timer()\n    for modpack in modpacks:\n        ModpackExporter.export(modpack, args)\n        debug_modpack(args.debugdir, args.debug_info, modpack)\n    export_end = timeit.default_timer()\n    stages_time = {'read': read_end - read_start, 'convert': conversion_end - conversion_start, 'export': export_end - export_start}\n    debug_execution_time(args.debugdir, args.debug_info, stages_time)\n    if args.flag('gen_extra_files'):\n        dbg('generating extra files for visualization')",
        "mutated": [
            "def convert_metadata(args: Namespace) -> None:\n    if False:\n        i = 10\n    '\\n    Converts the metadata part.\\n    '\n    if not args.flag('no_metadata'):\n        info('converting metadata')\n    args.converter = get_converter(args.game_version)\n    palettes = get_palettes(args.srcdir, args.game_version)\n    args.palettes = palettes\n    if args.flag('no_metadata'):\n        return\n    gamedata_path = args.targetdir.joinpath('gamedata')\n    if gamedata_path.exists():\n        gamedata_path.removerecursive()\n    read_start = timeit.default_timer()\n    debug_gamedata_format(args.debugdir, args.debug_info, args.game_version)\n    gamespec = get_gamespec(args.srcdir, args.game_version, not args.flag('no_pickle_cache'))\n    if args.game_version.edition.game_id == 'SWGB':\n        args.blend_mode_count = gamespec[0]['blend_mode_count_swgb'].value\n    else:\n        args.blend_mode_count = None\n    string_resources = get_string_resources(args)\n    debug_string_resources(args.debugdir, args.debug_info, string_resources)\n    existing_graphics = get_existing_graphics(args)\n    debug_registered_graphics(args.debugdir, args.debug_info, existing_graphics)\n    read_end = timeit.default_timer()\n    conversion_start = timeit.default_timer()\n    modpacks = args.converter.convert(gamespec, args, string_resources, existing_graphics)\n    conversion_end = timeit.default_timer()\n    export_start = timeit.default_timer()\n    for modpack in modpacks:\n        ModpackExporter.export(modpack, args)\n        debug_modpack(args.debugdir, args.debug_info, modpack)\n    export_end = timeit.default_timer()\n    stages_time = {'read': read_end - read_start, 'convert': conversion_end - conversion_start, 'export': export_end - export_start}\n    debug_execution_time(args.debugdir, args.debug_info, stages_time)\n    if args.flag('gen_extra_files'):\n        dbg('generating extra files for visualization')",
            "def convert_metadata(args: Namespace) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Converts the metadata part.\\n    '\n    if not args.flag('no_metadata'):\n        info('converting metadata')\n    args.converter = get_converter(args.game_version)\n    palettes = get_palettes(args.srcdir, args.game_version)\n    args.palettes = palettes\n    if args.flag('no_metadata'):\n        return\n    gamedata_path = args.targetdir.joinpath('gamedata')\n    if gamedata_path.exists():\n        gamedata_path.removerecursive()\n    read_start = timeit.default_timer()\n    debug_gamedata_format(args.debugdir, args.debug_info, args.game_version)\n    gamespec = get_gamespec(args.srcdir, args.game_version, not args.flag('no_pickle_cache'))\n    if args.game_version.edition.game_id == 'SWGB':\n        args.blend_mode_count = gamespec[0]['blend_mode_count_swgb'].value\n    else:\n        args.blend_mode_count = None\n    string_resources = get_string_resources(args)\n    debug_string_resources(args.debugdir, args.debug_info, string_resources)\n    existing_graphics = get_existing_graphics(args)\n    debug_registered_graphics(args.debugdir, args.debug_info, existing_graphics)\n    read_end = timeit.default_timer()\n    conversion_start = timeit.default_timer()\n    modpacks = args.converter.convert(gamespec, args, string_resources, existing_graphics)\n    conversion_end = timeit.default_timer()\n    export_start = timeit.default_timer()\n    for modpack in modpacks:\n        ModpackExporter.export(modpack, args)\n        debug_modpack(args.debugdir, args.debug_info, modpack)\n    export_end = timeit.default_timer()\n    stages_time = {'read': read_end - read_start, 'convert': conversion_end - conversion_start, 'export': export_end - export_start}\n    debug_execution_time(args.debugdir, args.debug_info, stages_time)\n    if args.flag('gen_extra_files'):\n        dbg('generating extra files for visualization')",
            "def convert_metadata(args: Namespace) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Converts the metadata part.\\n    '\n    if not args.flag('no_metadata'):\n        info('converting metadata')\n    args.converter = get_converter(args.game_version)\n    palettes = get_palettes(args.srcdir, args.game_version)\n    args.palettes = palettes\n    if args.flag('no_metadata'):\n        return\n    gamedata_path = args.targetdir.joinpath('gamedata')\n    if gamedata_path.exists():\n        gamedata_path.removerecursive()\n    read_start = timeit.default_timer()\n    debug_gamedata_format(args.debugdir, args.debug_info, args.game_version)\n    gamespec = get_gamespec(args.srcdir, args.game_version, not args.flag('no_pickle_cache'))\n    if args.game_version.edition.game_id == 'SWGB':\n        args.blend_mode_count = gamespec[0]['blend_mode_count_swgb'].value\n    else:\n        args.blend_mode_count = None\n    string_resources = get_string_resources(args)\n    debug_string_resources(args.debugdir, args.debug_info, string_resources)\n    existing_graphics = get_existing_graphics(args)\n    debug_registered_graphics(args.debugdir, args.debug_info, existing_graphics)\n    read_end = timeit.default_timer()\n    conversion_start = timeit.default_timer()\n    modpacks = args.converter.convert(gamespec, args, string_resources, existing_graphics)\n    conversion_end = timeit.default_timer()\n    export_start = timeit.default_timer()\n    for modpack in modpacks:\n        ModpackExporter.export(modpack, args)\n        debug_modpack(args.debugdir, args.debug_info, modpack)\n    export_end = timeit.default_timer()\n    stages_time = {'read': read_end - read_start, 'convert': conversion_end - conversion_start, 'export': export_end - export_start}\n    debug_execution_time(args.debugdir, args.debug_info, stages_time)\n    if args.flag('gen_extra_files'):\n        dbg('generating extra files for visualization')",
            "def convert_metadata(args: Namespace) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Converts the metadata part.\\n    '\n    if not args.flag('no_metadata'):\n        info('converting metadata')\n    args.converter = get_converter(args.game_version)\n    palettes = get_palettes(args.srcdir, args.game_version)\n    args.palettes = palettes\n    if args.flag('no_metadata'):\n        return\n    gamedata_path = args.targetdir.joinpath('gamedata')\n    if gamedata_path.exists():\n        gamedata_path.removerecursive()\n    read_start = timeit.default_timer()\n    debug_gamedata_format(args.debugdir, args.debug_info, args.game_version)\n    gamespec = get_gamespec(args.srcdir, args.game_version, not args.flag('no_pickle_cache'))\n    if args.game_version.edition.game_id == 'SWGB':\n        args.blend_mode_count = gamespec[0]['blend_mode_count_swgb'].value\n    else:\n        args.blend_mode_count = None\n    string_resources = get_string_resources(args)\n    debug_string_resources(args.debugdir, args.debug_info, string_resources)\n    existing_graphics = get_existing_graphics(args)\n    debug_registered_graphics(args.debugdir, args.debug_info, existing_graphics)\n    read_end = timeit.default_timer()\n    conversion_start = timeit.default_timer()\n    modpacks = args.converter.convert(gamespec, args, string_resources, existing_graphics)\n    conversion_end = timeit.default_timer()\n    export_start = timeit.default_timer()\n    for modpack in modpacks:\n        ModpackExporter.export(modpack, args)\n        debug_modpack(args.debugdir, args.debug_info, modpack)\n    export_end = timeit.default_timer()\n    stages_time = {'read': read_end - read_start, 'convert': conversion_end - conversion_start, 'export': export_end - export_start}\n    debug_execution_time(args.debugdir, args.debug_info, stages_time)\n    if args.flag('gen_extra_files'):\n        dbg('generating extra files for visualization')",
            "def convert_metadata(args: Namespace) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Converts the metadata part.\\n    '\n    if not args.flag('no_metadata'):\n        info('converting metadata')\n    args.converter = get_converter(args.game_version)\n    palettes = get_palettes(args.srcdir, args.game_version)\n    args.palettes = palettes\n    if args.flag('no_metadata'):\n        return\n    gamedata_path = args.targetdir.joinpath('gamedata')\n    if gamedata_path.exists():\n        gamedata_path.removerecursive()\n    read_start = timeit.default_timer()\n    debug_gamedata_format(args.debugdir, args.debug_info, args.game_version)\n    gamespec = get_gamespec(args.srcdir, args.game_version, not args.flag('no_pickle_cache'))\n    if args.game_version.edition.game_id == 'SWGB':\n        args.blend_mode_count = gamespec[0]['blend_mode_count_swgb'].value\n    else:\n        args.blend_mode_count = None\n    string_resources = get_string_resources(args)\n    debug_string_resources(args.debugdir, args.debug_info, string_resources)\n    existing_graphics = get_existing_graphics(args)\n    debug_registered_graphics(args.debugdir, args.debug_info, existing_graphics)\n    read_end = timeit.default_timer()\n    conversion_start = timeit.default_timer()\n    modpacks = args.converter.convert(gamespec, args, string_resources, existing_graphics)\n    conversion_end = timeit.default_timer()\n    export_start = timeit.default_timer()\n    for modpack in modpacks:\n        ModpackExporter.export(modpack, args)\n        debug_modpack(args.debugdir, args.debug_info, modpack)\n    export_end = timeit.default_timer()\n    stages_time = {'read': read_end - read_start, 'convert': conversion_end - conversion_start, 'export': export_end - export_start}\n    debug_execution_time(args.debugdir, args.debug_info, stages_time)\n    if args.flag('gen_extra_files'):\n        dbg('generating extra files for visualization')"
        ]
    },
    {
        "func_name": "get_converter",
        "original": "def get_converter(game_version: GameVersion):\n    \"\"\"\n    Returns the converter for the specified game version.\n    \"\"\"\n    game_edition = game_version.edition\n    game_expansions = game_version.expansions\n    if game_edition.game_id == 'ROR':\n        from ..processor.conversion.ror.processor import RoRProcessor\n        return RoRProcessor\n    if game_edition.game_id == 'AOE1DE':\n        from ..processor.conversion.de1.processor import DE1Processor\n        return DE1Processor\n    if game_edition.game_id == 'AOC':\n        from ..processor.conversion.aoc.processor import AoCProcessor\n        return AoCProcessor\n    if game_edition.game_id == 'AOCDEMO':\n        game_edition.game_id = 'AOC'\n        from ..processor.conversion.aoc_demo.processor import DemoProcessor\n        return DemoProcessor\n    if game_edition.game_id == 'HDEDITION':\n        from ..processor.conversion.hd.processor import HDProcessor\n        return HDProcessor\n    if game_edition.game_id == 'AOE2DE':\n        from ..processor.conversion.de2.processor import DE2Processor\n        return DE2Processor\n    if game_edition.game_id == 'SWGB':\n        if 'SWGB_CC' in [expansion.game_id for expansion in game_expansions]:\n            from ..processor.conversion.swgbcc.processor import SWGBCCProcessor\n            return SWGBCCProcessor\n    raise RuntimeError(f'no valid converter found for game edition {game_edition.edition_name}')",
        "mutated": [
            "def get_converter(game_version: GameVersion):\n    if False:\n        i = 10\n    '\\n    Returns the converter for the specified game version.\\n    '\n    game_edition = game_version.edition\n    game_expansions = game_version.expansions\n    if game_edition.game_id == 'ROR':\n        from ..processor.conversion.ror.processor import RoRProcessor\n        return RoRProcessor\n    if game_edition.game_id == 'AOE1DE':\n        from ..processor.conversion.de1.processor import DE1Processor\n        return DE1Processor\n    if game_edition.game_id == 'AOC':\n        from ..processor.conversion.aoc.processor import AoCProcessor\n        return AoCProcessor\n    if game_edition.game_id == 'AOCDEMO':\n        game_edition.game_id = 'AOC'\n        from ..processor.conversion.aoc_demo.processor import DemoProcessor\n        return DemoProcessor\n    if game_edition.game_id == 'HDEDITION':\n        from ..processor.conversion.hd.processor import HDProcessor\n        return HDProcessor\n    if game_edition.game_id == 'AOE2DE':\n        from ..processor.conversion.de2.processor import DE2Processor\n        return DE2Processor\n    if game_edition.game_id == 'SWGB':\n        if 'SWGB_CC' in [expansion.game_id for expansion in game_expansions]:\n            from ..processor.conversion.swgbcc.processor import SWGBCCProcessor\n            return SWGBCCProcessor\n    raise RuntimeError(f'no valid converter found for game edition {game_edition.edition_name}')",
            "def get_converter(game_version: GameVersion):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the converter for the specified game version.\\n    '\n    game_edition = game_version.edition\n    game_expansions = game_version.expansions\n    if game_edition.game_id == 'ROR':\n        from ..processor.conversion.ror.processor import RoRProcessor\n        return RoRProcessor\n    if game_edition.game_id == 'AOE1DE':\n        from ..processor.conversion.de1.processor import DE1Processor\n        return DE1Processor\n    if game_edition.game_id == 'AOC':\n        from ..processor.conversion.aoc.processor import AoCProcessor\n        return AoCProcessor\n    if game_edition.game_id == 'AOCDEMO':\n        game_edition.game_id = 'AOC'\n        from ..processor.conversion.aoc_demo.processor import DemoProcessor\n        return DemoProcessor\n    if game_edition.game_id == 'HDEDITION':\n        from ..processor.conversion.hd.processor import HDProcessor\n        return HDProcessor\n    if game_edition.game_id == 'AOE2DE':\n        from ..processor.conversion.de2.processor import DE2Processor\n        return DE2Processor\n    if game_edition.game_id == 'SWGB':\n        if 'SWGB_CC' in [expansion.game_id for expansion in game_expansions]:\n            from ..processor.conversion.swgbcc.processor import SWGBCCProcessor\n            return SWGBCCProcessor\n    raise RuntimeError(f'no valid converter found for game edition {game_edition.edition_name}')",
            "def get_converter(game_version: GameVersion):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the converter for the specified game version.\\n    '\n    game_edition = game_version.edition\n    game_expansions = game_version.expansions\n    if game_edition.game_id == 'ROR':\n        from ..processor.conversion.ror.processor import RoRProcessor\n        return RoRProcessor\n    if game_edition.game_id == 'AOE1DE':\n        from ..processor.conversion.de1.processor import DE1Processor\n        return DE1Processor\n    if game_edition.game_id == 'AOC':\n        from ..processor.conversion.aoc.processor import AoCProcessor\n        return AoCProcessor\n    if game_edition.game_id == 'AOCDEMO':\n        game_edition.game_id = 'AOC'\n        from ..processor.conversion.aoc_demo.processor import DemoProcessor\n        return DemoProcessor\n    if game_edition.game_id == 'HDEDITION':\n        from ..processor.conversion.hd.processor import HDProcessor\n        return HDProcessor\n    if game_edition.game_id == 'AOE2DE':\n        from ..processor.conversion.de2.processor import DE2Processor\n        return DE2Processor\n    if game_edition.game_id == 'SWGB':\n        if 'SWGB_CC' in [expansion.game_id for expansion in game_expansions]:\n            from ..processor.conversion.swgbcc.processor import SWGBCCProcessor\n            return SWGBCCProcessor\n    raise RuntimeError(f'no valid converter found for game edition {game_edition.edition_name}')",
            "def get_converter(game_version: GameVersion):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the converter for the specified game version.\\n    '\n    game_edition = game_version.edition\n    game_expansions = game_version.expansions\n    if game_edition.game_id == 'ROR':\n        from ..processor.conversion.ror.processor import RoRProcessor\n        return RoRProcessor\n    if game_edition.game_id == 'AOE1DE':\n        from ..processor.conversion.de1.processor import DE1Processor\n        return DE1Processor\n    if game_edition.game_id == 'AOC':\n        from ..processor.conversion.aoc.processor import AoCProcessor\n        return AoCProcessor\n    if game_edition.game_id == 'AOCDEMO':\n        game_edition.game_id = 'AOC'\n        from ..processor.conversion.aoc_demo.processor import DemoProcessor\n        return DemoProcessor\n    if game_edition.game_id == 'HDEDITION':\n        from ..processor.conversion.hd.processor import HDProcessor\n        return HDProcessor\n    if game_edition.game_id == 'AOE2DE':\n        from ..processor.conversion.de2.processor import DE2Processor\n        return DE2Processor\n    if game_edition.game_id == 'SWGB':\n        if 'SWGB_CC' in [expansion.game_id for expansion in game_expansions]:\n            from ..processor.conversion.swgbcc.processor import SWGBCCProcessor\n            return SWGBCCProcessor\n    raise RuntimeError(f'no valid converter found for game edition {game_edition.edition_name}')",
            "def get_converter(game_version: GameVersion):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the converter for the specified game version.\\n    '\n    game_edition = game_version.edition\n    game_expansions = game_version.expansions\n    if game_edition.game_id == 'ROR':\n        from ..processor.conversion.ror.processor import RoRProcessor\n        return RoRProcessor\n    if game_edition.game_id == 'AOE1DE':\n        from ..processor.conversion.de1.processor import DE1Processor\n        return DE1Processor\n    if game_edition.game_id == 'AOC':\n        from ..processor.conversion.aoc.processor import AoCProcessor\n        return AoCProcessor\n    if game_edition.game_id == 'AOCDEMO':\n        game_edition.game_id = 'AOC'\n        from ..processor.conversion.aoc_demo.processor import DemoProcessor\n        return DemoProcessor\n    if game_edition.game_id == 'HDEDITION':\n        from ..processor.conversion.hd.processor import HDProcessor\n        return HDProcessor\n    if game_edition.game_id == 'AOE2DE':\n        from ..processor.conversion.de2.processor import DE2Processor\n        return DE2Processor\n    if game_edition.game_id == 'SWGB':\n        if 'SWGB_CC' in [expansion.game_id for expansion in game_expansions]:\n            from ..processor.conversion.swgbcc.processor import SWGBCCProcessor\n            return SWGBCCProcessor\n    raise RuntimeError(f'no valid converter found for game edition {game_edition.edition_name}')"
        ]
    }
]