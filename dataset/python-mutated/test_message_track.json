[
    {
        "func_name": "_track_subtype",
        "original": "@api.multi\ndef _track_subtype(self, init_values):\n    if 'public' in init_values and self.public == 'private':\n        return 'mail.mt_private'\n    elif 'name' in init_values and self.name == 'supername':\n        return 'mail.mt_name_supername'\n    elif 'group_public_id' in init_values and self.group_public_id:\n        return 'mail.mt_group_public_set'\n    elif 'group_public_id' in init_values and (not self.group_public_id):\n        return 'mail.mt_group_public_unset'\n    return False",
        "mutated": [
            "@api.multi\ndef _track_subtype(self, init_values):\n    if False:\n        i = 10\n    if 'public' in init_values and self.public == 'private':\n        return 'mail.mt_private'\n    elif 'name' in init_values and self.name == 'supername':\n        return 'mail.mt_name_supername'\n    elif 'group_public_id' in init_values and self.group_public_id:\n        return 'mail.mt_group_public_set'\n    elif 'group_public_id' in init_values and (not self.group_public_id):\n        return 'mail.mt_group_public_unset'\n    return False",
            "@api.multi\ndef _track_subtype(self, init_values):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'public' in init_values and self.public == 'private':\n        return 'mail.mt_private'\n    elif 'name' in init_values and self.name == 'supername':\n        return 'mail.mt_name_supername'\n    elif 'group_public_id' in init_values and self.group_public_id:\n        return 'mail.mt_group_public_set'\n    elif 'group_public_id' in init_values and (not self.group_public_id):\n        return 'mail.mt_group_public_unset'\n    return False",
            "@api.multi\ndef _track_subtype(self, init_values):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'public' in init_values and self.public == 'private':\n        return 'mail.mt_private'\n    elif 'name' in init_values and self.name == 'supername':\n        return 'mail.mt_name_supername'\n    elif 'group_public_id' in init_values and self.group_public_id:\n        return 'mail.mt_group_public_set'\n    elif 'group_public_id' in init_values and (not self.group_public_id):\n        return 'mail.mt_group_public_unset'\n    return False",
            "@api.multi\ndef _track_subtype(self, init_values):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'public' in init_values and self.public == 'private':\n        return 'mail.mt_private'\n    elif 'name' in init_values and self.name == 'supername':\n        return 'mail.mt_name_supername'\n    elif 'group_public_id' in init_values and self.group_public_id:\n        return 'mail.mt_group_public_set'\n    elif 'group_public_id' in init_values and (not self.group_public_id):\n        return 'mail.mt_group_public_unset'\n    return False",
            "@api.multi\ndef _track_subtype(self, init_values):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'public' in init_values and self.public == 'private':\n        return 'mail.mt_private'\n    elif 'name' in init_values and self.name == 'supername':\n        return 'mail.mt_name_supername'\n    elif 'group_public_id' in init_values and self.group_public_id:\n        return 'mail.mt_group_public_set'\n    elif 'group_public_id' in init_values and (not self.group_public_id):\n        return 'mail.mt_group_public_unset'\n    return False"
        ]
    },
    {
        "func_name": "cleanup",
        "original": "@self.addCleanup\ndef cleanup():\n    for key in visibility:\n        del getattr(cls, key).track_visibility",
        "mutated": [
            "@self.addCleanup\ndef cleanup():\n    if False:\n        i = 10\n    for key in visibility:\n        del getattr(cls, key).track_visibility",
            "@self.addCleanup\ndef cleanup():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for key in visibility:\n        del getattr(cls, key).track_visibility",
            "@self.addCleanup\ndef cleanup():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for key in visibility:\n        del getattr(cls, key).track_visibility",
            "@self.addCleanup\ndef cleanup():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for key in visibility:\n        del getattr(cls, key).track_visibility",
            "@self.addCleanup\ndef cleanup():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for key in visibility:\n        del getattr(cls, key).track_visibility"
        ]
    },
    {
        "func_name": "test_message_track",
        "original": "def test_message_track(self):\n    \"\"\" Testing auto tracking of fields. Warning, it has not be cleaned and\n        should probably be. \"\"\"\n    Subtype = self.env['mail.message.subtype']\n    Data = self.env['ir.model.data']\n    note_subtype = self.env.ref('mail.mt_note')\n    group_system = self.env.ref('base.group_system')\n    group_user = self.env.ref('base.group_user')\n    self.group_pigs.write({'channel_partner_ids': [(4, self.user_employee.partner_id.id)]})\n    mt_private = Subtype.create({'name': 'private', 'description': 'Public field set to private'})\n    Data.create({'name': 'mt_private', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_private.id})\n    mt_name_supername = Subtype.create({'name': 'name_supername', 'description': 'Name field set to supername'})\n    Data.create({'name': 'mt_name_supername', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_name_supername.id})\n    mt_group_public_set = Subtype.create({'name': 'group_public_set', 'description': 'Group_public field set'})\n    Data.create({'name': 'mt_group_public_set', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_set.id})\n    mt_group_public_unset = Subtype.create({'name': 'group_public_unset', 'description': 'Group_public field unset'})\n    Data.create({'name': 'mt_group_public_unset', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_unset.id})\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'public' in init_values and self.public == 'private':\n            return 'mail.mt_private'\n        elif 'name' in init_values and self.name == 'supername':\n            return 'mail.mt_name_supername'\n        elif 'group_public_id' in init_values and self.group_public_id:\n            return 'mail.mt_group_public_set'\n        elif 'group_public_id' in init_values and (not self.group_public_id):\n            return 'mail.mt_group_public_unset'\n        return False\n    self.registry('mail.channel')._patch_method('_track_subtype', _track_subtype)\n    visibility = {'public': 'onchange', 'name': 'always', 'group_public_id': 'onchange'}\n    cls = type(self.env['mail.channel'])\n    for key in visibility:\n        self.assertFalse(hasattr(getattr(cls, key), 'track_visibility'))\n        getattr(cls, key).track_visibility = visibility[key]\n\n    @self.addCleanup\n    def cleanup():\n        for key in visibility:\n            del getattr(cls, key).track_visibility\n    self.group_pigs.sudo(self.user_employee).write({'name': 'my_name'})\n    self.assertEqual(len(self.group_pigs.message_ids), 1)\n    last_msg = self.group_pigs.message_ids[-1]\n    self.assertEqual(last_msg.subtype_id, note_subtype)\n    self.assertEqual(len(last_msg.tracking_value_ids), 1)\n    self.assertEqual(last_msg.tracking_value_ids.field, 'name')\n    self.assertEqual(last_msg.tracking_value_ids.field_desc, 'Name')\n    self.assertEqual(last_msg.tracking_value_ids.old_value_char, 'Pigs')\n    self.assertEqual(last_msg.tracking_value_ids.new_value_char, 'my_name')\n    self.group_pigs.sudo(self.user_employee).write({'name': 'supername', 'public': 'private'})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids.ids), 2)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_private)\n    self.assertEqual(len(last_msg.tracking_value_ids), 2)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['name', 'public']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Name', 'Privacy']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set(['my_name', 'Selected group of users']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set(['supername', 'Invited people only']))\n    self.group_pigs.sudo(self.user_employee).write({'public': 'public', 'group_public_id': group_system.id})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids), 3)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_group_public_set)\n    self.assertEqual(len(last_msg.tracking_value_ids), 3)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['group_public_id', 'public', 'name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Authorized Group', 'Privacy', 'Name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set([group_user.name_get()[0][1], 'Invited people only', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set([group_system.name_get()[0][1], 'Everyone', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_integer')), set([0, group_user.id]))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_integer')), set([0, group_system.id]))",
        "mutated": [
            "def test_message_track(self):\n    if False:\n        i = 10\n    ' Testing auto tracking of fields. Warning, it has not be cleaned and\\n        should probably be. '\n    Subtype = self.env['mail.message.subtype']\n    Data = self.env['ir.model.data']\n    note_subtype = self.env.ref('mail.mt_note')\n    group_system = self.env.ref('base.group_system')\n    group_user = self.env.ref('base.group_user')\n    self.group_pigs.write({'channel_partner_ids': [(4, self.user_employee.partner_id.id)]})\n    mt_private = Subtype.create({'name': 'private', 'description': 'Public field set to private'})\n    Data.create({'name': 'mt_private', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_private.id})\n    mt_name_supername = Subtype.create({'name': 'name_supername', 'description': 'Name field set to supername'})\n    Data.create({'name': 'mt_name_supername', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_name_supername.id})\n    mt_group_public_set = Subtype.create({'name': 'group_public_set', 'description': 'Group_public field set'})\n    Data.create({'name': 'mt_group_public_set', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_set.id})\n    mt_group_public_unset = Subtype.create({'name': 'group_public_unset', 'description': 'Group_public field unset'})\n    Data.create({'name': 'mt_group_public_unset', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_unset.id})\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'public' in init_values and self.public == 'private':\n            return 'mail.mt_private'\n        elif 'name' in init_values and self.name == 'supername':\n            return 'mail.mt_name_supername'\n        elif 'group_public_id' in init_values and self.group_public_id:\n            return 'mail.mt_group_public_set'\n        elif 'group_public_id' in init_values and (not self.group_public_id):\n            return 'mail.mt_group_public_unset'\n        return False\n    self.registry('mail.channel')._patch_method('_track_subtype', _track_subtype)\n    visibility = {'public': 'onchange', 'name': 'always', 'group_public_id': 'onchange'}\n    cls = type(self.env['mail.channel'])\n    for key in visibility:\n        self.assertFalse(hasattr(getattr(cls, key), 'track_visibility'))\n        getattr(cls, key).track_visibility = visibility[key]\n\n    @self.addCleanup\n    def cleanup():\n        for key in visibility:\n            del getattr(cls, key).track_visibility\n    self.group_pigs.sudo(self.user_employee).write({'name': 'my_name'})\n    self.assertEqual(len(self.group_pigs.message_ids), 1)\n    last_msg = self.group_pigs.message_ids[-1]\n    self.assertEqual(last_msg.subtype_id, note_subtype)\n    self.assertEqual(len(last_msg.tracking_value_ids), 1)\n    self.assertEqual(last_msg.tracking_value_ids.field, 'name')\n    self.assertEqual(last_msg.tracking_value_ids.field_desc, 'Name')\n    self.assertEqual(last_msg.tracking_value_ids.old_value_char, 'Pigs')\n    self.assertEqual(last_msg.tracking_value_ids.new_value_char, 'my_name')\n    self.group_pigs.sudo(self.user_employee).write({'name': 'supername', 'public': 'private'})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids.ids), 2)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_private)\n    self.assertEqual(len(last_msg.tracking_value_ids), 2)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['name', 'public']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Name', 'Privacy']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set(['my_name', 'Selected group of users']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set(['supername', 'Invited people only']))\n    self.group_pigs.sudo(self.user_employee).write({'public': 'public', 'group_public_id': group_system.id})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids), 3)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_group_public_set)\n    self.assertEqual(len(last_msg.tracking_value_ids), 3)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['group_public_id', 'public', 'name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Authorized Group', 'Privacy', 'Name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set([group_user.name_get()[0][1], 'Invited people only', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set([group_system.name_get()[0][1], 'Everyone', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_integer')), set([0, group_user.id]))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_integer')), set([0, group_system.id]))",
            "def test_message_track(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Testing auto tracking of fields. Warning, it has not be cleaned and\\n        should probably be. '\n    Subtype = self.env['mail.message.subtype']\n    Data = self.env['ir.model.data']\n    note_subtype = self.env.ref('mail.mt_note')\n    group_system = self.env.ref('base.group_system')\n    group_user = self.env.ref('base.group_user')\n    self.group_pigs.write({'channel_partner_ids': [(4, self.user_employee.partner_id.id)]})\n    mt_private = Subtype.create({'name': 'private', 'description': 'Public field set to private'})\n    Data.create({'name': 'mt_private', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_private.id})\n    mt_name_supername = Subtype.create({'name': 'name_supername', 'description': 'Name field set to supername'})\n    Data.create({'name': 'mt_name_supername', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_name_supername.id})\n    mt_group_public_set = Subtype.create({'name': 'group_public_set', 'description': 'Group_public field set'})\n    Data.create({'name': 'mt_group_public_set', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_set.id})\n    mt_group_public_unset = Subtype.create({'name': 'group_public_unset', 'description': 'Group_public field unset'})\n    Data.create({'name': 'mt_group_public_unset', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_unset.id})\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'public' in init_values and self.public == 'private':\n            return 'mail.mt_private'\n        elif 'name' in init_values and self.name == 'supername':\n            return 'mail.mt_name_supername'\n        elif 'group_public_id' in init_values and self.group_public_id:\n            return 'mail.mt_group_public_set'\n        elif 'group_public_id' in init_values and (not self.group_public_id):\n            return 'mail.mt_group_public_unset'\n        return False\n    self.registry('mail.channel')._patch_method('_track_subtype', _track_subtype)\n    visibility = {'public': 'onchange', 'name': 'always', 'group_public_id': 'onchange'}\n    cls = type(self.env['mail.channel'])\n    for key in visibility:\n        self.assertFalse(hasattr(getattr(cls, key), 'track_visibility'))\n        getattr(cls, key).track_visibility = visibility[key]\n\n    @self.addCleanup\n    def cleanup():\n        for key in visibility:\n            del getattr(cls, key).track_visibility\n    self.group_pigs.sudo(self.user_employee).write({'name': 'my_name'})\n    self.assertEqual(len(self.group_pigs.message_ids), 1)\n    last_msg = self.group_pigs.message_ids[-1]\n    self.assertEqual(last_msg.subtype_id, note_subtype)\n    self.assertEqual(len(last_msg.tracking_value_ids), 1)\n    self.assertEqual(last_msg.tracking_value_ids.field, 'name')\n    self.assertEqual(last_msg.tracking_value_ids.field_desc, 'Name')\n    self.assertEqual(last_msg.tracking_value_ids.old_value_char, 'Pigs')\n    self.assertEqual(last_msg.tracking_value_ids.new_value_char, 'my_name')\n    self.group_pigs.sudo(self.user_employee).write({'name': 'supername', 'public': 'private'})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids.ids), 2)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_private)\n    self.assertEqual(len(last_msg.tracking_value_ids), 2)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['name', 'public']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Name', 'Privacy']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set(['my_name', 'Selected group of users']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set(['supername', 'Invited people only']))\n    self.group_pigs.sudo(self.user_employee).write({'public': 'public', 'group_public_id': group_system.id})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids), 3)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_group_public_set)\n    self.assertEqual(len(last_msg.tracking_value_ids), 3)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['group_public_id', 'public', 'name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Authorized Group', 'Privacy', 'Name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set([group_user.name_get()[0][1], 'Invited people only', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set([group_system.name_get()[0][1], 'Everyone', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_integer')), set([0, group_user.id]))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_integer')), set([0, group_system.id]))",
            "def test_message_track(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Testing auto tracking of fields. Warning, it has not be cleaned and\\n        should probably be. '\n    Subtype = self.env['mail.message.subtype']\n    Data = self.env['ir.model.data']\n    note_subtype = self.env.ref('mail.mt_note')\n    group_system = self.env.ref('base.group_system')\n    group_user = self.env.ref('base.group_user')\n    self.group_pigs.write({'channel_partner_ids': [(4, self.user_employee.partner_id.id)]})\n    mt_private = Subtype.create({'name': 'private', 'description': 'Public field set to private'})\n    Data.create({'name': 'mt_private', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_private.id})\n    mt_name_supername = Subtype.create({'name': 'name_supername', 'description': 'Name field set to supername'})\n    Data.create({'name': 'mt_name_supername', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_name_supername.id})\n    mt_group_public_set = Subtype.create({'name': 'group_public_set', 'description': 'Group_public field set'})\n    Data.create({'name': 'mt_group_public_set', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_set.id})\n    mt_group_public_unset = Subtype.create({'name': 'group_public_unset', 'description': 'Group_public field unset'})\n    Data.create({'name': 'mt_group_public_unset', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_unset.id})\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'public' in init_values and self.public == 'private':\n            return 'mail.mt_private'\n        elif 'name' in init_values and self.name == 'supername':\n            return 'mail.mt_name_supername'\n        elif 'group_public_id' in init_values and self.group_public_id:\n            return 'mail.mt_group_public_set'\n        elif 'group_public_id' in init_values and (not self.group_public_id):\n            return 'mail.mt_group_public_unset'\n        return False\n    self.registry('mail.channel')._patch_method('_track_subtype', _track_subtype)\n    visibility = {'public': 'onchange', 'name': 'always', 'group_public_id': 'onchange'}\n    cls = type(self.env['mail.channel'])\n    for key in visibility:\n        self.assertFalse(hasattr(getattr(cls, key), 'track_visibility'))\n        getattr(cls, key).track_visibility = visibility[key]\n\n    @self.addCleanup\n    def cleanup():\n        for key in visibility:\n            del getattr(cls, key).track_visibility\n    self.group_pigs.sudo(self.user_employee).write({'name': 'my_name'})\n    self.assertEqual(len(self.group_pigs.message_ids), 1)\n    last_msg = self.group_pigs.message_ids[-1]\n    self.assertEqual(last_msg.subtype_id, note_subtype)\n    self.assertEqual(len(last_msg.tracking_value_ids), 1)\n    self.assertEqual(last_msg.tracking_value_ids.field, 'name')\n    self.assertEqual(last_msg.tracking_value_ids.field_desc, 'Name')\n    self.assertEqual(last_msg.tracking_value_ids.old_value_char, 'Pigs')\n    self.assertEqual(last_msg.tracking_value_ids.new_value_char, 'my_name')\n    self.group_pigs.sudo(self.user_employee).write({'name': 'supername', 'public': 'private'})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids.ids), 2)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_private)\n    self.assertEqual(len(last_msg.tracking_value_ids), 2)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['name', 'public']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Name', 'Privacy']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set(['my_name', 'Selected group of users']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set(['supername', 'Invited people only']))\n    self.group_pigs.sudo(self.user_employee).write({'public': 'public', 'group_public_id': group_system.id})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids), 3)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_group_public_set)\n    self.assertEqual(len(last_msg.tracking_value_ids), 3)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['group_public_id', 'public', 'name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Authorized Group', 'Privacy', 'Name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set([group_user.name_get()[0][1], 'Invited people only', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set([group_system.name_get()[0][1], 'Everyone', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_integer')), set([0, group_user.id]))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_integer')), set([0, group_system.id]))",
            "def test_message_track(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Testing auto tracking of fields. Warning, it has not be cleaned and\\n        should probably be. '\n    Subtype = self.env['mail.message.subtype']\n    Data = self.env['ir.model.data']\n    note_subtype = self.env.ref('mail.mt_note')\n    group_system = self.env.ref('base.group_system')\n    group_user = self.env.ref('base.group_user')\n    self.group_pigs.write({'channel_partner_ids': [(4, self.user_employee.partner_id.id)]})\n    mt_private = Subtype.create({'name': 'private', 'description': 'Public field set to private'})\n    Data.create({'name': 'mt_private', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_private.id})\n    mt_name_supername = Subtype.create({'name': 'name_supername', 'description': 'Name field set to supername'})\n    Data.create({'name': 'mt_name_supername', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_name_supername.id})\n    mt_group_public_set = Subtype.create({'name': 'group_public_set', 'description': 'Group_public field set'})\n    Data.create({'name': 'mt_group_public_set', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_set.id})\n    mt_group_public_unset = Subtype.create({'name': 'group_public_unset', 'description': 'Group_public field unset'})\n    Data.create({'name': 'mt_group_public_unset', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_unset.id})\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'public' in init_values and self.public == 'private':\n            return 'mail.mt_private'\n        elif 'name' in init_values and self.name == 'supername':\n            return 'mail.mt_name_supername'\n        elif 'group_public_id' in init_values and self.group_public_id:\n            return 'mail.mt_group_public_set'\n        elif 'group_public_id' in init_values and (not self.group_public_id):\n            return 'mail.mt_group_public_unset'\n        return False\n    self.registry('mail.channel')._patch_method('_track_subtype', _track_subtype)\n    visibility = {'public': 'onchange', 'name': 'always', 'group_public_id': 'onchange'}\n    cls = type(self.env['mail.channel'])\n    for key in visibility:\n        self.assertFalse(hasattr(getattr(cls, key), 'track_visibility'))\n        getattr(cls, key).track_visibility = visibility[key]\n\n    @self.addCleanup\n    def cleanup():\n        for key in visibility:\n            del getattr(cls, key).track_visibility\n    self.group_pigs.sudo(self.user_employee).write({'name': 'my_name'})\n    self.assertEqual(len(self.group_pigs.message_ids), 1)\n    last_msg = self.group_pigs.message_ids[-1]\n    self.assertEqual(last_msg.subtype_id, note_subtype)\n    self.assertEqual(len(last_msg.tracking_value_ids), 1)\n    self.assertEqual(last_msg.tracking_value_ids.field, 'name')\n    self.assertEqual(last_msg.tracking_value_ids.field_desc, 'Name')\n    self.assertEqual(last_msg.tracking_value_ids.old_value_char, 'Pigs')\n    self.assertEqual(last_msg.tracking_value_ids.new_value_char, 'my_name')\n    self.group_pigs.sudo(self.user_employee).write({'name': 'supername', 'public': 'private'})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids.ids), 2)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_private)\n    self.assertEqual(len(last_msg.tracking_value_ids), 2)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['name', 'public']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Name', 'Privacy']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set(['my_name', 'Selected group of users']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set(['supername', 'Invited people only']))\n    self.group_pigs.sudo(self.user_employee).write({'public': 'public', 'group_public_id': group_system.id})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids), 3)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_group_public_set)\n    self.assertEqual(len(last_msg.tracking_value_ids), 3)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['group_public_id', 'public', 'name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Authorized Group', 'Privacy', 'Name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set([group_user.name_get()[0][1], 'Invited people only', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set([group_system.name_get()[0][1], 'Everyone', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_integer')), set([0, group_user.id]))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_integer')), set([0, group_system.id]))",
            "def test_message_track(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Testing auto tracking of fields. Warning, it has not be cleaned and\\n        should probably be. '\n    Subtype = self.env['mail.message.subtype']\n    Data = self.env['ir.model.data']\n    note_subtype = self.env.ref('mail.mt_note')\n    group_system = self.env.ref('base.group_system')\n    group_user = self.env.ref('base.group_user')\n    self.group_pigs.write({'channel_partner_ids': [(4, self.user_employee.partner_id.id)]})\n    mt_private = Subtype.create({'name': 'private', 'description': 'Public field set to private'})\n    Data.create({'name': 'mt_private', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_private.id})\n    mt_name_supername = Subtype.create({'name': 'name_supername', 'description': 'Name field set to supername'})\n    Data.create({'name': 'mt_name_supername', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_name_supername.id})\n    mt_group_public_set = Subtype.create({'name': 'group_public_set', 'description': 'Group_public field set'})\n    Data.create({'name': 'mt_group_public_set', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_set.id})\n    mt_group_public_unset = Subtype.create({'name': 'group_public_unset', 'description': 'Group_public field unset'})\n    Data.create({'name': 'mt_group_public_unset', 'model': 'mail.message.subtype', 'module': 'mail', 'res_id': mt_group_public_unset.id})\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'public' in init_values and self.public == 'private':\n            return 'mail.mt_private'\n        elif 'name' in init_values and self.name == 'supername':\n            return 'mail.mt_name_supername'\n        elif 'group_public_id' in init_values and self.group_public_id:\n            return 'mail.mt_group_public_set'\n        elif 'group_public_id' in init_values and (not self.group_public_id):\n            return 'mail.mt_group_public_unset'\n        return False\n    self.registry('mail.channel')._patch_method('_track_subtype', _track_subtype)\n    visibility = {'public': 'onchange', 'name': 'always', 'group_public_id': 'onchange'}\n    cls = type(self.env['mail.channel'])\n    for key in visibility:\n        self.assertFalse(hasattr(getattr(cls, key), 'track_visibility'))\n        getattr(cls, key).track_visibility = visibility[key]\n\n    @self.addCleanup\n    def cleanup():\n        for key in visibility:\n            del getattr(cls, key).track_visibility\n    self.group_pigs.sudo(self.user_employee).write({'name': 'my_name'})\n    self.assertEqual(len(self.group_pigs.message_ids), 1)\n    last_msg = self.group_pigs.message_ids[-1]\n    self.assertEqual(last_msg.subtype_id, note_subtype)\n    self.assertEqual(len(last_msg.tracking_value_ids), 1)\n    self.assertEqual(last_msg.tracking_value_ids.field, 'name')\n    self.assertEqual(last_msg.tracking_value_ids.field_desc, 'Name')\n    self.assertEqual(last_msg.tracking_value_ids.old_value_char, 'Pigs')\n    self.assertEqual(last_msg.tracking_value_ids.new_value_char, 'my_name')\n    self.group_pigs.sudo(self.user_employee).write({'name': 'supername', 'public': 'private'})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids.ids), 2)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_private)\n    self.assertEqual(len(last_msg.tracking_value_ids), 2)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['name', 'public']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Name', 'Privacy']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set(['my_name', 'Selected group of users']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set(['supername', 'Invited people only']))\n    self.group_pigs.sudo(self.user_employee).write({'public': 'public', 'group_public_id': group_system.id})\n    self.group_pigs.invalidate_cache()\n    self.assertEqual(len(self.group_pigs.message_ids), 3)\n    last_msg = self.group_pigs.message_ids[0]\n    self.assertEqual(last_msg.subtype_id, mt_group_public_set)\n    self.assertEqual(len(last_msg.tracking_value_ids), 3)\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field')), set(['group_public_id', 'public', 'name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('field_desc')), set(['Authorized Group', 'Privacy', 'Name']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_char')), set([group_user.name_get()[0][1], 'Invited people only', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set([group_system.name_get()[0][1], 'Everyone', 'supername']))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('old_value_integer')), set([0, group_user.id]))\n    self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_integer')), set([0, group_system.id]))"
        ]
    }
]