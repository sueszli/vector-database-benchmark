[
    {
        "func_name": "test_can_insert_person_overrides",
        "original": "@pytest.mark.django_db\ndef test_can_insert_person_overrides():\n    sync_execute(KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)\n    producer = KafkaProducer(bootstrap_servers=KAFKA_HOSTS)\n    try:\n        old_person_id = uuid4()\n        override_person_id = uuid4()\n        oldest_event_string = '2020-01-01 00:00:00'\n        oldest_event = datetime.fromisoformat(oldest_event_string).replace(tzinfo=ZoneInfo('UTC'))\n        merged_at_string = '2020-01-02 00:00:00'\n        merged_at = datetime.fromisoformat(merged_at_string).replace(tzinfo=ZoneInfo('UTC'))\n        message = {'team_id': 1, 'old_person_id': str(old_person_id), 'override_person_id': str(override_person_id), 'oldest_event': oldest_event_string, 'merged_at': merged_at_string, 'version': 2}\n        future = producer.send(topic=KAFKA_PERSON_OVERRIDE, key=str(uuid4()).encode('utf-8'), value=json.dumps(message).encode('utf-8'))\n        future.get(timeout=5)\n        results = []\n        for _ in range(5):\n            results = sync_execute('\\n                SELECT\\n                    created_at,\\n                    team_id,\\n                    old_person_id,\\n                    override_person_id,\\n                    oldest_event,\\n                    merged_at,\\n                    version\\n                FROM\\n                    person_overrides\\n                WHERE old_person_id = %(old_person_id)s\\n                ', {'old_person_id': str(old_person_id)})\n            if results:\n                break\n            sleep(1)\n        assert isinstance(results, list)\n        assert results != []\n        [result] = results\n        (created_at, *the_rest) = result\n        assert the_rest == [1, old_person_id, override_person_id, oldest_event, merged_at, 2]\n        assert created_at > datetime.now(tz=ZoneInfo('UTC')) - timedelta(seconds=10)\n    finally:\n        producer.close()\n        sync_execute(DROP_KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n        sync_execute(DROP_PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)",
        "mutated": [
            "@pytest.mark.django_db\ndef test_can_insert_person_overrides():\n    if False:\n        i = 10\n    sync_execute(KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)\n    producer = KafkaProducer(bootstrap_servers=KAFKA_HOSTS)\n    try:\n        old_person_id = uuid4()\n        override_person_id = uuid4()\n        oldest_event_string = '2020-01-01 00:00:00'\n        oldest_event = datetime.fromisoformat(oldest_event_string).replace(tzinfo=ZoneInfo('UTC'))\n        merged_at_string = '2020-01-02 00:00:00'\n        merged_at = datetime.fromisoformat(merged_at_string).replace(tzinfo=ZoneInfo('UTC'))\n        message = {'team_id': 1, 'old_person_id': str(old_person_id), 'override_person_id': str(override_person_id), 'oldest_event': oldest_event_string, 'merged_at': merged_at_string, 'version': 2}\n        future = producer.send(topic=KAFKA_PERSON_OVERRIDE, key=str(uuid4()).encode('utf-8'), value=json.dumps(message).encode('utf-8'))\n        future.get(timeout=5)\n        results = []\n        for _ in range(5):\n            results = sync_execute('\\n                SELECT\\n                    created_at,\\n                    team_id,\\n                    old_person_id,\\n                    override_person_id,\\n                    oldest_event,\\n                    merged_at,\\n                    version\\n                FROM\\n                    person_overrides\\n                WHERE old_person_id = %(old_person_id)s\\n                ', {'old_person_id': str(old_person_id)})\n            if results:\n                break\n            sleep(1)\n        assert isinstance(results, list)\n        assert results != []\n        [result] = results\n        (created_at, *the_rest) = result\n        assert the_rest == [1, old_person_id, override_person_id, oldest_event, merged_at, 2]\n        assert created_at > datetime.now(tz=ZoneInfo('UTC')) - timedelta(seconds=10)\n    finally:\n        producer.close()\n        sync_execute(DROP_KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n        sync_execute(DROP_PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)",
            "@pytest.mark.django_db\ndef test_can_insert_person_overrides():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sync_execute(KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)\n    producer = KafkaProducer(bootstrap_servers=KAFKA_HOSTS)\n    try:\n        old_person_id = uuid4()\n        override_person_id = uuid4()\n        oldest_event_string = '2020-01-01 00:00:00'\n        oldest_event = datetime.fromisoformat(oldest_event_string).replace(tzinfo=ZoneInfo('UTC'))\n        merged_at_string = '2020-01-02 00:00:00'\n        merged_at = datetime.fromisoformat(merged_at_string).replace(tzinfo=ZoneInfo('UTC'))\n        message = {'team_id': 1, 'old_person_id': str(old_person_id), 'override_person_id': str(override_person_id), 'oldest_event': oldest_event_string, 'merged_at': merged_at_string, 'version': 2}\n        future = producer.send(topic=KAFKA_PERSON_OVERRIDE, key=str(uuid4()).encode('utf-8'), value=json.dumps(message).encode('utf-8'))\n        future.get(timeout=5)\n        results = []\n        for _ in range(5):\n            results = sync_execute('\\n                SELECT\\n                    created_at,\\n                    team_id,\\n                    old_person_id,\\n                    override_person_id,\\n                    oldest_event,\\n                    merged_at,\\n                    version\\n                FROM\\n                    person_overrides\\n                WHERE old_person_id = %(old_person_id)s\\n                ', {'old_person_id': str(old_person_id)})\n            if results:\n                break\n            sleep(1)\n        assert isinstance(results, list)\n        assert results != []\n        [result] = results\n        (created_at, *the_rest) = result\n        assert the_rest == [1, old_person_id, override_person_id, oldest_event, merged_at, 2]\n        assert created_at > datetime.now(tz=ZoneInfo('UTC')) - timedelta(seconds=10)\n    finally:\n        producer.close()\n        sync_execute(DROP_KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n        sync_execute(DROP_PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)",
            "@pytest.mark.django_db\ndef test_can_insert_person_overrides():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sync_execute(KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)\n    producer = KafkaProducer(bootstrap_servers=KAFKA_HOSTS)\n    try:\n        old_person_id = uuid4()\n        override_person_id = uuid4()\n        oldest_event_string = '2020-01-01 00:00:00'\n        oldest_event = datetime.fromisoformat(oldest_event_string).replace(tzinfo=ZoneInfo('UTC'))\n        merged_at_string = '2020-01-02 00:00:00'\n        merged_at = datetime.fromisoformat(merged_at_string).replace(tzinfo=ZoneInfo('UTC'))\n        message = {'team_id': 1, 'old_person_id': str(old_person_id), 'override_person_id': str(override_person_id), 'oldest_event': oldest_event_string, 'merged_at': merged_at_string, 'version': 2}\n        future = producer.send(topic=KAFKA_PERSON_OVERRIDE, key=str(uuid4()).encode('utf-8'), value=json.dumps(message).encode('utf-8'))\n        future.get(timeout=5)\n        results = []\n        for _ in range(5):\n            results = sync_execute('\\n                SELECT\\n                    created_at,\\n                    team_id,\\n                    old_person_id,\\n                    override_person_id,\\n                    oldest_event,\\n                    merged_at,\\n                    version\\n                FROM\\n                    person_overrides\\n                WHERE old_person_id = %(old_person_id)s\\n                ', {'old_person_id': str(old_person_id)})\n            if results:\n                break\n            sleep(1)\n        assert isinstance(results, list)\n        assert results != []\n        [result] = results\n        (created_at, *the_rest) = result\n        assert the_rest == [1, old_person_id, override_person_id, oldest_event, merged_at, 2]\n        assert created_at > datetime.now(tz=ZoneInfo('UTC')) - timedelta(seconds=10)\n    finally:\n        producer.close()\n        sync_execute(DROP_KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n        sync_execute(DROP_PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)",
            "@pytest.mark.django_db\ndef test_can_insert_person_overrides():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sync_execute(KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)\n    producer = KafkaProducer(bootstrap_servers=KAFKA_HOSTS)\n    try:\n        old_person_id = uuid4()\n        override_person_id = uuid4()\n        oldest_event_string = '2020-01-01 00:00:00'\n        oldest_event = datetime.fromisoformat(oldest_event_string).replace(tzinfo=ZoneInfo('UTC'))\n        merged_at_string = '2020-01-02 00:00:00'\n        merged_at = datetime.fromisoformat(merged_at_string).replace(tzinfo=ZoneInfo('UTC'))\n        message = {'team_id': 1, 'old_person_id': str(old_person_id), 'override_person_id': str(override_person_id), 'oldest_event': oldest_event_string, 'merged_at': merged_at_string, 'version': 2}\n        future = producer.send(topic=KAFKA_PERSON_OVERRIDE, key=str(uuid4()).encode('utf-8'), value=json.dumps(message).encode('utf-8'))\n        future.get(timeout=5)\n        results = []\n        for _ in range(5):\n            results = sync_execute('\\n                SELECT\\n                    created_at,\\n                    team_id,\\n                    old_person_id,\\n                    override_person_id,\\n                    oldest_event,\\n                    merged_at,\\n                    version\\n                FROM\\n                    person_overrides\\n                WHERE old_person_id = %(old_person_id)s\\n                ', {'old_person_id': str(old_person_id)})\n            if results:\n                break\n            sleep(1)\n        assert isinstance(results, list)\n        assert results != []\n        [result] = results\n        (created_at, *the_rest) = result\n        assert the_rest == [1, old_person_id, override_person_id, oldest_event, merged_at, 2]\n        assert created_at > datetime.now(tz=ZoneInfo('UTC')) - timedelta(seconds=10)\n    finally:\n        producer.close()\n        sync_execute(DROP_KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n        sync_execute(DROP_PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)",
            "@pytest.mark.django_db\ndef test_can_insert_person_overrides():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sync_execute(KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)\n    producer = KafkaProducer(bootstrap_servers=KAFKA_HOSTS)\n    try:\n        old_person_id = uuid4()\n        override_person_id = uuid4()\n        oldest_event_string = '2020-01-01 00:00:00'\n        oldest_event = datetime.fromisoformat(oldest_event_string).replace(tzinfo=ZoneInfo('UTC'))\n        merged_at_string = '2020-01-02 00:00:00'\n        merged_at = datetime.fromisoformat(merged_at_string).replace(tzinfo=ZoneInfo('UTC'))\n        message = {'team_id': 1, 'old_person_id': str(old_person_id), 'override_person_id': str(override_person_id), 'oldest_event': oldest_event_string, 'merged_at': merged_at_string, 'version': 2}\n        future = producer.send(topic=KAFKA_PERSON_OVERRIDE, key=str(uuid4()).encode('utf-8'), value=json.dumps(message).encode('utf-8'))\n        future.get(timeout=5)\n        results = []\n        for _ in range(5):\n            results = sync_execute('\\n                SELECT\\n                    created_at,\\n                    team_id,\\n                    old_person_id,\\n                    override_person_id,\\n                    oldest_event,\\n                    merged_at,\\n                    version\\n                FROM\\n                    person_overrides\\n                WHERE old_person_id = %(old_person_id)s\\n                ', {'old_person_id': str(old_person_id)})\n            if results:\n                break\n            sleep(1)\n        assert isinstance(results, list)\n        assert results != []\n        [result] = results\n        (created_at, *the_rest) = result\n        assert the_rest == [1, old_person_id, override_person_id, oldest_event, merged_at, 2]\n        assert created_at > datetime.now(tz=ZoneInfo('UTC')) - timedelta(seconds=10)\n    finally:\n        producer.close()\n        sync_execute(DROP_KAFKA_PERSON_OVERRIDES_TABLE_SQL)\n        sync_execute(DROP_PERSON_OVERRIDES_CREATE_MATERIALIZED_VIEW_SQL)"
        ]
    },
    {
        "func_name": "test_person_overrides_dict",
        "original": "@pytest.mark.django_db\ndef test_person_overrides_dict():\n    \"\"\"Test behavior of person_overrides_dict with multiple versions of same key.\n\n    The dictionary should always favor the latest version after every reload.\n    \"\"\"\n    sync_execute(PERSON_OVERRIDES_CREATE_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_DICTIONARY_SQL)\n    values: PersonOverrideValues = {'team_id': 1, 'old_person_id': uuid4(), 'override_person_id': uuid4(), 'merged_at': datetime.fromisoformat('2020-01-02T00:00:00+00:00'), 'oldest_event': datetime.fromisoformat('2020-01-01T00:00:00+00:00'), 'created_at': datetime.utcnow(), 'version': 1}\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(results) == 1\n    assert results[0][0] == values['override_person_id']\n    values['version'] = 2\n    values['override_person_id'] = uuid4()\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    new_results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(new_results) == 1\n    assert new_results[0][0] == values['override_person_id']\n    assert new_results[0][0] != results[0][0]",
        "mutated": [
            "@pytest.mark.django_db\ndef test_person_overrides_dict():\n    if False:\n        i = 10\n    'Test behavior of person_overrides_dict with multiple versions of same key.\\n\\n    The dictionary should always favor the latest version after every reload.\\n    '\n    sync_execute(PERSON_OVERRIDES_CREATE_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_DICTIONARY_SQL)\n    values: PersonOverrideValues = {'team_id': 1, 'old_person_id': uuid4(), 'override_person_id': uuid4(), 'merged_at': datetime.fromisoformat('2020-01-02T00:00:00+00:00'), 'oldest_event': datetime.fromisoformat('2020-01-01T00:00:00+00:00'), 'created_at': datetime.utcnow(), 'version': 1}\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(results) == 1\n    assert results[0][0] == values['override_person_id']\n    values['version'] = 2\n    values['override_person_id'] = uuid4()\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    new_results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(new_results) == 1\n    assert new_results[0][0] == values['override_person_id']\n    assert new_results[0][0] != results[0][0]",
            "@pytest.mark.django_db\ndef test_person_overrides_dict():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test behavior of person_overrides_dict with multiple versions of same key.\\n\\n    The dictionary should always favor the latest version after every reload.\\n    '\n    sync_execute(PERSON_OVERRIDES_CREATE_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_DICTIONARY_SQL)\n    values: PersonOverrideValues = {'team_id': 1, 'old_person_id': uuid4(), 'override_person_id': uuid4(), 'merged_at': datetime.fromisoformat('2020-01-02T00:00:00+00:00'), 'oldest_event': datetime.fromisoformat('2020-01-01T00:00:00+00:00'), 'created_at': datetime.utcnow(), 'version': 1}\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(results) == 1\n    assert results[0][0] == values['override_person_id']\n    values['version'] = 2\n    values['override_person_id'] = uuid4()\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    new_results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(new_results) == 1\n    assert new_results[0][0] == values['override_person_id']\n    assert new_results[0][0] != results[0][0]",
            "@pytest.mark.django_db\ndef test_person_overrides_dict():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test behavior of person_overrides_dict with multiple versions of same key.\\n\\n    The dictionary should always favor the latest version after every reload.\\n    '\n    sync_execute(PERSON_OVERRIDES_CREATE_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_DICTIONARY_SQL)\n    values: PersonOverrideValues = {'team_id': 1, 'old_person_id': uuid4(), 'override_person_id': uuid4(), 'merged_at': datetime.fromisoformat('2020-01-02T00:00:00+00:00'), 'oldest_event': datetime.fromisoformat('2020-01-01T00:00:00+00:00'), 'created_at': datetime.utcnow(), 'version': 1}\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(results) == 1\n    assert results[0][0] == values['override_person_id']\n    values['version'] = 2\n    values['override_person_id'] = uuid4()\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    new_results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(new_results) == 1\n    assert new_results[0][0] == values['override_person_id']\n    assert new_results[0][0] != results[0][0]",
            "@pytest.mark.django_db\ndef test_person_overrides_dict():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test behavior of person_overrides_dict with multiple versions of same key.\\n\\n    The dictionary should always favor the latest version after every reload.\\n    '\n    sync_execute(PERSON_OVERRIDES_CREATE_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_DICTIONARY_SQL)\n    values: PersonOverrideValues = {'team_id': 1, 'old_person_id': uuid4(), 'override_person_id': uuid4(), 'merged_at': datetime.fromisoformat('2020-01-02T00:00:00+00:00'), 'oldest_event': datetime.fromisoformat('2020-01-01T00:00:00+00:00'), 'created_at': datetime.utcnow(), 'version': 1}\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(results) == 1\n    assert results[0][0] == values['override_person_id']\n    values['version'] = 2\n    values['override_person_id'] = uuid4()\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    new_results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(new_results) == 1\n    assert new_results[0][0] == values['override_person_id']\n    assert new_results[0][0] != results[0][0]",
            "@pytest.mark.django_db\ndef test_person_overrides_dict():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test behavior of person_overrides_dict with multiple versions of same key.\\n\\n    The dictionary should always favor the latest version after every reload.\\n    '\n    sync_execute(PERSON_OVERRIDES_CREATE_TABLE_SQL)\n    sync_execute(PERSON_OVERRIDES_CREATE_DICTIONARY_SQL)\n    values: PersonOverrideValues = {'team_id': 1, 'old_person_id': uuid4(), 'override_person_id': uuid4(), 'merged_at': datetime.fromisoformat('2020-01-02T00:00:00+00:00'), 'oldest_event': datetime.fromisoformat('2020-01-01T00:00:00+00:00'), 'created_at': datetime.utcnow(), 'version': 1}\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(results) == 1\n    assert results[0][0] == values['override_person_id']\n    values['version'] = 2\n    values['override_person_id'] = uuid4()\n    sync_execute('INSERT INTO person_overrides (*) VALUES', [values])\n    sync_execute('SYSTEM RELOAD DICTIONARY person_overrides_dict')\n    new_results = sync_execute(\"SELECT dictGet(person_overrides_dict, 'override_person_id', (%(team_id)s, %(old_person_id)s))\", values)\n    assert len(new_results) == 1\n    assert new_results[0][0] == values['override_person_id']\n    assert new_results[0][0] != results[0][0]"
        ]
    }
]