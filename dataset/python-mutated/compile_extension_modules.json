[
    {
        "func_name": "displayError",
        "original": "def displayError(dirname, filename):\n    assert dirname is None\n    dist_path = filename[:-3] + '.dist'\n    displayFolderContents('dist folder', dist_path)\n    inclusion_log_path = filename[:-3] + '.py.inclusion.log'\n    displayFileContents('inclusion log', inclusion_log_path)",
        "mutated": [
            "def displayError(dirname, filename):\n    if False:\n        i = 10\n    assert dirname is None\n    dist_path = filename[:-3] + '.dist'\n    displayFolderContents('dist folder', dist_path)\n    inclusion_log_path = filename[:-3] + '.py.inclusion.log'\n    displayFileContents('inclusion log', inclusion_log_path)",
            "def displayError(dirname, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert dirname is None\n    dist_path = filename[:-3] + '.dist'\n    displayFolderContents('dist folder', dist_path)\n    inclusion_log_path = filename[:-3] + '.py.inclusion.log'\n    displayFileContents('inclusion log', inclusion_log_path)",
            "def displayError(dirname, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert dirname is None\n    dist_path = filename[:-3] + '.dist'\n    displayFolderContents('dist folder', dist_path)\n    inclusion_log_path = filename[:-3] + '.py.inclusion.log'\n    displayFileContents('inclusion log', inclusion_log_path)",
            "def displayError(dirname, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert dirname is None\n    dist_path = filename[:-3] + '.dist'\n    displayFolderContents('dist folder', dist_path)\n    inclusion_log_path = filename[:-3] + '.py.inclusion.log'\n    displayFileContents('inclusion log', inclusion_log_path)",
            "def displayError(dirname, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert dirname is None\n    dist_path = filename[:-3] + '.dist'\n    displayFolderContents('dist folder', dist_path)\n    inclusion_log_path = filename[:-3] + '.py.inclusion.log'\n    displayFileContents('inclusion log', inclusion_log_path)"
        ]
    },
    {
        "func_name": "decide",
        "original": "def decide(root, filename):\n    if os.path.sep + 'Cython' + os.path.sep in root:\n        return False\n    if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n        return False\n    if filename.endswith('linux-gnu_d.so'):\n        return False\n    if root.endswith(os.path.sep + 'msgpack'):\n        return False\n    first_part = filename.split('.')[0]\n    if first_part in done:\n        return False\n    done.add(first_part)\n    return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))",
        "mutated": [
            "def decide(root, filename):\n    if False:\n        i = 10\n    if os.path.sep + 'Cython' + os.path.sep in root:\n        return False\n    if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n        return False\n    if filename.endswith('linux-gnu_d.so'):\n        return False\n    if root.endswith(os.path.sep + 'msgpack'):\n        return False\n    first_part = filename.split('.')[0]\n    if first_part in done:\n        return False\n    done.add(first_part)\n    return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))",
            "def decide(root, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if os.path.sep + 'Cython' + os.path.sep in root:\n        return False\n    if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n        return False\n    if filename.endswith('linux-gnu_d.so'):\n        return False\n    if root.endswith(os.path.sep + 'msgpack'):\n        return False\n    first_part = filename.split('.')[0]\n    if first_part in done:\n        return False\n    done.add(first_part)\n    return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))",
            "def decide(root, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if os.path.sep + 'Cython' + os.path.sep in root:\n        return False\n    if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n        return False\n    if filename.endswith('linux-gnu_d.so'):\n        return False\n    if root.endswith(os.path.sep + 'msgpack'):\n        return False\n    first_part = filename.split('.')[0]\n    if first_part in done:\n        return False\n    done.add(first_part)\n    return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))",
            "def decide(root, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if os.path.sep + 'Cython' + os.path.sep in root:\n        return False\n    if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n        return False\n    if filename.endswith('linux-gnu_d.so'):\n        return False\n    if root.endswith(os.path.sep + 'msgpack'):\n        return False\n    first_part = filename.split('.')[0]\n    if first_part in done:\n        return False\n    done.add(first_part)\n    return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))",
            "def decide(root, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if os.path.sep + 'Cython' + os.path.sep in root:\n        return False\n    if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n        return False\n    if filename.endswith('linux-gnu_d.so'):\n        return False\n    if root.endswith(os.path.sep + 'msgpack'):\n        return False\n    first_part = filename.split('.')[0]\n    if first_part in done:\n        return False\n    done.add(first_part)\n    return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))"
        ]
    },
    {
        "func_name": "action",
        "original": "def action(stage_dir, root, path):\n    command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n    filename = os.path.join(stage_dir, 'importer.py')\n    assert path.startswith(root)\n    module_name = path[len(root) + 1:]\n    module_name = module_name.split('.')[0]\n    module_name = module_name.replace(os.path.sep, '.')\n    module_name = ModuleName(module_name)\n    with openTextFile(filename, 'w') as output:\n        plugin_names = set(['pylint-warnings'])\n        if module_name.hasNamespace('PySide2'):\n            plugin_names.add('pyside2')\n        elif module_name.hasNamespace('PySide6'):\n            plugin_names.add('pyside6')\n        elif module_name.hasNamespace('PyQt5'):\n            plugin_names.add('pyqt5')\n        elif module_name.hasNamespace('PyQt6'):\n            plugin_names.add('pyqt6')\n        else:\n            plugin_names.add('no-qt')\n        for plugin_name in plugin_names:\n            output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n        output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n        output.write('# nuitka-project: --standalone\\n')\n        output.write('import ' + module_name.asString() + '\\n')\n        output.write(\"print('OK.')\")\n    command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n    command.append(filename)\n    if checkSucceedsWithCPython(filename):\n        try:\n            output = check_output(command).splitlines()\n        except NuitkaCalledProcessError as e:\n            my_print('SCRIPT:', filename, style='blue')\n            my_print(getFileContents(filename))\n            test_logger.sysexit('Error with compilation: %s' % e)\n        except Exception:\n            raise\n        else:\n            assert os.path.exists(filename[:-3] + '.dist')\n            binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n            loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n            outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n            if outside_accesses:\n                displayError(None, filename)\n                displayRuntimeTraces(test_logger, binary_filename)\n                test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                search_mode.onErrorDetected(1)\n            if output[-1] != b'OK.':\n                my_print(' '.join(command))\n                my_print(filename)\n                my_print(output)\n                test_logger.sysexit('FAIL.')\n            my_print('OK.')\n            assert not outside_accesses, outside_accesses\n            shutil.rmtree(filename[:-3] + '.dist')\n    else:\n        my_print('SKIP (does not work with CPython)')",
        "mutated": [
            "def action(stage_dir, root, path):\n    if False:\n        i = 10\n    command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n    filename = os.path.join(stage_dir, 'importer.py')\n    assert path.startswith(root)\n    module_name = path[len(root) + 1:]\n    module_name = module_name.split('.')[0]\n    module_name = module_name.replace(os.path.sep, '.')\n    module_name = ModuleName(module_name)\n    with openTextFile(filename, 'w') as output:\n        plugin_names = set(['pylint-warnings'])\n        if module_name.hasNamespace('PySide2'):\n            plugin_names.add('pyside2')\n        elif module_name.hasNamespace('PySide6'):\n            plugin_names.add('pyside6')\n        elif module_name.hasNamespace('PyQt5'):\n            plugin_names.add('pyqt5')\n        elif module_name.hasNamespace('PyQt6'):\n            plugin_names.add('pyqt6')\n        else:\n            plugin_names.add('no-qt')\n        for plugin_name in plugin_names:\n            output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n        output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n        output.write('# nuitka-project: --standalone\\n')\n        output.write('import ' + module_name.asString() + '\\n')\n        output.write(\"print('OK.')\")\n    command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n    command.append(filename)\n    if checkSucceedsWithCPython(filename):\n        try:\n            output = check_output(command).splitlines()\n        except NuitkaCalledProcessError as e:\n            my_print('SCRIPT:', filename, style='blue')\n            my_print(getFileContents(filename))\n            test_logger.sysexit('Error with compilation: %s' % e)\n        except Exception:\n            raise\n        else:\n            assert os.path.exists(filename[:-3] + '.dist')\n            binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n            loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n            outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n            if outside_accesses:\n                displayError(None, filename)\n                displayRuntimeTraces(test_logger, binary_filename)\n                test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                search_mode.onErrorDetected(1)\n            if output[-1] != b'OK.':\n                my_print(' '.join(command))\n                my_print(filename)\n                my_print(output)\n                test_logger.sysexit('FAIL.')\n            my_print('OK.')\n            assert not outside_accesses, outside_accesses\n            shutil.rmtree(filename[:-3] + '.dist')\n    else:\n        my_print('SKIP (does not work with CPython)')",
            "def action(stage_dir, root, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n    filename = os.path.join(stage_dir, 'importer.py')\n    assert path.startswith(root)\n    module_name = path[len(root) + 1:]\n    module_name = module_name.split('.')[0]\n    module_name = module_name.replace(os.path.sep, '.')\n    module_name = ModuleName(module_name)\n    with openTextFile(filename, 'w') as output:\n        plugin_names = set(['pylint-warnings'])\n        if module_name.hasNamespace('PySide2'):\n            plugin_names.add('pyside2')\n        elif module_name.hasNamespace('PySide6'):\n            plugin_names.add('pyside6')\n        elif module_name.hasNamespace('PyQt5'):\n            plugin_names.add('pyqt5')\n        elif module_name.hasNamespace('PyQt6'):\n            plugin_names.add('pyqt6')\n        else:\n            plugin_names.add('no-qt')\n        for plugin_name in plugin_names:\n            output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n        output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n        output.write('# nuitka-project: --standalone\\n')\n        output.write('import ' + module_name.asString() + '\\n')\n        output.write(\"print('OK.')\")\n    command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n    command.append(filename)\n    if checkSucceedsWithCPython(filename):\n        try:\n            output = check_output(command).splitlines()\n        except NuitkaCalledProcessError as e:\n            my_print('SCRIPT:', filename, style='blue')\n            my_print(getFileContents(filename))\n            test_logger.sysexit('Error with compilation: %s' % e)\n        except Exception:\n            raise\n        else:\n            assert os.path.exists(filename[:-3] + '.dist')\n            binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n            loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n            outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n            if outside_accesses:\n                displayError(None, filename)\n                displayRuntimeTraces(test_logger, binary_filename)\n                test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                search_mode.onErrorDetected(1)\n            if output[-1] != b'OK.':\n                my_print(' '.join(command))\n                my_print(filename)\n                my_print(output)\n                test_logger.sysexit('FAIL.')\n            my_print('OK.')\n            assert not outside_accesses, outside_accesses\n            shutil.rmtree(filename[:-3] + '.dist')\n    else:\n        my_print('SKIP (does not work with CPython)')",
            "def action(stage_dir, root, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n    filename = os.path.join(stage_dir, 'importer.py')\n    assert path.startswith(root)\n    module_name = path[len(root) + 1:]\n    module_name = module_name.split('.')[0]\n    module_name = module_name.replace(os.path.sep, '.')\n    module_name = ModuleName(module_name)\n    with openTextFile(filename, 'w') as output:\n        plugin_names = set(['pylint-warnings'])\n        if module_name.hasNamespace('PySide2'):\n            plugin_names.add('pyside2')\n        elif module_name.hasNamespace('PySide6'):\n            plugin_names.add('pyside6')\n        elif module_name.hasNamespace('PyQt5'):\n            plugin_names.add('pyqt5')\n        elif module_name.hasNamespace('PyQt6'):\n            plugin_names.add('pyqt6')\n        else:\n            plugin_names.add('no-qt')\n        for plugin_name in plugin_names:\n            output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n        output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n        output.write('# nuitka-project: --standalone\\n')\n        output.write('import ' + module_name.asString() + '\\n')\n        output.write(\"print('OK.')\")\n    command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n    command.append(filename)\n    if checkSucceedsWithCPython(filename):\n        try:\n            output = check_output(command).splitlines()\n        except NuitkaCalledProcessError as e:\n            my_print('SCRIPT:', filename, style='blue')\n            my_print(getFileContents(filename))\n            test_logger.sysexit('Error with compilation: %s' % e)\n        except Exception:\n            raise\n        else:\n            assert os.path.exists(filename[:-3] + '.dist')\n            binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n            loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n            outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n            if outside_accesses:\n                displayError(None, filename)\n                displayRuntimeTraces(test_logger, binary_filename)\n                test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                search_mode.onErrorDetected(1)\n            if output[-1] != b'OK.':\n                my_print(' '.join(command))\n                my_print(filename)\n                my_print(output)\n                test_logger.sysexit('FAIL.')\n            my_print('OK.')\n            assert not outside_accesses, outside_accesses\n            shutil.rmtree(filename[:-3] + '.dist')\n    else:\n        my_print('SKIP (does not work with CPython)')",
            "def action(stage_dir, root, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n    filename = os.path.join(stage_dir, 'importer.py')\n    assert path.startswith(root)\n    module_name = path[len(root) + 1:]\n    module_name = module_name.split('.')[0]\n    module_name = module_name.replace(os.path.sep, '.')\n    module_name = ModuleName(module_name)\n    with openTextFile(filename, 'w') as output:\n        plugin_names = set(['pylint-warnings'])\n        if module_name.hasNamespace('PySide2'):\n            plugin_names.add('pyside2')\n        elif module_name.hasNamespace('PySide6'):\n            plugin_names.add('pyside6')\n        elif module_name.hasNamespace('PyQt5'):\n            plugin_names.add('pyqt5')\n        elif module_name.hasNamespace('PyQt6'):\n            plugin_names.add('pyqt6')\n        else:\n            plugin_names.add('no-qt')\n        for plugin_name in plugin_names:\n            output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n        output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n        output.write('# nuitka-project: --standalone\\n')\n        output.write('import ' + module_name.asString() + '\\n')\n        output.write(\"print('OK.')\")\n    command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n    command.append(filename)\n    if checkSucceedsWithCPython(filename):\n        try:\n            output = check_output(command).splitlines()\n        except NuitkaCalledProcessError as e:\n            my_print('SCRIPT:', filename, style='blue')\n            my_print(getFileContents(filename))\n            test_logger.sysexit('Error with compilation: %s' % e)\n        except Exception:\n            raise\n        else:\n            assert os.path.exists(filename[:-3] + '.dist')\n            binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n            loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n            outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n            if outside_accesses:\n                displayError(None, filename)\n                displayRuntimeTraces(test_logger, binary_filename)\n                test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                search_mode.onErrorDetected(1)\n            if output[-1] != b'OK.':\n                my_print(' '.join(command))\n                my_print(filename)\n                my_print(output)\n                test_logger.sysexit('FAIL.')\n            my_print('OK.')\n            assert not outside_accesses, outside_accesses\n            shutil.rmtree(filename[:-3] + '.dist')\n    else:\n        my_print('SKIP (does not work with CPython)')",
            "def action(stage_dir, root, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n    filename = os.path.join(stage_dir, 'importer.py')\n    assert path.startswith(root)\n    module_name = path[len(root) + 1:]\n    module_name = module_name.split('.')[0]\n    module_name = module_name.replace(os.path.sep, '.')\n    module_name = ModuleName(module_name)\n    with openTextFile(filename, 'w') as output:\n        plugin_names = set(['pylint-warnings'])\n        if module_name.hasNamespace('PySide2'):\n            plugin_names.add('pyside2')\n        elif module_name.hasNamespace('PySide6'):\n            plugin_names.add('pyside6')\n        elif module_name.hasNamespace('PyQt5'):\n            plugin_names.add('pyqt5')\n        elif module_name.hasNamespace('PyQt6'):\n            plugin_names.add('pyqt6')\n        else:\n            plugin_names.add('no-qt')\n        for plugin_name in plugin_names:\n            output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n        output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n        output.write('# nuitka-project: --standalone\\n')\n        output.write('import ' + module_name.asString() + '\\n')\n        output.write(\"print('OK.')\")\n    command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n    command.append(filename)\n    if checkSucceedsWithCPython(filename):\n        try:\n            output = check_output(command).splitlines()\n        except NuitkaCalledProcessError as e:\n            my_print('SCRIPT:', filename, style='blue')\n            my_print(getFileContents(filename))\n            test_logger.sysexit('Error with compilation: %s' % e)\n        except Exception:\n            raise\n        else:\n            assert os.path.exists(filename[:-3] + '.dist')\n            binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n            loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n            outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n            if outside_accesses:\n                displayError(None, filename)\n                displayRuntimeTraces(test_logger, binary_filename)\n                test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                search_mode.onErrorDetected(1)\n            if output[-1] != b'OK.':\n                my_print(' '.join(command))\n                my_print(filename)\n                my_print(output)\n                test_logger.sysexit('FAIL.')\n            my_print('OK.')\n            assert not outside_accesses, outside_accesses\n            shutil.rmtree(filename[:-3] + '.dist')\n    else:\n        my_print('SKIP (does not work with CPython)')"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    setup(suite='extension_modules', needs_io_encoding=True)\n    search_mode = createSearchMode()\n    tmp_dir = getTempDir()\n    done = set()\n\n    def decide(root, filename):\n        if os.path.sep + 'Cython' + os.path.sep in root:\n            return False\n        if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n            return False\n        if filename.endswith('linux-gnu_d.so'):\n            return False\n        if root.endswith(os.path.sep + 'msgpack'):\n            return False\n        first_part = filename.split('.')[0]\n        if first_part in done:\n            return False\n        done.add(first_part)\n        return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))\n    current_dir = os.path.normpath(os.getcwd())\n    current_dir = os.path.normcase(current_dir)\n\n    def action(stage_dir, root, path):\n        command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n        filename = os.path.join(stage_dir, 'importer.py')\n        assert path.startswith(root)\n        module_name = path[len(root) + 1:]\n        module_name = module_name.split('.')[0]\n        module_name = module_name.replace(os.path.sep, '.')\n        module_name = ModuleName(module_name)\n        with openTextFile(filename, 'w') as output:\n            plugin_names = set(['pylint-warnings'])\n            if module_name.hasNamespace('PySide2'):\n                plugin_names.add('pyside2')\n            elif module_name.hasNamespace('PySide6'):\n                plugin_names.add('pyside6')\n            elif module_name.hasNamespace('PyQt5'):\n                plugin_names.add('pyqt5')\n            elif module_name.hasNamespace('PyQt6'):\n                plugin_names.add('pyqt6')\n            else:\n                plugin_names.add('no-qt')\n            for plugin_name in plugin_names:\n                output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n            output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n            output.write('# nuitka-project: --standalone\\n')\n            output.write('import ' + module_name.asString() + '\\n')\n            output.write(\"print('OK.')\")\n        command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n        command.append(filename)\n        if checkSucceedsWithCPython(filename):\n            try:\n                output = check_output(command).splitlines()\n            except NuitkaCalledProcessError as e:\n                my_print('SCRIPT:', filename, style='blue')\n                my_print(getFileContents(filename))\n                test_logger.sysexit('Error with compilation: %s' % e)\n            except Exception:\n                raise\n            else:\n                assert os.path.exists(filename[:-3] + '.dist')\n                binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n                loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n                outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n                if outside_accesses:\n                    displayError(None, filename)\n                    displayRuntimeTraces(test_logger, binary_filename)\n                    test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                    search_mode.onErrorDetected(1)\n                if output[-1] != b'OK.':\n                    my_print(' '.join(command))\n                    my_print(filename)\n                    my_print(output)\n                    test_logger.sysexit('FAIL.')\n                my_print('OK.')\n                assert not outside_accesses, outside_accesses\n                shutil.rmtree(filename[:-3] + '.dist')\n        else:\n            my_print('SKIP (does not work with CPython)')\n    compileLibraryTest(search_mode=search_mode, stage_dir=os.path.join(tmp_dir, 'compile_extensions'), decide=decide, action=action)\n    my_print('FINISHED, all extension modules compiled.')",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    setup(suite='extension_modules', needs_io_encoding=True)\n    search_mode = createSearchMode()\n    tmp_dir = getTempDir()\n    done = set()\n\n    def decide(root, filename):\n        if os.path.sep + 'Cython' + os.path.sep in root:\n            return False\n        if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n            return False\n        if filename.endswith('linux-gnu_d.so'):\n            return False\n        if root.endswith(os.path.sep + 'msgpack'):\n            return False\n        first_part = filename.split('.')[0]\n        if first_part in done:\n            return False\n        done.add(first_part)\n        return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))\n    current_dir = os.path.normpath(os.getcwd())\n    current_dir = os.path.normcase(current_dir)\n\n    def action(stage_dir, root, path):\n        command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n        filename = os.path.join(stage_dir, 'importer.py')\n        assert path.startswith(root)\n        module_name = path[len(root) + 1:]\n        module_name = module_name.split('.')[0]\n        module_name = module_name.replace(os.path.sep, '.')\n        module_name = ModuleName(module_name)\n        with openTextFile(filename, 'w') as output:\n            plugin_names = set(['pylint-warnings'])\n            if module_name.hasNamespace('PySide2'):\n                plugin_names.add('pyside2')\n            elif module_name.hasNamespace('PySide6'):\n                plugin_names.add('pyside6')\n            elif module_name.hasNamespace('PyQt5'):\n                plugin_names.add('pyqt5')\n            elif module_name.hasNamespace('PyQt6'):\n                plugin_names.add('pyqt6')\n            else:\n                plugin_names.add('no-qt')\n            for plugin_name in plugin_names:\n                output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n            output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n            output.write('# nuitka-project: --standalone\\n')\n            output.write('import ' + module_name.asString() + '\\n')\n            output.write(\"print('OK.')\")\n        command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n        command.append(filename)\n        if checkSucceedsWithCPython(filename):\n            try:\n                output = check_output(command).splitlines()\n            except NuitkaCalledProcessError as e:\n                my_print('SCRIPT:', filename, style='blue')\n                my_print(getFileContents(filename))\n                test_logger.sysexit('Error with compilation: %s' % e)\n            except Exception:\n                raise\n            else:\n                assert os.path.exists(filename[:-3] + '.dist')\n                binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n                loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n                outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n                if outside_accesses:\n                    displayError(None, filename)\n                    displayRuntimeTraces(test_logger, binary_filename)\n                    test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                    search_mode.onErrorDetected(1)\n                if output[-1] != b'OK.':\n                    my_print(' '.join(command))\n                    my_print(filename)\n                    my_print(output)\n                    test_logger.sysexit('FAIL.')\n                my_print('OK.')\n                assert not outside_accesses, outside_accesses\n                shutil.rmtree(filename[:-3] + '.dist')\n        else:\n            my_print('SKIP (does not work with CPython)')\n    compileLibraryTest(search_mode=search_mode, stage_dir=os.path.join(tmp_dir, 'compile_extensions'), decide=decide, action=action)\n    my_print('FINISHED, all extension modules compiled.')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    setup(suite='extension_modules', needs_io_encoding=True)\n    search_mode = createSearchMode()\n    tmp_dir = getTempDir()\n    done = set()\n\n    def decide(root, filename):\n        if os.path.sep + 'Cython' + os.path.sep in root:\n            return False\n        if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n            return False\n        if filename.endswith('linux-gnu_d.so'):\n            return False\n        if root.endswith(os.path.sep + 'msgpack'):\n            return False\n        first_part = filename.split('.')[0]\n        if first_part in done:\n            return False\n        done.add(first_part)\n        return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))\n    current_dir = os.path.normpath(os.getcwd())\n    current_dir = os.path.normcase(current_dir)\n\n    def action(stage_dir, root, path):\n        command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n        filename = os.path.join(stage_dir, 'importer.py')\n        assert path.startswith(root)\n        module_name = path[len(root) + 1:]\n        module_name = module_name.split('.')[0]\n        module_name = module_name.replace(os.path.sep, '.')\n        module_name = ModuleName(module_name)\n        with openTextFile(filename, 'w') as output:\n            plugin_names = set(['pylint-warnings'])\n            if module_name.hasNamespace('PySide2'):\n                plugin_names.add('pyside2')\n            elif module_name.hasNamespace('PySide6'):\n                plugin_names.add('pyside6')\n            elif module_name.hasNamespace('PyQt5'):\n                plugin_names.add('pyqt5')\n            elif module_name.hasNamespace('PyQt6'):\n                plugin_names.add('pyqt6')\n            else:\n                plugin_names.add('no-qt')\n            for plugin_name in plugin_names:\n                output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n            output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n            output.write('# nuitka-project: --standalone\\n')\n            output.write('import ' + module_name.asString() + '\\n')\n            output.write(\"print('OK.')\")\n        command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n        command.append(filename)\n        if checkSucceedsWithCPython(filename):\n            try:\n                output = check_output(command).splitlines()\n            except NuitkaCalledProcessError as e:\n                my_print('SCRIPT:', filename, style='blue')\n                my_print(getFileContents(filename))\n                test_logger.sysexit('Error with compilation: %s' % e)\n            except Exception:\n                raise\n            else:\n                assert os.path.exists(filename[:-3] + '.dist')\n                binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n                loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n                outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n                if outside_accesses:\n                    displayError(None, filename)\n                    displayRuntimeTraces(test_logger, binary_filename)\n                    test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                    search_mode.onErrorDetected(1)\n                if output[-1] != b'OK.':\n                    my_print(' '.join(command))\n                    my_print(filename)\n                    my_print(output)\n                    test_logger.sysexit('FAIL.')\n                my_print('OK.')\n                assert not outside_accesses, outside_accesses\n                shutil.rmtree(filename[:-3] + '.dist')\n        else:\n            my_print('SKIP (does not work with CPython)')\n    compileLibraryTest(search_mode=search_mode, stage_dir=os.path.join(tmp_dir, 'compile_extensions'), decide=decide, action=action)\n    my_print('FINISHED, all extension modules compiled.')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    setup(suite='extension_modules', needs_io_encoding=True)\n    search_mode = createSearchMode()\n    tmp_dir = getTempDir()\n    done = set()\n\n    def decide(root, filename):\n        if os.path.sep + 'Cython' + os.path.sep in root:\n            return False\n        if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n            return False\n        if filename.endswith('linux-gnu_d.so'):\n            return False\n        if root.endswith(os.path.sep + 'msgpack'):\n            return False\n        first_part = filename.split('.')[0]\n        if first_part in done:\n            return False\n        done.add(first_part)\n        return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))\n    current_dir = os.path.normpath(os.getcwd())\n    current_dir = os.path.normcase(current_dir)\n\n    def action(stage_dir, root, path):\n        command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n        filename = os.path.join(stage_dir, 'importer.py')\n        assert path.startswith(root)\n        module_name = path[len(root) + 1:]\n        module_name = module_name.split('.')[0]\n        module_name = module_name.replace(os.path.sep, '.')\n        module_name = ModuleName(module_name)\n        with openTextFile(filename, 'w') as output:\n            plugin_names = set(['pylint-warnings'])\n            if module_name.hasNamespace('PySide2'):\n                plugin_names.add('pyside2')\n            elif module_name.hasNamespace('PySide6'):\n                plugin_names.add('pyside6')\n            elif module_name.hasNamespace('PyQt5'):\n                plugin_names.add('pyqt5')\n            elif module_name.hasNamespace('PyQt6'):\n                plugin_names.add('pyqt6')\n            else:\n                plugin_names.add('no-qt')\n            for plugin_name in plugin_names:\n                output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n            output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n            output.write('# nuitka-project: --standalone\\n')\n            output.write('import ' + module_name.asString() + '\\n')\n            output.write(\"print('OK.')\")\n        command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n        command.append(filename)\n        if checkSucceedsWithCPython(filename):\n            try:\n                output = check_output(command).splitlines()\n            except NuitkaCalledProcessError as e:\n                my_print('SCRIPT:', filename, style='blue')\n                my_print(getFileContents(filename))\n                test_logger.sysexit('Error with compilation: %s' % e)\n            except Exception:\n                raise\n            else:\n                assert os.path.exists(filename[:-3] + '.dist')\n                binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n                loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n                outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n                if outside_accesses:\n                    displayError(None, filename)\n                    displayRuntimeTraces(test_logger, binary_filename)\n                    test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                    search_mode.onErrorDetected(1)\n                if output[-1] != b'OK.':\n                    my_print(' '.join(command))\n                    my_print(filename)\n                    my_print(output)\n                    test_logger.sysexit('FAIL.')\n                my_print('OK.')\n                assert not outside_accesses, outside_accesses\n                shutil.rmtree(filename[:-3] + '.dist')\n        else:\n            my_print('SKIP (does not work with CPython)')\n    compileLibraryTest(search_mode=search_mode, stage_dir=os.path.join(tmp_dir, 'compile_extensions'), decide=decide, action=action)\n    my_print('FINISHED, all extension modules compiled.')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    setup(suite='extension_modules', needs_io_encoding=True)\n    search_mode = createSearchMode()\n    tmp_dir = getTempDir()\n    done = set()\n\n    def decide(root, filename):\n        if os.path.sep + 'Cython' + os.path.sep in root:\n            return False\n        if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n            return False\n        if filename.endswith('linux-gnu_d.so'):\n            return False\n        if root.endswith(os.path.sep + 'msgpack'):\n            return False\n        first_part = filename.split('.')[0]\n        if first_part in done:\n            return False\n        done.add(first_part)\n        return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))\n    current_dir = os.path.normpath(os.getcwd())\n    current_dir = os.path.normcase(current_dir)\n\n    def action(stage_dir, root, path):\n        command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n        filename = os.path.join(stage_dir, 'importer.py')\n        assert path.startswith(root)\n        module_name = path[len(root) + 1:]\n        module_name = module_name.split('.')[0]\n        module_name = module_name.replace(os.path.sep, '.')\n        module_name = ModuleName(module_name)\n        with openTextFile(filename, 'w') as output:\n            plugin_names = set(['pylint-warnings'])\n            if module_name.hasNamespace('PySide2'):\n                plugin_names.add('pyside2')\n            elif module_name.hasNamespace('PySide6'):\n                plugin_names.add('pyside6')\n            elif module_name.hasNamespace('PyQt5'):\n                plugin_names.add('pyqt5')\n            elif module_name.hasNamespace('PyQt6'):\n                plugin_names.add('pyqt6')\n            else:\n                plugin_names.add('no-qt')\n            for plugin_name in plugin_names:\n                output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n            output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n            output.write('# nuitka-project: --standalone\\n')\n            output.write('import ' + module_name.asString() + '\\n')\n            output.write(\"print('OK.')\")\n        command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n        command.append(filename)\n        if checkSucceedsWithCPython(filename):\n            try:\n                output = check_output(command).splitlines()\n            except NuitkaCalledProcessError as e:\n                my_print('SCRIPT:', filename, style='blue')\n                my_print(getFileContents(filename))\n                test_logger.sysexit('Error with compilation: %s' % e)\n            except Exception:\n                raise\n            else:\n                assert os.path.exists(filename[:-3] + '.dist')\n                binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n                loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n                outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n                if outside_accesses:\n                    displayError(None, filename)\n                    displayRuntimeTraces(test_logger, binary_filename)\n                    test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                    search_mode.onErrorDetected(1)\n                if output[-1] != b'OK.':\n                    my_print(' '.join(command))\n                    my_print(filename)\n                    my_print(output)\n                    test_logger.sysexit('FAIL.')\n                my_print('OK.')\n                assert not outside_accesses, outside_accesses\n                shutil.rmtree(filename[:-3] + '.dist')\n        else:\n            my_print('SKIP (does not work with CPython)')\n    compileLibraryTest(search_mode=search_mode, stage_dir=os.path.join(tmp_dir, 'compile_extensions'), decide=decide, action=action)\n    my_print('FINISHED, all extension modules compiled.')",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    setup(suite='extension_modules', needs_io_encoding=True)\n    search_mode = createSearchMode()\n    tmp_dir = getTempDir()\n    done = set()\n\n    def decide(root, filename):\n        if os.path.sep + 'Cython' + os.path.sep in root:\n            return False\n        if root.endswith(os.path.sep + 'matplotlib') or os.path.sep + 'matplotlib' + os.path.sep in root:\n            return False\n        if filename.endswith('linux-gnu_d.so'):\n            return False\n        if root.endswith(os.path.sep + 'msgpack'):\n            return False\n        first_part = filename.split('.')[0]\n        if first_part in done:\n            return False\n        done.add(first_part)\n        return filename.endswith(('.so', '.pyd')) and (not filename.startswith('libpython'))\n    current_dir = os.path.normpath(os.getcwd())\n    current_dir = os.path.normcase(current_dir)\n\n    def action(stage_dir, root, path):\n        command = [sys.executable, os.path.join('..', '..', 'bin', 'nuitka'), '--stand', '--run', '--output-dir=%s' % stage_dir, '--remove-output', '--no-progressbar']\n        filename = os.path.join(stage_dir, 'importer.py')\n        assert path.startswith(root)\n        module_name = path[len(root) + 1:]\n        module_name = module_name.split('.')[0]\n        module_name = module_name.replace(os.path.sep, '.')\n        module_name = ModuleName(module_name)\n        with openTextFile(filename, 'w') as output:\n            plugin_names = set(['pylint-warnings'])\n            if module_name.hasNamespace('PySide2'):\n                plugin_names.add('pyside2')\n            elif module_name.hasNamespace('PySide6'):\n                plugin_names.add('pyside6')\n            elif module_name.hasNamespace('PyQt5'):\n                plugin_names.add('pyqt5')\n            elif module_name.hasNamespace('PyQt6'):\n                plugin_names.add('pyqt6')\n            else:\n                plugin_names.add('no-qt')\n            for plugin_name in plugin_names:\n                output.write('# nuitka-project: --enable-plugin=%s\\n' % plugin_name)\n            output.write('# nuitka-project: --noinclude-default-mode=error\\n')\n            output.write('# nuitka-project: --standalone\\n')\n            output.write('import ' + module_name.asString() + '\\n')\n            output.write(\"print('OK.')\")\n        command += os.environ.get('NUITKA_EXTRA_OPTIONS', '').split()\n        command.append(filename)\n        if checkSucceedsWithCPython(filename):\n            try:\n                output = check_output(command).splitlines()\n            except NuitkaCalledProcessError as e:\n                my_print('SCRIPT:', filename, style='blue')\n                my_print(getFileContents(filename))\n                test_logger.sysexit('Error with compilation: %s' % e)\n            except Exception:\n                raise\n            else:\n                assert os.path.exists(filename[:-3] + '.dist')\n                binary_filename = os.path.join(filename[:-3] + '.dist', 'importer.exe' if os.name == 'nt' else 'importer')\n                loaded_filenames = getRuntimeTraceOfLoadedFiles(logger=test_logger, command=[binary_filename])\n                outside_accesses = checkLoadedFileAccesses(loaded_filenames=loaded_filenames, current_dir=os.getcwd())\n                if outside_accesses:\n                    displayError(None, filename)\n                    displayRuntimeTraces(test_logger, binary_filename)\n                    test_logger.warning(\"Should not access these file(s): '%r'.\" % outside_accesses)\n                    search_mode.onErrorDetected(1)\n                if output[-1] != b'OK.':\n                    my_print(' '.join(command))\n                    my_print(filename)\n                    my_print(output)\n                    test_logger.sysexit('FAIL.')\n                my_print('OK.')\n                assert not outside_accesses, outside_accesses\n                shutil.rmtree(filename[:-3] + '.dist')\n        else:\n            my_print('SKIP (does not work with CPython)')\n    compileLibraryTest(search_mode=search_mode, stage_dir=os.path.join(tmp_dir, 'compile_extensions'), decide=decide, action=action)\n    my_print('FINISHED, all extension modules compiled.')"
        ]
    }
]