[
    {
        "func_name": "clear_border",
        "original": "def clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None):\n    \"\"\"Clear objects connected to the label image border.\n\n    Parameters\n    ----------\n    labels : (M[, N[, ..., P]]) array of int or bool\n        Imaging data labels.\n    buffer_size : int, optional\n        The width of the border examined.  By default, only objects\n        that touch the outside of the image are removed.\n    bgval : float or int, optional\n        Cleared objects are set to this value.\n    mask : ndarray of bool, same shape as `image`, optional.\n        Image data mask. Objects in labels image overlapping with\n        False pixels of mask will be removed. If defined, the\n        argument buffer_size will be ignored.\n    out : ndarray\n        Array of the same shape as `labels`, into which the\n        output is placed. By default, a new array is created.\n\n    Returns\n    -------\n    out : (M[, N[, ..., P]]) array\n        Imaging data labels with cleared borders\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage.segmentation import clear_border\n    >>> labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\n    ...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],\n    ...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],\n    ...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],\n    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],\n    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n    >>> clear_border(labels)\n    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n    >>> mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)\n    >>> clear_border(labels, mask=mask)\n    array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 1, 0, 0, 1, 0],\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n\n    \"\"\"\n    if any((buffer_size >= s for s in labels.shape)) and mask is None:\n        raise ValueError('buffer size may not be greater than labels size')\n    if out is None:\n        out = labels.copy()\n    if mask is not None:\n        err_msg = f'labels and mask should have the same shape but are {out.shape} and {mask.shape}'\n        if out.shape != mask.shape:\n            raise (ValueError, err_msg)\n        if mask.dtype != bool:\n            raise TypeError('mask should be of type bool.')\n        borders = ~mask\n    else:\n        borders = np.zeros_like(out, dtype=bool)\n        ext = buffer_size + 1\n        slstart = slice(ext)\n        slend = slice(-ext, None)\n        slices = [slice(None) for _ in out.shape]\n        for d in range(out.ndim):\n            slices[d] = slstart\n            borders[tuple(slices)] = True\n            slices[d] = slend\n            borders[tuple(slices)] = True\n            slices[d] = slice(None)\n    (labels, number) = label(out, background=0, return_num=True)\n    borders_indices = np.unique(labels[borders])\n    indices = np.arange(number + 1)\n    label_mask = np.isin(indices, borders_indices)\n    mask = label_mask[labels.reshape(-1)].reshape(labels.shape)\n    out[mask] = bgval\n    return out",
        "mutated": [
            "def clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None):\n    if False:\n        i = 10\n    'Clear objects connected to the label image border.\\n\\n    Parameters\\n    ----------\\n    labels : (M[, N[, ..., P]]) array of int or bool\\n        Imaging data labels.\\n    buffer_size : int, optional\\n        The width of the border examined.  By default, only objects\\n        that touch the outside of the image are removed.\\n    bgval : float or int, optional\\n        Cleared objects are set to this value.\\n    mask : ndarray of bool, same shape as `image`, optional.\\n        Image data mask. Objects in labels image overlapping with\\n        False pixels of mask will be removed. If defined, the\\n        argument buffer_size will be ignored.\\n    out : ndarray\\n        Array of the same shape as `labels`, into which the\\n        output is placed. By default, a new array is created.\\n\\n    Returns\\n    -------\\n    out : (M[, N[, ..., P]]) array\\n        Imaging data labels with cleared borders\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.segmentation import clear_border\\n    >>> labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],\\n    ...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> clear_border(labels)\\n    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)\\n    >>> clear_border(labels, mask=mask)\\n    array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 1, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n\\n    '\n    if any((buffer_size >= s for s in labels.shape)) and mask is None:\n        raise ValueError('buffer size may not be greater than labels size')\n    if out is None:\n        out = labels.copy()\n    if mask is not None:\n        err_msg = f'labels and mask should have the same shape but are {out.shape} and {mask.shape}'\n        if out.shape != mask.shape:\n            raise (ValueError, err_msg)\n        if mask.dtype != bool:\n            raise TypeError('mask should be of type bool.')\n        borders = ~mask\n    else:\n        borders = np.zeros_like(out, dtype=bool)\n        ext = buffer_size + 1\n        slstart = slice(ext)\n        slend = slice(-ext, None)\n        slices = [slice(None) for _ in out.shape]\n        for d in range(out.ndim):\n            slices[d] = slstart\n            borders[tuple(slices)] = True\n            slices[d] = slend\n            borders[tuple(slices)] = True\n            slices[d] = slice(None)\n    (labels, number) = label(out, background=0, return_num=True)\n    borders_indices = np.unique(labels[borders])\n    indices = np.arange(number + 1)\n    label_mask = np.isin(indices, borders_indices)\n    mask = label_mask[labels.reshape(-1)].reshape(labels.shape)\n    out[mask] = bgval\n    return out",
            "def clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Clear objects connected to the label image border.\\n\\n    Parameters\\n    ----------\\n    labels : (M[, N[, ..., P]]) array of int or bool\\n        Imaging data labels.\\n    buffer_size : int, optional\\n        The width of the border examined.  By default, only objects\\n        that touch the outside of the image are removed.\\n    bgval : float or int, optional\\n        Cleared objects are set to this value.\\n    mask : ndarray of bool, same shape as `image`, optional.\\n        Image data mask. Objects in labels image overlapping with\\n        False pixels of mask will be removed. If defined, the\\n        argument buffer_size will be ignored.\\n    out : ndarray\\n        Array of the same shape as `labels`, into which the\\n        output is placed. By default, a new array is created.\\n\\n    Returns\\n    -------\\n    out : (M[, N[, ..., P]]) array\\n        Imaging data labels with cleared borders\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.segmentation import clear_border\\n    >>> labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],\\n    ...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> clear_border(labels)\\n    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)\\n    >>> clear_border(labels, mask=mask)\\n    array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 1, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n\\n    '\n    if any((buffer_size >= s for s in labels.shape)) and mask is None:\n        raise ValueError('buffer size may not be greater than labels size')\n    if out is None:\n        out = labels.copy()\n    if mask is not None:\n        err_msg = f'labels and mask should have the same shape but are {out.shape} and {mask.shape}'\n        if out.shape != mask.shape:\n            raise (ValueError, err_msg)\n        if mask.dtype != bool:\n            raise TypeError('mask should be of type bool.')\n        borders = ~mask\n    else:\n        borders = np.zeros_like(out, dtype=bool)\n        ext = buffer_size + 1\n        slstart = slice(ext)\n        slend = slice(-ext, None)\n        slices = [slice(None) for _ in out.shape]\n        for d in range(out.ndim):\n            slices[d] = slstart\n            borders[tuple(slices)] = True\n            slices[d] = slend\n            borders[tuple(slices)] = True\n            slices[d] = slice(None)\n    (labels, number) = label(out, background=0, return_num=True)\n    borders_indices = np.unique(labels[borders])\n    indices = np.arange(number + 1)\n    label_mask = np.isin(indices, borders_indices)\n    mask = label_mask[labels.reshape(-1)].reshape(labels.shape)\n    out[mask] = bgval\n    return out",
            "def clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Clear objects connected to the label image border.\\n\\n    Parameters\\n    ----------\\n    labels : (M[, N[, ..., P]]) array of int or bool\\n        Imaging data labels.\\n    buffer_size : int, optional\\n        The width of the border examined.  By default, only objects\\n        that touch the outside of the image are removed.\\n    bgval : float or int, optional\\n        Cleared objects are set to this value.\\n    mask : ndarray of bool, same shape as `image`, optional.\\n        Image data mask. Objects in labels image overlapping with\\n        False pixels of mask will be removed. If defined, the\\n        argument buffer_size will be ignored.\\n    out : ndarray\\n        Array of the same shape as `labels`, into which the\\n        output is placed. By default, a new array is created.\\n\\n    Returns\\n    -------\\n    out : (M[, N[, ..., P]]) array\\n        Imaging data labels with cleared borders\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.segmentation import clear_border\\n    >>> labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],\\n    ...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> clear_border(labels)\\n    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)\\n    >>> clear_border(labels, mask=mask)\\n    array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 1, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n\\n    '\n    if any((buffer_size >= s for s in labels.shape)) and mask is None:\n        raise ValueError('buffer size may not be greater than labels size')\n    if out is None:\n        out = labels.copy()\n    if mask is not None:\n        err_msg = f'labels and mask should have the same shape but are {out.shape} and {mask.shape}'\n        if out.shape != mask.shape:\n            raise (ValueError, err_msg)\n        if mask.dtype != bool:\n            raise TypeError('mask should be of type bool.')\n        borders = ~mask\n    else:\n        borders = np.zeros_like(out, dtype=bool)\n        ext = buffer_size + 1\n        slstart = slice(ext)\n        slend = slice(-ext, None)\n        slices = [slice(None) for _ in out.shape]\n        for d in range(out.ndim):\n            slices[d] = slstart\n            borders[tuple(slices)] = True\n            slices[d] = slend\n            borders[tuple(slices)] = True\n            slices[d] = slice(None)\n    (labels, number) = label(out, background=0, return_num=True)\n    borders_indices = np.unique(labels[borders])\n    indices = np.arange(number + 1)\n    label_mask = np.isin(indices, borders_indices)\n    mask = label_mask[labels.reshape(-1)].reshape(labels.shape)\n    out[mask] = bgval\n    return out",
            "def clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Clear objects connected to the label image border.\\n\\n    Parameters\\n    ----------\\n    labels : (M[, N[, ..., P]]) array of int or bool\\n        Imaging data labels.\\n    buffer_size : int, optional\\n        The width of the border examined.  By default, only objects\\n        that touch the outside of the image are removed.\\n    bgval : float or int, optional\\n        Cleared objects are set to this value.\\n    mask : ndarray of bool, same shape as `image`, optional.\\n        Image data mask. Objects in labels image overlapping with\\n        False pixels of mask will be removed. If defined, the\\n        argument buffer_size will be ignored.\\n    out : ndarray\\n        Array of the same shape as `labels`, into which the\\n        output is placed. By default, a new array is created.\\n\\n    Returns\\n    -------\\n    out : (M[, N[, ..., P]]) array\\n        Imaging data labels with cleared borders\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.segmentation import clear_border\\n    >>> labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],\\n    ...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> clear_border(labels)\\n    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)\\n    >>> clear_border(labels, mask=mask)\\n    array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 1, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n\\n    '\n    if any((buffer_size >= s for s in labels.shape)) and mask is None:\n        raise ValueError('buffer size may not be greater than labels size')\n    if out is None:\n        out = labels.copy()\n    if mask is not None:\n        err_msg = f'labels and mask should have the same shape but are {out.shape} and {mask.shape}'\n        if out.shape != mask.shape:\n            raise (ValueError, err_msg)\n        if mask.dtype != bool:\n            raise TypeError('mask should be of type bool.')\n        borders = ~mask\n    else:\n        borders = np.zeros_like(out, dtype=bool)\n        ext = buffer_size + 1\n        slstart = slice(ext)\n        slend = slice(-ext, None)\n        slices = [slice(None) for _ in out.shape]\n        for d in range(out.ndim):\n            slices[d] = slstart\n            borders[tuple(slices)] = True\n            slices[d] = slend\n            borders[tuple(slices)] = True\n            slices[d] = slice(None)\n    (labels, number) = label(out, background=0, return_num=True)\n    borders_indices = np.unique(labels[borders])\n    indices = np.arange(number + 1)\n    label_mask = np.isin(indices, borders_indices)\n    mask = label_mask[labels.reshape(-1)].reshape(labels.shape)\n    out[mask] = bgval\n    return out",
            "def clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Clear objects connected to the label image border.\\n\\n    Parameters\\n    ----------\\n    labels : (M[, N[, ..., P]]) array of int or bool\\n        Imaging data labels.\\n    buffer_size : int, optional\\n        The width of the border examined.  By default, only objects\\n        that touch the outside of the image are removed.\\n    bgval : float or int, optional\\n        Cleared objects are set to this value.\\n    mask : ndarray of bool, same shape as `image`, optional.\\n        Image data mask. Objects in labels image overlapping with\\n        False pixels of mask will be removed. If defined, the\\n        argument buffer_size will be ignored.\\n    out : ndarray\\n        Array of the same shape as `labels`, into which the\\n        output is placed. By default, a new array is created.\\n\\n    Returns\\n    -------\\n    out : (M[, N[, ..., P]]) array\\n        Imaging data labels with cleared borders\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage.segmentation import clear_border\\n    >>> labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],\\n    ...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],\\n    ...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> clear_border(labels)\\n    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n    >>> mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)\\n    >>> clear_border(labels, mask=mask)\\n    array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\\n           [0, 0, 0, 0, 1, 0, 0, 1, 0],\\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\\n\\n    '\n    if any((buffer_size >= s for s in labels.shape)) and mask is None:\n        raise ValueError('buffer size may not be greater than labels size')\n    if out is None:\n        out = labels.copy()\n    if mask is not None:\n        err_msg = f'labels and mask should have the same shape but are {out.shape} and {mask.shape}'\n        if out.shape != mask.shape:\n            raise (ValueError, err_msg)\n        if mask.dtype != bool:\n            raise TypeError('mask should be of type bool.')\n        borders = ~mask\n    else:\n        borders = np.zeros_like(out, dtype=bool)\n        ext = buffer_size + 1\n        slstart = slice(ext)\n        slend = slice(-ext, None)\n        slices = [slice(None) for _ in out.shape]\n        for d in range(out.ndim):\n            slices[d] = slstart\n            borders[tuple(slices)] = True\n            slices[d] = slend\n            borders[tuple(slices)] = True\n            slices[d] = slice(None)\n    (labels, number) = label(out, background=0, return_num=True)\n    borders_indices = np.unique(labels[borders])\n    indices = np.arange(number + 1)\n    label_mask = np.isin(indices, borders_indices)\n    mask = label_mask[labels.reshape(-1)].reshape(labels.shape)\n    out[mask] = bgval\n    return out"
        ]
    }
]