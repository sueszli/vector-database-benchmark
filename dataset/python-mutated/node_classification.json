[
    {
        "func_name": "harmonic_function",
        "original": "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef harmonic_function(G, max_iter=30, label_name='label'):\n    \"\"\"Node classification by Harmonic function\n\n    Function for computing Harmonic function algorithm by Zhu et al.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n    max_iter : int\n        maximum number of iterations allowed\n    label_name : string\n        name of target labels to predict\n\n    Returns\n    -------\n    predicted : list\n        List of length ``len(G)`` with the predicted labels for each node.\n\n    Raises\n    ------\n    NetworkXError\n        If no nodes in `G` have attribute `label_name`.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import node_classification\n    >>> G = nx.path_graph(4)\n    >>> G.nodes[0][\"label\"] = \"A\"\n    >>> G.nodes[3][\"label\"] = \"B\"\n    >>> G.nodes(data=True)\n    NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})\n    >>> G.edges()\n    EdgeView([(0, 1), (1, 2), (2, 3)])\n    >>> predicted = node_classification.harmonic_function(G)\n    >>> predicted\n    ['A', 'A', 'B', 'B']\n\n    References\n    ----------\n    Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\n    Semi-supervised learning using gaussian fields and harmonic functions.\n    In ICML (Vol. 3, pp. 912-919).\n    \"\"\"\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D = sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0))\n    P = (D @ X).tolil()\n    P[labels[:, 0]] = 0\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
        "mutated": [
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef harmonic_function(G, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n    'Node classification by Harmonic function\\n\\n    Function for computing Harmonic function algorithm by Zhu et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    max_iter : int\\n        maximum number of iterations allowed\\n    label_name : string\\n        name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.harmonic_function(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\\n    Semi-supervised learning using gaussian fields and harmonic functions.\\n    In ICML (Vol. 3, pp. 912-919).\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D = sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0))\n    P = (D @ X).tolil()\n    P[labels[:, 0]] = 0\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef harmonic_function(G, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Node classification by Harmonic function\\n\\n    Function for computing Harmonic function algorithm by Zhu et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    max_iter : int\\n        maximum number of iterations allowed\\n    label_name : string\\n        name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.harmonic_function(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\\n    Semi-supervised learning using gaussian fields and harmonic functions.\\n    In ICML (Vol. 3, pp. 912-919).\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D = sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0))\n    P = (D @ X).tolil()\n    P[labels[:, 0]] = 0\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef harmonic_function(G, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Node classification by Harmonic function\\n\\n    Function for computing Harmonic function algorithm by Zhu et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    max_iter : int\\n        maximum number of iterations allowed\\n    label_name : string\\n        name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.harmonic_function(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\\n    Semi-supervised learning using gaussian fields and harmonic functions.\\n    In ICML (Vol. 3, pp. 912-919).\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D = sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0))\n    P = (D @ X).tolil()\n    P[labels[:, 0]] = 0\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef harmonic_function(G, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Node classification by Harmonic function\\n\\n    Function for computing Harmonic function algorithm by Zhu et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    max_iter : int\\n        maximum number of iterations allowed\\n    label_name : string\\n        name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.harmonic_function(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\\n    Semi-supervised learning using gaussian fields and harmonic functions.\\n    In ICML (Vol. 3, pp. 912-919).\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D = sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0))\n    P = (D @ X).tolil()\n    P[labels[:, 0]] = 0\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef harmonic_function(G, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Node classification by Harmonic function\\n\\n    Function for computing Harmonic function algorithm by Zhu et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    max_iter : int\\n        maximum number of iterations allowed\\n    label_name : string\\n        name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.harmonic_function(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\\n    Semi-supervised learning using gaussian fields and harmonic functions.\\n    In ICML (Vol. 3, pp. 912-919).\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D = sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0))\n    P = (D @ X).tolil()\n    P[labels[:, 0]] = 0\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()"
        ]
    },
    {
        "func_name": "local_and_global_consistency",
        "original": "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name='label'):\n    \"\"\"Node classification by Local and Global Consistency\n\n    Function for computing Local and global consistency algorithm by Zhou et al.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n    alpha : float\n        Clamping factor\n    max_iter : int\n        Maximum number of iterations allowed\n    label_name : string\n        Name of target labels to predict\n\n    Returns\n    -------\n    predicted : list\n        List of length ``len(G)`` with the predicted labels for each node.\n\n    Raises\n    ------\n    NetworkXError\n        If no nodes in `G` have attribute `label_name`.\n\n    Examples\n    --------\n    >>> from networkx.algorithms import node_classification\n    >>> G = nx.path_graph(4)\n    >>> G.nodes[0][\"label\"] = \"A\"\n    >>> G.nodes[3][\"label\"] = \"B\"\n    >>> G.nodes(data=True)\n    NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})\n    >>> G.edges()\n    EdgeView([(0, 1), (1, 2), (2, 3)])\n    >>> predicted = node_classification.local_and_global_consistency(G)\n    >>> predicted\n    ['A', 'A', 'B', 'B']\n\n    References\n    ----------\n    Zhou, D., Bousquet, O., Lal, T. N., Weston, J., & Sch\u00f6lkopf, B. (2004).\n    Learning with local and global consistency.\n    Advances in neural information processing systems, 16(16), 321-328.\n    \"\"\"\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D2 = np.sqrt(sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0)))\n    P = alpha * (D2 @ X @ D2)\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1 - alpha\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
        "mutated": [
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n    'Node classification by Local and Global Consistency\\n\\n    Function for computing Local and global consistency algorithm by Zhou et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    alpha : float\\n        Clamping factor\\n    max_iter : int\\n        Maximum number of iterations allowed\\n    label_name : string\\n        Name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.local_and_global_consistency(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhou, D., Bousquet, O., Lal, T. N., Weston, J., & Sch\u00f6lkopf, B. (2004).\\n    Learning with local and global consistency.\\n    Advances in neural information processing systems, 16(16), 321-328.\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D2 = np.sqrt(sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0)))\n    P = alpha * (D2 @ X @ D2)\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1 - alpha\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Node classification by Local and Global Consistency\\n\\n    Function for computing Local and global consistency algorithm by Zhou et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    alpha : float\\n        Clamping factor\\n    max_iter : int\\n        Maximum number of iterations allowed\\n    label_name : string\\n        Name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.local_and_global_consistency(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhou, D., Bousquet, O., Lal, T. N., Weston, J., & Sch\u00f6lkopf, B. (2004).\\n    Learning with local and global consistency.\\n    Advances in neural information processing systems, 16(16), 321-328.\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D2 = np.sqrt(sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0)))\n    P = alpha * (D2 @ X @ D2)\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1 - alpha\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Node classification by Local and Global Consistency\\n\\n    Function for computing Local and global consistency algorithm by Zhou et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    alpha : float\\n        Clamping factor\\n    max_iter : int\\n        Maximum number of iterations allowed\\n    label_name : string\\n        Name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.local_and_global_consistency(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhou, D., Bousquet, O., Lal, T. N., Weston, J., & Sch\u00f6lkopf, B. (2004).\\n    Learning with local and global consistency.\\n    Advances in neural information processing systems, 16(16), 321-328.\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D2 = np.sqrt(sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0)))\n    P = alpha * (D2 @ X @ D2)\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1 - alpha\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Node classification by Local and Global Consistency\\n\\n    Function for computing Local and global consistency algorithm by Zhou et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    alpha : float\\n        Clamping factor\\n    max_iter : int\\n        Maximum number of iterations allowed\\n    label_name : string\\n        Name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.local_and_global_consistency(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhou, D., Bousquet, O., Lal, T. N., Weston, J., & Sch\u00f6lkopf, B. (2004).\\n    Learning with local and global consistency.\\n    Advances in neural information processing systems, 16(16), 321-328.\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D2 = np.sqrt(sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0)))\n    P = alpha * (D2 @ X @ D2)\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1 - alpha\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()",
            "@nx.utils.not_implemented_for('directed')\n@nx._dispatch(node_attrs='label_name')\ndef local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name='label'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Node classification by Local and Global Consistency\\n\\n    Function for computing Local and global consistency algorithm by Zhou et al.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n    alpha : float\\n        Clamping factor\\n    max_iter : int\\n        Maximum number of iterations allowed\\n    label_name : string\\n        Name of target labels to predict\\n\\n    Returns\\n    -------\\n    predicted : list\\n        List of length ``len(G)`` with the predicted labels for each node.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If no nodes in `G` have attribute `label_name`.\\n\\n    Examples\\n    --------\\n    >>> from networkx.algorithms import node_classification\\n    >>> G = nx.path_graph(4)\\n    >>> G.nodes[0][\"label\"] = \"A\"\\n    >>> G.nodes[3][\"label\"] = \"B\"\\n    >>> G.nodes(data=True)\\n    NodeDataView({0: {\\'label\\': \\'A\\'}, 1: {}, 2: {}, 3: {\\'label\\': \\'B\\'}})\\n    >>> G.edges()\\n    EdgeView([(0, 1), (1, 2), (2, 3)])\\n    >>> predicted = node_classification.local_and_global_consistency(G)\\n    >>> predicted\\n    [\\'A\\', \\'A\\', \\'B\\', \\'B\\']\\n\\n    References\\n    ----------\\n    Zhou, D., Bousquet, O., Lal, T. N., Weston, J., & Sch\u00f6lkopf, B. (2004).\\n    Learning with local and global consistency.\\n    Advances in neural information processing systems, 16(16), 321-328.\\n    '\n    import numpy as np\n    import scipy as sp\n    X = nx.to_scipy_sparse_array(G)\n    (labels, label_dict) = _get_label_info(G, label_name)\n    if labels.shape[0] == 0:\n        raise nx.NetworkXError(f\"No node on the input graph is labeled by '{label_name}'.\")\n    n_samples = X.shape[0]\n    n_classes = label_dict.shape[0]\n    F = np.zeros((n_samples, n_classes))\n    degrees = X.sum(axis=0)\n    degrees[degrees == 0] = 1\n    D2 = np.sqrt(sp.sparse.csr_array(sp.sparse.diags(1.0 / degrees, offsets=0)))\n    P = alpha * (D2 @ X @ D2)\n    B = np.zeros((n_samples, n_classes))\n    B[labels[:, 0], labels[:, 1]] = 1 - alpha\n    for _ in range(max_iter):\n        F = P @ F + B\n    return label_dict[np.argmax(F, axis=1)].tolist()"
        ]
    },
    {
        "func_name": "_get_label_info",
        "original": "def _get_label_info(G, label_name):\n    \"\"\"Get and return information of labels from the input graph\n\n    Parameters\n    ----------\n    G : Network X graph\n    label_name : string\n        Name of the target label\n\n    Returns\n    -------\n    labels : numpy array, shape = [n_labeled_samples, 2]\n        Array of pairs of labeled node ID and label ID\n    label_dict : numpy array, shape = [n_classes]\n        Array of labels\n        i-th element contains the label corresponding label ID `i`\n    \"\"\"\n    import numpy as np\n    labels = []\n    label_to_id = {}\n    lid = 0\n    for (i, n) in enumerate(G.nodes(data=True)):\n        if label_name in n[1]:\n            label = n[1][label_name]\n            if label not in label_to_id:\n                label_to_id[label] = lid\n                lid += 1\n            labels.append([i, label_to_id[label]])\n    labels = np.array(labels)\n    label_dict = np.array([label for (label, _) in sorted(label_to_id.items(), key=lambda x: x[1])])\n    return (labels, label_dict)",
        "mutated": [
            "def _get_label_info(G, label_name):\n    if False:\n        i = 10\n    'Get and return information of labels from the input graph\\n\\n    Parameters\\n    ----------\\n    G : Network X graph\\n    label_name : string\\n        Name of the target label\\n\\n    Returns\\n    -------\\n    labels : numpy array, shape = [n_labeled_samples, 2]\\n        Array of pairs of labeled node ID and label ID\\n    label_dict : numpy array, shape = [n_classes]\\n        Array of labels\\n        i-th element contains the label corresponding label ID `i`\\n    '\n    import numpy as np\n    labels = []\n    label_to_id = {}\n    lid = 0\n    for (i, n) in enumerate(G.nodes(data=True)):\n        if label_name in n[1]:\n            label = n[1][label_name]\n            if label not in label_to_id:\n                label_to_id[label] = lid\n                lid += 1\n            labels.append([i, label_to_id[label]])\n    labels = np.array(labels)\n    label_dict = np.array([label for (label, _) in sorted(label_to_id.items(), key=lambda x: x[1])])\n    return (labels, label_dict)",
            "def _get_label_info(G, label_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get and return information of labels from the input graph\\n\\n    Parameters\\n    ----------\\n    G : Network X graph\\n    label_name : string\\n        Name of the target label\\n\\n    Returns\\n    -------\\n    labels : numpy array, shape = [n_labeled_samples, 2]\\n        Array of pairs of labeled node ID and label ID\\n    label_dict : numpy array, shape = [n_classes]\\n        Array of labels\\n        i-th element contains the label corresponding label ID `i`\\n    '\n    import numpy as np\n    labels = []\n    label_to_id = {}\n    lid = 0\n    for (i, n) in enumerate(G.nodes(data=True)):\n        if label_name in n[1]:\n            label = n[1][label_name]\n            if label not in label_to_id:\n                label_to_id[label] = lid\n                lid += 1\n            labels.append([i, label_to_id[label]])\n    labels = np.array(labels)\n    label_dict = np.array([label for (label, _) in sorted(label_to_id.items(), key=lambda x: x[1])])\n    return (labels, label_dict)",
            "def _get_label_info(G, label_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get and return information of labels from the input graph\\n\\n    Parameters\\n    ----------\\n    G : Network X graph\\n    label_name : string\\n        Name of the target label\\n\\n    Returns\\n    -------\\n    labels : numpy array, shape = [n_labeled_samples, 2]\\n        Array of pairs of labeled node ID and label ID\\n    label_dict : numpy array, shape = [n_classes]\\n        Array of labels\\n        i-th element contains the label corresponding label ID `i`\\n    '\n    import numpy as np\n    labels = []\n    label_to_id = {}\n    lid = 0\n    for (i, n) in enumerate(G.nodes(data=True)):\n        if label_name in n[1]:\n            label = n[1][label_name]\n            if label not in label_to_id:\n                label_to_id[label] = lid\n                lid += 1\n            labels.append([i, label_to_id[label]])\n    labels = np.array(labels)\n    label_dict = np.array([label for (label, _) in sorted(label_to_id.items(), key=lambda x: x[1])])\n    return (labels, label_dict)",
            "def _get_label_info(G, label_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get and return information of labels from the input graph\\n\\n    Parameters\\n    ----------\\n    G : Network X graph\\n    label_name : string\\n        Name of the target label\\n\\n    Returns\\n    -------\\n    labels : numpy array, shape = [n_labeled_samples, 2]\\n        Array of pairs of labeled node ID and label ID\\n    label_dict : numpy array, shape = [n_classes]\\n        Array of labels\\n        i-th element contains the label corresponding label ID `i`\\n    '\n    import numpy as np\n    labels = []\n    label_to_id = {}\n    lid = 0\n    for (i, n) in enumerate(G.nodes(data=True)):\n        if label_name in n[1]:\n            label = n[1][label_name]\n            if label not in label_to_id:\n                label_to_id[label] = lid\n                lid += 1\n            labels.append([i, label_to_id[label]])\n    labels = np.array(labels)\n    label_dict = np.array([label for (label, _) in sorted(label_to_id.items(), key=lambda x: x[1])])\n    return (labels, label_dict)",
            "def _get_label_info(G, label_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get and return information of labels from the input graph\\n\\n    Parameters\\n    ----------\\n    G : Network X graph\\n    label_name : string\\n        Name of the target label\\n\\n    Returns\\n    -------\\n    labels : numpy array, shape = [n_labeled_samples, 2]\\n        Array of pairs of labeled node ID and label ID\\n    label_dict : numpy array, shape = [n_classes]\\n        Array of labels\\n        i-th element contains the label corresponding label ID `i`\\n    '\n    import numpy as np\n    labels = []\n    label_to_id = {}\n    lid = 0\n    for (i, n) in enumerate(G.nodes(data=True)):\n        if label_name in n[1]:\n            label = n[1][label_name]\n            if label not in label_to_id:\n                label_to_id[label] = lid\n                lid += 1\n            labels.append([i, label_to_id[label]])\n    labels = np.array(labels)\n    label_dict = np.array([label for (label, _) in sorted(label_to_id.items(), key=lambda x: x[1])])\n    return (labels, label_dict)"
        ]
    }
]