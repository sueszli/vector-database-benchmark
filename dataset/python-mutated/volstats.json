[
    {
        "func_name": "__init__",
        "original": "def __init__(self, market_df=None, intraday_spot_df=None):\n    self._market_df = market_df\n    self._intraday_spot_df = intraday_spot_df\n    self._calculations = Calculations()\n    self._timezone = Timezone()\n    self._filter = Filter()",
        "mutated": [
            "def __init__(self, market_df=None, intraday_spot_df=None):\n    if False:\n        i = 10\n    self._market_df = market_df\n    self._intraday_spot_df = intraday_spot_df\n    self._calculations = Calculations()\n    self._timezone = Timezone()\n    self._filter = Filter()",
            "def __init__(self, market_df=None, intraday_spot_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._market_df = market_df\n    self._intraday_spot_df = intraday_spot_df\n    self._calculations = Calculations()\n    self._timezone = Timezone()\n    self._filter = Filter()",
            "def __init__(self, market_df=None, intraday_spot_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._market_df = market_df\n    self._intraday_spot_df = intraday_spot_df\n    self._calculations = Calculations()\n    self._timezone = Timezone()\n    self._filter = Filter()",
            "def __init__(self, market_df=None, intraday_spot_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._market_df = market_df\n    self._intraday_spot_df = intraday_spot_df\n    self._calculations = Calculations()\n    self._timezone = Timezone()\n    self._filter = Filter()",
            "def __init__(self, market_df=None, intraday_spot_df=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._market_df = market_df\n    self._intraday_spot_df = intraday_spot_df\n    self._calculations = Calculations()\n    self._timezone = Timezone()\n    self._filter = Filter()"
        ]
    },
    {
        "func_name": "calculate_realized_vol",
        "original": "def calculate_realized_vol(self, asset, spot_df=None, returns_df=None, tenor_label='ON', freq='daily', freq_min_mult=1, hour_of_day=10, minute_of_day=0, field='close', returns_calc='simple', timezone_hour_minute='America/New_York'):\n    \"\"\"Calculates rolling realized vol with daily cutoffs either using daily spot data or intraday spot data\n        (which is assumed to be in UTC timezone)\n\n        Parameters\n        ----------\n        asset : str\n            asset to be calculated\n\n        spot_df : pd.DataFrame\n            minute spot returns (freq_min_mult should be the same as the frequency and should have timezone set)\n\n        tenor_label : str\n            tenor to calculate\n\n        freq_min_mult : int\n            frequency multiply for data (1 = 1 min)\n\n        hour_of_day : closing time of data in the timezone specified\n            eg. 10 which is 1000 time (default = 10)\n\n        minute_of_day : closing time of data in the timezone specified\n            eg. 0 which is 0 time (default = 0)\n\n        field : str\n            By default 'close'\n\n        returns_calc : str\n            'simple' calculate simple returns\n            'log' calculate log returns\n\n        timezone_hour_minute : str\n            The timezone for the closing hour/minute (default: 'America/New_York')\n\n        Returns\n        -------\n        pd.DataFrame of realized volatility\n        \"\"\"\n    if returns_df is None:\n        if spot_df is None:\n            if freq == 'daily':\n                spot_df = self._market_df[asset + '.' + field]\n            else:\n                spot_df = self._intraday_spot_df[asset + '.' + field]\n        if returns_calc == 'simple':\n            returns_df = self._calculations.calculate_returns(spot_df)\n        else:\n            returns_df = self._calculations.calculate_log_returns(spot_df)\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if freq == 'intraday':\n        mult = int(1440.0 / float(freq_min_mult))\n        realized_rolling = self._calculations.rolling_volatility(returns_df, tenor_days * mult, obs_in_year=252 * mult)\n        realized_rolling = self._timezone.convert_index_aware_to_alt(realized_rolling, timezone_hour_minute)\n        realized_vol = self._filter.filter_time_series_by_time_of_day(hour_of_day, minute_of_day, realized_rolling)\n        realized_vol = self._timezone.convert_index_aware_to_UTC_time(realized_vol)\n        realized_vol = self._timezone.set_as_no_timezone(realized_vol)\n    elif freq == 'daily':\n        realized_vol = self._calculations.rolling_volatility(spot_df, tenor_days, obs_in_year=252)\n    realized_vol.index = realized_vol.index.date\n    realized_vol = pd.DataFrame(realized_vol)\n    realized_vol.columns = [asset + 'H' + tenor_label + '.close']\n    return realized_vol",
        "mutated": [
            "def calculate_realized_vol(self, asset, spot_df=None, returns_df=None, tenor_label='ON', freq='daily', freq_min_mult=1, hour_of_day=10, minute_of_day=0, field='close', returns_calc='simple', timezone_hour_minute='America/New_York'):\n    if False:\n        i = 10\n    \"Calculates rolling realized vol with daily cutoffs either using daily spot data or intraday spot data\\n        (which is assumed to be in UTC timezone)\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to be calculated\\n\\n        spot_df : pd.DataFrame\\n            minute spot returns (freq_min_mult should be the same as the frequency and should have timezone set)\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        freq_min_mult : int\\n            frequency multiply for data (1 = 1 min)\\n\\n        hour_of_day : closing time of data in the timezone specified\\n            eg. 10 which is 1000 time (default = 10)\\n\\n        minute_of_day : closing time of data in the timezone specified\\n            eg. 0 which is 0 time (default = 0)\\n\\n        field : str\\n            By default 'close'\\n\\n        returns_calc : str\\n            'simple' calculate simple returns\\n            'log' calculate log returns\\n\\n        timezone_hour_minute : str\\n            The timezone for the closing hour/minute (default: 'America/New_York')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of realized volatility\\n        \"\n    if returns_df is None:\n        if spot_df is None:\n            if freq == 'daily':\n                spot_df = self._market_df[asset + '.' + field]\n            else:\n                spot_df = self._intraday_spot_df[asset + '.' + field]\n        if returns_calc == 'simple':\n            returns_df = self._calculations.calculate_returns(spot_df)\n        else:\n            returns_df = self._calculations.calculate_log_returns(spot_df)\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if freq == 'intraday':\n        mult = int(1440.0 / float(freq_min_mult))\n        realized_rolling = self._calculations.rolling_volatility(returns_df, tenor_days * mult, obs_in_year=252 * mult)\n        realized_rolling = self._timezone.convert_index_aware_to_alt(realized_rolling, timezone_hour_minute)\n        realized_vol = self._filter.filter_time_series_by_time_of_day(hour_of_day, minute_of_day, realized_rolling)\n        realized_vol = self._timezone.convert_index_aware_to_UTC_time(realized_vol)\n        realized_vol = self._timezone.set_as_no_timezone(realized_vol)\n    elif freq == 'daily':\n        realized_vol = self._calculations.rolling_volatility(spot_df, tenor_days, obs_in_year=252)\n    realized_vol.index = realized_vol.index.date\n    realized_vol = pd.DataFrame(realized_vol)\n    realized_vol.columns = [asset + 'H' + tenor_label + '.close']\n    return realized_vol",
            "def calculate_realized_vol(self, asset, spot_df=None, returns_df=None, tenor_label='ON', freq='daily', freq_min_mult=1, hour_of_day=10, minute_of_day=0, field='close', returns_calc='simple', timezone_hour_minute='America/New_York'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Calculates rolling realized vol with daily cutoffs either using daily spot data or intraday spot data\\n        (which is assumed to be in UTC timezone)\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to be calculated\\n\\n        spot_df : pd.DataFrame\\n            minute spot returns (freq_min_mult should be the same as the frequency and should have timezone set)\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        freq_min_mult : int\\n            frequency multiply for data (1 = 1 min)\\n\\n        hour_of_day : closing time of data in the timezone specified\\n            eg. 10 which is 1000 time (default = 10)\\n\\n        minute_of_day : closing time of data in the timezone specified\\n            eg. 0 which is 0 time (default = 0)\\n\\n        field : str\\n            By default 'close'\\n\\n        returns_calc : str\\n            'simple' calculate simple returns\\n            'log' calculate log returns\\n\\n        timezone_hour_minute : str\\n            The timezone for the closing hour/minute (default: 'America/New_York')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of realized volatility\\n        \"\n    if returns_df is None:\n        if spot_df is None:\n            if freq == 'daily':\n                spot_df = self._market_df[asset + '.' + field]\n            else:\n                spot_df = self._intraday_spot_df[asset + '.' + field]\n        if returns_calc == 'simple':\n            returns_df = self._calculations.calculate_returns(spot_df)\n        else:\n            returns_df = self._calculations.calculate_log_returns(spot_df)\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if freq == 'intraday':\n        mult = int(1440.0 / float(freq_min_mult))\n        realized_rolling = self._calculations.rolling_volatility(returns_df, tenor_days * mult, obs_in_year=252 * mult)\n        realized_rolling = self._timezone.convert_index_aware_to_alt(realized_rolling, timezone_hour_minute)\n        realized_vol = self._filter.filter_time_series_by_time_of_day(hour_of_day, minute_of_day, realized_rolling)\n        realized_vol = self._timezone.convert_index_aware_to_UTC_time(realized_vol)\n        realized_vol = self._timezone.set_as_no_timezone(realized_vol)\n    elif freq == 'daily':\n        realized_vol = self._calculations.rolling_volatility(spot_df, tenor_days, obs_in_year=252)\n    realized_vol.index = realized_vol.index.date\n    realized_vol = pd.DataFrame(realized_vol)\n    realized_vol.columns = [asset + 'H' + tenor_label + '.close']\n    return realized_vol",
            "def calculate_realized_vol(self, asset, spot_df=None, returns_df=None, tenor_label='ON', freq='daily', freq_min_mult=1, hour_of_day=10, minute_of_day=0, field='close', returns_calc='simple', timezone_hour_minute='America/New_York'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Calculates rolling realized vol with daily cutoffs either using daily spot data or intraday spot data\\n        (which is assumed to be in UTC timezone)\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to be calculated\\n\\n        spot_df : pd.DataFrame\\n            minute spot returns (freq_min_mult should be the same as the frequency and should have timezone set)\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        freq_min_mult : int\\n            frequency multiply for data (1 = 1 min)\\n\\n        hour_of_day : closing time of data in the timezone specified\\n            eg. 10 which is 1000 time (default = 10)\\n\\n        minute_of_day : closing time of data in the timezone specified\\n            eg. 0 which is 0 time (default = 0)\\n\\n        field : str\\n            By default 'close'\\n\\n        returns_calc : str\\n            'simple' calculate simple returns\\n            'log' calculate log returns\\n\\n        timezone_hour_minute : str\\n            The timezone for the closing hour/minute (default: 'America/New_York')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of realized volatility\\n        \"\n    if returns_df is None:\n        if spot_df is None:\n            if freq == 'daily':\n                spot_df = self._market_df[asset + '.' + field]\n            else:\n                spot_df = self._intraday_spot_df[asset + '.' + field]\n        if returns_calc == 'simple':\n            returns_df = self._calculations.calculate_returns(spot_df)\n        else:\n            returns_df = self._calculations.calculate_log_returns(spot_df)\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if freq == 'intraday':\n        mult = int(1440.0 / float(freq_min_mult))\n        realized_rolling = self._calculations.rolling_volatility(returns_df, tenor_days * mult, obs_in_year=252 * mult)\n        realized_rolling = self._timezone.convert_index_aware_to_alt(realized_rolling, timezone_hour_minute)\n        realized_vol = self._filter.filter_time_series_by_time_of_day(hour_of_day, minute_of_day, realized_rolling)\n        realized_vol = self._timezone.convert_index_aware_to_UTC_time(realized_vol)\n        realized_vol = self._timezone.set_as_no_timezone(realized_vol)\n    elif freq == 'daily':\n        realized_vol = self._calculations.rolling_volatility(spot_df, tenor_days, obs_in_year=252)\n    realized_vol.index = realized_vol.index.date\n    realized_vol = pd.DataFrame(realized_vol)\n    realized_vol.columns = [asset + 'H' + tenor_label + '.close']\n    return realized_vol",
            "def calculate_realized_vol(self, asset, spot_df=None, returns_df=None, tenor_label='ON', freq='daily', freq_min_mult=1, hour_of_day=10, minute_of_day=0, field='close', returns_calc='simple', timezone_hour_minute='America/New_York'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Calculates rolling realized vol with daily cutoffs either using daily spot data or intraday spot data\\n        (which is assumed to be in UTC timezone)\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to be calculated\\n\\n        spot_df : pd.DataFrame\\n            minute spot returns (freq_min_mult should be the same as the frequency and should have timezone set)\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        freq_min_mult : int\\n            frequency multiply for data (1 = 1 min)\\n\\n        hour_of_day : closing time of data in the timezone specified\\n            eg. 10 which is 1000 time (default = 10)\\n\\n        minute_of_day : closing time of data in the timezone specified\\n            eg. 0 which is 0 time (default = 0)\\n\\n        field : str\\n            By default 'close'\\n\\n        returns_calc : str\\n            'simple' calculate simple returns\\n            'log' calculate log returns\\n\\n        timezone_hour_minute : str\\n            The timezone for the closing hour/minute (default: 'America/New_York')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of realized volatility\\n        \"\n    if returns_df is None:\n        if spot_df is None:\n            if freq == 'daily':\n                spot_df = self._market_df[asset + '.' + field]\n            else:\n                spot_df = self._intraday_spot_df[asset + '.' + field]\n        if returns_calc == 'simple':\n            returns_df = self._calculations.calculate_returns(spot_df)\n        else:\n            returns_df = self._calculations.calculate_log_returns(spot_df)\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if freq == 'intraday':\n        mult = int(1440.0 / float(freq_min_mult))\n        realized_rolling = self._calculations.rolling_volatility(returns_df, tenor_days * mult, obs_in_year=252 * mult)\n        realized_rolling = self._timezone.convert_index_aware_to_alt(realized_rolling, timezone_hour_minute)\n        realized_vol = self._filter.filter_time_series_by_time_of_day(hour_of_day, minute_of_day, realized_rolling)\n        realized_vol = self._timezone.convert_index_aware_to_UTC_time(realized_vol)\n        realized_vol = self._timezone.set_as_no_timezone(realized_vol)\n    elif freq == 'daily':\n        realized_vol = self._calculations.rolling_volatility(spot_df, tenor_days, obs_in_year=252)\n    realized_vol.index = realized_vol.index.date\n    realized_vol = pd.DataFrame(realized_vol)\n    realized_vol.columns = [asset + 'H' + tenor_label + '.close']\n    return realized_vol",
            "def calculate_realized_vol(self, asset, spot_df=None, returns_df=None, tenor_label='ON', freq='daily', freq_min_mult=1, hour_of_day=10, minute_of_day=0, field='close', returns_calc='simple', timezone_hour_minute='America/New_York'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Calculates rolling realized vol with daily cutoffs either using daily spot data or intraday spot data\\n        (which is assumed to be in UTC timezone)\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to be calculated\\n\\n        spot_df : pd.DataFrame\\n            minute spot returns (freq_min_mult should be the same as the frequency and should have timezone set)\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        freq_min_mult : int\\n            frequency multiply for data (1 = 1 min)\\n\\n        hour_of_day : closing time of data in the timezone specified\\n            eg. 10 which is 1000 time (default = 10)\\n\\n        minute_of_day : closing time of data in the timezone specified\\n            eg. 0 which is 0 time (default = 0)\\n\\n        field : str\\n            By default 'close'\\n\\n        returns_calc : str\\n            'simple' calculate simple returns\\n            'log' calculate log returns\\n\\n        timezone_hour_minute : str\\n            The timezone for the closing hour/minute (default: 'America/New_York')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of realized volatility\\n        \"\n    if returns_df is None:\n        if spot_df is None:\n            if freq == 'daily':\n                spot_df = self._market_df[asset + '.' + field]\n            else:\n                spot_df = self._intraday_spot_df[asset + '.' + field]\n        if returns_calc == 'simple':\n            returns_df = self._calculations.calculate_returns(spot_df)\n        else:\n            returns_df = self._calculations.calculate_log_returns(spot_df)\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if freq == 'intraday':\n        mult = int(1440.0 / float(freq_min_mult))\n        realized_rolling = self._calculations.rolling_volatility(returns_df, tenor_days * mult, obs_in_year=252 * mult)\n        realized_rolling = self._timezone.convert_index_aware_to_alt(realized_rolling, timezone_hour_minute)\n        realized_vol = self._filter.filter_time_series_by_time_of_day(hour_of_day, minute_of_day, realized_rolling)\n        realized_vol = self._timezone.convert_index_aware_to_UTC_time(realized_vol)\n        realized_vol = self._timezone.set_as_no_timezone(realized_vol)\n    elif freq == 'daily':\n        realized_vol = self._calculations.rolling_volatility(spot_df, tenor_days, obs_in_year=252)\n    realized_vol.index = realized_vol.index.date\n    realized_vol = pd.DataFrame(realized_vol)\n    realized_vol.columns = [asset + 'H' + tenor_label + '.close']\n    return realized_vol"
        ]
    },
    {
        "func_name": "calculate_vol_risk_premium",
        "original": "def calculate_vol_risk_premium(self, asset, tenor_label='ON', implied_vol=None, realized_vol=None, field='close', adj_ON_friday=False):\n    \"\"\"Calculates volatility risk premium given implied and realized quotes (ie. implied - realized) and tenor\n\n        Calculates both a version which is aligned (VRP), where the implied and realized volatilities cover\n        the same period (note: you will have a gap for recent points, where you can't grab future implied volatilities),\n        and an unaligned version (VRPV), which is the typical one used in the market\n\n        Parameters\n        ----------\n        asset : str\n            asset to calculate value for\n\n        tenor_label : str\n            tenor to calculate\n\n        implied_vol : pd.DataFrame\n            implied vol quotes where columns are of the form eg. EURUSDV1M.close\n\n        realized_vol : pd.DataFrame\n            realized vol eg. EURUSDH1M.close\n\n        field : str\n            the field of the data to use (default: 'close')\n\n        Returns\n        -------\n        pd.DataFrame of vrp (both lagged - VRPV & contemporanous - VRP)\n        \"\"\"\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.copy(deep=True)\n    implied_unaligned = implied_vol.copy(deep=True)\n    cols_to_change = implied_vol.columns.values\n    new_cols = []\n    for i in range(0, len(cols_to_change)):\n        temp_col = list(cols_to_change[i])\n        temp_col[6] = 'U'\n        new_cols.append(''.join(temp_col))\n    implied_vol.columns = new_cols\n    implied_vol.index = [pd.Timestamp(x) + pd.tseries.offsets.BDay(tenor_days) for x in implied_vol.index]\n    vrp = implied_vol.join(realized_vol, how='outer')\n    vrp[asset + 'VRP' + tenor_label + '.close'] = vrp[asset + 'U' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    vrp = vrp.join(implied_unaligned, how='outer')\n    vrp[asset + 'VRPV' + tenor_label + '.close'] = vrp[asset + 'V' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    return vrp",
        "mutated": [
            "def calculate_vol_risk_premium(self, asset, tenor_label='ON', implied_vol=None, realized_vol=None, field='close', adj_ON_friday=False):\n    if False:\n        i = 10\n    \"Calculates volatility risk premium given implied and realized quotes (ie. implied - realized) and tenor\\n\\n        Calculates both a version which is aligned (VRP), where the implied and realized volatilities cover\\n        the same period (note: you will have a gap for recent points, where you can't grab future implied volatilities),\\n        and an unaligned version (VRPV), which is the typical one used in the market\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to calculate value for\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        implied_vol : pd.DataFrame\\n            implied vol quotes where columns are of the form eg. EURUSDV1M.close\\n\\n        realized_vol : pd.DataFrame\\n            realized vol eg. EURUSDH1M.close\\n\\n        field : str\\n            the field of the data to use (default: 'close')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of vrp (both lagged - VRPV & contemporanous - VRP)\\n        \"\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.copy(deep=True)\n    implied_unaligned = implied_vol.copy(deep=True)\n    cols_to_change = implied_vol.columns.values\n    new_cols = []\n    for i in range(0, len(cols_to_change)):\n        temp_col = list(cols_to_change[i])\n        temp_col[6] = 'U'\n        new_cols.append(''.join(temp_col))\n    implied_vol.columns = new_cols\n    implied_vol.index = [pd.Timestamp(x) + pd.tseries.offsets.BDay(tenor_days) for x in implied_vol.index]\n    vrp = implied_vol.join(realized_vol, how='outer')\n    vrp[asset + 'VRP' + tenor_label + '.close'] = vrp[asset + 'U' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    vrp = vrp.join(implied_unaligned, how='outer')\n    vrp[asset + 'VRPV' + tenor_label + '.close'] = vrp[asset + 'V' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    return vrp",
            "def calculate_vol_risk_premium(self, asset, tenor_label='ON', implied_vol=None, realized_vol=None, field='close', adj_ON_friday=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Calculates volatility risk premium given implied and realized quotes (ie. implied - realized) and tenor\\n\\n        Calculates both a version which is aligned (VRP), where the implied and realized volatilities cover\\n        the same period (note: you will have a gap for recent points, where you can't grab future implied volatilities),\\n        and an unaligned version (VRPV), which is the typical one used in the market\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to calculate value for\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        implied_vol : pd.DataFrame\\n            implied vol quotes where columns are of the form eg. EURUSDV1M.close\\n\\n        realized_vol : pd.DataFrame\\n            realized vol eg. EURUSDH1M.close\\n\\n        field : str\\n            the field of the data to use (default: 'close')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of vrp (both lagged - VRPV & contemporanous - VRP)\\n        \"\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.copy(deep=True)\n    implied_unaligned = implied_vol.copy(deep=True)\n    cols_to_change = implied_vol.columns.values\n    new_cols = []\n    for i in range(0, len(cols_to_change)):\n        temp_col = list(cols_to_change[i])\n        temp_col[6] = 'U'\n        new_cols.append(''.join(temp_col))\n    implied_vol.columns = new_cols\n    implied_vol.index = [pd.Timestamp(x) + pd.tseries.offsets.BDay(tenor_days) for x in implied_vol.index]\n    vrp = implied_vol.join(realized_vol, how='outer')\n    vrp[asset + 'VRP' + tenor_label + '.close'] = vrp[asset + 'U' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    vrp = vrp.join(implied_unaligned, how='outer')\n    vrp[asset + 'VRPV' + tenor_label + '.close'] = vrp[asset + 'V' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    return vrp",
            "def calculate_vol_risk_premium(self, asset, tenor_label='ON', implied_vol=None, realized_vol=None, field='close', adj_ON_friday=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Calculates volatility risk premium given implied and realized quotes (ie. implied - realized) and tenor\\n\\n        Calculates both a version which is aligned (VRP), where the implied and realized volatilities cover\\n        the same period (note: you will have a gap for recent points, where you can't grab future implied volatilities),\\n        and an unaligned version (VRPV), which is the typical one used in the market\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to calculate value for\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        implied_vol : pd.DataFrame\\n            implied vol quotes where columns are of the form eg. EURUSDV1M.close\\n\\n        realized_vol : pd.DataFrame\\n            realized vol eg. EURUSDH1M.close\\n\\n        field : str\\n            the field of the data to use (default: 'close')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of vrp (both lagged - VRPV & contemporanous - VRP)\\n        \"\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.copy(deep=True)\n    implied_unaligned = implied_vol.copy(deep=True)\n    cols_to_change = implied_vol.columns.values\n    new_cols = []\n    for i in range(0, len(cols_to_change)):\n        temp_col = list(cols_to_change[i])\n        temp_col[6] = 'U'\n        new_cols.append(''.join(temp_col))\n    implied_vol.columns = new_cols\n    implied_vol.index = [pd.Timestamp(x) + pd.tseries.offsets.BDay(tenor_days) for x in implied_vol.index]\n    vrp = implied_vol.join(realized_vol, how='outer')\n    vrp[asset + 'VRP' + tenor_label + '.close'] = vrp[asset + 'U' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    vrp = vrp.join(implied_unaligned, how='outer')\n    vrp[asset + 'VRPV' + tenor_label + '.close'] = vrp[asset + 'V' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    return vrp",
            "def calculate_vol_risk_premium(self, asset, tenor_label='ON', implied_vol=None, realized_vol=None, field='close', adj_ON_friday=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Calculates volatility risk premium given implied and realized quotes (ie. implied - realized) and tenor\\n\\n        Calculates both a version which is aligned (VRP), where the implied and realized volatilities cover\\n        the same period (note: you will have a gap for recent points, where you can't grab future implied volatilities),\\n        and an unaligned version (VRPV), which is the typical one used in the market\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to calculate value for\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        implied_vol : pd.DataFrame\\n            implied vol quotes where columns are of the form eg. EURUSDV1M.close\\n\\n        realized_vol : pd.DataFrame\\n            realized vol eg. EURUSDH1M.close\\n\\n        field : str\\n            the field of the data to use (default: 'close')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of vrp (both lagged - VRPV & contemporanous - VRP)\\n        \"\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.copy(deep=True)\n    implied_unaligned = implied_vol.copy(deep=True)\n    cols_to_change = implied_vol.columns.values\n    new_cols = []\n    for i in range(0, len(cols_to_change)):\n        temp_col = list(cols_to_change[i])\n        temp_col[6] = 'U'\n        new_cols.append(''.join(temp_col))\n    implied_vol.columns = new_cols\n    implied_vol.index = [pd.Timestamp(x) + pd.tseries.offsets.BDay(tenor_days) for x in implied_vol.index]\n    vrp = implied_vol.join(realized_vol, how='outer')\n    vrp[asset + 'VRP' + tenor_label + '.close'] = vrp[asset + 'U' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    vrp = vrp.join(implied_unaligned, how='outer')\n    vrp[asset + 'VRPV' + tenor_label + '.close'] = vrp[asset + 'V' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    return vrp",
            "def calculate_vol_risk_premium(self, asset, tenor_label='ON', implied_vol=None, realized_vol=None, field='close', adj_ON_friday=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Calculates volatility risk premium given implied and realized quotes (ie. implied - realized) and tenor\\n\\n        Calculates both a version which is aligned (VRP), where the implied and realized volatilities cover\\n        the same period (note: you will have a gap for recent points, where you can't grab future implied volatilities),\\n        and an unaligned version (VRPV), which is the typical one used in the market\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            asset to calculate value for\\n\\n        tenor_label : str\\n            tenor to calculate\\n\\n        implied_vol : pd.DataFrame\\n            implied vol quotes where columns are of the form eg. EURUSDV1M.close\\n\\n        realized_vol : pd.DataFrame\\n            realized vol eg. EURUSDH1M.close\\n\\n        field : str\\n            the field of the data to use (default: 'close')\\n\\n        Returns\\n        -------\\n        pd.DataFrame of vrp (both lagged - VRPV & contemporanous - VRP)\\n        \"\n    cal = Calendar()\n    tenor_days = cal.get_business_days_tenor(tenor_label)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.copy(deep=True)\n    implied_unaligned = implied_vol.copy(deep=True)\n    cols_to_change = implied_vol.columns.values\n    new_cols = []\n    for i in range(0, len(cols_to_change)):\n        temp_col = list(cols_to_change[i])\n        temp_col[6] = 'U'\n        new_cols.append(''.join(temp_col))\n    implied_vol.columns = new_cols\n    implied_vol.index = [pd.Timestamp(x) + pd.tseries.offsets.BDay(tenor_days) for x in implied_vol.index]\n    vrp = implied_vol.join(realized_vol, how='outer')\n    vrp[asset + 'VRP' + tenor_label + '.close'] = vrp[asset + 'U' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    vrp = vrp.join(implied_unaligned, how='outer')\n    vrp[asset + 'VRPV' + tenor_label + '.close'] = vrp[asset + 'V' + tenor_label + '.' + field] - vrp[asset + 'H' + tenor_label + '.' + field]\n    return vrp"
        ]
    },
    {
        "func_name": "calculate_implied_vol_addon",
        "original": "def calculate_implied_vol_addon(self, asset, implied_vol=None, tenor_label='ON', model_window=20, model_algo='weighted-median-model', field='close', adj_ON_friday=True):\n    \"\"\"Calculates the implied volatility add on for specific tenors. The implied volatility addon can be seen as\n        a proxy for the event weights of large scheduled events for that day, such as the US employment report.\n\n        If there are multiple large events in the same period covered by the option, then this approach is not going\n        to be able to disentangle this.\n\n        Parameters\n        ----------\n        asset : str\n            Asset to be traded (eg. EURUSD)\n\n        tenor: str\n            eg. ON\n\n        Returns\n        ------\n        Implied volatility addon\n        \"\"\"\n    part = 'V'\n    if implied_vol is None:\n        implied_vol = self._market_df[asset + 'V' + tenor_label + '.' + field]\n    implied_vol = implied_vol.copy(deep=True)\n    implied_vol = pd.DataFrame(implied_vol)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.dropna()\n    if model_algo == 'weighted-median-model':\n        vol_data_20D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    elif model_algo == 'weighted-mean-model':\n        vol_data_20D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    vol_data_addon = pd.DataFrame(vol_data_addon)\n    implied_vol = pd.DataFrame(implied_vol)\n    new_cols = implied_vol.columns.values\n    new_cols = [w.replace(part + tenor_label, 'ADD' + tenor_label) for w in new_cols]\n    vol_data_addon.columns = new_cols\n    return vol_data_addon",
        "mutated": [
            "def calculate_implied_vol_addon(self, asset, implied_vol=None, tenor_label='ON', model_window=20, model_algo='weighted-median-model', field='close', adj_ON_friday=True):\n    if False:\n        i = 10\n    'Calculates the implied volatility add on for specific tenors. The implied volatility addon can be seen as\\n        a proxy for the event weights of large scheduled events for that day, such as the US employment report.\\n\\n        If there are multiple large events in the same period covered by the option, then this approach is not going\\n        to be able to disentangle this.\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            Asset to be traded (eg. EURUSD)\\n\\n        tenor: str\\n            eg. ON\\n\\n        Returns\\n        ------\\n        Implied volatility addon\\n        '\n    part = 'V'\n    if implied_vol is None:\n        implied_vol = self._market_df[asset + 'V' + tenor_label + '.' + field]\n    implied_vol = implied_vol.copy(deep=True)\n    implied_vol = pd.DataFrame(implied_vol)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.dropna()\n    if model_algo == 'weighted-median-model':\n        vol_data_20D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    elif model_algo == 'weighted-mean-model':\n        vol_data_20D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    vol_data_addon = pd.DataFrame(vol_data_addon)\n    implied_vol = pd.DataFrame(implied_vol)\n    new_cols = implied_vol.columns.values\n    new_cols = [w.replace(part + tenor_label, 'ADD' + tenor_label) for w in new_cols]\n    vol_data_addon.columns = new_cols\n    return vol_data_addon",
            "def calculate_implied_vol_addon(self, asset, implied_vol=None, tenor_label='ON', model_window=20, model_algo='weighted-median-model', field='close', adj_ON_friday=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculates the implied volatility add on for specific tenors. The implied volatility addon can be seen as\\n        a proxy for the event weights of large scheduled events for that day, such as the US employment report.\\n\\n        If there are multiple large events in the same period covered by the option, then this approach is not going\\n        to be able to disentangle this.\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            Asset to be traded (eg. EURUSD)\\n\\n        tenor: str\\n            eg. ON\\n\\n        Returns\\n        ------\\n        Implied volatility addon\\n        '\n    part = 'V'\n    if implied_vol is None:\n        implied_vol = self._market_df[asset + 'V' + tenor_label + '.' + field]\n    implied_vol = implied_vol.copy(deep=True)\n    implied_vol = pd.DataFrame(implied_vol)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.dropna()\n    if model_algo == 'weighted-median-model':\n        vol_data_20D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    elif model_algo == 'weighted-mean-model':\n        vol_data_20D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    vol_data_addon = pd.DataFrame(vol_data_addon)\n    implied_vol = pd.DataFrame(implied_vol)\n    new_cols = implied_vol.columns.values\n    new_cols = [w.replace(part + tenor_label, 'ADD' + tenor_label) for w in new_cols]\n    vol_data_addon.columns = new_cols\n    return vol_data_addon",
            "def calculate_implied_vol_addon(self, asset, implied_vol=None, tenor_label='ON', model_window=20, model_algo='weighted-median-model', field='close', adj_ON_friday=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculates the implied volatility add on for specific tenors. The implied volatility addon can be seen as\\n        a proxy for the event weights of large scheduled events for that day, such as the US employment report.\\n\\n        If there are multiple large events in the same period covered by the option, then this approach is not going\\n        to be able to disentangle this.\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            Asset to be traded (eg. EURUSD)\\n\\n        tenor: str\\n            eg. ON\\n\\n        Returns\\n        ------\\n        Implied volatility addon\\n        '\n    part = 'V'\n    if implied_vol is None:\n        implied_vol = self._market_df[asset + 'V' + tenor_label + '.' + field]\n    implied_vol = implied_vol.copy(deep=True)\n    implied_vol = pd.DataFrame(implied_vol)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.dropna()\n    if model_algo == 'weighted-median-model':\n        vol_data_20D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    elif model_algo == 'weighted-mean-model':\n        vol_data_20D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    vol_data_addon = pd.DataFrame(vol_data_addon)\n    implied_vol = pd.DataFrame(implied_vol)\n    new_cols = implied_vol.columns.values\n    new_cols = [w.replace(part + tenor_label, 'ADD' + tenor_label) for w in new_cols]\n    vol_data_addon.columns = new_cols\n    return vol_data_addon",
            "def calculate_implied_vol_addon(self, asset, implied_vol=None, tenor_label='ON', model_window=20, model_algo='weighted-median-model', field='close', adj_ON_friday=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculates the implied volatility add on for specific tenors. The implied volatility addon can be seen as\\n        a proxy for the event weights of large scheduled events for that day, such as the US employment report.\\n\\n        If there are multiple large events in the same period covered by the option, then this approach is not going\\n        to be able to disentangle this.\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            Asset to be traded (eg. EURUSD)\\n\\n        tenor: str\\n            eg. ON\\n\\n        Returns\\n        ------\\n        Implied volatility addon\\n        '\n    part = 'V'\n    if implied_vol is None:\n        implied_vol = self._market_df[asset + 'V' + tenor_label + '.' + field]\n    implied_vol = implied_vol.copy(deep=True)\n    implied_vol = pd.DataFrame(implied_vol)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.dropna()\n    if model_algo == 'weighted-median-model':\n        vol_data_20D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    elif model_algo == 'weighted-mean-model':\n        vol_data_20D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    vol_data_addon = pd.DataFrame(vol_data_addon)\n    implied_vol = pd.DataFrame(implied_vol)\n    new_cols = implied_vol.columns.values\n    new_cols = [w.replace(part + tenor_label, 'ADD' + tenor_label) for w in new_cols]\n    vol_data_addon.columns = new_cols\n    return vol_data_addon",
            "def calculate_implied_vol_addon(self, asset, implied_vol=None, tenor_label='ON', model_window=20, model_algo='weighted-median-model', field='close', adj_ON_friday=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculates the implied volatility add on for specific tenors. The implied volatility addon can be seen as\\n        a proxy for the event weights of large scheduled events for that day, such as the US employment report.\\n\\n        If there are multiple large events in the same period covered by the option, then this approach is not going\\n        to be able to disentangle this.\\n\\n        Parameters\\n        ----------\\n        asset : str\\n            Asset to be traded (eg. EURUSD)\\n\\n        tenor: str\\n            eg. ON\\n\\n        Returns\\n        ------\\n        Implied volatility addon\\n        '\n    part = 'V'\n    if implied_vol is None:\n        implied_vol = self._market_df[asset + 'V' + tenor_label + '.' + field]\n    implied_vol = implied_vol.copy(deep=True)\n    implied_vol = pd.DataFrame(implied_vol)\n    if tenor_label == 'ON' and adj_ON_friday:\n        implied_vol = self.adjust_implied_ON_fri_vol(implied_vol)\n    implied_vol = implied_vol.dropna()\n    if model_algo == 'weighted-median-model':\n        vol_data_20D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_median(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    elif model_algo == 'weighted-mean-model':\n        vol_data_20D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_10D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_5D_avg = self._calculations.rolling_average(implied_vol, model_window)\n        vol_data_avg = (vol_data_20D_avg + vol_data_10D_avg + vol_data_5D_avg) / 3\n        vol_data_addon = implied_vol - vol_data_avg\n    vol_data_addon = pd.DataFrame(vol_data_addon)\n    implied_vol = pd.DataFrame(implied_vol)\n    new_cols = implied_vol.columns.values\n    new_cols = [w.replace(part + tenor_label, 'ADD' + tenor_label) for w in new_cols]\n    vol_data_addon.columns = new_cols\n    return vol_data_addon"
        ]
    },
    {
        "func_name": "adjust_implied_ON_fri_vol",
        "original": "def adjust_implied_ON_fri_vol(self, data_frame):\n    cols_ON = [x for x in data_frame.columns if 'VON' in x]\n    for c in cols_ON:\n        data_frame[c][data_frame.index.dayofweek == 4] = data_frame[c][data_frame.index.dayofweek == 4] * math.sqrt(3)\n    return data_frame",
        "mutated": [
            "def adjust_implied_ON_fri_vol(self, data_frame):\n    if False:\n        i = 10\n    cols_ON = [x for x in data_frame.columns if 'VON' in x]\n    for c in cols_ON:\n        data_frame[c][data_frame.index.dayofweek == 4] = data_frame[c][data_frame.index.dayofweek == 4] * math.sqrt(3)\n    return data_frame",
            "def adjust_implied_ON_fri_vol(self, data_frame):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cols_ON = [x for x in data_frame.columns if 'VON' in x]\n    for c in cols_ON:\n        data_frame[c][data_frame.index.dayofweek == 4] = data_frame[c][data_frame.index.dayofweek == 4] * math.sqrt(3)\n    return data_frame",
            "def adjust_implied_ON_fri_vol(self, data_frame):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cols_ON = [x for x in data_frame.columns if 'VON' in x]\n    for c in cols_ON:\n        data_frame[c][data_frame.index.dayofweek == 4] = data_frame[c][data_frame.index.dayofweek == 4] * math.sqrt(3)\n    return data_frame",
            "def adjust_implied_ON_fri_vol(self, data_frame):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cols_ON = [x for x in data_frame.columns if 'VON' in x]\n    for c in cols_ON:\n        data_frame[c][data_frame.index.dayofweek == 4] = data_frame[c][data_frame.index.dayofweek == 4] * math.sqrt(3)\n    return data_frame",
            "def adjust_implied_ON_fri_vol(self, data_frame):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cols_ON = [x for x in data_frame.columns if 'VON' in x]\n    for c in cols_ON:\n        data_frame[c][data_frame.index.dayofweek == 4] = data_frame[c][data_frame.index.dayofweek == 4] * math.sqrt(3)\n    return data_frame"
        ]
    }
]