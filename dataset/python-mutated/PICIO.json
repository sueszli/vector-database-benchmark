[
    {
        "func_name": "akcache",
        "original": "def akcache(akstr: str) -> AtomKey:\n    \"\"\"Maintain dictionary of AtomKeys seen while reading this PIC file.\"\"\"\n    try:\n        return akc[akstr]\n    except KeyError:\n        ak = akc[akstr] = AtomKey(akstr)\n        return ak",
        "mutated": [
            "def akcache(akstr: str) -> AtomKey:\n    if False:\n        i = 10\n    'Maintain dictionary of AtomKeys seen while reading this PIC file.'\n    try:\n        return akc[akstr]\n    except KeyError:\n        ak = akc[akstr] = AtomKey(akstr)\n        return ak",
            "def akcache(akstr: str) -> AtomKey:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Maintain dictionary of AtomKeys seen while reading this PIC file.'\n    try:\n        return akc[akstr]\n    except KeyError:\n        ak = akc[akstr] = AtomKey(akstr)\n        return ak",
            "def akcache(akstr: str) -> AtomKey:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Maintain dictionary of AtomKeys seen while reading this PIC file.'\n    try:\n        return akc[akstr]\n    except KeyError:\n        ak = akc[akstr] = AtomKey(akstr)\n        return ak",
            "def akcache(akstr: str) -> AtomKey:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Maintain dictionary of AtomKeys seen while reading this PIC file.'\n    try:\n        return akc[akstr]\n    except KeyError:\n        ak = akc[akstr] = AtomKey(akstr)\n        return ak",
            "def akcache(akstr: str) -> AtomKey:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Maintain dictionary of AtomKeys seen while reading this PIC file.'\n    try:\n        return akc[akstr]\n    except KeyError:\n        ak = akc[akstr] = AtomKey(akstr)\n        return ak"
        ]
    },
    {
        "func_name": "link_residues",
        "original": "def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n    \"\"\"Set next and prev links between i-1 and i-2 residues.\"\"\"\n    for p_r in pr:\n        pric = p_r.internal_coord\n        for p_p_r in ppr:\n            ppric = p_p_r.internal_coord\n            if p_r.id[0] == ' ':\n                if pric not in ppric.rnext:\n                    ppric.rnext.append(pric)\n            if p_p_r.id[0] == ' ':\n                if ppric not in pric.rprev:\n                    pric.rprev.append(ppric)",
        "mutated": [
            "def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n    if False:\n        i = 10\n    'Set next and prev links between i-1 and i-2 residues.'\n    for p_r in pr:\n        pric = p_r.internal_coord\n        for p_p_r in ppr:\n            ppric = p_p_r.internal_coord\n            if p_r.id[0] == ' ':\n                if pric not in ppric.rnext:\n                    ppric.rnext.append(pric)\n            if p_p_r.id[0] == ' ':\n                if ppric not in pric.rprev:\n                    pric.rprev.append(ppric)",
            "def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Set next and prev links between i-1 and i-2 residues.'\n    for p_r in pr:\n        pric = p_r.internal_coord\n        for p_p_r in ppr:\n            ppric = p_p_r.internal_coord\n            if p_r.id[0] == ' ':\n                if pric not in ppric.rnext:\n                    ppric.rnext.append(pric)\n            if p_p_r.id[0] == ' ':\n                if ppric not in pric.rprev:\n                    pric.rprev.append(ppric)",
            "def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Set next and prev links between i-1 and i-2 residues.'\n    for p_r in pr:\n        pric = p_r.internal_coord\n        for p_p_r in ppr:\n            ppric = p_p_r.internal_coord\n            if p_r.id[0] == ' ':\n                if pric not in ppric.rnext:\n                    ppric.rnext.append(pric)\n            if p_p_r.id[0] == ' ':\n                if ppric not in pric.rprev:\n                    pric.rprev.append(ppric)",
            "def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Set next and prev links between i-1 and i-2 residues.'\n    for p_r in pr:\n        pric = p_r.internal_coord\n        for p_p_r in ppr:\n            ppric = p_p_r.internal_coord\n            if p_r.id[0] == ' ':\n                if pric not in ppric.rnext:\n                    ppric.rnext.append(pric)\n            if p_p_r.id[0] == ' ':\n                if ppric not in pric.rprev:\n                    pric.rprev.append(ppric)",
            "def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Set next and prev links between i-1 and i-2 residues.'\n    for p_r in pr:\n        pric = p_r.internal_coord\n        for p_p_r in ppr:\n            ppric = p_p_r.internal_coord\n            if p_r.id[0] == ' ':\n                if pric not in ppric.rnext:\n                    ppric.rnext.append(pric)\n            if p_p_r.id[0] == ' ':\n                if ppric not in pric.rprev:\n                    pric.rprev.append(ppric)"
        ]
    },
    {
        "func_name": "process_hedron",
        "original": "def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n    \"\"\"Create Hedron on current (sbcic) Chain.internal_coord.\"\"\"\n    ek = (akcache(a1), akcache(a2), akcache(a3))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n        return\n    hl12[ek] = float(l12)\n    ha[ek] = float(ang)\n    hl23[ek] = float(l23)\n    sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n    h.cic = sbcic\n    ak_add(ek, ric)\n    return ek",
        "mutated": [
            "def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n    if False:\n        i = 10\n    'Create Hedron on current (sbcic) Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n        return\n    hl12[ek] = float(l12)\n    ha[ek] = float(ang)\n    hl23[ek] = float(l23)\n    sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n    h.cic = sbcic\n    ak_add(ek, ric)\n    return ek",
            "def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create Hedron on current (sbcic) Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n        return\n    hl12[ek] = float(l12)\n    ha[ek] = float(ang)\n    hl23[ek] = float(l23)\n    sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n    h.cic = sbcic\n    ak_add(ek, ric)\n    return ek",
            "def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create Hedron on current (sbcic) Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n        return\n    hl12[ek] = float(l12)\n    ha[ek] = float(ang)\n    hl23[ek] = float(l23)\n    sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n    h.cic = sbcic\n    ak_add(ek, ric)\n    return ek",
            "def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create Hedron on current (sbcic) Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n        return\n    hl12[ek] = float(l12)\n    ha[ek] = float(ang)\n    hl23[ek] = float(l23)\n    sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n    h.cic = sbcic\n    ak_add(ek, ric)\n    return ek",
            "def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create Hedron on current (sbcic) Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n        return\n    hl12[ek] = float(l12)\n    ha[ek] = float(ang)\n    hl23[ek] = float(l23)\n    sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n    h.cic = sbcic\n    ak_add(ek, ric)\n    return ek"
        ]
    },
    {
        "func_name": "default_hedron",
        "original": "def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n    \"\"\"Create Hedron based on same re_class hedra in ref database.\n\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n    atomkeys = []\n    hkey = None\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    atomkeys = [ek[i].akl for i in range(3)]\n    atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n    res = atomkeys[0][resNdx]\n    if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n        hkey = ek\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n        try:\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        except KeyError:\n            if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n            else:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n            dflts = hedra_defaults[rhc][0]\n    else:\n        hkey = ek[::-1]\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n        dflts = hedra_defaults[''.join(rhcl)][0]\n    process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n    if verbose:\n        print(f' default for {ek}')",
        "mutated": [
            "def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n    'Create Hedron based on same re_class hedra in ref database.\\n\\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atomkeys = []\n    hkey = None\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    atomkeys = [ek[i].akl for i in range(3)]\n    atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n    res = atomkeys[0][resNdx]\n    if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n        hkey = ek\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n        try:\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        except KeyError:\n            if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n            else:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n            dflts = hedra_defaults[rhc][0]\n    else:\n        hkey = ek[::-1]\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n        dflts = hedra_defaults[''.join(rhcl)][0]\n    process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n    if verbose:\n        print(f' default for {ek}')",
            "def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create Hedron based on same re_class hedra in ref database.\\n\\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atomkeys = []\n    hkey = None\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    atomkeys = [ek[i].akl for i in range(3)]\n    atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n    res = atomkeys[0][resNdx]\n    if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n        hkey = ek\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n        try:\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        except KeyError:\n            if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n            else:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n            dflts = hedra_defaults[rhc][0]\n    else:\n        hkey = ek[::-1]\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n        dflts = hedra_defaults[''.join(rhcl)][0]\n    process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n    if verbose:\n        print(f' default for {ek}')",
            "def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create Hedron based on same re_class hedra in ref database.\\n\\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atomkeys = []\n    hkey = None\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    atomkeys = [ek[i].akl for i in range(3)]\n    atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n    res = atomkeys[0][resNdx]\n    if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n        hkey = ek\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n        try:\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        except KeyError:\n            if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n            else:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n            dflts = hedra_defaults[rhc][0]\n    else:\n        hkey = ek[::-1]\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n        dflts = hedra_defaults[''.join(rhcl)][0]\n    process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n    if verbose:\n        print(f' default for {ek}')",
            "def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create Hedron based on same re_class hedra in ref database.\\n\\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atomkeys = []\n    hkey = None\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    atomkeys = [ek[i].akl for i in range(3)]\n    atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n    res = atomkeys[0][resNdx]\n    if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n        hkey = ek\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n        try:\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        except KeyError:\n            if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n            else:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n            dflts = hedra_defaults[rhc][0]\n    else:\n        hkey = ek[::-1]\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n        dflts = hedra_defaults[''.join(rhcl)][0]\n    process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n    if verbose:\n        print(f' default for {ek}')",
            "def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create Hedron based on same re_class hedra in ref database.\\n\\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atomkeys = []\n    hkey = None\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    atomkeys = [ek[i].akl for i in range(3)]\n    atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n    res = atomkeys[0][resNdx]\n    if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n        hkey = ek\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n        try:\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        except KeyError:\n            if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n            else:\n                rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n            dflts = hedra_defaults[rhc][0]\n    else:\n        hkey = ek[::-1]\n        rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n        dflts = hedra_defaults[''.join(rhcl)][0]\n    process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n    if verbose:\n        print(f' default for {ek}')"
        ]
    },
    {
        "func_name": "hedra_check",
        "original": "def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n    \"\"\"Confirm both hedra present for dihedron key, use default if set.\"\"\"\n    if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[0:3], ric)\n        else:\n            print(f'{dk} missing h1')\n    if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[1:4], ric)\n        else:\n            print(f'{dk} missing h2')",
        "mutated": [
            "def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n    'Confirm both hedra present for dihedron key, use default if set.'\n    if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[0:3], ric)\n        else:\n            print(f'{dk} missing h1')\n    if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[1:4], ric)\n        else:\n            print(f'{dk} missing h2')",
            "def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Confirm both hedra present for dihedron key, use default if set.'\n    if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[0:3], ric)\n        else:\n            print(f'{dk} missing h1')\n    if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[1:4], ric)\n        else:\n            print(f'{dk} missing h2')",
            "def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Confirm both hedra present for dihedron key, use default if set.'\n    if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[0:3], ric)\n        else:\n            print(f'{dk} missing h1')\n    if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[1:4], ric)\n        else:\n            print(f'{dk} missing h2')",
            "def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Confirm both hedra present for dihedron key, use default if set.'\n    if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[0:3], ric)\n        else:\n            print(f'{dk} missing h1')\n    if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[1:4], ric)\n        else:\n            print(f'{dk} missing h2')",
            "def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Confirm both hedra present for dihedron key, use default if set.'\n    if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[0:3], ric)\n        else:\n            print(f'{dk} missing h1')\n    if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n        if defaults:\n            default_hedron(dk[1:4], ric)\n        else:\n            print(f'{dk} missing h2')"
        ]
    },
    {
        "func_name": "process_dihedron",
        "original": "def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n    \"\"\"Create Dihedron on current Chain.internal_coord.\"\"\"\n    ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n        return\n    dangle = float(dangle)\n    dangle = dangle if dangle <= 180.0 else dangle - 360.0\n    dangle = dangle if dangle >= -180.0 else dangle + 360.0\n    da[ek] = float(dangle)\n    sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n    d.cic = sbcic\n    if not quick:\n        hedra_check(ek, ric)\n    ak_add(ek, ric)\n    return ek",
        "mutated": [
            "def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n    if False:\n        i = 10\n    'Create Dihedron on current Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n        return\n    dangle = float(dangle)\n    dangle = dangle if dangle <= 180.0 else dangle - 360.0\n    dangle = dangle if dangle >= -180.0 else dangle + 360.0\n    da[ek] = float(dangle)\n    sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n    d.cic = sbcic\n    if not quick:\n        hedra_check(ek, ric)\n    ak_add(ek, ric)\n    return ek",
            "def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create Dihedron on current Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n        return\n    dangle = float(dangle)\n    dangle = dangle if dangle <= 180.0 else dangle - 360.0\n    dangle = dangle if dangle >= -180.0 else dangle + 360.0\n    da[ek] = float(dangle)\n    sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n    d.cic = sbcic\n    if not quick:\n        hedra_check(ek, ric)\n    ak_add(ek, ric)\n    return ek",
            "def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create Dihedron on current Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n        return\n    dangle = float(dangle)\n    dangle = dangle if dangle <= 180.0 else dangle - 360.0\n    dangle = dangle if dangle >= -180.0 else dangle + 360.0\n    da[ek] = float(dangle)\n    sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n    d.cic = sbcic\n    if not quick:\n        hedra_check(ek, ric)\n    ak_add(ek, ric)\n    return ek",
            "def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create Dihedron on current Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n        return\n    dangle = float(dangle)\n    dangle = dangle if dangle <= 180.0 else dangle - 360.0\n    dangle = dangle if dangle >= -180.0 else dangle + 360.0\n    da[ek] = float(dangle)\n    sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n    d.cic = sbcic\n    if not quick:\n        hedra_check(ek, ric)\n    ak_add(ek, ric)\n    return ek",
            "def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create Dihedron on current Chain.internal_coord.'\n    ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n    atmNdx = AtomKey.fields.atm\n    accpt = IC_Residue.accept_atoms\n    if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n        return\n    dangle = float(dangle)\n    dangle = dangle if dangle <= 180.0 else dangle - 360.0\n    dangle = dangle if dangle >= -180.0 else dangle + 360.0\n    da[ek] = float(dangle)\n    sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n    d.cic = sbcic\n    if not quick:\n        hedra_check(ek, ric)\n    ak_add(ek, ric)\n    return ek"
        ]
    },
    {
        "func_name": "default_dihedron",
        "original": "def default_dihedron(ek: List, ric: IC_Residue) -> None:\n    \"\"\"Create Dihedron based on same residue class dihedra in ref database.\n\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    rdclass = ''\n    dclass = ''\n    for ak in ek:\n        dclass += ak.akl[atmNdx]\n        rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n    if dclass == 'NCACN':\n        rdclass = rdclass[0:7] + 'XN'\n    elif dclass == 'CACNCA':\n        rdclass = 'XCAXC' + rdclass[5:]\n    elif dclass == 'CNCAC':\n        rdclass = 'XC' + rdclass[2:]\n    if rdclass in dihedra_primary_defaults:\n        process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n        if verbose:\n            print(f' default for {ek}')\n    elif rdclass in dihedra_secondary_defaults:\n        (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n        rname = ek[2].akl[resNdx]\n        rnum = int(ek[2].akl[resPos])\n        paKey = None\n        if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n            paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n            rnext = ek[0].ric.rnext\n            paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n            paKey = tuple(paKey)\n        elif primAngle == ('CA', 'C', 'N', 'CA'):\n            prname = pr.akl[0][resNdx]\n            prnum = pr.akl[0][resPos]\n            paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n            paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n            paKey = tuple(paKey)\n        else:\n            paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n        if paKey in da:\n            angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n            if verbose:\n                print(f' secondary default for {ek}')\n        elif rdclass in dihedra_secondary_xoxt_defaults:\n            if primAngle == ('C', 'N', 'CA', 'C'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                paKey = tuple(paKey)\n            else:\n                (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                rname = ek[2].akl[resNdx]\n                rnum = int(ek[2].akl[resPos])\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + offset\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' oxt default for {ek}')\n            else:\n                print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n    else:\n        print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')",
        "mutated": [
            "def default_dihedron(ek: List, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n    'Create Dihedron based on same residue class dihedra in ref database.\\n\\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    rdclass = ''\n    dclass = ''\n    for ak in ek:\n        dclass += ak.akl[atmNdx]\n        rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n    if dclass == 'NCACN':\n        rdclass = rdclass[0:7] + 'XN'\n    elif dclass == 'CACNCA':\n        rdclass = 'XCAXC' + rdclass[5:]\n    elif dclass == 'CNCAC':\n        rdclass = 'XC' + rdclass[2:]\n    if rdclass in dihedra_primary_defaults:\n        process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n        if verbose:\n            print(f' default for {ek}')\n    elif rdclass in dihedra_secondary_defaults:\n        (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n        rname = ek[2].akl[resNdx]\n        rnum = int(ek[2].akl[resPos])\n        paKey = None\n        if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n            paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n            rnext = ek[0].ric.rnext\n            paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n            paKey = tuple(paKey)\n        elif primAngle == ('CA', 'C', 'N', 'CA'):\n            prname = pr.akl[0][resNdx]\n            prnum = pr.akl[0][resPos]\n            paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n            paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n            paKey = tuple(paKey)\n        else:\n            paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n        if paKey in da:\n            angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n            if verbose:\n                print(f' secondary default for {ek}')\n        elif rdclass in dihedra_secondary_xoxt_defaults:\n            if primAngle == ('C', 'N', 'CA', 'C'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                paKey = tuple(paKey)\n            else:\n                (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                rname = ek[2].akl[resNdx]\n                rnum = int(ek[2].akl[resPos])\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + offset\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' oxt default for {ek}')\n            else:\n                print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n    else:\n        print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')",
            "def default_dihedron(ek: List, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create Dihedron based on same residue class dihedra in ref database.\\n\\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    rdclass = ''\n    dclass = ''\n    for ak in ek:\n        dclass += ak.akl[atmNdx]\n        rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n    if dclass == 'NCACN':\n        rdclass = rdclass[0:7] + 'XN'\n    elif dclass == 'CACNCA':\n        rdclass = 'XCAXC' + rdclass[5:]\n    elif dclass == 'CNCAC':\n        rdclass = 'XC' + rdclass[2:]\n    if rdclass in dihedra_primary_defaults:\n        process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n        if verbose:\n            print(f' default for {ek}')\n    elif rdclass in dihedra_secondary_defaults:\n        (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n        rname = ek[2].akl[resNdx]\n        rnum = int(ek[2].akl[resPos])\n        paKey = None\n        if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n            paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n            rnext = ek[0].ric.rnext\n            paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n            paKey = tuple(paKey)\n        elif primAngle == ('CA', 'C', 'N', 'CA'):\n            prname = pr.akl[0][resNdx]\n            prnum = pr.akl[0][resPos]\n            paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n            paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n            paKey = tuple(paKey)\n        else:\n            paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n        if paKey in da:\n            angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n            if verbose:\n                print(f' secondary default for {ek}')\n        elif rdclass in dihedra_secondary_xoxt_defaults:\n            if primAngle == ('C', 'N', 'CA', 'C'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                paKey = tuple(paKey)\n            else:\n                (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                rname = ek[2].akl[resNdx]\n                rnum = int(ek[2].akl[resPos])\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + offset\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' oxt default for {ek}')\n            else:\n                print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n    else:\n        print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')",
            "def default_dihedron(ek: List, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create Dihedron based on same residue class dihedra in ref database.\\n\\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    rdclass = ''\n    dclass = ''\n    for ak in ek:\n        dclass += ak.akl[atmNdx]\n        rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n    if dclass == 'NCACN':\n        rdclass = rdclass[0:7] + 'XN'\n    elif dclass == 'CACNCA':\n        rdclass = 'XCAXC' + rdclass[5:]\n    elif dclass == 'CNCAC':\n        rdclass = 'XC' + rdclass[2:]\n    if rdclass in dihedra_primary_defaults:\n        process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n        if verbose:\n            print(f' default for {ek}')\n    elif rdclass in dihedra_secondary_defaults:\n        (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n        rname = ek[2].akl[resNdx]\n        rnum = int(ek[2].akl[resPos])\n        paKey = None\n        if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n            paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n            rnext = ek[0].ric.rnext\n            paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n            paKey = tuple(paKey)\n        elif primAngle == ('CA', 'C', 'N', 'CA'):\n            prname = pr.akl[0][resNdx]\n            prnum = pr.akl[0][resPos]\n            paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n            paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n            paKey = tuple(paKey)\n        else:\n            paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n        if paKey in da:\n            angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n            if verbose:\n                print(f' secondary default for {ek}')\n        elif rdclass in dihedra_secondary_xoxt_defaults:\n            if primAngle == ('C', 'N', 'CA', 'C'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                paKey = tuple(paKey)\n            else:\n                (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                rname = ek[2].akl[resNdx]\n                rnum = int(ek[2].akl[resPos])\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + offset\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' oxt default for {ek}')\n            else:\n                print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n    else:\n        print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')",
            "def default_dihedron(ek: List, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create Dihedron based on same residue class dihedra in ref database.\\n\\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    rdclass = ''\n    dclass = ''\n    for ak in ek:\n        dclass += ak.akl[atmNdx]\n        rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n    if dclass == 'NCACN':\n        rdclass = rdclass[0:7] + 'XN'\n    elif dclass == 'CACNCA':\n        rdclass = 'XCAXC' + rdclass[5:]\n    elif dclass == 'CNCAC':\n        rdclass = 'XC' + rdclass[2:]\n    if rdclass in dihedra_primary_defaults:\n        process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n        if verbose:\n            print(f' default for {ek}')\n    elif rdclass in dihedra_secondary_defaults:\n        (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n        rname = ek[2].akl[resNdx]\n        rnum = int(ek[2].akl[resPos])\n        paKey = None\n        if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n            paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n            rnext = ek[0].ric.rnext\n            paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n            paKey = tuple(paKey)\n        elif primAngle == ('CA', 'C', 'N', 'CA'):\n            prname = pr.akl[0][resNdx]\n            prnum = pr.akl[0][resPos]\n            paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n            paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n            paKey = tuple(paKey)\n        else:\n            paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n        if paKey in da:\n            angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n            if verbose:\n                print(f' secondary default for {ek}')\n        elif rdclass in dihedra_secondary_xoxt_defaults:\n            if primAngle == ('C', 'N', 'CA', 'C'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                paKey = tuple(paKey)\n            else:\n                (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                rname = ek[2].akl[resNdx]\n                rnum = int(ek[2].akl[resPos])\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + offset\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' oxt default for {ek}')\n            else:\n                print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n    else:\n        print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')",
            "def default_dihedron(ek: List, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create Dihedron based on same residue class dihedra in ref database.\\n\\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\\n        values and reference database source.\\n        '\n    atmNdx = AtomKey.fields.atm\n    resNdx = AtomKey.fields.resname\n    resPos = AtomKey.fields.respos\n    rdclass = ''\n    dclass = ''\n    for ak in ek:\n        dclass += ak.akl[atmNdx]\n        rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n    if dclass == 'NCACN':\n        rdclass = rdclass[0:7] + 'XN'\n    elif dclass == 'CACNCA':\n        rdclass = 'XCAXC' + rdclass[5:]\n    elif dclass == 'CNCAC':\n        rdclass = 'XC' + rdclass[2:]\n    if rdclass in dihedra_primary_defaults:\n        process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n        if verbose:\n            print(f' default for {ek}')\n    elif rdclass in dihedra_secondary_defaults:\n        (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n        rname = ek[2].akl[resNdx]\n        rnum = int(ek[2].akl[resPos])\n        paKey = None\n        if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n            paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n            rnext = ek[0].ric.rnext\n            paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n            paKey = tuple(paKey)\n        elif primAngle == ('CA', 'C', 'N', 'CA'):\n            prname = pr.akl[0][resNdx]\n            prnum = pr.akl[0][resPos]\n            paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n            paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n            paKey = tuple(paKey)\n        else:\n            paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n        if paKey in da:\n            angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n            if verbose:\n                print(f' secondary default for {ek}')\n        elif rdclass in dihedra_secondary_xoxt_defaults:\n            if primAngle == ('C', 'N', 'CA', 'C'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                paKey = tuple(paKey)\n            else:\n                (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                rname = ek[2].akl[resNdx]\n                rnum = int(ek[2].akl[resPos])\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + offset\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' oxt default for {ek}')\n            else:\n                print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n    else:\n        print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')"
        ]
    },
    {
        "func_name": "ake_recurse",
        "original": "def ake_recurse(akList: List) -> List:\n    \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n    car = akList[0]\n    if len(akList) > 1:\n        retList = []\n        for ak in car:\n            cdr = akList[1:]\n            rslt = ake_recurse(cdr)\n            for r in rslt:\n                r.insert(0, ak)\n                retList.append(r)\n        return retList\n    elif len(car) == 1:\n        return [list(car)]\n    else:\n        retList = [[ak] for ak in car]\n        return retList",
        "mutated": [
            "def ake_recurse(akList: List) -> List:\n    if False:\n        i = 10\n    'Bulid combinatorics of AtomKey lists.'\n    car = akList[0]\n    if len(akList) > 1:\n        retList = []\n        for ak in car:\n            cdr = akList[1:]\n            rslt = ake_recurse(cdr)\n            for r in rslt:\n                r.insert(0, ak)\n                retList.append(r)\n        return retList\n    elif len(car) == 1:\n        return [list(car)]\n    else:\n        retList = [[ak] for ak in car]\n        return retList",
            "def ake_recurse(akList: List) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Bulid combinatorics of AtomKey lists.'\n    car = akList[0]\n    if len(akList) > 1:\n        retList = []\n        for ak in car:\n            cdr = akList[1:]\n            rslt = ake_recurse(cdr)\n            for r in rslt:\n                r.insert(0, ak)\n                retList.append(r)\n        return retList\n    elif len(car) == 1:\n        return [list(car)]\n    else:\n        retList = [[ak] for ak in car]\n        return retList",
            "def ake_recurse(akList: List) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Bulid combinatorics of AtomKey lists.'\n    car = akList[0]\n    if len(akList) > 1:\n        retList = []\n        for ak in car:\n            cdr = akList[1:]\n            rslt = ake_recurse(cdr)\n            for r in rslt:\n                r.insert(0, ak)\n                retList.append(r)\n        return retList\n    elif len(car) == 1:\n        return [list(car)]\n    else:\n        retList = [[ak] for ak in car]\n        return retList",
            "def ake_recurse(akList: List) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Bulid combinatorics of AtomKey lists.'\n    car = akList[0]\n    if len(akList) > 1:\n        retList = []\n        for ak in car:\n            cdr = akList[1:]\n            rslt = ake_recurse(cdr)\n            for r in rslt:\n                r.insert(0, ak)\n                retList.append(r)\n        return retList\n    elif len(car) == 1:\n        return [list(car)]\n    else:\n        retList = [[ak] for ak in car]\n        return retList",
            "def ake_recurse(akList: List) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Bulid combinatorics of AtomKey lists.'\n    car = akList[0]\n    if len(akList) > 1:\n        retList = []\n        for ak in car:\n            cdr = akList[1:]\n            rslt = ake_recurse(cdr)\n            for r in rslt:\n                r.insert(0, ak)\n                retList.append(r)\n        return retList\n    elif len(car) == 1:\n        return [list(car)]\n    else:\n        retList = [[ak] for ak in car]\n        return retList"
        ]
    },
    {
        "func_name": "ak_expand",
        "original": "def ak_expand(eLst: List) -> List:\n    \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n    retList = []\n    for edron in eLst:\n        newList = []\n        for ak in edron:\n            rslt = ak.ric.split_akl([ak])\n            rlst = [r[0] for r in rslt]\n            if rlst != []:\n                newList.append(rlst)\n            else:\n                newList.append([ak])\n        rslt = ake_recurse(newList)\n        for r in rslt:\n            retList.append(r)\n    return retList",
        "mutated": [
            "def ak_expand(eLst: List) -> List:\n    if False:\n        i = 10\n    'Expand AtomKey list with altlocs, all combinatorics.'\n    retList = []\n    for edron in eLst:\n        newList = []\n        for ak in edron:\n            rslt = ak.ric.split_akl([ak])\n            rlst = [r[0] for r in rslt]\n            if rlst != []:\n                newList.append(rlst)\n            else:\n                newList.append([ak])\n        rslt = ake_recurse(newList)\n        for r in rslt:\n            retList.append(r)\n    return retList",
            "def ak_expand(eLst: List) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Expand AtomKey list with altlocs, all combinatorics.'\n    retList = []\n    for edron in eLst:\n        newList = []\n        for ak in edron:\n            rslt = ak.ric.split_akl([ak])\n            rlst = [r[0] for r in rslt]\n            if rlst != []:\n                newList.append(rlst)\n            else:\n                newList.append([ak])\n        rslt = ake_recurse(newList)\n        for r in rslt:\n            retList.append(r)\n    return retList",
            "def ak_expand(eLst: List) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Expand AtomKey list with altlocs, all combinatorics.'\n    retList = []\n    for edron in eLst:\n        newList = []\n        for ak in edron:\n            rslt = ak.ric.split_akl([ak])\n            rlst = [r[0] for r in rslt]\n            if rlst != []:\n                newList.append(rlst)\n            else:\n                newList.append([ak])\n        rslt = ake_recurse(newList)\n        for r in rslt:\n            retList.append(r)\n    return retList",
            "def ak_expand(eLst: List) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Expand AtomKey list with altlocs, all combinatorics.'\n    retList = []\n    for edron in eLst:\n        newList = []\n        for ak in edron:\n            rslt = ak.ric.split_akl([ak])\n            rlst = [r[0] for r in rslt]\n            if rlst != []:\n                newList.append(rlst)\n            else:\n                newList.append([ak])\n        rslt = ake_recurse(newList)\n        for r in rslt:\n            retList.append(r)\n    return retList",
            "def ak_expand(eLst: List) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Expand AtomKey list with altlocs, all combinatorics.'\n    retList = []\n    for edron in eLst:\n        newList = []\n        for ak in edron:\n            rslt = ak.ric.split_akl([ak])\n            rlst = [r[0] for r in rslt]\n            if rlst != []:\n                newList.append(rlst)\n            else:\n                newList.append([ak])\n        rslt = ake_recurse(newList)\n        for r in rslt:\n            retList.append(r)\n    return retList"
        ]
    },
    {
        "func_name": "dihedra_check",
        "original": "def dihedra_check(ric: IC_Residue) -> None:\n    \"\"\"Look for required dihedra in residue, generate defaults if set.\"\"\"\n\n    def ake_recurse(akList: List) -> List:\n        \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n        car = akList[0]\n        if len(akList) > 1:\n            retList = []\n            for ak in car:\n                cdr = akList[1:]\n                rslt = ake_recurse(cdr)\n                for r in rslt:\n                    r.insert(0, ak)\n                    retList.append(r)\n            return retList\n        elif len(car) == 1:\n            return [list(car)]\n        else:\n            retList = [[ak] for ak in car]\n            return retList\n\n    def ak_expand(eLst: List) -> List:\n        \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n        retList = []\n        for edron in eLst:\n            newList = []\n            for ak in edron:\n                rslt = ak.ric.split_akl([ak])\n                rlst = [r[0] for r in rslt]\n                if rlst != []:\n                    newList.append(rlst)\n                else:\n                    newList.append([ak])\n            rslt = ake_recurse(newList)\n            for r in rslt:\n                retList.append(r)\n        return retList\n    chkLst = []\n    (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n    (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n    if ric.rnext != []:\n        for rn in ric.rnext:\n            (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n            chkLst.append((sN, sCA, sC, nN))\n            chkLst.append((sCA, sC, nN, nCA))\n            chkLst.append((sC, nN, nCA, nC))\n    else:\n        chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n        rn = '(no rnext)'\n    chkLst.append((sN, sCA, sC, sO))\n    if ric.lc != 'G':\n        chkLst.append((sO, sC, sCA, sCB))\n        if ric.lc == 'A':\n            chkLst.append((sN, sCA, sCB))\n    if ric.rprev != [] and ric.lc != 'P' and proton:\n        chkLst.append((sC, sCA, sN, sH))\n    try:\n        for edron in ic_data_sidechains[ric.lc]:\n            if len(edron) > 3:\n                if all((atm[0] != 'H' for atm in edron)):\n                    akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                    chkLst.append(akl)\n    except KeyError:\n        pass\n    chkLst = ak_expand(chkLst)\n    altloc_ndx = AtomKey.fields.altloc\n    for dk in chkLst:\n        if tuple(dk) in ric.dihedra:\n            pass\n        elif sH in dk:\n            pass\n        elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n            if defaults:\n                if len(dk) != 3:\n                    default_dihedron(dk, ric)\n                else:\n                    default_hedron(dk, ric)\n            elif verbose:\n                print(f'{ric}-{rn} missing {dk}')\n        else:\n            pass",
        "mutated": [
            "def dihedra_check(ric: IC_Residue) -> None:\n    if False:\n        i = 10\n    'Look for required dihedra in residue, generate defaults if set.'\n\n    def ake_recurse(akList: List) -> List:\n        \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n        car = akList[0]\n        if len(akList) > 1:\n            retList = []\n            for ak in car:\n                cdr = akList[1:]\n                rslt = ake_recurse(cdr)\n                for r in rslt:\n                    r.insert(0, ak)\n                    retList.append(r)\n            return retList\n        elif len(car) == 1:\n            return [list(car)]\n        else:\n            retList = [[ak] for ak in car]\n            return retList\n\n    def ak_expand(eLst: List) -> List:\n        \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n        retList = []\n        for edron in eLst:\n            newList = []\n            for ak in edron:\n                rslt = ak.ric.split_akl([ak])\n                rlst = [r[0] for r in rslt]\n                if rlst != []:\n                    newList.append(rlst)\n                else:\n                    newList.append([ak])\n            rslt = ake_recurse(newList)\n            for r in rslt:\n                retList.append(r)\n        return retList\n    chkLst = []\n    (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n    (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n    if ric.rnext != []:\n        for rn in ric.rnext:\n            (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n            chkLst.append((sN, sCA, sC, nN))\n            chkLst.append((sCA, sC, nN, nCA))\n            chkLst.append((sC, nN, nCA, nC))\n    else:\n        chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n        rn = '(no rnext)'\n    chkLst.append((sN, sCA, sC, sO))\n    if ric.lc != 'G':\n        chkLst.append((sO, sC, sCA, sCB))\n        if ric.lc == 'A':\n            chkLst.append((sN, sCA, sCB))\n    if ric.rprev != [] and ric.lc != 'P' and proton:\n        chkLst.append((sC, sCA, sN, sH))\n    try:\n        for edron in ic_data_sidechains[ric.lc]:\n            if len(edron) > 3:\n                if all((atm[0] != 'H' for atm in edron)):\n                    akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                    chkLst.append(akl)\n    except KeyError:\n        pass\n    chkLst = ak_expand(chkLst)\n    altloc_ndx = AtomKey.fields.altloc\n    for dk in chkLst:\n        if tuple(dk) in ric.dihedra:\n            pass\n        elif sH in dk:\n            pass\n        elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n            if defaults:\n                if len(dk) != 3:\n                    default_dihedron(dk, ric)\n                else:\n                    default_hedron(dk, ric)\n            elif verbose:\n                print(f'{ric}-{rn} missing {dk}')\n        else:\n            pass",
            "def dihedra_check(ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Look for required dihedra in residue, generate defaults if set.'\n\n    def ake_recurse(akList: List) -> List:\n        \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n        car = akList[0]\n        if len(akList) > 1:\n            retList = []\n            for ak in car:\n                cdr = akList[1:]\n                rslt = ake_recurse(cdr)\n                for r in rslt:\n                    r.insert(0, ak)\n                    retList.append(r)\n            return retList\n        elif len(car) == 1:\n            return [list(car)]\n        else:\n            retList = [[ak] for ak in car]\n            return retList\n\n    def ak_expand(eLst: List) -> List:\n        \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n        retList = []\n        for edron in eLst:\n            newList = []\n            for ak in edron:\n                rslt = ak.ric.split_akl([ak])\n                rlst = [r[0] for r in rslt]\n                if rlst != []:\n                    newList.append(rlst)\n                else:\n                    newList.append([ak])\n            rslt = ake_recurse(newList)\n            for r in rslt:\n                retList.append(r)\n        return retList\n    chkLst = []\n    (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n    (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n    if ric.rnext != []:\n        for rn in ric.rnext:\n            (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n            chkLst.append((sN, sCA, sC, nN))\n            chkLst.append((sCA, sC, nN, nCA))\n            chkLst.append((sC, nN, nCA, nC))\n    else:\n        chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n        rn = '(no rnext)'\n    chkLst.append((sN, sCA, sC, sO))\n    if ric.lc != 'G':\n        chkLst.append((sO, sC, sCA, sCB))\n        if ric.lc == 'A':\n            chkLst.append((sN, sCA, sCB))\n    if ric.rprev != [] and ric.lc != 'P' and proton:\n        chkLst.append((sC, sCA, sN, sH))\n    try:\n        for edron in ic_data_sidechains[ric.lc]:\n            if len(edron) > 3:\n                if all((atm[0] != 'H' for atm in edron)):\n                    akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                    chkLst.append(akl)\n    except KeyError:\n        pass\n    chkLst = ak_expand(chkLst)\n    altloc_ndx = AtomKey.fields.altloc\n    for dk in chkLst:\n        if tuple(dk) in ric.dihedra:\n            pass\n        elif sH in dk:\n            pass\n        elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n            if defaults:\n                if len(dk) != 3:\n                    default_dihedron(dk, ric)\n                else:\n                    default_hedron(dk, ric)\n            elif verbose:\n                print(f'{ric}-{rn} missing {dk}')\n        else:\n            pass",
            "def dihedra_check(ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Look for required dihedra in residue, generate defaults if set.'\n\n    def ake_recurse(akList: List) -> List:\n        \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n        car = akList[0]\n        if len(akList) > 1:\n            retList = []\n            for ak in car:\n                cdr = akList[1:]\n                rslt = ake_recurse(cdr)\n                for r in rslt:\n                    r.insert(0, ak)\n                    retList.append(r)\n            return retList\n        elif len(car) == 1:\n            return [list(car)]\n        else:\n            retList = [[ak] for ak in car]\n            return retList\n\n    def ak_expand(eLst: List) -> List:\n        \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n        retList = []\n        for edron in eLst:\n            newList = []\n            for ak in edron:\n                rslt = ak.ric.split_akl([ak])\n                rlst = [r[0] for r in rslt]\n                if rlst != []:\n                    newList.append(rlst)\n                else:\n                    newList.append([ak])\n            rslt = ake_recurse(newList)\n            for r in rslt:\n                retList.append(r)\n        return retList\n    chkLst = []\n    (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n    (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n    if ric.rnext != []:\n        for rn in ric.rnext:\n            (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n            chkLst.append((sN, sCA, sC, nN))\n            chkLst.append((sCA, sC, nN, nCA))\n            chkLst.append((sC, nN, nCA, nC))\n    else:\n        chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n        rn = '(no rnext)'\n    chkLst.append((sN, sCA, sC, sO))\n    if ric.lc != 'G':\n        chkLst.append((sO, sC, sCA, sCB))\n        if ric.lc == 'A':\n            chkLst.append((sN, sCA, sCB))\n    if ric.rprev != [] and ric.lc != 'P' and proton:\n        chkLst.append((sC, sCA, sN, sH))\n    try:\n        for edron in ic_data_sidechains[ric.lc]:\n            if len(edron) > 3:\n                if all((atm[0] != 'H' for atm in edron)):\n                    akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                    chkLst.append(akl)\n    except KeyError:\n        pass\n    chkLst = ak_expand(chkLst)\n    altloc_ndx = AtomKey.fields.altloc\n    for dk in chkLst:\n        if tuple(dk) in ric.dihedra:\n            pass\n        elif sH in dk:\n            pass\n        elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n            if defaults:\n                if len(dk) != 3:\n                    default_dihedron(dk, ric)\n                else:\n                    default_hedron(dk, ric)\n            elif verbose:\n                print(f'{ric}-{rn} missing {dk}')\n        else:\n            pass",
            "def dihedra_check(ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Look for required dihedra in residue, generate defaults if set.'\n\n    def ake_recurse(akList: List) -> List:\n        \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n        car = akList[0]\n        if len(akList) > 1:\n            retList = []\n            for ak in car:\n                cdr = akList[1:]\n                rslt = ake_recurse(cdr)\n                for r in rslt:\n                    r.insert(0, ak)\n                    retList.append(r)\n            return retList\n        elif len(car) == 1:\n            return [list(car)]\n        else:\n            retList = [[ak] for ak in car]\n            return retList\n\n    def ak_expand(eLst: List) -> List:\n        \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n        retList = []\n        for edron in eLst:\n            newList = []\n            for ak in edron:\n                rslt = ak.ric.split_akl([ak])\n                rlst = [r[0] for r in rslt]\n                if rlst != []:\n                    newList.append(rlst)\n                else:\n                    newList.append([ak])\n            rslt = ake_recurse(newList)\n            for r in rslt:\n                retList.append(r)\n        return retList\n    chkLst = []\n    (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n    (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n    if ric.rnext != []:\n        for rn in ric.rnext:\n            (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n            chkLst.append((sN, sCA, sC, nN))\n            chkLst.append((sCA, sC, nN, nCA))\n            chkLst.append((sC, nN, nCA, nC))\n    else:\n        chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n        rn = '(no rnext)'\n    chkLst.append((sN, sCA, sC, sO))\n    if ric.lc != 'G':\n        chkLst.append((sO, sC, sCA, sCB))\n        if ric.lc == 'A':\n            chkLst.append((sN, sCA, sCB))\n    if ric.rprev != [] and ric.lc != 'P' and proton:\n        chkLst.append((sC, sCA, sN, sH))\n    try:\n        for edron in ic_data_sidechains[ric.lc]:\n            if len(edron) > 3:\n                if all((atm[0] != 'H' for atm in edron)):\n                    akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                    chkLst.append(akl)\n    except KeyError:\n        pass\n    chkLst = ak_expand(chkLst)\n    altloc_ndx = AtomKey.fields.altloc\n    for dk in chkLst:\n        if tuple(dk) in ric.dihedra:\n            pass\n        elif sH in dk:\n            pass\n        elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n            if defaults:\n                if len(dk) != 3:\n                    default_dihedron(dk, ric)\n                else:\n                    default_hedron(dk, ric)\n            elif verbose:\n                print(f'{ric}-{rn} missing {dk}')\n        else:\n            pass",
            "def dihedra_check(ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Look for required dihedra in residue, generate defaults if set.'\n\n    def ake_recurse(akList: List) -> List:\n        \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n        car = akList[0]\n        if len(akList) > 1:\n            retList = []\n            for ak in car:\n                cdr = akList[1:]\n                rslt = ake_recurse(cdr)\n                for r in rslt:\n                    r.insert(0, ak)\n                    retList.append(r)\n            return retList\n        elif len(car) == 1:\n            return [list(car)]\n        else:\n            retList = [[ak] for ak in car]\n            return retList\n\n    def ak_expand(eLst: List) -> List:\n        \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n        retList = []\n        for edron in eLst:\n            newList = []\n            for ak in edron:\n                rslt = ak.ric.split_akl([ak])\n                rlst = [r[0] for r in rslt]\n                if rlst != []:\n                    newList.append(rlst)\n                else:\n                    newList.append([ak])\n            rslt = ake_recurse(newList)\n            for r in rslt:\n                retList.append(r)\n        return retList\n    chkLst = []\n    (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n    (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n    if ric.rnext != []:\n        for rn in ric.rnext:\n            (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n            chkLst.append((sN, sCA, sC, nN))\n            chkLst.append((sCA, sC, nN, nCA))\n            chkLst.append((sC, nN, nCA, nC))\n    else:\n        chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n        rn = '(no rnext)'\n    chkLst.append((sN, sCA, sC, sO))\n    if ric.lc != 'G':\n        chkLst.append((sO, sC, sCA, sCB))\n        if ric.lc == 'A':\n            chkLst.append((sN, sCA, sCB))\n    if ric.rprev != [] and ric.lc != 'P' and proton:\n        chkLst.append((sC, sCA, sN, sH))\n    try:\n        for edron in ic_data_sidechains[ric.lc]:\n            if len(edron) > 3:\n                if all((atm[0] != 'H' for atm in edron)):\n                    akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                    chkLst.append(akl)\n    except KeyError:\n        pass\n    chkLst = ak_expand(chkLst)\n    altloc_ndx = AtomKey.fields.altloc\n    for dk in chkLst:\n        if tuple(dk) in ric.dihedra:\n            pass\n        elif sH in dk:\n            pass\n        elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n            if defaults:\n                if len(dk) != 3:\n                    default_dihedron(dk, ric)\n                else:\n                    default_hedron(dk, ric)\n            elif verbose:\n                print(f'{ric}-{rn} missing {dk}')\n        else:\n            pass"
        ]
    },
    {
        "func_name": "ak_add",
        "original": "def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n    \"\"\"Allocate edron key AtomKeys to current residue as appropriate.\n\n        A hedron or dihedron may span a backbone amide bond, this routine\n        allocates atoms in the (h/di)edron to the ric residue or saves them\n        for a residue yet to be processed.\n\n        :param set ek: AtomKeys in edron\n        :param IC_Residue ric: current residue to assign AtomKeys to\n        \"\"\"\n    res = ric.residue\n    reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n    for ak in ek:\n        if ak.ric is None:\n            sbcic.akset.add(ak)\n            if ak.akl[0:3] == reskl:\n                ak.ric = ric\n                ric.ak_set.add(ak)\n            else:\n                orphan_aks.add(ak)",
        "mutated": [
            "def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n    'Allocate edron key AtomKeys to current residue as appropriate.\\n\\n        A hedron or dihedron may span a backbone amide bond, this routine\\n        allocates atoms in the (h/di)edron to the ric residue or saves them\\n        for a residue yet to be processed.\\n\\n        :param set ek: AtomKeys in edron\\n        :param IC_Residue ric: current residue to assign AtomKeys to\\n        '\n    res = ric.residue\n    reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n    for ak in ek:\n        if ak.ric is None:\n            sbcic.akset.add(ak)\n            if ak.akl[0:3] == reskl:\n                ak.ric = ric\n                ric.ak_set.add(ak)\n            else:\n                orphan_aks.add(ak)",
            "def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Allocate edron key AtomKeys to current residue as appropriate.\\n\\n        A hedron or dihedron may span a backbone amide bond, this routine\\n        allocates atoms in the (h/di)edron to the ric residue or saves them\\n        for a residue yet to be processed.\\n\\n        :param set ek: AtomKeys in edron\\n        :param IC_Residue ric: current residue to assign AtomKeys to\\n        '\n    res = ric.residue\n    reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n    for ak in ek:\n        if ak.ric is None:\n            sbcic.akset.add(ak)\n            if ak.akl[0:3] == reskl:\n                ak.ric = ric\n                ric.ak_set.add(ak)\n            else:\n                orphan_aks.add(ak)",
            "def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Allocate edron key AtomKeys to current residue as appropriate.\\n\\n        A hedron or dihedron may span a backbone amide bond, this routine\\n        allocates atoms in the (h/di)edron to the ric residue or saves them\\n        for a residue yet to be processed.\\n\\n        :param set ek: AtomKeys in edron\\n        :param IC_Residue ric: current residue to assign AtomKeys to\\n        '\n    res = ric.residue\n    reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n    for ak in ek:\n        if ak.ric is None:\n            sbcic.akset.add(ak)\n            if ak.akl[0:3] == reskl:\n                ak.ric = ric\n                ric.ak_set.add(ak)\n            else:\n                orphan_aks.add(ak)",
            "def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Allocate edron key AtomKeys to current residue as appropriate.\\n\\n        A hedron or dihedron may span a backbone amide bond, this routine\\n        allocates atoms in the (h/di)edron to the ric residue or saves them\\n        for a residue yet to be processed.\\n\\n        :param set ek: AtomKeys in edron\\n        :param IC_Residue ric: current residue to assign AtomKeys to\\n        '\n    res = ric.residue\n    reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n    for ak in ek:\n        if ak.ric is None:\n            sbcic.akset.add(ak)\n            if ak.akl[0:3] == reskl:\n                ak.ric = ric\n                ric.ak_set.add(ak)\n            else:\n                orphan_aks.add(ak)",
            "def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Allocate edron key AtomKeys to current residue as appropriate.\\n\\n        A hedron or dihedron may span a backbone amide bond, this routine\\n        allocates atoms in the (h/di)edron to the ric residue or saves them\\n        for a residue yet to be processed.\\n\\n        :param set ek: AtomKeys in edron\\n        :param IC_Residue ric: current residue to assign AtomKeys to\\n        '\n    res = ric.residue\n    reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n    for ak in ek:\n        if ak.ric is None:\n            sbcic.akset.add(ak)\n            if ak.akl[0:3] == reskl:\n                ak.ric = ric\n                ric.ak_set.add(ak)\n            else:\n                orphan_aks.add(ak)"
        ]
    },
    {
        "func_name": "finish_chain",
        "original": "def finish_chain() -> None:\n    \"\"\"Do last rnext, rprev links and process chain edra data.\"\"\"\n    link_residues(pr, tr)\n    if not quick:\n        for r in pr:\n            dihedra_check(r.internal_coord)\n        for r in tr:\n            dihedra_check(r.internal_coord)\n    if ha != {}:\n        sha = {k: ha[k] for k in sorted(ha)}\n        shl12 = {k: hl12[k] for k in sorted(hl12)}\n        shl23 = {k: hl23[k] for k in sorted(hl23)}\n        sda = {k: da[k] for k in sorted(da)}\n        sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)",
        "mutated": [
            "def finish_chain() -> None:\n    if False:\n        i = 10\n    'Do last rnext, rprev links and process chain edra data.'\n    link_residues(pr, tr)\n    if not quick:\n        for r in pr:\n            dihedra_check(r.internal_coord)\n        for r in tr:\n            dihedra_check(r.internal_coord)\n    if ha != {}:\n        sha = {k: ha[k] for k in sorted(ha)}\n        shl12 = {k: hl12[k] for k in sorted(hl12)}\n        shl23 = {k: hl23[k] for k in sorted(hl23)}\n        sda = {k: da[k] for k in sorted(da)}\n        sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)",
            "def finish_chain() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Do last rnext, rprev links and process chain edra data.'\n    link_residues(pr, tr)\n    if not quick:\n        for r in pr:\n            dihedra_check(r.internal_coord)\n        for r in tr:\n            dihedra_check(r.internal_coord)\n    if ha != {}:\n        sha = {k: ha[k] for k in sorted(ha)}\n        shl12 = {k: hl12[k] for k in sorted(hl12)}\n        shl23 = {k: hl23[k] for k in sorted(hl23)}\n        sda = {k: da[k] for k in sorted(da)}\n        sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)",
            "def finish_chain() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Do last rnext, rprev links and process chain edra data.'\n    link_residues(pr, tr)\n    if not quick:\n        for r in pr:\n            dihedra_check(r.internal_coord)\n        for r in tr:\n            dihedra_check(r.internal_coord)\n    if ha != {}:\n        sha = {k: ha[k] for k in sorted(ha)}\n        shl12 = {k: hl12[k] for k in sorted(hl12)}\n        shl23 = {k: hl23[k] for k in sorted(hl23)}\n        sda = {k: da[k] for k in sorted(da)}\n        sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)",
            "def finish_chain() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Do last rnext, rprev links and process chain edra data.'\n    link_residues(pr, tr)\n    if not quick:\n        for r in pr:\n            dihedra_check(r.internal_coord)\n        for r in tr:\n            dihedra_check(r.internal_coord)\n    if ha != {}:\n        sha = {k: ha[k] for k in sorted(ha)}\n        shl12 = {k: hl12[k] for k in sorted(hl12)}\n        shl23 = {k: hl23[k] for k in sorted(hl23)}\n        sda = {k: da[k] for k in sorted(da)}\n        sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)",
            "def finish_chain() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Do last rnext, rprev links and process chain edra data.'\n    link_residues(pr, tr)\n    if not quick:\n        for r in pr:\n            dihedra_check(r.internal_coord)\n        for r in tr:\n            dihedra_check(r.internal_coord)\n    if ha != {}:\n        sha = {k: ha[k] for k in sorted(ha)}\n        shl12 = {k: hl12[k] for k in sorted(hl12)}\n        shl23 = {k: hl23[k] for k in sorted(hl23)}\n        sda = {k: da[k] for k in sorted(da)}\n        sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)"
        ]
    },
    {
        "func_name": "read_PIC",
        "original": "def read_PIC(file: TextIO, verbose: bool=False, quick: bool=False, defaults: bool=False) -> Structure:\n    \"\"\"Load Protein Internal Coordinate (.pic) data from file.\n\n    PIC file format:\n        - comment lines start with #\n        - (optional) PDB HEADER record\n           - idcode and deposition date recommended but optional\n           - deposition date in PDB format or as changed by Biopython\n        - (optional) PDB TITLE record\n        - repeat:\n           - Biopython Residue Full ID - sets residue IDs of returned structure\n           - (optional) PDB N, CA, C ATOM records for chain start\n           - (optional) PIC Hedra records for residue\n           - (optional) PIC Dihedra records for residue\n           - (optional) BFAC records listing AtomKeys and b-factors\n\n    An improvement would define relative positions for HOH (water) entries.\n\n    Defaults will be supplied for any value if defaults=True.  Default values\n    are supplied in ic_data.py, but structures degrade quickly with any\n    deviation from true coordinates.  Experiment with\n    :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags` options to\n    :func:`write_PIC` to verify this.\n\n    N.B. dihedron (i-1)C-N-CA-CB is ignored in assembly if O exists.\n\n    C-beta is by default placed using O-C-CA-CB, but O is missing\n    in some PDB file residues, which means the sidechain cannot be\n    placed.  The alternate CB path (i-1)C-N-CA-CB is provided to\n    circumvent this, but if this is needed then it must be adjusted in\n    conjunction with PHI ((i-1)C-N-CA-C) as they overlap (see :meth:`.bond_set`\n    and :meth:`.bond_rotate` to handle this automatically).\n\n    :param Bio.File file: :func:`.as_handle` file name or handle\n    :param bool verbose: complain when lines not as expected\n    :param bool quick: don't check residues for all dihedra (no default values)\n    :param bool defaults: create di/hedra as needed from reference database.\n        Amide proton created if 'H' is in IC_Residue.accept_atoms\n    :returns: Biopython Structure object, Residues with .internal_coord\n        attributes but no coordinates except for chain start N, CA, C atoms if\n        supplied, **OR** None on parse fail (silent unless verbose=True)\n\n    \"\"\"\n    proton = 'H' in IC_Residue.accept_atoms\n    pdb_hdr_re = re.compile('^HEADER\\\\s{4}(?P<cf>.{1,40})(?:\\\\s+(?P<dd>\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d|\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d))?(?:\\\\s+(?P<id>[0-9A-Z]{4}))?\\\\s*$')\n    pdb_ttl_re = re.compile('^TITLE\\\\s{5}(?P<ttl>.+)\\\\s*$')\n    biop_id_re = re.compile(\"^\\\\('(?P<pid>[^\\\\s]*)',\\\\s(?P<mdl>\\\\d+),\\\\s'(?P<chn>\\\\s|\\\\w)',\\\\s\\\\('(?P<het>\\\\s|[\\\\w\\\\s-]+)',\\\\s(?P<pos>-?\\\\d+),\\\\s'(?P<icode>\\\\s|\\\\w)'\\\\)\\\\)\\\\s+(?P<res>[\\\\w]{1,3})(\\\\s\\\\[(?P<segid>[a-zA-z\\\\s]+)\\\\])?\\\\s*$\")\n    pdb_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<occ>[\\\\s\\\\d\\\\.]{6})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    pdbx_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<occ>[\\\\s\\\\d\\\\.]{7})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    bfac_re = re.compile('^BFAC:\\\\s([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?')\n    bfac2_re = re.compile('([^\\\\s]+)\\\\s+([\\\\-\\\\d\\\\.]+)')\n    struct_builder = StructureBuilder()\n    header_dict = _parse_pdb_header_list([])\n    curr_SMCS = [None, None, None, None]\n    SMCS_init = [struct_builder.init_structure, struct_builder.init_model, struct_builder.init_chain, struct_builder.init_seg]\n    sb_res = None\n    rkl = None\n    sb_chain = None\n    sbcic = None\n    sbric = None\n    akc = {}\n    hl12 = {}\n    ha = {}\n    hl23 = {}\n    da = {}\n    bfacs = {}\n    orphan_aks = set()\n    tr = []\n    pr = []\n\n    def akcache(akstr: str) -> AtomKey:\n        \"\"\"Maintain dictionary of AtomKeys seen while reading this PIC file.\"\"\"\n        try:\n            return akc[akstr]\n        except KeyError:\n            ak = akc[akstr] = AtomKey(akstr)\n            return ak\n\n    def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n        \"\"\"Set next and prev links between i-1 and i-2 residues.\"\"\"\n        for p_r in pr:\n            pric = p_r.internal_coord\n            for p_p_r in ppr:\n                ppric = p_p_r.internal_coord\n                if p_r.id[0] == ' ':\n                    if pric not in ppric.rnext:\n                        ppric.rnext.append(pric)\n                if p_p_r.id[0] == ' ':\n                    if ppric not in pric.rprev:\n                        pric.rprev.append(ppric)\n\n    def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n        \"\"\"Create Hedron on current (sbcic) Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n            return\n        hl12[ek] = float(l12)\n        ha[ek] = float(ang)\n        hl23[ek] = float(l23)\n        sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n        h.cic = sbcic\n        ak_add(ek, ric)\n        return ek\n\n    def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Create Hedron based on same re_class hedra in ref database.\n\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atomkeys = []\n        hkey = None\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        atomkeys = [ek[i].akl for i in range(3)]\n        atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n        res = atomkeys[0][resNdx]\n        if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n            hkey = ek\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n            try:\n                dflts = hedra_defaults[''.join(rhcl)][0]\n            except KeyError:\n                if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                    rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n                else:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                    rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n                dflts = hedra_defaults[rhc][0]\n        else:\n            hkey = ek[::-1]\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n        if verbose:\n            print(f' default for {ek}')\n\n    def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Confirm both hedra present for dihedron key, use default if set.\"\"\"\n        if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[0:3], ric)\n            else:\n                print(f'{dk} missing h1')\n        if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[1:4], ric)\n            else:\n                print(f'{dk} missing h2')\n\n    def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n        \"\"\"Create Dihedron on current Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n            return\n        dangle = float(dangle)\n        dangle = dangle if dangle <= 180.0 else dangle - 360.0\n        dangle = dangle if dangle >= -180.0 else dangle + 360.0\n        da[ek] = float(dangle)\n        sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n        d.cic = sbcic\n        if not quick:\n            hedra_check(ek, ric)\n        ak_add(ek, ric)\n        return ek\n\n    def default_dihedron(ek: List, ric: IC_Residue) -> None:\n        \"\"\"Create Dihedron based on same residue class dihedra in ref database.\n\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        rdclass = ''\n        dclass = ''\n        for ak in ek:\n            dclass += ak.akl[atmNdx]\n            rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n        if dclass == 'NCACN':\n            rdclass = rdclass[0:7] + 'XN'\n        elif dclass == 'CACNCA':\n            rdclass = 'XCAXC' + rdclass[5:]\n        elif dclass == 'CNCAC':\n            rdclass = 'XC' + rdclass[2:]\n        if rdclass in dihedra_primary_defaults:\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n            if verbose:\n                print(f' default for {ek}')\n        elif rdclass in dihedra_secondary_defaults:\n            (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n            rname = ek[2].akl[resNdx]\n            rnum = int(ek[2].akl[resPos])\n            paKey = None\n            if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n                paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n                rnext = ek[0].ric.rnext\n                paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n                paKey = tuple(paKey)\n            elif primAngle == ('CA', 'C', 'N', 'CA'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n                paKey = tuple(paKey)\n            else:\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' secondary default for {ek}')\n            elif rdclass in dihedra_secondary_xoxt_defaults:\n                if primAngle == ('C', 'N', 'CA', 'C'):\n                    prname = pr.akl[0][resNdx]\n                    prnum = pr.akl[0][resPos]\n                    paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                    paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                    paKey = tuple(paKey)\n                else:\n                    (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                    rname = ek[2].akl[resNdx]\n                    rnum = int(ek[2].akl[resPos])\n                    paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n                if paKey in da:\n                    angl = da[paKey] + offset\n                    process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                    if verbose:\n                        print(f' oxt default for {ek}')\n                else:\n                    print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n        else:\n            print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')\n\n    def dihedra_check(ric: IC_Residue) -> None:\n        \"\"\"Look for required dihedra in residue, generate defaults if set.\"\"\"\n\n        def ake_recurse(akList: List) -> List:\n            \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n            car = akList[0]\n            if len(akList) > 1:\n                retList = []\n                for ak in car:\n                    cdr = akList[1:]\n                    rslt = ake_recurse(cdr)\n                    for r in rslt:\n                        r.insert(0, ak)\n                        retList.append(r)\n                return retList\n            elif len(car) == 1:\n                return [list(car)]\n            else:\n                retList = [[ak] for ak in car]\n                return retList\n\n        def ak_expand(eLst: List) -> List:\n            \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n            retList = []\n            for edron in eLst:\n                newList = []\n                for ak in edron:\n                    rslt = ak.ric.split_akl([ak])\n                    rlst = [r[0] for r in rslt]\n                    if rlst != []:\n                        newList.append(rlst)\n                    else:\n                        newList.append([ak])\n                rslt = ake_recurse(newList)\n                for r in rslt:\n                    retList.append(r)\n            return retList\n        chkLst = []\n        (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n        (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n        if ric.rnext != []:\n            for rn in ric.rnext:\n                (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n                chkLst.append((sN, sCA, sC, nN))\n                chkLst.append((sCA, sC, nN, nCA))\n                chkLst.append((sC, nN, nCA, nC))\n        else:\n            chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n            rn = '(no rnext)'\n        chkLst.append((sN, sCA, sC, sO))\n        if ric.lc != 'G':\n            chkLst.append((sO, sC, sCA, sCB))\n            if ric.lc == 'A':\n                chkLst.append((sN, sCA, sCB))\n        if ric.rprev != [] and ric.lc != 'P' and proton:\n            chkLst.append((sC, sCA, sN, sH))\n        try:\n            for edron in ic_data_sidechains[ric.lc]:\n                if len(edron) > 3:\n                    if all((atm[0] != 'H' for atm in edron)):\n                        akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                        chkLst.append(akl)\n        except KeyError:\n            pass\n        chkLst = ak_expand(chkLst)\n        altloc_ndx = AtomKey.fields.altloc\n        for dk in chkLst:\n            if tuple(dk) in ric.dihedra:\n                pass\n            elif sH in dk:\n                pass\n            elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n                if defaults:\n                    if len(dk) != 3:\n                        default_dihedron(dk, ric)\n                    else:\n                        default_hedron(dk, ric)\n                elif verbose:\n                    print(f'{ric}-{rn} missing {dk}')\n            else:\n                pass\n\n    def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Allocate edron key AtomKeys to current residue as appropriate.\n\n        A hedron or dihedron may span a backbone amide bond, this routine\n        allocates atoms in the (h/di)edron to the ric residue or saves them\n        for a residue yet to be processed.\n\n        :param set ek: AtomKeys in edron\n        :param IC_Residue ric: current residue to assign AtomKeys to\n        \"\"\"\n        res = ric.residue\n        reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n        for ak in ek:\n            if ak.ric is None:\n                sbcic.akset.add(ak)\n                if ak.akl[0:3] == reskl:\n                    ak.ric = ric\n                    ric.ak_set.add(ak)\n                else:\n                    orphan_aks.add(ak)\n\n    def finish_chain() -> None:\n        \"\"\"Do last rnext, rprev links and process chain edra data.\"\"\"\n        link_residues(pr, tr)\n        if not quick:\n            for r in pr:\n                dihedra_check(r.internal_coord)\n            for r in tr:\n                dihedra_check(r.internal_coord)\n        if ha != {}:\n            sha = {k: ha[k] for k in sorted(ha)}\n            shl12 = {k: hl12[k] for k in sorted(hl12)}\n            shl23 = {k: hl23[k] for k in sorted(hl23)}\n            sda = {k: da[k] for k in sorted(da)}\n            sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)\n    with as_handle(file, mode='r') as handle:\n        for line in handle.readlines():\n            if line.startswith('#'):\n                pass\n            elif line.startswith('HEADER '):\n                m = pdb_hdr_re.match(line)\n                if m:\n                    header_dict['head'] = m.group('cf')\n                    header_dict['idcode'] = m.group('id')\n                    header_dict['deposition_date'] = m.group('dd')\n                elif verbose:\n                    print('Reading pic file', file, 'HEADER parse fail: ', line)\n            elif line.startswith('TITLE '):\n                m = pdb_ttl_re.match(line)\n                if m:\n                    header_dict['name'] = m.group('ttl').strip()\n                elif verbose:\n                    print('Reading pic file', file, 'TITLE parse fail:, ', line)\n            elif line.startswith('('):\n                m = biop_id_re.match(line)\n                if m:\n                    segid = m.group(9)\n                    if segid is None:\n                        segid = '    '\n                    this_SMCS = [m.group(1), int(m.group(2)), m.group(3), segid]\n                    if curr_SMCS != this_SMCS:\n                        if curr_SMCS[:3] != this_SMCS[:3] and ha != {}:\n                            finish_chain()\n                            akc = {}\n                            hl12 = {}\n                            ha = {}\n                            hl23 = {}\n                            da = {}\n                            bfacs = {}\n                        for i in range(4):\n                            if curr_SMCS[i] != this_SMCS[i]:\n                                SMCS_init[i](this_SMCS[i])\n                                curr_SMCS[i] = this_SMCS[i]\n                                if i == 0:\n                                    struct_builder.set_header(header_dict)\n                                elif i == 1:\n                                    curr_SMCS[2] = curr_SMCS[3] = None\n                                elif i == 2:\n                                    sb_chain = struct_builder.chain\n                                    sbcic = sb_chain.internal_coord = IC_Chain(sb_chain)\n                    struct_builder.init_residue(m.group('res'), m.group('het'), int(m.group('pos')), m.group('icode'))\n                    sb_res = struct_builder.residue\n                    if sb_res.id[0] != ' ':\n                        continue\n                    if 2 == sb_res.is_disordered():\n                        for r in sb_res.child_dict.values():\n                            if not r.internal_coord:\n                                sb_res = r\n                                break\n                        tr.append(sb_res)\n                    else:\n                        link_residues(pr, tr)\n                        if not quick:\n                            for r in pr:\n                                dihedra_check(r.internal_coord)\n                        pr = tr\n                        tr = [sb_res]\n                    sbric = sb_res.internal_coord = IC_Residue(sb_res)\n                    sbric.cic = sbcic\n                    rkl = (str(sb_res.id[1]), None if sb_res.id[2] == ' ' else sb_res.id[2], sbric.lc)\n                    sbcic.ordered_aa_ic_list.append(sbric)\n                    for ak in orphan_aks:\n                        if ak.akl[0:3] == rkl:\n                            ak.ric = sbric\n                            sbric.ak_set.add(ak)\n                    orphan_aks = set(filter(lambda ak: ak.ric is None, orphan_aks))\n                else:\n                    if verbose:\n                        print('Reading pic file', file, 'residue ID parse fail: ', line)\n                    return None\n            elif line.startswith('ATOM '):\n                m = pdb_atm_re.match(line)\n                if not m:\n                    m = pdbx_atm_re.match(line)\n                if m:\n                    if sb_res is None:\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM without residue configured:, ', line)\n                        return None\n                    if sb_res.resname != m.group('res') or sb_res.id[1] != int(m.group('pos')):\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM not in configured residue (', sb_res.resname, str(sb_res.id), '):', line)\n                        return None\n                    coord = np.array((float(m.group('x')), float(m.group('y')), float(m.group('z'))), 'f')\n                    struct_builder.init_atom(m.group('atm').strip(), coord, float(m.group('tfac')), float(m.group('occ')), m.group('alc'), m.group('atm'), int(m.group('ser')), m.group('elm').strip())\n                    pr = []\n            elif line.startswith('BFAC: '):\n                m = bfac_re.match(line)\n                if m:\n                    for bfac_pair in m.groups():\n                        if bfac_pair is not None:\n                            m2 = bfac2_re.match(bfac_pair)\n                            bfacs[m2.group(1)] = float(m2.group(2))\n            else:\n                m = Edron.edron_re.match(line)\n                if m and sb_res is not None:\n                    if m['a4'] is None:\n                        process_hedron(m['a1'], m['a2'], m['a3'], m['len12'], m['angle'], m['len23'], sb_res.internal_coord)\n                    else:\n                        process_dihedron(m['a1'], m['a2'], m['a3'], m['a4'], m['dihedral'], sb_res.internal_coord)\n                elif m:\n                    print('PIC file: ', file, ' error: no residue info before reading (di/h)edron: ', line)\n                    return None\n                elif line.strip():\n                    if verbose:\n                        print('Reading PIC file', file, 'parse fail on: .', line, '.')\n                    return None\n    finish_chain()\n    return struct_builder.get_structure()",
        "mutated": [
            "def read_PIC(file: TextIO, verbose: bool=False, quick: bool=False, defaults: bool=False) -> Structure:\n    if False:\n        i = 10\n    \"Load Protein Internal Coordinate (.pic) data from file.\\n\\n    PIC file format:\\n        - comment lines start with #\\n        - (optional) PDB HEADER record\\n           - idcode and deposition date recommended but optional\\n           - deposition date in PDB format or as changed by Biopython\\n        - (optional) PDB TITLE record\\n        - repeat:\\n           - Biopython Residue Full ID - sets residue IDs of returned structure\\n           - (optional) PDB N, CA, C ATOM records for chain start\\n           - (optional) PIC Hedra records for residue\\n           - (optional) PIC Dihedra records for residue\\n           - (optional) BFAC records listing AtomKeys and b-factors\\n\\n    An improvement would define relative positions for HOH (water) entries.\\n\\n    Defaults will be supplied for any value if defaults=True.  Default values\\n    are supplied in ic_data.py, but structures degrade quickly with any\\n    deviation from true coordinates.  Experiment with\\n    :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags` options to\\n    :func:`write_PIC` to verify this.\\n\\n    N.B. dihedron (i-1)C-N-CA-CB is ignored in assembly if O exists.\\n\\n    C-beta is by default placed using O-C-CA-CB, but O is missing\\n    in some PDB file residues, which means the sidechain cannot be\\n    placed.  The alternate CB path (i-1)C-N-CA-CB is provided to\\n    circumvent this, but if this is needed then it must be adjusted in\\n    conjunction with PHI ((i-1)C-N-CA-C) as they overlap (see :meth:`.bond_set`\\n    and :meth:`.bond_rotate` to handle this automatically).\\n\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param bool verbose: complain when lines not as expected\\n    :param bool quick: don't check residues for all dihedra (no default values)\\n    :param bool defaults: create di/hedra as needed from reference database.\\n        Amide proton created if 'H' is in IC_Residue.accept_atoms\\n    :returns: Biopython Structure object, Residues with .internal_coord\\n        attributes but no coordinates except for chain start N, CA, C atoms if\\n        supplied, **OR** None on parse fail (silent unless verbose=True)\\n\\n    \"\n    proton = 'H' in IC_Residue.accept_atoms\n    pdb_hdr_re = re.compile('^HEADER\\\\s{4}(?P<cf>.{1,40})(?:\\\\s+(?P<dd>\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d|\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d))?(?:\\\\s+(?P<id>[0-9A-Z]{4}))?\\\\s*$')\n    pdb_ttl_re = re.compile('^TITLE\\\\s{5}(?P<ttl>.+)\\\\s*$')\n    biop_id_re = re.compile(\"^\\\\('(?P<pid>[^\\\\s]*)',\\\\s(?P<mdl>\\\\d+),\\\\s'(?P<chn>\\\\s|\\\\w)',\\\\s\\\\('(?P<het>\\\\s|[\\\\w\\\\s-]+)',\\\\s(?P<pos>-?\\\\d+),\\\\s'(?P<icode>\\\\s|\\\\w)'\\\\)\\\\)\\\\s+(?P<res>[\\\\w]{1,3})(\\\\s\\\\[(?P<segid>[a-zA-z\\\\s]+)\\\\])?\\\\s*$\")\n    pdb_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<occ>[\\\\s\\\\d\\\\.]{6})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    pdbx_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<occ>[\\\\s\\\\d\\\\.]{7})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    bfac_re = re.compile('^BFAC:\\\\s([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?')\n    bfac2_re = re.compile('([^\\\\s]+)\\\\s+([\\\\-\\\\d\\\\.]+)')\n    struct_builder = StructureBuilder()\n    header_dict = _parse_pdb_header_list([])\n    curr_SMCS = [None, None, None, None]\n    SMCS_init = [struct_builder.init_structure, struct_builder.init_model, struct_builder.init_chain, struct_builder.init_seg]\n    sb_res = None\n    rkl = None\n    sb_chain = None\n    sbcic = None\n    sbric = None\n    akc = {}\n    hl12 = {}\n    ha = {}\n    hl23 = {}\n    da = {}\n    bfacs = {}\n    orphan_aks = set()\n    tr = []\n    pr = []\n\n    def akcache(akstr: str) -> AtomKey:\n        \"\"\"Maintain dictionary of AtomKeys seen while reading this PIC file.\"\"\"\n        try:\n            return akc[akstr]\n        except KeyError:\n            ak = akc[akstr] = AtomKey(akstr)\n            return ak\n\n    def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n        \"\"\"Set next and prev links between i-1 and i-2 residues.\"\"\"\n        for p_r in pr:\n            pric = p_r.internal_coord\n            for p_p_r in ppr:\n                ppric = p_p_r.internal_coord\n                if p_r.id[0] == ' ':\n                    if pric not in ppric.rnext:\n                        ppric.rnext.append(pric)\n                if p_p_r.id[0] == ' ':\n                    if ppric not in pric.rprev:\n                        pric.rprev.append(ppric)\n\n    def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n        \"\"\"Create Hedron on current (sbcic) Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n            return\n        hl12[ek] = float(l12)\n        ha[ek] = float(ang)\n        hl23[ek] = float(l23)\n        sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n        h.cic = sbcic\n        ak_add(ek, ric)\n        return ek\n\n    def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Create Hedron based on same re_class hedra in ref database.\n\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atomkeys = []\n        hkey = None\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        atomkeys = [ek[i].akl for i in range(3)]\n        atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n        res = atomkeys[0][resNdx]\n        if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n            hkey = ek\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n            try:\n                dflts = hedra_defaults[''.join(rhcl)][0]\n            except KeyError:\n                if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                    rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n                else:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                    rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n                dflts = hedra_defaults[rhc][0]\n        else:\n            hkey = ek[::-1]\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n        if verbose:\n            print(f' default for {ek}')\n\n    def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Confirm both hedra present for dihedron key, use default if set.\"\"\"\n        if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[0:3], ric)\n            else:\n                print(f'{dk} missing h1')\n        if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[1:4], ric)\n            else:\n                print(f'{dk} missing h2')\n\n    def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n        \"\"\"Create Dihedron on current Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n            return\n        dangle = float(dangle)\n        dangle = dangle if dangle <= 180.0 else dangle - 360.0\n        dangle = dangle if dangle >= -180.0 else dangle + 360.0\n        da[ek] = float(dangle)\n        sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n        d.cic = sbcic\n        if not quick:\n            hedra_check(ek, ric)\n        ak_add(ek, ric)\n        return ek\n\n    def default_dihedron(ek: List, ric: IC_Residue) -> None:\n        \"\"\"Create Dihedron based on same residue class dihedra in ref database.\n\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        rdclass = ''\n        dclass = ''\n        for ak in ek:\n            dclass += ak.akl[atmNdx]\n            rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n        if dclass == 'NCACN':\n            rdclass = rdclass[0:7] + 'XN'\n        elif dclass == 'CACNCA':\n            rdclass = 'XCAXC' + rdclass[5:]\n        elif dclass == 'CNCAC':\n            rdclass = 'XC' + rdclass[2:]\n        if rdclass in dihedra_primary_defaults:\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n            if verbose:\n                print(f' default for {ek}')\n        elif rdclass in dihedra_secondary_defaults:\n            (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n            rname = ek[2].akl[resNdx]\n            rnum = int(ek[2].akl[resPos])\n            paKey = None\n            if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n                paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n                rnext = ek[0].ric.rnext\n                paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n                paKey = tuple(paKey)\n            elif primAngle == ('CA', 'C', 'N', 'CA'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n                paKey = tuple(paKey)\n            else:\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' secondary default for {ek}')\n            elif rdclass in dihedra_secondary_xoxt_defaults:\n                if primAngle == ('C', 'N', 'CA', 'C'):\n                    prname = pr.akl[0][resNdx]\n                    prnum = pr.akl[0][resPos]\n                    paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                    paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                    paKey = tuple(paKey)\n                else:\n                    (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                    rname = ek[2].akl[resNdx]\n                    rnum = int(ek[2].akl[resPos])\n                    paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n                if paKey in da:\n                    angl = da[paKey] + offset\n                    process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                    if verbose:\n                        print(f' oxt default for {ek}')\n                else:\n                    print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n        else:\n            print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')\n\n    def dihedra_check(ric: IC_Residue) -> None:\n        \"\"\"Look for required dihedra in residue, generate defaults if set.\"\"\"\n\n        def ake_recurse(akList: List) -> List:\n            \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n            car = akList[0]\n            if len(akList) > 1:\n                retList = []\n                for ak in car:\n                    cdr = akList[1:]\n                    rslt = ake_recurse(cdr)\n                    for r in rslt:\n                        r.insert(0, ak)\n                        retList.append(r)\n                return retList\n            elif len(car) == 1:\n                return [list(car)]\n            else:\n                retList = [[ak] for ak in car]\n                return retList\n\n        def ak_expand(eLst: List) -> List:\n            \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n            retList = []\n            for edron in eLst:\n                newList = []\n                for ak in edron:\n                    rslt = ak.ric.split_akl([ak])\n                    rlst = [r[0] for r in rslt]\n                    if rlst != []:\n                        newList.append(rlst)\n                    else:\n                        newList.append([ak])\n                rslt = ake_recurse(newList)\n                for r in rslt:\n                    retList.append(r)\n            return retList\n        chkLst = []\n        (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n        (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n        if ric.rnext != []:\n            for rn in ric.rnext:\n                (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n                chkLst.append((sN, sCA, sC, nN))\n                chkLst.append((sCA, sC, nN, nCA))\n                chkLst.append((sC, nN, nCA, nC))\n        else:\n            chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n            rn = '(no rnext)'\n        chkLst.append((sN, sCA, sC, sO))\n        if ric.lc != 'G':\n            chkLst.append((sO, sC, sCA, sCB))\n            if ric.lc == 'A':\n                chkLst.append((sN, sCA, sCB))\n        if ric.rprev != [] and ric.lc != 'P' and proton:\n            chkLst.append((sC, sCA, sN, sH))\n        try:\n            for edron in ic_data_sidechains[ric.lc]:\n                if len(edron) > 3:\n                    if all((atm[0] != 'H' for atm in edron)):\n                        akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                        chkLst.append(akl)\n        except KeyError:\n            pass\n        chkLst = ak_expand(chkLst)\n        altloc_ndx = AtomKey.fields.altloc\n        for dk in chkLst:\n            if tuple(dk) in ric.dihedra:\n                pass\n            elif sH in dk:\n                pass\n            elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n                if defaults:\n                    if len(dk) != 3:\n                        default_dihedron(dk, ric)\n                    else:\n                        default_hedron(dk, ric)\n                elif verbose:\n                    print(f'{ric}-{rn} missing {dk}')\n            else:\n                pass\n\n    def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Allocate edron key AtomKeys to current residue as appropriate.\n\n        A hedron or dihedron may span a backbone amide bond, this routine\n        allocates atoms in the (h/di)edron to the ric residue or saves them\n        for a residue yet to be processed.\n\n        :param set ek: AtomKeys in edron\n        :param IC_Residue ric: current residue to assign AtomKeys to\n        \"\"\"\n        res = ric.residue\n        reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n        for ak in ek:\n            if ak.ric is None:\n                sbcic.akset.add(ak)\n                if ak.akl[0:3] == reskl:\n                    ak.ric = ric\n                    ric.ak_set.add(ak)\n                else:\n                    orphan_aks.add(ak)\n\n    def finish_chain() -> None:\n        \"\"\"Do last rnext, rprev links and process chain edra data.\"\"\"\n        link_residues(pr, tr)\n        if not quick:\n            for r in pr:\n                dihedra_check(r.internal_coord)\n            for r in tr:\n                dihedra_check(r.internal_coord)\n        if ha != {}:\n            sha = {k: ha[k] for k in sorted(ha)}\n            shl12 = {k: hl12[k] for k in sorted(hl12)}\n            shl23 = {k: hl23[k] for k in sorted(hl23)}\n            sda = {k: da[k] for k in sorted(da)}\n            sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)\n    with as_handle(file, mode='r') as handle:\n        for line in handle.readlines():\n            if line.startswith('#'):\n                pass\n            elif line.startswith('HEADER '):\n                m = pdb_hdr_re.match(line)\n                if m:\n                    header_dict['head'] = m.group('cf')\n                    header_dict['idcode'] = m.group('id')\n                    header_dict['deposition_date'] = m.group('dd')\n                elif verbose:\n                    print('Reading pic file', file, 'HEADER parse fail: ', line)\n            elif line.startswith('TITLE '):\n                m = pdb_ttl_re.match(line)\n                if m:\n                    header_dict['name'] = m.group('ttl').strip()\n                elif verbose:\n                    print('Reading pic file', file, 'TITLE parse fail:, ', line)\n            elif line.startswith('('):\n                m = biop_id_re.match(line)\n                if m:\n                    segid = m.group(9)\n                    if segid is None:\n                        segid = '    '\n                    this_SMCS = [m.group(1), int(m.group(2)), m.group(3), segid]\n                    if curr_SMCS != this_SMCS:\n                        if curr_SMCS[:3] != this_SMCS[:3] and ha != {}:\n                            finish_chain()\n                            akc = {}\n                            hl12 = {}\n                            ha = {}\n                            hl23 = {}\n                            da = {}\n                            bfacs = {}\n                        for i in range(4):\n                            if curr_SMCS[i] != this_SMCS[i]:\n                                SMCS_init[i](this_SMCS[i])\n                                curr_SMCS[i] = this_SMCS[i]\n                                if i == 0:\n                                    struct_builder.set_header(header_dict)\n                                elif i == 1:\n                                    curr_SMCS[2] = curr_SMCS[3] = None\n                                elif i == 2:\n                                    sb_chain = struct_builder.chain\n                                    sbcic = sb_chain.internal_coord = IC_Chain(sb_chain)\n                    struct_builder.init_residue(m.group('res'), m.group('het'), int(m.group('pos')), m.group('icode'))\n                    sb_res = struct_builder.residue\n                    if sb_res.id[0] != ' ':\n                        continue\n                    if 2 == sb_res.is_disordered():\n                        for r in sb_res.child_dict.values():\n                            if not r.internal_coord:\n                                sb_res = r\n                                break\n                        tr.append(sb_res)\n                    else:\n                        link_residues(pr, tr)\n                        if not quick:\n                            for r in pr:\n                                dihedra_check(r.internal_coord)\n                        pr = tr\n                        tr = [sb_res]\n                    sbric = sb_res.internal_coord = IC_Residue(sb_res)\n                    sbric.cic = sbcic\n                    rkl = (str(sb_res.id[1]), None if sb_res.id[2] == ' ' else sb_res.id[2], sbric.lc)\n                    sbcic.ordered_aa_ic_list.append(sbric)\n                    for ak in orphan_aks:\n                        if ak.akl[0:3] == rkl:\n                            ak.ric = sbric\n                            sbric.ak_set.add(ak)\n                    orphan_aks = set(filter(lambda ak: ak.ric is None, orphan_aks))\n                else:\n                    if verbose:\n                        print('Reading pic file', file, 'residue ID parse fail: ', line)\n                    return None\n            elif line.startswith('ATOM '):\n                m = pdb_atm_re.match(line)\n                if not m:\n                    m = pdbx_atm_re.match(line)\n                if m:\n                    if sb_res is None:\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM without residue configured:, ', line)\n                        return None\n                    if sb_res.resname != m.group('res') or sb_res.id[1] != int(m.group('pos')):\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM not in configured residue (', sb_res.resname, str(sb_res.id), '):', line)\n                        return None\n                    coord = np.array((float(m.group('x')), float(m.group('y')), float(m.group('z'))), 'f')\n                    struct_builder.init_atom(m.group('atm').strip(), coord, float(m.group('tfac')), float(m.group('occ')), m.group('alc'), m.group('atm'), int(m.group('ser')), m.group('elm').strip())\n                    pr = []\n            elif line.startswith('BFAC: '):\n                m = bfac_re.match(line)\n                if m:\n                    for bfac_pair in m.groups():\n                        if bfac_pair is not None:\n                            m2 = bfac2_re.match(bfac_pair)\n                            bfacs[m2.group(1)] = float(m2.group(2))\n            else:\n                m = Edron.edron_re.match(line)\n                if m and sb_res is not None:\n                    if m['a4'] is None:\n                        process_hedron(m['a1'], m['a2'], m['a3'], m['len12'], m['angle'], m['len23'], sb_res.internal_coord)\n                    else:\n                        process_dihedron(m['a1'], m['a2'], m['a3'], m['a4'], m['dihedral'], sb_res.internal_coord)\n                elif m:\n                    print('PIC file: ', file, ' error: no residue info before reading (di/h)edron: ', line)\n                    return None\n                elif line.strip():\n                    if verbose:\n                        print('Reading PIC file', file, 'parse fail on: .', line, '.')\n                    return None\n    finish_chain()\n    return struct_builder.get_structure()",
            "def read_PIC(file: TextIO, verbose: bool=False, quick: bool=False, defaults: bool=False) -> Structure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Load Protein Internal Coordinate (.pic) data from file.\\n\\n    PIC file format:\\n        - comment lines start with #\\n        - (optional) PDB HEADER record\\n           - idcode and deposition date recommended but optional\\n           - deposition date in PDB format or as changed by Biopython\\n        - (optional) PDB TITLE record\\n        - repeat:\\n           - Biopython Residue Full ID - sets residue IDs of returned structure\\n           - (optional) PDB N, CA, C ATOM records for chain start\\n           - (optional) PIC Hedra records for residue\\n           - (optional) PIC Dihedra records for residue\\n           - (optional) BFAC records listing AtomKeys and b-factors\\n\\n    An improvement would define relative positions for HOH (water) entries.\\n\\n    Defaults will be supplied for any value if defaults=True.  Default values\\n    are supplied in ic_data.py, but structures degrade quickly with any\\n    deviation from true coordinates.  Experiment with\\n    :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags` options to\\n    :func:`write_PIC` to verify this.\\n\\n    N.B. dihedron (i-1)C-N-CA-CB is ignored in assembly if O exists.\\n\\n    C-beta is by default placed using O-C-CA-CB, but O is missing\\n    in some PDB file residues, which means the sidechain cannot be\\n    placed.  The alternate CB path (i-1)C-N-CA-CB is provided to\\n    circumvent this, but if this is needed then it must be adjusted in\\n    conjunction with PHI ((i-1)C-N-CA-C) as they overlap (see :meth:`.bond_set`\\n    and :meth:`.bond_rotate` to handle this automatically).\\n\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param bool verbose: complain when lines not as expected\\n    :param bool quick: don't check residues for all dihedra (no default values)\\n    :param bool defaults: create di/hedra as needed from reference database.\\n        Amide proton created if 'H' is in IC_Residue.accept_atoms\\n    :returns: Biopython Structure object, Residues with .internal_coord\\n        attributes but no coordinates except for chain start N, CA, C atoms if\\n        supplied, **OR** None on parse fail (silent unless verbose=True)\\n\\n    \"\n    proton = 'H' in IC_Residue.accept_atoms\n    pdb_hdr_re = re.compile('^HEADER\\\\s{4}(?P<cf>.{1,40})(?:\\\\s+(?P<dd>\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d|\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d))?(?:\\\\s+(?P<id>[0-9A-Z]{4}))?\\\\s*$')\n    pdb_ttl_re = re.compile('^TITLE\\\\s{5}(?P<ttl>.+)\\\\s*$')\n    biop_id_re = re.compile(\"^\\\\('(?P<pid>[^\\\\s]*)',\\\\s(?P<mdl>\\\\d+),\\\\s'(?P<chn>\\\\s|\\\\w)',\\\\s\\\\('(?P<het>\\\\s|[\\\\w\\\\s-]+)',\\\\s(?P<pos>-?\\\\d+),\\\\s'(?P<icode>\\\\s|\\\\w)'\\\\)\\\\)\\\\s+(?P<res>[\\\\w]{1,3})(\\\\s\\\\[(?P<segid>[a-zA-z\\\\s]+)\\\\])?\\\\s*$\")\n    pdb_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<occ>[\\\\s\\\\d\\\\.]{6})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    pdbx_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<occ>[\\\\s\\\\d\\\\.]{7})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    bfac_re = re.compile('^BFAC:\\\\s([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?')\n    bfac2_re = re.compile('([^\\\\s]+)\\\\s+([\\\\-\\\\d\\\\.]+)')\n    struct_builder = StructureBuilder()\n    header_dict = _parse_pdb_header_list([])\n    curr_SMCS = [None, None, None, None]\n    SMCS_init = [struct_builder.init_structure, struct_builder.init_model, struct_builder.init_chain, struct_builder.init_seg]\n    sb_res = None\n    rkl = None\n    sb_chain = None\n    sbcic = None\n    sbric = None\n    akc = {}\n    hl12 = {}\n    ha = {}\n    hl23 = {}\n    da = {}\n    bfacs = {}\n    orphan_aks = set()\n    tr = []\n    pr = []\n\n    def akcache(akstr: str) -> AtomKey:\n        \"\"\"Maintain dictionary of AtomKeys seen while reading this PIC file.\"\"\"\n        try:\n            return akc[akstr]\n        except KeyError:\n            ak = akc[akstr] = AtomKey(akstr)\n            return ak\n\n    def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n        \"\"\"Set next and prev links between i-1 and i-2 residues.\"\"\"\n        for p_r in pr:\n            pric = p_r.internal_coord\n            for p_p_r in ppr:\n                ppric = p_p_r.internal_coord\n                if p_r.id[0] == ' ':\n                    if pric not in ppric.rnext:\n                        ppric.rnext.append(pric)\n                if p_p_r.id[0] == ' ':\n                    if ppric not in pric.rprev:\n                        pric.rprev.append(ppric)\n\n    def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n        \"\"\"Create Hedron on current (sbcic) Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n            return\n        hl12[ek] = float(l12)\n        ha[ek] = float(ang)\n        hl23[ek] = float(l23)\n        sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n        h.cic = sbcic\n        ak_add(ek, ric)\n        return ek\n\n    def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Create Hedron based on same re_class hedra in ref database.\n\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atomkeys = []\n        hkey = None\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        atomkeys = [ek[i].akl for i in range(3)]\n        atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n        res = atomkeys[0][resNdx]\n        if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n            hkey = ek\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n            try:\n                dflts = hedra_defaults[''.join(rhcl)][0]\n            except KeyError:\n                if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                    rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n                else:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                    rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n                dflts = hedra_defaults[rhc][0]\n        else:\n            hkey = ek[::-1]\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n        if verbose:\n            print(f' default for {ek}')\n\n    def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Confirm both hedra present for dihedron key, use default if set.\"\"\"\n        if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[0:3], ric)\n            else:\n                print(f'{dk} missing h1')\n        if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[1:4], ric)\n            else:\n                print(f'{dk} missing h2')\n\n    def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n        \"\"\"Create Dihedron on current Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n            return\n        dangle = float(dangle)\n        dangle = dangle if dangle <= 180.0 else dangle - 360.0\n        dangle = dangle if dangle >= -180.0 else dangle + 360.0\n        da[ek] = float(dangle)\n        sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n        d.cic = sbcic\n        if not quick:\n            hedra_check(ek, ric)\n        ak_add(ek, ric)\n        return ek\n\n    def default_dihedron(ek: List, ric: IC_Residue) -> None:\n        \"\"\"Create Dihedron based on same residue class dihedra in ref database.\n\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        rdclass = ''\n        dclass = ''\n        for ak in ek:\n            dclass += ak.akl[atmNdx]\n            rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n        if dclass == 'NCACN':\n            rdclass = rdclass[0:7] + 'XN'\n        elif dclass == 'CACNCA':\n            rdclass = 'XCAXC' + rdclass[5:]\n        elif dclass == 'CNCAC':\n            rdclass = 'XC' + rdclass[2:]\n        if rdclass in dihedra_primary_defaults:\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n            if verbose:\n                print(f' default for {ek}')\n        elif rdclass in dihedra_secondary_defaults:\n            (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n            rname = ek[2].akl[resNdx]\n            rnum = int(ek[2].akl[resPos])\n            paKey = None\n            if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n                paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n                rnext = ek[0].ric.rnext\n                paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n                paKey = tuple(paKey)\n            elif primAngle == ('CA', 'C', 'N', 'CA'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n                paKey = tuple(paKey)\n            else:\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' secondary default for {ek}')\n            elif rdclass in dihedra_secondary_xoxt_defaults:\n                if primAngle == ('C', 'N', 'CA', 'C'):\n                    prname = pr.akl[0][resNdx]\n                    prnum = pr.akl[0][resPos]\n                    paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                    paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                    paKey = tuple(paKey)\n                else:\n                    (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                    rname = ek[2].akl[resNdx]\n                    rnum = int(ek[2].akl[resPos])\n                    paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n                if paKey in da:\n                    angl = da[paKey] + offset\n                    process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                    if verbose:\n                        print(f' oxt default for {ek}')\n                else:\n                    print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n        else:\n            print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')\n\n    def dihedra_check(ric: IC_Residue) -> None:\n        \"\"\"Look for required dihedra in residue, generate defaults if set.\"\"\"\n\n        def ake_recurse(akList: List) -> List:\n            \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n            car = akList[0]\n            if len(akList) > 1:\n                retList = []\n                for ak in car:\n                    cdr = akList[1:]\n                    rslt = ake_recurse(cdr)\n                    for r in rslt:\n                        r.insert(0, ak)\n                        retList.append(r)\n                return retList\n            elif len(car) == 1:\n                return [list(car)]\n            else:\n                retList = [[ak] for ak in car]\n                return retList\n\n        def ak_expand(eLst: List) -> List:\n            \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n            retList = []\n            for edron in eLst:\n                newList = []\n                for ak in edron:\n                    rslt = ak.ric.split_akl([ak])\n                    rlst = [r[0] for r in rslt]\n                    if rlst != []:\n                        newList.append(rlst)\n                    else:\n                        newList.append([ak])\n                rslt = ake_recurse(newList)\n                for r in rslt:\n                    retList.append(r)\n            return retList\n        chkLst = []\n        (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n        (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n        if ric.rnext != []:\n            for rn in ric.rnext:\n                (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n                chkLst.append((sN, sCA, sC, nN))\n                chkLst.append((sCA, sC, nN, nCA))\n                chkLst.append((sC, nN, nCA, nC))\n        else:\n            chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n            rn = '(no rnext)'\n        chkLst.append((sN, sCA, sC, sO))\n        if ric.lc != 'G':\n            chkLst.append((sO, sC, sCA, sCB))\n            if ric.lc == 'A':\n                chkLst.append((sN, sCA, sCB))\n        if ric.rprev != [] and ric.lc != 'P' and proton:\n            chkLst.append((sC, sCA, sN, sH))\n        try:\n            for edron in ic_data_sidechains[ric.lc]:\n                if len(edron) > 3:\n                    if all((atm[0] != 'H' for atm in edron)):\n                        akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                        chkLst.append(akl)\n        except KeyError:\n            pass\n        chkLst = ak_expand(chkLst)\n        altloc_ndx = AtomKey.fields.altloc\n        for dk in chkLst:\n            if tuple(dk) in ric.dihedra:\n                pass\n            elif sH in dk:\n                pass\n            elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n                if defaults:\n                    if len(dk) != 3:\n                        default_dihedron(dk, ric)\n                    else:\n                        default_hedron(dk, ric)\n                elif verbose:\n                    print(f'{ric}-{rn} missing {dk}')\n            else:\n                pass\n\n    def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Allocate edron key AtomKeys to current residue as appropriate.\n\n        A hedron or dihedron may span a backbone amide bond, this routine\n        allocates atoms in the (h/di)edron to the ric residue or saves them\n        for a residue yet to be processed.\n\n        :param set ek: AtomKeys in edron\n        :param IC_Residue ric: current residue to assign AtomKeys to\n        \"\"\"\n        res = ric.residue\n        reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n        for ak in ek:\n            if ak.ric is None:\n                sbcic.akset.add(ak)\n                if ak.akl[0:3] == reskl:\n                    ak.ric = ric\n                    ric.ak_set.add(ak)\n                else:\n                    orphan_aks.add(ak)\n\n    def finish_chain() -> None:\n        \"\"\"Do last rnext, rprev links and process chain edra data.\"\"\"\n        link_residues(pr, tr)\n        if not quick:\n            for r in pr:\n                dihedra_check(r.internal_coord)\n            for r in tr:\n                dihedra_check(r.internal_coord)\n        if ha != {}:\n            sha = {k: ha[k] for k in sorted(ha)}\n            shl12 = {k: hl12[k] for k in sorted(hl12)}\n            shl23 = {k: hl23[k] for k in sorted(hl23)}\n            sda = {k: da[k] for k in sorted(da)}\n            sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)\n    with as_handle(file, mode='r') as handle:\n        for line in handle.readlines():\n            if line.startswith('#'):\n                pass\n            elif line.startswith('HEADER '):\n                m = pdb_hdr_re.match(line)\n                if m:\n                    header_dict['head'] = m.group('cf')\n                    header_dict['idcode'] = m.group('id')\n                    header_dict['deposition_date'] = m.group('dd')\n                elif verbose:\n                    print('Reading pic file', file, 'HEADER parse fail: ', line)\n            elif line.startswith('TITLE '):\n                m = pdb_ttl_re.match(line)\n                if m:\n                    header_dict['name'] = m.group('ttl').strip()\n                elif verbose:\n                    print('Reading pic file', file, 'TITLE parse fail:, ', line)\n            elif line.startswith('('):\n                m = biop_id_re.match(line)\n                if m:\n                    segid = m.group(9)\n                    if segid is None:\n                        segid = '    '\n                    this_SMCS = [m.group(1), int(m.group(2)), m.group(3), segid]\n                    if curr_SMCS != this_SMCS:\n                        if curr_SMCS[:3] != this_SMCS[:3] and ha != {}:\n                            finish_chain()\n                            akc = {}\n                            hl12 = {}\n                            ha = {}\n                            hl23 = {}\n                            da = {}\n                            bfacs = {}\n                        for i in range(4):\n                            if curr_SMCS[i] != this_SMCS[i]:\n                                SMCS_init[i](this_SMCS[i])\n                                curr_SMCS[i] = this_SMCS[i]\n                                if i == 0:\n                                    struct_builder.set_header(header_dict)\n                                elif i == 1:\n                                    curr_SMCS[2] = curr_SMCS[3] = None\n                                elif i == 2:\n                                    sb_chain = struct_builder.chain\n                                    sbcic = sb_chain.internal_coord = IC_Chain(sb_chain)\n                    struct_builder.init_residue(m.group('res'), m.group('het'), int(m.group('pos')), m.group('icode'))\n                    sb_res = struct_builder.residue\n                    if sb_res.id[0] != ' ':\n                        continue\n                    if 2 == sb_res.is_disordered():\n                        for r in sb_res.child_dict.values():\n                            if not r.internal_coord:\n                                sb_res = r\n                                break\n                        tr.append(sb_res)\n                    else:\n                        link_residues(pr, tr)\n                        if not quick:\n                            for r in pr:\n                                dihedra_check(r.internal_coord)\n                        pr = tr\n                        tr = [sb_res]\n                    sbric = sb_res.internal_coord = IC_Residue(sb_res)\n                    sbric.cic = sbcic\n                    rkl = (str(sb_res.id[1]), None if sb_res.id[2] == ' ' else sb_res.id[2], sbric.lc)\n                    sbcic.ordered_aa_ic_list.append(sbric)\n                    for ak in orphan_aks:\n                        if ak.akl[0:3] == rkl:\n                            ak.ric = sbric\n                            sbric.ak_set.add(ak)\n                    orphan_aks = set(filter(lambda ak: ak.ric is None, orphan_aks))\n                else:\n                    if verbose:\n                        print('Reading pic file', file, 'residue ID parse fail: ', line)\n                    return None\n            elif line.startswith('ATOM '):\n                m = pdb_atm_re.match(line)\n                if not m:\n                    m = pdbx_atm_re.match(line)\n                if m:\n                    if sb_res is None:\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM without residue configured:, ', line)\n                        return None\n                    if sb_res.resname != m.group('res') or sb_res.id[1] != int(m.group('pos')):\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM not in configured residue (', sb_res.resname, str(sb_res.id), '):', line)\n                        return None\n                    coord = np.array((float(m.group('x')), float(m.group('y')), float(m.group('z'))), 'f')\n                    struct_builder.init_atom(m.group('atm').strip(), coord, float(m.group('tfac')), float(m.group('occ')), m.group('alc'), m.group('atm'), int(m.group('ser')), m.group('elm').strip())\n                    pr = []\n            elif line.startswith('BFAC: '):\n                m = bfac_re.match(line)\n                if m:\n                    for bfac_pair in m.groups():\n                        if bfac_pair is not None:\n                            m2 = bfac2_re.match(bfac_pair)\n                            bfacs[m2.group(1)] = float(m2.group(2))\n            else:\n                m = Edron.edron_re.match(line)\n                if m and sb_res is not None:\n                    if m['a4'] is None:\n                        process_hedron(m['a1'], m['a2'], m['a3'], m['len12'], m['angle'], m['len23'], sb_res.internal_coord)\n                    else:\n                        process_dihedron(m['a1'], m['a2'], m['a3'], m['a4'], m['dihedral'], sb_res.internal_coord)\n                elif m:\n                    print('PIC file: ', file, ' error: no residue info before reading (di/h)edron: ', line)\n                    return None\n                elif line.strip():\n                    if verbose:\n                        print('Reading PIC file', file, 'parse fail on: .', line, '.')\n                    return None\n    finish_chain()\n    return struct_builder.get_structure()",
            "def read_PIC(file: TextIO, verbose: bool=False, quick: bool=False, defaults: bool=False) -> Structure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Load Protein Internal Coordinate (.pic) data from file.\\n\\n    PIC file format:\\n        - comment lines start with #\\n        - (optional) PDB HEADER record\\n           - idcode and deposition date recommended but optional\\n           - deposition date in PDB format or as changed by Biopython\\n        - (optional) PDB TITLE record\\n        - repeat:\\n           - Biopython Residue Full ID - sets residue IDs of returned structure\\n           - (optional) PDB N, CA, C ATOM records for chain start\\n           - (optional) PIC Hedra records for residue\\n           - (optional) PIC Dihedra records for residue\\n           - (optional) BFAC records listing AtomKeys and b-factors\\n\\n    An improvement would define relative positions for HOH (water) entries.\\n\\n    Defaults will be supplied for any value if defaults=True.  Default values\\n    are supplied in ic_data.py, but structures degrade quickly with any\\n    deviation from true coordinates.  Experiment with\\n    :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags` options to\\n    :func:`write_PIC` to verify this.\\n\\n    N.B. dihedron (i-1)C-N-CA-CB is ignored in assembly if O exists.\\n\\n    C-beta is by default placed using O-C-CA-CB, but O is missing\\n    in some PDB file residues, which means the sidechain cannot be\\n    placed.  The alternate CB path (i-1)C-N-CA-CB is provided to\\n    circumvent this, but if this is needed then it must be adjusted in\\n    conjunction with PHI ((i-1)C-N-CA-C) as they overlap (see :meth:`.bond_set`\\n    and :meth:`.bond_rotate` to handle this automatically).\\n\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param bool verbose: complain when lines not as expected\\n    :param bool quick: don't check residues for all dihedra (no default values)\\n    :param bool defaults: create di/hedra as needed from reference database.\\n        Amide proton created if 'H' is in IC_Residue.accept_atoms\\n    :returns: Biopython Structure object, Residues with .internal_coord\\n        attributes but no coordinates except for chain start N, CA, C atoms if\\n        supplied, **OR** None on parse fail (silent unless verbose=True)\\n\\n    \"\n    proton = 'H' in IC_Residue.accept_atoms\n    pdb_hdr_re = re.compile('^HEADER\\\\s{4}(?P<cf>.{1,40})(?:\\\\s+(?P<dd>\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d|\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d))?(?:\\\\s+(?P<id>[0-9A-Z]{4}))?\\\\s*$')\n    pdb_ttl_re = re.compile('^TITLE\\\\s{5}(?P<ttl>.+)\\\\s*$')\n    biop_id_re = re.compile(\"^\\\\('(?P<pid>[^\\\\s]*)',\\\\s(?P<mdl>\\\\d+),\\\\s'(?P<chn>\\\\s|\\\\w)',\\\\s\\\\('(?P<het>\\\\s|[\\\\w\\\\s-]+)',\\\\s(?P<pos>-?\\\\d+),\\\\s'(?P<icode>\\\\s|\\\\w)'\\\\)\\\\)\\\\s+(?P<res>[\\\\w]{1,3})(\\\\s\\\\[(?P<segid>[a-zA-z\\\\s]+)\\\\])?\\\\s*$\")\n    pdb_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<occ>[\\\\s\\\\d\\\\.]{6})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    pdbx_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<occ>[\\\\s\\\\d\\\\.]{7})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    bfac_re = re.compile('^BFAC:\\\\s([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?')\n    bfac2_re = re.compile('([^\\\\s]+)\\\\s+([\\\\-\\\\d\\\\.]+)')\n    struct_builder = StructureBuilder()\n    header_dict = _parse_pdb_header_list([])\n    curr_SMCS = [None, None, None, None]\n    SMCS_init = [struct_builder.init_structure, struct_builder.init_model, struct_builder.init_chain, struct_builder.init_seg]\n    sb_res = None\n    rkl = None\n    sb_chain = None\n    sbcic = None\n    sbric = None\n    akc = {}\n    hl12 = {}\n    ha = {}\n    hl23 = {}\n    da = {}\n    bfacs = {}\n    orphan_aks = set()\n    tr = []\n    pr = []\n\n    def akcache(akstr: str) -> AtomKey:\n        \"\"\"Maintain dictionary of AtomKeys seen while reading this PIC file.\"\"\"\n        try:\n            return akc[akstr]\n        except KeyError:\n            ak = akc[akstr] = AtomKey(akstr)\n            return ak\n\n    def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n        \"\"\"Set next and prev links between i-1 and i-2 residues.\"\"\"\n        for p_r in pr:\n            pric = p_r.internal_coord\n            for p_p_r in ppr:\n                ppric = p_p_r.internal_coord\n                if p_r.id[0] == ' ':\n                    if pric not in ppric.rnext:\n                        ppric.rnext.append(pric)\n                if p_p_r.id[0] == ' ':\n                    if ppric not in pric.rprev:\n                        pric.rprev.append(ppric)\n\n    def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n        \"\"\"Create Hedron on current (sbcic) Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n            return\n        hl12[ek] = float(l12)\n        ha[ek] = float(ang)\n        hl23[ek] = float(l23)\n        sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n        h.cic = sbcic\n        ak_add(ek, ric)\n        return ek\n\n    def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Create Hedron based on same re_class hedra in ref database.\n\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atomkeys = []\n        hkey = None\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        atomkeys = [ek[i].akl for i in range(3)]\n        atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n        res = atomkeys[0][resNdx]\n        if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n            hkey = ek\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n            try:\n                dflts = hedra_defaults[''.join(rhcl)][0]\n            except KeyError:\n                if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                    rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n                else:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                    rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n                dflts = hedra_defaults[rhc][0]\n        else:\n            hkey = ek[::-1]\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n        if verbose:\n            print(f' default for {ek}')\n\n    def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Confirm both hedra present for dihedron key, use default if set.\"\"\"\n        if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[0:3], ric)\n            else:\n                print(f'{dk} missing h1')\n        if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[1:4], ric)\n            else:\n                print(f'{dk} missing h2')\n\n    def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n        \"\"\"Create Dihedron on current Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n            return\n        dangle = float(dangle)\n        dangle = dangle if dangle <= 180.0 else dangle - 360.0\n        dangle = dangle if dangle >= -180.0 else dangle + 360.0\n        da[ek] = float(dangle)\n        sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n        d.cic = sbcic\n        if not quick:\n            hedra_check(ek, ric)\n        ak_add(ek, ric)\n        return ek\n\n    def default_dihedron(ek: List, ric: IC_Residue) -> None:\n        \"\"\"Create Dihedron based on same residue class dihedra in ref database.\n\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        rdclass = ''\n        dclass = ''\n        for ak in ek:\n            dclass += ak.akl[atmNdx]\n            rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n        if dclass == 'NCACN':\n            rdclass = rdclass[0:7] + 'XN'\n        elif dclass == 'CACNCA':\n            rdclass = 'XCAXC' + rdclass[5:]\n        elif dclass == 'CNCAC':\n            rdclass = 'XC' + rdclass[2:]\n        if rdclass in dihedra_primary_defaults:\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n            if verbose:\n                print(f' default for {ek}')\n        elif rdclass in dihedra_secondary_defaults:\n            (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n            rname = ek[2].akl[resNdx]\n            rnum = int(ek[2].akl[resPos])\n            paKey = None\n            if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n                paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n                rnext = ek[0].ric.rnext\n                paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n                paKey = tuple(paKey)\n            elif primAngle == ('CA', 'C', 'N', 'CA'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n                paKey = tuple(paKey)\n            else:\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' secondary default for {ek}')\n            elif rdclass in dihedra_secondary_xoxt_defaults:\n                if primAngle == ('C', 'N', 'CA', 'C'):\n                    prname = pr.akl[0][resNdx]\n                    prnum = pr.akl[0][resPos]\n                    paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                    paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                    paKey = tuple(paKey)\n                else:\n                    (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                    rname = ek[2].akl[resNdx]\n                    rnum = int(ek[2].akl[resPos])\n                    paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n                if paKey in da:\n                    angl = da[paKey] + offset\n                    process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                    if verbose:\n                        print(f' oxt default for {ek}')\n                else:\n                    print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n        else:\n            print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')\n\n    def dihedra_check(ric: IC_Residue) -> None:\n        \"\"\"Look for required dihedra in residue, generate defaults if set.\"\"\"\n\n        def ake_recurse(akList: List) -> List:\n            \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n            car = akList[0]\n            if len(akList) > 1:\n                retList = []\n                for ak in car:\n                    cdr = akList[1:]\n                    rslt = ake_recurse(cdr)\n                    for r in rslt:\n                        r.insert(0, ak)\n                        retList.append(r)\n                return retList\n            elif len(car) == 1:\n                return [list(car)]\n            else:\n                retList = [[ak] for ak in car]\n                return retList\n\n        def ak_expand(eLst: List) -> List:\n            \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n            retList = []\n            for edron in eLst:\n                newList = []\n                for ak in edron:\n                    rslt = ak.ric.split_akl([ak])\n                    rlst = [r[0] for r in rslt]\n                    if rlst != []:\n                        newList.append(rlst)\n                    else:\n                        newList.append([ak])\n                rslt = ake_recurse(newList)\n                for r in rslt:\n                    retList.append(r)\n            return retList\n        chkLst = []\n        (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n        (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n        if ric.rnext != []:\n            for rn in ric.rnext:\n                (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n                chkLst.append((sN, sCA, sC, nN))\n                chkLst.append((sCA, sC, nN, nCA))\n                chkLst.append((sC, nN, nCA, nC))\n        else:\n            chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n            rn = '(no rnext)'\n        chkLst.append((sN, sCA, sC, sO))\n        if ric.lc != 'G':\n            chkLst.append((sO, sC, sCA, sCB))\n            if ric.lc == 'A':\n                chkLst.append((sN, sCA, sCB))\n        if ric.rprev != [] and ric.lc != 'P' and proton:\n            chkLst.append((sC, sCA, sN, sH))\n        try:\n            for edron in ic_data_sidechains[ric.lc]:\n                if len(edron) > 3:\n                    if all((atm[0] != 'H' for atm in edron)):\n                        akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                        chkLst.append(akl)\n        except KeyError:\n            pass\n        chkLst = ak_expand(chkLst)\n        altloc_ndx = AtomKey.fields.altloc\n        for dk in chkLst:\n            if tuple(dk) in ric.dihedra:\n                pass\n            elif sH in dk:\n                pass\n            elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n                if defaults:\n                    if len(dk) != 3:\n                        default_dihedron(dk, ric)\n                    else:\n                        default_hedron(dk, ric)\n                elif verbose:\n                    print(f'{ric}-{rn} missing {dk}')\n            else:\n                pass\n\n    def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Allocate edron key AtomKeys to current residue as appropriate.\n\n        A hedron or dihedron may span a backbone amide bond, this routine\n        allocates atoms in the (h/di)edron to the ric residue or saves them\n        for a residue yet to be processed.\n\n        :param set ek: AtomKeys in edron\n        :param IC_Residue ric: current residue to assign AtomKeys to\n        \"\"\"\n        res = ric.residue\n        reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n        for ak in ek:\n            if ak.ric is None:\n                sbcic.akset.add(ak)\n                if ak.akl[0:3] == reskl:\n                    ak.ric = ric\n                    ric.ak_set.add(ak)\n                else:\n                    orphan_aks.add(ak)\n\n    def finish_chain() -> None:\n        \"\"\"Do last rnext, rprev links and process chain edra data.\"\"\"\n        link_residues(pr, tr)\n        if not quick:\n            for r in pr:\n                dihedra_check(r.internal_coord)\n            for r in tr:\n                dihedra_check(r.internal_coord)\n        if ha != {}:\n            sha = {k: ha[k] for k in sorted(ha)}\n            shl12 = {k: hl12[k] for k in sorted(hl12)}\n            shl23 = {k: hl23[k] for k in sorted(hl23)}\n            sda = {k: da[k] for k in sorted(da)}\n            sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)\n    with as_handle(file, mode='r') as handle:\n        for line in handle.readlines():\n            if line.startswith('#'):\n                pass\n            elif line.startswith('HEADER '):\n                m = pdb_hdr_re.match(line)\n                if m:\n                    header_dict['head'] = m.group('cf')\n                    header_dict['idcode'] = m.group('id')\n                    header_dict['deposition_date'] = m.group('dd')\n                elif verbose:\n                    print('Reading pic file', file, 'HEADER parse fail: ', line)\n            elif line.startswith('TITLE '):\n                m = pdb_ttl_re.match(line)\n                if m:\n                    header_dict['name'] = m.group('ttl').strip()\n                elif verbose:\n                    print('Reading pic file', file, 'TITLE parse fail:, ', line)\n            elif line.startswith('('):\n                m = biop_id_re.match(line)\n                if m:\n                    segid = m.group(9)\n                    if segid is None:\n                        segid = '    '\n                    this_SMCS = [m.group(1), int(m.group(2)), m.group(3), segid]\n                    if curr_SMCS != this_SMCS:\n                        if curr_SMCS[:3] != this_SMCS[:3] and ha != {}:\n                            finish_chain()\n                            akc = {}\n                            hl12 = {}\n                            ha = {}\n                            hl23 = {}\n                            da = {}\n                            bfacs = {}\n                        for i in range(4):\n                            if curr_SMCS[i] != this_SMCS[i]:\n                                SMCS_init[i](this_SMCS[i])\n                                curr_SMCS[i] = this_SMCS[i]\n                                if i == 0:\n                                    struct_builder.set_header(header_dict)\n                                elif i == 1:\n                                    curr_SMCS[2] = curr_SMCS[3] = None\n                                elif i == 2:\n                                    sb_chain = struct_builder.chain\n                                    sbcic = sb_chain.internal_coord = IC_Chain(sb_chain)\n                    struct_builder.init_residue(m.group('res'), m.group('het'), int(m.group('pos')), m.group('icode'))\n                    sb_res = struct_builder.residue\n                    if sb_res.id[0] != ' ':\n                        continue\n                    if 2 == sb_res.is_disordered():\n                        for r in sb_res.child_dict.values():\n                            if not r.internal_coord:\n                                sb_res = r\n                                break\n                        tr.append(sb_res)\n                    else:\n                        link_residues(pr, tr)\n                        if not quick:\n                            for r in pr:\n                                dihedra_check(r.internal_coord)\n                        pr = tr\n                        tr = [sb_res]\n                    sbric = sb_res.internal_coord = IC_Residue(sb_res)\n                    sbric.cic = sbcic\n                    rkl = (str(sb_res.id[1]), None if sb_res.id[2] == ' ' else sb_res.id[2], sbric.lc)\n                    sbcic.ordered_aa_ic_list.append(sbric)\n                    for ak in orphan_aks:\n                        if ak.akl[0:3] == rkl:\n                            ak.ric = sbric\n                            sbric.ak_set.add(ak)\n                    orphan_aks = set(filter(lambda ak: ak.ric is None, orphan_aks))\n                else:\n                    if verbose:\n                        print('Reading pic file', file, 'residue ID parse fail: ', line)\n                    return None\n            elif line.startswith('ATOM '):\n                m = pdb_atm_re.match(line)\n                if not m:\n                    m = pdbx_atm_re.match(line)\n                if m:\n                    if sb_res is None:\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM without residue configured:, ', line)\n                        return None\n                    if sb_res.resname != m.group('res') or sb_res.id[1] != int(m.group('pos')):\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM not in configured residue (', sb_res.resname, str(sb_res.id), '):', line)\n                        return None\n                    coord = np.array((float(m.group('x')), float(m.group('y')), float(m.group('z'))), 'f')\n                    struct_builder.init_atom(m.group('atm').strip(), coord, float(m.group('tfac')), float(m.group('occ')), m.group('alc'), m.group('atm'), int(m.group('ser')), m.group('elm').strip())\n                    pr = []\n            elif line.startswith('BFAC: '):\n                m = bfac_re.match(line)\n                if m:\n                    for bfac_pair in m.groups():\n                        if bfac_pair is not None:\n                            m2 = bfac2_re.match(bfac_pair)\n                            bfacs[m2.group(1)] = float(m2.group(2))\n            else:\n                m = Edron.edron_re.match(line)\n                if m and sb_res is not None:\n                    if m['a4'] is None:\n                        process_hedron(m['a1'], m['a2'], m['a3'], m['len12'], m['angle'], m['len23'], sb_res.internal_coord)\n                    else:\n                        process_dihedron(m['a1'], m['a2'], m['a3'], m['a4'], m['dihedral'], sb_res.internal_coord)\n                elif m:\n                    print('PIC file: ', file, ' error: no residue info before reading (di/h)edron: ', line)\n                    return None\n                elif line.strip():\n                    if verbose:\n                        print('Reading PIC file', file, 'parse fail on: .', line, '.')\n                    return None\n    finish_chain()\n    return struct_builder.get_structure()",
            "def read_PIC(file: TextIO, verbose: bool=False, quick: bool=False, defaults: bool=False) -> Structure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Load Protein Internal Coordinate (.pic) data from file.\\n\\n    PIC file format:\\n        - comment lines start with #\\n        - (optional) PDB HEADER record\\n           - idcode and deposition date recommended but optional\\n           - deposition date in PDB format or as changed by Biopython\\n        - (optional) PDB TITLE record\\n        - repeat:\\n           - Biopython Residue Full ID - sets residue IDs of returned structure\\n           - (optional) PDB N, CA, C ATOM records for chain start\\n           - (optional) PIC Hedra records for residue\\n           - (optional) PIC Dihedra records for residue\\n           - (optional) BFAC records listing AtomKeys and b-factors\\n\\n    An improvement would define relative positions for HOH (water) entries.\\n\\n    Defaults will be supplied for any value if defaults=True.  Default values\\n    are supplied in ic_data.py, but structures degrade quickly with any\\n    deviation from true coordinates.  Experiment with\\n    :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags` options to\\n    :func:`write_PIC` to verify this.\\n\\n    N.B. dihedron (i-1)C-N-CA-CB is ignored in assembly if O exists.\\n\\n    C-beta is by default placed using O-C-CA-CB, but O is missing\\n    in some PDB file residues, which means the sidechain cannot be\\n    placed.  The alternate CB path (i-1)C-N-CA-CB is provided to\\n    circumvent this, but if this is needed then it must be adjusted in\\n    conjunction with PHI ((i-1)C-N-CA-C) as they overlap (see :meth:`.bond_set`\\n    and :meth:`.bond_rotate` to handle this automatically).\\n\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param bool verbose: complain when lines not as expected\\n    :param bool quick: don't check residues for all dihedra (no default values)\\n    :param bool defaults: create di/hedra as needed from reference database.\\n        Amide proton created if 'H' is in IC_Residue.accept_atoms\\n    :returns: Biopython Structure object, Residues with .internal_coord\\n        attributes but no coordinates except for chain start N, CA, C atoms if\\n        supplied, **OR** None on parse fail (silent unless verbose=True)\\n\\n    \"\n    proton = 'H' in IC_Residue.accept_atoms\n    pdb_hdr_re = re.compile('^HEADER\\\\s{4}(?P<cf>.{1,40})(?:\\\\s+(?P<dd>\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d|\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d))?(?:\\\\s+(?P<id>[0-9A-Z]{4}))?\\\\s*$')\n    pdb_ttl_re = re.compile('^TITLE\\\\s{5}(?P<ttl>.+)\\\\s*$')\n    biop_id_re = re.compile(\"^\\\\('(?P<pid>[^\\\\s]*)',\\\\s(?P<mdl>\\\\d+),\\\\s'(?P<chn>\\\\s|\\\\w)',\\\\s\\\\('(?P<het>\\\\s|[\\\\w\\\\s-]+)',\\\\s(?P<pos>-?\\\\d+),\\\\s'(?P<icode>\\\\s|\\\\w)'\\\\)\\\\)\\\\s+(?P<res>[\\\\w]{1,3})(\\\\s\\\\[(?P<segid>[a-zA-z\\\\s]+)\\\\])?\\\\s*$\")\n    pdb_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<occ>[\\\\s\\\\d\\\\.]{6})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    pdbx_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<occ>[\\\\s\\\\d\\\\.]{7})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    bfac_re = re.compile('^BFAC:\\\\s([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?')\n    bfac2_re = re.compile('([^\\\\s]+)\\\\s+([\\\\-\\\\d\\\\.]+)')\n    struct_builder = StructureBuilder()\n    header_dict = _parse_pdb_header_list([])\n    curr_SMCS = [None, None, None, None]\n    SMCS_init = [struct_builder.init_structure, struct_builder.init_model, struct_builder.init_chain, struct_builder.init_seg]\n    sb_res = None\n    rkl = None\n    sb_chain = None\n    sbcic = None\n    sbric = None\n    akc = {}\n    hl12 = {}\n    ha = {}\n    hl23 = {}\n    da = {}\n    bfacs = {}\n    orphan_aks = set()\n    tr = []\n    pr = []\n\n    def akcache(akstr: str) -> AtomKey:\n        \"\"\"Maintain dictionary of AtomKeys seen while reading this PIC file.\"\"\"\n        try:\n            return akc[akstr]\n        except KeyError:\n            ak = akc[akstr] = AtomKey(akstr)\n            return ak\n\n    def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n        \"\"\"Set next and prev links between i-1 and i-2 residues.\"\"\"\n        for p_r in pr:\n            pric = p_r.internal_coord\n            for p_p_r in ppr:\n                ppric = p_p_r.internal_coord\n                if p_r.id[0] == ' ':\n                    if pric not in ppric.rnext:\n                        ppric.rnext.append(pric)\n                if p_p_r.id[0] == ' ':\n                    if ppric not in pric.rprev:\n                        pric.rprev.append(ppric)\n\n    def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n        \"\"\"Create Hedron on current (sbcic) Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n            return\n        hl12[ek] = float(l12)\n        ha[ek] = float(ang)\n        hl23[ek] = float(l23)\n        sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n        h.cic = sbcic\n        ak_add(ek, ric)\n        return ek\n\n    def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Create Hedron based on same re_class hedra in ref database.\n\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atomkeys = []\n        hkey = None\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        atomkeys = [ek[i].akl for i in range(3)]\n        atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n        res = atomkeys[0][resNdx]\n        if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n            hkey = ek\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n            try:\n                dflts = hedra_defaults[''.join(rhcl)][0]\n            except KeyError:\n                if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                    rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n                else:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                    rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n                dflts = hedra_defaults[rhc][0]\n        else:\n            hkey = ek[::-1]\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n        if verbose:\n            print(f' default for {ek}')\n\n    def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Confirm both hedra present for dihedron key, use default if set.\"\"\"\n        if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[0:3], ric)\n            else:\n                print(f'{dk} missing h1')\n        if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[1:4], ric)\n            else:\n                print(f'{dk} missing h2')\n\n    def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n        \"\"\"Create Dihedron on current Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n            return\n        dangle = float(dangle)\n        dangle = dangle if dangle <= 180.0 else dangle - 360.0\n        dangle = dangle if dangle >= -180.0 else dangle + 360.0\n        da[ek] = float(dangle)\n        sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n        d.cic = sbcic\n        if not quick:\n            hedra_check(ek, ric)\n        ak_add(ek, ric)\n        return ek\n\n    def default_dihedron(ek: List, ric: IC_Residue) -> None:\n        \"\"\"Create Dihedron based on same residue class dihedra in ref database.\n\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        rdclass = ''\n        dclass = ''\n        for ak in ek:\n            dclass += ak.akl[atmNdx]\n            rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n        if dclass == 'NCACN':\n            rdclass = rdclass[0:7] + 'XN'\n        elif dclass == 'CACNCA':\n            rdclass = 'XCAXC' + rdclass[5:]\n        elif dclass == 'CNCAC':\n            rdclass = 'XC' + rdclass[2:]\n        if rdclass in dihedra_primary_defaults:\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n            if verbose:\n                print(f' default for {ek}')\n        elif rdclass in dihedra_secondary_defaults:\n            (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n            rname = ek[2].akl[resNdx]\n            rnum = int(ek[2].akl[resPos])\n            paKey = None\n            if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n                paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n                rnext = ek[0].ric.rnext\n                paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n                paKey = tuple(paKey)\n            elif primAngle == ('CA', 'C', 'N', 'CA'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n                paKey = tuple(paKey)\n            else:\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' secondary default for {ek}')\n            elif rdclass in dihedra_secondary_xoxt_defaults:\n                if primAngle == ('C', 'N', 'CA', 'C'):\n                    prname = pr.akl[0][resNdx]\n                    prnum = pr.akl[0][resPos]\n                    paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                    paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                    paKey = tuple(paKey)\n                else:\n                    (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                    rname = ek[2].akl[resNdx]\n                    rnum = int(ek[2].akl[resPos])\n                    paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n                if paKey in da:\n                    angl = da[paKey] + offset\n                    process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                    if verbose:\n                        print(f' oxt default for {ek}')\n                else:\n                    print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n        else:\n            print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')\n\n    def dihedra_check(ric: IC_Residue) -> None:\n        \"\"\"Look for required dihedra in residue, generate defaults if set.\"\"\"\n\n        def ake_recurse(akList: List) -> List:\n            \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n            car = akList[0]\n            if len(akList) > 1:\n                retList = []\n                for ak in car:\n                    cdr = akList[1:]\n                    rslt = ake_recurse(cdr)\n                    for r in rslt:\n                        r.insert(0, ak)\n                        retList.append(r)\n                return retList\n            elif len(car) == 1:\n                return [list(car)]\n            else:\n                retList = [[ak] for ak in car]\n                return retList\n\n        def ak_expand(eLst: List) -> List:\n            \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n            retList = []\n            for edron in eLst:\n                newList = []\n                for ak in edron:\n                    rslt = ak.ric.split_akl([ak])\n                    rlst = [r[0] for r in rslt]\n                    if rlst != []:\n                        newList.append(rlst)\n                    else:\n                        newList.append([ak])\n                rslt = ake_recurse(newList)\n                for r in rslt:\n                    retList.append(r)\n            return retList\n        chkLst = []\n        (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n        (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n        if ric.rnext != []:\n            for rn in ric.rnext:\n                (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n                chkLst.append((sN, sCA, sC, nN))\n                chkLst.append((sCA, sC, nN, nCA))\n                chkLst.append((sC, nN, nCA, nC))\n        else:\n            chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n            rn = '(no rnext)'\n        chkLst.append((sN, sCA, sC, sO))\n        if ric.lc != 'G':\n            chkLst.append((sO, sC, sCA, sCB))\n            if ric.lc == 'A':\n                chkLst.append((sN, sCA, sCB))\n        if ric.rprev != [] and ric.lc != 'P' and proton:\n            chkLst.append((sC, sCA, sN, sH))\n        try:\n            for edron in ic_data_sidechains[ric.lc]:\n                if len(edron) > 3:\n                    if all((atm[0] != 'H' for atm in edron)):\n                        akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                        chkLst.append(akl)\n        except KeyError:\n            pass\n        chkLst = ak_expand(chkLst)\n        altloc_ndx = AtomKey.fields.altloc\n        for dk in chkLst:\n            if tuple(dk) in ric.dihedra:\n                pass\n            elif sH in dk:\n                pass\n            elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n                if defaults:\n                    if len(dk) != 3:\n                        default_dihedron(dk, ric)\n                    else:\n                        default_hedron(dk, ric)\n                elif verbose:\n                    print(f'{ric}-{rn} missing {dk}')\n            else:\n                pass\n\n    def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Allocate edron key AtomKeys to current residue as appropriate.\n\n        A hedron or dihedron may span a backbone amide bond, this routine\n        allocates atoms in the (h/di)edron to the ric residue or saves them\n        for a residue yet to be processed.\n\n        :param set ek: AtomKeys in edron\n        :param IC_Residue ric: current residue to assign AtomKeys to\n        \"\"\"\n        res = ric.residue\n        reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n        for ak in ek:\n            if ak.ric is None:\n                sbcic.akset.add(ak)\n                if ak.akl[0:3] == reskl:\n                    ak.ric = ric\n                    ric.ak_set.add(ak)\n                else:\n                    orphan_aks.add(ak)\n\n    def finish_chain() -> None:\n        \"\"\"Do last rnext, rprev links and process chain edra data.\"\"\"\n        link_residues(pr, tr)\n        if not quick:\n            for r in pr:\n                dihedra_check(r.internal_coord)\n            for r in tr:\n                dihedra_check(r.internal_coord)\n        if ha != {}:\n            sha = {k: ha[k] for k in sorted(ha)}\n            shl12 = {k: hl12[k] for k in sorted(hl12)}\n            shl23 = {k: hl23[k] for k in sorted(hl23)}\n            sda = {k: da[k] for k in sorted(da)}\n            sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)\n    with as_handle(file, mode='r') as handle:\n        for line in handle.readlines():\n            if line.startswith('#'):\n                pass\n            elif line.startswith('HEADER '):\n                m = pdb_hdr_re.match(line)\n                if m:\n                    header_dict['head'] = m.group('cf')\n                    header_dict['idcode'] = m.group('id')\n                    header_dict['deposition_date'] = m.group('dd')\n                elif verbose:\n                    print('Reading pic file', file, 'HEADER parse fail: ', line)\n            elif line.startswith('TITLE '):\n                m = pdb_ttl_re.match(line)\n                if m:\n                    header_dict['name'] = m.group('ttl').strip()\n                elif verbose:\n                    print('Reading pic file', file, 'TITLE parse fail:, ', line)\n            elif line.startswith('('):\n                m = biop_id_re.match(line)\n                if m:\n                    segid = m.group(9)\n                    if segid is None:\n                        segid = '    '\n                    this_SMCS = [m.group(1), int(m.group(2)), m.group(3), segid]\n                    if curr_SMCS != this_SMCS:\n                        if curr_SMCS[:3] != this_SMCS[:3] and ha != {}:\n                            finish_chain()\n                            akc = {}\n                            hl12 = {}\n                            ha = {}\n                            hl23 = {}\n                            da = {}\n                            bfacs = {}\n                        for i in range(4):\n                            if curr_SMCS[i] != this_SMCS[i]:\n                                SMCS_init[i](this_SMCS[i])\n                                curr_SMCS[i] = this_SMCS[i]\n                                if i == 0:\n                                    struct_builder.set_header(header_dict)\n                                elif i == 1:\n                                    curr_SMCS[2] = curr_SMCS[3] = None\n                                elif i == 2:\n                                    sb_chain = struct_builder.chain\n                                    sbcic = sb_chain.internal_coord = IC_Chain(sb_chain)\n                    struct_builder.init_residue(m.group('res'), m.group('het'), int(m.group('pos')), m.group('icode'))\n                    sb_res = struct_builder.residue\n                    if sb_res.id[0] != ' ':\n                        continue\n                    if 2 == sb_res.is_disordered():\n                        for r in sb_res.child_dict.values():\n                            if not r.internal_coord:\n                                sb_res = r\n                                break\n                        tr.append(sb_res)\n                    else:\n                        link_residues(pr, tr)\n                        if not quick:\n                            for r in pr:\n                                dihedra_check(r.internal_coord)\n                        pr = tr\n                        tr = [sb_res]\n                    sbric = sb_res.internal_coord = IC_Residue(sb_res)\n                    sbric.cic = sbcic\n                    rkl = (str(sb_res.id[1]), None if sb_res.id[2] == ' ' else sb_res.id[2], sbric.lc)\n                    sbcic.ordered_aa_ic_list.append(sbric)\n                    for ak in orphan_aks:\n                        if ak.akl[0:3] == rkl:\n                            ak.ric = sbric\n                            sbric.ak_set.add(ak)\n                    orphan_aks = set(filter(lambda ak: ak.ric is None, orphan_aks))\n                else:\n                    if verbose:\n                        print('Reading pic file', file, 'residue ID parse fail: ', line)\n                    return None\n            elif line.startswith('ATOM '):\n                m = pdb_atm_re.match(line)\n                if not m:\n                    m = pdbx_atm_re.match(line)\n                if m:\n                    if sb_res is None:\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM without residue configured:, ', line)\n                        return None\n                    if sb_res.resname != m.group('res') or sb_res.id[1] != int(m.group('pos')):\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM not in configured residue (', sb_res.resname, str(sb_res.id), '):', line)\n                        return None\n                    coord = np.array((float(m.group('x')), float(m.group('y')), float(m.group('z'))), 'f')\n                    struct_builder.init_atom(m.group('atm').strip(), coord, float(m.group('tfac')), float(m.group('occ')), m.group('alc'), m.group('atm'), int(m.group('ser')), m.group('elm').strip())\n                    pr = []\n            elif line.startswith('BFAC: '):\n                m = bfac_re.match(line)\n                if m:\n                    for bfac_pair in m.groups():\n                        if bfac_pair is not None:\n                            m2 = bfac2_re.match(bfac_pair)\n                            bfacs[m2.group(1)] = float(m2.group(2))\n            else:\n                m = Edron.edron_re.match(line)\n                if m and sb_res is not None:\n                    if m['a4'] is None:\n                        process_hedron(m['a1'], m['a2'], m['a3'], m['len12'], m['angle'], m['len23'], sb_res.internal_coord)\n                    else:\n                        process_dihedron(m['a1'], m['a2'], m['a3'], m['a4'], m['dihedral'], sb_res.internal_coord)\n                elif m:\n                    print('PIC file: ', file, ' error: no residue info before reading (di/h)edron: ', line)\n                    return None\n                elif line.strip():\n                    if verbose:\n                        print('Reading PIC file', file, 'parse fail on: .', line, '.')\n                    return None\n    finish_chain()\n    return struct_builder.get_structure()",
            "def read_PIC(file: TextIO, verbose: bool=False, quick: bool=False, defaults: bool=False) -> Structure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Load Protein Internal Coordinate (.pic) data from file.\\n\\n    PIC file format:\\n        - comment lines start with #\\n        - (optional) PDB HEADER record\\n           - idcode and deposition date recommended but optional\\n           - deposition date in PDB format or as changed by Biopython\\n        - (optional) PDB TITLE record\\n        - repeat:\\n           - Biopython Residue Full ID - sets residue IDs of returned structure\\n           - (optional) PDB N, CA, C ATOM records for chain start\\n           - (optional) PIC Hedra records for residue\\n           - (optional) PIC Dihedra records for residue\\n           - (optional) BFAC records listing AtomKeys and b-factors\\n\\n    An improvement would define relative positions for HOH (water) entries.\\n\\n    Defaults will be supplied for any value if defaults=True.  Default values\\n    are supplied in ic_data.py, but structures degrade quickly with any\\n    deviation from true coordinates.  Experiment with\\n    :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags` options to\\n    :func:`write_PIC` to verify this.\\n\\n    N.B. dihedron (i-1)C-N-CA-CB is ignored in assembly if O exists.\\n\\n    C-beta is by default placed using O-C-CA-CB, but O is missing\\n    in some PDB file residues, which means the sidechain cannot be\\n    placed.  The alternate CB path (i-1)C-N-CA-CB is provided to\\n    circumvent this, but if this is needed then it must be adjusted in\\n    conjunction with PHI ((i-1)C-N-CA-C) as they overlap (see :meth:`.bond_set`\\n    and :meth:`.bond_rotate` to handle this automatically).\\n\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param bool verbose: complain when lines not as expected\\n    :param bool quick: don't check residues for all dihedra (no default values)\\n    :param bool defaults: create di/hedra as needed from reference database.\\n        Amide proton created if 'H' is in IC_Residue.accept_atoms\\n    :returns: Biopython Structure object, Residues with .internal_coord\\n        attributes but no coordinates except for chain start N, CA, C atoms if\\n        supplied, **OR** None on parse fail (silent unless verbose=True)\\n\\n    \"\n    proton = 'H' in IC_Residue.accept_atoms\n    pdb_hdr_re = re.compile('^HEADER\\\\s{4}(?P<cf>.{1,40})(?:\\\\s+(?P<dd>\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d|\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d))?(?:\\\\s+(?P<id>[0-9A-Z]{4}))?\\\\s*$')\n    pdb_ttl_re = re.compile('^TITLE\\\\s{5}(?P<ttl>.+)\\\\s*$')\n    biop_id_re = re.compile(\"^\\\\('(?P<pid>[^\\\\s]*)',\\\\s(?P<mdl>\\\\d+),\\\\s'(?P<chn>\\\\s|\\\\w)',\\\\s\\\\('(?P<het>\\\\s|[\\\\w\\\\s-]+)',\\\\s(?P<pos>-?\\\\d+),\\\\s'(?P<icode>\\\\s|\\\\w)'\\\\)\\\\)\\\\s+(?P<res>[\\\\w]{1,3})(\\\\s\\\\[(?P<segid>[a-zA-z\\\\s]+)\\\\])?\\\\s*$\")\n    pdb_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{8})(?P<occ>[\\\\s\\\\d\\\\.]{6})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    pdbx_atm_re = re.compile('^ATOM\\\\s\\\\s(?:\\\\s*(?P<ser>\\\\d+))\\\\s(?P<atm>[\\\\w\\\\s]{4})(?P<alc>\\\\w|\\\\s)(?P<res>[\\\\w]{3})\\\\s(?P<chn>.)(?P<pos>[\\\\s\\\\-\\\\d]{4})(?P<icode>[A-Za-z\\\\s])\\\\s\\\\s\\\\s(?P<x>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<y>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<z>[\\\\s\\\\-\\\\d\\\\.]{10})(?P<occ>[\\\\s\\\\d\\\\.]{7})(?P<tfac>[\\\\s\\\\d\\\\.]{6})\\\\s{6}(?P<segid>[a-zA-z\\\\s]{4})(?P<elm>.{2})(?P<chg>.{2})?\\\\s*$')\n    bfac_re = re.compile('^BFAC:\\\\s([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?\\\\s*([^\\\\s]+\\\\s+[\\\\-\\\\d\\\\.]+)?')\n    bfac2_re = re.compile('([^\\\\s]+)\\\\s+([\\\\-\\\\d\\\\.]+)')\n    struct_builder = StructureBuilder()\n    header_dict = _parse_pdb_header_list([])\n    curr_SMCS = [None, None, None, None]\n    SMCS_init = [struct_builder.init_structure, struct_builder.init_model, struct_builder.init_chain, struct_builder.init_seg]\n    sb_res = None\n    rkl = None\n    sb_chain = None\n    sbcic = None\n    sbric = None\n    akc = {}\n    hl12 = {}\n    ha = {}\n    hl23 = {}\n    da = {}\n    bfacs = {}\n    orphan_aks = set()\n    tr = []\n    pr = []\n\n    def akcache(akstr: str) -> AtomKey:\n        \"\"\"Maintain dictionary of AtomKeys seen while reading this PIC file.\"\"\"\n        try:\n            return akc[akstr]\n        except KeyError:\n            ak = akc[akstr] = AtomKey(akstr)\n            return ak\n\n    def link_residues(ppr: List[Residue], pr: List[Residue]) -> None:\n        \"\"\"Set next and prev links between i-1 and i-2 residues.\"\"\"\n        for p_r in pr:\n            pric = p_r.internal_coord\n            for p_p_r in ppr:\n                ppric = p_p_r.internal_coord\n                if p_r.id[0] == ' ':\n                    if pric not in ppric.rnext:\n                        ppric.rnext.append(pric)\n                if p_p_r.id[0] == ' ':\n                    if ppric not in pric.rprev:\n                        pric.rprev.append(ppric)\n\n    def process_hedron(a1: str, a2: str, a3: str, l12: str, ang: str, l23: str, ric: IC_Residue) -> Tuple:\n        \"\"\"Create Hedron on current (sbcic) Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(3))):\n            return\n        hl12[ek] = float(l12)\n        ha[ek] = float(ang)\n        hl23[ek] = float(l23)\n        sbcic.hedra[ek] = ric.hedra[ek] = h = Hedron(ek)\n        h.cic = sbcic\n        ak_add(ek, ric)\n        return ek\n\n    def default_hedron(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Create Hedron based on same re_class hedra in ref database.\n\n        Adds Hedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atomkeys = []\n        hkey = None\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        atomkeys = [ek[i].akl for i in range(3)]\n        atpl = tuple([atomkeys[i][atmNdx] for i in range(3)])\n        res = atomkeys[0][resNdx]\n        if atomkeys[0][resPos] != atomkeys[2][resPos] or atpl == ('N', 'CA', 'C') or atpl in ic_data_backbone or (res not in ['A', 'G'] and atpl in ic_data_sidechains[res]):\n            hkey = ek\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(3)]\n            try:\n                dflts = hedra_defaults[''.join(rhcl)][0]\n            except KeyError:\n                if atomkeys[0][resPos] == atomkeys[1][resPos]:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2)]\n                    rhc = ''.join(rhcl) + 'X' + atomkeys[2][atmNdx]\n                else:\n                    rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(1, 3)]\n                    rhc = 'X' + atomkeys[0][atmNdx] + ''.join(rhcl)\n                dflts = hedra_defaults[rhc][0]\n        else:\n            hkey = ek[::-1]\n            rhcl = [atomkeys[i][resNdx] + atomkeys[i][atmNdx] for i in range(2, -1, -1)]\n            dflts = hedra_defaults[''.join(rhcl)][0]\n        process_hedron(str(hkey[0]), str(hkey[1]), str(hkey[2]), dflts[0], dflts[1], dflts[2], ric)\n        if verbose:\n            print(f' default for {ek}')\n\n    def hedra_check(dk: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Confirm both hedra present for dihedron key, use default if set.\"\"\"\n        if dk[0:3] not in sbcic.hedra and dk[2::-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[0:3], ric)\n            else:\n                print(f'{dk} missing h1')\n        if dk[1:4] not in sbcic.hedra and dk[3:0:-1] not in sbcic.hedra:\n            if defaults:\n                default_hedron(dk[1:4], ric)\n            else:\n                print(f'{dk} missing h2')\n\n    def process_dihedron(a1: str, a2: str, a3: str, a4: str, dangle: str, ric: IC_Residue) -> Set:\n        \"\"\"Create Dihedron on current Chain.internal_coord.\"\"\"\n        ek = (akcache(a1), akcache(a2), akcache(a3), akcache(a4))\n        atmNdx = AtomKey.fields.atm\n        accpt = IC_Residue.accept_atoms\n        if not all((ek[i].akl[atmNdx] in accpt for i in range(4))):\n            return\n        dangle = float(dangle)\n        dangle = dangle if dangle <= 180.0 else dangle - 360.0\n        dangle = dangle if dangle >= -180.0 else dangle + 360.0\n        da[ek] = float(dangle)\n        sbcic.dihedra[ek] = ric.dihedra[ek] = d = Dihedron(ek)\n        d.cic = sbcic\n        if not quick:\n            hedra_check(ek, ric)\n        ak_add(ek, ric)\n        return ek\n\n    def default_dihedron(ek: List, ric: IC_Residue) -> None:\n        \"\"\"Create Dihedron based on same residue class dihedra in ref database.\n\n        Adds Dihedron to current Chain.internal_coord, see ic_data for default\n        values and reference database source.\n        \"\"\"\n        atmNdx = AtomKey.fields.atm\n        resNdx = AtomKey.fields.resname\n        resPos = AtomKey.fields.respos\n        rdclass = ''\n        dclass = ''\n        for ak in ek:\n            dclass += ak.akl[atmNdx]\n            rdclass += ak.akl[resNdx] + ak.akl[atmNdx]\n        if dclass == 'NCACN':\n            rdclass = rdclass[0:7] + 'XN'\n        elif dclass == 'CACNCA':\n            rdclass = 'XCAXC' + rdclass[5:]\n        elif dclass == 'CNCAC':\n            rdclass = 'XC' + rdclass[2:]\n        if rdclass in dihedra_primary_defaults:\n            process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), dihedra_primary_defaults[rdclass][0], ric)\n            if verbose:\n                print(f' default for {ek}')\n        elif rdclass in dihedra_secondary_defaults:\n            (primAngle, offset) = dihedra_secondary_defaults[rdclass]\n            rname = ek[2].akl[resNdx]\n            rnum = int(ek[2].akl[resPos])\n            paKey = None\n            if primAngle == ('N', 'CA', 'C', 'N') and ek[0].ric.rnext != []:\n                paKey = [AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(3)]\n                rnext = ek[0].ric.rnext\n                paKey.append(AtomKey((rnext[0].rbase[0], None, rnext[0].rbase[2], 'N', None, None)))\n                paKey = tuple(paKey)\n            elif primAngle == ('CA', 'C', 'N', 'CA'):\n                prname = pr.akl[0][resNdx]\n                prnum = pr.akl[0][resPos]\n                paKey = [AtomKey(prnum, None, prname, primAngle[x], None, None) for x in range(2)]\n                paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(2, 4)])\n                paKey = tuple(paKey)\n            else:\n                paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n            if paKey in da:\n                angl = da[paKey] + dihedra_secondary_defaults[rdclass][1]\n                process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                if verbose:\n                    print(f' secondary default for {ek}')\n            elif rdclass in dihedra_secondary_xoxt_defaults:\n                if primAngle == ('C', 'N', 'CA', 'C'):\n                    prname = pr.akl[0][resNdx]\n                    prnum = pr.akl[0][resPos]\n                    paKey = [AtomKey(prnum, None, prname, primAngle[0], None, None)]\n                    paKey.add([AtomKey((rnum, None, rname, primAngle[x], None, None)) for x in range(1, 4)])\n                    paKey = tuple(paKey)\n                else:\n                    (primAngle, offset) = dihedra_secondary_xoxt_defaults[rdclass]\n                    rname = ek[2].akl[resNdx]\n                    rnum = int(ek[2].akl[resPos])\n                    paKey = tuple((AtomKey((rnum, None, rname, atm, None, None)) for atm in primAngle))\n                if paKey in da:\n                    angl = da[paKey] + offset\n                    process_dihedron(str(ek[0]), str(ek[1]), str(ek[2]), str(ek[3]), angl, ric)\n                    if verbose:\n                        print(f' oxt default for {ek}')\n                else:\n                    print(f'missing primary angle {paKey} {primAngle} to generate {rnum}{rname} {rdclass}')\n        else:\n            print(f'missing {ek} -> {rdclass} ({dclass}) not found in primary or secondary defaults')\n\n    def dihedra_check(ric: IC_Residue) -> None:\n        \"\"\"Look for required dihedra in residue, generate defaults if set.\"\"\"\n\n        def ake_recurse(akList: List) -> List:\n            \"\"\"Bulid combinatorics of AtomKey lists.\"\"\"\n            car = akList[0]\n            if len(akList) > 1:\n                retList = []\n                for ak in car:\n                    cdr = akList[1:]\n                    rslt = ake_recurse(cdr)\n                    for r in rslt:\n                        r.insert(0, ak)\n                        retList.append(r)\n                return retList\n            elif len(car) == 1:\n                return [list(car)]\n            else:\n                retList = [[ak] for ak in car]\n                return retList\n\n        def ak_expand(eLst: List) -> List:\n            \"\"\"Expand AtomKey list with altlocs, all combinatorics.\"\"\"\n            retList = []\n            for edron in eLst:\n                newList = []\n                for ak in edron:\n                    rslt = ak.ric.split_akl([ak])\n                    rlst = [r[0] for r in rslt]\n                    if rlst != []:\n                        newList.append(rlst)\n                    else:\n                        newList.append([ak])\n                rslt = ake_recurse(newList)\n                for r in rslt:\n                    retList.append(r)\n            return retList\n        chkLst = []\n        (sN, sCA, sC) = (AtomKey(ric, 'N'), AtomKey(ric, 'CA'), AtomKey(ric, 'C'))\n        (sO, sCB, sH) = (AtomKey(ric, 'O'), AtomKey(ric, 'CB'), AtomKey(ric, 'H'))\n        if ric.rnext != []:\n            for rn in ric.rnext:\n                (nN, nCA, nC) = (AtomKey(rn, 'N'), AtomKey(rn, 'CA'), AtomKey(rn, 'C'))\n                chkLst.append((sN, sCA, sC, nN))\n                chkLst.append((sCA, sC, nN, nCA))\n                chkLst.append((sC, nN, nCA, nC))\n        else:\n            chkLst.append((sN, sCA, sC, AtomKey(ric, 'OXT')))\n            rn = '(no rnext)'\n        chkLst.append((sN, sCA, sC, sO))\n        if ric.lc != 'G':\n            chkLst.append((sO, sC, sCA, sCB))\n            if ric.lc == 'A':\n                chkLst.append((sN, sCA, sCB))\n        if ric.rprev != [] and ric.lc != 'P' and proton:\n            chkLst.append((sC, sCA, sN, sH))\n        try:\n            for edron in ic_data_sidechains[ric.lc]:\n                if len(edron) > 3:\n                    if all((atm[0] != 'H' for atm in edron)):\n                        akl = [AtomKey(ric, atm) for atm in edron[0:4]]\n                        chkLst.append(akl)\n        except KeyError:\n            pass\n        chkLst = ak_expand(chkLst)\n        altloc_ndx = AtomKey.fields.altloc\n        for dk in chkLst:\n            if tuple(dk) in ric.dihedra:\n                pass\n            elif sH in dk:\n                pass\n            elif all((atm.akl[altloc_ndx] is None for atm in dk)):\n                if defaults:\n                    if len(dk) != 3:\n                        default_dihedron(dk, ric)\n                    else:\n                        default_hedron(dk, ric)\n                elif verbose:\n                    print(f'{ric}-{rn} missing {dk}')\n            else:\n                pass\n\n    def ak_add(ek: Tuple, ric: IC_Residue) -> None:\n        \"\"\"Allocate edron key AtomKeys to current residue as appropriate.\n\n        A hedron or dihedron may span a backbone amide bond, this routine\n        allocates atoms in the (h/di)edron to the ric residue or saves them\n        for a residue yet to be processed.\n\n        :param set ek: AtomKeys in edron\n        :param IC_Residue ric: current residue to assign AtomKeys to\n        \"\"\"\n        res = ric.residue\n        reskl = (str(res.id[1]), None if res.id[2] == ' ' else res.id[2], ric.lc)\n        for ak in ek:\n            if ak.ric is None:\n                sbcic.akset.add(ak)\n                if ak.akl[0:3] == reskl:\n                    ak.ric = ric\n                    ric.ak_set.add(ak)\n                else:\n                    orphan_aks.add(ak)\n\n    def finish_chain() -> None:\n        \"\"\"Do last rnext, rprev links and process chain edra data.\"\"\"\n        link_residues(pr, tr)\n        if not quick:\n            for r in pr:\n                dihedra_check(r.internal_coord)\n            for r in tr:\n                dihedra_check(r.internal_coord)\n        if ha != {}:\n            sha = {k: ha[k] for k in sorted(ha)}\n            shl12 = {k: hl12[k] for k in sorted(hl12)}\n            shl23 = {k: hl23[k] for k in sorted(hl23)}\n            sda = {k: da[k] for k in sorted(da)}\n            sbcic._hedraDict2chain(shl12, sha, shl23, sda, bfacs)\n    with as_handle(file, mode='r') as handle:\n        for line in handle.readlines():\n            if line.startswith('#'):\n                pass\n            elif line.startswith('HEADER '):\n                m = pdb_hdr_re.match(line)\n                if m:\n                    header_dict['head'] = m.group('cf')\n                    header_dict['idcode'] = m.group('id')\n                    header_dict['deposition_date'] = m.group('dd')\n                elif verbose:\n                    print('Reading pic file', file, 'HEADER parse fail: ', line)\n            elif line.startswith('TITLE '):\n                m = pdb_ttl_re.match(line)\n                if m:\n                    header_dict['name'] = m.group('ttl').strip()\n                elif verbose:\n                    print('Reading pic file', file, 'TITLE parse fail:, ', line)\n            elif line.startswith('('):\n                m = biop_id_re.match(line)\n                if m:\n                    segid = m.group(9)\n                    if segid is None:\n                        segid = '    '\n                    this_SMCS = [m.group(1), int(m.group(2)), m.group(3), segid]\n                    if curr_SMCS != this_SMCS:\n                        if curr_SMCS[:3] != this_SMCS[:3] and ha != {}:\n                            finish_chain()\n                            akc = {}\n                            hl12 = {}\n                            ha = {}\n                            hl23 = {}\n                            da = {}\n                            bfacs = {}\n                        for i in range(4):\n                            if curr_SMCS[i] != this_SMCS[i]:\n                                SMCS_init[i](this_SMCS[i])\n                                curr_SMCS[i] = this_SMCS[i]\n                                if i == 0:\n                                    struct_builder.set_header(header_dict)\n                                elif i == 1:\n                                    curr_SMCS[2] = curr_SMCS[3] = None\n                                elif i == 2:\n                                    sb_chain = struct_builder.chain\n                                    sbcic = sb_chain.internal_coord = IC_Chain(sb_chain)\n                    struct_builder.init_residue(m.group('res'), m.group('het'), int(m.group('pos')), m.group('icode'))\n                    sb_res = struct_builder.residue\n                    if sb_res.id[0] != ' ':\n                        continue\n                    if 2 == sb_res.is_disordered():\n                        for r in sb_res.child_dict.values():\n                            if not r.internal_coord:\n                                sb_res = r\n                                break\n                        tr.append(sb_res)\n                    else:\n                        link_residues(pr, tr)\n                        if not quick:\n                            for r in pr:\n                                dihedra_check(r.internal_coord)\n                        pr = tr\n                        tr = [sb_res]\n                    sbric = sb_res.internal_coord = IC_Residue(sb_res)\n                    sbric.cic = sbcic\n                    rkl = (str(sb_res.id[1]), None if sb_res.id[2] == ' ' else sb_res.id[2], sbric.lc)\n                    sbcic.ordered_aa_ic_list.append(sbric)\n                    for ak in orphan_aks:\n                        if ak.akl[0:3] == rkl:\n                            ak.ric = sbric\n                            sbric.ak_set.add(ak)\n                    orphan_aks = set(filter(lambda ak: ak.ric is None, orphan_aks))\n                else:\n                    if verbose:\n                        print('Reading pic file', file, 'residue ID parse fail: ', line)\n                    return None\n            elif line.startswith('ATOM '):\n                m = pdb_atm_re.match(line)\n                if not m:\n                    m = pdbx_atm_re.match(line)\n                if m:\n                    if sb_res is None:\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM without residue configured:, ', line)\n                        return None\n                    if sb_res.resname != m.group('res') or sb_res.id[1] != int(m.group('pos')):\n                        if verbose:\n                            print('Reading pic file', file, 'ATOM not in configured residue (', sb_res.resname, str(sb_res.id), '):', line)\n                        return None\n                    coord = np.array((float(m.group('x')), float(m.group('y')), float(m.group('z'))), 'f')\n                    struct_builder.init_atom(m.group('atm').strip(), coord, float(m.group('tfac')), float(m.group('occ')), m.group('alc'), m.group('atm'), int(m.group('ser')), m.group('elm').strip())\n                    pr = []\n            elif line.startswith('BFAC: '):\n                m = bfac_re.match(line)\n                if m:\n                    for bfac_pair in m.groups():\n                        if bfac_pair is not None:\n                            m2 = bfac2_re.match(bfac_pair)\n                            bfacs[m2.group(1)] = float(m2.group(2))\n            else:\n                m = Edron.edron_re.match(line)\n                if m and sb_res is not None:\n                    if m['a4'] is None:\n                        process_hedron(m['a1'], m['a2'], m['a3'], m['len12'], m['angle'], m['len23'], sb_res.internal_coord)\n                    else:\n                        process_dihedron(m['a1'], m['a2'], m['a3'], m['a4'], m['dihedral'], sb_res.internal_coord)\n                elif m:\n                    print('PIC file: ', file, ' error: no residue info before reading (di/h)edron: ', line)\n                    return None\n                elif line.strip():\n                    if verbose:\n                        print('Reading PIC file', file, 'parse fail on: .', line, '.')\n                    return None\n    finish_chain()\n    return struct_builder.get_structure()"
        ]
    },
    {
        "func_name": "read_PIC_seq",
        "original": "def read_PIC_seq(seqRec: 'SeqIO.SeqRecord', pdbid: str=None, title: str=None, chain: str=None) -> Structure:\n    \"\"\"Read :class:`.SeqRecord` into Structure with default internal coords.\"\"\"\n    (read_pdbid, read_title, read_chain) = (None, None, None)\n    if seqRec.id is not None:\n        read_pdbid = seqRec.id\n    if seqRec.description is not None:\n        read_title = seqRec.description.replace(f'{read_pdbid} ', '')\n    if ':' in read_pdbid:\n        (read_pdbid, read_chain) = read_pdbid.split(':')\n    if chain is None:\n        chain = read_chain if read_chain is not None else 'A'\n    if title is None:\n        title = read_title if read_title is not None else f\"sequence input {(seqRec.id if seqRec.id is not None else '')}\"\n    if pdbid is None:\n        pdbid = read_pdbid if read_pdbid is not None else '0PDB'\n    today = date.today()\n    datestr = today.strftime('%d-%b-%y').upper()\n    output = f\"HEADER    {'GENERATED STRUCTURE':40}{datestr}   {pdbid}\\n\"\n    output += f'TITLE     {title.upper():69}\\n'\n    ndx = 1\n    for r in seqRec.seq:\n        output += f\"('{pdbid}', 0, '{chain}', (' ', {ndx}, ' ')) {protein_letters_1to3[r]}\\n\"\n        ndx += 1\n    sp = StringIO()\n    sp.write(output)\n    sp.seek(0)\n    return read_PIC(sp, defaults=True)",
        "mutated": [
            "def read_PIC_seq(seqRec: 'SeqIO.SeqRecord', pdbid: str=None, title: str=None, chain: str=None) -> Structure:\n    if False:\n        i = 10\n    'Read :class:`.SeqRecord` into Structure with default internal coords.'\n    (read_pdbid, read_title, read_chain) = (None, None, None)\n    if seqRec.id is not None:\n        read_pdbid = seqRec.id\n    if seqRec.description is not None:\n        read_title = seqRec.description.replace(f'{read_pdbid} ', '')\n    if ':' in read_pdbid:\n        (read_pdbid, read_chain) = read_pdbid.split(':')\n    if chain is None:\n        chain = read_chain if read_chain is not None else 'A'\n    if title is None:\n        title = read_title if read_title is not None else f\"sequence input {(seqRec.id if seqRec.id is not None else '')}\"\n    if pdbid is None:\n        pdbid = read_pdbid if read_pdbid is not None else '0PDB'\n    today = date.today()\n    datestr = today.strftime('%d-%b-%y').upper()\n    output = f\"HEADER    {'GENERATED STRUCTURE':40}{datestr}   {pdbid}\\n\"\n    output += f'TITLE     {title.upper():69}\\n'\n    ndx = 1\n    for r in seqRec.seq:\n        output += f\"('{pdbid}', 0, '{chain}', (' ', {ndx}, ' ')) {protein_letters_1to3[r]}\\n\"\n        ndx += 1\n    sp = StringIO()\n    sp.write(output)\n    sp.seek(0)\n    return read_PIC(sp, defaults=True)",
            "def read_PIC_seq(seqRec: 'SeqIO.SeqRecord', pdbid: str=None, title: str=None, chain: str=None) -> Structure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Read :class:`.SeqRecord` into Structure with default internal coords.'\n    (read_pdbid, read_title, read_chain) = (None, None, None)\n    if seqRec.id is not None:\n        read_pdbid = seqRec.id\n    if seqRec.description is not None:\n        read_title = seqRec.description.replace(f'{read_pdbid} ', '')\n    if ':' in read_pdbid:\n        (read_pdbid, read_chain) = read_pdbid.split(':')\n    if chain is None:\n        chain = read_chain if read_chain is not None else 'A'\n    if title is None:\n        title = read_title if read_title is not None else f\"sequence input {(seqRec.id if seqRec.id is not None else '')}\"\n    if pdbid is None:\n        pdbid = read_pdbid if read_pdbid is not None else '0PDB'\n    today = date.today()\n    datestr = today.strftime('%d-%b-%y').upper()\n    output = f\"HEADER    {'GENERATED STRUCTURE':40}{datestr}   {pdbid}\\n\"\n    output += f'TITLE     {title.upper():69}\\n'\n    ndx = 1\n    for r in seqRec.seq:\n        output += f\"('{pdbid}', 0, '{chain}', (' ', {ndx}, ' ')) {protein_letters_1to3[r]}\\n\"\n        ndx += 1\n    sp = StringIO()\n    sp.write(output)\n    sp.seek(0)\n    return read_PIC(sp, defaults=True)",
            "def read_PIC_seq(seqRec: 'SeqIO.SeqRecord', pdbid: str=None, title: str=None, chain: str=None) -> Structure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Read :class:`.SeqRecord` into Structure with default internal coords.'\n    (read_pdbid, read_title, read_chain) = (None, None, None)\n    if seqRec.id is not None:\n        read_pdbid = seqRec.id\n    if seqRec.description is not None:\n        read_title = seqRec.description.replace(f'{read_pdbid} ', '')\n    if ':' in read_pdbid:\n        (read_pdbid, read_chain) = read_pdbid.split(':')\n    if chain is None:\n        chain = read_chain if read_chain is not None else 'A'\n    if title is None:\n        title = read_title if read_title is not None else f\"sequence input {(seqRec.id if seqRec.id is not None else '')}\"\n    if pdbid is None:\n        pdbid = read_pdbid if read_pdbid is not None else '0PDB'\n    today = date.today()\n    datestr = today.strftime('%d-%b-%y').upper()\n    output = f\"HEADER    {'GENERATED STRUCTURE':40}{datestr}   {pdbid}\\n\"\n    output += f'TITLE     {title.upper():69}\\n'\n    ndx = 1\n    for r in seqRec.seq:\n        output += f\"('{pdbid}', 0, '{chain}', (' ', {ndx}, ' ')) {protein_letters_1to3[r]}\\n\"\n        ndx += 1\n    sp = StringIO()\n    sp.write(output)\n    sp.seek(0)\n    return read_PIC(sp, defaults=True)",
            "def read_PIC_seq(seqRec: 'SeqIO.SeqRecord', pdbid: str=None, title: str=None, chain: str=None) -> Structure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Read :class:`.SeqRecord` into Structure with default internal coords.'\n    (read_pdbid, read_title, read_chain) = (None, None, None)\n    if seqRec.id is not None:\n        read_pdbid = seqRec.id\n    if seqRec.description is not None:\n        read_title = seqRec.description.replace(f'{read_pdbid} ', '')\n    if ':' in read_pdbid:\n        (read_pdbid, read_chain) = read_pdbid.split(':')\n    if chain is None:\n        chain = read_chain if read_chain is not None else 'A'\n    if title is None:\n        title = read_title if read_title is not None else f\"sequence input {(seqRec.id if seqRec.id is not None else '')}\"\n    if pdbid is None:\n        pdbid = read_pdbid if read_pdbid is not None else '0PDB'\n    today = date.today()\n    datestr = today.strftime('%d-%b-%y').upper()\n    output = f\"HEADER    {'GENERATED STRUCTURE':40}{datestr}   {pdbid}\\n\"\n    output += f'TITLE     {title.upper():69}\\n'\n    ndx = 1\n    for r in seqRec.seq:\n        output += f\"('{pdbid}', 0, '{chain}', (' ', {ndx}, ' ')) {protein_letters_1to3[r]}\\n\"\n        ndx += 1\n    sp = StringIO()\n    sp.write(output)\n    sp.seek(0)\n    return read_PIC(sp, defaults=True)",
            "def read_PIC_seq(seqRec: 'SeqIO.SeqRecord', pdbid: str=None, title: str=None, chain: str=None) -> Structure:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Read :class:`.SeqRecord` into Structure with default internal coords.'\n    (read_pdbid, read_title, read_chain) = (None, None, None)\n    if seqRec.id is not None:\n        read_pdbid = seqRec.id\n    if seqRec.description is not None:\n        read_title = seqRec.description.replace(f'{read_pdbid} ', '')\n    if ':' in read_pdbid:\n        (read_pdbid, read_chain) = read_pdbid.split(':')\n    if chain is None:\n        chain = read_chain if read_chain is not None else 'A'\n    if title is None:\n        title = read_title if read_title is not None else f\"sequence input {(seqRec.id if seqRec.id is not None else '')}\"\n    if pdbid is None:\n        pdbid = read_pdbid if read_pdbid is not None else '0PDB'\n    today = date.today()\n    datestr = today.strftime('%d-%b-%y').upper()\n    output = f\"HEADER    {'GENERATED STRUCTURE':40}{datestr}   {pdbid}\\n\"\n    output += f'TITLE     {title.upper():69}\\n'\n    ndx = 1\n    for r in seqRec.seq:\n        output += f\"('{pdbid}', 0, '{chain}', (' ', {ndx}, ' ')) {protein_letters_1to3[r]}\\n\"\n        ndx += 1\n    sp = StringIO()\n    sp.write(output)\n    sp.seek(0)\n    return read_PIC(sp, defaults=True)"
        ]
    },
    {
        "func_name": "_wpr",
        "original": "def _wpr(entity, fp, pdbid, chainid, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if entity.internal_coord:\n        if not chainid or not pdbid:\n            chain = entity.parent\n            if not chainid:\n                chainid = chain.id\n            if not pdbid:\n                struct = chain.parent.parent\n                pdbid = struct.header.get('idcode')\n        fp.write(entity.internal_coord._write_PIC(pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut))\n    else:\n        fp.write(IC_Residue._residue_string(entity))",
        "mutated": [
            "def _wpr(entity, fp, pdbid, chainid, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n    if entity.internal_coord:\n        if not chainid or not pdbid:\n            chain = entity.parent\n            if not chainid:\n                chainid = chain.id\n            if not pdbid:\n                struct = chain.parent.parent\n                pdbid = struct.header.get('idcode')\n        fp.write(entity.internal_coord._write_PIC(pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut))\n    else:\n        fp.write(IC_Residue._residue_string(entity))",
            "def _wpr(entity, fp, pdbid, chainid, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if entity.internal_coord:\n        if not chainid or not pdbid:\n            chain = entity.parent\n            if not chainid:\n                chainid = chain.id\n            if not pdbid:\n                struct = chain.parent.parent\n                pdbid = struct.header.get('idcode')\n        fp.write(entity.internal_coord._write_PIC(pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut))\n    else:\n        fp.write(IC_Residue._residue_string(entity))",
            "def _wpr(entity, fp, pdbid, chainid, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if entity.internal_coord:\n        if not chainid or not pdbid:\n            chain = entity.parent\n            if not chainid:\n                chainid = chain.id\n            if not pdbid:\n                struct = chain.parent.parent\n                pdbid = struct.header.get('idcode')\n        fp.write(entity.internal_coord._write_PIC(pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut))\n    else:\n        fp.write(IC_Residue._residue_string(entity))",
            "def _wpr(entity, fp, pdbid, chainid, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if entity.internal_coord:\n        if not chainid or not pdbid:\n            chain = entity.parent\n            if not chainid:\n                chainid = chain.id\n            if not pdbid:\n                struct = chain.parent.parent\n                pdbid = struct.header.get('idcode')\n        fp.write(entity.internal_coord._write_PIC(pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut))\n    else:\n        fp.write(IC_Residue._residue_string(entity))",
            "def _wpr(entity, fp, pdbid, chainid, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if entity.internal_coord:\n        if not chainid or not pdbid:\n            chain = entity.parent\n            if not chainid:\n                chainid = chain.id\n            if not pdbid:\n                struct = chain.parent.parent\n                pdbid = struct.header.get('idcode')\n        fp.write(entity.internal_coord._write_PIC(pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut))\n    else:\n        fp.write(IC_Residue._residue_string(entity))"
        ]
    },
    {
        "func_name": "_enumerate_entity_atoms",
        "original": "def _enumerate_entity_atoms(entity):\n    need = False\n    for atm in entity.get_atoms():\n        need = not atm.get_serial_number()\n        break\n    if need:\n        anum = 1\n        for res in entity.get_residues():\n            if 2 == res.is_disordered():\n                for r in res.child_dict.values():\n                    for atm in r.get_unpacked_list():\n                        atm.set_serial_number(anum)\n                        anum += 1\n            else:\n                for atm in res.get_unpacked_list():\n                    atm.set_serial_number(anum)\n                    anum += 1",
        "mutated": [
            "def _enumerate_entity_atoms(entity):\n    if False:\n        i = 10\n    need = False\n    for atm in entity.get_atoms():\n        need = not atm.get_serial_number()\n        break\n    if need:\n        anum = 1\n        for res in entity.get_residues():\n            if 2 == res.is_disordered():\n                for r in res.child_dict.values():\n                    for atm in r.get_unpacked_list():\n                        atm.set_serial_number(anum)\n                        anum += 1\n            else:\n                for atm in res.get_unpacked_list():\n                    atm.set_serial_number(anum)\n                    anum += 1",
            "def _enumerate_entity_atoms(entity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    need = False\n    for atm in entity.get_atoms():\n        need = not atm.get_serial_number()\n        break\n    if need:\n        anum = 1\n        for res in entity.get_residues():\n            if 2 == res.is_disordered():\n                for r in res.child_dict.values():\n                    for atm in r.get_unpacked_list():\n                        atm.set_serial_number(anum)\n                        anum += 1\n            else:\n                for atm in res.get_unpacked_list():\n                    atm.set_serial_number(anum)\n                    anum += 1",
            "def _enumerate_entity_atoms(entity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    need = False\n    for atm in entity.get_atoms():\n        need = not atm.get_serial_number()\n        break\n    if need:\n        anum = 1\n        for res in entity.get_residues():\n            if 2 == res.is_disordered():\n                for r in res.child_dict.values():\n                    for atm in r.get_unpacked_list():\n                        atm.set_serial_number(anum)\n                        anum += 1\n            else:\n                for atm in res.get_unpacked_list():\n                    atm.set_serial_number(anum)\n                    anum += 1",
            "def _enumerate_entity_atoms(entity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    need = False\n    for atm in entity.get_atoms():\n        need = not atm.get_serial_number()\n        break\n    if need:\n        anum = 1\n        for res in entity.get_residues():\n            if 2 == res.is_disordered():\n                for r in res.child_dict.values():\n                    for atm in r.get_unpacked_list():\n                        atm.set_serial_number(anum)\n                        anum += 1\n            else:\n                for atm in res.get_unpacked_list():\n                    atm.set_serial_number(anum)\n                    anum += 1",
            "def _enumerate_entity_atoms(entity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    need = False\n    for atm in entity.get_atoms():\n        need = not atm.get_serial_number()\n        break\n    if need:\n        anum = 1\n        for res in entity.get_residues():\n            if 2 == res.is_disordered():\n                for r in res.child_dict.values():\n                    for atm in r.get_unpacked_list():\n                        atm.set_serial_number(anum)\n                        anum += 1\n            else:\n                for atm in res.get_unpacked_list():\n                    atm.set_serial_number(anum)\n                    anum += 1"
        ]
    },
    {
        "func_name": "enumerate_atoms",
        "original": "def enumerate_atoms(entity):\n    \"\"\"Ensure all atoms in entity have serial_number set.\"\"\"\n    while entity.get_parent():\n        entity = entity.get_parent()\n    if 'S' == entity.level:\n        for mdl in entity:\n            _enumerate_entity_atoms(mdl)\n    else:\n        _enumerate_entity_atoms(entity)",
        "mutated": [
            "def enumerate_atoms(entity):\n    if False:\n        i = 10\n    'Ensure all atoms in entity have serial_number set.'\n    while entity.get_parent():\n        entity = entity.get_parent()\n    if 'S' == entity.level:\n        for mdl in entity:\n            _enumerate_entity_atoms(mdl)\n    else:\n        _enumerate_entity_atoms(entity)",
            "def enumerate_atoms(entity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Ensure all atoms in entity have serial_number set.'\n    while entity.get_parent():\n        entity = entity.get_parent()\n    if 'S' == entity.level:\n        for mdl in entity:\n            _enumerate_entity_atoms(mdl)\n    else:\n        _enumerate_entity_atoms(entity)",
            "def enumerate_atoms(entity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Ensure all atoms in entity have serial_number set.'\n    while entity.get_parent():\n        entity = entity.get_parent()\n    if 'S' == entity.level:\n        for mdl in entity:\n            _enumerate_entity_atoms(mdl)\n    else:\n        _enumerate_entity_atoms(entity)",
            "def enumerate_atoms(entity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Ensure all atoms in entity have serial_number set.'\n    while entity.get_parent():\n        entity = entity.get_parent()\n    if 'S' == entity.level:\n        for mdl in entity:\n            _enumerate_entity_atoms(mdl)\n    else:\n        _enumerate_entity_atoms(entity)",
            "def enumerate_atoms(entity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Ensure all atoms in entity have serial_number set.'\n    while entity.get_parent():\n        entity = entity.get_parent()\n    if 'S' == entity.level:\n        for mdl in entity:\n            _enumerate_entity_atoms(mdl)\n    else:\n        _enumerate_entity_atoms(entity)"
        ]
    },
    {
        "func_name": "pdb_date",
        "original": "def pdb_date(datestr: str) -> str:\n    \"\"\"Convert yyyy-mm-dd date to dd-month-yy.\"\"\"\n    if datestr:\n        m = re.match('(\\\\d{4})-(\\\\d{2})-(\\\\d{2})', datestr)\n        if m:\n            mo = ['XXX', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'][int(m.group(2))]\n            datestr = m.group(3) + '-' + mo + '-' + m.group(1)[-2:]\n    return datestr",
        "mutated": [
            "def pdb_date(datestr: str) -> str:\n    if False:\n        i = 10\n    'Convert yyyy-mm-dd date to dd-month-yy.'\n    if datestr:\n        m = re.match('(\\\\d{4})-(\\\\d{2})-(\\\\d{2})', datestr)\n        if m:\n            mo = ['XXX', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'][int(m.group(2))]\n            datestr = m.group(3) + '-' + mo + '-' + m.group(1)[-2:]\n    return datestr",
            "def pdb_date(datestr: str) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert yyyy-mm-dd date to dd-month-yy.'\n    if datestr:\n        m = re.match('(\\\\d{4})-(\\\\d{2})-(\\\\d{2})', datestr)\n        if m:\n            mo = ['XXX', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'][int(m.group(2))]\n            datestr = m.group(3) + '-' + mo + '-' + m.group(1)[-2:]\n    return datestr",
            "def pdb_date(datestr: str) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert yyyy-mm-dd date to dd-month-yy.'\n    if datestr:\n        m = re.match('(\\\\d{4})-(\\\\d{2})-(\\\\d{2})', datestr)\n        if m:\n            mo = ['XXX', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'][int(m.group(2))]\n            datestr = m.group(3) + '-' + mo + '-' + m.group(1)[-2:]\n    return datestr",
            "def pdb_date(datestr: str) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert yyyy-mm-dd date to dd-month-yy.'\n    if datestr:\n        m = re.match('(\\\\d{4})-(\\\\d{2})-(\\\\d{2})', datestr)\n        if m:\n            mo = ['XXX', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'][int(m.group(2))]\n            datestr = m.group(3) + '-' + mo + '-' + m.group(1)[-2:]\n    return datestr",
            "def pdb_date(datestr: str) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert yyyy-mm-dd date to dd-month-yy.'\n    if datestr:\n        m = re.match('(\\\\d{4})-(\\\\d{2})-(\\\\d{2})', datestr)\n        if m:\n            mo = ['XXX', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'][int(m.group(2))]\n            datestr = m.group(3) + '-' + mo + '-' + m.group(1)[-2:]\n    return datestr"
        ]
    },
    {
        "func_name": "write_PIC",
        "original": "def write_PIC(entity, file, pdbid=None, chainid=None, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    \"\"\"Write Protein Internal Coordinates (PIC) to file.\n\n    See :func:`read_PIC` for file format.\n    See :data:`IC_Residue.pic_accuracy` to vary numeric accuracy.\n    Recurses to lower entity levels (M, C, R).\n\n    :param Entity entity: Biopython PDB Entity object: S, M, C or R\n    :param Bio.File file: :func:`.as_handle` file name or handle\n    :param str pdbid: PDB idcode, read from entity if not supplied\n    :param char chainid: PDB Chain ID, set from C level entity.id if needed\n    :param int picFlags: boolean flags controlling output, defined in\n        :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags`\n\n        * \"psi\",\n        * \"omg\",\n        * \"phi\",\n        * \"tau\",  # tau hedron (N-Ca-C)\n        * \"chi1\",\n        * \"chi2\",\n        * \"chi3\",\n        * \"chi4\",\n        * \"chi5\",\n        * \"pomg\",  # proline omega\n        * \"chi\",   # chi1 through chi5\n        * \"classic_b\",  # psi | phi | tau | pomg\n        * \"classic\",    # classic_b | chi\n        * \"hedra\",      # all hedra including bond lengths\n        * \"primary\",    # all primary dihedra\n        * \"secondary\",  # all secondary dihedra (fixed angle from primary dihedra)\n        * \"all\",        # hedra | primary | secondary\n        * \"initAtoms\",  # XYZ coordinates of initial Tau (N-Ca-C)\n        * \"bFactors\"\n\n        default is everything::\n\n            picFlagsDefault = (\n                pic_flags.all | pic_flags.initAtoms | pic_flags.bFactors\n            )\n\n        Usage in your code::\n\n            # just primary dihedra and all hedra\n            picFlags = (\n                IC_Residue.pic_flags.primary | IC_Residue.pic_flags.hedra\n            )\n\n            # no B-factors:\n            picFlags = IC_Residue.picFlagsDefault\n            picFlags &= ~IC_Residue.pic_flags.bFactors\n\n        :func:`read_PIC` with `(defaults=True)` will use default values for\n        anything left out\n\n    :param float hCut: default None\n        only write hedra with ref db angle std dev greater than this value\n    :param float pCut: default None\n        only write primary dihedra with ref db angle std dev greater than this\n        value\n\n    **Default values**:\n\n    Data averaged from Sep 2019 Dunbrack cullpdb_pc20_res2.2_R1.0.\n\n    Please see\n\n    `PISCES: A Protein Sequence Culling Server <https://dunbrack.fccc.edu/pisces/>`_\n\n    'G. Wang and R. L. Dunbrack, Jr. PISCES: a protein sequence culling\n    server. Bioinformatics, 19:1589-1591, 2003.'\n\n    'primary' and 'secondary' dihedra are defined in ic_data.py.  Specifically,\n    secondary dihedra can be determined as a fixed rotation from another known\n    angle, for example N-Ca-C-O can be estimated from N-Ca-C-N (psi).\n\n    Standard deviations are listed in\n    <biopython distribution>/Bio/PDB/ic_data.py for default values, and can be\n    used to limit which hedra and dihedra are defaulted vs. output exact\n    measurements from structure (see hCut and pCut above).  Default values for\n    primary dihedra (psi, phi, omega, chi1, etc.) are chosen as the most common\n    integer value, not an average.\n\n    :raises PDBException: if entity level is A (Atom)\n    :raises Exception: if entity does not have .level attribute\n    \"\"\"\n    enumerate_atoms(entity)\n    with as_handle(file, 'w') as fp:\n        try:\n            if 'A' == entity.level:\n                raise PDBException('No PIC output at Atom level')\n            elif 'R' == entity.level:\n                if 2 == entity.is_disordered():\n                    for r in entity.child_dict.values():\n                        _wpr(r, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n                else:\n                    _wpr(entity, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'C' == entity.level:\n                if not chainid:\n                    chainid = entity.id\n                for res in entity:\n                    write_PIC(res, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'M' == entity.level:\n                for chn in entity:\n                    write_PIC(chn, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'S' == entity.level:\n                if not pdbid:\n                    pdbid = entity.header.get('idcode', None)\n                hdr = entity.header.get('head', None)\n                dd = pdb_date(entity.header.get('deposition_date', None))\n                if hdr:\n                    fp.write('HEADER    {:40}{:8}   {:4}\\n'.format(hdr.upper(), dd or '', pdbid or ''))\n                nam = entity.header.get('name', None)\n                if nam:\n                    fp.write('TITLE     ' + nam.upper() + '\\n')\n                for mdl in entity:\n                    write_PIC(mdl, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            else:\n                raise PDBException('Cannot identify level: ' + str(entity.level))\n        except KeyError:\n            raise Exception('write_PIC: argument is not a Biopython PDB Entity ' + str(entity))",
        "mutated": [
            "def write_PIC(entity, file, pdbid=None, chainid=None, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n    'Write Protein Internal Coordinates (PIC) to file.\\n\\n    See :func:`read_PIC` for file format.\\n    See :data:`IC_Residue.pic_accuracy` to vary numeric accuracy.\\n    Recurses to lower entity levels (M, C, R).\\n\\n    :param Entity entity: Biopython PDB Entity object: S, M, C or R\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param str pdbid: PDB idcode, read from entity if not supplied\\n    :param char chainid: PDB Chain ID, set from C level entity.id if needed\\n    :param int picFlags: boolean flags controlling output, defined in\\n        :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags`\\n\\n        * \"psi\",\\n        * \"omg\",\\n        * \"phi\",\\n        * \"tau\",  # tau hedron (N-Ca-C)\\n        * \"chi1\",\\n        * \"chi2\",\\n        * \"chi3\",\\n        * \"chi4\",\\n        * \"chi5\",\\n        * \"pomg\",  # proline omega\\n        * \"chi\",   # chi1 through chi5\\n        * \"classic_b\",  # psi | phi | tau | pomg\\n        * \"classic\",    # classic_b | chi\\n        * \"hedra\",      # all hedra including bond lengths\\n        * \"primary\",    # all primary dihedra\\n        * \"secondary\",  # all secondary dihedra (fixed angle from primary dihedra)\\n        * \"all\",        # hedra | primary | secondary\\n        * \"initAtoms\",  # XYZ coordinates of initial Tau (N-Ca-C)\\n        * \"bFactors\"\\n\\n        default is everything::\\n\\n            picFlagsDefault = (\\n                pic_flags.all | pic_flags.initAtoms | pic_flags.bFactors\\n            )\\n\\n        Usage in your code::\\n\\n            # just primary dihedra and all hedra\\n            picFlags = (\\n                IC_Residue.pic_flags.primary | IC_Residue.pic_flags.hedra\\n            )\\n\\n            # no B-factors:\\n            picFlags = IC_Residue.picFlagsDefault\\n            picFlags &= ~IC_Residue.pic_flags.bFactors\\n\\n        :func:`read_PIC` with `(defaults=True)` will use default values for\\n        anything left out\\n\\n    :param float hCut: default None\\n        only write hedra with ref db angle std dev greater than this value\\n    :param float pCut: default None\\n        only write primary dihedra with ref db angle std dev greater than this\\n        value\\n\\n    **Default values**:\\n\\n    Data averaged from Sep 2019 Dunbrack cullpdb_pc20_res2.2_R1.0.\\n\\n    Please see\\n\\n    `PISCES: A Protein Sequence Culling Server <https://dunbrack.fccc.edu/pisces/>`_\\n\\n    \\'G. Wang and R. L. Dunbrack, Jr. PISCES: a protein sequence culling\\n    server. Bioinformatics, 19:1589-1591, 2003.\\'\\n\\n    \\'primary\\' and \\'secondary\\' dihedra are defined in ic_data.py.  Specifically,\\n    secondary dihedra can be determined as a fixed rotation from another known\\n    angle, for example N-Ca-C-O can be estimated from N-Ca-C-N (psi).\\n\\n    Standard deviations are listed in\\n    <biopython distribution>/Bio/PDB/ic_data.py for default values, and can be\\n    used to limit which hedra and dihedra are defaulted vs. output exact\\n    measurements from structure (see hCut and pCut above).  Default values for\\n    primary dihedra (psi, phi, omega, chi1, etc.) are chosen as the most common\\n    integer value, not an average.\\n\\n    :raises PDBException: if entity level is A (Atom)\\n    :raises Exception: if entity does not have .level attribute\\n    '\n    enumerate_atoms(entity)\n    with as_handle(file, 'w') as fp:\n        try:\n            if 'A' == entity.level:\n                raise PDBException('No PIC output at Atom level')\n            elif 'R' == entity.level:\n                if 2 == entity.is_disordered():\n                    for r in entity.child_dict.values():\n                        _wpr(r, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n                else:\n                    _wpr(entity, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'C' == entity.level:\n                if not chainid:\n                    chainid = entity.id\n                for res in entity:\n                    write_PIC(res, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'M' == entity.level:\n                for chn in entity:\n                    write_PIC(chn, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'S' == entity.level:\n                if not pdbid:\n                    pdbid = entity.header.get('idcode', None)\n                hdr = entity.header.get('head', None)\n                dd = pdb_date(entity.header.get('deposition_date', None))\n                if hdr:\n                    fp.write('HEADER    {:40}{:8}   {:4}\\n'.format(hdr.upper(), dd or '', pdbid or ''))\n                nam = entity.header.get('name', None)\n                if nam:\n                    fp.write('TITLE     ' + nam.upper() + '\\n')\n                for mdl in entity:\n                    write_PIC(mdl, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            else:\n                raise PDBException('Cannot identify level: ' + str(entity.level))\n        except KeyError:\n            raise Exception('write_PIC: argument is not a Biopython PDB Entity ' + str(entity))",
            "def write_PIC(entity, file, pdbid=None, chainid=None, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Write Protein Internal Coordinates (PIC) to file.\\n\\n    See :func:`read_PIC` for file format.\\n    See :data:`IC_Residue.pic_accuracy` to vary numeric accuracy.\\n    Recurses to lower entity levels (M, C, R).\\n\\n    :param Entity entity: Biopython PDB Entity object: S, M, C or R\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param str pdbid: PDB idcode, read from entity if not supplied\\n    :param char chainid: PDB Chain ID, set from C level entity.id if needed\\n    :param int picFlags: boolean flags controlling output, defined in\\n        :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags`\\n\\n        * \"psi\",\\n        * \"omg\",\\n        * \"phi\",\\n        * \"tau\",  # tau hedron (N-Ca-C)\\n        * \"chi1\",\\n        * \"chi2\",\\n        * \"chi3\",\\n        * \"chi4\",\\n        * \"chi5\",\\n        * \"pomg\",  # proline omega\\n        * \"chi\",   # chi1 through chi5\\n        * \"classic_b\",  # psi | phi | tau | pomg\\n        * \"classic\",    # classic_b | chi\\n        * \"hedra\",      # all hedra including bond lengths\\n        * \"primary\",    # all primary dihedra\\n        * \"secondary\",  # all secondary dihedra (fixed angle from primary dihedra)\\n        * \"all\",        # hedra | primary | secondary\\n        * \"initAtoms\",  # XYZ coordinates of initial Tau (N-Ca-C)\\n        * \"bFactors\"\\n\\n        default is everything::\\n\\n            picFlagsDefault = (\\n                pic_flags.all | pic_flags.initAtoms | pic_flags.bFactors\\n            )\\n\\n        Usage in your code::\\n\\n            # just primary dihedra and all hedra\\n            picFlags = (\\n                IC_Residue.pic_flags.primary | IC_Residue.pic_flags.hedra\\n            )\\n\\n            # no B-factors:\\n            picFlags = IC_Residue.picFlagsDefault\\n            picFlags &= ~IC_Residue.pic_flags.bFactors\\n\\n        :func:`read_PIC` with `(defaults=True)` will use default values for\\n        anything left out\\n\\n    :param float hCut: default None\\n        only write hedra with ref db angle std dev greater than this value\\n    :param float pCut: default None\\n        only write primary dihedra with ref db angle std dev greater than this\\n        value\\n\\n    **Default values**:\\n\\n    Data averaged from Sep 2019 Dunbrack cullpdb_pc20_res2.2_R1.0.\\n\\n    Please see\\n\\n    `PISCES: A Protein Sequence Culling Server <https://dunbrack.fccc.edu/pisces/>`_\\n\\n    \\'G. Wang and R. L. Dunbrack, Jr. PISCES: a protein sequence culling\\n    server. Bioinformatics, 19:1589-1591, 2003.\\'\\n\\n    \\'primary\\' and \\'secondary\\' dihedra are defined in ic_data.py.  Specifically,\\n    secondary dihedra can be determined as a fixed rotation from another known\\n    angle, for example N-Ca-C-O can be estimated from N-Ca-C-N (psi).\\n\\n    Standard deviations are listed in\\n    <biopython distribution>/Bio/PDB/ic_data.py for default values, and can be\\n    used to limit which hedra and dihedra are defaulted vs. output exact\\n    measurements from structure (see hCut and pCut above).  Default values for\\n    primary dihedra (psi, phi, omega, chi1, etc.) are chosen as the most common\\n    integer value, not an average.\\n\\n    :raises PDBException: if entity level is A (Atom)\\n    :raises Exception: if entity does not have .level attribute\\n    '\n    enumerate_atoms(entity)\n    with as_handle(file, 'w') as fp:\n        try:\n            if 'A' == entity.level:\n                raise PDBException('No PIC output at Atom level')\n            elif 'R' == entity.level:\n                if 2 == entity.is_disordered():\n                    for r in entity.child_dict.values():\n                        _wpr(r, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n                else:\n                    _wpr(entity, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'C' == entity.level:\n                if not chainid:\n                    chainid = entity.id\n                for res in entity:\n                    write_PIC(res, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'M' == entity.level:\n                for chn in entity:\n                    write_PIC(chn, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'S' == entity.level:\n                if not pdbid:\n                    pdbid = entity.header.get('idcode', None)\n                hdr = entity.header.get('head', None)\n                dd = pdb_date(entity.header.get('deposition_date', None))\n                if hdr:\n                    fp.write('HEADER    {:40}{:8}   {:4}\\n'.format(hdr.upper(), dd or '', pdbid or ''))\n                nam = entity.header.get('name', None)\n                if nam:\n                    fp.write('TITLE     ' + nam.upper() + '\\n')\n                for mdl in entity:\n                    write_PIC(mdl, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            else:\n                raise PDBException('Cannot identify level: ' + str(entity.level))\n        except KeyError:\n            raise Exception('write_PIC: argument is not a Biopython PDB Entity ' + str(entity))",
            "def write_PIC(entity, file, pdbid=None, chainid=None, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Write Protein Internal Coordinates (PIC) to file.\\n\\n    See :func:`read_PIC` for file format.\\n    See :data:`IC_Residue.pic_accuracy` to vary numeric accuracy.\\n    Recurses to lower entity levels (M, C, R).\\n\\n    :param Entity entity: Biopython PDB Entity object: S, M, C or R\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param str pdbid: PDB idcode, read from entity if not supplied\\n    :param char chainid: PDB Chain ID, set from C level entity.id if needed\\n    :param int picFlags: boolean flags controlling output, defined in\\n        :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags`\\n\\n        * \"psi\",\\n        * \"omg\",\\n        * \"phi\",\\n        * \"tau\",  # tau hedron (N-Ca-C)\\n        * \"chi1\",\\n        * \"chi2\",\\n        * \"chi3\",\\n        * \"chi4\",\\n        * \"chi5\",\\n        * \"pomg\",  # proline omega\\n        * \"chi\",   # chi1 through chi5\\n        * \"classic_b\",  # psi | phi | tau | pomg\\n        * \"classic\",    # classic_b | chi\\n        * \"hedra\",      # all hedra including bond lengths\\n        * \"primary\",    # all primary dihedra\\n        * \"secondary\",  # all secondary dihedra (fixed angle from primary dihedra)\\n        * \"all\",        # hedra | primary | secondary\\n        * \"initAtoms\",  # XYZ coordinates of initial Tau (N-Ca-C)\\n        * \"bFactors\"\\n\\n        default is everything::\\n\\n            picFlagsDefault = (\\n                pic_flags.all | pic_flags.initAtoms | pic_flags.bFactors\\n            )\\n\\n        Usage in your code::\\n\\n            # just primary dihedra and all hedra\\n            picFlags = (\\n                IC_Residue.pic_flags.primary | IC_Residue.pic_flags.hedra\\n            )\\n\\n            # no B-factors:\\n            picFlags = IC_Residue.picFlagsDefault\\n            picFlags &= ~IC_Residue.pic_flags.bFactors\\n\\n        :func:`read_PIC` with `(defaults=True)` will use default values for\\n        anything left out\\n\\n    :param float hCut: default None\\n        only write hedra with ref db angle std dev greater than this value\\n    :param float pCut: default None\\n        only write primary dihedra with ref db angle std dev greater than this\\n        value\\n\\n    **Default values**:\\n\\n    Data averaged from Sep 2019 Dunbrack cullpdb_pc20_res2.2_R1.0.\\n\\n    Please see\\n\\n    `PISCES: A Protein Sequence Culling Server <https://dunbrack.fccc.edu/pisces/>`_\\n\\n    \\'G. Wang and R. L. Dunbrack, Jr. PISCES: a protein sequence culling\\n    server. Bioinformatics, 19:1589-1591, 2003.\\'\\n\\n    \\'primary\\' and \\'secondary\\' dihedra are defined in ic_data.py.  Specifically,\\n    secondary dihedra can be determined as a fixed rotation from another known\\n    angle, for example N-Ca-C-O can be estimated from N-Ca-C-N (psi).\\n\\n    Standard deviations are listed in\\n    <biopython distribution>/Bio/PDB/ic_data.py for default values, and can be\\n    used to limit which hedra and dihedra are defaulted vs. output exact\\n    measurements from structure (see hCut and pCut above).  Default values for\\n    primary dihedra (psi, phi, omega, chi1, etc.) are chosen as the most common\\n    integer value, not an average.\\n\\n    :raises PDBException: if entity level is A (Atom)\\n    :raises Exception: if entity does not have .level attribute\\n    '\n    enumerate_atoms(entity)\n    with as_handle(file, 'w') as fp:\n        try:\n            if 'A' == entity.level:\n                raise PDBException('No PIC output at Atom level')\n            elif 'R' == entity.level:\n                if 2 == entity.is_disordered():\n                    for r in entity.child_dict.values():\n                        _wpr(r, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n                else:\n                    _wpr(entity, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'C' == entity.level:\n                if not chainid:\n                    chainid = entity.id\n                for res in entity:\n                    write_PIC(res, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'M' == entity.level:\n                for chn in entity:\n                    write_PIC(chn, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'S' == entity.level:\n                if not pdbid:\n                    pdbid = entity.header.get('idcode', None)\n                hdr = entity.header.get('head', None)\n                dd = pdb_date(entity.header.get('deposition_date', None))\n                if hdr:\n                    fp.write('HEADER    {:40}{:8}   {:4}\\n'.format(hdr.upper(), dd or '', pdbid or ''))\n                nam = entity.header.get('name', None)\n                if nam:\n                    fp.write('TITLE     ' + nam.upper() + '\\n')\n                for mdl in entity:\n                    write_PIC(mdl, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            else:\n                raise PDBException('Cannot identify level: ' + str(entity.level))\n        except KeyError:\n            raise Exception('write_PIC: argument is not a Biopython PDB Entity ' + str(entity))",
            "def write_PIC(entity, file, pdbid=None, chainid=None, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Write Protein Internal Coordinates (PIC) to file.\\n\\n    See :func:`read_PIC` for file format.\\n    See :data:`IC_Residue.pic_accuracy` to vary numeric accuracy.\\n    Recurses to lower entity levels (M, C, R).\\n\\n    :param Entity entity: Biopython PDB Entity object: S, M, C or R\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param str pdbid: PDB idcode, read from entity if not supplied\\n    :param char chainid: PDB Chain ID, set from C level entity.id if needed\\n    :param int picFlags: boolean flags controlling output, defined in\\n        :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags`\\n\\n        * \"psi\",\\n        * \"omg\",\\n        * \"phi\",\\n        * \"tau\",  # tau hedron (N-Ca-C)\\n        * \"chi1\",\\n        * \"chi2\",\\n        * \"chi3\",\\n        * \"chi4\",\\n        * \"chi5\",\\n        * \"pomg\",  # proline omega\\n        * \"chi\",   # chi1 through chi5\\n        * \"classic_b\",  # psi | phi | tau | pomg\\n        * \"classic\",    # classic_b | chi\\n        * \"hedra\",      # all hedra including bond lengths\\n        * \"primary\",    # all primary dihedra\\n        * \"secondary\",  # all secondary dihedra (fixed angle from primary dihedra)\\n        * \"all\",        # hedra | primary | secondary\\n        * \"initAtoms\",  # XYZ coordinates of initial Tau (N-Ca-C)\\n        * \"bFactors\"\\n\\n        default is everything::\\n\\n            picFlagsDefault = (\\n                pic_flags.all | pic_flags.initAtoms | pic_flags.bFactors\\n            )\\n\\n        Usage in your code::\\n\\n            # just primary dihedra and all hedra\\n            picFlags = (\\n                IC_Residue.pic_flags.primary | IC_Residue.pic_flags.hedra\\n            )\\n\\n            # no B-factors:\\n            picFlags = IC_Residue.picFlagsDefault\\n            picFlags &= ~IC_Residue.pic_flags.bFactors\\n\\n        :func:`read_PIC` with `(defaults=True)` will use default values for\\n        anything left out\\n\\n    :param float hCut: default None\\n        only write hedra with ref db angle std dev greater than this value\\n    :param float pCut: default None\\n        only write primary dihedra with ref db angle std dev greater than this\\n        value\\n\\n    **Default values**:\\n\\n    Data averaged from Sep 2019 Dunbrack cullpdb_pc20_res2.2_R1.0.\\n\\n    Please see\\n\\n    `PISCES: A Protein Sequence Culling Server <https://dunbrack.fccc.edu/pisces/>`_\\n\\n    \\'G. Wang and R. L. Dunbrack, Jr. PISCES: a protein sequence culling\\n    server. Bioinformatics, 19:1589-1591, 2003.\\'\\n\\n    \\'primary\\' and \\'secondary\\' dihedra are defined in ic_data.py.  Specifically,\\n    secondary dihedra can be determined as a fixed rotation from another known\\n    angle, for example N-Ca-C-O can be estimated from N-Ca-C-N (psi).\\n\\n    Standard deviations are listed in\\n    <biopython distribution>/Bio/PDB/ic_data.py for default values, and can be\\n    used to limit which hedra and dihedra are defaulted vs. output exact\\n    measurements from structure (see hCut and pCut above).  Default values for\\n    primary dihedra (psi, phi, omega, chi1, etc.) are chosen as the most common\\n    integer value, not an average.\\n\\n    :raises PDBException: if entity level is A (Atom)\\n    :raises Exception: if entity does not have .level attribute\\n    '\n    enumerate_atoms(entity)\n    with as_handle(file, 'w') as fp:\n        try:\n            if 'A' == entity.level:\n                raise PDBException('No PIC output at Atom level')\n            elif 'R' == entity.level:\n                if 2 == entity.is_disordered():\n                    for r in entity.child_dict.values():\n                        _wpr(r, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n                else:\n                    _wpr(entity, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'C' == entity.level:\n                if not chainid:\n                    chainid = entity.id\n                for res in entity:\n                    write_PIC(res, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'M' == entity.level:\n                for chn in entity:\n                    write_PIC(chn, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'S' == entity.level:\n                if not pdbid:\n                    pdbid = entity.header.get('idcode', None)\n                hdr = entity.header.get('head', None)\n                dd = pdb_date(entity.header.get('deposition_date', None))\n                if hdr:\n                    fp.write('HEADER    {:40}{:8}   {:4}\\n'.format(hdr.upper(), dd or '', pdbid or ''))\n                nam = entity.header.get('name', None)\n                if nam:\n                    fp.write('TITLE     ' + nam.upper() + '\\n')\n                for mdl in entity:\n                    write_PIC(mdl, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            else:\n                raise PDBException('Cannot identify level: ' + str(entity.level))\n        except KeyError:\n            raise Exception('write_PIC: argument is not a Biopython PDB Entity ' + str(entity))",
            "def write_PIC(entity, file, pdbid=None, chainid=None, picFlags: int=IC_Residue.picFlagsDefault, hCut: Optional[Union[float, None]]=None, pCut: Optional[Union[float, None]]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Write Protein Internal Coordinates (PIC) to file.\\n\\n    See :func:`read_PIC` for file format.\\n    See :data:`IC_Residue.pic_accuracy` to vary numeric accuracy.\\n    Recurses to lower entity levels (M, C, R).\\n\\n    :param Entity entity: Biopython PDB Entity object: S, M, C or R\\n    :param Bio.File file: :func:`.as_handle` file name or handle\\n    :param str pdbid: PDB idcode, read from entity if not supplied\\n    :param char chainid: PDB Chain ID, set from C level entity.id if needed\\n    :param int picFlags: boolean flags controlling output, defined in\\n        :data:`Bio.PDB.internal_coords.IC_Residue.pic_flags`\\n\\n        * \"psi\",\\n        * \"omg\",\\n        * \"phi\",\\n        * \"tau\",  # tau hedron (N-Ca-C)\\n        * \"chi1\",\\n        * \"chi2\",\\n        * \"chi3\",\\n        * \"chi4\",\\n        * \"chi5\",\\n        * \"pomg\",  # proline omega\\n        * \"chi\",   # chi1 through chi5\\n        * \"classic_b\",  # psi | phi | tau | pomg\\n        * \"classic\",    # classic_b | chi\\n        * \"hedra\",      # all hedra including bond lengths\\n        * \"primary\",    # all primary dihedra\\n        * \"secondary\",  # all secondary dihedra (fixed angle from primary dihedra)\\n        * \"all\",        # hedra | primary | secondary\\n        * \"initAtoms\",  # XYZ coordinates of initial Tau (N-Ca-C)\\n        * \"bFactors\"\\n\\n        default is everything::\\n\\n            picFlagsDefault = (\\n                pic_flags.all | pic_flags.initAtoms | pic_flags.bFactors\\n            )\\n\\n        Usage in your code::\\n\\n            # just primary dihedra and all hedra\\n            picFlags = (\\n                IC_Residue.pic_flags.primary | IC_Residue.pic_flags.hedra\\n            )\\n\\n            # no B-factors:\\n            picFlags = IC_Residue.picFlagsDefault\\n            picFlags &= ~IC_Residue.pic_flags.bFactors\\n\\n        :func:`read_PIC` with `(defaults=True)` will use default values for\\n        anything left out\\n\\n    :param float hCut: default None\\n        only write hedra with ref db angle std dev greater than this value\\n    :param float pCut: default None\\n        only write primary dihedra with ref db angle std dev greater than this\\n        value\\n\\n    **Default values**:\\n\\n    Data averaged from Sep 2019 Dunbrack cullpdb_pc20_res2.2_R1.0.\\n\\n    Please see\\n\\n    `PISCES: A Protein Sequence Culling Server <https://dunbrack.fccc.edu/pisces/>`_\\n\\n    \\'G. Wang and R. L. Dunbrack, Jr. PISCES: a protein sequence culling\\n    server. Bioinformatics, 19:1589-1591, 2003.\\'\\n\\n    \\'primary\\' and \\'secondary\\' dihedra are defined in ic_data.py.  Specifically,\\n    secondary dihedra can be determined as a fixed rotation from another known\\n    angle, for example N-Ca-C-O can be estimated from N-Ca-C-N (psi).\\n\\n    Standard deviations are listed in\\n    <biopython distribution>/Bio/PDB/ic_data.py for default values, and can be\\n    used to limit which hedra and dihedra are defaulted vs. output exact\\n    measurements from structure (see hCut and pCut above).  Default values for\\n    primary dihedra (psi, phi, omega, chi1, etc.) are chosen as the most common\\n    integer value, not an average.\\n\\n    :raises PDBException: if entity level is A (Atom)\\n    :raises Exception: if entity does not have .level attribute\\n    '\n    enumerate_atoms(entity)\n    with as_handle(file, 'w') as fp:\n        try:\n            if 'A' == entity.level:\n                raise PDBException('No PIC output at Atom level')\n            elif 'R' == entity.level:\n                if 2 == entity.is_disordered():\n                    for r in entity.child_dict.values():\n                        _wpr(r, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n                else:\n                    _wpr(entity, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'C' == entity.level:\n                if not chainid:\n                    chainid = entity.id\n                for res in entity:\n                    write_PIC(res, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'M' == entity.level:\n                for chn in entity:\n                    write_PIC(chn, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            elif 'S' == entity.level:\n                if not pdbid:\n                    pdbid = entity.header.get('idcode', None)\n                hdr = entity.header.get('head', None)\n                dd = pdb_date(entity.header.get('deposition_date', None))\n                if hdr:\n                    fp.write('HEADER    {:40}{:8}   {:4}\\n'.format(hdr.upper(), dd or '', pdbid or ''))\n                nam = entity.header.get('name', None)\n                if nam:\n                    fp.write('TITLE     ' + nam.upper() + '\\n')\n                for mdl in entity:\n                    write_PIC(mdl, fp, pdbid, chainid, picFlags=picFlags, hCut=hCut, pCut=pCut)\n            else:\n                raise PDBException('Cannot identify level: ' + str(entity.level))\n        except KeyError:\n            raise Exception('write_PIC: argument is not a Biopython PDB Entity ' + str(entity))"
        ]
    }
]