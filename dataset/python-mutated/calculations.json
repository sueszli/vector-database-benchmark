[
    {
        "func_name": "_fast_cross_3d",
        "original": "def _fast_cross_3d(x, y):\n    \"\"\"Compute cross product between list of 3D vectors\n\n    Much faster than np.cross() when the number of cross products\n    becomes large (>500). This is because np.cross() methods become\n    less memory efficient at this stage.\n\n    Parameters\n    ----------\n    x : array\n        Input array 1.\n    y : array\n        Input array 2.\n\n    Returns\n    -------\n    z : array\n        Cross product of x and y.\n\n    Notes\n    -----\n    x and y must both be 2D row vectors. One must have length 1, or both\n    lengths must match.\n    \"\"\"\n    assert x.ndim == 2\n    assert y.ndim == 2\n    assert x.shape[1] == 3\n    assert y.shape[1] == 3\n    assert (x.shape[0] == 1 or y.shape[0] == 1) or x.shape[0] == y.shape[0]\n    if max([x.shape[0], y.shape[0]]) >= 500:\n        return np.c_[x[:, 1] * y[:, 2] - x[:, 2] * y[:, 1], x[:, 2] * y[:, 0] - x[:, 0] * y[:, 2], x[:, 0] * y[:, 1] - x[:, 1] * y[:, 0]]\n    else:\n        return np.cross(x, y)",
        "mutated": [
            "def _fast_cross_3d(x, y):\n    if False:\n        i = 10\n    'Compute cross product between list of 3D vectors\\n\\n    Much faster than np.cross() when the number of cross products\\n    becomes large (>500). This is because np.cross() methods become\\n    less memory efficient at this stage.\\n\\n    Parameters\\n    ----------\\n    x : array\\n        Input array 1.\\n    y : array\\n        Input array 2.\\n\\n    Returns\\n    -------\\n    z : array\\n        Cross product of x and y.\\n\\n    Notes\\n    -----\\n    x and y must both be 2D row vectors. One must have length 1, or both\\n    lengths must match.\\n    '\n    assert x.ndim == 2\n    assert y.ndim == 2\n    assert x.shape[1] == 3\n    assert y.shape[1] == 3\n    assert (x.shape[0] == 1 or y.shape[0] == 1) or x.shape[0] == y.shape[0]\n    if max([x.shape[0], y.shape[0]]) >= 500:\n        return np.c_[x[:, 1] * y[:, 2] - x[:, 2] * y[:, 1], x[:, 2] * y[:, 0] - x[:, 0] * y[:, 2], x[:, 0] * y[:, 1] - x[:, 1] * y[:, 0]]\n    else:\n        return np.cross(x, y)",
            "def _fast_cross_3d(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute cross product between list of 3D vectors\\n\\n    Much faster than np.cross() when the number of cross products\\n    becomes large (>500). This is because np.cross() methods become\\n    less memory efficient at this stage.\\n\\n    Parameters\\n    ----------\\n    x : array\\n        Input array 1.\\n    y : array\\n        Input array 2.\\n\\n    Returns\\n    -------\\n    z : array\\n        Cross product of x and y.\\n\\n    Notes\\n    -----\\n    x and y must both be 2D row vectors. One must have length 1, or both\\n    lengths must match.\\n    '\n    assert x.ndim == 2\n    assert y.ndim == 2\n    assert x.shape[1] == 3\n    assert y.shape[1] == 3\n    assert (x.shape[0] == 1 or y.shape[0] == 1) or x.shape[0] == y.shape[0]\n    if max([x.shape[0], y.shape[0]]) >= 500:\n        return np.c_[x[:, 1] * y[:, 2] - x[:, 2] * y[:, 1], x[:, 2] * y[:, 0] - x[:, 0] * y[:, 2], x[:, 0] * y[:, 1] - x[:, 1] * y[:, 0]]\n    else:\n        return np.cross(x, y)",
            "def _fast_cross_3d(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute cross product between list of 3D vectors\\n\\n    Much faster than np.cross() when the number of cross products\\n    becomes large (>500). This is because np.cross() methods become\\n    less memory efficient at this stage.\\n\\n    Parameters\\n    ----------\\n    x : array\\n        Input array 1.\\n    y : array\\n        Input array 2.\\n\\n    Returns\\n    -------\\n    z : array\\n        Cross product of x and y.\\n\\n    Notes\\n    -----\\n    x and y must both be 2D row vectors. One must have length 1, or both\\n    lengths must match.\\n    '\n    assert x.ndim == 2\n    assert y.ndim == 2\n    assert x.shape[1] == 3\n    assert y.shape[1] == 3\n    assert (x.shape[0] == 1 or y.shape[0] == 1) or x.shape[0] == y.shape[0]\n    if max([x.shape[0], y.shape[0]]) >= 500:\n        return np.c_[x[:, 1] * y[:, 2] - x[:, 2] * y[:, 1], x[:, 2] * y[:, 0] - x[:, 0] * y[:, 2], x[:, 0] * y[:, 1] - x[:, 1] * y[:, 0]]\n    else:\n        return np.cross(x, y)",
            "def _fast_cross_3d(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute cross product between list of 3D vectors\\n\\n    Much faster than np.cross() when the number of cross products\\n    becomes large (>500). This is because np.cross() methods become\\n    less memory efficient at this stage.\\n\\n    Parameters\\n    ----------\\n    x : array\\n        Input array 1.\\n    y : array\\n        Input array 2.\\n\\n    Returns\\n    -------\\n    z : array\\n        Cross product of x and y.\\n\\n    Notes\\n    -----\\n    x and y must both be 2D row vectors. One must have length 1, or both\\n    lengths must match.\\n    '\n    assert x.ndim == 2\n    assert y.ndim == 2\n    assert x.shape[1] == 3\n    assert y.shape[1] == 3\n    assert (x.shape[0] == 1 or y.shape[0] == 1) or x.shape[0] == y.shape[0]\n    if max([x.shape[0], y.shape[0]]) >= 500:\n        return np.c_[x[:, 1] * y[:, 2] - x[:, 2] * y[:, 1], x[:, 2] * y[:, 0] - x[:, 0] * y[:, 2], x[:, 0] * y[:, 1] - x[:, 1] * y[:, 0]]\n    else:\n        return np.cross(x, y)",
            "def _fast_cross_3d(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute cross product between list of 3D vectors\\n\\n    Much faster than np.cross() when the number of cross products\\n    becomes large (>500). This is because np.cross() methods become\\n    less memory efficient at this stage.\\n\\n    Parameters\\n    ----------\\n    x : array\\n        Input array 1.\\n    y : array\\n        Input array 2.\\n\\n    Returns\\n    -------\\n    z : array\\n        Cross product of x and y.\\n\\n    Notes\\n    -----\\n    x and y must both be 2D row vectors. One must have length 1, or both\\n    lengths must match.\\n    '\n    assert x.ndim == 2\n    assert y.ndim == 2\n    assert x.shape[1] == 3\n    assert y.shape[1] == 3\n    assert (x.shape[0] == 1 or y.shape[0] == 1) or x.shape[0] == y.shape[0]\n    if max([x.shape[0], y.shape[0]]) >= 500:\n        return np.c_[x[:, 1] * y[:, 2] - x[:, 2] * y[:, 1], x[:, 2] * y[:, 0] - x[:, 0] * y[:, 2], x[:, 0] * y[:, 1] - x[:, 1] * y[:, 0]]\n    else:\n        return np.cross(x, y)"
        ]
    },
    {
        "func_name": "_calculate_normals",
        "original": "def _calculate_normals(rr, tris):\n    \"\"\"Efficiently compute vertex normals for triangulated surface\"\"\"\n    rr = rr.astype(np.float64)\n    r1 = rr[tris[:, 0], :]\n    r2 = rr[tris[:, 1], :]\n    r3 = rr[tris[:, 2], :]\n    tri_nn = _fast_cross_3d(r2 - r1, r3 - r1)\n    size = np.sqrt(np.sum(tri_nn * tri_nn, axis=1))\n    size[size == 0] = 1.0\n    tri_nn /= size[:, np.newaxis]\n    npts = len(rr)\n    nn = np.zeros((npts, 3))\n    for verts in tris.T:\n        for idx in range(3):\n            nn[:, idx] += np.bincount(verts.astype(np.int32), tri_nn[:, idx], minlength=npts)\n    size = np.sqrt(np.sum(nn * nn, axis=1))\n    size[size == 0] = 1.0\n    nn /= size[:, np.newaxis]\n    return nn",
        "mutated": [
            "def _calculate_normals(rr, tris):\n    if False:\n        i = 10\n    'Efficiently compute vertex normals for triangulated surface'\n    rr = rr.astype(np.float64)\n    r1 = rr[tris[:, 0], :]\n    r2 = rr[tris[:, 1], :]\n    r3 = rr[tris[:, 2], :]\n    tri_nn = _fast_cross_3d(r2 - r1, r3 - r1)\n    size = np.sqrt(np.sum(tri_nn * tri_nn, axis=1))\n    size[size == 0] = 1.0\n    tri_nn /= size[:, np.newaxis]\n    npts = len(rr)\n    nn = np.zeros((npts, 3))\n    for verts in tris.T:\n        for idx in range(3):\n            nn[:, idx] += np.bincount(verts.astype(np.int32), tri_nn[:, idx], minlength=npts)\n    size = np.sqrt(np.sum(nn * nn, axis=1))\n    size[size == 0] = 1.0\n    nn /= size[:, np.newaxis]\n    return nn",
            "def _calculate_normals(rr, tris):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Efficiently compute vertex normals for triangulated surface'\n    rr = rr.astype(np.float64)\n    r1 = rr[tris[:, 0], :]\n    r2 = rr[tris[:, 1], :]\n    r3 = rr[tris[:, 2], :]\n    tri_nn = _fast_cross_3d(r2 - r1, r3 - r1)\n    size = np.sqrt(np.sum(tri_nn * tri_nn, axis=1))\n    size[size == 0] = 1.0\n    tri_nn /= size[:, np.newaxis]\n    npts = len(rr)\n    nn = np.zeros((npts, 3))\n    for verts in tris.T:\n        for idx in range(3):\n            nn[:, idx] += np.bincount(verts.astype(np.int32), tri_nn[:, idx], minlength=npts)\n    size = np.sqrt(np.sum(nn * nn, axis=1))\n    size[size == 0] = 1.0\n    nn /= size[:, np.newaxis]\n    return nn",
            "def _calculate_normals(rr, tris):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Efficiently compute vertex normals for triangulated surface'\n    rr = rr.astype(np.float64)\n    r1 = rr[tris[:, 0], :]\n    r2 = rr[tris[:, 1], :]\n    r3 = rr[tris[:, 2], :]\n    tri_nn = _fast_cross_3d(r2 - r1, r3 - r1)\n    size = np.sqrt(np.sum(tri_nn * tri_nn, axis=1))\n    size[size == 0] = 1.0\n    tri_nn /= size[:, np.newaxis]\n    npts = len(rr)\n    nn = np.zeros((npts, 3))\n    for verts in tris.T:\n        for idx in range(3):\n            nn[:, idx] += np.bincount(verts.astype(np.int32), tri_nn[:, idx], minlength=npts)\n    size = np.sqrt(np.sum(nn * nn, axis=1))\n    size[size == 0] = 1.0\n    nn /= size[:, np.newaxis]\n    return nn",
            "def _calculate_normals(rr, tris):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Efficiently compute vertex normals for triangulated surface'\n    rr = rr.astype(np.float64)\n    r1 = rr[tris[:, 0], :]\n    r2 = rr[tris[:, 1], :]\n    r3 = rr[tris[:, 2], :]\n    tri_nn = _fast_cross_3d(r2 - r1, r3 - r1)\n    size = np.sqrt(np.sum(tri_nn * tri_nn, axis=1))\n    size[size == 0] = 1.0\n    tri_nn /= size[:, np.newaxis]\n    npts = len(rr)\n    nn = np.zeros((npts, 3))\n    for verts in tris.T:\n        for idx in range(3):\n            nn[:, idx] += np.bincount(verts.astype(np.int32), tri_nn[:, idx], minlength=npts)\n    size = np.sqrt(np.sum(nn * nn, axis=1))\n    size[size == 0] = 1.0\n    nn /= size[:, np.newaxis]\n    return nn",
            "def _calculate_normals(rr, tris):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Efficiently compute vertex normals for triangulated surface'\n    rr = rr.astype(np.float64)\n    r1 = rr[tris[:, 0], :]\n    r2 = rr[tris[:, 1], :]\n    r3 = rr[tris[:, 2], :]\n    tri_nn = _fast_cross_3d(r2 - r1, r3 - r1)\n    size = np.sqrt(np.sum(tri_nn * tri_nn, axis=1))\n    size[size == 0] = 1.0\n    tri_nn /= size[:, np.newaxis]\n    npts = len(rr)\n    nn = np.zeros((npts, 3))\n    for verts in tris.T:\n        for idx in range(3):\n            nn[:, idx] += np.bincount(verts.astype(np.int32), tri_nn[:, idx], minlength=npts)\n    size = np.sqrt(np.sum(nn * nn, axis=1))\n    size[size == 0] = 1.0\n    nn /= size[:, np.newaxis]\n    return nn"
        ]
    },
    {
        "func_name": "resize",
        "original": "def resize(image, shape, kind='linear'):\n    \"\"\"Resize an image\n\n    Parameters\n    ----------\n    image : ndarray\n        Array of shape (N, M, ...).\n    shape : tuple\n        2-element shape.\n    kind : str\n        Interpolation, either \"linear\" or \"nearest\".\n\n    Returns\n    -------\n    scaled_image : ndarray\n        New image, will have dtype np.float64.\n    \"\"\"\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, str) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out",
        "mutated": [
            "def resize(image, shape, kind='linear'):\n    if False:\n        i = 10\n    'Resize an image\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Array of shape (N, M, ...).\\n    shape : tuple\\n        2-element shape.\\n    kind : str\\n        Interpolation, either \"linear\" or \"nearest\".\\n\\n    Returns\\n    -------\\n    scaled_image : ndarray\\n        New image, will have dtype np.float64.\\n    '\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, str) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out",
            "def resize(image, shape, kind='linear'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Resize an image\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Array of shape (N, M, ...).\\n    shape : tuple\\n        2-element shape.\\n    kind : str\\n        Interpolation, either \"linear\" or \"nearest\".\\n\\n    Returns\\n    -------\\n    scaled_image : ndarray\\n        New image, will have dtype np.float64.\\n    '\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, str) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out",
            "def resize(image, shape, kind='linear'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Resize an image\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Array of shape (N, M, ...).\\n    shape : tuple\\n        2-element shape.\\n    kind : str\\n        Interpolation, either \"linear\" or \"nearest\".\\n\\n    Returns\\n    -------\\n    scaled_image : ndarray\\n        New image, will have dtype np.float64.\\n    '\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, str) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out",
            "def resize(image, shape, kind='linear'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Resize an image\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Array of shape (N, M, ...).\\n    shape : tuple\\n        2-element shape.\\n    kind : str\\n        Interpolation, either \"linear\" or \"nearest\".\\n\\n    Returns\\n    -------\\n    scaled_image : ndarray\\n        New image, will have dtype np.float64.\\n    '\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, str) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out",
            "def resize(image, shape, kind='linear'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Resize an image\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        Array of shape (N, M, ...).\\n    shape : tuple\\n        2-element shape.\\n    kind : str\\n        Interpolation, either \"linear\" or \"nearest\".\\n\\n    Returns\\n    -------\\n    scaled_image : ndarray\\n        New image, will have dtype np.float64.\\n    '\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, str) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out"
        ]
    }
]