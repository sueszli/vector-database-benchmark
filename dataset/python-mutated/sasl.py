"""
XMPP-specific SASL profile.
"""
import re
from base64 import b64decode, b64encode
from twisted.internet import defer
from twisted.words.protocols.jabber import sasl_mechanisms, xmlstream
from twisted.words.xish import domish
NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl'

def get_mechanisms(xs):
    if False:
        for i in range(10):
            print('nop')
    '\n    Parse the SASL feature to extract the available mechanism names.\n    '
    mechanisms = []
    for element in xs.features[NS_XMPP_SASL, 'mechanisms'].elements():
        if element.name == 'mechanism':
            mechanisms.append(str(element))
    return mechanisms

class SASLError(Exception):
    """
    SASL base exception.
    """

class SASLNoAcceptableMechanism(SASLError):
    """
    The server did not present an acceptable SASL mechanism.
    """

class SASLAuthError(SASLError):
    """
    SASL Authentication failed.
    """

    def __init__(self, condition=None):
        if False:
            print('Hello World!')
        self.condition = condition

    def __str__(self) -> str:
        if False:
            i = 10
            return i + 15
        return 'SASLAuthError with condition %r' % self.condition

class SASLIncorrectEncodingError(SASLError):
    """
    SASL base64 encoding was incorrect.

    RFC 3920 specifies that any characters not in the base64 alphabet
    and padding characters present elsewhere than at the end of the string
    MUST be rejected. See also L{fromBase64}.

    This exception is raised whenever the encoded string does not adhere
    to these additional restrictions or when the decoding itself fails.

    The recommended behaviour for so-called receiving entities (like servers in
    client-to-server connections, see RFC 3920 for terminology) is to fail the
    SASL negotiation with a C{'incorrect-encoding'} condition. For initiating
    entities, one should assume the receiving entity to be either buggy or
    malevolent. The stream should be terminated and reconnecting is not
    advised.
    """
base64Pattern = re.compile('^[0-9A-Za-z+/]*[0-9A-Za-z+/=]{,2}$')

def fromBase64(s):
    if False:
        for i in range(10):
            print('nop')
    '\n    Decode base64 encoded string.\n\n    This helper performs regular decoding of a base64 encoded string, but also\n    rejects any characters that are not in the base64 alphabet and padding\n    occurring elsewhere from the last or last two characters, as specified in\n    section 14.9 of RFC 3920. This safeguards against various attack vectors\n    among which the creation of a covert channel that "leaks" information.\n    '
    if base64Pattern.match(s) is None:
        raise SASLIncorrectEncodingError()
    try:
        return b64decode(s)
    except Exception as e:
        raise SASLIncorrectEncodingError(str(e))

class SASLInitiatingInitializer(xmlstream.BaseFeatureInitiatingInitializer):
    """
    Stream initializer that performs SASL authentication.

    The supported mechanisms by this initializer are C{DIGEST-MD5}, C{PLAIN}
    and C{ANONYMOUS}. The C{ANONYMOUS} SASL mechanism is used when the JID, set
    on the authenticator, does not have a localpart (username), requesting an
    anonymous session where the username is generated by the server.
    Otherwise, C{DIGEST-MD5} and C{PLAIN} are attempted, in that order.
    """
    feature = (NS_XMPP_SASL, 'mechanisms')
    _deferred = None

    def setMechanism(self):
        if False:
            print('Hello World!')
        "\n        Select and setup authentication mechanism.\n\n        Uses the authenticator's C{jid} and C{password} attribute for the\n        authentication credentials. If no supported SASL mechanisms are\n        advertized by the receiving party, a failing deferred is returned with\n        a L{SASLNoAcceptableMechanism} exception.\n        "
        jid = self.xmlstream.authenticator.jid
        password = self.xmlstream.authenticator.password
        mechanisms = get_mechanisms(self.xmlstream)
        if jid.user is not None:
            if 'DIGEST-MD5' in mechanisms:
                self.mechanism = sasl_mechanisms.DigestMD5('xmpp', jid.host, None, jid.user, password)
            elif 'PLAIN' in mechanisms:
                self.mechanism = sasl_mechanisms.Plain(None, jid.user, password)
            else:
                raise SASLNoAcceptableMechanism()
        elif 'ANONYMOUS' in mechanisms:
            self.mechanism = sasl_mechanisms.Anonymous()
        else:
            raise SASLNoAcceptableMechanism()

    def start(self):
        if False:
            return 10
        '\n        Start SASL authentication exchange.\n        '
        self.setMechanism()
        self._deferred = defer.Deferred()
        self.xmlstream.addObserver('/challenge', self.onChallenge)
        self.xmlstream.addOnetimeObserver('/success', self.onSuccess)
        self.xmlstream.addOnetimeObserver('/failure', self.onFailure)
        self.sendAuth(self.mechanism.getInitialResponse())
        return self._deferred

    def sendAuth(self, data=None):
        if False:
            print('Hello World!')
        '\n        Initiate authentication protocol exchange.\n\n        If an initial client response is given in C{data}, it will be\n        sent along.\n\n        @param data: initial client response.\n        @type data: C{str} or L{None}.\n        '
        auth = domish.Element((NS_XMPP_SASL, 'auth'))
        auth['mechanism'] = self.mechanism.name
        if data is not None:
            auth.addContent(b64encode(data).decode('ascii') or '=')
        self.xmlstream.send(auth)

    def sendResponse(self, data=b''):
        if False:
            while True:
                i = 10
        '\n        Send response to a challenge.\n\n        @param data: client response.\n        @type data: L{bytes}.\n        '
        response = domish.Element((NS_XMPP_SASL, 'response'))
        if data:
            response.addContent(b64encode(data).decode('ascii'))
        self.xmlstream.send(response)

    def onChallenge(self, element):
        if False:
            print('Hello World!')
        '\n        Parse challenge and send response from the mechanism.\n\n        @param element: the challenge protocol element.\n        @type element: L{domish.Element}.\n        '
        try:
            challenge = fromBase64(str(element))
        except SASLIncorrectEncodingError:
            self._deferred.errback()
        else:
            self.sendResponse(self.mechanism.getResponse(challenge))

    def onSuccess(self, success):
        if False:
            for i in range(10):
                print('nop')
        '\n        Clean up observers, reset the XML stream and send a new header.\n\n        @param success: the success protocol element. For now unused, but\n                        could hold additional data.\n        @type success: L{domish.Element}\n        '
        self.xmlstream.removeObserver('/challenge', self.onChallenge)
        self.xmlstream.removeObserver('/failure', self.onFailure)
        self.xmlstream.reset()
        self.xmlstream.sendHeader()
        self._deferred.callback(xmlstream.Reset)

    def onFailure(self, failure):
        if False:
            print('Hello World!')
        '\n        Clean up observers, parse the failure and errback the deferred.\n\n        @param failure: the failure protocol element. Holds details on\n                        the error condition.\n        @type failure: L{domish.Element}\n        '
        self.xmlstream.removeObserver('/challenge', self.onChallenge)
        self.xmlstream.removeObserver('/success', self.onSuccess)
        try:
            condition = failure.firstChildElement().name
        except AttributeError:
            condition = None
        self._deferred.errback(SASLAuthError(condition))