[
    {
        "func_name": "__init__",
        "original": "def __init__(self, Run_Name):\n    self.Run_Name = Run_Name\n    self.input_data()\n    self.write_ini()",
        "mutated": [
            "def __init__(self, Run_Name):\n    if False:\n        i = 10\n    self.Run_Name = Run_Name\n    self.input_data()\n    self.write_ini()",
            "def __init__(self, Run_Name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.Run_Name = Run_Name\n    self.input_data()\n    self.write_ini()",
            "def __init__(self, Run_Name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.Run_Name = Run_Name\n    self.input_data()\n    self.write_ini()",
            "def __init__(self, Run_Name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.Run_Name = Run_Name\n    self.input_data()\n    self.write_ini()",
            "def __init__(self, Run_Name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.Run_Name = Run_Name\n    self.input_data()\n    self.write_ini()"
        ]
    },
    {
        "func_name": "input_data",
        "original": "def input_data(self):\n    info_run_file = 'input/' + str(self.Run_Name) + '/run.info'\n    if os.path.exists(info_run_file):\n        read_info_file = open(info_run_file, 'r')\n        lines_of_the_file = read_info_file.readlines()\n        self.option_map = lines_of_the_file[1].split('\\t')[1]\n        lines_of_the_file = [x.strip('L\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\r\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\n') for x in lines_of_the_file]\n        if self.option_map == 'yes':\n            self.ll_lon = lines_of_the_file[2].split('\\t')[1]\n            self.ll_lat = lines_of_the_file[2].split('\\t')[2]\n            self.lr_lon = lines_of_the_file[2].split('\\t')[3]\n            self.lr_lat = lines_of_the_file[2].split('\\t')[4]\n            self.ur_lon = lines_of_the_file[2].split('\\t')[5]\n            self.ur_lat = lines_of_the_file[2].split('\\t')[6]\n            self.ul_lon = lines_of_the_file[2].split('\\t')[7]\n            self.ul_lat = lines_of_the_file[2].split('\\t')[8]\n            self.region_grid_spacing = lines_of_the_file[3].split('\\t')[1]\n        else:\n            self.Longitude = lines_of_the_file[2].split('\\t')[1]\n            self.Latitude = lines_of_the_file[3].split('\\t')[1]\n        self.Vs30 = lines_of_the_file[4].split('\\t')[1]\n        self.Z1000 = lines_of_the_file[5].split('\\t')[1]\n        self.Z2500 = lines_of_the_file[6].split('\\t')[1]\n        self.nb_LT_samp = lines_of_the_file[7].split('\\t')[1]\n        self.rup_mesh = lines_of_the_file[8].split('\\t')[1]\n        self.source_discr = lines_of_the_file[9].split('\\t')[1]\n        self.investigation_time = lines_of_the_file[10].split('\\t')[1]\n        self.poes = lines_of_the_file[11].split('\\t')[1]\n        self.trunc_lvl = lines_of_the_file[12].split('\\t')[1]\n        self.max_dist = lines_of_the_file[13].split('\\t')[1]\n        self.nb_sample = int(lines_of_the_file[14].split('\\t')[1])\n        self.Mmin = float(lines_of_the_file[15].split('\\t')[1])\n        self.seed = int(lines_of_the_file[16].split('\\t')[1])\n        self.sr_correl = lines_of_the_file[17].split('\\t')[1]\n        if self.sr_correl == 'yes' or self.sr_correl == 'Yes' or self.sr_correl == 'True' or (self.sr_correl == 'true'):\n            self.sr_correl = True\n        else:\n            self.sr_correl = False\n        self.size_of_increment = float(lines_of_the_file[18].split('\\t')[1])\n        self.Mmax_range = [float(lines_of_the_file[19].split('\\t')[1]), float(lines_of_the_file[19].split('\\t')[2])]\n        self.intensity_out = []\n        self.min_int_out = []\n        self.max_int_out = []\n        self.nb_int_out = []\n        for line in lines_of_the_file[20:]:\n            self.intensity_out.append(line.split('\\t')[1])\n            self.min_int_out.append(float(line.split('\\t')[2]))\n            self.max_int_out.append(float(line.split('\\t')[3]))\n            self.nb_int_out.append(int(line.split('\\t')[4]))\n        read_info_file.close()\n    else:\n        print('ERROR : File run.info not found! \\n Please refer to the user manual')\n        exit()",
        "mutated": [
            "def input_data(self):\n    if False:\n        i = 10\n    info_run_file = 'input/' + str(self.Run_Name) + '/run.info'\n    if os.path.exists(info_run_file):\n        read_info_file = open(info_run_file, 'r')\n        lines_of_the_file = read_info_file.readlines()\n        self.option_map = lines_of_the_file[1].split('\\t')[1]\n        lines_of_the_file = [x.strip('L\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\r\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\n') for x in lines_of_the_file]\n        if self.option_map == 'yes':\n            self.ll_lon = lines_of_the_file[2].split('\\t')[1]\n            self.ll_lat = lines_of_the_file[2].split('\\t')[2]\n            self.lr_lon = lines_of_the_file[2].split('\\t')[3]\n            self.lr_lat = lines_of_the_file[2].split('\\t')[4]\n            self.ur_lon = lines_of_the_file[2].split('\\t')[5]\n            self.ur_lat = lines_of_the_file[2].split('\\t')[6]\n            self.ul_lon = lines_of_the_file[2].split('\\t')[7]\n            self.ul_lat = lines_of_the_file[2].split('\\t')[8]\n            self.region_grid_spacing = lines_of_the_file[3].split('\\t')[1]\n        else:\n            self.Longitude = lines_of_the_file[2].split('\\t')[1]\n            self.Latitude = lines_of_the_file[3].split('\\t')[1]\n        self.Vs30 = lines_of_the_file[4].split('\\t')[1]\n        self.Z1000 = lines_of_the_file[5].split('\\t')[1]\n        self.Z2500 = lines_of_the_file[6].split('\\t')[1]\n        self.nb_LT_samp = lines_of_the_file[7].split('\\t')[1]\n        self.rup_mesh = lines_of_the_file[8].split('\\t')[1]\n        self.source_discr = lines_of_the_file[9].split('\\t')[1]\n        self.investigation_time = lines_of_the_file[10].split('\\t')[1]\n        self.poes = lines_of_the_file[11].split('\\t')[1]\n        self.trunc_lvl = lines_of_the_file[12].split('\\t')[1]\n        self.max_dist = lines_of_the_file[13].split('\\t')[1]\n        self.nb_sample = int(lines_of_the_file[14].split('\\t')[1])\n        self.Mmin = float(lines_of_the_file[15].split('\\t')[1])\n        self.seed = int(lines_of_the_file[16].split('\\t')[1])\n        self.sr_correl = lines_of_the_file[17].split('\\t')[1]\n        if self.sr_correl == 'yes' or self.sr_correl == 'Yes' or self.sr_correl == 'True' or (self.sr_correl == 'true'):\n            self.sr_correl = True\n        else:\n            self.sr_correl = False\n        self.size_of_increment = float(lines_of_the_file[18].split('\\t')[1])\n        self.Mmax_range = [float(lines_of_the_file[19].split('\\t')[1]), float(lines_of_the_file[19].split('\\t')[2])]\n        self.intensity_out = []\n        self.min_int_out = []\n        self.max_int_out = []\n        self.nb_int_out = []\n        for line in lines_of_the_file[20:]:\n            self.intensity_out.append(line.split('\\t')[1])\n            self.min_int_out.append(float(line.split('\\t')[2]))\n            self.max_int_out.append(float(line.split('\\t')[3]))\n            self.nb_int_out.append(int(line.split('\\t')[4]))\n        read_info_file.close()\n    else:\n        print('ERROR : File run.info not found! \\n Please refer to the user manual')\n        exit()",
            "def input_data(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    info_run_file = 'input/' + str(self.Run_Name) + '/run.info'\n    if os.path.exists(info_run_file):\n        read_info_file = open(info_run_file, 'r')\n        lines_of_the_file = read_info_file.readlines()\n        self.option_map = lines_of_the_file[1].split('\\t')[1]\n        lines_of_the_file = [x.strip('L\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\r\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\n') for x in lines_of_the_file]\n        if self.option_map == 'yes':\n            self.ll_lon = lines_of_the_file[2].split('\\t')[1]\n            self.ll_lat = lines_of_the_file[2].split('\\t')[2]\n            self.lr_lon = lines_of_the_file[2].split('\\t')[3]\n            self.lr_lat = lines_of_the_file[2].split('\\t')[4]\n            self.ur_lon = lines_of_the_file[2].split('\\t')[5]\n            self.ur_lat = lines_of_the_file[2].split('\\t')[6]\n            self.ul_lon = lines_of_the_file[2].split('\\t')[7]\n            self.ul_lat = lines_of_the_file[2].split('\\t')[8]\n            self.region_grid_spacing = lines_of_the_file[3].split('\\t')[1]\n        else:\n            self.Longitude = lines_of_the_file[2].split('\\t')[1]\n            self.Latitude = lines_of_the_file[3].split('\\t')[1]\n        self.Vs30 = lines_of_the_file[4].split('\\t')[1]\n        self.Z1000 = lines_of_the_file[5].split('\\t')[1]\n        self.Z2500 = lines_of_the_file[6].split('\\t')[1]\n        self.nb_LT_samp = lines_of_the_file[7].split('\\t')[1]\n        self.rup_mesh = lines_of_the_file[8].split('\\t')[1]\n        self.source_discr = lines_of_the_file[9].split('\\t')[1]\n        self.investigation_time = lines_of_the_file[10].split('\\t')[1]\n        self.poes = lines_of_the_file[11].split('\\t')[1]\n        self.trunc_lvl = lines_of_the_file[12].split('\\t')[1]\n        self.max_dist = lines_of_the_file[13].split('\\t')[1]\n        self.nb_sample = int(lines_of_the_file[14].split('\\t')[1])\n        self.Mmin = float(lines_of_the_file[15].split('\\t')[1])\n        self.seed = int(lines_of_the_file[16].split('\\t')[1])\n        self.sr_correl = lines_of_the_file[17].split('\\t')[1]\n        if self.sr_correl == 'yes' or self.sr_correl == 'Yes' or self.sr_correl == 'True' or (self.sr_correl == 'true'):\n            self.sr_correl = True\n        else:\n            self.sr_correl = False\n        self.size_of_increment = float(lines_of_the_file[18].split('\\t')[1])\n        self.Mmax_range = [float(lines_of_the_file[19].split('\\t')[1]), float(lines_of_the_file[19].split('\\t')[2])]\n        self.intensity_out = []\n        self.min_int_out = []\n        self.max_int_out = []\n        self.nb_int_out = []\n        for line in lines_of_the_file[20:]:\n            self.intensity_out.append(line.split('\\t')[1])\n            self.min_int_out.append(float(line.split('\\t')[2]))\n            self.max_int_out.append(float(line.split('\\t')[3]))\n            self.nb_int_out.append(int(line.split('\\t')[4]))\n        read_info_file.close()\n    else:\n        print('ERROR : File run.info not found! \\n Please refer to the user manual')\n        exit()",
            "def input_data(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    info_run_file = 'input/' + str(self.Run_Name) + '/run.info'\n    if os.path.exists(info_run_file):\n        read_info_file = open(info_run_file, 'r')\n        lines_of_the_file = read_info_file.readlines()\n        self.option_map = lines_of_the_file[1].split('\\t')[1]\n        lines_of_the_file = [x.strip('L\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\r\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\n') for x in lines_of_the_file]\n        if self.option_map == 'yes':\n            self.ll_lon = lines_of_the_file[2].split('\\t')[1]\n            self.ll_lat = lines_of_the_file[2].split('\\t')[2]\n            self.lr_lon = lines_of_the_file[2].split('\\t')[3]\n            self.lr_lat = lines_of_the_file[2].split('\\t')[4]\n            self.ur_lon = lines_of_the_file[2].split('\\t')[5]\n            self.ur_lat = lines_of_the_file[2].split('\\t')[6]\n            self.ul_lon = lines_of_the_file[2].split('\\t')[7]\n            self.ul_lat = lines_of_the_file[2].split('\\t')[8]\n            self.region_grid_spacing = lines_of_the_file[3].split('\\t')[1]\n        else:\n            self.Longitude = lines_of_the_file[2].split('\\t')[1]\n            self.Latitude = lines_of_the_file[3].split('\\t')[1]\n        self.Vs30 = lines_of_the_file[4].split('\\t')[1]\n        self.Z1000 = lines_of_the_file[5].split('\\t')[1]\n        self.Z2500 = lines_of_the_file[6].split('\\t')[1]\n        self.nb_LT_samp = lines_of_the_file[7].split('\\t')[1]\n        self.rup_mesh = lines_of_the_file[8].split('\\t')[1]\n        self.source_discr = lines_of_the_file[9].split('\\t')[1]\n        self.investigation_time = lines_of_the_file[10].split('\\t')[1]\n        self.poes = lines_of_the_file[11].split('\\t')[1]\n        self.trunc_lvl = lines_of_the_file[12].split('\\t')[1]\n        self.max_dist = lines_of_the_file[13].split('\\t')[1]\n        self.nb_sample = int(lines_of_the_file[14].split('\\t')[1])\n        self.Mmin = float(lines_of_the_file[15].split('\\t')[1])\n        self.seed = int(lines_of_the_file[16].split('\\t')[1])\n        self.sr_correl = lines_of_the_file[17].split('\\t')[1]\n        if self.sr_correl == 'yes' or self.sr_correl == 'Yes' or self.sr_correl == 'True' or (self.sr_correl == 'true'):\n            self.sr_correl = True\n        else:\n            self.sr_correl = False\n        self.size_of_increment = float(lines_of_the_file[18].split('\\t')[1])\n        self.Mmax_range = [float(lines_of_the_file[19].split('\\t')[1]), float(lines_of_the_file[19].split('\\t')[2])]\n        self.intensity_out = []\n        self.min_int_out = []\n        self.max_int_out = []\n        self.nb_int_out = []\n        for line in lines_of_the_file[20:]:\n            self.intensity_out.append(line.split('\\t')[1])\n            self.min_int_out.append(float(line.split('\\t')[2]))\n            self.max_int_out.append(float(line.split('\\t')[3]))\n            self.nb_int_out.append(int(line.split('\\t')[4]))\n        read_info_file.close()\n    else:\n        print('ERROR : File run.info not found! \\n Please refer to the user manual')\n        exit()",
            "def input_data(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    info_run_file = 'input/' + str(self.Run_Name) + '/run.info'\n    if os.path.exists(info_run_file):\n        read_info_file = open(info_run_file, 'r')\n        lines_of_the_file = read_info_file.readlines()\n        self.option_map = lines_of_the_file[1].split('\\t')[1]\n        lines_of_the_file = [x.strip('L\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\r\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\n') for x in lines_of_the_file]\n        if self.option_map == 'yes':\n            self.ll_lon = lines_of_the_file[2].split('\\t')[1]\n            self.ll_lat = lines_of_the_file[2].split('\\t')[2]\n            self.lr_lon = lines_of_the_file[2].split('\\t')[3]\n            self.lr_lat = lines_of_the_file[2].split('\\t')[4]\n            self.ur_lon = lines_of_the_file[2].split('\\t')[5]\n            self.ur_lat = lines_of_the_file[2].split('\\t')[6]\n            self.ul_lon = lines_of_the_file[2].split('\\t')[7]\n            self.ul_lat = lines_of_the_file[2].split('\\t')[8]\n            self.region_grid_spacing = lines_of_the_file[3].split('\\t')[1]\n        else:\n            self.Longitude = lines_of_the_file[2].split('\\t')[1]\n            self.Latitude = lines_of_the_file[3].split('\\t')[1]\n        self.Vs30 = lines_of_the_file[4].split('\\t')[1]\n        self.Z1000 = lines_of_the_file[5].split('\\t')[1]\n        self.Z2500 = lines_of_the_file[6].split('\\t')[1]\n        self.nb_LT_samp = lines_of_the_file[7].split('\\t')[1]\n        self.rup_mesh = lines_of_the_file[8].split('\\t')[1]\n        self.source_discr = lines_of_the_file[9].split('\\t')[1]\n        self.investigation_time = lines_of_the_file[10].split('\\t')[1]\n        self.poes = lines_of_the_file[11].split('\\t')[1]\n        self.trunc_lvl = lines_of_the_file[12].split('\\t')[1]\n        self.max_dist = lines_of_the_file[13].split('\\t')[1]\n        self.nb_sample = int(lines_of_the_file[14].split('\\t')[1])\n        self.Mmin = float(lines_of_the_file[15].split('\\t')[1])\n        self.seed = int(lines_of_the_file[16].split('\\t')[1])\n        self.sr_correl = lines_of_the_file[17].split('\\t')[1]\n        if self.sr_correl == 'yes' or self.sr_correl == 'Yes' or self.sr_correl == 'True' or (self.sr_correl == 'true'):\n            self.sr_correl = True\n        else:\n            self.sr_correl = False\n        self.size_of_increment = float(lines_of_the_file[18].split('\\t')[1])\n        self.Mmax_range = [float(lines_of_the_file[19].split('\\t')[1]), float(lines_of_the_file[19].split('\\t')[2])]\n        self.intensity_out = []\n        self.min_int_out = []\n        self.max_int_out = []\n        self.nb_int_out = []\n        for line in lines_of_the_file[20:]:\n            self.intensity_out.append(line.split('\\t')[1])\n            self.min_int_out.append(float(line.split('\\t')[2]))\n            self.max_int_out.append(float(line.split('\\t')[3]))\n            self.nb_int_out.append(int(line.split('\\t')[4]))\n        read_info_file.close()\n    else:\n        print('ERROR : File run.info not found! \\n Please refer to the user manual')\n        exit()",
            "def input_data(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    info_run_file = 'input/' + str(self.Run_Name) + '/run.info'\n    if os.path.exists(info_run_file):\n        read_info_file = open(info_run_file, 'r')\n        lines_of_the_file = read_info_file.readlines()\n        self.option_map = lines_of_the_file[1].split('\\t')[1]\n        lines_of_the_file = [x.strip('L\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\r\\n') for x in lines_of_the_file]\n        lines_of_the_file = [x.strip('\\n') for x in lines_of_the_file]\n        if self.option_map == 'yes':\n            self.ll_lon = lines_of_the_file[2].split('\\t')[1]\n            self.ll_lat = lines_of_the_file[2].split('\\t')[2]\n            self.lr_lon = lines_of_the_file[2].split('\\t')[3]\n            self.lr_lat = lines_of_the_file[2].split('\\t')[4]\n            self.ur_lon = lines_of_the_file[2].split('\\t')[5]\n            self.ur_lat = lines_of_the_file[2].split('\\t')[6]\n            self.ul_lon = lines_of_the_file[2].split('\\t')[7]\n            self.ul_lat = lines_of_the_file[2].split('\\t')[8]\n            self.region_grid_spacing = lines_of_the_file[3].split('\\t')[1]\n        else:\n            self.Longitude = lines_of_the_file[2].split('\\t')[1]\n            self.Latitude = lines_of_the_file[3].split('\\t')[1]\n        self.Vs30 = lines_of_the_file[4].split('\\t')[1]\n        self.Z1000 = lines_of_the_file[5].split('\\t')[1]\n        self.Z2500 = lines_of_the_file[6].split('\\t')[1]\n        self.nb_LT_samp = lines_of_the_file[7].split('\\t')[1]\n        self.rup_mesh = lines_of_the_file[8].split('\\t')[1]\n        self.source_discr = lines_of_the_file[9].split('\\t')[1]\n        self.investigation_time = lines_of_the_file[10].split('\\t')[1]\n        self.poes = lines_of_the_file[11].split('\\t')[1]\n        self.trunc_lvl = lines_of_the_file[12].split('\\t')[1]\n        self.max_dist = lines_of_the_file[13].split('\\t')[1]\n        self.nb_sample = int(lines_of_the_file[14].split('\\t')[1])\n        self.Mmin = float(lines_of_the_file[15].split('\\t')[1])\n        self.seed = int(lines_of_the_file[16].split('\\t')[1])\n        self.sr_correl = lines_of_the_file[17].split('\\t')[1]\n        if self.sr_correl == 'yes' or self.sr_correl == 'Yes' or self.sr_correl == 'True' or (self.sr_correl == 'true'):\n            self.sr_correl = True\n        else:\n            self.sr_correl = False\n        self.size_of_increment = float(lines_of_the_file[18].split('\\t')[1])\n        self.Mmax_range = [float(lines_of_the_file[19].split('\\t')[1]), float(lines_of_the_file[19].split('\\t')[2])]\n        self.intensity_out = []\n        self.min_int_out = []\n        self.max_int_out = []\n        self.nb_int_out = []\n        for line in lines_of_the_file[20:]:\n            self.intensity_out.append(line.split('\\t')[1])\n            self.min_int_out.append(float(line.split('\\t')[2]))\n            self.max_int_out.append(float(line.split('\\t')[3]))\n            self.nb_int_out.append(int(line.split('\\t')[4]))\n        read_info_file.close()\n    else:\n        print('ERROR : File run.info not found! \\n Please refer to the user manual')\n        exit()"
        ]
    },
    {
        "func_name": "write_ini",
        "original": "def write_ini(self):\n    jobfile = open(str(self.Run_Name) + '/job.ini', 'w')\n    Ligne = '[general]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = \"description = '\" + str(self.Run_Name) + \"'\\n\"\n    jobfile.write(Ligne)\n    Ligne = 'calculation_mode = classical\\n'\n    jobfile.write(Ligne)\n    Ligne = 'random_seed = ' + str(self.seed) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[geometry]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    if self.option_map == 'yes':\n        jobfile.write(Ligne)\n        Ligne = 'region = ' + str(self.ll_lon) + ' ' + str(self.ll_lat) + ', ' + str(self.lr_lon) + ' ' + str(self.lr_lat) + ', ' + str(self.ur_lon) + ' ' + str(self.ur_lat) + ', ' + str(self.ul_lon) + ' ' + str(self.ul_lat) + '\\n'\n        jobfile.write(Ligne)\n        Ligne = 'region_grid_spacing = ' + str(self.region_grid_spacing) + '\\n'\n    else:\n        jobfile.write(Ligne)\n        Ligne = 'sites = ' + str(self.Longitude)[:-1] + ' ' + str(self.Latitude) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[logic_tree]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'number_of_logic_tree_samples = ' + str(self.nb_LT_samp) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[erf]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'rupture_mesh_spacing =' + str(self.rup_mesh) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'width_of_mfd_bin = 0.1\\n'\n    jobfile.write(Ligne)\n    Ligne = 'area_source_discretization = ' + str(self.source_discr) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[site_params]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_type = measured\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_value = ' + str(self.Vs30) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_2pt5km_per_sec = ' + str(self.Z2500) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_1pt0km_per_sec = ' + str(self.Z1000) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[calculation]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'source_model_logic_tree_file = Sources_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'gsim_logic_tree_file = GMPE_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'investigation_time = ' + str(self.investigation_time) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'intensity_measure_types_and_levels = {'\n    jobfile.write(Ligne)\n    intensities_done = []\n    for i in range(len(self.intensity_out)):\n        Ligne_1 = '\"' + str(self.intensity_out[i]) + '\": ['\n        array_ints = np.logspace(np.log10(self.min_int_out[i]), np.log10(self.max_int_out[i]), self.nb_int_out[i])\n        Ligne_2 = ''\n        for values in array_ints:\n            if len(Ligne_2) > 1:\n                Ligne_2 += ', '\n            Ligne_2 += str(values)\n        if not self.intensity_out[i] in intensities_done:\n            if len(intensities_done) != 0:\n                jobfile.write(', ')\n            jobfile.write(Ligne_1 + Ligne_2 + ']')\n        intensities_done.append(self.intensity_out[i])\n    Ligne = '}\\n'\n    jobfile.write(Ligne)\n    Ligne = 'truncation_level = ' + str(self.trunc_lvl) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'maximum_distance = ' + str(self.max_dist) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[output]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'export_dir =  ./results\\n'\n    jobfile.write(Ligne)\n    Ligne = 'mean_hazard_curves = true\\n'\n    jobfile.write(Ligne)\n    Ligne = 'quantile_hazard_curves =\\n'\n    jobfile.write(Ligne)\n    Ligne = 'uniform_hazard_spectra = false\\n'\n    jobfile.write(Ligne)\n    Ligne = 'poes = ' + str(self.poes) + '\\n'\n    jobfile.write(Ligne)",
        "mutated": [
            "def write_ini(self):\n    if False:\n        i = 10\n    jobfile = open(str(self.Run_Name) + '/job.ini', 'w')\n    Ligne = '[general]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = \"description = '\" + str(self.Run_Name) + \"'\\n\"\n    jobfile.write(Ligne)\n    Ligne = 'calculation_mode = classical\\n'\n    jobfile.write(Ligne)\n    Ligne = 'random_seed = ' + str(self.seed) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[geometry]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    if self.option_map == 'yes':\n        jobfile.write(Ligne)\n        Ligne = 'region = ' + str(self.ll_lon) + ' ' + str(self.ll_lat) + ', ' + str(self.lr_lon) + ' ' + str(self.lr_lat) + ', ' + str(self.ur_lon) + ' ' + str(self.ur_lat) + ', ' + str(self.ul_lon) + ' ' + str(self.ul_lat) + '\\n'\n        jobfile.write(Ligne)\n        Ligne = 'region_grid_spacing = ' + str(self.region_grid_spacing) + '\\n'\n    else:\n        jobfile.write(Ligne)\n        Ligne = 'sites = ' + str(self.Longitude)[:-1] + ' ' + str(self.Latitude) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[logic_tree]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'number_of_logic_tree_samples = ' + str(self.nb_LT_samp) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[erf]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'rupture_mesh_spacing =' + str(self.rup_mesh) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'width_of_mfd_bin = 0.1\\n'\n    jobfile.write(Ligne)\n    Ligne = 'area_source_discretization = ' + str(self.source_discr) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[site_params]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_type = measured\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_value = ' + str(self.Vs30) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_2pt5km_per_sec = ' + str(self.Z2500) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_1pt0km_per_sec = ' + str(self.Z1000) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[calculation]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'source_model_logic_tree_file = Sources_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'gsim_logic_tree_file = GMPE_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'investigation_time = ' + str(self.investigation_time) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'intensity_measure_types_and_levels = {'\n    jobfile.write(Ligne)\n    intensities_done = []\n    for i in range(len(self.intensity_out)):\n        Ligne_1 = '\"' + str(self.intensity_out[i]) + '\": ['\n        array_ints = np.logspace(np.log10(self.min_int_out[i]), np.log10(self.max_int_out[i]), self.nb_int_out[i])\n        Ligne_2 = ''\n        for values in array_ints:\n            if len(Ligne_2) > 1:\n                Ligne_2 += ', '\n            Ligne_2 += str(values)\n        if not self.intensity_out[i] in intensities_done:\n            if len(intensities_done) != 0:\n                jobfile.write(', ')\n            jobfile.write(Ligne_1 + Ligne_2 + ']')\n        intensities_done.append(self.intensity_out[i])\n    Ligne = '}\\n'\n    jobfile.write(Ligne)\n    Ligne = 'truncation_level = ' + str(self.trunc_lvl) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'maximum_distance = ' + str(self.max_dist) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[output]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'export_dir =  ./results\\n'\n    jobfile.write(Ligne)\n    Ligne = 'mean_hazard_curves = true\\n'\n    jobfile.write(Ligne)\n    Ligne = 'quantile_hazard_curves =\\n'\n    jobfile.write(Ligne)\n    Ligne = 'uniform_hazard_spectra = false\\n'\n    jobfile.write(Ligne)\n    Ligne = 'poes = ' + str(self.poes) + '\\n'\n    jobfile.write(Ligne)",
            "def write_ini(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    jobfile = open(str(self.Run_Name) + '/job.ini', 'w')\n    Ligne = '[general]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = \"description = '\" + str(self.Run_Name) + \"'\\n\"\n    jobfile.write(Ligne)\n    Ligne = 'calculation_mode = classical\\n'\n    jobfile.write(Ligne)\n    Ligne = 'random_seed = ' + str(self.seed) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[geometry]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    if self.option_map == 'yes':\n        jobfile.write(Ligne)\n        Ligne = 'region = ' + str(self.ll_lon) + ' ' + str(self.ll_lat) + ', ' + str(self.lr_lon) + ' ' + str(self.lr_lat) + ', ' + str(self.ur_lon) + ' ' + str(self.ur_lat) + ', ' + str(self.ul_lon) + ' ' + str(self.ul_lat) + '\\n'\n        jobfile.write(Ligne)\n        Ligne = 'region_grid_spacing = ' + str(self.region_grid_spacing) + '\\n'\n    else:\n        jobfile.write(Ligne)\n        Ligne = 'sites = ' + str(self.Longitude)[:-1] + ' ' + str(self.Latitude) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[logic_tree]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'number_of_logic_tree_samples = ' + str(self.nb_LT_samp) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[erf]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'rupture_mesh_spacing =' + str(self.rup_mesh) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'width_of_mfd_bin = 0.1\\n'\n    jobfile.write(Ligne)\n    Ligne = 'area_source_discretization = ' + str(self.source_discr) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[site_params]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_type = measured\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_value = ' + str(self.Vs30) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_2pt5km_per_sec = ' + str(self.Z2500) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_1pt0km_per_sec = ' + str(self.Z1000) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[calculation]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'source_model_logic_tree_file = Sources_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'gsim_logic_tree_file = GMPE_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'investigation_time = ' + str(self.investigation_time) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'intensity_measure_types_and_levels = {'\n    jobfile.write(Ligne)\n    intensities_done = []\n    for i in range(len(self.intensity_out)):\n        Ligne_1 = '\"' + str(self.intensity_out[i]) + '\": ['\n        array_ints = np.logspace(np.log10(self.min_int_out[i]), np.log10(self.max_int_out[i]), self.nb_int_out[i])\n        Ligne_2 = ''\n        for values in array_ints:\n            if len(Ligne_2) > 1:\n                Ligne_2 += ', '\n            Ligne_2 += str(values)\n        if not self.intensity_out[i] in intensities_done:\n            if len(intensities_done) != 0:\n                jobfile.write(', ')\n            jobfile.write(Ligne_1 + Ligne_2 + ']')\n        intensities_done.append(self.intensity_out[i])\n    Ligne = '}\\n'\n    jobfile.write(Ligne)\n    Ligne = 'truncation_level = ' + str(self.trunc_lvl) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'maximum_distance = ' + str(self.max_dist) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[output]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'export_dir =  ./results\\n'\n    jobfile.write(Ligne)\n    Ligne = 'mean_hazard_curves = true\\n'\n    jobfile.write(Ligne)\n    Ligne = 'quantile_hazard_curves =\\n'\n    jobfile.write(Ligne)\n    Ligne = 'uniform_hazard_spectra = false\\n'\n    jobfile.write(Ligne)\n    Ligne = 'poes = ' + str(self.poes) + '\\n'\n    jobfile.write(Ligne)",
            "def write_ini(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    jobfile = open(str(self.Run_Name) + '/job.ini', 'w')\n    Ligne = '[general]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = \"description = '\" + str(self.Run_Name) + \"'\\n\"\n    jobfile.write(Ligne)\n    Ligne = 'calculation_mode = classical\\n'\n    jobfile.write(Ligne)\n    Ligne = 'random_seed = ' + str(self.seed) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[geometry]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    if self.option_map == 'yes':\n        jobfile.write(Ligne)\n        Ligne = 'region = ' + str(self.ll_lon) + ' ' + str(self.ll_lat) + ', ' + str(self.lr_lon) + ' ' + str(self.lr_lat) + ', ' + str(self.ur_lon) + ' ' + str(self.ur_lat) + ', ' + str(self.ul_lon) + ' ' + str(self.ul_lat) + '\\n'\n        jobfile.write(Ligne)\n        Ligne = 'region_grid_spacing = ' + str(self.region_grid_spacing) + '\\n'\n    else:\n        jobfile.write(Ligne)\n        Ligne = 'sites = ' + str(self.Longitude)[:-1] + ' ' + str(self.Latitude) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[logic_tree]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'number_of_logic_tree_samples = ' + str(self.nb_LT_samp) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[erf]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'rupture_mesh_spacing =' + str(self.rup_mesh) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'width_of_mfd_bin = 0.1\\n'\n    jobfile.write(Ligne)\n    Ligne = 'area_source_discretization = ' + str(self.source_discr) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[site_params]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_type = measured\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_value = ' + str(self.Vs30) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_2pt5km_per_sec = ' + str(self.Z2500) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_1pt0km_per_sec = ' + str(self.Z1000) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[calculation]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'source_model_logic_tree_file = Sources_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'gsim_logic_tree_file = GMPE_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'investigation_time = ' + str(self.investigation_time) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'intensity_measure_types_and_levels = {'\n    jobfile.write(Ligne)\n    intensities_done = []\n    for i in range(len(self.intensity_out)):\n        Ligne_1 = '\"' + str(self.intensity_out[i]) + '\": ['\n        array_ints = np.logspace(np.log10(self.min_int_out[i]), np.log10(self.max_int_out[i]), self.nb_int_out[i])\n        Ligne_2 = ''\n        for values in array_ints:\n            if len(Ligne_2) > 1:\n                Ligne_2 += ', '\n            Ligne_2 += str(values)\n        if not self.intensity_out[i] in intensities_done:\n            if len(intensities_done) != 0:\n                jobfile.write(', ')\n            jobfile.write(Ligne_1 + Ligne_2 + ']')\n        intensities_done.append(self.intensity_out[i])\n    Ligne = '}\\n'\n    jobfile.write(Ligne)\n    Ligne = 'truncation_level = ' + str(self.trunc_lvl) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'maximum_distance = ' + str(self.max_dist) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[output]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'export_dir =  ./results\\n'\n    jobfile.write(Ligne)\n    Ligne = 'mean_hazard_curves = true\\n'\n    jobfile.write(Ligne)\n    Ligne = 'quantile_hazard_curves =\\n'\n    jobfile.write(Ligne)\n    Ligne = 'uniform_hazard_spectra = false\\n'\n    jobfile.write(Ligne)\n    Ligne = 'poes = ' + str(self.poes) + '\\n'\n    jobfile.write(Ligne)",
            "def write_ini(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    jobfile = open(str(self.Run_Name) + '/job.ini', 'w')\n    Ligne = '[general]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = \"description = '\" + str(self.Run_Name) + \"'\\n\"\n    jobfile.write(Ligne)\n    Ligne = 'calculation_mode = classical\\n'\n    jobfile.write(Ligne)\n    Ligne = 'random_seed = ' + str(self.seed) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[geometry]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    if self.option_map == 'yes':\n        jobfile.write(Ligne)\n        Ligne = 'region = ' + str(self.ll_lon) + ' ' + str(self.ll_lat) + ', ' + str(self.lr_lon) + ' ' + str(self.lr_lat) + ', ' + str(self.ur_lon) + ' ' + str(self.ur_lat) + ', ' + str(self.ul_lon) + ' ' + str(self.ul_lat) + '\\n'\n        jobfile.write(Ligne)\n        Ligne = 'region_grid_spacing = ' + str(self.region_grid_spacing) + '\\n'\n    else:\n        jobfile.write(Ligne)\n        Ligne = 'sites = ' + str(self.Longitude)[:-1] + ' ' + str(self.Latitude) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[logic_tree]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'number_of_logic_tree_samples = ' + str(self.nb_LT_samp) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[erf]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'rupture_mesh_spacing =' + str(self.rup_mesh) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'width_of_mfd_bin = 0.1\\n'\n    jobfile.write(Ligne)\n    Ligne = 'area_source_discretization = ' + str(self.source_discr) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[site_params]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_type = measured\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_value = ' + str(self.Vs30) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_2pt5km_per_sec = ' + str(self.Z2500) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_1pt0km_per_sec = ' + str(self.Z1000) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[calculation]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'source_model_logic_tree_file = Sources_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'gsim_logic_tree_file = GMPE_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'investigation_time = ' + str(self.investigation_time) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'intensity_measure_types_and_levels = {'\n    jobfile.write(Ligne)\n    intensities_done = []\n    for i in range(len(self.intensity_out)):\n        Ligne_1 = '\"' + str(self.intensity_out[i]) + '\": ['\n        array_ints = np.logspace(np.log10(self.min_int_out[i]), np.log10(self.max_int_out[i]), self.nb_int_out[i])\n        Ligne_2 = ''\n        for values in array_ints:\n            if len(Ligne_2) > 1:\n                Ligne_2 += ', '\n            Ligne_2 += str(values)\n        if not self.intensity_out[i] in intensities_done:\n            if len(intensities_done) != 0:\n                jobfile.write(', ')\n            jobfile.write(Ligne_1 + Ligne_2 + ']')\n        intensities_done.append(self.intensity_out[i])\n    Ligne = '}\\n'\n    jobfile.write(Ligne)\n    Ligne = 'truncation_level = ' + str(self.trunc_lvl) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'maximum_distance = ' + str(self.max_dist) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[output]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'export_dir =  ./results\\n'\n    jobfile.write(Ligne)\n    Ligne = 'mean_hazard_curves = true\\n'\n    jobfile.write(Ligne)\n    Ligne = 'quantile_hazard_curves =\\n'\n    jobfile.write(Ligne)\n    Ligne = 'uniform_hazard_spectra = false\\n'\n    jobfile.write(Ligne)\n    Ligne = 'poes = ' + str(self.poes) + '\\n'\n    jobfile.write(Ligne)",
            "def write_ini(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    jobfile = open(str(self.Run_Name) + '/job.ini', 'w')\n    Ligne = '[general]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = \"description = '\" + str(self.Run_Name) + \"'\\n\"\n    jobfile.write(Ligne)\n    Ligne = 'calculation_mode = classical\\n'\n    jobfile.write(Ligne)\n    Ligne = 'random_seed = ' + str(self.seed) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[geometry]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    if self.option_map == 'yes':\n        jobfile.write(Ligne)\n        Ligne = 'region = ' + str(self.ll_lon) + ' ' + str(self.ll_lat) + ', ' + str(self.lr_lon) + ' ' + str(self.lr_lat) + ', ' + str(self.ur_lon) + ' ' + str(self.ur_lat) + ', ' + str(self.ul_lon) + ' ' + str(self.ul_lat) + '\\n'\n        jobfile.write(Ligne)\n        Ligne = 'region_grid_spacing = ' + str(self.region_grid_spacing) + '\\n'\n    else:\n        jobfile.write(Ligne)\n        Ligne = 'sites = ' + str(self.Longitude)[:-1] + ' ' + str(self.Latitude) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[logic_tree]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'number_of_logic_tree_samples = ' + str(self.nb_LT_samp) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[erf]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'rupture_mesh_spacing =' + str(self.rup_mesh) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'width_of_mfd_bin = 0.1\\n'\n    jobfile.write(Ligne)\n    Ligne = 'area_source_discretization = ' + str(self.source_discr) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[site_params]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_type = measured\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_vs30_value = ' + str(self.Vs30) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_2pt5km_per_sec = ' + str(self.Z2500) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'reference_depth_to_1pt0km_per_sec = ' + str(self.Z1000) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[calculation]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'source_model_logic_tree_file = Sources_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'gsim_logic_tree_file = GMPE_Logic_tree.xml\\n'\n    jobfile.write(Ligne)\n    Ligne = 'investigation_time = ' + str(self.investigation_time) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'intensity_measure_types_and_levels = {'\n    jobfile.write(Ligne)\n    intensities_done = []\n    for i in range(len(self.intensity_out)):\n        Ligne_1 = '\"' + str(self.intensity_out[i]) + '\": ['\n        array_ints = np.logspace(np.log10(self.min_int_out[i]), np.log10(self.max_int_out[i]), self.nb_int_out[i])\n        Ligne_2 = ''\n        for values in array_ints:\n            if len(Ligne_2) > 1:\n                Ligne_2 += ', '\n            Ligne_2 += str(values)\n        if not self.intensity_out[i] in intensities_done:\n            if len(intensities_done) != 0:\n                jobfile.write(', ')\n            jobfile.write(Ligne_1 + Ligne_2 + ']')\n        intensities_done.append(self.intensity_out[i])\n    Ligne = '}\\n'\n    jobfile.write(Ligne)\n    Ligne = 'truncation_level = ' + str(self.trunc_lvl) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'maximum_distance = ' + str(self.max_dist) + '\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = '[output]\\n'\n    jobfile.write(Ligne)\n    Ligne = '\\n'\n    jobfile.write(Ligne)\n    Ligne = 'export_dir =  ./results\\n'\n    jobfile.write(Ligne)\n    Ligne = 'mean_hazard_curves = true\\n'\n    jobfile.write(Ligne)\n    Ligne = 'quantile_hazard_curves =\\n'\n    jobfile.write(Ligne)\n    Ligne = 'uniform_hazard_spectra = false\\n'\n    jobfile.write(Ligne)\n    Ligne = 'poes = ' + str(self.poes) + '\\n'\n    jobfile.write(Ligne)"
        ]
    }
]