import argparse
import builtins
import itertools
import logging
import operator
import re
import sys
import typing
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from textwrap import dedent, indent as tw_indent
import inflection
import requests
URL_API_NPMJS_LATEST = 'https://registry.npmjs.org/devtools-protocol/latest'
JSON_PROTOCOL_URLS = ['https://github.com/ChromeDevTools/devtools-protocol/raw/{ref}/json/browser_protocol.json', 'https://github.com/ChromeDevTools/devtools-protocol/raw/{ref}/json/js_protocol.json']
OUTPUT_PATH = Path(__file__).parent.parent / 'src'
DOMAINS_REQUIRED = ['target', 'inspector']
parser = argparse.ArgumentParser()
parser.add_argument('domains', nargs='*')
parser.add_argument('--ref')
parser.add_argument('-p', '--package', default='streamlink.webbrowser.cdp.devtools')
parser.add_argument('-l', '--loglevel', choices=['debug', 'info', 'warning', 'error'], default='info')
logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler(stream=sys.stdout))
SHARED_HEADER = '# DO NOT EDIT THIS FILE!\n#\n# This file is generated from the CDP specification. If you need to make\n# changes, edit the generator and regenerate all modules.\n#\n# CDP version: {ref}'
INIT_HEADER = f'{SHARED_HEADER}\n\n'
MODULE_HEADER = f'{SHARED_HEADER}\n# CDP domain: {{domain}}{{experimental}}\n\nfrom __future__ import annotations\n\nimport enum\nimport typing\nfrom dataclasses import dataclass\n\n{{imports}}\n\n\n'
UTIL = f'{SHARED_HEADER}\n\nimport typing\n\n\nT_JSON_DICT = typing.Dict[str, typing.Any]\n_event_parsers = {{{{}}}}\n\n\ndef event_class(method):\n    """A decorator that registers a class as an event class."""\n    def decorate(cls):\n        _event_parsers[method] = cls\n        return cls\n    return decorate\n\n\ndef parse_json_event(json: T_JSON_DICT) -> typing.Any:\n    """Parse a JSON dictionary into a CDP event."""\n    return _event_parsers[json["method"]].from_json(json["params"])\n'

def indent(s: str, n: int):
    if False:
        for i in range(10):
            print('nop')
    'A shortcut for ``textwrap.indent`` that always uses spaces.'
    return tw_indent(s, n * ' ')
BACKTICK_RE = re.compile('`([^`]+)`(\\w+)?')

def escape_backticks(docstr: str) -> str:
    if False:
        while True:
            i = 10
    '\n    Escape backticks in a docstring by doubling them up.\n\n    This is a little tricky because RST requires a non-letter character after\n    the closing backticks, but some CDPs docs have things like "`AxNodeId`s".\n    If we double the backticks in that string, then it won\'t be valid RST. The\n    fix is to insert an apostrophe if an "s" trails the backticks.\n    '

    def replace_one(match):
        if False:
            print('Hello World!')
        if match.group(2) == 's':
            return f"``{match.group(1)}``'s"
        elif match.group(2):
            return f'``{match.group(1)}`` {match.group(2)}'
        else:
            return f'``{match.group(1)}``'
    if docstr.count('`') % 2:
        docstr = docstr.replace('`', '')
    docstr = docstr.replace('|', '`')
    return BACKTICK_RE.sub(replace_one, docstr)

def inline_doc(description) -> str:
    if False:
        i = 10
        return i + 15
    'Generate an inline doc, e.g. ``#: This type is a ...``'
    if not description:
        return ''
    description = escape_backticks(description)
    lines = [f'#: {line}'.rstrip() for line in description.split('\n')]
    return '\n'.join(lines)

def docstring(description: typing.Optional[str]) -> str:
    if False:
        for i in range(10):
            print('nop')
    'Generate a docstring from a description.'
    if not description:
        return ''
    description = escape_backticks(description)
    return dedent(f'"""\n{description}\n"""')

def is_builtin(name: str) -> bool:
    if False:
        print('Hello World!')
    'Return True if ``name`` would shadow a builtin.'
    try:
        getattr(builtins, name)
        return True
    except AttributeError:
        return False

def snake_case(name: str) -> str:
    if False:
        for i in range(10):
            print('nop')
    '\n    Convert a camel case name to snake case. If the name would shadow a\n    Python builtin, then append an underscore.\n    '
    name = inflection.underscore(name)
    if is_builtin(name):
        name += '_'
    return name

def ref_to_python(ref: str, domain: str) -> str:
    if False:
        return 10
    '\n    Convert a CDP ``$ref`` to the name of a Python type.\n\n    For a dotted ref, the part before the dot is snake cased.\n    '
    if '.' not in ref:
        return f'{ref}'
    (_domain, subtype) = ref.split('.')
    if _domain == domain:
        return subtype
    return f'{snake_case(_domain)}.{subtype}'

class CdpPrimitiveType(Enum):
    """All of the CDP types that map directly to a Python type."""
    boolean = 'bool'
    integer = 'int'
    number = 'float'
    object = 'dict'
    string = 'str'

    @classmethod
    def get_annotation(cls, cdp_type):
        if False:
            print('Hello World!')
        'Return a type annotation for the CDP type.'
        if cdp_type == 'any':
            return 'typing.Any'
        else:
            return cls[cdp_type].value

    @classmethod
    def get_constructor(cls, cdp_type, val):
        if False:
            print('Hello World!')
        'Return the code to construct a value for a given CDP type.'
        if cdp_type == 'any':
            return val
        else:
            cons = cls[cdp_type].value
            return f'{cons}({val})'

@dataclass
class CdpItems:
    """Represents the type of a repeated item."""
    type: str
    ref: str

    @classmethod
    def from_json(cls, type_) -> 'CdpItems':
        if False:
            return 10
        'Generate code to instantiate an item from a JSON object.'
        return cls(type_.get('type'), type_.get('$ref'))

@dataclass
class CdpProperty:
    """A property belonging to a non-primitive CDP type."""
    name: str
    description: typing.Optional[str]
    type: typing.Optional[str]
    ref: typing.Optional[str]
    enum: typing.List[str]
    items: typing.Optional[CdpItems]
    optional: bool
    experimental: bool
    deprecated: bool
    domain: str

    @property
    def py_name(self) -> str:
        if False:
            return 10
        "Get this property's Python name."
        return snake_case(self.name)

    @property
    def py_annotation(self) -> str:
        if False:
            return 10
        "This property's Python type annotation."
        if self.items:
            if self.items.ref:
                py_ref = ref_to_python(self.items.ref, self.domain)
                ann = f'typing.List[{py_ref}]'
            else:
                ann = f'typing.List[{CdpPrimitiveType.get_annotation(self.items.type)}]'
        elif self.ref:
            py_ref = ref_to_python(self.ref, self.domain)
            ann = py_ref
        else:
            ann = CdpPrimitiveType.get_annotation(typing.cast(str, self.type))
        if self.optional:
            ann = f'typing.Optional[{ann}]'
        return ann

    @classmethod
    def from_json(cls, property_, domain) -> 'CdpProperty':
        if False:
            print('Hello World!')
        'Instantiate a CDP property from a JSON object.'
        return cls(property_['name'], property_.get('description'), property_.get('type'), property_.get('$ref'), property_.get('enum'), CdpItems.from_json(property_['items']) if 'items' in property_ else None, property_.get('optional', False), property_.get('experimental', False), property_.get('deprecated', False), domain)

    def generate_decl(self) -> str:
        if False:
            while True:
                i = 10
        'Generate the code that declares this property.'
        code = inline_doc(self.description)
        if code:
            code += '\n'
        code += f'{self.py_name}: {self.py_annotation}'
        if self.optional:
            code += ' = None'
        return code

    def generate_to_json(self, dict_: str, use_self: bool=True) -> str:
        if False:
            for i in range(10):
                print('nop')
        'Generate the code that exports this property to the specified JSON dict.'
        self_ref = 'self.' if use_self else ''
        assign = f'{dict_}["{self.name}"] = '
        if self.items:
            if self.items.ref:
                assign += f'[i.to_json() for i in {self_ref}{self.py_name}]'
            else:
                assign += f'list({self_ref}{self.py_name})'
        elif self.ref:
            assign += f'{self_ref}{self.py_name}.to_json()'
        else:
            assign += f'{self_ref}{self.py_name}'
        if self.optional:
            code = dedent(f'                if {self_ref}{self.py_name} is not None:\n                    {assign}')
        else:
            code = assign
        return code

    def generate_from_json(self, dict_) -> str:
        if False:
            while True:
                i = 10
        'Generate the code that creates an instance from a JSON dict named ``dict_``.'
        if self.items:
            if self.items.ref:
                py_ref = ref_to_python(self.items.ref, self.domain)
                expr = f'[{py_ref}.from_json(i) for i in {dict_}["{self.name}"]]'
            else:
                cons = CdpPrimitiveType.get_constructor(self.items.type, 'i')
                if cons == 'i':
                    expr = f'list({dict_}["{self.name}"])'
                else:
                    expr = f'[{cons} for i in {dict_}["{self.name}"]]'
        elif self.ref:
            py_ref = ref_to_python(self.ref, self.domain)
            expr = f'{py_ref}.from_json({dict_}["{self.name}"])'
        else:
            expr = CdpPrimitiveType.get_constructor(self.type, f'{dict_}["{self.name}"]')
        if self.optional:
            expr = f'{expr} if "{self.name}" in {dict_} else None'
        return expr

@dataclass
class CdpType:
    """A top-level CDP type."""
    id: str
    description: typing.Optional[str]
    type: str
    items: typing.Optional[CdpItems]
    enum: typing.List[str]
    properties: typing.List[CdpProperty]
    domain: str

    @classmethod
    def from_json(cls, type_, domain) -> 'CdpType':
        if False:
            for i in range(10):
                print('nop')
        'Instantiate a CDP type from a JSON object.'
        return cls(type_['id'], type_.get('description'), type_['type'], CdpItems.from_json(type_['items']) if 'items' in type_ else None, type_.get('enum'), [CdpProperty.from_json(p, domain) for p in type_.get('properties', [])], domain)

    def generate_code(self) -> str:
        if False:
            return 10
        'Generate Python code for this type.'
        logger.debug(f'Generating type {self.id}: {self.type}')
        if self.enum:
            return self.generate_enum_code()
        elif self.properties:
            return self.generate_class_code()
        else:
            return self.generate_primitive_code()

    def generate_primitive_code(self) -> str:
        if False:
            return 10
        'Generate code for a primitive type.'
        if self.items:
            if self.items.ref:
                nested_type = ref_to_python(self.items.ref, self.domain)
            else:
                nested_type = CdpPrimitiveType.get_annotation(self.items.type)
            py_type = f'typing.List[{nested_type}]'
            superclass = 'list'
        else:
            py_type = CdpPrimitiveType.get_annotation(self.type)
            superclass = py_type
        code = f'class {self.id}({superclass}):\n'
        doc = docstring(self.description)
        if doc:
            code += indent(doc, 4) + '\n'
        def_to_json = dedent(f'            def to_json(self) -> {py_type}:\n                return self')
        code += indent(def_to_json, 4)
        def_from_json = dedent(f'            @classmethod\n            def from_json(cls, json: {py_type}) -> {self.id}:\n                return cls(json)')
        code += '\n\n' + indent(def_from_json, 4)
        def_repr = dedent(f'            def __repr__(self):\n                return f"{self.id}({{super().__repr__()}})"')
        code += '\n\n' + indent(def_repr, 4)
        return code

    def generate_enum_code(self) -> str:
        if False:
            return 10
        '\n        Generate an "enum" type.\n\n        Enums are handled by making a python class that contains only class\n        members. Each class member is upper snaked case, e.g.\n        ``MyTypeClass.MY_ENUM_VALUE`` and is assigned a string value from the\n        CDP metadata.\n        '
        def_to_json = dedent('            def to_json(self) -> str:\n                return self.value')
        def_from_json = dedent(f'            @classmethod\n            def from_json(cls, json: str) -> {self.id}:\n                return cls(json)')
        code = f'class {self.id}(enum.Enum):\n'
        doc = docstring(self.description)
        if doc:
            code += indent(doc, 4) + '\n'
        for enum_member in self.enum:
            snake_name = snake_case(enum_member).upper()
            enum_code = f'{snake_name} = "{enum_member}"\n'
            code += indent(enum_code, 4)
        code += '\n' + indent(def_to_json, 4)
        code += '\n\n' + indent(def_from_json, 4)
        return code

    def generate_class_code(self) -> str:
        if False:
            return 10
        '\n        Generate a class type.\n\n        Top-level types that are defined as a CDP ``object`` are turned into Python\n        dataclasses.\n        '
        code = dedent(f'            @dataclass\n            class {self.id}:\n')
        doc = docstring(self.description)
        if doc:
            code += indent(doc, 4) + '\n'
        props = list(self.properties)
        props.sort(key=operator.attrgetter('optional'))
        code += '\n\n'.join((indent(p.generate_decl(), 4) for p in props))
        code += '\n\n'
        def_to_json = dedent('            def to_json(self) -> T_JSON_DICT:\n                json: T_JSON_DICT = {}\n        ')
        assigns = (p.generate_to_json(dict_='json') for p in props)
        def_to_json += indent('\n'.join(assigns), 4)
        def_to_json += '\n'
        def_to_json += indent('return json', 4)
        code += indent(def_to_json, 4) + '\n\n'
        def_from_json = dedent(f'            @classmethod\n            def from_json(cls, json: T_JSON_DICT) -> {self.id}:\n                return cls(\n        ')
        from_jsons = []
        for p in props:
            from_json = p.generate_from_json(dict_='json')
            from_jsons.append(f'{p.py_name}={from_json},')
        def_from_json += indent('\n'.join(from_jsons), 8)
        def_from_json += '\n'
        def_from_json += indent(')', 4)
        code += indent(def_from_json, 4)
        return code

    def get_refs(self):
        if False:
            print('Hello World!')
        'Return all refs for this type.'
        refs = set()
        if self.enum:
            pass
        elif self.properties:
            for prop in self.properties:
                if prop.items and prop.items.ref:
                    refs.add(prop.items.ref)
                elif prop.ref:
                    refs.add(prop.ref)
        elif self.items and self.items.ref:
            refs.add(self.items.ref)
        return refs

class CdpParameter(CdpProperty):
    """A parameter to a CDP command."""

    def generate_code(self) -> str:
        if False:
            return 10
        'Generate the code for a parameter in a function call.'
        if self.items:
            if self.items.ref:
                nested_type = ref_to_python(self.items.ref, self.domain)
                py_type = f'typing.List[{nested_type}]'
            else:
                nested_type = CdpPrimitiveType.get_annotation(self.items.type)
                py_type = f'typing.List[{nested_type}]'
        elif self.ref:
            py_type = f'{ref_to_python(self.ref, self.domain)}'
        else:
            py_type = CdpPrimitiveType.get_annotation(typing.cast(str, self.type))
        if self.optional:
            py_type = f'typing.Optional[{py_type}]'
        code = f'{self.py_name}: {py_type}'
        if self.optional:
            code += ' = None'
        return code

    def generate_decl(self) -> str:
        if False:
            i = 10
            return i + 15
        'Generate the declaration for this parameter.'
        if self.description:
            code = inline_doc(self.description)
            code += '\n'
        else:
            code = ''
        code += f'{self.py_name}: {self.py_annotation}'
        return code

    def generate_doc(self) -> str:
        if False:
            print('Hello World!')
        'Generate the docstring for this parameter.'
        doc = f':param {self.py_name}:'
        if self.experimental:
            doc += ' **(EXPERIMENTAL)**'
        if self.optional:
            doc += ' *(Optional)*'
        if self.description:
            desc = self.description.replace('`', '``').replace('\n', ' ')
            doc += f' {desc}'
        return doc

    def generate_from_json(self, dict_) -> str:
        if False:
            print('Hello World!')
        'Generate the code to instantiate this parameter from a JSON dict.'
        code = super().generate_from_json(dict_)
        return f'{self.py_name}={code}'

class CdpReturn(CdpProperty):
    """A return value from a CDP command."""

    @property
    def py_annotation(self):
        if False:
            i = 10
            return i + 15
        'Return the Python type annotation for this return.'
        if self.items:
            if self.items.ref:
                py_ref = ref_to_python(self.items.ref, self.domain)
                ann = f'typing.List[{py_ref}]'
            else:
                py_type = CdpPrimitiveType.get_annotation(self.items.type)
                ann = f'typing.List[{py_type}]'
        elif self.ref:
            py_ref = ref_to_python(self.ref, self.domain)
            ann = f'{py_ref}'
        else:
            ann = CdpPrimitiveType.get_annotation(self.type)
        if self.optional:
            ann = f'typing.Optional[{ann}]'
        return ann

    def generate_doc(self):
        if False:
            for i in range(10):
                print('nop')
        'Generate the docstring for this return.'
        if self.description:
            doc = self.description.replace('\n', ' ')
            if self.optional:
                doc = f'*(Optional)* {doc}'
        else:
            doc = ''
        return doc

    def generate_return(self, dict_):
        if False:
            i = 10
            return i + 15
        'Generate code for returning this value.'
        return super().generate_from_json(dict_)

@dataclass
class CdpCommand:
    """A CDP command."""
    name: str
    description: str
    experimental: bool
    deprecated: bool
    parameters: typing.List[CdpParameter]
    returns: typing.List[CdpReturn]
    domain: str

    @property
    def py_name(self):
        if False:
            i = 10
            return i + 15
        'Get a Python name for this command.'
        return snake_case(self.name)

    @classmethod
    def from_json(cls, command, domain) -> 'CdpCommand':
        if False:
            for i in range(10):
                print('nop')
        'Instantiate a CDP command from a JSON object.'
        parameters = command.get('parameters', [])
        returns = command.get('returns', [])
        return cls(command['name'], command.get('description'), command.get('experimental', False), command.get('deprecated', False), [typing.cast(CdpParameter, CdpParameter.from_json(p, domain)) for p in parameters], [typing.cast(CdpReturn, CdpReturn.from_json(r, domain)) for r in returns], domain)

    def generate_code(self) -> str:
        if False:
            i = 10
            return i + 15
        'Generate code for a CDP command.'
        if len(self.returns) == 0:
            ret_type = 'None'
        elif len(self.returns) == 1:
            ret_type = self.returns[0].py_annotation
        else:
            nested_types = ', '.join((r.py_annotation for r in self.returns))
            ret_type = f'typing.Tuple[{nested_types}]'
        ret_type = f'typing.Generator[T_JSON_DICT, T_JSON_DICT, {ret_type}]'
        code = ''
        code += f'def {self.py_name}('
        ret = f') -> {ret_type}:\n'
        parameters = sorted(self.parameters, key=operator.attrgetter('optional'))
        if parameters:
            params = [f'{p.generate_code()},' for p in parameters]
            code += '\n'
            code += indent('\n'.join(params), 4)
            code += '\n'
            code += ret
        else:
            code += ret
        doc = ''
        if self.description:
            doc = self.description
        if self.experimental:
            doc += '\n\n**EXPERIMENTAL**'
        if parameters and doc:
            doc += '\n\n'
        elif not parameters and self.returns:
            doc += '\n'
        doc += '\n'.join((p.generate_doc() for p in parameters))
        if len(self.returns) == 1:
            doc += '\n'
            ret_doc = self.returns[0].generate_doc()
            doc += f':returns: {ret_doc}'.rstrip()
        elif len(self.returns) > 1:
            doc += '\n'
            doc += ':returns: A tuple with the following items:\n\n'
            ret_docs = '\n'.join((f'{i}. **{r.name}** - {r.generate_doc()}'.rstrip() for (i, r) in enumerate(self.returns)))
            doc += indent(ret_docs, 4)
        if doc:
            code += indent(docstring(doc), 4)
        if parameters:
            code += '\n'
            code += indent('params: T_JSON_DICT = {}', 4)
            code += '\n'
        assigns = (p.generate_to_json(dict_='params', use_self=False) for p in parameters)
        code += indent('\n'.join(assigns), 4)
        code += '\n'
        code += indent('cmd_dict: T_JSON_DICT = {\n', 4)
        code += indent(f'"method": "{self.domain}.{self.name}",\n', 8)
        if parameters:
            code += indent('"params": params,\n', 8)
        code += indent('}\n', 4)
        code += indent(f"{('json = ' if len(self.returns) else '')}yield cmd_dict", 4)
        if len(self.returns) == 0:
            pass
        elif len(self.returns) == 1:
            ret = self.returns[0].generate_return(dict_='json')
            code += indent(f'\nreturn {ret}', 4)
        else:
            ret = '\nreturn (\n'
            expr = '\n'.join((f"{r.generate_return(dict_='json')}," for r in self.returns))
            ret += indent(expr, 4)
            ret += '\n)'
            code += indent(ret, 4)
        return code

    def get_refs(self):
        if False:
            return 10
        'Get all refs for this command.'
        refs = set()
        for type_ in itertools.chain(self.parameters, self.returns):
            if type_.items and type_.items.ref:
                refs.add(type_.items.ref)
            elif type_.ref:
                refs.add(type_.ref)
        return refs

@dataclass
class CdpEvent:
    """A CDP event object."""
    name: str
    description: typing.Optional[str]
    deprecated: bool
    experimental: bool
    parameters: typing.List[CdpParameter]
    domain: str

    @property
    def py_name(self):
        if False:
            while True:
                i = 10
        'Return the Python class name for this event.'
        return inflection.camelize(self.name, uppercase_first_letter=True)

    @classmethod
    def from_json(cls, json_: dict, domain: str):
        if False:
            return 10
        'Create a new CDP event instance from a JSON dict.'
        return cls(json_['name'], json_.get('description'), json_.get('deprecated', False), json_.get('experimental', False), [typing.cast(CdpParameter, CdpParameter.from_json(p, domain)) for p in json_.get('parameters', [])], domain)

    def generate_code(self) -> str:
        if False:
            while True:
                i = 10
        'Generate code for a CDP event.'
        code = dedent(f'            @event_class("{self.domain}.{self.name}")\n            @dataclass\n            class {self.py_name}:')
        code += '\n'
        desc = ''
        if self.description or self.experimental:
            if self.experimental:
                desc += '**EXPERIMENTAL**\n\n'
            if self.description:
                desc += self.description
            code += indent(docstring(desc), 4)
            code += '\n'
        code += indent('\n'.join((p.generate_decl() for p in self.parameters)), 4)
        code += '\n\n'
        def_from_json = dedent(f'            @classmethod\n            def from_json(cls, json: T_JSON_DICT) -> {self.py_name}:\n                return cls(\n        ')
        code += indent(def_from_json, 4)
        from_json = '\n'.join((f"{p.generate_from_json(dict_='json')}," for p in self.parameters))
        code += indent(from_json, 12)
        code += '\n'
        code += indent(')', 8)
        return code

    def get_refs(self):
        if False:
            i = 10
            return i + 15
        'Get all refs for this event.'
        refs = set()
        for param in self.parameters:
            if param.items and param.items.ref:
                refs.add(param.items.ref)
            elif param.ref:
                refs.add(param.ref)
        return refs

@dataclass
class CdpDomain:
    """A CDP domain contains metadata, types, commands, and events."""
    domain: str
    description: typing.Optional[str]
    experimental: bool
    dependencies: typing.List[str]
    types: typing.List[CdpType]
    commands: typing.List[CdpCommand]
    events: typing.List[CdpEvent]

    @property
    def module(self):
        if False:
            for i in range(10):
                print('nop')
        'The name of the Python module for this CDP domain.'
        return snake_case(self.domain)

    @classmethod
    def from_json(cls, domain: dict):
        if False:
            while True:
                i = 10
        'Instantiate a CDP domain from a JSON object.'
        types = domain.get('types', [])
        commands = domain.get('commands', [])
        events = domain.get('events', [])
        domain_name = domain['domain']
        return cls(domain_name, domain.get('description'), domain.get('experimental', False), domain.get('dependencies', []), [CdpType.from_json(_type, domain_name) for _type in types], [CdpCommand.from_json(command, domain_name) for command in commands], [CdpEvent.from_json(event, domain_name) for event in events])

    def generate_code(self, ref: str, package: str) -> str:
        if False:
            while True:
                i = 10
        'Generate the Python module code for a given CDP domain.'
        exp = ' (experimental)' if self.experimental else ''
        imports = self.generate_imports(package)
        code = MODULE_HEADER.format(ref=ref, domain=self.domain, experimental=exp, imports=imports)
        item_iter_t = typing.Union[CdpEvent, CdpCommand, CdpType]
        item_iter: typing.Iterator[item_iter_t] = itertools.chain(iter(self.types), iter(self.commands), iter(self.events))
        code += '\n\n\n'.join((item.generate_code() for item in item_iter))
        code += '\n'
        return code

    def get_imports(self):
        if False:
            i = 10
            return i + 15
        refs = set()
        for type_ in self.types:
            refs |= type_.get_refs()
        for command in self.commands:
            refs |= command.get_refs()
        for event in self.events:
            refs |= event.get_refs()
        dependencies = set()
        for ref in refs:
            try:
                (domain, _) = ref.split('.')
            except ValueError:
                continue
            if domain != self.domain:
                dependencies.add(snake_case(domain))
        return dependencies

    def generate_imports(self, package: str):
        if False:
            for i in range(10):
                print('nop')
        "\n        Determine which modules this module depends on and emit the code to\n        import those modules.\n\n        Notice that CDP defines a ``dependencies`` field for each domain, but\n        these dependencies are a subset of the modules that we actually need to\n        import to make our Python code work correctly and type safe. So we\n        ignore the CDP's declared dependencies and compute them ourselves.\n        "
        dependencies = self.get_imports()
        imports = [f'import {package}.{d} as {d}\n' for d in sorted(dependencies)]
        imports.append(f'from {package}.util import T_JSON_DICT, event_class')
        return ''.join(imports)

def parse(schema: dict) -> typing.List[CdpDomain]:
    if False:
        while True:
            i = 10
    'Parse JSON protocol description and return domain objects.'
    version = schema['version']
    assert (version['major'], version['minor']) == ('1', '3')
    domains = []
    for domain in schema['domains']:
        domains.append(CdpDomain.from_json(domain))
    return domains

def generate_init(init_path: Path, ref: str, package: str, domains: typing.List[CdpDomain]):
    if False:
        return 10
    'Generate an ``__init__.py`` that exports the specified modules.'
    with init_path.open('w') as init_file:
        init_file.write(INIT_HEADER.format(ref=ref))
        for module in sorted([domain.module for domain in domains] + ['util']):
            init_file.write(f'import {package}.{module} as {module}\n')

def generate_util(util_path: Path, ref: str):
    if False:
        while True:
            i = 10
    'Generate a ``util.py`` that is imported by the domain module files.'
    with util_path.open('w') as util_file:
        util_file.write(UTIL.format(ref=ref))

def main():
    if False:
        return 10
    'Main entry point.'
    args = parser.parse_args()
    logger.setLevel(args.loglevel.upper())
    output_path = OUTPUT_PATH / Path(*args.package.split('.'))
    logger.info(f'Output: {output_path}')
    session = requests.Session()
    session.headers['User-Agent'] = 'streamlink/streamlink'
    ref = args.ref
    if not ref:
        logger.info('Fetching latest tag from NPMJS')
        try:
            npmjs_api_data = session.get(URL_API_NPMJS_LATEST).json()
            ref = f"v{npmjs_api_data['version']}"
        except (requests.HTTPError, KeyError) as err:
            logger.exception(err)
            return
        logger.info(f'Latest tag: {ref}')
    json_data = []
    try:
        for url in JSON_PROTOCOL_URLS:
            url = url.format(ref=ref)
            logger.info(f'Fetching {url}')
            res = session.get(url, timeout=10)
            logger.debug('Parsing JSON...')
            json_data.append(res.json())
    except requests.HTTPError as err:
        logger.exception(err)
        return
    logger.info('Parsing domains...')
    domain_data = []
    for data in json_data:
        domain_data.extend(parse(data))
    domain_map = {snake_case(domain.domain): domain for domain in domain_data}
    selected_domains = {snake_case(name) for name in args.domains + DOMAINS_REQUIRED}
    for name in selected_domains:
        if name not in domain_map:
            logger.error(f'Invalid domain: {name}')
            return
    required_domains = set()

    def add_required_domains(current):
        if False:
            while True:
                i = 10
        if current in required_domains:
            return
        required_domains.add(current)
        deps = domain_map[current].get_imports()
        for dep in deps:
            add_required_domains(dep)
    for selection in selected_domains:
        add_required_domains(selection)
    domains = [domain_map[name] for name in sorted(required_domains)]
    logger.info('Writing output...')
    output_path.mkdir(parents=True, exist_ok=True)
    for subpath in output_path.iterdir():
        if subpath.is_file():
            subpath.unlink()
    for domain in domains:
        logger.info(f'Generating module: {domain.domain} -> {domain.module}.py')
        module_path = output_path / f'{domain.module}.py'
        with module_path.open('w') as module_file:
            module_file.write(domain.generate_code(ref, args.package))
    init_path = output_path / '__init__.py'
    util_path = output_path / 'util.py'
    generate_init(init_path, ref, args.package, domains)
    generate_util(util_path, ref)
if __name__ == '__main__':
    main()