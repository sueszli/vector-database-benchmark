[
    {
        "func_name": "__init__",
        "original": "def __init__(self, voxel_size, point_cloud_range, max_num_points, max_voxels=20000):\n    point_cloud_range = np.array(point_cloud_range, dtype=np.float32)\n    voxel_size = np.array(voxel_size, dtype=np.float32)\n    grid_size = (point_cloud_range[3:] - point_cloud_range[:3]) / voxel_size\n    grid_size = np.round(grid_size).astype(np.int64)\n    self._voxel_size = voxel_size\n    self._point_cloud_range = point_cloud_range\n    self._max_num_points = max_num_points\n    self._max_voxels = max_voxels\n    self._grid_size = grid_size",
        "mutated": [
            "def __init__(self, voxel_size, point_cloud_range, max_num_points, max_voxels=20000):\n    if False:\n        i = 10\n    point_cloud_range = np.array(point_cloud_range, dtype=np.float32)\n    voxel_size = np.array(voxel_size, dtype=np.float32)\n    grid_size = (point_cloud_range[3:] - point_cloud_range[:3]) / voxel_size\n    grid_size = np.round(grid_size).astype(np.int64)\n    self._voxel_size = voxel_size\n    self._point_cloud_range = point_cloud_range\n    self._max_num_points = max_num_points\n    self._max_voxels = max_voxels\n    self._grid_size = grid_size",
            "def __init__(self, voxel_size, point_cloud_range, max_num_points, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    point_cloud_range = np.array(point_cloud_range, dtype=np.float32)\n    voxel_size = np.array(voxel_size, dtype=np.float32)\n    grid_size = (point_cloud_range[3:] - point_cloud_range[:3]) / voxel_size\n    grid_size = np.round(grid_size).astype(np.int64)\n    self._voxel_size = voxel_size\n    self._point_cloud_range = point_cloud_range\n    self._max_num_points = max_num_points\n    self._max_voxels = max_voxels\n    self._grid_size = grid_size",
            "def __init__(self, voxel_size, point_cloud_range, max_num_points, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    point_cloud_range = np.array(point_cloud_range, dtype=np.float32)\n    voxel_size = np.array(voxel_size, dtype=np.float32)\n    grid_size = (point_cloud_range[3:] - point_cloud_range[:3]) / voxel_size\n    grid_size = np.round(grid_size).astype(np.int64)\n    self._voxel_size = voxel_size\n    self._point_cloud_range = point_cloud_range\n    self._max_num_points = max_num_points\n    self._max_voxels = max_voxels\n    self._grid_size = grid_size",
            "def __init__(self, voxel_size, point_cloud_range, max_num_points, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    point_cloud_range = np.array(point_cloud_range, dtype=np.float32)\n    voxel_size = np.array(voxel_size, dtype=np.float32)\n    grid_size = (point_cloud_range[3:] - point_cloud_range[:3]) / voxel_size\n    grid_size = np.round(grid_size).astype(np.int64)\n    self._voxel_size = voxel_size\n    self._point_cloud_range = point_cloud_range\n    self._max_num_points = max_num_points\n    self._max_voxels = max_voxels\n    self._grid_size = grid_size",
            "def __init__(self, voxel_size, point_cloud_range, max_num_points, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    point_cloud_range = np.array(point_cloud_range, dtype=np.float32)\n    voxel_size = np.array(voxel_size, dtype=np.float32)\n    grid_size = (point_cloud_range[3:] - point_cloud_range[:3]) / voxel_size\n    grid_size = np.round(grid_size).astype(np.int64)\n    self._voxel_size = voxel_size\n    self._point_cloud_range = point_cloud_range\n    self._max_num_points = max_num_points\n    self._max_voxels = max_voxels\n    self._grid_size = grid_size"
        ]
    },
    {
        "func_name": "generate",
        "original": "def generate(self, points):\n    \"\"\"Generate voxels given points.\"\"\"\n    return points_to_voxel(points, self._voxel_size, self._point_cloud_range, self._max_num_points, True, self._max_voxels)",
        "mutated": [
            "def generate(self, points):\n    if False:\n        i = 10\n    'Generate voxels given points.'\n    return points_to_voxel(points, self._voxel_size, self._point_cloud_range, self._max_num_points, True, self._max_voxels)",
            "def generate(self, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate voxels given points.'\n    return points_to_voxel(points, self._voxel_size, self._point_cloud_range, self._max_num_points, True, self._max_voxels)",
            "def generate(self, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate voxels given points.'\n    return points_to_voxel(points, self._voxel_size, self._point_cloud_range, self._max_num_points, True, self._max_voxels)",
            "def generate(self, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate voxels given points.'\n    return points_to_voxel(points, self._voxel_size, self._point_cloud_range, self._max_num_points, True, self._max_voxels)",
            "def generate(self, points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate voxels given points.'\n    return points_to_voxel(points, self._voxel_size, self._point_cloud_range, self._max_num_points, True, self._max_voxels)"
        ]
    },
    {
        "func_name": "voxel_size",
        "original": "@property\ndef voxel_size(self):\n    \"\"\"list[float]: Size of a single voxel.\"\"\"\n    return self._voxel_size",
        "mutated": [
            "@property\ndef voxel_size(self):\n    if False:\n        i = 10\n    'list[float]: Size of a single voxel.'\n    return self._voxel_size",
            "@property\ndef voxel_size(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'list[float]: Size of a single voxel.'\n    return self._voxel_size",
            "@property\ndef voxel_size(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'list[float]: Size of a single voxel.'\n    return self._voxel_size",
            "@property\ndef voxel_size(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'list[float]: Size of a single voxel.'\n    return self._voxel_size",
            "@property\ndef voxel_size(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'list[float]: Size of a single voxel.'\n    return self._voxel_size"
        ]
    },
    {
        "func_name": "max_num_points_per_voxel",
        "original": "@property\ndef max_num_points_per_voxel(self):\n    \"\"\"int: Maximum number of points per voxel.\"\"\"\n    return self._max_num_points",
        "mutated": [
            "@property\ndef max_num_points_per_voxel(self):\n    if False:\n        i = 10\n    'int: Maximum number of points per voxel.'\n    return self._max_num_points",
            "@property\ndef max_num_points_per_voxel(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'int: Maximum number of points per voxel.'\n    return self._max_num_points",
            "@property\ndef max_num_points_per_voxel(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'int: Maximum number of points per voxel.'\n    return self._max_num_points",
            "@property\ndef max_num_points_per_voxel(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'int: Maximum number of points per voxel.'\n    return self._max_num_points",
            "@property\ndef max_num_points_per_voxel(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'int: Maximum number of points per voxel.'\n    return self._max_num_points"
        ]
    },
    {
        "func_name": "point_cloud_range",
        "original": "@property\ndef point_cloud_range(self):\n    \"\"\"list[float]: Range of point cloud.\"\"\"\n    return self._point_cloud_range",
        "mutated": [
            "@property\ndef point_cloud_range(self):\n    if False:\n        i = 10\n    'list[float]: Range of point cloud.'\n    return self._point_cloud_range",
            "@property\ndef point_cloud_range(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'list[float]: Range of point cloud.'\n    return self._point_cloud_range",
            "@property\ndef point_cloud_range(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'list[float]: Range of point cloud.'\n    return self._point_cloud_range",
            "@property\ndef point_cloud_range(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'list[float]: Range of point cloud.'\n    return self._point_cloud_range",
            "@property\ndef point_cloud_range(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'list[float]: Range of point cloud.'\n    return self._point_cloud_range"
        ]
    },
    {
        "func_name": "grid_size",
        "original": "@property\ndef grid_size(self):\n    \"\"\"np.ndarray: The size of grids.\"\"\"\n    return self._grid_size",
        "mutated": [
            "@property\ndef grid_size(self):\n    if False:\n        i = 10\n    'np.ndarray: The size of grids.'\n    return self._grid_size",
            "@property\ndef grid_size(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'np.ndarray: The size of grids.'\n    return self._grid_size",
            "@property\ndef grid_size(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'np.ndarray: The size of grids.'\n    return self._grid_size",
            "@property\ndef grid_size(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'np.ndarray: The size of grids.'\n    return self._grid_size",
            "@property\ndef grid_size(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'np.ndarray: The size of grids.'\n    return self._grid_size"
        ]
    },
    {
        "func_name": "__repr__",
        "original": "def __repr__(self):\n    \"\"\"str: Return a string that describes the module.\"\"\"\n    repr_str = self.__class__.__name__\n    indent = ' ' * (len(repr_str) + 1)\n    repr_str += f'(voxel_size={self._voxel_size},\\n'\n    repr_str += indent + 'point_cloud_range='\n    repr_str += f'{self._point_cloud_range.tolist()},\\n'\n    repr_str += indent + f'max_num_points={self._max_num_points},\\n'\n    repr_str += indent + f'max_voxels={self._max_voxels},\\n'\n    repr_str += indent + f'grid_size={self._grid_size.tolist()}'\n    repr_str += ')'\n    return repr_str",
        "mutated": [
            "def __repr__(self):\n    if False:\n        i = 10\n    'str: Return a string that describes the module.'\n    repr_str = self.__class__.__name__\n    indent = ' ' * (len(repr_str) + 1)\n    repr_str += f'(voxel_size={self._voxel_size},\\n'\n    repr_str += indent + 'point_cloud_range='\n    repr_str += f'{self._point_cloud_range.tolist()},\\n'\n    repr_str += indent + f'max_num_points={self._max_num_points},\\n'\n    repr_str += indent + f'max_voxels={self._max_voxels},\\n'\n    repr_str += indent + f'grid_size={self._grid_size.tolist()}'\n    repr_str += ')'\n    return repr_str",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'str: Return a string that describes the module.'\n    repr_str = self.__class__.__name__\n    indent = ' ' * (len(repr_str) + 1)\n    repr_str += f'(voxel_size={self._voxel_size},\\n'\n    repr_str += indent + 'point_cloud_range='\n    repr_str += f'{self._point_cloud_range.tolist()},\\n'\n    repr_str += indent + f'max_num_points={self._max_num_points},\\n'\n    repr_str += indent + f'max_voxels={self._max_voxels},\\n'\n    repr_str += indent + f'grid_size={self._grid_size.tolist()}'\n    repr_str += ')'\n    return repr_str",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'str: Return a string that describes the module.'\n    repr_str = self.__class__.__name__\n    indent = ' ' * (len(repr_str) + 1)\n    repr_str += f'(voxel_size={self._voxel_size},\\n'\n    repr_str += indent + 'point_cloud_range='\n    repr_str += f'{self._point_cloud_range.tolist()},\\n'\n    repr_str += indent + f'max_num_points={self._max_num_points},\\n'\n    repr_str += indent + f'max_voxels={self._max_voxels},\\n'\n    repr_str += indent + f'grid_size={self._grid_size.tolist()}'\n    repr_str += ')'\n    return repr_str",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'str: Return a string that describes the module.'\n    repr_str = self.__class__.__name__\n    indent = ' ' * (len(repr_str) + 1)\n    repr_str += f'(voxel_size={self._voxel_size},\\n'\n    repr_str += indent + 'point_cloud_range='\n    repr_str += f'{self._point_cloud_range.tolist()},\\n'\n    repr_str += indent + f'max_num_points={self._max_num_points},\\n'\n    repr_str += indent + f'max_voxels={self._max_voxels},\\n'\n    repr_str += indent + f'grid_size={self._grid_size.tolist()}'\n    repr_str += ')'\n    return repr_str",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'str: Return a string that describes the module.'\n    repr_str = self.__class__.__name__\n    indent = ' ' * (len(repr_str) + 1)\n    repr_str += f'(voxel_size={self._voxel_size},\\n'\n    repr_str += indent + 'point_cloud_range='\n    repr_str += f'{self._point_cloud_range.tolist()},\\n'\n    repr_str += indent + f'max_num_points={self._max_num_points},\\n'\n    repr_str += indent + f'max_voxels={self._max_voxels},\\n'\n    repr_str += indent + f'grid_size={self._grid_size.tolist()}'\n    repr_str += ')'\n    return repr_str"
        ]
    },
    {
        "func_name": "points_to_voxel",
        "original": "def points_to_voxel(points, voxel_size, coors_range, max_points=35, reverse_index=True, max_voxels=20000):\n    \"\"\"convert kitti points(N, >=3) to voxels.\n\n    Args:\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\n            points[:, 3:] contain other information such as reflectivity.\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\n        coors_range (list[float | tuple[float] | ndarray]): Voxel range.\n            format: xyzxyz, minmax\n        max_points (int): Indicate maximum points contained in a voxel.\n        reverse_index (bool): Whether return reversed coordinates.\n            if points has xyz format and reverse_index is True, output\n            coordinates will be zyx format, but points in features always\n            xyz format.\n        max_voxels (int): Maximum number of voxels this function creates.\n            For second, 20000 is a good choice. Points should be shuffled for\n            randomness before this function because max_voxels drops points.\n\n    Returns:\n        tuple[np.ndarray]:\n            voxels: [M, max_points, ndim] float tensor. only contain points.\n            coordinates: [M, 3] int32 tensor.\n            num_points_per_voxel: [M] int32 tensor.\n    \"\"\"\n    if not isinstance(voxel_size, np.ndarray):\n        voxel_size = np.array(voxel_size, dtype=points.dtype)\n    if not isinstance(coors_range, np.ndarray):\n        coors_range = np.array(coors_range, dtype=points.dtype)\n    voxelmap_shape = (coors_range[3:] - coors_range[:3]) / voxel_size\n    voxelmap_shape = tuple(np.round(voxelmap_shape).astype(np.int32).tolist())\n    if reverse_index:\n        voxelmap_shape = voxelmap_shape[::-1]\n    num_points_per_voxel = np.zeros(shape=(max_voxels,), dtype=np.int32)\n    coor_to_voxelidx = -np.ones(shape=voxelmap_shape, dtype=np.int32)\n    voxels = np.zeros(shape=(max_voxels, max_points, points.shape[-1]), dtype=points.dtype)\n    coors = np.zeros(shape=(max_voxels, 3), dtype=np.int32)\n    if reverse_index:\n        voxel_num = _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    else:\n        voxel_num = _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    coors = coors[:voxel_num]\n    voxels = voxels[:voxel_num]\n    num_points_per_voxel = num_points_per_voxel[:voxel_num]\n    return (voxels, coors, num_points_per_voxel)",
        "mutated": [
            "def points_to_voxel(points, voxel_size, coors_range, max_points=35, reverse_index=True, max_voxels=20000):\n    if False:\n        i = 10\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Voxel range.\\n            format: xyzxyz, minmax\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        reverse_index (bool): Whether return reversed coordinates.\\n            if points has xyz format and reverse_index is True, output\\n            coordinates will be zyx format, but points in features always\\n            xyz format.\\n        max_voxels (int): Maximum number of voxels this function creates.\\n            For second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: [M, max_points, ndim] float tensor. only contain points.\\n            coordinates: [M, 3] int32 tensor.\\n            num_points_per_voxel: [M] int32 tensor.\\n    '\n    if not isinstance(voxel_size, np.ndarray):\n        voxel_size = np.array(voxel_size, dtype=points.dtype)\n    if not isinstance(coors_range, np.ndarray):\n        coors_range = np.array(coors_range, dtype=points.dtype)\n    voxelmap_shape = (coors_range[3:] - coors_range[:3]) / voxel_size\n    voxelmap_shape = tuple(np.round(voxelmap_shape).astype(np.int32).tolist())\n    if reverse_index:\n        voxelmap_shape = voxelmap_shape[::-1]\n    num_points_per_voxel = np.zeros(shape=(max_voxels,), dtype=np.int32)\n    coor_to_voxelidx = -np.ones(shape=voxelmap_shape, dtype=np.int32)\n    voxels = np.zeros(shape=(max_voxels, max_points, points.shape[-1]), dtype=points.dtype)\n    coors = np.zeros(shape=(max_voxels, 3), dtype=np.int32)\n    if reverse_index:\n        voxel_num = _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    else:\n        voxel_num = _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    coors = coors[:voxel_num]\n    voxels = voxels[:voxel_num]\n    num_points_per_voxel = num_points_per_voxel[:voxel_num]\n    return (voxels, coors, num_points_per_voxel)",
            "def points_to_voxel(points, voxel_size, coors_range, max_points=35, reverse_index=True, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Voxel range.\\n            format: xyzxyz, minmax\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        reverse_index (bool): Whether return reversed coordinates.\\n            if points has xyz format and reverse_index is True, output\\n            coordinates will be zyx format, but points in features always\\n            xyz format.\\n        max_voxels (int): Maximum number of voxels this function creates.\\n            For second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: [M, max_points, ndim] float tensor. only contain points.\\n            coordinates: [M, 3] int32 tensor.\\n            num_points_per_voxel: [M] int32 tensor.\\n    '\n    if not isinstance(voxel_size, np.ndarray):\n        voxel_size = np.array(voxel_size, dtype=points.dtype)\n    if not isinstance(coors_range, np.ndarray):\n        coors_range = np.array(coors_range, dtype=points.dtype)\n    voxelmap_shape = (coors_range[3:] - coors_range[:3]) / voxel_size\n    voxelmap_shape = tuple(np.round(voxelmap_shape).astype(np.int32).tolist())\n    if reverse_index:\n        voxelmap_shape = voxelmap_shape[::-1]\n    num_points_per_voxel = np.zeros(shape=(max_voxels,), dtype=np.int32)\n    coor_to_voxelidx = -np.ones(shape=voxelmap_shape, dtype=np.int32)\n    voxels = np.zeros(shape=(max_voxels, max_points, points.shape[-1]), dtype=points.dtype)\n    coors = np.zeros(shape=(max_voxels, 3), dtype=np.int32)\n    if reverse_index:\n        voxel_num = _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    else:\n        voxel_num = _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    coors = coors[:voxel_num]\n    voxels = voxels[:voxel_num]\n    num_points_per_voxel = num_points_per_voxel[:voxel_num]\n    return (voxels, coors, num_points_per_voxel)",
            "def points_to_voxel(points, voxel_size, coors_range, max_points=35, reverse_index=True, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Voxel range.\\n            format: xyzxyz, minmax\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        reverse_index (bool): Whether return reversed coordinates.\\n            if points has xyz format and reverse_index is True, output\\n            coordinates will be zyx format, but points in features always\\n            xyz format.\\n        max_voxels (int): Maximum number of voxels this function creates.\\n            For second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: [M, max_points, ndim] float tensor. only contain points.\\n            coordinates: [M, 3] int32 tensor.\\n            num_points_per_voxel: [M] int32 tensor.\\n    '\n    if not isinstance(voxel_size, np.ndarray):\n        voxel_size = np.array(voxel_size, dtype=points.dtype)\n    if not isinstance(coors_range, np.ndarray):\n        coors_range = np.array(coors_range, dtype=points.dtype)\n    voxelmap_shape = (coors_range[3:] - coors_range[:3]) / voxel_size\n    voxelmap_shape = tuple(np.round(voxelmap_shape).astype(np.int32).tolist())\n    if reverse_index:\n        voxelmap_shape = voxelmap_shape[::-1]\n    num_points_per_voxel = np.zeros(shape=(max_voxels,), dtype=np.int32)\n    coor_to_voxelidx = -np.ones(shape=voxelmap_shape, dtype=np.int32)\n    voxels = np.zeros(shape=(max_voxels, max_points, points.shape[-1]), dtype=points.dtype)\n    coors = np.zeros(shape=(max_voxels, 3), dtype=np.int32)\n    if reverse_index:\n        voxel_num = _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    else:\n        voxel_num = _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    coors = coors[:voxel_num]\n    voxels = voxels[:voxel_num]\n    num_points_per_voxel = num_points_per_voxel[:voxel_num]\n    return (voxels, coors, num_points_per_voxel)",
            "def points_to_voxel(points, voxel_size, coors_range, max_points=35, reverse_index=True, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Voxel range.\\n            format: xyzxyz, minmax\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        reverse_index (bool): Whether return reversed coordinates.\\n            if points has xyz format and reverse_index is True, output\\n            coordinates will be zyx format, but points in features always\\n            xyz format.\\n        max_voxels (int): Maximum number of voxels this function creates.\\n            For second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: [M, max_points, ndim] float tensor. only contain points.\\n            coordinates: [M, 3] int32 tensor.\\n            num_points_per_voxel: [M] int32 tensor.\\n    '\n    if not isinstance(voxel_size, np.ndarray):\n        voxel_size = np.array(voxel_size, dtype=points.dtype)\n    if not isinstance(coors_range, np.ndarray):\n        coors_range = np.array(coors_range, dtype=points.dtype)\n    voxelmap_shape = (coors_range[3:] - coors_range[:3]) / voxel_size\n    voxelmap_shape = tuple(np.round(voxelmap_shape).astype(np.int32).tolist())\n    if reverse_index:\n        voxelmap_shape = voxelmap_shape[::-1]\n    num_points_per_voxel = np.zeros(shape=(max_voxels,), dtype=np.int32)\n    coor_to_voxelidx = -np.ones(shape=voxelmap_shape, dtype=np.int32)\n    voxels = np.zeros(shape=(max_voxels, max_points, points.shape[-1]), dtype=points.dtype)\n    coors = np.zeros(shape=(max_voxels, 3), dtype=np.int32)\n    if reverse_index:\n        voxel_num = _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    else:\n        voxel_num = _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    coors = coors[:voxel_num]\n    voxels = voxels[:voxel_num]\n    num_points_per_voxel = num_points_per_voxel[:voxel_num]\n    return (voxels, coors, num_points_per_voxel)",
            "def points_to_voxel(points, voxel_size, coors_range, max_points=35, reverse_index=True, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Voxel range.\\n            format: xyzxyz, minmax\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        reverse_index (bool): Whether return reversed coordinates.\\n            if points has xyz format and reverse_index is True, output\\n            coordinates will be zyx format, but points in features always\\n            xyz format.\\n        max_voxels (int): Maximum number of voxels this function creates.\\n            For second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: [M, max_points, ndim] float tensor. only contain points.\\n            coordinates: [M, 3] int32 tensor.\\n            num_points_per_voxel: [M] int32 tensor.\\n    '\n    if not isinstance(voxel_size, np.ndarray):\n        voxel_size = np.array(voxel_size, dtype=points.dtype)\n    if not isinstance(coors_range, np.ndarray):\n        coors_range = np.array(coors_range, dtype=points.dtype)\n    voxelmap_shape = (coors_range[3:] - coors_range[:3]) / voxel_size\n    voxelmap_shape = tuple(np.round(voxelmap_shape).astype(np.int32).tolist())\n    if reverse_index:\n        voxelmap_shape = voxelmap_shape[::-1]\n    num_points_per_voxel = np.zeros(shape=(max_voxels,), dtype=np.int32)\n    coor_to_voxelidx = -np.ones(shape=voxelmap_shape, dtype=np.int32)\n    voxels = np.zeros(shape=(max_voxels, max_points, points.shape[-1]), dtype=points.dtype)\n    coors = np.zeros(shape=(max_voxels, 3), dtype=np.int32)\n    if reverse_index:\n        voxel_num = _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    else:\n        voxel_num = _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points, max_voxels)\n    coors = coors[:voxel_num]\n    voxels = voxels[:voxel_num]\n    num_points_per_voxel = num_points_per_voxel[:voxel_num]\n    return (voxels, coors, num_points_per_voxel)"
        ]
    },
    {
        "func_name": "_points_to_voxel_reverse_kernel",
        "original": "@numba.jit(nopython=True)\ndef _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    \"\"\"convert kitti points(N, >=3) to voxels.\n\n    Args:\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\n            points[:, 3:] contain other information such as reflectivity.\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\n            format: xyzxyz, minmax\n        num_points_per_voxel (int): Number of points per voxel.\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\n            which has the same shape as the complete voxel map. It indicates\n            the index of each corresponding voxel.\n        voxels (np.ndarray): Created empty voxels.\n        coors (np.ndarray): Created coordinates of each voxel.\n        max_points (int): Indicate maximum points contained in a voxel.\n        max_voxels (int): Maximum number of voxels this function create.\n            for second, 20000 is a good choice. Points should be shuffled for\n            randomness before this function because max_voxels drops points.\n\n    Returns:\n        tuple[np.ndarray]:\n            voxels: Shape [M, max_points, ndim], only contain points.\n            coordinates: Shape [M, 3].\n            num_points_per_voxel: Shape [M].\n    \"\"\"\n    N = points.shape[0]\n    ndim = 3\n    ndim_minus_1 = ndim - 1\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[ndim_minus_1 - j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
        "mutated": [
            "@numba.jit(nopython=True)\ndef _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    ndim_minus_1 = ndim - 1\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[ndim_minus_1 - j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
            "@numba.jit(nopython=True)\ndef _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    ndim_minus_1 = ndim - 1\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[ndim_minus_1 - j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
            "@numba.jit(nopython=True)\ndef _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    ndim_minus_1 = ndim - 1\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[ndim_minus_1 - j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
            "@numba.jit(nopython=True)\ndef _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    ndim_minus_1 = ndim - 1\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[ndim_minus_1 - j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
            "@numba.jit(nopython=True)\ndef _points_to_voxel_reverse_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    ndim_minus_1 = ndim - 1\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[ndim_minus_1 - j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num"
        ]
    },
    {
        "func_name": "_points_to_voxel_kernel",
        "original": "@numba.jit(nopython=True)\ndef _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    \"\"\"convert kitti points(N, >=3) to voxels.\n\n    Args:\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\n            points[:, 3:] contain other information such as reflectivity.\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size.\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\n            format: xyzxyz, minmax\n        num_points_per_voxel (int): Number of points per voxel.\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\n            which has the same shape as the complete voxel map. It indicates\n            the index of each corresponding voxel.\n        voxels (np.ndarray): Created empty voxels.\n        coors (np.ndarray): Created coordinates of each voxel.\n        max_points (int): Indicate maximum points contained in a voxel.\n        max_voxels (int): Maximum number of voxels this function create.\n            for second, 20000 is a good choice. Points should be shuffled for\n            randomness before this function because max_voxels drops points.\n\n    Returns:\n        tuple[np.ndarray]:\n            voxels: Shape [M, max_points, ndim], only contain points.\n            coordinates: Shape [M, 3].\n            num_points_per_voxel: Shape [M].\n    \"\"\"\n    N = points.shape[0]\n    ndim = 3\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
        "mutated": [
            "@numba.jit(nopython=True)\ndef _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size.\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
            "@numba.jit(nopython=True)\ndef _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size.\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
            "@numba.jit(nopython=True)\ndef _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size.\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
            "@numba.jit(nopython=True)\ndef _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size.\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num",
            "@numba.jit(nopython=True)\ndef _points_to_voxel_kernel(points, voxel_size, coors_range, num_points_per_voxel, coor_to_voxelidx, voxels, coors, max_points=35, max_voxels=20000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'convert kitti points(N, >=3) to voxels.\\n\\n    Args:\\n        points (np.ndarray): [N, ndim]. points[:, :3] contain xyz points and\\n            points[:, 3:] contain other information such as reflectivity.\\n        voxel_size (list, tuple, np.ndarray): [3] xyz, indicate voxel size.\\n        coors_range (list[float | tuple[float] | ndarray]): Range of voxels.\\n            format: xyzxyz, minmax\\n        num_points_per_voxel (int): Number of points per voxel.\\n        coor_to_voxel_idx (np.ndarray): A voxel grid of shape (D, H, W),\\n            which has the same shape as the complete voxel map. It indicates\\n            the index of each corresponding voxel.\\n        voxels (np.ndarray): Created empty voxels.\\n        coors (np.ndarray): Created coordinates of each voxel.\\n        max_points (int): Indicate maximum points contained in a voxel.\\n        max_voxels (int): Maximum number of voxels this function create.\\n            for second, 20000 is a good choice. Points should be shuffled for\\n            randomness before this function because max_voxels drops points.\\n\\n    Returns:\\n        tuple[np.ndarray]:\\n            voxels: Shape [M, max_points, ndim], only contain points.\\n            coordinates: Shape [M, 3].\\n            num_points_per_voxel: Shape [M].\\n    '\n    N = points.shape[0]\n    ndim = 3\n    grid_size = (coors_range[3:] - coors_range[:3]) / voxel_size\n    grid_size = np.round(grid_size, 0, grid_size).astype(np.int32)\n    coor = np.zeros(shape=(3,), dtype=np.int32)\n    voxel_num = 0\n    failed = False\n    for i in range(N):\n        failed = False\n        for j in range(ndim):\n            c = np.floor((points[i, j] - coors_range[j]) / voxel_size[j])\n            if c < 0 or c >= grid_size[j]:\n                failed = True\n                break\n            coor[j] = c\n        if failed:\n            continue\n        voxelidx = coor_to_voxelidx[coor[0], coor[1], coor[2]]\n        if voxelidx == -1:\n            voxelidx = voxel_num\n            if voxel_num >= max_voxels:\n                continue\n            voxel_num += 1\n            coor_to_voxelidx[coor[0], coor[1], coor[2]] = voxelidx\n            coors[voxelidx] = coor\n        num = num_points_per_voxel[voxelidx]\n        if num < max_points:\n            voxels[voxelidx, num] = points[i]\n            num_points_per_voxel[voxelidx] += 1\n    return voxel_num"
        ]
    }
]