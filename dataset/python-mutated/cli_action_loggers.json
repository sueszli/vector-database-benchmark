[
    {
        "func_name": "register_pre_exec_callback",
        "original": "def register_pre_exec_callback(action_logger):\n    \"\"\"Register more action_logger function callback for pre-execution.\n\n    This function callback is expected to be called with keyword args.\n    For more about the arguments that is being passed to the callback,\n    refer to airflow.utils.cli.action_logging().\n\n    :param action_logger: An action logger function\n    :return: None\n    \"\"\"\n    logging.debug('Adding %s to pre execution callback', action_logger)\n    __pre_exec_callbacks.append(action_logger)",
        "mutated": [
            "def register_pre_exec_callback(action_logger):\n    if False:\n        i = 10\n    'Register more action_logger function callback for pre-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to pre execution callback', action_logger)\n    __pre_exec_callbacks.append(action_logger)",
            "def register_pre_exec_callback(action_logger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Register more action_logger function callback for pre-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to pre execution callback', action_logger)\n    __pre_exec_callbacks.append(action_logger)",
            "def register_pre_exec_callback(action_logger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Register more action_logger function callback for pre-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to pre execution callback', action_logger)\n    __pre_exec_callbacks.append(action_logger)",
            "def register_pre_exec_callback(action_logger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Register more action_logger function callback for pre-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to pre execution callback', action_logger)\n    __pre_exec_callbacks.append(action_logger)",
            "def register_pre_exec_callback(action_logger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Register more action_logger function callback for pre-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to pre execution callback', action_logger)\n    __pre_exec_callbacks.append(action_logger)"
        ]
    },
    {
        "func_name": "register_post_exec_callback",
        "original": "def register_post_exec_callback(action_logger):\n    \"\"\"Register more action_logger function callback for post-execution.\n\n    This function callback is expected to be called with keyword args.\n    For more about the arguments that is being passed to the callback,\n    refer to airflow.utils.cli.action_logging().\n\n    :param action_logger: An action logger function\n    :return: None\n    \"\"\"\n    logging.debug('Adding %s to post execution callback', action_logger)\n    __post_exec_callbacks.append(action_logger)",
        "mutated": [
            "def register_post_exec_callback(action_logger):\n    if False:\n        i = 10\n    'Register more action_logger function callback for post-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to post execution callback', action_logger)\n    __post_exec_callbacks.append(action_logger)",
            "def register_post_exec_callback(action_logger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Register more action_logger function callback for post-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to post execution callback', action_logger)\n    __post_exec_callbacks.append(action_logger)",
            "def register_post_exec_callback(action_logger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Register more action_logger function callback for post-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to post execution callback', action_logger)\n    __post_exec_callbacks.append(action_logger)",
            "def register_post_exec_callback(action_logger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Register more action_logger function callback for post-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to post execution callback', action_logger)\n    __post_exec_callbacks.append(action_logger)",
            "def register_post_exec_callback(action_logger):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Register more action_logger function callback for post-execution.\\n\\n    This function callback is expected to be called with keyword args.\\n    For more about the arguments that is being passed to the callback,\\n    refer to airflow.utils.cli.action_logging().\\n\\n    :param action_logger: An action logger function\\n    :return: None\\n    '\n    logging.debug('Adding %s to post execution callback', action_logger)\n    __post_exec_callbacks.append(action_logger)"
        ]
    },
    {
        "func_name": "on_pre_execution",
        "original": "def on_pre_execution(**kwargs):\n    \"\"\"Call callbacks before execution.\n\n    Note that any exception from callback will be logged but won't be propagated.\n\n    :param kwargs:\n    :return: None\n    \"\"\"\n    logging.debug('Calling callbacks: %s', __pre_exec_callbacks)\n    for callback in __pre_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on pre-execution callback using %s', callback)",
        "mutated": [
            "def on_pre_execution(**kwargs):\n    if False:\n        i = 10\n    \"Call callbacks before execution.\\n\\n    Note that any exception from callback will be logged but won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __pre_exec_callbacks)\n    for callback in __pre_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on pre-execution callback using %s', callback)",
            "def on_pre_execution(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Call callbacks before execution.\\n\\n    Note that any exception from callback will be logged but won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __pre_exec_callbacks)\n    for callback in __pre_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on pre-execution callback using %s', callback)",
            "def on_pre_execution(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Call callbacks before execution.\\n\\n    Note that any exception from callback will be logged but won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __pre_exec_callbacks)\n    for callback in __pre_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on pre-execution callback using %s', callback)",
            "def on_pre_execution(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Call callbacks before execution.\\n\\n    Note that any exception from callback will be logged but won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __pre_exec_callbacks)\n    for callback in __pre_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on pre-execution callback using %s', callback)",
            "def on_pre_execution(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Call callbacks before execution.\\n\\n    Note that any exception from callback will be logged but won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __pre_exec_callbacks)\n    for callback in __pre_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on pre-execution callback using %s', callback)"
        ]
    },
    {
        "func_name": "on_post_execution",
        "original": "def on_post_execution(**kwargs):\n    \"\"\"Call callbacks after execution.\n\n    As it's being called after execution, it can capture status of execution,\n    duration, etc. Note that any exception from callback will be logged but\n    won't be propagated.\n\n    :param kwargs:\n    :return: None\n    \"\"\"\n    logging.debug('Calling callbacks: %s', __post_exec_callbacks)\n    for callback in __post_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on post-execution callback using %s', callback)",
        "mutated": [
            "def on_post_execution(**kwargs):\n    if False:\n        i = 10\n    \"Call callbacks after execution.\\n\\n    As it's being called after execution, it can capture status of execution,\\n    duration, etc. Note that any exception from callback will be logged but\\n    won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __post_exec_callbacks)\n    for callback in __post_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on post-execution callback using %s', callback)",
            "def on_post_execution(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Call callbacks after execution.\\n\\n    As it's being called after execution, it can capture status of execution,\\n    duration, etc. Note that any exception from callback will be logged but\\n    won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __post_exec_callbacks)\n    for callback in __post_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on post-execution callback using %s', callback)",
            "def on_post_execution(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Call callbacks after execution.\\n\\n    As it's being called after execution, it can capture status of execution,\\n    duration, etc. Note that any exception from callback will be logged but\\n    won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __post_exec_callbacks)\n    for callback in __post_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on post-execution callback using %s', callback)",
            "def on_post_execution(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Call callbacks after execution.\\n\\n    As it's being called after execution, it can capture status of execution,\\n    duration, etc. Note that any exception from callback will be logged but\\n    won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __post_exec_callbacks)\n    for callback in __post_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on post-execution callback using %s', callback)",
            "def on_post_execution(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Call callbacks after execution.\\n\\n    As it's being called after execution, it can capture status of execution,\\n    duration, etc. Note that any exception from callback will be logged but\\n    won't be propagated.\\n\\n    :param kwargs:\\n    :return: None\\n    \"\n    logging.debug('Calling callbacks: %s', __post_exec_callbacks)\n    for callback in __post_exec_callbacks:\n        try:\n            callback(**kwargs)\n        except Exception:\n            logging.exception('Failed on post-execution callback using %s', callback)"
        ]
    },
    {
        "func_name": "default_action_log",
        "original": "def default_action_log(sub_command, user, task_id, dag_id, execution_date, host_name, full_command, **_):\n    \"\"\"\n    Behave similar to ``action_logging``; default action logger callback.\n\n    The difference is this function uses the global ORM session, and pushes a\n    ``Log`` row into the database instead of actually logging.\n    \"\"\"\n    from sqlalchemy.exc import OperationalError, ProgrammingError\n    from airflow.models.log import Log\n    from airflow.utils import timezone\n    from airflow.utils.session import create_session\n    try:\n        with create_session() as session:\n            extra = json.dumps({'host_name': host_name, 'full_command': full_command})\n            session.bulk_insert_mappings(Log, [{'event': f'cli_{sub_command}', 'task_instance': None, 'owner': user, 'extra': extra, 'task_id': task_id, 'dag_id': dag_id, 'execution_date': execution_date, 'dttm': timezone.utcnow()}])\n    except (OperationalError, ProgrammingError) as e:\n        expected = ['\"log\" does not exist', 'no such table', \"log' doesn't exist\", \"Invalid object name 'log'\"]\n        error_is_ok = e.args and any((x in e.args[0] for x in expected))\n        if not error_is_ok:\n            logging.warning('Failed to log action %s', e)\n    except Exception as e:\n        logging.warning('Failed to log action %s', e)",
        "mutated": [
            "def default_action_log(sub_command, user, task_id, dag_id, execution_date, host_name, full_command, **_):\n    if False:\n        i = 10\n    '\\n    Behave similar to ``action_logging``; default action logger callback.\\n\\n    The difference is this function uses the global ORM session, and pushes a\\n    ``Log`` row into the database instead of actually logging.\\n    '\n    from sqlalchemy.exc import OperationalError, ProgrammingError\n    from airflow.models.log import Log\n    from airflow.utils import timezone\n    from airflow.utils.session import create_session\n    try:\n        with create_session() as session:\n            extra = json.dumps({'host_name': host_name, 'full_command': full_command})\n            session.bulk_insert_mappings(Log, [{'event': f'cli_{sub_command}', 'task_instance': None, 'owner': user, 'extra': extra, 'task_id': task_id, 'dag_id': dag_id, 'execution_date': execution_date, 'dttm': timezone.utcnow()}])\n    except (OperationalError, ProgrammingError) as e:\n        expected = ['\"log\" does not exist', 'no such table', \"log' doesn't exist\", \"Invalid object name 'log'\"]\n        error_is_ok = e.args and any((x in e.args[0] for x in expected))\n        if not error_is_ok:\n            logging.warning('Failed to log action %s', e)\n    except Exception as e:\n        logging.warning('Failed to log action %s', e)",
            "def default_action_log(sub_command, user, task_id, dag_id, execution_date, host_name, full_command, **_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Behave similar to ``action_logging``; default action logger callback.\\n\\n    The difference is this function uses the global ORM session, and pushes a\\n    ``Log`` row into the database instead of actually logging.\\n    '\n    from sqlalchemy.exc import OperationalError, ProgrammingError\n    from airflow.models.log import Log\n    from airflow.utils import timezone\n    from airflow.utils.session import create_session\n    try:\n        with create_session() as session:\n            extra = json.dumps({'host_name': host_name, 'full_command': full_command})\n            session.bulk_insert_mappings(Log, [{'event': f'cli_{sub_command}', 'task_instance': None, 'owner': user, 'extra': extra, 'task_id': task_id, 'dag_id': dag_id, 'execution_date': execution_date, 'dttm': timezone.utcnow()}])\n    except (OperationalError, ProgrammingError) as e:\n        expected = ['\"log\" does not exist', 'no such table', \"log' doesn't exist\", \"Invalid object name 'log'\"]\n        error_is_ok = e.args and any((x in e.args[0] for x in expected))\n        if not error_is_ok:\n            logging.warning('Failed to log action %s', e)\n    except Exception as e:\n        logging.warning('Failed to log action %s', e)",
            "def default_action_log(sub_command, user, task_id, dag_id, execution_date, host_name, full_command, **_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Behave similar to ``action_logging``; default action logger callback.\\n\\n    The difference is this function uses the global ORM session, and pushes a\\n    ``Log`` row into the database instead of actually logging.\\n    '\n    from sqlalchemy.exc import OperationalError, ProgrammingError\n    from airflow.models.log import Log\n    from airflow.utils import timezone\n    from airflow.utils.session import create_session\n    try:\n        with create_session() as session:\n            extra = json.dumps({'host_name': host_name, 'full_command': full_command})\n            session.bulk_insert_mappings(Log, [{'event': f'cli_{sub_command}', 'task_instance': None, 'owner': user, 'extra': extra, 'task_id': task_id, 'dag_id': dag_id, 'execution_date': execution_date, 'dttm': timezone.utcnow()}])\n    except (OperationalError, ProgrammingError) as e:\n        expected = ['\"log\" does not exist', 'no such table', \"log' doesn't exist\", \"Invalid object name 'log'\"]\n        error_is_ok = e.args and any((x in e.args[0] for x in expected))\n        if not error_is_ok:\n            logging.warning('Failed to log action %s', e)\n    except Exception as e:\n        logging.warning('Failed to log action %s', e)",
            "def default_action_log(sub_command, user, task_id, dag_id, execution_date, host_name, full_command, **_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Behave similar to ``action_logging``; default action logger callback.\\n\\n    The difference is this function uses the global ORM session, and pushes a\\n    ``Log`` row into the database instead of actually logging.\\n    '\n    from sqlalchemy.exc import OperationalError, ProgrammingError\n    from airflow.models.log import Log\n    from airflow.utils import timezone\n    from airflow.utils.session import create_session\n    try:\n        with create_session() as session:\n            extra = json.dumps({'host_name': host_name, 'full_command': full_command})\n            session.bulk_insert_mappings(Log, [{'event': f'cli_{sub_command}', 'task_instance': None, 'owner': user, 'extra': extra, 'task_id': task_id, 'dag_id': dag_id, 'execution_date': execution_date, 'dttm': timezone.utcnow()}])\n    except (OperationalError, ProgrammingError) as e:\n        expected = ['\"log\" does not exist', 'no such table', \"log' doesn't exist\", \"Invalid object name 'log'\"]\n        error_is_ok = e.args and any((x in e.args[0] for x in expected))\n        if not error_is_ok:\n            logging.warning('Failed to log action %s', e)\n    except Exception as e:\n        logging.warning('Failed to log action %s', e)",
            "def default_action_log(sub_command, user, task_id, dag_id, execution_date, host_name, full_command, **_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Behave similar to ``action_logging``; default action logger callback.\\n\\n    The difference is this function uses the global ORM session, and pushes a\\n    ``Log`` row into the database instead of actually logging.\\n    '\n    from sqlalchemy.exc import OperationalError, ProgrammingError\n    from airflow.models.log import Log\n    from airflow.utils import timezone\n    from airflow.utils.session import create_session\n    try:\n        with create_session() as session:\n            extra = json.dumps({'host_name': host_name, 'full_command': full_command})\n            session.bulk_insert_mappings(Log, [{'event': f'cli_{sub_command}', 'task_instance': None, 'owner': user, 'extra': extra, 'task_id': task_id, 'dag_id': dag_id, 'execution_date': execution_date, 'dttm': timezone.utcnow()}])\n    except (OperationalError, ProgrammingError) as e:\n        expected = ['\"log\" does not exist', 'no such table', \"log' doesn't exist\", \"Invalid object name 'log'\"]\n        error_is_ok = e.args and any((x in e.args[0] for x in expected))\n        if not error_is_ok:\n            logging.warning('Failed to log action %s', e)\n    except Exception as e:\n        logging.warning('Failed to log action %s', e)"
        ]
    }
]