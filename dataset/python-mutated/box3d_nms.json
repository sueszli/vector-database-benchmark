[
    {
        "func_name": "box3d_multiclass_nms",
        "original": "def box3d_multiclass_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_scores, score_thr, max_num, cfg, mlvl_dir_scores=None, mlvl_attr_scores=None, mlvl_bboxes2d=None):\n    \"\"\"Multi-class NMS for 3D boxes. The IoU used for NMS is defined as the 2D\n    IoU between BEV boxes.\n\n    Args:\n        mlvl_bboxes (torch.Tensor): Multi-level boxes with shape (N, M).\n            M is the dimensions of boxes.\n        mlvl_bboxes_for_nms (torch.Tensor): Multi-level boxes with shape\n            (N, 5) ([x1, y1, x2, y2, ry]). N is the number of boxes.\n            The coordinate system of the BEV boxes is counterclockwise.\n        mlvl_scores (torch.Tensor): Multi-level boxes with shape\n            (N, C + 1). N is the number of boxes. C is the number of classes.\n        score_thr (float): Score threshold to filter boxes with low\n            confidence.\n        max_num (int): Maximum number of boxes will be kept.\n        cfg (dict): Configuration dict of NMS.\n        mlvl_dir_scores (torch.Tensor, optional): Multi-level scores\n            of direction classifier. Defaults to None.\n        mlvl_attr_scores (torch.Tensor, optional): Multi-level scores\n            of attribute classifier. Defaults to None.\n        mlvl_bboxes2d (torch.Tensor, optional): Multi-level 2D bounding\n            boxes. Defaults to None.\n\n    Returns:\n        tuple[torch.Tensor]: Return results after nms, including 3D\n            bounding boxes, scores, labels, direction scores, attribute\n            scores (optional) and 2D bounding boxes (optional).\n    \"\"\"\n    num_classes = mlvl_scores.shape[1] - 1\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    attr_scores = []\n    bboxes2d = []\n    for i in range(0, num_classes):\n        cls_inds = mlvl_scores[:, i] > score_thr\n        if not cls_inds.any():\n            continue\n        _scores = mlvl_scores[cls_inds, i]\n        _bboxes_for_nms = mlvl_bboxes_for_nms[cls_inds, :]\n        if cfg.use_rotate_nms:\n            nms_func = nms_bev\n        else:\n            nms_func = nms_normal_bev\n        selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n        _mlvl_bboxes = mlvl_bboxes[cls_inds, :]\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        cls_label = mlvl_bboxes.new_full((len(selected),), i, dtype=torch.long)\n        labels.append(cls_label)\n        if mlvl_dir_scores is not None:\n            _mlvl_dir_scores = mlvl_dir_scores[cls_inds]\n            dir_scores.append(_mlvl_dir_scores[selected])\n        if mlvl_attr_scores is not None:\n            _mlvl_attr_scores = mlvl_attr_scores[cls_inds]\n            attr_scores.append(_mlvl_attr_scores[selected])\n        if mlvl_bboxes2d is not None:\n            _mlvl_bboxes2d = mlvl_bboxes2d[cls_inds]\n            bboxes2d.append(_mlvl_bboxes2d[selected])\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if mlvl_dir_scores is not None:\n            dir_scores = torch.cat(dir_scores, dim=0)\n        if mlvl_attr_scores is not None:\n            attr_scores = torch.cat(attr_scores, dim=0)\n        if mlvl_bboxes2d is not None:\n            bboxes2d = torch.cat(bboxes2d, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            if mlvl_dir_scores is not None:\n                dir_scores = dir_scores[inds]\n            if mlvl_attr_scores is not None:\n                attr_scores = attr_scores[inds]\n            if mlvl_bboxes2d is not None:\n                bboxes2d = bboxes2d[inds]\n    else:\n        bboxes = mlvl_scores.new_zeros((0, mlvl_bboxes.size(-1)))\n        scores = mlvl_scores.new_zeros((0,))\n        labels = mlvl_scores.new_zeros((0,), dtype=torch.long)\n        if mlvl_dir_scores is not None:\n            dir_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_attr_scores is not None:\n            attr_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_bboxes2d is not None:\n            bboxes2d = mlvl_scores.new_zeros((0, 4))\n    results = (bboxes, scores, labels)\n    if mlvl_dir_scores is not None:\n        results = results + (dir_scores,)\n    if mlvl_attr_scores is not None:\n        results = results + (attr_scores,)\n    if mlvl_bboxes2d is not None:\n        results = results + (bboxes2d,)\n    return results",
        "mutated": [
            "def box3d_multiclass_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_scores, score_thr, max_num, cfg, mlvl_dir_scores=None, mlvl_attr_scores=None, mlvl_bboxes2d=None):\n    if False:\n        i = 10\n    'Multi-class NMS for 3D boxes. The IoU used for NMS is defined as the 2D\\n    IoU between BEV boxes.\\n\\n    Args:\\n        mlvl_bboxes (torch.Tensor): Multi-level boxes with shape (N, M).\\n            M is the dimensions of boxes.\\n        mlvl_bboxes_for_nms (torch.Tensor): Multi-level boxes with shape\\n            (N, 5) ([x1, y1, x2, y2, ry]). N is the number of boxes.\\n            The coordinate system of the BEV boxes is counterclockwise.\\n        mlvl_scores (torch.Tensor): Multi-level boxes with shape\\n            (N, C + 1). N is the number of boxes. C is the number of classes.\\n        score_thr (float): Score threshold to filter boxes with low\\n            confidence.\\n        max_num (int): Maximum number of boxes will be kept.\\n        cfg (dict): Configuration dict of NMS.\\n        mlvl_dir_scores (torch.Tensor, optional): Multi-level scores\\n            of direction classifier. Defaults to None.\\n        mlvl_attr_scores (torch.Tensor, optional): Multi-level scores\\n            of attribute classifier. Defaults to None.\\n        mlvl_bboxes2d (torch.Tensor, optional): Multi-level 2D bounding\\n            boxes. Defaults to None.\\n\\n    Returns:\\n        tuple[torch.Tensor]: Return results after nms, including 3D\\n            bounding boxes, scores, labels, direction scores, attribute\\n            scores (optional) and 2D bounding boxes (optional).\\n    '\n    num_classes = mlvl_scores.shape[1] - 1\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    attr_scores = []\n    bboxes2d = []\n    for i in range(0, num_classes):\n        cls_inds = mlvl_scores[:, i] > score_thr\n        if not cls_inds.any():\n            continue\n        _scores = mlvl_scores[cls_inds, i]\n        _bboxes_for_nms = mlvl_bboxes_for_nms[cls_inds, :]\n        if cfg.use_rotate_nms:\n            nms_func = nms_bev\n        else:\n            nms_func = nms_normal_bev\n        selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n        _mlvl_bboxes = mlvl_bboxes[cls_inds, :]\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        cls_label = mlvl_bboxes.new_full((len(selected),), i, dtype=torch.long)\n        labels.append(cls_label)\n        if mlvl_dir_scores is not None:\n            _mlvl_dir_scores = mlvl_dir_scores[cls_inds]\n            dir_scores.append(_mlvl_dir_scores[selected])\n        if mlvl_attr_scores is not None:\n            _mlvl_attr_scores = mlvl_attr_scores[cls_inds]\n            attr_scores.append(_mlvl_attr_scores[selected])\n        if mlvl_bboxes2d is not None:\n            _mlvl_bboxes2d = mlvl_bboxes2d[cls_inds]\n            bboxes2d.append(_mlvl_bboxes2d[selected])\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if mlvl_dir_scores is not None:\n            dir_scores = torch.cat(dir_scores, dim=0)\n        if mlvl_attr_scores is not None:\n            attr_scores = torch.cat(attr_scores, dim=0)\n        if mlvl_bboxes2d is not None:\n            bboxes2d = torch.cat(bboxes2d, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            if mlvl_dir_scores is not None:\n                dir_scores = dir_scores[inds]\n            if mlvl_attr_scores is not None:\n                attr_scores = attr_scores[inds]\n            if mlvl_bboxes2d is not None:\n                bboxes2d = bboxes2d[inds]\n    else:\n        bboxes = mlvl_scores.new_zeros((0, mlvl_bboxes.size(-1)))\n        scores = mlvl_scores.new_zeros((0,))\n        labels = mlvl_scores.new_zeros((0,), dtype=torch.long)\n        if mlvl_dir_scores is not None:\n            dir_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_attr_scores is not None:\n            attr_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_bboxes2d is not None:\n            bboxes2d = mlvl_scores.new_zeros((0, 4))\n    results = (bboxes, scores, labels)\n    if mlvl_dir_scores is not None:\n        results = results + (dir_scores,)\n    if mlvl_attr_scores is not None:\n        results = results + (attr_scores,)\n    if mlvl_bboxes2d is not None:\n        results = results + (bboxes2d,)\n    return results",
            "def box3d_multiclass_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_scores, score_thr, max_num, cfg, mlvl_dir_scores=None, mlvl_attr_scores=None, mlvl_bboxes2d=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Multi-class NMS for 3D boxes. The IoU used for NMS is defined as the 2D\\n    IoU between BEV boxes.\\n\\n    Args:\\n        mlvl_bboxes (torch.Tensor): Multi-level boxes with shape (N, M).\\n            M is the dimensions of boxes.\\n        mlvl_bboxes_for_nms (torch.Tensor): Multi-level boxes with shape\\n            (N, 5) ([x1, y1, x2, y2, ry]). N is the number of boxes.\\n            The coordinate system of the BEV boxes is counterclockwise.\\n        mlvl_scores (torch.Tensor): Multi-level boxes with shape\\n            (N, C + 1). N is the number of boxes. C is the number of classes.\\n        score_thr (float): Score threshold to filter boxes with low\\n            confidence.\\n        max_num (int): Maximum number of boxes will be kept.\\n        cfg (dict): Configuration dict of NMS.\\n        mlvl_dir_scores (torch.Tensor, optional): Multi-level scores\\n            of direction classifier. Defaults to None.\\n        mlvl_attr_scores (torch.Tensor, optional): Multi-level scores\\n            of attribute classifier. Defaults to None.\\n        mlvl_bboxes2d (torch.Tensor, optional): Multi-level 2D bounding\\n            boxes. Defaults to None.\\n\\n    Returns:\\n        tuple[torch.Tensor]: Return results after nms, including 3D\\n            bounding boxes, scores, labels, direction scores, attribute\\n            scores (optional) and 2D bounding boxes (optional).\\n    '\n    num_classes = mlvl_scores.shape[1] - 1\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    attr_scores = []\n    bboxes2d = []\n    for i in range(0, num_classes):\n        cls_inds = mlvl_scores[:, i] > score_thr\n        if not cls_inds.any():\n            continue\n        _scores = mlvl_scores[cls_inds, i]\n        _bboxes_for_nms = mlvl_bboxes_for_nms[cls_inds, :]\n        if cfg.use_rotate_nms:\n            nms_func = nms_bev\n        else:\n            nms_func = nms_normal_bev\n        selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n        _mlvl_bboxes = mlvl_bboxes[cls_inds, :]\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        cls_label = mlvl_bboxes.new_full((len(selected),), i, dtype=torch.long)\n        labels.append(cls_label)\n        if mlvl_dir_scores is not None:\n            _mlvl_dir_scores = mlvl_dir_scores[cls_inds]\n            dir_scores.append(_mlvl_dir_scores[selected])\n        if mlvl_attr_scores is not None:\n            _mlvl_attr_scores = mlvl_attr_scores[cls_inds]\n            attr_scores.append(_mlvl_attr_scores[selected])\n        if mlvl_bboxes2d is not None:\n            _mlvl_bboxes2d = mlvl_bboxes2d[cls_inds]\n            bboxes2d.append(_mlvl_bboxes2d[selected])\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if mlvl_dir_scores is not None:\n            dir_scores = torch.cat(dir_scores, dim=0)\n        if mlvl_attr_scores is not None:\n            attr_scores = torch.cat(attr_scores, dim=0)\n        if mlvl_bboxes2d is not None:\n            bboxes2d = torch.cat(bboxes2d, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            if mlvl_dir_scores is not None:\n                dir_scores = dir_scores[inds]\n            if mlvl_attr_scores is not None:\n                attr_scores = attr_scores[inds]\n            if mlvl_bboxes2d is not None:\n                bboxes2d = bboxes2d[inds]\n    else:\n        bboxes = mlvl_scores.new_zeros((0, mlvl_bboxes.size(-1)))\n        scores = mlvl_scores.new_zeros((0,))\n        labels = mlvl_scores.new_zeros((0,), dtype=torch.long)\n        if mlvl_dir_scores is not None:\n            dir_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_attr_scores is not None:\n            attr_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_bboxes2d is not None:\n            bboxes2d = mlvl_scores.new_zeros((0, 4))\n    results = (bboxes, scores, labels)\n    if mlvl_dir_scores is not None:\n        results = results + (dir_scores,)\n    if mlvl_attr_scores is not None:\n        results = results + (attr_scores,)\n    if mlvl_bboxes2d is not None:\n        results = results + (bboxes2d,)\n    return results",
            "def box3d_multiclass_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_scores, score_thr, max_num, cfg, mlvl_dir_scores=None, mlvl_attr_scores=None, mlvl_bboxes2d=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Multi-class NMS for 3D boxes. The IoU used for NMS is defined as the 2D\\n    IoU between BEV boxes.\\n\\n    Args:\\n        mlvl_bboxes (torch.Tensor): Multi-level boxes with shape (N, M).\\n            M is the dimensions of boxes.\\n        mlvl_bboxes_for_nms (torch.Tensor): Multi-level boxes with shape\\n            (N, 5) ([x1, y1, x2, y2, ry]). N is the number of boxes.\\n            The coordinate system of the BEV boxes is counterclockwise.\\n        mlvl_scores (torch.Tensor): Multi-level boxes with shape\\n            (N, C + 1). N is the number of boxes. C is the number of classes.\\n        score_thr (float): Score threshold to filter boxes with low\\n            confidence.\\n        max_num (int): Maximum number of boxes will be kept.\\n        cfg (dict): Configuration dict of NMS.\\n        mlvl_dir_scores (torch.Tensor, optional): Multi-level scores\\n            of direction classifier. Defaults to None.\\n        mlvl_attr_scores (torch.Tensor, optional): Multi-level scores\\n            of attribute classifier. Defaults to None.\\n        mlvl_bboxes2d (torch.Tensor, optional): Multi-level 2D bounding\\n            boxes. Defaults to None.\\n\\n    Returns:\\n        tuple[torch.Tensor]: Return results after nms, including 3D\\n            bounding boxes, scores, labels, direction scores, attribute\\n            scores (optional) and 2D bounding boxes (optional).\\n    '\n    num_classes = mlvl_scores.shape[1] - 1\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    attr_scores = []\n    bboxes2d = []\n    for i in range(0, num_classes):\n        cls_inds = mlvl_scores[:, i] > score_thr\n        if not cls_inds.any():\n            continue\n        _scores = mlvl_scores[cls_inds, i]\n        _bboxes_for_nms = mlvl_bboxes_for_nms[cls_inds, :]\n        if cfg.use_rotate_nms:\n            nms_func = nms_bev\n        else:\n            nms_func = nms_normal_bev\n        selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n        _mlvl_bboxes = mlvl_bboxes[cls_inds, :]\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        cls_label = mlvl_bboxes.new_full((len(selected),), i, dtype=torch.long)\n        labels.append(cls_label)\n        if mlvl_dir_scores is not None:\n            _mlvl_dir_scores = mlvl_dir_scores[cls_inds]\n            dir_scores.append(_mlvl_dir_scores[selected])\n        if mlvl_attr_scores is not None:\n            _mlvl_attr_scores = mlvl_attr_scores[cls_inds]\n            attr_scores.append(_mlvl_attr_scores[selected])\n        if mlvl_bboxes2d is not None:\n            _mlvl_bboxes2d = mlvl_bboxes2d[cls_inds]\n            bboxes2d.append(_mlvl_bboxes2d[selected])\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if mlvl_dir_scores is not None:\n            dir_scores = torch.cat(dir_scores, dim=0)\n        if mlvl_attr_scores is not None:\n            attr_scores = torch.cat(attr_scores, dim=0)\n        if mlvl_bboxes2d is not None:\n            bboxes2d = torch.cat(bboxes2d, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            if mlvl_dir_scores is not None:\n                dir_scores = dir_scores[inds]\n            if mlvl_attr_scores is not None:\n                attr_scores = attr_scores[inds]\n            if mlvl_bboxes2d is not None:\n                bboxes2d = bboxes2d[inds]\n    else:\n        bboxes = mlvl_scores.new_zeros((0, mlvl_bboxes.size(-1)))\n        scores = mlvl_scores.new_zeros((0,))\n        labels = mlvl_scores.new_zeros((0,), dtype=torch.long)\n        if mlvl_dir_scores is not None:\n            dir_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_attr_scores is not None:\n            attr_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_bboxes2d is not None:\n            bboxes2d = mlvl_scores.new_zeros((0, 4))\n    results = (bboxes, scores, labels)\n    if mlvl_dir_scores is not None:\n        results = results + (dir_scores,)\n    if mlvl_attr_scores is not None:\n        results = results + (attr_scores,)\n    if mlvl_bboxes2d is not None:\n        results = results + (bboxes2d,)\n    return results",
            "def box3d_multiclass_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_scores, score_thr, max_num, cfg, mlvl_dir_scores=None, mlvl_attr_scores=None, mlvl_bboxes2d=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Multi-class NMS for 3D boxes. The IoU used for NMS is defined as the 2D\\n    IoU between BEV boxes.\\n\\n    Args:\\n        mlvl_bboxes (torch.Tensor): Multi-level boxes with shape (N, M).\\n            M is the dimensions of boxes.\\n        mlvl_bboxes_for_nms (torch.Tensor): Multi-level boxes with shape\\n            (N, 5) ([x1, y1, x2, y2, ry]). N is the number of boxes.\\n            The coordinate system of the BEV boxes is counterclockwise.\\n        mlvl_scores (torch.Tensor): Multi-level boxes with shape\\n            (N, C + 1). N is the number of boxes. C is the number of classes.\\n        score_thr (float): Score threshold to filter boxes with low\\n            confidence.\\n        max_num (int): Maximum number of boxes will be kept.\\n        cfg (dict): Configuration dict of NMS.\\n        mlvl_dir_scores (torch.Tensor, optional): Multi-level scores\\n            of direction classifier. Defaults to None.\\n        mlvl_attr_scores (torch.Tensor, optional): Multi-level scores\\n            of attribute classifier. Defaults to None.\\n        mlvl_bboxes2d (torch.Tensor, optional): Multi-level 2D bounding\\n            boxes. Defaults to None.\\n\\n    Returns:\\n        tuple[torch.Tensor]: Return results after nms, including 3D\\n            bounding boxes, scores, labels, direction scores, attribute\\n            scores (optional) and 2D bounding boxes (optional).\\n    '\n    num_classes = mlvl_scores.shape[1] - 1\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    attr_scores = []\n    bboxes2d = []\n    for i in range(0, num_classes):\n        cls_inds = mlvl_scores[:, i] > score_thr\n        if not cls_inds.any():\n            continue\n        _scores = mlvl_scores[cls_inds, i]\n        _bboxes_for_nms = mlvl_bboxes_for_nms[cls_inds, :]\n        if cfg.use_rotate_nms:\n            nms_func = nms_bev\n        else:\n            nms_func = nms_normal_bev\n        selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n        _mlvl_bboxes = mlvl_bboxes[cls_inds, :]\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        cls_label = mlvl_bboxes.new_full((len(selected),), i, dtype=torch.long)\n        labels.append(cls_label)\n        if mlvl_dir_scores is not None:\n            _mlvl_dir_scores = mlvl_dir_scores[cls_inds]\n            dir_scores.append(_mlvl_dir_scores[selected])\n        if mlvl_attr_scores is not None:\n            _mlvl_attr_scores = mlvl_attr_scores[cls_inds]\n            attr_scores.append(_mlvl_attr_scores[selected])\n        if mlvl_bboxes2d is not None:\n            _mlvl_bboxes2d = mlvl_bboxes2d[cls_inds]\n            bboxes2d.append(_mlvl_bboxes2d[selected])\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if mlvl_dir_scores is not None:\n            dir_scores = torch.cat(dir_scores, dim=0)\n        if mlvl_attr_scores is not None:\n            attr_scores = torch.cat(attr_scores, dim=0)\n        if mlvl_bboxes2d is not None:\n            bboxes2d = torch.cat(bboxes2d, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            if mlvl_dir_scores is not None:\n                dir_scores = dir_scores[inds]\n            if mlvl_attr_scores is not None:\n                attr_scores = attr_scores[inds]\n            if mlvl_bboxes2d is not None:\n                bboxes2d = bboxes2d[inds]\n    else:\n        bboxes = mlvl_scores.new_zeros((0, mlvl_bboxes.size(-1)))\n        scores = mlvl_scores.new_zeros((0,))\n        labels = mlvl_scores.new_zeros((0,), dtype=torch.long)\n        if mlvl_dir_scores is not None:\n            dir_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_attr_scores is not None:\n            attr_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_bboxes2d is not None:\n            bboxes2d = mlvl_scores.new_zeros((0, 4))\n    results = (bboxes, scores, labels)\n    if mlvl_dir_scores is not None:\n        results = results + (dir_scores,)\n    if mlvl_attr_scores is not None:\n        results = results + (attr_scores,)\n    if mlvl_bboxes2d is not None:\n        results = results + (bboxes2d,)\n    return results",
            "def box3d_multiclass_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_scores, score_thr, max_num, cfg, mlvl_dir_scores=None, mlvl_attr_scores=None, mlvl_bboxes2d=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Multi-class NMS for 3D boxes. The IoU used for NMS is defined as the 2D\\n    IoU between BEV boxes.\\n\\n    Args:\\n        mlvl_bboxes (torch.Tensor): Multi-level boxes with shape (N, M).\\n            M is the dimensions of boxes.\\n        mlvl_bboxes_for_nms (torch.Tensor): Multi-level boxes with shape\\n            (N, 5) ([x1, y1, x2, y2, ry]). N is the number of boxes.\\n            The coordinate system of the BEV boxes is counterclockwise.\\n        mlvl_scores (torch.Tensor): Multi-level boxes with shape\\n            (N, C + 1). N is the number of boxes. C is the number of classes.\\n        score_thr (float): Score threshold to filter boxes with low\\n            confidence.\\n        max_num (int): Maximum number of boxes will be kept.\\n        cfg (dict): Configuration dict of NMS.\\n        mlvl_dir_scores (torch.Tensor, optional): Multi-level scores\\n            of direction classifier. Defaults to None.\\n        mlvl_attr_scores (torch.Tensor, optional): Multi-level scores\\n            of attribute classifier. Defaults to None.\\n        mlvl_bboxes2d (torch.Tensor, optional): Multi-level 2D bounding\\n            boxes. Defaults to None.\\n\\n    Returns:\\n        tuple[torch.Tensor]: Return results after nms, including 3D\\n            bounding boxes, scores, labels, direction scores, attribute\\n            scores (optional) and 2D bounding boxes (optional).\\n    '\n    num_classes = mlvl_scores.shape[1] - 1\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    attr_scores = []\n    bboxes2d = []\n    for i in range(0, num_classes):\n        cls_inds = mlvl_scores[:, i] > score_thr\n        if not cls_inds.any():\n            continue\n        _scores = mlvl_scores[cls_inds, i]\n        _bboxes_for_nms = mlvl_bboxes_for_nms[cls_inds, :]\n        if cfg.use_rotate_nms:\n            nms_func = nms_bev\n        else:\n            nms_func = nms_normal_bev\n        selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n        _mlvl_bboxes = mlvl_bboxes[cls_inds, :]\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        cls_label = mlvl_bboxes.new_full((len(selected),), i, dtype=torch.long)\n        labels.append(cls_label)\n        if mlvl_dir_scores is not None:\n            _mlvl_dir_scores = mlvl_dir_scores[cls_inds]\n            dir_scores.append(_mlvl_dir_scores[selected])\n        if mlvl_attr_scores is not None:\n            _mlvl_attr_scores = mlvl_attr_scores[cls_inds]\n            attr_scores.append(_mlvl_attr_scores[selected])\n        if mlvl_bboxes2d is not None:\n            _mlvl_bboxes2d = mlvl_bboxes2d[cls_inds]\n            bboxes2d.append(_mlvl_bboxes2d[selected])\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if mlvl_dir_scores is not None:\n            dir_scores = torch.cat(dir_scores, dim=0)\n        if mlvl_attr_scores is not None:\n            attr_scores = torch.cat(attr_scores, dim=0)\n        if mlvl_bboxes2d is not None:\n            bboxes2d = torch.cat(bboxes2d, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            if mlvl_dir_scores is not None:\n                dir_scores = dir_scores[inds]\n            if mlvl_attr_scores is not None:\n                attr_scores = attr_scores[inds]\n            if mlvl_bboxes2d is not None:\n                bboxes2d = bboxes2d[inds]\n    else:\n        bboxes = mlvl_scores.new_zeros((0, mlvl_bboxes.size(-1)))\n        scores = mlvl_scores.new_zeros((0,))\n        labels = mlvl_scores.new_zeros((0,), dtype=torch.long)\n        if mlvl_dir_scores is not None:\n            dir_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_attr_scores is not None:\n            attr_scores = mlvl_scores.new_zeros((0,))\n        if mlvl_bboxes2d is not None:\n            bboxes2d = mlvl_scores.new_zeros((0, 4))\n    results = (bboxes, scores, labels)\n    if mlvl_dir_scores is not None:\n        results = results + (dir_scores,)\n    if mlvl_attr_scores is not None:\n        results = results + (attr_scores,)\n    if mlvl_bboxes2d is not None:\n        results = results + (bboxes2d,)\n    return results"
        ]
    },
    {
        "func_name": "aligned_3d_nms",
        "original": "def aligned_3d_nms(boxes, scores, classes, thresh):\n    \"\"\"3D NMS for aligned boxes.\n\n    Args:\n        boxes (torch.Tensor): Aligned box with shape [n, 6].\n        scores (torch.Tensor): Scores of each box.\n        classes (torch.Tensor): Class of each box.\n        thresh (float): IoU threshold for nms.\n\n    Returns:\n        torch.Tensor: Indices of selected boxes.\n    \"\"\"\n    x1 = boxes[:, 0]\n    y1 = boxes[:, 1]\n    z1 = boxes[:, 2]\n    x2 = boxes[:, 3]\n    y2 = boxes[:, 4]\n    z2 = boxes[:, 5]\n    area = (x2 - x1) * (y2 - y1) * (z2 - z1)\n    zero = boxes.new_zeros(1)\n    score_sorted = torch.argsort(scores)\n    pick = []\n    while score_sorted.shape[0] != 0:\n        last = score_sorted.shape[0]\n        i = score_sorted[-1]\n        pick.append(i)\n        xx1 = torch.max(x1[i], x1[score_sorted[:last - 1]])\n        yy1 = torch.max(y1[i], y1[score_sorted[:last - 1]])\n        zz1 = torch.max(z1[i], z1[score_sorted[:last - 1]])\n        xx2 = torch.min(x2[i], x2[score_sorted[:last - 1]])\n        yy2 = torch.min(y2[i], y2[score_sorted[:last - 1]])\n        zz2 = torch.min(z2[i], z2[score_sorted[:last - 1]])\n        classes1 = classes[i]\n        classes2 = classes[score_sorted[:last - 1]]\n        inter_l = torch.max(zero, xx2 - xx1)\n        inter_w = torch.max(zero, yy2 - yy1)\n        inter_h = torch.max(zero, zz2 - zz1)\n        inter = inter_l * inter_w * inter_h\n        iou = inter / (area[i] + area[score_sorted[:last - 1]] - inter)\n        iou = iou * (classes1 == classes2).float()\n        score_sorted = score_sorted[torch.nonzero(iou <= thresh, as_tuple=False).flatten()]\n    indices = boxes.new_tensor(pick, dtype=torch.long)\n    return indices",
        "mutated": [
            "def aligned_3d_nms(boxes, scores, classes, thresh):\n    if False:\n        i = 10\n    '3D NMS for aligned boxes.\\n\\n    Args:\\n        boxes (torch.Tensor): Aligned box with shape [n, 6].\\n        scores (torch.Tensor): Scores of each box.\\n        classes (torch.Tensor): Class of each box.\\n        thresh (float): IoU threshold for nms.\\n\\n    Returns:\\n        torch.Tensor: Indices of selected boxes.\\n    '\n    x1 = boxes[:, 0]\n    y1 = boxes[:, 1]\n    z1 = boxes[:, 2]\n    x2 = boxes[:, 3]\n    y2 = boxes[:, 4]\n    z2 = boxes[:, 5]\n    area = (x2 - x1) * (y2 - y1) * (z2 - z1)\n    zero = boxes.new_zeros(1)\n    score_sorted = torch.argsort(scores)\n    pick = []\n    while score_sorted.shape[0] != 0:\n        last = score_sorted.shape[0]\n        i = score_sorted[-1]\n        pick.append(i)\n        xx1 = torch.max(x1[i], x1[score_sorted[:last - 1]])\n        yy1 = torch.max(y1[i], y1[score_sorted[:last - 1]])\n        zz1 = torch.max(z1[i], z1[score_sorted[:last - 1]])\n        xx2 = torch.min(x2[i], x2[score_sorted[:last - 1]])\n        yy2 = torch.min(y2[i], y2[score_sorted[:last - 1]])\n        zz2 = torch.min(z2[i], z2[score_sorted[:last - 1]])\n        classes1 = classes[i]\n        classes2 = classes[score_sorted[:last - 1]]\n        inter_l = torch.max(zero, xx2 - xx1)\n        inter_w = torch.max(zero, yy2 - yy1)\n        inter_h = torch.max(zero, zz2 - zz1)\n        inter = inter_l * inter_w * inter_h\n        iou = inter / (area[i] + area[score_sorted[:last - 1]] - inter)\n        iou = iou * (classes1 == classes2).float()\n        score_sorted = score_sorted[torch.nonzero(iou <= thresh, as_tuple=False).flatten()]\n    indices = boxes.new_tensor(pick, dtype=torch.long)\n    return indices",
            "def aligned_3d_nms(boxes, scores, classes, thresh):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '3D NMS for aligned boxes.\\n\\n    Args:\\n        boxes (torch.Tensor): Aligned box with shape [n, 6].\\n        scores (torch.Tensor): Scores of each box.\\n        classes (torch.Tensor): Class of each box.\\n        thresh (float): IoU threshold for nms.\\n\\n    Returns:\\n        torch.Tensor: Indices of selected boxes.\\n    '\n    x1 = boxes[:, 0]\n    y1 = boxes[:, 1]\n    z1 = boxes[:, 2]\n    x2 = boxes[:, 3]\n    y2 = boxes[:, 4]\n    z2 = boxes[:, 5]\n    area = (x2 - x1) * (y2 - y1) * (z2 - z1)\n    zero = boxes.new_zeros(1)\n    score_sorted = torch.argsort(scores)\n    pick = []\n    while score_sorted.shape[0] != 0:\n        last = score_sorted.shape[0]\n        i = score_sorted[-1]\n        pick.append(i)\n        xx1 = torch.max(x1[i], x1[score_sorted[:last - 1]])\n        yy1 = torch.max(y1[i], y1[score_sorted[:last - 1]])\n        zz1 = torch.max(z1[i], z1[score_sorted[:last - 1]])\n        xx2 = torch.min(x2[i], x2[score_sorted[:last - 1]])\n        yy2 = torch.min(y2[i], y2[score_sorted[:last - 1]])\n        zz2 = torch.min(z2[i], z2[score_sorted[:last - 1]])\n        classes1 = classes[i]\n        classes2 = classes[score_sorted[:last - 1]]\n        inter_l = torch.max(zero, xx2 - xx1)\n        inter_w = torch.max(zero, yy2 - yy1)\n        inter_h = torch.max(zero, zz2 - zz1)\n        inter = inter_l * inter_w * inter_h\n        iou = inter / (area[i] + area[score_sorted[:last - 1]] - inter)\n        iou = iou * (classes1 == classes2).float()\n        score_sorted = score_sorted[torch.nonzero(iou <= thresh, as_tuple=False).flatten()]\n    indices = boxes.new_tensor(pick, dtype=torch.long)\n    return indices",
            "def aligned_3d_nms(boxes, scores, classes, thresh):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '3D NMS for aligned boxes.\\n\\n    Args:\\n        boxes (torch.Tensor): Aligned box with shape [n, 6].\\n        scores (torch.Tensor): Scores of each box.\\n        classes (torch.Tensor): Class of each box.\\n        thresh (float): IoU threshold for nms.\\n\\n    Returns:\\n        torch.Tensor: Indices of selected boxes.\\n    '\n    x1 = boxes[:, 0]\n    y1 = boxes[:, 1]\n    z1 = boxes[:, 2]\n    x2 = boxes[:, 3]\n    y2 = boxes[:, 4]\n    z2 = boxes[:, 5]\n    area = (x2 - x1) * (y2 - y1) * (z2 - z1)\n    zero = boxes.new_zeros(1)\n    score_sorted = torch.argsort(scores)\n    pick = []\n    while score_sorted.shape[0] != 0:\n        last = score_sorted.shape[0]\n        i = score_sorted[-1]\n        pick.append(i)\n        xx1 = torch.max(x1[i], x1[score_sorted[:last - 1]])\n        yy1 = torch.max(y1[i], y1[score_sorted[:last - 1]])\n        zz1 = torch.max(z1[i], z1[score_sorted[:last - 1]])\n        xx2 = torch.min(x2[i], x2[score_sorted[:last - 1]])\n        yy2 = torch.min(y2[i], y2[score_sorted[:last - 1]])\n        zz2 = torch.min(z2[i], z2[score_sorted[:last - 1]])\n        classes1 = classes[i]\n        classes2 = classes[score_sorted[:last - 1]]\n        inter_l = torch.max(zero, xx2 - xx1)\n        inter_w = torch.max(zero, yy2 - yy1)\n        inter_h = torch.max(zero, zz2 - zz1)\n        inter = inter_l * inter_w * inter_h\n        iou = inter / (area[i] + area[score_sorted[:last - 1]] - inter)\n        iou = iou * (classes1 == classes2).float()\n        score_sorted = score_sorted[torch.nonzero(iou <= thresh, as_tuple=False).flatten()]\n    indices = boxes.new_tensor(pick, dtype=torch.long)\n    return indices",
            "def aligned_3d_nms(boxes, scores, classes, thresh):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '3D NMS for aligned boxes.\\n\\n    Args:\\n        boxes (torch.Tensor): Aligned box with shape [n, 6].\\n        scores (torch.Tensor): Scores of each box.\\n        classes (torch.Tensor): Class of each box.\\n        thresh (float): IoU threshold for nms.\\n\\n    Returns:\\n        torch.Tensor: Indices of selected boxes.\\n    '\n    x1 = boxes[:, 0]\n    y1 = boxes[:, 1]\n    z1 = boxes[:, 2]\n    x2 = boxes[:, 3]\n    y2 = boxes[:, 4]\n    z2 = boxes[:, 5]\n    area = (x2 - x1) * (y2 - y1) * (z2 - z1)\n    zero = boxes.new_zeros(1)\n    score_sorted = torch.argsort(scores)\n    pick = []\n    while score_sorted.shape[0] != 0:\n        last = score_sorted.shape[0]\n        i = score_sorted[-1]\n        pick.append(i)\n        xx1 = torch.max(x1[i], x1[score_sorted[:last - 1]])\n        yy1 = torch.max(y1[i], y1[score_sorted[:last - 1]])\n        zz1 = torch.max(z1[i], z1[score_sorted[:last - 1]])\n        xx2 = torch.min(x2[i], x2[score_sorted[:last - 1]])\n        yy2 = torch.min(y2[i], y2[score_sorted[:last - 1]])\n        zz2 = torch.min(z2[i], z2[score_sorted[:last - 1]])\n        classes1 = classes[i]\n        classes2 = classes[score_sorted[:last - 1]]\n        inter_l = torch.max(zero, xx2 - xx1)\n        inter_w = torch.max(zero, yy2 - yy1)\n        inter_h = torch.max(zero, zz2 - zz1)\n        inter = inter_l * inter_w * inter_h\n        iou = inter / (area[i] + area[score_sorted[:last - 1]] - inter)\n        iou = iou * (classes1 == classes2).float()\n        score_sorted = score_sorted[torch.nonzero(iou <= thresh, as_tuple=False).flatten()]\n    indices = boxes.new_tensor(pick, dtype=torch.long)\n    return indices",
            "def aligned_3d_nms(boxes, scores, classes, thresh):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '3D NMS for aligned boxes.\\n\\n    Args:\\n        boxes (torch.Tensor): Aligned box with shape [n, 6].\\n        scores (torch.Tensor): Scores of each box.\\n        classes (torch.Tensor): Class of each box.\\n        thresh (float): IoU threshold for nms.\\n\\n    Returns:\\n        torch.Tensor: Indices of selected boxes.\\n    '\n    x1 = boxes[:, 0]\n    y1 = boxes[:, 1]\n    z1 = boxes[:, 2]\n    x2 = boxes[:, 3]\n    y2 = boxes[:, 4]\n    z2 = boxes[:, 5]\n    area = (x2 - x1) * (y2 - y1) * (z2 - z1)\n    zero = boxes.new_zeros(1)\n    score_sorted = torch.argsort(scores)\n    pick = []\n    while score_sorted.shape[0] != 0:\n        last = score_sorted.shape[0]\n        i = score_sorted[-1]\n        pick.append(i)\n        xx1 = torch.max(x1[i], x1[score_sorted[:last - 1]])\n        yy1 = torch.max(y1[i], y1[score_sorted[:last - 1]])\n        zz1 = torch.max(z1[i], z1[score_sorted[:last - 1]])\n        xx2 = torch.min(x2[i], x2[score_sorted[:last - 1]])\n        yy2 = torch.min(y2[i], y2[score_sorted[:last - 1]])\n        zz2 = torch.min(z2[i], z2[score_sorted[:last - 1]])\n        classes1 = classes[i]\n        classes2 = classes[score_sorted[:last - 1]]\n        inter_l = torch.max(zero, xx2 - xx1)\n        inter_w = torch.max(zero, yy2 - yy1)\n        inter_h = torch.max(zero, zz2 - zz1)\n        inter = inter_l * inter_w * inter_h\n        iou = inter / (area[i] + area[score_sorted[:last - 1]] - inter)\n        iou = iou * (classes1 == classes2).float()\n        score_sorted = score_sorted[torch.nonzero(iou <= thresh, as_tuple=False).flatten()]\n    indices = boxes.new_tensor(pick, dtype=torch.long)\n    return indices"
        ]
    },
    {
        "func_name": "circle_nms",
        "original": "@numba.jit(nopython=True)\ndef circle_nms(dets, thresh, post_max_size=83):\n    \"\"\"Circular NMS.\n\n    An object is only counted as positive if no other center\n    with a higher confidence exists within a radius r using a\n    bird-eye view distance metric.\n\n    Args:\n        dets (torch.Tensor): Detection results with the shape of [N, 3].\n        thresh (float): Value of threshold.\n        post_max_size (int, optional): Max number of prediction to be kept.\n            Defaults to 83.\n\n    Returns:\n        torch.Tensor: Indexes of the detections to be kept.\n    \"\"\"\n    x1 = dets[:, 0]\n    y1 = dets[:, 1]\n    scores = dets[:, 2]\n    order = scores.argsort()[::-1].astype(np.int32)\n    ndets = dets.shape[0]\n    suppressed = np.zeros(ndets, dtype=np.int32)\n    keep = []\n    for _i in range(ndets):\n        i = order[_i]\n        if suppressed[i] == 1:\n            continue\n        keep.append(i)\n        for _j in range(_i + 1, ndets):\n            j = order[_j]\n            if suppressed[j] == 1:\n                continue\n            dist = (x1[i] - x1[j]) ** 2 + (y1[i] - y1[j]) ** 2\n            if dist <= thresh:\n                suppressed[j] = 1\n    if post_max_size < len(keep):\n        return keep[:post_max_size]\n    return keep",
        "mutated": [
            "@numba.jit(nopython=True)\ndef circle_nms(dets, thresh, post_max_size=83):\n    if False:\n        i = 10\n    'Circular NMS.\\n\\n    An object is only counted as positive if no other center\\n    with a higher confidence exists within a radius r using a\\n    bird-eye view distance metric.\\n\\n    Args:\\n        dets (torch.Tensor): Detection results with the shape of [N, 3].\\n        thresh (float): Value of threshold.\\n        post_max_size (int, optional): Max number of prediction to be kept.\\n            Defaults to 83.\\n\\n    Returns:\\n        torch.Tensor: Indexes of the detections to be kept.\\n    '\n    x1 = dets[:, 0]\n    y1 = dets[:, 1]\n    scores = dets[:, 2]\n    order = scores.argsort()[::-1].astype(np.int32)\n    ndets = dets.shape[0]\n    suppressed = np.zeros(ndets, dtype=np.int32)\n    keep = []\n    for _i in range(ndets):\n        i = order[_i]\n        if suppressed[i] == 1:\n            continue\n        keep.append(i)\n        for _j in range(_i + 1, ndets):\n            j = order[_j]\n            if suppressed[j] == 1:\n                continue\n            dist = (x1[i] - x1[j]) ** 2 + (y1[i] - y1[j]) ** 2\n            if dist <= thresh:\n                suppressed[j] = 1\n    if post_max_size < len(keep):\n        return keep[:post_max_size]\n    return keep",
            "@numba.jit(nopython=True)\ndef circle_nms(dets, thresh, post_max_size=83):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Circular NMS.\\n\\n    An object is only counted as positive if no other center\\n    with a higher confidence exists within a radius r using a\\n    bird-eye view distance metric.\\n\\n    Args:\\n        dets (torch.Tensor): Detection results with the shape of [N, 3].\\n        thresh (float): Value of threshold.\\n        post_max_size (int, optional): Max number of prediction to be kept.\\n            Defaults to 83.\\n\\n    Returns:\\n        torch.Tensor: Indexes of the detections to be kept.\\n    '\n    x1 = dets[:, 0]\n    y1 = dets[:, 1]\n    scores = dets[:, 2]\n    order = scores.argsort()[::-1].astype(np.int32)\n    ndets = dets.shape[0]\n    suppressed = np.zeros(ndets, dtype=np.int32)\n    keep = []\n    for _i in range(ndets):\n        i = order[_i]\n        if suppressed[i] == 1:\n            continue\n        keep.append(i)\n        for _j in range(_i + 1, ndets):\n            j = order[_j]\n            if suppressed[j] == 1:\n                continue\n            dist = (x1[i] - x1[j]) ** 2 + (y1[i] - y1[j]) ** 2\n            if dist <= thresh:\n                suppressed[j] = 1\n    if post_max_size < len(keep):\n        return keep[:post_max_size]\n    return keep",
            "@numba.jit(nopython=True)\ndef circle_nms(dets, thresh, post_max_size=83):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Circular NMS.\\n\\n    An object is only counted as positive if no other center\\n    with a higher confidence exists within a radius r using a\\n    bird-eye view distance metric.\\n\\n    Args:\\n        dets (torch.Tensor): Detection results with the shape of [N, 3].\\n        thresh (float): Value of threshold.\\n        post_max_size (int, optional): Max number of prediction to be kept.\\n            Defaults to 83.\\n\\n    Returns:\\n        torch.Tensor: Indexes of the detections to be kept.\\n    '\n    x1 = dets[:, 0]\n    y1 = dets[:, 1]\n    scores = dets[:, 2]\n    order = scores.argsort()[::-1].astype(np.int32)\n    ndets = dets.shape[0]\n    suppressed = np.zeros(ndets, dtype=np.int32)\n    keep = []\n    for _i in range(ndets):\n        i = order[_i]\n        if suppressed[i] == 1:\n            continue\n        keep.append(i)\n        for _j in range(_i + 1, ndets):\n            j = order[_j]\n            if suppressed[j] == 1:\n                continue\n            dist = (x1[i] - x1[j]) ** 2 + (y1[i] - y1[j]) ** 2\n            if dist <= thresh:\n                suppressed[j] = 1\n    if post_max_size < len(keep):\n        return keep[:post_max_size]\n    return keep",
            "@numba.jit(nopython=True)\ndef circle_nms(dets, thresh, post_max_size=83):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Circular NMS.\\n\\n    An object is only counted as positive if no other center\\n    with a higher confidence exists within a radius r using a\\n    bird-eye view distance metric.\\n\\n    Args:\\n        dets (torch.Tensor): Detection results with the shape of [N, 3].\\n        thresh (float): Value of threshold.\\n        post_max_size (int, optional): Max number of prediction to be kept.\\n            Defaults to 83.\\n\\n    Returns:\\n        torch.Tensor: Indexes of the detections to be kept.\\n    '\n    x1 = dets[:, 0]\n    y1 = dets[:, 1]\n    scores = dets[:, 2]\n    order = scores.argsort()[::-1].astype(np.int32)\n    ndets = dets.shape[0]\n    suppressed = np.zeros(ndets, dtype=np.int32)\n    keep = []\n    for _i in range(ndets):\n        i = order[_i]\n        if suppressed[i] == 1:\n            continue\n        keep.append(i)\n        for _j in range(_i + 1, ndets):\n            j = order[_j]\n            if suppressed[j] == 1:\n                continue\n            dist = (x1[i] - x1[j]) ** 2 + (y1[i] - y1[j]) ** 2\n            if dist <= thresh:\n                suppressed[j] = 1\n    if post_max_size < len(keep):\n        return keep[:post_max_size]\n    return keep",
            "@numba.jit(nopython=True)\ndef circle_nms(dets, thresh, post_max_size=83):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Circular NMS.\\n\\n    An object is only counted as positive if no other center\\n    with a higher confidence exists within a radius r using a\\n    bird-eye view distance metric.\\n\\n    Args:\\n        dets (torch.Tensor): Detection results with the shape of [N, 3].\\n        thresh (float): Value of threshold.\\n        post_max_size (int, optional): Max number of prediction to be kept.\\n            Defaults to 83.\\n\\n    Returns:\\n        torch.Tensor: Indexes of the detections to be kept.\\n    '\n    x1 = dets[:, 0]\n    y1 = dets[:, 1]\n    scores = dets[:, 2]\n    order = scores.argsort()[::-1].astype(np.int32)\n    ndets = dets.shape[0]\n    suppressed = np.zeros(ndets, dtype=np.int32)\n    keep = []\n    for _i in range(ndets):\n        i = order[_i]\n        if suppressed[i] == 1:\n            continue\n        keep.append(i)\n        for _j in range(_i + 1, ndets):\n            j = order[_j]\n            if suppressed[j] == 1:\n                continue\n            dist = (x1[i] - x1[j]) ** 2 + (y1[i] - y1[j]) ** 2\n            if dist <= thresh:\n                suppressed[j] = 1\n    if post_max_size < len(keep):\n        return keep[:post_max_size]\n    return keep"
        ]
    },
    {
        "func_name": "nms_bev",
        "original": "def nms_bev(boxes, scores, thresh, pre_max_size=None, post_max_size=None):\n    \"\"\"NMS function GPU implementation (for BEV boxes). The overlap of two\n    boxes for IoU calculation is defined as the exact overlapping area of the\n    two boxes. In this function, one can also set ``pre_max_size`` and\n    ``post_max_size``.\n\n    Args:\n        boxes (torch.Tensor): Input boxes with the shape of [N, 5]\n            ([x1, y1, x2, y2, ry]).\n        scores (torch.Tensor): Scores of boxes with the shape of [N].\n        thresh (float): Overlap threshold of NMS.\n        pre_max_size (int, optional): Max size of boxes before NMS.\n            Default: None.\n        post_max_size (int, optional): Max size of boxes after NMS.\n            Default: None.\n\n    Returns:\n        torch.Tensor: Indexes after NMS.\n    \"\"\"\n    assert boxes.size(1) == 5, 'Input boxes shape should be [N, 5]'\n    order = scores.sort(0, descending=True)[1]\n    if pre_max_size is not None:\n        order = order[:pre_max_size]\n    boxes = boxes[order].contiguous()\n    scores = scores[order]\n    boxes = torch.stack(((boxes[:, 0] + boxes[:, 2]) / 2, (boxes[:, 1] + boxes[:, 3]) / 2, boxes[:, 2] - boxes[:, 0], boxes[:, 3] - boxes[:, 1], boxes[:, 4]), dim=-1)\n    keep = nms_rotated(boxes, scores, thresh)[1]\n    keep = order[keep]\n    if post_max_size is not None:\n        keep = keep[:post_max_size]\n    return keep",
        "mutated": [
            "def nms_bev(boxes, scores, thresh, pre_max_size=None, post_max_size=None):\n    if False:\n        i = 10\n    'NMS function GPU implementation (for BEV boxes). The overlap of two\\n    boxes for IoU calculation is defined as the exact overlapping area of the\\n    two boxes. In this function, one can also set ``pre_max_size`` and\\n    ``post_max_size``.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with the shape of [N, 5]\\n            ([x1, y1, x2, y2, ry]).\\n        scores (torch.Tensor): Scores of boxes with the shape of [N].\\n        thresh (float): Overlap threshold of NMS.\\n        pre_max_size (int, optional): Max size of boxes before NMS.\\n            Default: None.\\n        post_max_size (int, optional): Max size of boxes after NMS.\\n            Default: None.\\n\\n    Returns:\\n        torch.Tensor: Indexes after NMS.\\n    '\n    assert boxes.size(1) == 5, 'Input boxes shape should be [N, 5]'\n    order = scores.sort(0, descending=True)[1]\n    if pre_max_size is not None:\n        order = order[:pre_max_size]\n    boxes = boxes[order].contiguous()\n    scores = scores[order]\n    boxes = torch.stack(((boxes[:, 0] + boxes[:, 2]) / 2, (boxes[:, 1] + boxes[:, 3]) / 2, boxes[:, 2] - boxes[:, 0], boxes[:, 3] - boxes[:, 1], boxes[:, 4]), dim=-1)\n    keep = nms_rotated(boxes, scores, thresh)[1]\n    keep = order[keep]\n    if post_max_size is not None:\n        keep = keep[:post_max_size]\n    return keep",
            "def nms_bev(boxes, scores, thresh, pre_max_size=None, post_max_size=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'NMS function GPU implementation (for BEV boxes). The overlap of two\\n    boxes for IoU calculation is defined as the exact overlapping area of the\\n    two boxes. In this function, one can also set ``pre_max_size`` and\\n    ``post_max_size``.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with the shape of [N, 5]\\n            ([x1, y1, x2, y2, ry]).\\n        scores (torch.Tensor): Scores of boxes with the shape of [N].\\n        thresh (float): Overlap threshold of NMS.\\n        pre_max_size (int, optional): Max size of boxes before NMS.\\n            Default: None.\\n        post_max_size (int, optional): Max size of boxes after NMS.\\n            Default: None.\\n\\n    Returns:\\n        torch.Tensor: Indexes after NMS.\\n    '\n    assert boxes.size(1) == 5, 'Input boxes shape should be [N, 5]'\n    order = scores.sort(0, descending=True)[1]\n    if pre_max_size is not None:\n        order = order[:pre_max_size]\n    boxes = boxes[order].contiguous()\n    scores = scores[order]\n    boxes = torch.stack(((boxes[:, 0] + boxes[:, 2]) / 2, (boxes[:, 1] + boxes[:, 3]) / 2, boxes[:, 2] - boxes[:, 0], boxes[:, 3] - boxes[:, 1], boxes[:, 4]), dim=-1)\n    keep = nms_rotated(boxes, scores, thresh)[1]\n    keep = order[keep]\n    if post_max_size is not None:\n        keep = keep[:post_max_size]\n    return keep",
            "def nms_bev(boxes, scores, thresh, pre_max_size=None, post_max_size=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'NMS function GPU implementation (for BEV boxes). The overlap of two\\n    boxes for IoU calculation is defined as the exact overlapping area of the\\n    two boxes. In this function, one can also set ``pre_max_size`` and\\n    ``post_max_size``.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with the shape of [N, 5]\\n            ([x1, y1, x2, y2, ry]).\\n        scores (torch.Tensor): Scores of boxes with the shape of [N].\\n        thresh (float): Overlap threshold of NMS.\\n        pre_max_size (int, optional): Max size of boxes before NMS.\\n            Default: None.\\n        post_max_size (int, optional): Max size of boxes after NMS.\\n            Default: None.\\n\\n    Returns:\\n        torch.Tensor: Indexes after NMS.\\n    '\n    assert boxes.size(1) == 5, 'Input boxes shape should be [N, 5]'\n    order = scores.sort(0, descending=True)[1]\n    if pre_max_size is not None:\n        order = order[:pre_max_size]\n    boxes = boxes[order].contiguous()\n    scores = scores[order]\n    boxes = torch.stack(((boxes[:, 0] + boxes[:, 2]) / 2, (boxes[:, 1] + boxes[:, 3]) / 2, boxes[:, 2] - boxes[:, 0], boxes[:, 3] - boxes[:, 1], boxes[:, 4]), dim=-1)\n    keep = nms_rotated(boxes, scores, thresh)[1]\n    keep = order[keep]\n    if post_max_size is not None:\n        keep = keep[:post_max_size]\n    return keep",
            "def nms_bev(boxes, scores, thresh, pre_max_size=None, post_max_size=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'NMS function GPU implementation (for BEV boxes). The overlap of two\\n    boxes for IoU calculation is defined as the exact overlapping area of the\\n    two boxes. In this function, one can also set ``pre_max_size`` and\\n    ``post_max_size``.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with the shape of [N, 5]\\n            ([x1, y1, x2, y2, ry]).\\n        scores (torch.Tensor): Scores of boxes with the shape of [N].\\n        thresh (float): Overlap threshold of NMS.\\n        pre_max_size (int, optional): Max size of boxes before NMS.\\n            Default: None.\\n        post_max_size (int, optional): Max size of boxes after NMS.\\n            Default: None.\\n\\n    Returns:\\n        torch.Tensor: Indexes after NMS.\\n    '\n    assert boxes.size(1) == 5, 'Input boxes shape should be [N, 5]'\n    order = scores.sort(0, descending=True)[1]\n    if pre_max_size is not None:\n        order = order[:pre_max_size]\n    boxes = boxes[order].contiguous()\n    scores = scores[order]\n    boxes = torch.stack(((boxes[:, 0] + boxes[:, 2]) / 2, (boxes[:, 1] + boxes[:, 3]) / 2, boxes[:, 2] - boxes[:, 0], boxes[:, 3] - boxes[:, 1], boxes[:, 4]), dim=-1)\n    keep = nms_rotated(boxes, scores, thresh)[1]\n    keep = order[keep]\n    if post_max_size is not None:\n        keep = keep[:post_max_size]\n    return keep",
            "def nms_bev(boxes, scores, thresh, pre_max_size=None, post_max_size=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'NMS function GPU implementation (for BEV boxes). The overlap of two\\n    boxes for IoU calculation is defined as the exact overlapping area of the\\n    two boxes. In this function, one can also set ``pre_max_size`` and\\n    ``post_max_size``.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with the shape of [N, 5]\\n            ([x1, y1, x2, y2, ry]).\\n        scores (torch.Tensor): Scores of boxes with the shape of [N].\\n        thresh (float): Overlap threshold of NMS.\\n        pre_max_size (int, optional): Max size of boxes before NMS.\\n            Default: None.\\n        post_max_size (int, optional): Max size of boxes after NMS.\\n            Default: None.\\n\\n    Returns:\\n        torch.Tensor: Indexes after NMS.\\n    '\n    assert boxes.size(1) == 5, 'Input boxes shape should be [N, 5]'\n    order = scores.sort(0, descending=True)[1]\n    if pre_max_size is not None:\n        order = order[:pre_max_size]\n    boxes = boxes[order].contiguous()\n    scores = scores[order]\n    boxes = torch.stack(((boxes[:, 0] + boxes[:, 2]) / 2, (boxes[:, 1] + boxes[:, 3]) / 2, boxes[:, 2] - boxes[:, 0], boxes[:, 3] - boxes[:, 1], boxes[:, 4]), dim=-1)\n    keep = nms_rotated(boxes, scores, thresh)[1]\n    keep = order[keep]\n    if post_max_size is not None:\n        keep = keep[:post_max_size]\n    return keep"
        ]
    },
    {
        "func_name": "nms_normal_bev",
        "original": "def nms_normal_bev(boxes, scores, thresh):\n    \"\"\"Normal NMS function GPU implementation (for BEV boxes). The overlap of\n    two boxes for IoU calculation is defined as the exact overlapping area of\n    the two boxes WITH their yaw angle set to 0.\n\n    Args:\n        boxes (torch.Tensor): Input boxes with shape (N, 5).\n        scores (torch.Tensor): Scores of predicted boxes with shape (N).\n        thresh (float): Overlap threshold of NMS.\n\n    Returns:\n        torch.Tensor: Remaining indices with scores in descending order.\n    \"\"\"\n    assert boxes.shape[1] == 5, 'Input boxes shape should be [N, 5]'\n    return nms(boxes[:, :-1], scores, thresh)[1]",
        "mutated": [
            "def nms_normal_bev(boxes, scores, thresh):\n    if False:\n        i = 10\n    'Normal NMS function GPU implementation (for BEV boxes). The overlap of\\n    two boxes for IoU calculation is defined as the exact overlapping area of\\n    the two boxes WITH their yaw angle set to 0.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with shape (N, 5).\\n        scores (torch.Tensor): Scores of predicted boxes with shape (N).\\n        thresh (float): Overlap threshold of NMS.\\n\\n    Returns:\\n        torch.Tensor: Remaining indices with scores in descending order.\\n    '\n    assert boxes.shape[1] == 5, 'Input boxes shape should be [N, 5]'\n    return nms(boxes[:, :-1], scores, thresh)[1]",
            "def nms_normal_bev(boxes, scores, thresh):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Normal NMS function GPU implementation (for BEV boxes). The overlap of\\n    two boxes for IoU calculation is defined as the exact overlapping area of\\n    the two boxes WITH their yaw angle set to 0.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with shape (N, 5).\\n        scores (torch.Tensor): Scores of predicted boxes with shape (N).\\n        thresh (float): Overlap threshold of NMS.\\n\\n    Returns:\\n        torch.Tensor: Remaining indices with scores in descending order.\\n    '\n    assert boxes.shape[1] == 5, 'Input boxes shape should be [N, 5]'\n    return nms(boxes[:, :-1], scores, thresh)[1]",
            "def nms_normal_bev(boxes, scores, thresh):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Normal NMS function GPU implementation (for BEV boxes). The overlap of\\n    two boxes for IoU calculation is defined as the exact overlapping area of\\n    the two boxes WITH their yaw angle set to 0.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with shape (N, 5).\\n        scores (torch.Tensor): Scores of predicted boxes with shape (N).\\n        thresh (float): Overlap threshold of NMS.\\n\\n    Returns:\\n        torch.Tensor: Remaining indices with scores in descending order.\\n    '\n    assert boxes.shape[1] == 5, 'Input boxes shape should be [N, 5]'\n    return nms(boxes[:, :-1], scores, thresh)[1]",
            "def nms_normal_bev(boxes, scores, thresh):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Normal NMS function GPU implementation (for BEV boxes). The overlap of\\n    two boxes for IoU calculation is defined as the exact overlapping area of\\n    the two boxes WITH their yaw angle set to 0.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with shape (N, 5).\\n        scores (torch.Tensor): Scores of predicted boxes with shape (N).\\n        thresh (float): Overlap threshold of NMS.\\n\\n    Returns:\\n        torch.Tensor: Remaining indices with scores in descending order.\\n    '\n    assert boxes.shape[1] == 5, 'Input boxes shape should be [N, 5]'\n    return nms(boxes[:, :-1], scores, thresh)[1]",
            "def nms_normal_bev(boxes, scores, thresh):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Normal NMS function GPU implementation (for BEV boxes). The overlap of\\n    two boxes for IoU calculation is defined as the exact overlapping area of\\n    the two boxes WITH their yaw angle set to 0.\\n\\n    Args:\\n        boxes (torch.Tensor): Input boxes with shape (N, 5).\\n        scores (torch.Tensor): Scores of predicted boxes with shape (N).\\n        thresh (float): Overlap threshold of NMS.\\n\\n    Returns:\\n        torch.Tensor: Remaining indices with scores in descending order.\\n    '\n    assert boxes.shape[1] == 5, 'Input boxes shape should be [N, 5]'\n    return nms(boxes[:, :-1], scores, thresh)[1]"
        ]
    }
]