[
    {
        "func_name": "_calculate_roc_for_fpr",
        "original": "def _calculate_roc_for_fpr(y_true: np.ndarray, y_proba: np.ndarray, targeted_fpr: float) -> Tuple[FPR, TPR, THR]:\n    \"\"\"\n    Get FPR, TPR and, THRESHOLD based on the targeted_fpr (such that FPR <= targeted_fpr)\n    :param y_true: True attack labels.\n    :param y_proba: Predicted attack probabilities.\n    :param targeted_fpr: the targeted False Positive Rate, ROC will be calculated based on this FPR.\n    :return: tuple that contains (Achieved FPR, TPR, Threshold).\n    \"\"\"\n    (fpr, tpr, thr) = roc_curve(y_true=y_true, y_score=y_proba)\n    if np.isnan(fpr).all() or np.isnan(tpr).all():\n        logging.error('TPR or FPR values are NaN')\n        raise ValueError(\"The targeted FPR can't be achieved.\")\n    targeted_fpr_idx = np.where(fpr <= targeted_fpr)[0][-1]\n    return (fpr[targeted_fpr_idx], tpr[targeted_fpr_idx], thr[targeted_fpr_idx])",
        "mutated": [
            "def _calculate_roc_for_fpr(y_true: np.ndarray, y_proba: np.ndarray, targeted_fpr: float) -> Tuple[FPR, TPR, THR]:\n    if False:\n        i = 10\n    '\\n    Get FPR, TPR and, THRESHOLD based on the targeted_fpr (such that FPR <= targeted_fpr)\\n    :param y_true: True attack labels.\\n    :param y_proba: Predicted attack probabilities.\\n    :param targeted_fpr: the targeted False Positive Rate, ROC will be calculated based on this FPR.\\n    :return: tuple that contains (Achieved FPR, TPR, Threshold).\\n    '\n    (fpr, tpr, thr) = roc_curve(y_true=y_true, y_score=y_proba)\n    if np.isnan(fpr).all() or np.isnan(tpr).all():\n        logging.error('TPR or FPR values are NaN')\n        raise ValueError(\"The targeted FPR can't be achieved.\")\n    targeted_fpr_idx = np.where(fpr <= targeted_fpr)[0][-1]\n    return (fpr[targeted_fpr_idx], tpr[targeted_fpr_idx], thr[targeted_fpr_idx])",
            "def _calculate_roc_for_fpr(y_true: np.ndarray, y_proba: np.ndarray, targeted_fpr: float) -> Tuple[FPR, TPR, THR]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get FPR, TPR and, THRESHOLD based on the targeted_fpr (such that FPR <= targeted_fpr)\\n    :param y_true: True attack labels.\\n    :param y_proba: Predicted attack probabilities.\\n    :param targeted_fpr: the targeted False Positive Rate, ROC will be calculated based on this FPR.\\n    :return: tuple that contains (Achieved FPR, TPR, Threshold).\\n    '\n    (fpr, tpr, thr) = roc_curve(y_true=y_true, y_score=y_proba)\n    if np.isnan(fpr).all() or np.isnan(tpr).all():\n        logging.error('TPR or FPR values are NaN')\n        raise ValueError(\"The targeted FPR can't be achieved.\")\n    targeted_fpr_idx = np.where(fpr <= targeted_fpr)[0][-1]\n    return (fpr[targeted_fpr_idx], tpr[targeted_fpr_idx], thr[targeted_fpr_idx])",
            "def _calculate_roc_for_fpr(y_true: np.ndarray, y_proba: np.ndarray, targeted_fpr: float) -> Tuple[FPR, TPR, THR]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get FPR, TPR and, THRESHOLD based on the targeted_fpr (such that FPR <= targeted_fpr)\\n    :param y_true: True attack labels.\\n    :param y_proba: Predicted attack probabilities.\\n    :param targeted_fpr: the targeted False Positive Rate, ROC will be calculated based on this FPR.\\n    :return: tuple that contains (Achieved FPR, TPR, Threshold).\\n    '\n    (fpr, tpr, thr) = roc_curve(y_true=y_true, y_score=y_proba)\n    if np.isnan(fpr).all() or np.isnan(tpr).all():\n        logging.error('TPR or FPR values are NaN')\n        raise ValueError(\"The targeted FPR can't be achieved.\")\n    targeted_fpr_idx = np.where(fpr <= targeted_fpr)[0][-1]\n    return (fpr[targeted_fpr_idx], tpr[targeted_fpr_idx], thr[targeted_fpr_idx])",
            "def _calculate_roc_for_fpr(y_true: np.ndarray, y_proba: np.ndarray, targeted_fpr: float) -> Tuple[FPR, TPR, THR]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get FPR, TPR and, THRESHOLD based on the targeted_fpr (such that FPR <= targeted_fpr)\\n    :param y_true: True attack labels.\\n    :param y_proba: Predicted attack probabilities.\\n    :param targeted_fpr: the targeted False Positive Rate, ROC will be calculated based on this FPR.\\n    :return: tuple that contains (Achieved FPR, TPR, Threshold).\\n    '\n    (fpr, tpr, thr) = roc_curve(y_true=y_true, y_score=y_proba)\n    if np.isnan(fpr).all() or np.isnan(tpr).all():\n        logging.error('TPR or FPR values are NaN')\n        raise ValueError(\"The targeted FPR can't be achieved.\")\n    targeted_fpr_idx = np.where(fpr <= targeted_fpr)[0][-1]\n    return (fpr[targeted_fpr_idx], tpr[targeted_fpr_idx], thr[targeted_fpr_idx])",
            "def _calculate_roc_for_fpr(y_true: np.ndarray, y_proba: np.ndarray, targeted_fpr: float) -> Tuple[FPR, TPR, THR]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get FPR, TPR and, THRESHOLD based on the targeted_fpr (such that FPR <= targeted_fpr)\\n    :param y_true: True attack labels.\\n    :param y_proba: Predicted attack probabilities.\\n    :param targeted_fpr: the targeted False Positive Rate, ROC will be calculated based on this FPR.\\n    :return: tuple that contains (Achieved FPR, TPR, Threshold).\\n    '\n    (fpr, tpr, thr) = roc_curve(y_true=y_true, y_score=y_proba)\n    if np.isnan(fpr).all() or np.isnan(tpr).all():\n        logging.error('TPR or FPR values are NaN')\n        raise ValueError(\"The targeted FPR can't be achieved.\")\n    targeted_fpr_idx = np.where(fpr <= targeted_fpr)[0][-1]\n    return (fpr[targeted_fpr_idx], tpr[targeted_fpr_idx], thr[targeted_fpr_idx])"
        ]
    },
    {
        "func_name": "get_roc_for_fpr",
        "original": "def get_roc_for_fpr(attack_proba: np.ndarray, attack_true: np.ndarray, target_model_labels: Optional[np.ndarray]=None, targeted_fpr: float=0.001) -> Union[List[Tuple[FPR, TPR, THR]], List[Tuple[int, FPR, TPR, THR]]]:\n    \"\"\"\n    Compute the attack TPR, THRESHOLD and achieved FPR based on the targeted FPR. This implementation supports only\n    binary attack prediction labels {0,1}. The returned THRESHOLD defines the decision threshold on the attack\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1)\n    | Related paper link: https://arxiv.org/abs/2112.03570\n\n    :param attack_proba: Predicted attack probabilities.\n    :param attack_true: True attack labels.\n    :param targeted_fpr: the targeted False Positive Rate, attack accuracy will be calculated based on this FPRs.\n     If not supplied, get_roc_for_fpr will be computed for `0.001` FPR.\n    :param target_model_labels: Original labels, if provided the Accuracy and threshold will be calculated per each\n     class separately.\n    :return: list of tuples the contains (original label (if target_model_labels is provided),\n    Achieved FPR, TPR, Threshold).\n    \"\"\"\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    if target_model_labels is not None and attack_proba.shape[0] != target_model_labels.shape[0]:\n        raise ValueError('Number of rows in target_model_labels and attack_pred do not match')\n    results = []\n    if target_model_labels is not None:\n        (values, _) = np.unique(target_model_labels, return_counts=True)\n        for value in values:\n            idxs = np.where(target_model_labels == value)[0]\n            (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba[idxs], y_true=attack_true[idxs], targeted_fpr=targeted_fpr)\n            results.append((value, fpr, tpr, thr))\n        return results\n    (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=targeted_fpr)\n    return [(fpr, tpr, thr)]",
        "mutated": [
            "def get_roc_for_fpr(attack_proba: np.ndarray, attack_true: np.ndarray, target_model_labels: Optional[np.ndarray]=None, targeted_fpr: float=0.001) -> Union[List[Tuple[FPR, TPR, THR]], List[Tuple[int, FPR, TPR, THR]]]:\n    if False:\n        i = 10\n    '\\n    Compute the attack TPR, THRESHOLD and achieved FPR based on the targeted FPR. This implementation supports only\\n    binary attack prediction labels {0,1}. The returned THRESHOLD defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1)\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fpr: the targeted False Positive Rate, attack accuracy will be calculated based on this FPRs.\\n     If not supplied, get_roc_for_fpr will be computed for `0.001` FPR.\\n    :param target_model_labels: Original labels, if provided the Accuracy and threshold will be calculated per each\\n     class separately.\\n    :return: list of tuples the contains (original label (if target_model_labels is provided),\\n    Achieved FPR, TPR, Threshold).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    if target_model_labels is not None and attack_proba.shape[0] != target_model_labels.shape[0]:\n        raise ValueError('Number of rows in target_model_labels and attack_pred do not match')\n    results = []\n    if target_model_labels is not None:\n        (values, _) = np.unique(target_model_labels, return_counts=True)\n        for value in values:\n            idxs = np.where(target_model_labels == value)[0]\n            (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba[idxs], y_true=attack_true[idxs], targeted_fpr=targeted_fpr)\n            results.append((value, fpr, tpr, thr))\n        return results\n    (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=targeted_fpr)\n    return [(fpr, tpr, thr)]",
            "def get_roc_for_fpr(attack_proba: np.ndarray, attack_true: np.ndarray, target_model_labels: Optional[np.ndarray]=None, targeted_fpr: float=0.001) -> Union[List[Tuple[FPR, TPR, THR]], List[Tuple[int, FPR, TPR, THR]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the attack TPR, THRESHOLD and achieved FPR based on the targeted FPR. This implementation supports only\\n    binary attack prediction labels {0,1}. The returned THRESHOLD defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1)\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fpr: the targeted False Positive Rate, attack accuracy will be calculated based on this FPRs.\\n     If not supplied, get_roc_for_fpr will be computed for `0.001` FPR.\\n    :param target_model_labels: Original labels, if provided the Accuracy and threshold will be calculated per each\\n     class separately.\\n    :return: list of tuples the contains (original label (if target_model_labels is provided),\\n    Achieved FPR, TPR, Threshold).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    if target_model_labels is not None and attack_proba.shape[0] != target_model_labels.shape[0]:\n        raise ValueError('Number of rows in target_model_labels and attack_pred do not match')\n    results = []\n    if target_model_labels is not None:\n        (values, _) = np.unique(target_model_labels, return_counts=True)\n        for value in values:\n            idxs = np.where(target_model_labels == value)[0]\n            (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba[idxs], y_true=attack_true[idxs], targeted_fpr=targeted_fpr)\n            results.append((value, fpr, tpr, thr))\n        return results\n    (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=targeted_fpr)\n    return [(fpr, tpr, thr)]",
            "def get_roc_for_fpr(attack_proba: np.ndarray, attack_true: np.ndarray, target_model_labels: Optional[np.ndarray]=None, targeted_fpr: float=0.001) -> Union[List[Tuple[FPR, TPR, THR]], List[Tuple[int, FPR, TPR, THR]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the attack TPR, THRESHOLD and achieved FPR based on the targeted FPR. This implementation supports only\\n    binary attack prediction labels {0,1}. The returned THRESHOLD defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1)\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fpr: the targeted False Positive Rate, attack accuracy will be calculated based on this FPRs.\\n     If not supplied, get_roc_for_fpr will be computed for `0.001` FPR.\\n    :param target_model_labels: Original labels, if provided the Accuracy and threshold will be calculated per each\\n     class separately.\\n    :return: list of tuples the contains (original label (if target_model_labels is provided),\\n    Achieved FPR, TPR, Threshold).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    if target_model_labels is not None and attack_proba.shape[0] != target_model_labels.shape[0]:\n        raise ValueError('Number of rows in target_model_labels and attack_pred do not match')\n    results = []\n    if target_model_labels is not None:\n        (values, _) = np.unique(target_model_labels, return_counts=True)\n        for value in values:\n            idxs = np.where(target_model_labels == value)[0]\n            (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba[idxs], y_true=attack_true[idxs], targeted_fpr=targeted_fpr)\n            results.append((value, fpr, tpr, thr))\n        return results\n    (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=targeted_fpr)\n    return [(fpr, tpr, thr)]",
            "def get_roc_for_fpr(attack_proba: np.ndarray, attack_true: np.ndarray, target_model_labels: Optional[np.ndarray]=None, targeted_fpr: float=0.001) -> Union[List[Tuple[FPR, TPR, THR]], List[Tuple[int, FPR, TPR, THR]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the attack TPR, THRESHOLD and achieved FPR based on the targeted FPR. This implementation supports only\\n    binary attack prediction labels {0,1}. The returned THRESHOLD defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1)\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fpr: the targeted False Positive Rate, attack accuracy will be calculated based on this FPRs.\\n     If not supplied, get_roc_for_fpr will be computed for `0.001` FPR.\\n    :param target_model_labels: Original labels, if provided the Accuracy and threshold will be calculated per each\\n     class separately.\\n    :return: list of tuples the contains (original label (if target_model_labels is provided),\\n    Achieved FPR, TPR, Threshold).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    if target_model_labels is not None and attack_proba.shape[0] != target_model_labels.shape[0]:\n        raise ValueError('Number of rows in target_model_labels and attack_pred do not match')\n    results = []\n    if target_model_labels is not None:\n        (values, _) = np.unique(target_model_labels, return_counts=True)\n        for value in values:\n            idxs = np.where(target_model_labels == value)[0]\n            (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba[idxs], y_true=attack_true[idxs], targeted_fpr=targeted_fpr)\n            results.append((value, fpr, tpr, thr))\n        return results\n    (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=targeted_fpr)\n    return [(fpr, tpr, thr)]",
            "def get_roc_for_fpr(attack_proba: np.ndarray, attack_true: np.ndarray, target_model_labels: Optional[np.ndarray]=None, targeted_fpr: float=0.001) -> Union[List[Tuple[FPR, TPR, THR]], List[Tuple[int, FPR, TPR, THR]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the attack TPR, THRESHOLD and achieved FPR based on the targeted FPR. This implementation supports only\\n    binary attack prediction labels {0,1}. The returned THRESHOLD defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1)\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fpr: the targeted False Positive Rate, attack accuracy will be calculated based on this FPRs.\\n     If not supplied, get_roc_for_fpr will be computed for `0.001` FPR.\\n    :param target_model_labels: Original labels, if provided the Accuracy and threshold will be calculated per each\\n     class separately.\\n    :return: list of tuples the contains (original label (if target_model_labels is provided),\\n    Achieved FPR, TPR, Threshold).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    if target_model_labels is not None and attack_proba.shape[0] != target_model_labels.shape[0]:\n        raise ValueError('Number of rows in target_model_labels and attack_pred do not match')\n    results = []\n    if target_model_labels is not None:\n        (values, _) = np.unique(target_model_labels, return_counts=True)\n        for value in values:\n            idxs = np.where(target_model_labels == value)[0]\n            (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba[idxs], y_true=attack_true[idxs], targeted_fpr=targeted_fpr)\n            results.append((value, fpr, tpr, thr))\n        return results\n    (fpr, tpr, thr) = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=targeted_fpr)\n    return [(fpr, tpr, thr)]"
        ]
    },
    {
        "func_name": "get_roc_for_multi_fprs",
        "original": "def get_roc_for_multi_fprs(attack_proba: np.ndarray, attack_true: np.ndarray, targeted_fprs: np.ndarray) -> Tuple[List[FPR], List[TPR], List[THR]]:\n    \"\"\"\n    Compute the attack ROC based on the targeted FPRs. This implementation supports only binary\n    attack prediction labels. The returned list of THRESHOLDs defines the decision threshold on the attack\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1) for each provided fpr\n\n    | Related paper link: https://arxiv.org/abs/2112.03570\n\n    :param attack_proba: Predicted attack probabilities.\n    :param attack_true: True attack labels.\n    :param targeted_fprs: the set of targeted FPR (False Positive Rates), attack accuracy will be calculated based on\n    these FPRs.\n    :return: list of tuples that  (TPR, Threshold, Achieved FPR).\n    \"\"\"\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    tpr = []\n    thr = []\n    fpr = []\n    for t_fpr in targeted_fprs:\n        res = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=t_fpr)\n        fpr.append(res[0])\n        tpr.append(res[1])\n        thr.append(res[2])\n    return (fpr, tpr, thr)",
        "mutated": [
            "def get_roc_for_multi_fprs(attack_proba: np.ndarray, attack_true: np.ndarray, targeted_fprs: np.ndarray) -> Tuple[List[FPR], List[TPR], List[THR]]:\n    if False:\n        i = 10\n    '\\n    Compute the attack ROC based on the targeted FPRs. This implementation supports only binary\\n    attack prediction labels. The returned list of THRESHOLDs defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1) for each provided fpr\\n\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fprs: the set of targeted FPR (False Positive Rates), attack accuracy will be calculated based on\\n    these FPRs.\\n    :return: list of tuples that  (TPR, Threshold, Achieved FPR).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    tpr = []\n    thr = []\n    fpr = []\n    for t_fpr in targeted_fprs:\n        res = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=t_fpr)\n        fpr.append(res[0])\n        tpr.append(res[1])\n        thr.append(res[2])\n    return (fpr, tpr, thr)",
            "def get_roc_for_multi_fprs(attack_proba: np.ndarray, attack_true: np.ndarray, targeted_fprs: np.ndarray) -> Tuple[List[FPR], List[TPR], List[THR]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the attack ROC based on the targeted FPRs. This implementation supports only binary\\n    attack prediction labels. The returned list of THRESHOLDs defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1) for each provided fpr\\n\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fprs: the set of targeted FPR (False Positive Rates), attack accuracy will be calculated based on\\n    these FPRs.\\n    :return: list of tuples that  (TPR, Threshold, Achieved FPR).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    tpr = []\n    thr = []\n    fpr = []\n    for t_fpr in targeted_fprs:\n        res = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=t_fpr)\n        fpr.append(res[0])\n        tpr.append(res[1])\n        thr.append(res[2])\n    return (fpr, tpr, thr)",
            "def get_roc_for_multi_fprs(attack_proba: np.ndarray, attack_true: np.ndarray, targeted_fprs: np.ndarray) -> Tuple[List[FPR], List[TPR], List[THR]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the attack ROC based on the targeted FPRs. This implementation supports only binary\\n    attack prediction labels. The returned list of THRESHOLDs defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1) for each provided fpr\\n\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fprs: the set of targeted FPR (False Positive Rates), attack accuracy will be calculated based on\\n    these FPRs.\\n    :return: list of tuples that  (TPR, Threshold, Achieved FPR).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    tpr = []\n    thr = []\n    fpr = []\n    for t_fpr in targeted_fprs:\n        res = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=t_fpr)\n        fpr.append(res[0])\n        tpr.append(res[1])\n        thr.append(res[2])\n    return (fpr, tpr, thr)",
            "def get_roc_for_multi_fprs(attack_proba: np.ndarray, attack_true: np.ndarray, targeted_fprs: np.ndarray) -> Tuple[List[FPR], List[TPR], List[THR]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the attack ROC based on the targeted FPRs. This implementation supports only binary\\n    attack prediction labels. The returned list of THRESHOLDs defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1) for each provided fpr\\n\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fprs: the set of targeted FPR (False Positive Rates), attack accuracy will be calculated based on\\n    these FPRs.\\n    :return: list of tuples that  (TPR, Threshold, Achieved FPR).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    tpr = []\n    thr = []\n    fpr = []\n    for t_fpr in targeted_fprs:\n        res = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=t_fpr)\n        fpr.append(res[0])\n        tpr.append(res[1])\n        thr.append(res[2])\n    return (fpr, tpr, thr)",
            "def get_roc_for_multi_fprs(attack_proba: np.ndarray, attack_true: np.ndarray, targeted_fprs: np.ndarray) -> Tuple[List[FPR], List[TPR], List[THR]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the attack ROC based on the targeted FPRs. This implementation supports only binary\\n    attack prediction labels. The returned list of THRESHOLDs defines the decision threshold on the attack\\n    probabilities (meaning if p < THRESHOLD predict 0, otherwise predict 1) for each provided fpr\\n\\n    | Related paper link: https://arxiv.org/abs/2112.03570\\n\\n    :param attack_proba: Predicted attack probabilities.\\n    :param attack_true: True attack labels.\\n    :param targeted_fprs: the set of targeted FPR (False Positive Rates), attack accuracy will be calculated based on\\n    these FPRs.\\n    :return: list of tuples that  (TPR, Threshold, Achieved FPR).\\n    '\n    if attack_proba.shape[0] != attack_true.shape[0]:\n        raise ValueError('Number of rows in attack_pred and attack_true do not match')\n    tpr = []\n    thr = []\n    fpr = []\n    for t_fpr in targeted_fprs:\n        res = _calculate_roc_for_fpr(y_proba=attack_proba, y_true=attack_true, targeted_fpr=t_fpr)\n        fpr.append(res[0])\n        tpr.append(res[1])\n        thr.append(res[2])\n    return (fpr, tpr, thr)"
        ]
    }
]