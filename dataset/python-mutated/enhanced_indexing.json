[
    {
        "func_name": "__init__",
        "original": "def __init__(self, lamb: float=1, delta: Optional[float]=0.2, b_dev: Optional[float]=0.01, f_dev: Optional[Union[List[float], np.ndarray]]=None, scale_return: bool=True, epsilon: float=5e-05, solver_kwargs: Optional[Dict[str, Any]]={}):\n    \"\"\"\n        Args:\n            lamb (float): risk aversion parameter (larger `lamb` means more focus on risk)\n            delta (float): total turnover limit\n            b_dev (float): benchmark deviation limit\n            f_dev (list): factor deviation limit\n            scale_return (bool): whether scale return to match estimated volatility\n            epsilon (float): minimum weight\n            solver_kwargs (dict): kwargs for cvxpy solver\n        \"\"\"\n    assert lamb >= 0, 'risk aversion parameter `lamb` should be positive'\n    self.lamb = lamb\n    assert delta >= 0, 'turnover limit `delta` should be positive'\n    self.delta = delta\n    assert b_dev is None or b_dev >= 0, 'benchmark deviation limit `b_dev` should be positive'\n    self.b_dev = b_dev\n    if isinstance(f_dev, float):\n        assert f_dev >= 0, 'factor deviation limit `f_dev` should be positive'\n    elif f_dev is not None:\n        f_dev = np.array(f_dev)\n        assert all(f_dev >= 0), 'factor deviation limit `f_dev` should be positive'\n    self.f_dev = f_dev\n    self.scale_return = scale_return\n    self.epsilon = epsilon\n    self.solver_kwargs = solver_kwargs",
        "mutated": [
            "def __init__(self, lamb: float=1, delta: Optional[float]=0.2, b_dev: Optional[float]=0.01, f_dev: Optional[Union[List[float], np.ndarray]]=None, scale_return: bool=True, epsilon: float=5e-05, solver_kwargs: Optional[Dict[str, Any]]={}):\n    if False:\n        i = 10\n    '\\n        Args:\\n            lamb (float): risk aversion parameter (larger `lamb` means more focus on risk)\\n            delta (float): total turnover limit\\n            b_dev (float): benchmark deviation limit\\n            f_dev (list): factor deviation limit\\n            scale_return (bool): whether scale return to match estimated volatility\\n            epsilon (float): minimum weight\\n            solver_kwargs (dict): kwargs for cvxpy solver\\n        '\n    assert lamb >= 0, 'risk aversion parameter `lamb` should be positive'\n    self.lamb = lamb\n    assert delta >= 0, 'turnover limit `delta` should be positive'\n    self.delta = delta\n    assert b_dev is None or b_dev >= 0, 'benchmark deviation limit `b_dev` should be positive'\n    self.b_dev = b_dev\n    if isinstance(f_dev, float):\n        assert f_dev >= 0, 'factor deviation limit `f_dev` should be positive'\n    elif f_dev is not None:\n        f_dev = np.array(f_dev)\n        assert all(f_dev >= 0), 'factor deviation limit `f_dev` should be positive'\n    self.f_dev = f_dev\n    self.scale_return = scale_return\n    self.epsilon = epsilon\n    self.solver_kwargs = solver_kwargs",
            "def __init__(self, lamb: float=1, delta: Optional[float]=0.2, b_dev: Optional[float]=0.01, f_dev: Optional[Union[List[float], np.ndarray]]=None, scale_return: bool=True, epsilon: float=5e-05, solver_kwargs: Optional[Dict[str, Any]]={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Args:\\n            lamb (float): risk aversion parameter (larger `lamb` means more focus on risk)\\n            delta (float): total turnover limit\\n            b_dev (float): benchmark deviation limit\\n            f_dev (list): factor deviation limit\\n            scale_return (bool): whether scale return to match estimated volatility\\n            epsilon (float): minimum weight\\n            solver_kwargs (dict): kwargs for cvxpy solver\\n        '\n    assert lamb >= 0, 'risk aversion parameter `lamb` should be positive'\n    self.lamb = lamb\n    assert delta >= 0, 'turnover limit `delta` should be positive'\n    self.delta = delta\n    assert b_dev is None or b_dev >= 0, 'benchmark deviation limit `b_dev` should be positive'\n    self.b_dev = b_dev\n    if isinstance(f_dev, float):\n        assert f_dev >= 0, 'factor deviation limit `f_dev` should be positive'\n    elif f_dev is not None:\n        f_dev = np.array(f_dev)\n        assert all(f_dev >= 0), 'factor deviation limit `f_dev` should be positive'\n    self.f_dev = f_dev\n    self.scale_return = scale_return\n    self.epsilon = epsilon\n    self.solver_kwargs = solver_kwargs",
            "def __init__(self, lamb: float=1, delta: Optional[float]=0.2, b_dev: Optional[float]=0.01, f_dev: Optional[Union[List[float], np.ndarray]]=None, scale_return: bool=True, epsilon: float=5e-05, solver_kwargs: Optional[Dict[str, Any]]={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Args:\\n            lamb (float): risk aversion parameter (larger `lamb` means more focus on risk)\\n            delta (float): total turnover limit\\n            b_dev (float): benchmark deviation limit\\n            f_dev (list): factor deviation limit\\n            scale_return (bool): whether scale return to match estimated volatility\\n            epsilon (float): minimum weight\\n            solver_kwargs (dict): kwargs for cvxpy solver\\n        '\n    assert lamb >= 0, 'risk aversion parameter `lamb` should be positive'\n    self.lamb = lamb\n    assert delta >= 0, 'turnover limit `delta` should be positive'\n    self.delta = delta\n    assert b_dev is None or b_dev >= 0, 'benchmark deviation limit `b_dev` should be positive'\n    self.b_dev = b_dev\n    if isinstance(f_dev, float):\n        assert f_dev >= 0, 'factor deviation limit `f_dev` should be positive'\n    elif f_dev is not None:\n        f_dev = np.array(f_dev)\n        assert all(f_dev >= 0), 'factor deviation limit `f_dev` should be positive'\n    self.f_dev = f_dev\n    self.scale_return = scale_return\n    self.epsilon = epsilon\n    self.solver_kwargs = solver_kwargs",
            "def __init__(self, lamb: float=1, delta: Optional[float]=0.2, b_dev: Optional[float]=0.01, f_dev: Optional[Union[List[float], np.ndarray]]=None, scale_return: bool=True, epsilon: float=5e-05, solver_kwargs: Optional[Dict[str, Any]]={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Args:\\n            lamb (float): risk aversion parameter (larger `lamb` means more focus on risk)\\n            delta (float): total turnover limit\\n            b_dev (float): benchmark deviation limit\\n            f_dev (list): factor deviation limit\\n            scale_return (bool): whether scale return to match estimated volatility\\n            epsilon (float): minimum weight\\n            solver_kwargs (dict): kwargs for cvxpy solver\\n        '\n    assert lamb >= 0, 'risk aversion parameter `lamb` should be positive'\n    self.lamb = lamb\n    assert delta >= 0, 'turnover limit `delta` should be positive'\n    self.delta = delta\n    assert b_dev is None or b_dev >= 0, 'benchmark deviation limit `b_dev` should be positive'\n    self.b_dev = b_dev\n    if isinstance(f_dev, float):\n        assert f_dev >= 0, 'factor deviation limit `f_dev` should be positive'\n    elif f_dev is not None:\n        f_dev = np.array(f_dev)\n        assert all(f_dev >= 0), 'factor deviation limit `f_dev` should be positive'\n    self.f_dev = f_dev\n    self.scale_return = scale_return\n    self.epsilon = epsilon\n    self.solver_kwargs = solver_kwargs",
            "def __init__(self, lamb: float=1, delta: Optional[float]=0.2, b_dev: Optional[float]=0.01, f_dev: Optional[Union[List[float], np.ndarray]]=None, scale_return: bool=True, epsilon: float=5e-05, solver_kwargs: Optional[Dict[str, Any]]={}):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Args:\\n            lamb (float): risk aversion parameter (larger `lamb` means more focus on risk)\\n            delta (float): total turnover limit\\n            b_dev (float): benchmark deviation limit\\n            f_dev (list): factor deviation limit\\n            scale_return (bool): whether scale return to match estimated volatility\\n            epsilon (float): minimum weight\\n            solver_kwargs (dict): kwargs for cvxpy solver\\n        '\n    assert lamb >= 0, 'risk aversion parameter `lamb` should be positive'\n    self.lamb = lamb\n    assert delta >= 0, 'turnover limit `delta` should be positive'\n    self.delta = delta\n    assert b_dev is None or b_dev >= 0, 'benchmark deviation limit `b_dev` should be positive'\n    self.b_dev = b_dev\n    if isinstance(f_dev, float):\n        assert f_dev >= 0, 'factor deviation limit `f_dev` should be positive'\n    elif f_dev is not None:\n        f_dev = np.array(f_dev)\n        assert all(f_dev >= 0), 'factor deviation limit `f_dev` should be positive'\n    self.f_dev = f_dev\n    self.scale_return = scale_return\n    self.epsilon = epsilon\n    self.solver_kwargs = solver_kwargs"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, r: np.ndarray, F: np.ndarray, cov_b: np.ndarray, var_u: np.ndarray, w0: np.ndarray, wb: np.ndarray, mfh: Optional[np.ndarray]=None, mfs: Optional[np.ndarray]=None) -> np.ndarray:\n    \"\"\"\n        Args:\n            r (np.ndarray): expected returns\n            F (np.ndarray): factor exposure\n            cov_b (np.ndarray): factor covariance\n            var_u (np.ndarray): residual variance\n            w0 (np.ndarray): current holding weights\n            wb (np.ndarray): benchmark weights\n            mfh (np.ndarray): mask force holding\n            mfs (np.ndarray): mask force selling\n\n        Returns:\n            np.ndarray: optimized portfolio allocation\n        \"\"\"\n    if self.scale_return:\n        r = r / r.std()\n        r *= np.sqrt(np.mean(np.diag(F @ cov_b @ F.T) + var_u))\n    w = cp.Variable(len(r), nonneg=True)\n    w.value = wb\n    d = w - wb\n    v = d @ F\n    ret = d @ r\n    risk = cp.quad_form(v, cov_b) + var_u @ d ** 2\n    obj = cp.Maximize(ret - self.lamb * risk)\n    lb = np.zeros_like(wb)\n    ub = np.ones_like(wb)\n    if self.b_dev is not None:\n        lb = np.maximum(lb, wb - self.b_dev)\n        ub = np.minimum(ub, wb + self.b_dev)\n    if mfh is not None:\n        lb[mfh] = w0[mfh]\n        ub[mfh] = w0[mfh]\n    if mfs is not None:\n        lb[mfs] = 0\n        ub[mfs] = 0\n    cons = [cp.sum(w) == 1, w >= lb, w <= ub]\n    if self.f_dev is not None:\n        cons.extend([v >= -self.f_dev, v <= self.f_dev])\n    t_cons = []\n    if self.delta is not None:\n        if w0 is not None and w0.sum() > 0:\n            t_cons.extend([cp.norm(w - w0, 1) <= self.delta])\n    success = False\n    try:\n        prob = cp.Problem(obj, cons + t_cons)\n        prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n        assert prob.status == 'optimal'\n        success = True\n    except Exception as e:\n        logger.warning(f'trial 1 failed {e} (status: {prob.status})')\n    if not success and len(t_cons):\n        logger.info('try removing turnover constraint as the last optimization failed')\n        try:\n            w.value = wb\n            prob = cp.Problem(obj, cons)\n            prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n            assert prob.status in ['optimal', 'optimal_inaccurate']\n            success = True\n        except Exception as e:\n            logger.warning(f'trial 2 failed {e} (status: {prob.status})')\n    if not success:\n        logger.warning('optimization failed, will return current holding weight')\n        return w0\n    if prob.status == 'optimal_inaccurate':\n        logger.warning(f'the optimization is inaccurate')\n    w = np.asarray(w.value)\n    w[w < self.epsilon] = 0\n    w /= w.sum()\n    return w",
        "mutated": [
            "def __call__(self, r: np.ndarray, F: np.ndarray, cov_b: np.ndarray, var_u: np.ndarray, w0: np.ndarray, wb: np.ndarray, mfh: Optional[np.ndarray]=None, mfs: Optional[np.ndarray]=None) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n        Args:\\n            r (np.ndarray): expected returns\\n            F (np.ndarray): factor exposure\\n            cov_b (np.ndarray): factor covariance\\n            var_u (np.ndarray): residual variance\\n            w0 (np.ndarray): current holding weights\\n            wb (np.ndarray): benchmark weights\\n            mfh (np.ndarray): mask force holding\\n            mfs (np.ndarray): mask force selling\\n\\n        Returns:\\n            np.ndarray: optimized portfolio allocation\\n        '\n    if self.scale_return:\n        r = r / r.std()\n        r *= np.sqrt(np.mean(np.diag(F @ cov_b @ F.T) + var_u))\n    w = cp.Variable(len(r), nonneg=True)\n    w.value = wb\n    d = w - wb\n    v = d @ F\n    ret = d @ r\n    risk = cp.quad_form(v, cov_b) + var_u @ d ** 2\n    obj = cp.Maximize(ret - self.lamb * risk)\n    lb = np.zeros_like(wb)\n    ub = np.ones_like(wb)\n    if self.b_dev is not None:\n        lb = np.maximum(lb, wb - self.b_dev)\n        ub = np.minimum(ub, wb + self.b_dev)\n    if mfh is not None:\n        lb[mfh] = w0[mfh]\n        ub[mfh] = w0[mfh]\n    if mfs is not None:\n        lb[mfs] = 0\n        ub[mfs] = 0\n    cons = [cp.sum(w) == 1, w >= lb, w <= ub]\n    if self.f_dev is not None:\n        cons.extend([v >= -self.f_dev, v <= self.f_dev])\n    t_cons = []\n    if self.delta is not None:\n        if w0 is not None and w0.sum() > 0:\n            t_cons.extend([cp.norm(w - w0, 1) <= self.delta])\n    success = False\n    try:\n        prob = cp.Problem(obj, cons + t_cons)\n        prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n        assert prob.status == 'optimal'\n        success = True\n    except Exception as e:\n        logger.warning(f'trial 1 failed {e} (status: {prob.status})')\n    if not success and len(t_cons):\n        logger.info('try removing turnover constraint as the last optimization failed')\n        try:\n            w.value = wb\n            prob = cp.Problem(obj, cons)\n            prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n            assert prob.status in ['optimal', 'optimal_inaccurate']\n            success = True\n        except Exception as e:\n            logger.warning(f'trial 2 failed {e} (status: {prob.status})')\n    if not success:\n        logger.warning('optimization failed, will return current holding weight')\n        return w0\n    if prob.status == 'optimal_inaccurate':\n        logger.warning(f'the optimization is inaccurate')\n    w = np.asarray(w.value)\n    w[w < self.epsilon] = 0\n    w /= w.sum()\n    return w",
            "def __call__(self, r: np.ndarray, F: np.ndarray, cov_b: np.ndarray, var_u: np.ndarray, w0: np.ndarray, wb: np.ndarray, mfh: Optional[np.ndarray]=None, mfs: Optional[np.ndarray]=None) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Args:\\n            r (np.ndarray): expected returns\\n            F (np.ndarray): factor exposure\\n            cov_b (np.ndarray): factor covariance\\n            var_u (np.ndarray): residual variance\\n            w0 (np.ndarray): current holding weights\\n            wb (np.ndarray): benchmark weights\\n            mfh (np.ndarray): mask force holding\\n            mfs (np.ndarray): mask force selling\\n\\n        Returns:\\n            np.ndarray: optimized portfolio allocation\\n        '\n    if self.scale_return:\n        r = r / r.std()\n        r *= np.sqrt(np.mean(np.diag(F @ cov_b @ F.T) + var_u))\n    w = cp.Variable(len(r), nonneg=True)\n    w.value = wb\n    d = w - wb\n    v = d @ F\n    ret = d @ r\n    risk = cp.quad_form(v, cov_b) + var_u @ d ** 2\n    obj = cp.Maximize(ret - self.lamb * risk)\n    lb = np.zeros_like(wb)\n    ub = np.ones_like(wb)\n    if self.b_dev is not None:\n        lb = np.maximum(lb, wb - self.b_dev)\n        ub = np.minimum(ub, wb + self.b_dev)\n    if mfh is not None:\n        lb[mfh] = w0[mfh]\n        ub[mfh] = w0[mfh]\n    if mfs is not None:\n        lb[mfs] = 0\n        ub[mfs] = 0\n    cons = [cp.sum(w) == 1, w >= lb, w <= ub]\n    if self.f_dev is not None:\n        cons.extend([v >= -self.f_dev, v <= self.f_dev])\n    t_cons = []\n    if self.delta is not None:\n        if w0 is not None and w0.sum() > 0:\n            t_cons.extend([cp.norm(w - w0, 1) <= self.delta])\n    success = False\n    try:\n        prob = cp.Problem(obj, cons + t_cons)\n        prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n        assert prob.status == 'optimal'\n        success = True\n    except Exception as e:\n        logger.warning(f'trial 1 failed {e} (status: {prob.status})')\n    if not success and len(t_cons):\n        logger.info('try removing turnover constraint as the last optimization failed')\n        try:\n            w.value = wb\n            prob = cp.Problem(obj, cons)\n            prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n            assert prob.status in ['optimal', 'optimal_inaccurate']\n            success = True\n        except Exception as e:\n            logger.warning(f'trial 2 failed {e} (status: {prob.status})')\n    if not success:\n        logger.warning('optimization failed, will return current holding weight')\n        return w0\n    if prob.status == 'optimal_inaccurate':\n        logger.warning(f'the optimization is inaccurate')\n    w = np.asarray(w.value)\n    w[w < self.epsilon] = 0\n    w /= w.sum()\n    return w",
            "def __call__(self, r: np.ndarray, F: np.ndarray, cov_b: np.ndarray, var_u: np.ndarray, w0: np.ndarray, wb: np.ndarray, mfh: Optional[np.ndarray]=None, mfs: Optional[np.ndarray]=None) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Args:\\n            r (np.ndarray): expected returns\\n            F (np.ndarray): factor exposure\\n            cov_b (np.ndarray): factor covariance\\n            var_u (np.ndarray): residual variance\\n            w0 (np.ndarray): current holding weights\\n            wb (np.ndarray): benchmark weights\\n            mfh (np.ndarray): mask force holding\\n            mfs (np.ndarray): mask force selling\\n\\n        Returns:\\n            np.ndarray: optimized portfolio allocation\\n        '\n    if self.scale_return:\n        r = r / r.std()\n        r *= np.sqrt(np.mean(np.diag(F @ cov_b @ F.T) + var_u))\n    w = cp.Variable(len(r), nonneg=True)\n    w.value = wb\n    d = w - wb\n    v = d @ F\n    ret = d @ r\n    risk = cp.quad_form(v, cov_b) + var_u @ d ** 2\n    obj = cp.Maximize(ret - self.lamb * risk)\n    lb = np.zeros_like(wb)\n    ub = np.ones_like(wb)\n    if self.b_dev is not None:\n        lb = np.maximum(lb, wb - self.b_dev)\n        ub = np.minimum(ub, wb + self.b_dev)\n    if mfh is not None:\n        lb[mfh] = w0[mfh]\n        ub[mfh] = w0[mfh]\n    if mfs is not None:\n        lb[mfs] = 0\n        ub[mfs] = 0\n    cons = [cp.sum(w) == 1, w >= lb, w <= ub]\n    if self.f_dev is not None:\n        cons.extend([v >= -self.f_dev, v <= self.f_dev])\n    t_cons = []\n    if self.delta is not None:\n        if w0 is not None and w0.sum() > 0:\n            t_cons.extend([cp.norm(w - w0, 1) <= self.delta])\n    success = False\n    try:\n        prob = cp.Problem(obj, cons + t_cons)\n        prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n        assert prob.status == 'optimal'\n        success = True\n    except Exception as e:\n        logger.warning(f'trial 1 failed {e} (status: {prob.status})')\n    if not success and len(t_cons):\n        logger.info('try removing turnover constraint as the last optimization failed')\n        try:\n            w.value = wb\n            prob = cp.Problem(obj, cons)\n            prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n            assert prob.status in ['optimal', 'optimal_inaccurate']\n            success = True\n        except Exception as e:\n            logger.warning(f'trial 2 failed {e} (status: {prob.status})')\n    if not success:\n        logger.warning('optimization failed, will return current holding weight')\n        return w0\n    if prob.status == 'optimal_inaccurate':\n        logger.warning(f'the optimization is inaccurate')\n    w = np.asarray(w.value)\n    w[w < self.epsilon] = 0\n    w /= w.sum()\n    return w",
            "def __call__(self, r: np.ndarray, F: np.ndarray, cov_b: np.ndarray, var_u: np.ndarray, w0: np.ndarray, wb: np.ndarray, mfh: Optional[np.ndarray]=None, mfs: Optional[np.ndarray]=None) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Args:\\n            r (np.ndarray): expected returns\\n            F (np.ndarray): factor exposure\\n            cov_b (np.ndarray): factor covariance\\n            var_u (np.ndarray): residual variance\\n            w0 (np.ndarray): current holding weights\\n            wb (np.ndarray): benchmark weights\\n            mfh (np.ndarray): mask force holding\\n            mfs (np.ndarray): mask force selling\\n\\n        Returns:\\n            np.ndarray: optimized portfolio allocation\\n        '\n    if self.scale_return:\n        r = r / r.std()\n        r *= np.sqrt(np.mean(np.diag(F @ cov_b @ F.T) + var_u))\n    w = cp.Variable(len(r), nonneg=True)\n    w.value = wb\n    d = w - wb\n    v = d @ F\n    ret = d @ r\n    risk = cp.quad_form(v, cov_b) + var_u @ d ** 2\n    obj = cp.Maximize(ret - self.lamb * risk)\n    lb = np.zeros_like(wb)\n    ub = np.ones_like(wb)\n    if self.b_dev is not None:\n        lb = np.maximum(lb, wb - self.b_dev)\n        ub = np.minimum(ub, wb + self.b_dev)\n    if mfh is not None:\n        lb[mfh] = w0[mfh]\n        ub[mfh] = w0[mfh]\n    if mfs is not None:\n        lb[mfs] = 0\n        ub[mfs] = 0\n    cons = [cp.sum(w) == 1, w >= lb, w <= ub]\n    if self.f_dev is not None:\n        cons.extend([v >= -self.f_dev, v <= self.f_dev])\n    t_cons = []\n    if self.delta is not None:\n        if w0 is not None and w0.sum() > 0:\n            t_cons.extend([cp.norm(w - w0, 1) <= self.delta])\n    success = False\n    try:\n        prob = cp.Problem(obj, cons + t_cons)\n        prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n        assert prob.status == 'optimal'\n        success = True\n    except Exception as e:\n        logger.warning(f'trial 1 failed {e} (status: {prob.status})')\n    if not success and len(t_cons):\n        logger.info('try removing turnover constraint as the last optimization failed')\n        try:\n            w.value = wb\n            prob = cp.Problem(obj, cons)\n            prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n            assert prob.status in ['optimal', 'optimal_inaccurate']\n            success = True\n        except Exception as e:\n            logger.warning(f'trial 2 failed {e} (status: {prob.status})')\n    if not success:\n        logger.warning('optimization failed, will return current holding weight')\n        return w0\n    if prob.status == 'optimal_inaccurate':\n        logger.warning(f'the optimization is inaccurate')\n    w = np.asarray(w.value)\n    w[w < self.epsilon] = 0\n    w /= w.sum()\n    return w",
            "def __call__(self, r: np.ndarray, F: np.ndarray, cov_b: np.ndarray, var_u: np.ndarray, w0: np.ndarray, wb: np.ndarray, mfh: Optional[np.ndarray]=None, mfs: Optional[np.ndarray]=None) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Args:\\n            r (np.ndarray): expected returns\\n            F (np.ndarray): factor exposure\\n            cov_b (np.ndarray): factor covariance\\n            var_u (np.ndarray): residual variance\\n            w0 (np.ndarray): current holding weights\\n            wb (np.ndarray): benchmark weights\\n            mfh (np.ndarray): mask force holding\\n            mfs (np.ndarray): mask force selling\\n\\n        Returns:\\n            np.ndarray: optimized portfolio allocation\\n        '\n    if self.scale_return:\n        r = r / r.std()\n        r *= np.sqrt(np.mean(np.diag(F @ cov_b @ F.T) + var_u))\n    w = cp.Variable(len(r), nonneg=True)\n    w.value = wb\n    d = w - wb\n    v = d @ F\n    ret = d @ r\n    risk = cp.quad_form(v, cov_b) + var_u @ d ** 2\n    obj = cp.Maximize(ret - self.lamb * risk)\n    lb = np.zeros_like(wb)\n    ub = np.ones_like(wb)\n    if self.b_dev is not None:\n        lb = np.maximum(lb, wb - self.b_dev)\n        ub = np.minimum(ub, wb + self.b_dev)\n    if mfh is not None:\n        lb[mfh] = w0[mfh]\n        ub[mfh] = w0[mfh]\n    if mfs is not None:\n        lb[mfs] = 0\n        ub[mfs] = 0\n    cons = [cp.sum(w) == 1, w >= lb, w <= ub]\n    if self.f_dev is not None:\n        cons.extend([v >= -self.f_dev, v <= self.f_dev])\n    t_cons = []\n    if self.delta is not None:\n        if w0 is not None and w0.sum() > 0:\n            t_cons.extend([cp.norm(w - w0, 1) <= self.delta])\n    success = False\n    try:\n        prob = cp.Problem(obj, cons + t_cons)\n        prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n        assert prob.status == 'optimal'\n        success = True\n    except Exception as e:\n        logger.warning(f'trial 1 failed {e} (status: {prob.status})')\n    if not success and len(t_cons):\n        logger.info('try removing turnover constraint as the last optimization failed')\n        try:\n            w.value = wb\n            prob = cp.Problem(obj, cons)\n            prob.solve(solver=cp.ECOS, warm_start=True, **self.solver_kwargs)\n            assert prob.status in ['optimal', 'optimal_inaccurate']\n            success = True\n        except Exception as e:\n            logger.warning(f'trial 2 failed {e} (status: {prob.status})')\n    if not success:\n        logger.warning('optimization failed, will return current holding weight')\n        return w0\n    if prob.status == 'optimal_inaccurate':\n        logger.warning(f'the optimization is inaccurate')\n    w = np.asarray(w.value)\n    w[w < self.epsilon] = 0\n    w /= w.sum()\n    return w"
        ]
    }
]