[
    {
        "func_name": "distance_transform_edt",
        "original": "def distance_transform_edt(image, sampling=None, return_distances=True, return_indices=False, distances=None, indices=None, *, block_params=None, float64_distances=True):\n    \"\"\"Exact Euclidean distance transform.\n\n    This function calculates the distance transform of the `input`, by\n    replacing each foreground (non-zero) element, with its shortest distance to\n    the background (any zero-valued element).\n\n    In addition to the distance transform, the feature transform can be\n    calculated. In this case the index of the closest background element to\n    each foreground element is returned in a separate array.\n\n    Parameters\n    ----------\n    image : array_like\n        Input data to transform. Can be any type but will be converted into\n        binary: 1 wherever image equates to True, 0 elsewhere.\n    sampling : float, or sequence of float, optional\n        Spacing of elements along each dimension. If a sequence, must be of\n        length equal to the image rank; if a single number, this is used for\n        all axes. If not specified, a grid spacing of unity is implied.\n    return_distances : bool, optional\n        Whether to calculate the distance transform.\n    return_indices : bool, optional\n        Whether to calculate the feature transform.\n    distances : cupy.ndarray, optional\n        An output array to store the calculated distance transform, instead of\n        returning it. `return_distances` must be ``True``. It must be the same\n        shape as `image`. Should have dtype ``cp.float32`` if\n        `float64_distances` is ``False``, otherwise it should be\n        ``cp.float64``.\n    indices : cupy.ndarray, optional\n        An output array to store the calculated feature transform, instead of\n        returning it. `return_indicies` must be ``True``. Its shape must be\n        ``(image.ndim,) + image.shape``. Its dtype must be a signed or unsigned\n        integer type of at least 16-bits in 2D or 32-bits in 3D.\n\n    Other Parameters\n    ----------------\n    block_params : 3-tuple of int\n        The m1, m2, m3 algorithm parameters as described in [2]_. If None,\n        suitable defaults will be chosen. Note: This parameter is specific to\n        cuCIM and does not exist in SciPy.\n    float64_distances : bool, optional\n        If True, use double precision in the distance computation (to match\n        SciPy behavior). Otherwise, single precision will be used for\n        efficiency. Note: This parameter is specific to cuCIM and does not\n        exist in SciPy.\n\n    Returns\n    -------\n    distances : cupy.ndarray, optional\n        The calculated distance transform. Returned only when\n        `return_distances` is ``True`` and `distances` is not supplied. It will\n        have the same shape as `image`. Will have dtype `cp.float64` if\n        `float64_distances` is ``True``, otherwise it will have dtype\n        ``cp.float32``.\n    indices : ndarray, optional\n        The calculated feature transform. It has an image-shaped array for each\n        dimension of the image. See example below. Returned only when\n        `return_indices` is ``True`` and `indices` is not supplied.\n\n    Notes\n    -----\n    The Euclidean distance transform gives values of the Euclidean distance.\n\n    .. math::\n\n      y_i = \\\\sqrt{\\\\sum_{i}^{n} (x[i] - b[i])^2}\n\n    where :math:`b[i]` is the background point (value 0) with the smallest\n    Euclidean distance to input points :math:`x[i]`, and :math:`n` is the\n    number of dimensions.\n\n    Note that the `indices` output may differ from the one given by\n    :func:`scipy.ndimage.distance_transform_edt` in the case of input pixels\n    that are equidistant from multiple background points.\n\n    The parallel banding algorithm implemented here was originally described in\n    [1]_. The kernels used here correspond to the revised PBA+ implementation\n    that is described on the author's website [2]_. The source code of the\n    author's PBA+ implementation is available at [3]_.\n\n    References\n    ----------\n    .. [1] Thanh-Tung Cao, Ke Tang, Anis Mohamed, and Tiow-Seng Tan. 2010.\n        Parallel Banding Algorithm to compute exact distance transform with the\n        GPU. In Proceedings of the 2010 ACM SIGGRAPH symposium on Interactive\n        3D Graphics and Games (I3D \u201910). Association for Computing Machinery,\n        New York, NY, USA, 83\u201390.\n        DOI:https://doi.org/10.1145/1730804.1730818\n    .. [2] https://www.comp.nus.edu.sg/~tants/pba.html\n    .. [3] https://github.com/orzzzjq/Parallel-Banding-Algorithm-plus\n\n    Examples\n    --------\n    >>> import cupy as cp\n    >>> from cucim.core.operations import morphology\n    >>> a = cp.array(([0,1,1,1,1],\n    ...               [0,0,1,1,1],\n    ...               [0,1,1,1,1],\n    ...               [0,1,1,1,0],\n    ...               [0,1,1,0,0]))\n    >>> morphology.distance_transform_edt(a)\n    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],\n           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],\n           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\n\n    With a sampling of 2 units along x, 1 along y:\n\n    >>> morphology.distance_transform_edt(a, sampling=[2,1])\n    array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],\n           [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],\n           [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\n\n    Asking for indices as well:\n\n    >>> edt, inds = morphology.distance_transform_edt(a, return_indices=True)\n    >>> inds\n    array([[[0, 0, 1, 1, 3],\n            [1, 1, 1, 1, 3],\n            [2, 2, 1, 3, 3],\n            [3, 3, 4, 4, 3],\n            [4, 4, 4, 4, 4]],\n           [[0, 0, 1, 1, 4],\n            [0, 1, 1, 1, 4],\n            [0, 0, 1, 4, 4],\n            [0, 0, 3, 3, 4],\n            [0, 0, 3, 3, 4]]])\n\n    \"\"\"\n    scalar_sampling = None\n    if sampling is not None:\n        if isinstance(sampling, numbers.Number):\n            sampling = (sampling,)\n        if len(set(sampling)) == 1:\n            scalar_sampling = float(sampling[0])\n            sampling = None\n    if image.ndim == 3:\n        pba_func = _pba_3d\n    elif image.ndim == 2:\n        pba_func = _pba_2d\n    else:\n        raise NotImplementedError('Only 2D and 3D distance transforms are supported.')\n    vals = pba_func(image, sampling=sampling, return_distances=return_distances, return_indices=return_indices, block_params=block_params, distances=distances, indices=indices, float64_distances=float64_distances)\n    if return_distances and scalar_sampling is not None:\n        vals = list(vals)\n        vals[0] *= scalar_sampling\n        vals = tuple(vals)\n    if len(vals) == 1:\n        vals = vals[0]\n    return vals",
        "mutated": [
            "def distance_transform_edt(image, sampling=None, return_distances=True, return_indices=False, distances=None, indices=None, *, block_params=None, float64_distances=True):\n    if False:\n        i = 10\n    \"Exact Euclidean distance transform.\\n\\n    This function calculates the distance transform of the `input`, by\\n    replacing each foreground (non-zero) element, with its shortest distance to\\n    the background (any zero-valued element).\\n\\n    In addition to the distance transform, the feature transform can be\\n    calculated. In this case the index of the closest background element to\\n    each foreground element is returned in a separate array.\\n\\n    Parameters\\n    ----------\\n    image : array_like\\n        Input data to transform. Can be any type but will be converted into\\n        binary: 1 wherever image equates to True, 0 elsewhere.\\n    sampling : float, or sequence of float, optional\\n        Spacing of elements along each dimension. If a sequence, must be of\\n        length equal to the image rank; if a single number, this is used for\\n        all axes. If not specified, a grid spacing of unity is implied.\\n    return_distances : bool, optional\\n        Whether to calculate the distance transform.\\n    return_indices : bool, optional\\n        Whether to calculate the feature transform.\\n    distances : cupy.ndarray, optional\\n        An output array to store the calculated distance transform, instead of\\n        returning it. `return_distances` must be ``True``. It must be the same\\n        shape as `image`. Should have dtype ``cp.float32`` if\\n        `float64_distances` is ``False``, otherwise it should be\\n        ``cp.float64``.\\n    indices : cupy.ndarray, optional\\n        An output array to store the calculated feature transform, instead of\\n        returning it. `return_indicies` must be ``True``. Its shape must be\\n        ``(image.ndim,) + image.shape``. Its dtype must be a signed or unsigned\\n        integer type of at least 16-bits in 2D or 32-bits in 3D.\\n\\n    Other Parameters\\n    ----------------\\n    block_params : 3-tuple of int\\n        The m1, m2, m3 algorithm parameters as described in [2]_. If None,\\n        suitable defaults will be chosen. Note: This parameter is specific to\\n        cuCIM and does not exist in SciPy.\\n    float64_distances : bool, optional\\n        If True, use double precision in the distance computation (to match\\n        SciPy behavior). Otherwise, single precision will be used for\\n        efficiency. Note: This parameter is specific to cuCIM and does not\\n        exist in SciPy.\\n\\n    Returns\\n    -------\\n    distances : cupy.ndarray, optional\\n        The calculated distance transform. Returned only when\\n        `return_distances` is ``True`` and `distances` is not supplied. It will\\n        have the same shape as `image`. Will have dtype `cp.float64` if\\n        `float64_distances` is ``True``, otherwise it will have dtype\\n        ``cp.float32``.\\n    indices : ndarray, optional\\n        The calculated feature transform. It has an image-shaped array for each\\n        dimension of the image. See example below. Returned only when\\n        `return_indices` is ``True`` and `indices` is not supplied.\\n\\n    Notes\\n    -----\\n    The Euclidean distance transform gives values of the Euclidean distance.\\n\\n    .. math::\\n\\n      y_i = \\\\sqrt{\\\\sum_{i}^{n} (x[i] - b[i])^2}\\n\\n    where :math:`b[i]` is the background point (value 0) with the smallest\\n    Euclidean distance to input points :math:`x[i]`, and :math:`n` is the\\n    number of dimensions.\\n\\n    Note that the `indices` output may differ from the one given by\\n    :func:`scipy.ndimage.distance_transform_edt` in the case of input pixels\\n    that are equidistant from multiple background points.\\n\\n    The parallel banding algorithm implemented here was originally described in\\n    [1]_. The kernels used here correspond to the revised PBA+ implementation\\n    that is described on the author's website [2]_. The source code of the\\n    author's PBA+ implementation is available at [3]_.\\n\\n    References\\n    ----------\\n    .. [1] Thanh-Tung Cao, Ke Tang, Anis Mohamed, and Tiow-Seng Tan. 2010.\\n        Parallel Banding Algorithm to compute exact distance transform with the\\n        GPU. In Proceedings of the 2010 ACM SIGGRAPH symposium on Interactive\\n        3D Graphics and Games (I3D \u201910). Association for Computing Machinery,\\n        New York, NY, USA, 83\u201390.\\n        DOI:https://doi.org/10.1145/1730804.1730818\\n    .. [2] https://www.comp.nus.edu.sg/~tants/pba.html\\n    .. [3] https://github.com/orzzzjq/Parallel-Banding-Algorithm-plus\\n\\n    Examples\\n    --------\\n    >>> import cupy as cp\\n    >>> from cucim.core.operations import morphology\\n    >>> a = cp.array(([0,1,1,1,1],\\n    ...               [0,0,1,1,1],\\n    ...               [0,1,1,1,1],\\n    ...               [0,1,1,1,0],\\n    ...               [0,1,1,0,0]))\\n    >>> morphology.distance_transform_edt(a)\\n    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    With a sampling of 2 units along x, 1 along y:\\n\\n    >>> morphology.distance_transform_edt(a, sampling=[2,1])\\n    array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],\\n           [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],\\n           [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    Asking for indices as well:\\n\\n    >>> edt, inds = morphology.distance_transform_edt(a, return_indices=True)\\n    >>> inds\\n    array([[[0, 0, 1, 1, 3],\\n            [1, 1, 1, 1, 3],\\n            [2, 2, 1, 3, 3],\\n            [3, 3, 4, 4, 3],\\n            [4, 4, 4, 4, 4]],\\n           [[0, 0, 1, 1, 4],\\n            [0, 1, 1, 1, 4],\\n            [0, 0, 1, 4, 4],\\n            [0, 0, 3, 3, 4],\\n            [0, 0, 3, 3, 4]]])\\n\\n    \"\n    scalar_sampling = None\n    if sampling is not None:\n        if isinstance(sampling, numbers.Number):\n            sampling = (sampling,)\n        if len(set(sampling)) == 1:\n            scalar_sampling = float(sampling[0])\n            sampling = None\n    if image.ndim == 3:\n        pba_func = _pba_3d\n    elif image.ndim == 2:\n        pba_func = _pba_2d\n    else:\n        raise NotImplementedError('Only 2D and 3D distance transforms are supported.')\n    vals = pba_func(image, sampling=sampling, return_distances=return_distances, return_indices=return_indices, block_params=block_params, distances=distances, indices=indices, float64_distances=float64_distances)\n    if return_distances and scalar_sampling is not None:\n        vals = list(vals)\n        vals[0] *= scalar_sampling\n        vals = tuple(vals)\n    if len(vals) == 1:\n        vals = vals[0]\n    return vals",
            "def distance_transform_edt(image, sampling=None, return_distances=True, return_indices=False, distances=None, indices=None, *, block_params=None, float64_distances=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Exact Euclidean distance transform.\\n\\n    This function calculates the distance transform of the `input`, by\\n    replacing each foreground (non-zero) element, with its shortest distance to\\n    the background (any zero-valued element).\\n\\n    In addition to the distance transform, the feature transform can be\\n    calculated. In this case the index of the closest background element to\\n    each foreground element is returned in a separate array.\\n\\n    Parameters\\n    ----------\\n    image : array_like\\n        Input data to transform. Can be any type but will be converted into\\n        binary: 1 wherever image equates to True, 0 elsewhere.\\n    sampling : float, or sequence of float, optional\\n        Spacing of elements along each dimension. If a sequence, must be of\\n        length equal to the image rank; if a single number, this is used for\\n        all axes. If not specified, a grid spacing of unity is implied.\\n    return_distances : bool, optional\\n        Whether to calculate the distance transform.\\n    return_indices : bool, optional\\n        Whether to calculate the feature transform.\\n    distances : cupy.ndarray, optional\\n        An output array to store the calculated distance transform, instead of\\n        returning it. `return_distances` must be ``True``. It must be the same\\n        shape as `image`. Should have dtype ``cp.float32`` if\\n        `float64_distances` is ``False``, otherwise it should be\\n        ``cp.float64``.\\n    indices : cupy.ndarray, optional\\n        An output array to store the calculated feature transform, instead of\\n        returning it. `return_indicies` must be ``True``. Its shape must be\\n        ``(image.ndim,) + image.shape``. Its dtype must be a signed or unsigned\\n        integer type of at least 16-bits in 2D or 32-bits in 3D.\\n\\n    Other Parameters\\n    ----------------\\n    block_params : 3-tuple of int\\n        The m1, m2, m3 algorithm parameters as described in [2]_. If None,\\n        suitable defaults will be chosen. Note: This parameter is specific to\\n        cuCIM and does not exist in SciPy.\\n    float64_distances : bool, optional\\n        If True, use double precision in the distance computation (to match\\n        SciPy behavior). Otherwise, single precision will be used for\\n        efficiency. Note: This parameter is specific to cuCIM and does not\\n        exist in SciPy.\\n\\n    Returns\\n    -------\\n    distances : cupy.ndarray, optional\\n        The calculated distance transform. Returned only when\\n        `return_distances` is ``True`` and `distances` is not supplied. It will\\n        have the same shape as `image`. Will have dtype `cp.float64` if\\n        `float64_distances` is ``True``, otherwise it will have dtype\\n        ``cp.float32``.\\n    indices : ndarray, optional\\n        The calculated feature transform. It has an image-shaped array for each\\n        dimension of the image. See example below. Returned only when\\n        `return_indices` is ``True`` and `indices` is not supplied.\\n\\n    Notes\\n    -----\\n    The Euclidean distance transform gives values of the Euclidean distance.\\n\\n    .. math::\\n\\n      y_i = \\\\sqrt{\\\\sum_{i}^{n} (x[i] - b[i])^2}\\n\\n    where :math:`b[i]` is the background point (value 0) with the smallest\\n    Euclidean distance to input points :math:`x[i]`, and :math:`n` is the\\n    number of dimensions.\\n\\n    Note that the `indices` output may differ from the one given by\\n    :func:`scipy.ndimage.distance_transform_edt` in the case of input pixels\\n    that are equidistant from multiple background points.\\n\\n    The parallel banding algorithm implemented here was originally described in\\n    [1]_. The kernels used here correspond to the revised PBA+ implementation\\n    that is described on the author's website [2]_. The source code of the\\n    author's PBA+ implementation is available at [3]_.\\n\\n    References\\n    ----------\\n    .. [1] Thanh-Tung Cao, Ke Tang, Anis Mohamed, and Tiow-Seng Tan. 2010.\\n        Parallel Banding Algorithm to compute exact distance transform with the\\n        GPU. In Proceedings of the 2010 ACM SIGGRAPH symposium on Interactive\\n        3D Graphics and Games (I3D \u201910). Association for Computing Machinery,\\n        New York, NY, USA, 83\u201390.\\n        DOI:https://doi.org/10.1145/1730804.1730818\\n    .. [2] https://www.comp.nus.edu.sg/~tants/pba.html\\n    .. [3] https://github.com/orzzzjq/Parallel-Banding-Algorithm-plus\\n\\n    Examples\\n    --------\\n    >>> import cupy as cp\\n    >>> from cucim.core.operations import morphology\\n    >>> a = cp.array(([0,1,1,1,1],\\n    ...               [0,0,1,1,1],\\n    ...               [0,1,1,1,1],\\n    ...               [0,1,1,1,0],\\n    ...               [0,1,1,0,0]))\\n    >>> morphology.distance_transform_edt(a)\\n    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    With a sampling of 2 units along x, 1 along y:\\n\\n    >>> morphology.distance_transform_edt(a, sampling=[2,1])\\n    array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],\\n           [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],\\n           [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    Asking for indices as well:\\n\\n    >>> edt, inds = morphology.distance_transform_edt(a, return_indices=True)\\n    >>> inds\\n    array([[[0, 0, 1, 1, 3],\\n            [1, 1, 1, 1, 3],\\n            [2, 2, 1, 3, 3],\\n            [3, 3, 4, 4, 3],\\n            [4, 4, 4, 4, 4]],\\n           [[0, 0, 1, 1, 4],\\n            [0, 1, 1, 1, 4],\\n            [0, 0, 1, 4, 4],\\n            [0, 0, 3, 3, 4],\\n            [0, 0, 3, 3, 4]]])\\n\\n    \"\n    scalar_sampling = None\n    if sampling is not None:\n        if isinstance(sampling, numbers.Number):\n            sampling = (sampling,)\n        if len(set(sampling)) == 1:\n            scalar_sampling = float(sampling[0])\n            sampling = None\n    if image.ndim == 3:\n        pba_func = _pba_3d\n    elif image.ndim == 2:\n        pba_func = _pba_2d\n    else:\n        raise NotImplementedError('Only 2D and 3D distance transforms are supported.')\n    vals = pba_func(image, sampling=sampling, return_distances=return_distances, return_indices=return_indices, block_params=block_params, distances=distances, indices=indices, float64_distances=float64_distances)\n    if return_distances and scalar_sampling is not None:\n        vals = list(vals)\n        vals[0] *= scalar_sampling\n        vals = tuple(vals)\n    if len(vals) == 1:\n        vals = vals[0]\n    return vals",
            "def distance_transform_edt(image, sampling=None, return_distances=True, return_indices=False, distances=None, indices=None, *, block_params=None, float64_distances=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Exact Euclidean distance transform.\\n\\n    This function calculates the distance transform of the `input`, by\\n    replacing each foreground (non-zero) element, with its shortest distance to\\n    the background (any zero-valued element).\\n\\n    In addition to the distance transform, the feature transform can be\\n    calculated. In this case the index of the closest background element to\\n    each foreground element is returned in a separate array.\\n\\n    Parameters\\n    ----------\\n    image : array_like\\n        Input data to transform. Can be any type but will be converted into\\n        binary: 1 wherever image equates to True, 0 elsewhere.\\n    sampling : float, or sequence of float, optional\\n        Spacing of elements along each dimension. If a sequence, must be of\\n        length equal to the image rank; if a single number, this is used for\\n        all axes. If not specified, a grid spacing of unity is implied.\\n    return_distances : bool, optional\\n        Whether to calculate the distance transform.\\n    return_indices : bool, optional\\n        Whether to calculate the feature transform.\\n    distances : cupy.ndarray, optional\\n        An output array to store the calculated distance transform, instead of\\n        returning it. `return_distances` must be ``True``. It must be the same\\n        shape as `image`. Should have dtype ``cp.float32`` if\\n        `float64_distances` is ``False``, otherwise it should be\\n        ``cp.float64``.\\n    indices : cupy.ndarray, optional\\n        An output array to store the calculated feature transform, instead of\\n        returning it. `return_indicies` must be ``True``. Its shape must be\\n        ``(image.ndim,) + image.shape``. Its dtype must be a signed or unsigned\\n        integer type of at least 16-bits in 2D or 32-bits in 3D.\\n\\n    Other Parameters\\n    ----------------\\n    block_params : 3-tuple of int\\n        The m1, m2, m3 algorithm parameters as described in [2]_. If None,\\n        suitable defaults will be chosen. Note: This parameter is specific to\\n        cuCIM and does not exist in SciPy.\\n    float64_distances : bool, optional\\n        If True, use double precision in the distance computation (to match\\n        SciPy behavior). Otherwise, single precision will be used for\\n        efficiency. Note: This parameter is specific to cuCIM and does not\\n        exist in SciPy.\\n\\n    Returns\\n    -------\\n    distances : cupy.ndarray, optional\\n        The calculated distance transform. Returned only when\\n        `return_distances` is ``True`` and `distances` is not supplied. It will\\n        have the same shape as `image`. Will have dtype `cp.float64` if\\n        `float64_distances` is ``True``, otherwise it will have dtype\\n        ``cp.float32``.\\n    indices : ndarray, optional\\n        The calculated feature transform. It has an image-shaped array for each\\n        dimension of the image. See example below. Returned only when\\n        `return_indices` is ``True`` and `indices` is not supplied.\\n\\n    Notes\\n    -----\\n    The Euclidean distance transform gives values of the Euclidean distance.\\n\\n    .. math::\\n\\n      y_i = \\\\sqrt{\\\\sum_{i}^{n} (x[i] - b[i])^2}\\n\\n    where :math:`b[i]` is the background point (value 0) with the smallest\\n    Euclidean distance to input points :math:`x[i]`, and :math:`n` is the\\n    number of dimensions.\\n\\n    Note that the `indices` output may differ from the one given by\\n    :func:`scipy.ndimage.distance_transform_edt` in the case of input pixels\\n    that are equidistant from multiple background points.\\n\\n    The parallel banding algorithm implemented here was originally described in\\n    [1]_. The kernels used here correspond to the revised PBA+ implementation\\n    that is described on the author's website [2]_. The source code of the\\n    author's PBA+ implementation is available at [3]_.\\n\\n    References\\n    ----------\\n    .. [1] Thanh-Tung Cao, Ke Tang, Anis Mohamed, and Tiow-Seng Tan. 2010.\\n        Parallel Banding Algorithm to compute exact distance transform with the\\n        GPU. In Proceedings of the 2010 ACM SIGGRAPH symposium on Interactive\\n        3D Graphics and Games (I3D \u201910). Association for Computing Machinery,\\n        New York, NY, USA, 83\u201390.\\n        DOI:https://doi.org/10.1145/1730804.1730818\\n    .. [2] https://www.comp.nus.edu.sg/~tants/pba.html\\n    .. [3] https://github.com/orzzzjq/Parallel-Banding-Algorithm-plus\\n\\n    Examples\\n    --------\\n    >>> import cupy as cp\\n    >>> from cucim.core.operations import morphology\\n    >>> a = cp.array(([0,1,1,1,1],\\n    ...               [0,0,1,1,1],\\n    ...               [0,1,1,1,1],\\n    ...               [0,1,1,1,0],\\n    ...               [0,1,1,0,0]))\\n    >>> morphology.distance_transform_edt(a)\\n    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    With a sampling of 2 units along x, 1 along y:\\n\\n    >>> morphology.distance_transform_edt(a, sampling=[2,1])\\n    array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],\\n           [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],\\n           [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    Asking for indices as well:\\n\\n    >>> edt, inds = morphology.distance_transform_edt(a, return_indices=True)\\n    >>> inds\\n    array([[[0, 0, 1, 1, 3],\\n            [1, 1, 1, 1, 3],\\n            [2, 2, 1, 3, 3],\\n            [3, 3, 4, 4, 3],\\n            [4, 4, 4, 4, 4]],\\n           [[0, 0, 1, 1, 4],\\n            [0, 1, 1, 1, 4],\\n            [0, 0, 1, 4, 4],\\n            [0, 0, 3, 3, 4],\\n            [0, 0, 3, 3, 4]]])\\n\\n    \"\n    scalar_sampling = None\n    if sampling is not None:\n        if isinstance(sampling, numbers.Number):\n            sampling = (sampling,)\n        if len(set(sampling)) == 1:\n            scalar_sampling = float(sampling[0])\n            sampling = None\n    if image.ndim == 3:\n        pba_func = _pba_3d\n    elif image.ndim == 2:\n        pba_func = _pba_2d\n    else:\n        raise NotImplementedError('Only 2D and 3D distance transforms are supported.')\n    vals = pba_func(image, sampling=sampling, return_distances=return_distances, return_indices=return_indices, block_params=block_params, distances=distances, indices=indices, float64_distances=float64_distances)\n    if return_distances and scalar_sampling is not None:\n        vals = list(vals)\n        vals[0] *= scalar_sampling\n        vals = tuple(vals)\n    if len(vals) == 1:\n        vals = vals[0]\n    return vals",
            "def distance_transform_edt(image, sampling=None, return_distances=True, return_indices=False, distances=None, indices=None, *, block_params=None, float64_distances=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Exact Euclidean distance transform.\\n\\n    This function calculates the distance transform of the `input`, by\\n    replacing each foreground (non-zero) element, with its shortest distance to\\n    the background (any zero-valued element).\\n\\n    In addition to the distance transform, the feature transform can be\\n    calculated. In this case the index of the closest background element to\\n    each foreground element is returned in a separate array.\\n\\n    Parameters\\n    ----------\\n    image : array_like\\n        Input data to transform. Can be any type but will be converted into\\n        binary: 1 wherever image equates to True, 0 elsewhere.\\n    sampling : float, or sequence of float, optional\\n        Spacing of elements along each dimension. If a sequence, must be of\\n        length equal to the image rank; if a single number, this is used for\\n        all axes. If not specified, a grid spacing of unity is implied.\\n    return_distances : bool, optional\\n        Whether to calculate the distance transform.\\n    return_indices : bool, optional\\n        Whether to calculate the feature transform.\\n    distances : cupy.ndarray, optional\\n        An output array to store the calculated distance transform, instead of\\n        returning it. `return_distances` must be ``True``. It must be the same\\n        shape as `image`. Should have dtype ``cp.float32`` if\\n        `float64_distances` is ``False``, otherwise it should be\\n        ``cp.float64``.\\n    indices : cupy.ndarray, optional\\n        An output array to store the calculated feature transform, instead of\\n        returning it. `return_indicies` must be ``True``. Its shape must be\\n        ``(image.ndim,) + image.shape``. Its dtype must be a signed or unsigned\\n        integer type of at least 16-bits in 2D or 32-bits in 3D.\\n\\n    Other Parameters\\n    ----------------\\n    block_params : 3-tuple of int\\n        The m1, m2, m3 algorithm parameters as described in [2]_. If None,\\n        suitable defaults will be chosen. Note: This parameter is specific to\\n        cuCIM and does not exist in SciPy.\\n    float64_distances : bool, optional\\n        If True, use double precision in the distance computation (to match\\n        SciPy behavior). Otherwise, single precision will be used for\\n        efficiency. Note: This parameter is specific to cuCIM and does not\\n        exist in SciPy.\\n\\n    Returns\\n    -------\\n    distances : cupy.ndarray, optional\\n        The calculated distance transform. Returned only when\\n        `return_distances` is ``True`` and `distances` is not supplied. It will\\n        have the same shape as `image`. Will have dtype `cp.float64` if\\n        `float64_distances` is ``True``, otherwise it will have dtype\\n        ``cp.float32``.\\n    indices : ndarray, optional\\n        The calculated feature transform. It has an image-shaped array for each\\n        dimension of the image. See example below. Returned only when\\n        `return_indices` is ``True`` and `indices` is not supplied.\\n\\n    Notes\\n    -----\\n    The Euclidean distance transform gives values of the Euclidean distance.\\n\\n    .. math::\\n\\n      y_i = \\\\sqrt{\\\\sum_{i}^{n} (x[i] - b[i])^2}\\n\\n    where :math:`b[i]` is the background point (value 0) with the smallest\\n    Euclidean distance to input points :math:`x[i]`, and :math:`n` is the\\n    number of dimensions.\\n\\n    Note that the `indices` output may differ from the one given by\\n    :func:`scipy.ndimage.distance_transform_edt` in the case of input pixels\\n    that are equidistant from multiple background points.\\n\\n    The parallel banding algorithm implemented here was originally described in\\n    [1]_. The kernels used here correspond to the revised PBA+ implementation\\n    that is described on the author's website [2]_. The source code of the\\n    author's PBA+ implementation is available at [3]_.\\n\\n    References\\n    ----------\\n    .. [1] Thanh-Tung Cao, Ke Tang, Anis Mohamed, and Tiow-Seng Tan. 2010.\\n        Parallel Banding Algorithm to compute exact distance transform with the\\n        GPU. In Proceedings of the 2010 ACM SIGGRAPH symposium on Interactive\\n        3D Graphics and Games (I3D \u201910). Association for Computing Machinery,\\n        New York, NY, USA, 83\u201390.\\n        DOI:https://doi.org/10.1145/1730804.1730818\\n    .. [2] https://www.comp.nus.edu.sg/~tants/pba.html\\n    .. [3] https://github.com/orzzzjq/Parallel-Banding-Algorithm-plus\\n\\n    Examples\\n    --------\\n    >>> import cupy as cp\\n    >>> from cucim.core.operations import morphology\\n    >>> a = cp.array(([0,1,1,1,1],\\n    ...               [0,0,1,1,1],\\n    ...               [0,1,1,1,1],\\n    ...               [0,1,1,1,0],\\n    ...               [0,1,1,0,0]))\\n    >>> morphology.distance_transform_edt(a)\\n    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    With a sampling of 2 units along x, 1 along y:\\n\\n    >>> morphology.distance_transform_edt(a, sampling=[2,1])\\n    array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],\\n           [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],\\n           [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    Asking for indices as well:\\n\\n    >>> edt, inds = morphology.distance_transform_edt(a, return_indices=True)\\n    >>> inds\\n    array([[[0, 0, 1, 1, 3],\\n            [1, 1, 1, 1, 3],\\n            [2, 2, 1, 3, 3],\\n            [3, 3, 4, 4, 3],\\n            [4, 4, 4, 4, 4]],\\n           [[0, 0, 1, 1, 4],\\n            [0, 1, 1, 1, 4],\\n            [0, 0, 1, 4, 4],\\n            [0, 0, 3, 3, 4],\\n            [0, 0, 3, 3, 4]]])\\n\\n    \"\n    scalar_sampling = None\n    if sampling is not None:\n        if isinstance(sampling, numbers.Number):\n            sampling = (sampling,)\n        if len(set(sampling)) == 1:\n            scalar_sampling = float(sampling[0])\n            sampling = None\n    if image.ndim == 3:\n        pba_func = _pba_3d\n    elif image.ndim == 2:\n        pba_func = _pba_2d\n    else:\n        raise NotImplementedError('Only 2D and 3D distance transforms are supported.')\n    vals = pba_func(image, sampling=sampling, return_distances=return_distances, return_indices=return_indices, block_params=block_params, distances=distances, indices=indices, float64_distances=float64_distances)\n    if return_distances and scalar_sampling is not None:\n        vals = list(vals)\n        vals[0] *= scalar_sampling\n        vals = tuple(vals)\n    if len(vals) == 1:\n        vals = vals[0]\n    return vals",
            "def distance_transform_edt(image, sampling=None, return_distances=True, return_indices=False, distances=None, indices=None, *, block_params=None, float64_distances=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Exact Euclidean distance transform.\\n\\n    This function calculates the distance transform of the `input`, by\\n    replacing each foreground (non-zero) element, with its shortest distance to\\n    the background (any zero-valued element).\\n\\n    In addition to the distance transform, the feature transform can be\\n    calculated. In this case the index of the closest background element to\\n    each foreground element is returned in a separate array.\\n\\n    Parameters\\n    ----------\\n    image : array_like\\n        Input data to transform. Can be any type but will be converted into\\n        binary: 1 wherever image equates to True, 0 elsewhere.\\n    sampling : float, or sequence of float, optional\\n        Spacing of elements along each dimension. If a sequence, must be of\\n        length equal to the image rank; if a single number, this is used for\\n        all axes. If not specified, a grid spacing of unity is implied.\\n    return_distances : bool, optional\\n        Whether to calculate the distance transform.\\n    return_indices : bool, optional\\n        Whether to calculate the feature transform.\\n    distances : cupy.ndarray, optional\\n        An output array to store the calculated distance transform, instead of\\n        returning it. `return_distances` must be ``True``. It must be the same\\n        shape as `image`. Should have dtype ``cp.float32`` if\\n        `float64_distances` is ``False``, otherwise it should be\\n        ``cp.float64``.\\n    indices : cupy.ndarray, optional\\n        An output array to store the calculated feature transform, instead of\\n        returning it. `return_indicies` must be ``True``. Its shape must be\\n        ``(image.ndim,) + image.shape``. Its dtype must be a signed or unsigned\\n        integer type of at least 16-bits in 2D or 32-bits in 3D.\\n\\n    Other Parameters\\n    ----------------\\n    block_params : 3-tuple of int\\n        The m1, m2, m3 algorithm parameters as described in [2]_. If None,\\n        suitable defaults will be chosen. Note: This parameter is specific to\\n        cuCIM and does not exist in SciPy.\\n    float64_distances : bool, optional\\n        If True, use double precision in the distance computation (to match\\n        SciPy behavior). Otherwise, single precision will be used for\\n        efficiency. Note: This parameter is specific to cuCIM and does not\\n        exist in SciPy.\\n\\n    Returns\\n    -------\\n    distances : cupy.ndarray, optional\\n        The calculated distance transform. Returned only when\\n        `return_distances` is ``True`` and `distances` is not supplied. It will\\n        have the same shape as `image`. Will have dtype `cp.float64` if\\n        `float64_distances` is ``True``, otherwise it will have dtype\\n        ``cp.float32``.\\n    indices : ndarray, optional\\n        The calculated feature transform. It has an image-shaped array for each\\n        dimension of the image. See example below. Returned only when\\n        `return_indices` is ``True`` and `indices` is not supplied.\\n\\n    Notes\\n    -----\\n    The Euclidean distance transform gives values of the Euclidean distance.\\n\\n    .. math::\\n\\n      y_i = \\\\sqrt{\\\\sum_{i}^{n} (x[i] - b[i])^2}\\n\\n    where :math:`b[i]` is the background point (value 0) with the smallest\\n    Euclidean distance to input points :math:`x[i]`, and :math:`n` is the\\n    number of dimensions.\\n\\n    Note that the `indices` output may differ from the one given by\\n    :func:`scipy.ndimage.distance_transform_edt` in the case of input pixels\\n    that are equidistant from multiple background points.\\n\\n    The parallel banding algorithm implemented here was originally described in\\n    [1]_. The kernels used here correspond to the revised PBA+ implementation\\n    that is described on the author's website [2]_. The source code of the\\n    author's PBA+ implementation is available at [3]_.\\n\\n    References\\n    ----------\\n    .. [1] Thanh-Tung Cao, Ke Tang, Anis Mohamed, and Tiow-Seng Tan. 2010.\\n        Parallel Banding Algorithm to compute exact distance transform with the\\n        GPU. In Proceedings of the 2010 ACM SIGGRAPH symposium on Interactive\\n        3D Graphics and Games (I3D \u201910). Association for Computing Machinery,\\n        New York, NY, USA, 83\u201390.\\n        DOI:https://doi.org/10.1145/1730804.1730818\\n    .. [2] https://www.comp.nus.edu.sg/~tants/pba.html\\n    .. [3] https://github.com/orzzzjq/Parallel-Banding-Algorithm-plus\\n\\n    Examples\\n    --------\\n    >>> import cupy as cp\\n    >>> from cucim.core.operations import morphology\\n    >>> a = cp.array(([0,1,1,1,1],\\n    ...               [0,0,1,1,1],\\n    ...               [0,1,1,1,1],\\n    ...               [0,1,1,1,0],\\n    ...               [0,1,1,0,0]))\\n    >>> morphology.distance_transform_edt(a)\\n    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],\\n           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    With a sampling of 2 units along x, 1 along y:\\n\\n    >>> morphology.distance_transform_edt(a, sampling=[2,1])\\n    array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],\\n           [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],\\n           [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],\\n           [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],\\n           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])\\n\\n    Asking for indices as well:\\n\\n    >>> edt, inds = morphology.distance_transform_edt(a, return_indices=True)\\n    >>> inds\\n    array([[[0, 0, 1, 1, 3],\\n            [1, 1, 1, 1, 3],\\n            [2, 2, 1, 3, 3],\\n            [3, 3, 4, 4, 3],\\n            [4, 4, 4, 4, 4]],\\n           [[0, 0, 1, 1, 4],\\n            [0, 1, 1, 1, 4],\\n            [0, 0, 1, 4, 4],\\n            [0, 0, 3, 3, 4],\\n            [0, 0, 3, 3, 4]]])\\n\\n    \"\n    scalar_sampling = None\n    if sampling is not None:\n        if isinstance(sampling, numbers.Number):\n            sampling = (sampling,)\n        if len(set(sampling)) == 1:\n            scalar_sampling = float(sampling[0])\n            sampling = None\n    if image.ndim == 3:\n        pba_func = _pba_3d\n    elif image.ndim == 2:\n        pba_func = _pba_2d\n    else:\n        raise NotImplementedError('Only 2D and 3D distance transforms are supported.')\n    vals = pba_func(image, sampling=sampling, return_distances=return_distances, return_indices=return_indices, block_params=block_params, distances=distances, indices=indices, float64_distances=float64_distances)\n    if return_distances and scalar_sampling is not None:\n        vals = list(vals)\n        vals[0] *= scalar_sampling\n        vals = tuple(vals)\n    if len(vals) == 1:\n        vals = vals[0]\n    return vals"
        ]
    }
]