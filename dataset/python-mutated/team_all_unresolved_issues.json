[
    {
        "func_name": "calculate_unresolved_counts",
        "original": "def calculate_unresolved_counts(team, project_list, start, end, environment_id):\n    group_environment_filter = Q(groupenvironment__environment_id=environment_id) if environment_id else Q()\n    project_current_unresolved = {r['project']: r['total'] for r in Group.objects.filter_to_team(team).filter(group_environment_filter, status=GroupStatus.UNRESOLVED).values('project').annotate(total=Count('id'))}\n    group_history_environment_filter = Q(group__groupenvironment__environment_id=environment_id) if environment_id else Q()\n    prev_status_sub_qs = Coalesce(Subquery(GroupHistory.objects.filter(group_id=OuterRef('group_id'), date_added__lt=OuterRef('date_added'), status__in=OPEN_STATUSES + CLOSED_STATUSES).order_by('-id').values('status')[:1]), -1)\n    dedupe_status_filter = Q(~Q(prev_status__in=OPEN_STATUSES) & Q(status__in=OPEN_STATUSES) | ~Q(prev_status__in=CLOSED_STATUSES) & Q(status__in=CLOSED_STATUSES))\n    new_issues = Group.objects.filter_to_team(team).filter(group_environment_filter, first_seen__gte=start, first_seen__lt=end).annotate(bucket=TruncDay('first_seen')).order_by('bucket').values('project', 'bucket').annotate(open=Count('id'))\n    bucketed_issues = GroupHistory.objects.filter_to_team(team).filter(group_history_environment_filter, date_added__gte=start, date_added__lte=end).annotate(bucket=TruncDay('date_added'), prev_status=prev_status_sub_qs).filter(dedupe_status_filter).order_by('bucket').values('project', 'bucket').annotate(open=Count('id', filter=Q(status__in=OPEN_STATUSES)), closed=Count('id', filter=Q(status__in=CLOSED_STATUSES)))\n    (current_day, date_series_dict) = (start, {})\n    while current_day < end:\n        date_series_dict[current_day.isoformat()] = {'open': 0, 'closed': 0}\n        current_day += timedelta(days=1)\n    agg_project_precounts = {project.id: copy.deepcopy(date_series_dict) for project in project_list}\n    for r in chain(bucketed_issues, new_issues):\n        bucket = agg_project_precounts[r['project']][r['bucket'].isoformat()]\n        bucket['open'] += r.get('open', 0)\n        bucket['closed'] += r.get('closed', 0)\n    agg_project_counts = {}\n    for (project, precounts) in agg_project_precounts.items():\n        open = project_current_unresolved.get(project, 0)\n        sorted_bucket_keys = sorted(precounts.keys(), reverse=True)\n        project_counts = {}\n        for bucket_key in sorted_bucket_keys:\n            bucket = precounts[bucket_key]\n            project_counts[bucket_key] = {'unresolved': open}\n            open = max(open - bucket['open'] + bucket['closed'], 0)\n        agg_project_counts[project] = project_counts\n    return agg_project_counts",
        "mutated": [
            "def calculate_unresolved_counts(team, project_list, start, end, environment_id):\n    if False:\n        i = 10\n    group_environment_filter = Q(groupenvironment__environment_id=environment_id) if environment_id else Q()\n    project_current_unresolved = {r['project']: r['total'] for r in Group.objects.filter_to_team(team).filter(group_environment_filter, status=GroupStatus.UNRESOLVED).values('project').annotate(total=Count('id'))}\n    group_history_environment_filter = Q(group__groupenvironment__environment_id=environment_id) if environment_id else Q()\n    prev_status_sub_qs = Coalesce(Subquery(GroupHistory.objects.filter(group_id=OuterRef('group_id'), date_added__lt=OuterRef('date_added'), status__in=OPEN_STATUSES + CLOSED_STATUSES).order_by('-id').values('status')[:1]), -1)\n    dedupe_status_filter = Q(~Q(prev_status__in=OPEN_STATUSES) & Q(status__in=OPEN_STATUSES) | ~Q(prev_status__in=CLOSED_STATUSES) & Q(status__in=CLOSED_STATUSES))\n    new_issues = Group.objects.filter_to_team(team).filter(group_environment_filter, first_seen__gte=start, first_seen__lt=end).annotate(bucket=TruncDay('first_seen')).order_by('bucket').values('project', 'bucket').annotate(open=Count('id'))\n    bucketed_issues = GroupHistory.objects.filter_to_team(team).filter(group_history_environment_filter, date_added__gte=start, date_added__lte=end).annotate(bucket=TruncDay('date_added'), prev_status=prev_status_sub_qs).filter(dedupe_status_filter).order_by('bucket').values('project', 'bucket').annotate(open=Count('id', filter=Q(status__in=OPEN_STATUSES)), closed=Count('id', filter=Q(status__in=CLOSED_STATUSES)))\n    (current_day, date_series_dict) = (start, {})\n    while current_day < end:\n        date_series_dict[current_day.isoformat()] = {'open': 0, 'closed': 0}\n        current_day += timedelta(days=1)\n    agg_project_precounts = {project.id: copy.deepcopy(date_series_dict) for project in project_list}\n    for r in chain(bucketed_issues, new_issues):\n        bucket = agg_project_precounts[r['project']][r['bucket'].isoformat()]\n        bucket['open'] += r.get('open', 0)\n        bucket['closed'] += r.get('closed', 0)\n    agg_project_counts = {}\n    for (project, precounts) in agg_project_precounts.items():\n        open = project_current_unresolved.get(project, 0)\n        sorted_bucket_keys = sorted(precounts.keys(), reverse=True)\n        project_counts = {}\n        for bucket_key in sorted_bucket_keys:\n            bucket = precounts[bucket_key]\n            project_counts[bucket_key] = {'unresolved': open}\n            open = max(open - bucket['open'] + bucket['closed'], 0)\n        agg_project_counts[project] = project_counts\n    return agg_project_counts",
            "def calculate_unresolved_counts(team, project_list, start, end, environment_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    group_environment_filter = Q(groupenvironment__environment_id=environment_id) if environment_id else Q()\n    project_current_unresolved = {r['project']: r['total'] for r in Group.objects.filter_to_team(team).filter(group_environment_filter, status=GroupStatus.UNRESOLVED).values('project').annotate(total=Count('id'))}\n    group_history_environment_filter = Q(group__groupenvironment__environment_id=environment_id) if environment_id else Q()\n    prev_status_sub_qs = Coalesce(Subquery(GroupHistory.objects.filter(group_id=OuterRef('group_id'), date_added__lt=OuterRef('date_added'), status__in=OPEN_STATUSES + CLOSED_STATUSES).order_by('-id').values('status')[:1]), -1)\n    dedupe_status_filter = Q(~Q(prev_status__in=OPEN_STATUSES) & Q(status__in=OPEN_STATUSES) | ~Q(prev_status__in=CLOSED_STATUSES) & Q(status__in=CLOSED_STATUSES))\n    new_issues = Group.objects.filter_to_team(team).filter(group_environment_filter, first_seen__gte=start, first_seen__lt=end).annotate(bucket=TruncDay('first_seen')).order_by('bucket').values('project', 'bucket').annotate(open=Count('id'))\n    bucketed_issues = GroupHistory.objects.filter_to_team(team).filter(group_history_environment_filter, date_added__gte=start, date_added__lte=end).annotate(bucket=TruncDay('date_added'), prev_status=prev_status_sub_qs).filter(dedupe_status_filter).order_by('bucket').values('project', 'bucket').annotate(open=Count('id', filter=Q(status__in=OPEN_STATUSES)), closed=Count('id', filter=Q(status__in=CLOSED_STATUSES)))\n    (current_day, date_series_dict) = (start, {})\n    while current_day < end:\n        date_series_dict[current_day.isoformat()] = {'open': 0, 'closed': 0}\n        current_day += timedelta(days=1)\n    agg_project_precounts = {project.id: copy.deepcopy(date_series_dict) for project in project_list}\n    for r in chain(bucketed_issues, new_issues):\n        bucket = agg_project_precounts[r['project']][r['bucket'].isoformat()]\n        bucket['open'] += r.get('open', 0)\n        bucket['closed'] += r.get('closed', 0)\n    agg_project_counts = {}\n    for (project, precounts) in agg_project_precounts.items():\n        open = project_current_unresolved.get(project, 0)\n        sorted_bucket_keys = sorted(precounts.keys(), reverse=True)\n        project_counts = {}\n        for bucket_key in sorted_bucket_keys:\n            bucket = precounts[bucket_key]\n            project_counts[bucket_key] = {'unresolved': open}\n            open = max(open - bucket['open'] + bucket['closed'], 0)\n        agg_project_counts[project] = project_counts\n    return agg_project_counts",
            "def calculate_unresolved_counts(team, project_list, start, end, environment_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    group_environment_filter = Q(groupenvironment__environment_id=environment_id) if environment_id else Q()\n    project_current_unresolved = {r['project']: r['total'] for r in Group.objects.filter_to_team(team).filter(group_environment_filter, status=GroupStatus.UNRESOLVED).values('project').annotate(total=Count('id'))}\n    group_history_environment_filter = Q(group__groupenvironment__environment_id=environment_id) if environment_id else Q()\n    prev_status_sub_qs = Coalesce(Subquery(GroupHistory.objects.filter(group_id=OuterRef('group_id'), date_added__lt=OuterRef('date_added'), status__in=OPEN_STATUSES + CLOSED_STATUSES).order_by('-id').values('status')[:1]), -1)\n    dedupe_status_filter = Q(~Q(prev_status__in=OPEN_STATUSES) & Q(status__in=OPEN_STATUSES) | ~Q(prev_status__in=CLOSED_STATUSES) & Q(status__in=CLOSED_STATUSES))\n    new_issues = Group.objects.filter_to_team(team).filter(group_environment_filter, first_seen__gte=start, first_seen__lt=end).annotate(bucket=TruncDay('first_seen')).order_by('bucket').values('project', 'bucket').annotate(open=Count('id'))\n    bucketed_issues = GroupHistory.objects.filter_to_team(team).filter(group_history_environment_filter, date_added__gte=start, date_added__lte=end).annotate(bucket=TruncDay('date_added'), prev_status=prev_status_sub_qs).filter(dedupe_status_filter).order_by('bucket').values('project', 'bucket').annotate(open=Count('id', filter=Q(status__in=OPEN_STATUSES)), closed=Count('id', filter=Q(status__in=CLOSED_STATUSES)))\n    (current_day, date_series_dict) = (start, {})\n    while current_day < end:\n        date_series_dict[current_day.isoformat()] = {'open': 0, 'closed': 0}\n        current_day += timedelta(days=1)\n    agg_project_precounts = {project.id: copy.deepcopy(date_series_dict) for project in project_list}\n    for r in chain(bucketed_issues, new_issues):\n        bucket = agg_project_precounts[r['project']][r['bucket'].isoformat()]\n        bucket['open'] += r.get('open', 0)\n        bucket['closed'] += r.get('closed', 0)\n    agg_project_counts = {}\n    for (project, precounts) in agg_project_precounts.items():\n        open = project_current_unresolved.get(project, 0)\n        sorted_bucket_keys = sorted(precounts.keys(), reverse=True)\n        project_counts = {}\n        for bucket_key in sorted_bucket_keys:\n            bucket = precounts[bucket_key]\n            project_counts[bucket_key] = {'unresolved': open}\n            open = max(open - bucket['open'] + bucket['closed'], 0)\n        agg_project_counts[project] = project_counts\n    return agg_project_counts",
            "def calculate_unresolved_counts(team, project_list, start, end, environment_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    group_environment_filter = Q(groupenvironment__environment_id=environment_id) if environment_id else Q()\n    project_current_unresolved = {r['project']: r['total'] for r in Group.objects.filter_to_team(team).filter(group_environment_filter, status=GroupStatus.UNRESOLVED).values('project').annotate(total=Count('id'))}\n    group_history_environment_filter = Q(group__groupenvironment__environment_id=environment_id) if environment_id else Q()\n    prev_status_sub_qs = Coalesce(Subquery(GroupHistory.objects.filter(group_id=OuterRef('group_id'), date_added__lt=OuterRef('date_added'), status__in=OPEN_STATUSES + CLOSED_STATUSES).order_by('-id').values('status')[:1]), -1)\n    dedupe_status_filter = Q(~Q(prev_status__in=OPEN_STATUSES) & Q(status__in=OPEN_STATUSES) | ~Q(prev_status__in=CLOSED_STATUSES) & Q(status__in=CLOSED_STATUSES))\n    new_issues = Group.objects.filter_to_team(team).filter(group_environment_filter, first_seen__gte=start, first_seen__lt=end).annotate(bucket=TruncDay('first_seen')).order_by('bucket').values('project', 'bucket').annotate(open=Count('id'))\n    bucketed_issues = GroupHistory.objects.filter_to_team(team).filter(group_history_environment_filter, date_added__gte=start, date_added__lte=end).annotate(bucket=TruncDay('date_added'), prev_status=prev_status_sub_qs).filter(dedupe_status_filter).order_by('bucket').values('project', 'bucket').annotate(open=Count('id', filter=Q(status__in=OPEN_STATUSES)), closed=Count('id', filter=Q(status__in=CLOSED_STATUSES)))\n    (current_day, date_series_dict) = (start, {})\n    while current_day < end:\n        date_series_dict[current_day.isoformat()] = {'open': 0, 'closed': 0}\n        current_day += timedelta(days=1)\n    agg_project_precounts = {project.id: copy.deepcopy(date_series_dict) for project in project_list}\n    for r in chain(bucketed_issues, new_issues):\n        bucket = agg_project_precounts[r['project']][r['bucket'].isoformat()]\n        bucket['open'] += r.get('open', 0)\n        bucket['closed'] += r.get('closed', 0)\n    agg_project_counts = {}\n    for (project, precounts) in agg_project_precounts.items():\n        open = project_current_unresolved.get(project, 0)\n        sorted_bucket_keys = sorted(precounts.keys(), reverse=True)\n        project_counts = {}\n        for bucket_key in sorted_bucket_keys:\n            bucket = precounts[bucket_key]\n            project_counts[bucket_key] = {'unresolved': open}\n            open = max(open - bucket['open'] + bucket['closed'], 0)\n        agg_project_counts[project] = project_counts\n    return agg_project_counts",
            "def calculate_unresolved_counts(team, project_list, start, end, environment_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    group_environment_filter = Q(groupenvironment__environment_id=environment_id) if environment_id else Q()\n    project_current_unresolved = {r['project']: r['total'] for r in Group.objects.filter_to_team(team).filter(group_environment_filter, status=GroupStatus.UNRESOLVED).values('project').annotate(total=Count('id'))}\n    group_history_environment_filter = Q(group__groupenvironment__environment_id=environment_id) if environment_id else Q()\n    prev_status_sub_qs = Coalesce(Subquery(GroupHistory.objects.filter(group_id=OuterRef('group_id'), date_added__lt=OuterRef('date_added'), status__in=OPEN_STATUSES + CLOSED_STATUSES).order_by('-id').values('status')[:1]), -1)\n    dedupe_status_filter = Q(~Q(prev_status__in=OPEN_STATUSES) & Q(status__in=OPEN_STATUSES) | ~Q(prev_status__in=CLOSED_STATUSES) & Q(status__in=CLOSED_STATUSES))\n    new_issues = Group.objects.filter_to_team(team).filter(group_environment_filter, first_seen__gte=start, first_seen__lt=end).annotate(bucket=TruncDay('first_seen')).order_by('bucket').values('project', 'bucket').annotate(open=Count('id'))\n    bucketed_issues = GroupHistory.objects.filter_to_team(team).filter(group_history_environment_filter, date_added__gte=start, date_added__lte=end).annotate(bucket=TruncDay('date_added'), prev_status=prev_status_sub_qs).filter(dedupe_status_filter).order_by('bucket').values('project', 'bucket').annotate(open=Count('id', filter=Q(status__in=OPEN_STATUSES)), closed=Count('id', filter=Q(status__in=CLOSED_STATUSES)))\n    (current_day, date_series_dict) = (start, {})\n    while current_day < end:\n        date_series_dict[current_day.isoformat()] = {'open': 0, 'closed': 0}\n        current_day += timedelta(days=1)\n    agg_project_precounts = {project.id: copy.deepcopy(date_series_dict) for project in project_list}\n    for r in chain(bucketed_issues, new_issues):\n        bucket = agg_project_precounts[r['project']][r['bucket'].isoformat()]\n        bucket['open'] += r.get('open', 0)\n        bucket['closed'] += r.get('closed', 0)\n    agg_project_counts = {}\n    for (project, precounts) in agg_project_precounts.items():\n        open = project_current_unresolved.get(project, 0)\n        sorted_bucket_keys = sorted(precounts.keys(), reverse=True)\n        project_counts = {}\n        for bucket_key in sorted_bucket_keys:\n            bucket = precounts[bucket_key]\n            project_counts[bucket_key] = {'unresolved': open}\n            open = max(open - bucket['open'] + bucket['closed'], 0)\n        agg_project_counts[project] = project_counts\n    return agg_project_counts"
        ]
    },
    {
        "func_name": "get",
        "original": "def get(self, request: Request, team: Team) -> Response:\n    \"\"\"\n        Returns cumulative counts of unresolved groups per day within the stats period time range.\n        Response:\n        {\n            <project_id>: {\n                <isoformat_date>: {\"unresolved\": <unresolved_count>},\n                ...\n            }\n            ...\n        }\n        \"\"\"\n    if not features.has('organizations:team-insights', team.organization, actor=request.user):\n        return Response({'detail': 'You do not have the insights feature enabled'}, status=400)\n    project_list = Project.objects.get_for_team_ids(team_ids=[team.id])\n    if len(project_list) == 0:\n        return Response({})\n    (start, end) = get_date_range_from_params(request.GET)\n    end = end.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    start = start.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    environments = [e.id for e in get_environments(request, team.organization)]\n    environment_id = environments[0] if environments else None\n    return Response(calculate_unresolved_counts(team, project_list, start, end, environment_id))",
        "mutated": [
            "def get(self, request: Request, team: Team) -> Response:\n    if False:\n        i = 10\n    '\\n        Returns cumulative counts of unresolved groups per day within the stats period time range.\\n        Response:\\n        {\\n            <project_id>: {\\n                <isoformat_date>: {\"unresolved\": <unresolved_count>},\\n                ...\\n            }\\n            ...\\n        }\\n        '\n    if not features.has('organizations:team-insights', team.organization, actor=request.user):\n        return Response({'detail': 'You do not have the insights feature enabled'}, status=400)\n    project_list = Project.objects.get_for_team_ids(team_ids=[team.id])\n    if len(project_list) == 0:\n        return Response({})\n    (start, end) = get_date_range_from_params(request.GET)\n    end = end.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    start = start.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    environments = [e.id for e in get_environments(request, team.organization)]\n    environment_id = environments[0] if environments else None\n    return Response(calculate_unresolved_counts(team, project_list, start, end, environment_id))",
            "def get(self, request: Request, team: Team) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns cumulative counts of unresolved groups per day within the stats period time range.\\n        Response:\\n        {\\n            <project_id>: {\\n                <isoformat_date>: {\"unresolved\": <unresolved_count>},\\n                ...\\n            }\\n            ...\\n        }\\n        '\n    if not features.has('organizations:team-insights', team.organization, actor=request.user):\n        return Response({'detail': 'You do not have the insights feature enabled'}, status=400)\n    project_list = Project.objects.get_for_team_ids(team_ids=[team.id])\n    if len(project_list) == 0:\n        return Response({})\n    (start, end) = get_date_range_from_params(request.GET)\n    end = end.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    start = start.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    environments = [e.id for e in get_environments(request, team.organization)]\n    environment_id = environments[0] if environments else None\n    return Response(calculate_unresolved_counts(team, project_list, start, end, environment_id))",
            "def get(self, request: Request, team: Team) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns cumulative counts of unresolved groups per day within the stats period time range.\\n        Response:\\n        {\\n            <project_id>: {\\n                <isoformat_date>: {\"unresolved\": <unresolved_count>},\\n                ...\\n            }\\n            ...\\n        }\\n        '\n    if not features.has('organizations:team-insights', team.organization, actor=request.user):\n        return Response({'detail': 'You do not have the insights feature enabled'}, status=400)\n    project_list = Project.objects.get_for_team_ids(team_ids=[team.id])\n    if len(project_list) == 0:\n        return Response({})\n    (start, end) = get_date_range_from_params(request.GET)\n    end = end.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    start = start.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    environments = [e.id for e in get_environments(request, team.organization)]\n    environment_id = environments[0] if environments else None\n    return Response(calculate_unresolved_counts(team, project_list, start, end, environment_id))",
            "def get(self, request: Request, team: Team) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns cumulative counts of unresolved groups per day within the stats period time range.\\n        Response:\\n        {\\n            <project_id>: {\\n                <isoformat_date>: {\"unresolved\": <unresolved_count>},\\n                ...\\n            }\\n            ...\\n        }\\n        '\n    if not features.has('organizations:team-insights', team.organization, actor=request.user):\n        return Response({'detail': 'You do not have the insights feature enabled'}, status=400)\n    project_list = Project.objects.get_for_team_ids(team_ids=[team.id])\n    if len(project_list) == 0:\n        return Response({})\n    (start, end) = get_date_range_from_params(request.GET)\n    end = end.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    start = start.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    environments = [e.id for e in get_environments(request, team.organization)]\n    environment_id = environments[0] if environments else None\n    return Response(calculate_unresolved_counts(team, project_list, start, end, environment_id))",
            "def get(self, request: Request, team: Team) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns cumulative counts of unresolved groups per day within the stats period time range.\\n        Response:\\n        {\\n            <project_id>: {\\n                <isoformat_date>: {\"unresolved\": <unresolved_count>},\\n                ...\\n            }\\n            ...\\n        }\\n        '\n    if not features.has('organizations:team-insights', team.organization, actor=request.user):\n        return Response({'detail': 'You do not have the insights feature enabled'}, status=400)\n    project_list = Project.objects.get_for_team_ids(team_ids=[team.id])\n    if len(project_list) == 0:\n        return Response({})\n    (start, end) = get_date_range_from_params(request.GET)\n    end = end.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    start = start.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n    environments = [e.id for e in get_environments(request, team.organization)]\n    environment_id = environments[0] if environments else None\n    return Response(calculate_unresolved_counts(team, project_list, start, end, environment_id))"
        ]
    }
]