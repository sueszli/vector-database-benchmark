[
    {
        "func_name": "_calc_factlist",
        "original": "def _calc_factlist(nn):\n    \"\"\"\n    Function calculates a list of precomputed factorials in order to\n    massively accelerate future calculations of the various\n    coefficients.\n\n    Parameters\n    ==========\n\n    nn : integer\n        Highest factorial to be computed.\n\n    Returns\n    =======\n\n    list of integers :\n        The list of precomputed factorials.\n\n    Examples\n    ========\n\n    Calculate list of factorials::\n\n        sage: from sage.functions.wigner import _calc_factlist\n        sage: _calc_factlist(10)\n        [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n    \"\"\"\n    if nn >= len(_Factlist):\n        for ii in range(len(_Factlist), int(nn + 1)):\n            _Factlist.append(_Factlist[ii - 1] * ii)\n    return _Factlist[:int(nn) + 1]",
        "mutated": [
            "def _calc_factlist(nn):\n    if False:\n        i = 10\n    '\\n    Function calculates a list of precomputed factorials in order to\\n    massively accelerate future calculations of the various\\n    coefficients.\\n\\n    Parameters\\n    ==========\\n\\n    nn : integer\\n        Highest factorial to be computed.\\n\\n    Returns\\n    =======\\n\\n    list of integers :\\n        The list of precomputed factorials.\\n\\n    Examples\\n    ========\\n\\n    Calculate list of factorials::\\n\\n        sage: from sage.functions.wigner import _calc_factlist\\n        sage: _calc_factlist(10)\\n        [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\\n    '\n    if nn >= len(_Factlist):\n        for ii in range(len(_Factlist), int(nn + 1)):\n            _Factlist.append(_Factlist[ii - 1] * ii)\n    return _Factlist[:int(nn) + 1]",
            "def _calc_factlist(nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Function calculates a list of precomputed factorials in order to\\n    massively accelerate future calculations of the various\\n    coefficients.\\n\\n    Parameters\\n    ==========\\n\\n    nn : integer\\n        Highest factorial to be computed.\\n\\n    Returns\\n    =======\\n\\n    list of integers :\\n        The list of precomputed factorials.\\n\\n    Examples\\n    ========\\n\\n    Calculate list of factorials::\\n\\n        sage: from sage.functions.wigner import _calc_factlist\\n        sage: _calc_factlist(10)\\n        [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\\n    '\n    if nn >= len(_Factlist):\n        for ii in range(len(_Factlist), int(nn + 1)):\n            _Factlist.append(_Factlist[ii - 1] * ii)\n    return _Factlist[:int(nn) + 1]",
            "def _calc_factlist(nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Function calculates a list of precomputed factorials in order to\\n    massively accelerate future calculations of the various\\n    coefficients.\\n\\n    Parameters\\n    ==========\\n\\n    nn : integer\\n        Highest factorial to be computed.\\n\\n    Returns\\n    =======\\n\\n    list of integers :\\n        The list of precomputed factorials.\\n\\n    Examples\\n    ========\\n\\n    Calculate list of factorials::\\n\\n        sage: from sage.functions.wigner import _calc_factlist\\n        sage: _calc_factlist(10)\\n        [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\\n    '\n    if nn >= len(_Factlist):\n        for ii in range(len(_Factlist), int(nn + 1)):\n            _Factlist.append(_Factlist[ii - 1] * ii)\n    return _Factlist[:int(nn) + 1]",
            "def _calc_factlist(nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Function calculates a list of precomputed factorials in order to\\n    massively accelerate future calculations of the various\\n    coefficients.\\n\\n    Parameters\\n    ==========\\n\\n    nn : integer\\n        Highest factorial to be computed.\\n\\n    Returns\\n    =======\\n\\n    list of integers :\\n        The list of precomputed factorials.\\n\\n    Examples\\n    ========\\n\\n    Calculate list of factorials::\\n\\n        sage: from sage.functions.wigner import _calc_factlist\\n        sage: _calc_factlist(10)\\n        [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\\n    '\n    if nn >= len(_Factlist):\n        for ii in range(len(_Factlist), int(nn + 1)):\n            _Factlist.append(_Factlist[ii - 1] * ii)\n    return _Factlist[:int(nn) + 1]",
            "def _calc_factlist(nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Function calculates a list of precomputed factorials in order to\\n    massively accelerate future calculations of the various\\n    coefficients.\\n\\n    Parameters\\n    ==========\\n\\n    nn : integer\\n        Highest factorial to be computed.\\n\\n    Returns\\n    =======\\n\\n    list of integers :\\n        The list of precomputed factorials.\\n\\n    Examples\\n    ========\\n\\n    Calculate list of factorials::\\n\\n        sage: from sage.functions.wigner import _calc_factlist\\n        sage: _calc_factlist(10)\\n        [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\\n    '\n    if nn >= len(_Factlist):\n        for ii in range(len(_Factlist), int(nn + 1)):\n            _Factlist.append(_Factlist[ii - 1] * ii)\n    return _Factlist[:int(nn) + 1]"
        ]
    },
    {
        "func_name": "wigner_3j",
        "original": "def wigner_3j(j_1, j_2, j_3, m_1, m_2, m_3):\n    \"\"\"\n    Calculate the Wigner 3j symbol `\\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)`.\n\n    Parameters\n    ==========\n\n    j_1, j_2, j_3, m_1, m_2, m_3 :\n        Integer or half integer.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import wigner_3j\n    >>> wigner_3j(2, 6, 4, 0, 0, 0)\n    sqrt(715)/143\n    >>> wigner_3j(2, 6, 4, 0, 0, 1)\n    0\n\n    It is an error to have arguments that are not integer or half\n    integer values::\n\n        sage: wigner_3j(2.1, 6, 4, 0, 0, 0)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer\n        sage: wigner_3j(2, 6, 4, 1, 0, -1.1)\n        Traceback (most recent call last):\n        ...\n        ValueError: m values must be integer or half integer\n\n    Notes\n    =====\n\n    The Wigner 3j symbol obeys the following symmetry rules:\n\n    - invariant under any permutation of the columns (with the\n      exception of a sign change where `J:=j_1+j_2+j_3`):\n\n      .. math::\n\n         \\\\begin{aligned}\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\n          &=\\\\operatorname{Wigner3j}(j_3,j_1,j_2,m_3,m_1,m_2) \\\\\\\\\n          &=\\\\operatorname{Wigner3j}(j_2,j_3,j_1,m_2,m_3,m_1) \\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_3,j_2,j_1,m_3,m_2,m_1) \\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_1,j_3,j_2,m_1,m_3,m_2) \\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_2,j_1,j_3,m_2,m_1,m_3)\n         \\\\end{aligned}\n\n    - invariant under space inflection, i.e.\n\n      .. math::\n\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\n         =(-1)^J \\\\operatorname{Wigner3j}(j_1,j_2,j_3,-m_1,-m_2,-m_3)\n\n    - symmetric with respect to the 72 additional symmetries based on\n      the work by [Regge58]_\n\n    - zero for `j_1`, `j_2`, `j_3` not fulfilling triangle relation\n\n    - zero for `m_1 + m_2 + m_3 \\\\neq 0`\n\n    - zero for violating any one of the conditions\n      `j_1 \\\\ge |m_1|`,  `j_2 \\\\ge |m_2|`,  `j_3 \\\\ge |m_3|`\n\n    Algorithm\n    =========\n\n    This function uses the algorithm of [Edmonds74]_ to calculate the\n    value of the 3j symbol exactly. Note that the formula contains\n    alternating sums over large factorials and is therefore unsuitable\n    for finite precision arithmetic and only useful for a computer\n    algebra system [Rasch03]_.\n\n    Authors\n    =======\n\n    - Jens Rasch (2009-03-24): initial version\n    \"\"\"\n    if int(j_1 * 2) != j_1 * 2 or int(j_2 * 2) != j_2 * 2 or int(j_3 * 2) != j_3 * 2:\n        raise ValueError('j values must be integer or half integer')\n    if int(m_1 * 2) != m_1 * 2 or int(m_2 * 2) != m_2 * 2 or int(m_3 * 2) != m_3 * 2:\n        raise ValueError('m values must be integer or half integer')\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    prefid = Integer((-1) ** int(j_1 - j_2 - m_3))\n    m_3 = -m_3\n    a1 = j_1 + j_2 - j_3\n    if a1 < 0:\n        return S.Zero\n    a2 = j_1 - j_2 + j_3\n    if a2 < 0:\n        return S.Zero\n    a3 = -j_1 + j_2 + j_3\n    if a3 < 0:\n        return S.Zero\n    if abs(m_1) > j_1 or abs(m_2) > j_2 or abs(m_3) > j_3:\n        return S.Zero\n    maxfact = max(j_1 + j_2 + j_3 + 1, j_1 + abs(m_1), j_2 + abs(m_2), j_3 + abs(m_3))\n    _calc_factlist(int(maxfact))\n    argsqrt = Integer(_Factlist[int(j_1 + j_2 - j_3)] * _Factlist[int(j_1 - j_2 + j_3)] * _Factlist[int(-j_1 + j_2 + j_3)] * _Factlist[int(j_1 - m_1)] * _Factlist[int(j_1 + m_1)] * _Factlist[int(j_2 - m_2)] * _Factlist[int(j_2 + m_2)] * _Factlist[int(j_3 - m_3)] * _Factlist[int(j_3 + m_3)]) / _Factlist[int(j_1 + j_2 + j_3 + 1)]\n    ressqrt = sqrt(argsqrt)\n    if ressqrt.is_complex or ressqrt.is_infinite:\n        ressqrt = ressqrt.as_real_imag()[0]\n    imin = max(-j_3 + j_1 + m_2, -j_3 + j_2 - m_1, 0)\n    imax = min(j_2 + m_2, j_1 - m_1, j_1 + j_2 - j_3)\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[int(ii + j_3 - j_1 - m_2)] * _Factlist[int(j_2 + m_2 - ii)] * _Factlist[int(j_1 - ii - m_1)] * _Factlist[int(ii + j_3 - j_2 + m_1)] * _Factlist[int(j_1 + j_2 - j_3 - ii)]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * sumres * prefid\n    return res",
        "mutated": [
            "def wigner_3j(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n    '\\n    Calculate the Wigner 3j symbol `\\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_3j\\n    >>> wigner_3j(2, 6, 4, 0, 0, 0)\\n    sqrt(715)/143\\n    >>> wigner_3j(2, 6, 4, 0, 0, 1)\\n    0\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values::\\n\\n        sage: wigner_3j(2.1, 6, 4, 0, 0, 0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer\\n        sage: wigner_3j(2, 6, 4, 1, 0, -1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer or half integer\\n\\n    Notes\\n    =====\\n\\n    The Wigner 3j symbol obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns (with the\\n      exception of a sign change where `J:=j_1+j_2+j_3`):\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n          &=\\\\operatorname{Wigner3j}(j_3,j_1,j_2,m_3,m_1,m_2) \\\\\\\\\\n          &=\\\\operatorname{Wigner3j}(j_2,j_3,j_1,m_2,m_3,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_3,j_2,j_1,m_3,m_2,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_1,j_3,j_2,m_1,m_3,m_2) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_2,j_1,j_3,m_2,m_1,m_3)\\n         \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n         =(-1)^J \\\\operatorname{Wigner3j}(j_1,j_2,j_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 additional symmetries based on\\n      the work by [Regge58]_\\n\\n    - zero for `j_1`, `j_2`, `j_3` not fulfilling triangle relation\\n\\n    - zero for `m_1 + m_2 + m_3 \\\\neq 0`\\n\\n    - zero for violating any one of the conditions\\n      `j_1 \\\\ge |m_1|`,  `j_2 \\\\ge |m_2|`,  `j_3 \\\\ge |m_3|`\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    if int(j_1 * 2) != j_1 * 2 or int(j_2 * 2) != j_2 * 2 or int(j_3 * 2) != j_3 * 2:\n        raise ValueError('j values must be integer or half integer')\n    if int(m_1 * 2) != m_1 * 2 or int(m_2 * 2) != m_2 * 2 or int(m_3 * 2) != m_3 * 2:\n        raise ValueError('m values must be integer or half integer')\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    prefid = Integer((-1) ** int(j_1 - j_2 - m_3))\n    m_3 = -m_3\n    a1 = j_1 + j_2 - j_3\n    if a1 < 0:\n        return S.Zero\n    a2 = j_1 - j_2 + j_3\n    if a2 < 0:\n        return S.Zero\n    a3 = -j_1 + j_2 + j_3\n    if a3 < 0:\n        return S.Zero\n    if abs(m_1) > j_1 or abs(m_2) > j_2 or abs(m_3) > j_3:\n        return S.Zero\n    maxfact = max(j_1 + j_2 + j_3 + 1, j_1 + abs(m_1), j_2 + abs(m_2), j_3 + abs(m_3))\n    _calc_factlist(int(maxfact))\n    argsqrt = Integer(_Factlist[int(j_1 + j_2 - j_3)] * _Factlist[int(j_1 - j_2 + j_3)] * _Factlist[int(-j_1 + j_2 + j_3)] * _Factlist[int(j_1 - m_1)] * _Factlist[int(j_1 + m_1)] * _Factlist[int(j_2 - m_2)] * _Factlist[int(j_2 + m_2)] * _Factlist[int(j_3 - m_3)] * _Factlist[int(j_3 + m_3)]) / _Factlist[int(j_1 + j_2 + j_3 + 1)]\n    ressqrt = sqrt(argsqrt)\n    if ressqrt.is_complex or ressqrt.is_infinite:\n        ressqrt = ressqrt.as_real_imag()[0]\n    imin = max(-j_3 + j_1 + m_2, -j_3 + j_2 - m_1, 0)\n    imax = min(j_2 + m_2, j_1 - m_1, j_1 + j_2 - j_3)\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[int(ii + j_3 - j_1 - m_2)] * _Factlist[int(j_2 + m_2 - ii)] * _Factlist[int(j_1 - ii - m_1)] * _Factlist[int(ii + j_3 - j_2 + m_1)] * _Factlist[int(j_1 + j_2 - j_3 - ii)]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * sumres * prefid\n    return res",
            "def wigner_3j(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the Wigner 3j symbol `\\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_3j\\n    >>> wigner_3j(2, 6, 4, 0, 0, 0)\\n    sqrt(715)/143\\n    >>> wigner_3j(2, 6, 4, 0, 0, 1)\\n    0\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values::\\n\\n        sage: wigner_3j(2.1, 6, 4, 0, 0, 0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer\\n        sage: wigner_3j(2, 6, 4, 1, 0, -1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer or half integer\\n\\n    Notes\\n    =====\\n\\n    The Wigner 3j symbol obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns (with the\\n      exception of a sign change where `J:=j_1+j_2+j_3`):\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n          &=\\\\operatorname{Wigner3j}(j_3,j_1,j_2,m_3,m_1,m_2) \\\\\\\\\\n          &=\\\\operatorname{Wigner3j}(j_2,j_3,j_1,m_2,m_3,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_3,j_2,j_1,m_3,m_2,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_1,j_3,j_2,m_1,m_3,m_2) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_2,j_1,j_3,m_2,m_1,m_3)\\n         \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n         =(-1)^J \\\\operatorname{Wigner3j}(j_1,j_2,j_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 additional symmetries based on\\n      the work by [Regge58]_\\n\\n    - zero for `j_1`, `j_2`, `j_3` not fulfilling triangle relation\\n\\n    - zero for `m_1 + m_2 + m_3 \\\\neq 0`\\n\\n    - zero for violating any one of the conditions\\n      `j_1 \\\\ge |m_1|`,  `j_2 \\\\ge |m_2|`,  `j_3 \\\\ge |m_3|`\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    if int(j_1 * 2) != j_1 * 2 or int(j_2 * 2) != j_2 * 2 or int(j_3 * 2) != j_3 * 2:\n        raise ValueError('j values must be integer or half integer')\n    if int(m_1 * 2) != m_1 * 2 or int(m_2 * 2) != m_2 * 2 or int(m_3 * 2) != m_3 * 2:\n        raise ValueError('m values must be integer or half integer')\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    prefid = Integer((-1) ** int(j_1 - j_2 - m_3))\n    m_3 = -m_3\n    a1 = j_1 + j_2 - j_3\n    if a1 < 0:\n        return S.Zero\n    a2 = j_1 - j_2 + j_3\n    if a2 < 0:\n        return S.Zero\n    a3 = -j_1 + j_2 + j_3\n    if a3 < 0:\n        return S.Zero\n    if abs(m_1) > j_1 or abs(m_2) > j_2 or abs(m_3) > j_3:\n        return S.Zero\n    maxfact = max(j_1 + j_2 + j_3 + 1, j_1 + abs(m_1), j_2 + abs(m_2), j_3 + abs(m_3))\n    _calc_factlist(int(maxfact))\n    argsqrt = Integer(_Factlist[int(j_1 + j_2 - j_3)] * _Factlist[int(j_1 - j_2 + j_3)] * _Factlist[int(-j_1 + j_2 + j_3)] * _Factlist[int(j_1 - m_1)] * _Factlist[int(j_1 + m_1)] * _Factlist[int(j_2 - m_2)] * _Factlist[int(j_2 + m_2)] * _Factlist[int(j_3 - m_3)] * _Factlist[int(j_3 + m_3)]) / _Factlist[int(j_1 + j_2 + j_3 + 1)]\n    ressqrt = sqrt(argsqrt)\n    if ressqrt.is_complex or ressqrt.is_infinite:\n        ressqrt = ressqrt.as_real_imag()[0]\n    imin = max(-j_3 + j_1 + m_2, -j_3 + j_2 - m_1, 0)\n    imax = min(j_2 + m_2, j_1 - m_1, j_1 + j_2 - j_3)\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[int(ii + j_3 - j_1 - m_2)] * _Factlist[int(j_2 + m_2 - ii)] * _Factlist[int(j_1 - ii - m_1)] * _Factlist[int(ii + j_3 - j_2 + m_1)] * _Factlist[int(j_1 + j_2 - j_3 - ii)]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * sumres * prefid\n    return res",
            "def wigner_3j(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the Wigner 3j symbol `\\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_3j\\n    >>> wigner_3j(2, 6, 4, 0, 0, 0)\\n    sqrt(715)/143\\n    >>> wigner_3j(2, 6, 4, 0, 0, 1)\\n    0\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values::\\n\\n        sage: wigner_3j(2.1, 6, 4, 0, 0, 0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer\\n        sage: wigner_3j(2, 6, 4, 1, 0, -1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer or half integer\\n\\n    Notes\\n    =====\\n\\n    The Wigner 3j symbol obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns (with the\\n      exception of a sign change where `J:=j_1+j_2+j_3`):\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n          &=\\\\operatorname{Wigner3j}(j_3,j_1,j_2,m_3,m_1,m_2) \\\\\\\\\\n          &=\\\\operatorname{Wigner3j}(j_2,j_3,j_1,m_2,m_3,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_3,j_2,j_1,m_3,m_2,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_1,j_3,j_2,m_1,m_3,m_2) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_2,j_1,j_3,m_2,m_1,m_3)\\n         \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n         =(-1)^J \\\\operatorname{Wigner3j}(j_1,j_2,j_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 additional symmetries based on\\n      the work by [Regge58]_\\n\\n    - zero for `j_1`, `j_2`, `j_3` not fulfilling triangle relation\\n\\n    - zero for `m_1 + m_2 + m_3 \\\\neq 0`\\n\\n    - zero for violating any one of the conditions\\n      `j_1 \\\\ge |m_1|`,  `j_2 \\\\ge |m_2|`,  `j_3 \\\\ge |m_3|`\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    if int(j_1 * 2) != j_1 * 2 or int(j_2 * 2) != j_2 * 2 or int(j_3 * 2) != j_3 * 2:\n        raise ValueError('j values must be integer or half integer')\n    if int(m_1 * 2) != m_1 * 2 or int(m_2 * 2) != m_2 * 2 or int(m_3 * 2) != m_3 * 2:\n        raise ValueError('m values must be integer or half integer')\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    prefid = Integer((-1) ** int(j_1 - j_2 - m_3))\n    m_3 = -m_3\n    a1 = j_1 + j_2 - j_3\n    if a1 < 0:\n        return S.Zero\n    a2 = j_1 - j_2 + j_3\n    if a2 < 0:\n        return S.Zero\n    a3 = -j_1 + j_2 + j_3\n    if a3 < 0:\n        return S.Zero\n    if abs(m_1) > j_1 or abs(m_2) > j_2 or abs(m_3) > j_3:\n        return S.Zero\n    maxfact = max(j_1 + j_2 + j_3 + 1, j_1 + abs(m_1), j_2 + abs(m_2), j_3 + abs(m_3))\n    _calc_factlist(int(maxfact))\n    argsqrt = Integer(_Factlist[int(j_1 + j_2 - j_3)] * _Factlist[int(j_1 - j_2 + j_3)] * _Factlist[int(-j_1 + j_2 + j_3)] * _Factlist[int(j_1 - m_1)] * _Factlist[int(j_1 + m_1)] * _Factlist[int(j_2 - m_2)] * _Factlist[int(j_2 + m_2)] * _Factlist[int(j_3 - m_3)] * _Factlist[int(j_3 + m_3)]) / _Factlist[int(j_1 + j_2 + j_3 + 1)]\n    ressqrt = sqrt(argsqrt)\n    if ressqrt.is_complex or ressqrt.is_infinite:\n        ressqrt = ressqrt.as_real_imag()[0]\n    imin = max(-j_3 + j_1 + m_2, -j_3 + j_2 - m_1, 0)\n    imax = min(j_2 + m_2, j_1 - m_1, j_1 + j_2 - j_3)\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[int(ii + j_3 - j_1 - m_2)] * _Factlist[int(j_2 + m_2 - ii)] * _Factlist[int(j_1 - ii - m_1)] * _Factlist[int(ii + j_3 - j_2 + m_1)] * _Factlist[int(j_1 + j_2 - j_3 - ii)]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * sumres * prefid\n    return res",
            "def wigner_3j(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the Wigner 3j symbol `\\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_3j\\n    >>> wigner_3j(2, 6, 4, 0, 0, 0)\\n    sqrt(715)/143\\n    >>> wigner_3j(2, 6, 4, 0, 0, 1)\\n    0\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values::\\n\\n        sage: wigner_3j(2.1, 6, 4, 0, 0, 0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer\\n        sage: wigner_3j(2, 6, 4, 1, 0, -1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer or half integer\\n\\n    Notes\\n    =====\\n\\n    The Wigner 3j symbol obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns (with the\\n      exception of a sign change where `J:=j_1+j_2+j_3`):\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n          &=\\\\operatorname{Wigner3j}(j_3,j_1,j_2,m_3,m_1,m_2) \\\\\\\\\\n          &=\\\\operatorname{Wigner3j}(j_2,j_3,j_1,m_2,m_3,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_3,j_2,j_1,m_3,m_2,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_1,j_3,j_2,m_1,m_3,m_2) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_2,j_1,j_3,m_2,m_1,m_3)\\n         \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n         =(-1)^J \\\\operatorname{Wigner3j}(j_1,j_2,j_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 additional symmetries based on\\n      the work by [Regge58]_\\n\\n    - zero for `j_1`, `j_2`, `j_3` not fulfilling triangle relation\\n\\n    - zero for `m_1 + m_2 + m_3 \\\\neq 0`\\n\\n    - zero for violating any one of the conditions\\n      `j_1 \\\\ge |m_1|`,  `j_2 \\\\ge |m_2|`,  `j_3 \\\\ge |m_3|`\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    if int(j_1 * 2) != j_1 * 2 or int(j_2 * 2) != j_2 * 2 or int(j_3 * 2) != j_3 * 2:\n        raise ValueError('j values must be integer or half integer')\n    if int(m_1 * 2) != m_1 * 2 or int(m_2 * 2) != m_2 * 2 or int(m_3 * 2) != m_3 * 2:\n        raise ValueError('m values must be integer or half integer')\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    prefid = Integer((-1) ** int(j_1 - j_2 - m_3))\n    m_3 = -m_3\n    a1 = j_1 + j_2 - j_3\n    if a1 < 0:\n        return S.Zero\n    a2 = j_1 - j_2 + j_3\n    if a2 < 0:\n        return S.Zero\n    a3 = -j_1 + j_2 + j_3\n    if a3 < 0:\n        return S.Zero\n    if abs(m_1) > j_1 or abs(m_2) > j_2 or abs(m_3) > j_3:\n        return S.Zero\n    maxfact = max(j_1 + j_2 + j_3 + 1, j_1 + abs(m_1), j_2 + abs(m_2), j_3 + abs(m_3))\n    _calc_factlist(int(maxfact))\n    argsqrt = Integer(_Factlist[int(j_1 + j_2 - j_3)] * _Factlist[int(j_1 - j_2 + j_3)] * _Factlist[int(-j_1 + j_2 + j_3)] * _Factlist[int(j_1 - m_1)] * _Factlist[int(j_1 + m_1)] * _Factlist[int(j_2 - m_2)] * _Factlist[int(j_2 + m_2)] * _Factlist[int(j_3 - m_3)] * _Factlist[int(j_3 + m_3)]) / _Factlist[int(j_1 + j_2 + j_3 + 1)]\n    ressqrt = sqrt(argsqrt)\n    if ressqrt.is_complex or ressqrt.is_infinite:\n        ressqrt = ressqrt.as_real_imag()[0]\n    imin = max(-j_3 + j_1 + m_2, -j_3 + j_2 - m_1, 0)\n    imax = min(j_2 + m_2, j_1 - m_1, j_1 + j_2 - j_3)\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[int(ii + j_3 - j_1 - m_2)] * _Factlist[int(j_2 + m_2 - ii)] * _Factlist[int(j_1 - ii - m_1)] * _Factlist[int(ii + j_3 - j_2 + m_1)] * _Factlist[int(j_1 + j_2 - j_3 - ii)]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * sumres * prefid\n    return res",
            "def wigner_3j(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the Wigner 3j symbol `\\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_3j\\n    >>> wigner_3j(2, 6, 4, 0, 0, 0)\\n    sqrt(715)/143\\n    >>> wigner_3j(2, 6, 4, 0, 0, 1)\\n    0\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values::\\n\\n        sage: wigner_3j(2.1, 6, 4, 0, 0, 0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer\\n        sage: wigner_3j(2, 6, 4, 1, 0, -1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer or half integer\\n\\n    Notes\\n    =====\\n\\n    The Wigner 3j symbol obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns (with the\\n      exception of a sign change where `J:=j_1+j_2+j_3`):\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n          &=\\\\operatorname{Wigner3j}(j_3,j_1,j_2,m_3,m_1,m_2) \\\\\\\\\\n          &=\\\\operatorname{Wigner3j}(j_2,j_3,j_1,m_2,m_3,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_3,j_2,j_1,m_3,m_2,m_1) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_1,j_3,j_2,m_1,m_3,m_2) \\\\\\\\\\n          &=(-1)^J \\\\operatorname{Wigner3j}(j_2,j_1,j_3,m_2,m_1,m_3)\\n         \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\\n         =(-1)^J \\\\operatorname{Wigner3j}(j_1,j_2,j_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 additional symmetries based on\\n      the work by [Regge58]_\\n\\n    - zero for `j_1`, `j_2`, `j_3` not fulfilling triangle relation\\n\\n    - zero for `m_1 + m_2 + m_3 \\\\neq 0`\\n\\n    - zero for violating any one of the conditions\\n      `j_1 \\\\ge |m_1|`,  `j_2 \\\\ge |m_2|`,  `j_3 \\\\ge |m_3|`\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    if int(j_1 * 2) != j_1 * 2 or int(j_2 * 2) != j_2 * 2 or int(j_3 * 2) != j_3 * 2:\n        raise ValueError('j values must be integer or half integer')\n    if int(m_1 * 2) != m_1 * 2 or int(m_2 * 2) != m_2 * 2 or int(m_3 * 2) != m_3 * 2:\n        raise ValueError('m values must be integer or half integer')\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    prefid = Integer((-1) ** int(j_1 - j_2 - m_3))\n    m_3 = -m_3\n    a1 = j_1 + j_2 - j_3\n    if a1 < 0:\n        return S.Zero\n    a2 = j_1 - j_2 + j_3\n    if a2 < 0:\n        return S.Zero\n    a3 = -j_1 + j_2 + j_3\n    if a3 < 0:\n        return S.Zero\n    if abs(m_1) > j_1 or abs(m_2) > j_2 or abs(m_3) > j_3:\n        return S.Zero\n    maxfact = max(j_1 + j_2 + j_3 + 1, j_1 + abs(m_1), j_2 + abs(m_2), j_3 + abs(m_3))\n    _calc_factlist(int(maxfact))\n    argsqrt = Integer(_Factlist[int(j_1 + j_2 - j_3)] * _Factlist[int(j_1 - j_2 + j_3)] * _Factlist[int(-j_1 + j_2 + j_3)] * _Factlist[int(j_1 - m_1)] * _Factlist[int(j_1 + m_1)] * _Factlist[int(j_2 - m_2)] * _Factlist[int(j_2 + m_2)] * _Factlist[int(j_3 - m_3)] * _Factlist[int(j_3 + m_3)]) / _Factlist[int(j_1 + j_2 + j_3 + 1)]\n    ressqrt = sqrt(argsqrt)\n    if ressqrt.is_complex or ressqrt.is_infinite:\n        ressqrt = ressqrt.as_real_imag()[0]\n    imin = max(-j_3 + j_1 + m_2, -j_3 + j_2 - m_1, 0)\n    imax = min(j_2 + m_2, j_1 - m_1, j_1 + j_2 - j_3)\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[int(ii + j_3 - j_1 - m_2)] * _Factlist[int(j_2 + m_2 - ii)] * _Factlist[int(j_1 - ii - m_1)] * _Factlist[int(ii + j_3 - j_2 + m_1)] * _Factlist[int(j_1 + j_2 - j_3 - ii)]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * sumres * prefid\n    return res"
        ]
    },
    {
        "func_name": "clebsch_gordan",
        "original": "def clebsch_gordan(j_1, j_2, j_3, m_1, m_2, m_3):\n    \"\"\"\n    Calculates the Clebsch-Gordan coefficient.\n    `\\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle`.\n\n    The reference for this function is [Edmonds74]_.\n\n    Parameters\n    ==========\n\n    j_1, j_2, j_3, m_1, m_2, m_3 :\n        Integer or half integer.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> from sympy.physics.wigner import clebsch_gordan\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 2, S(3)/2, S(1)/2, 2)\n    1\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, S(3)/2, -S(1)/2, 1)\n    sqrt(3)/2\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, -S(1)/2, S(1)/2, 0)\n    -sqrt(2)/2\n\n    Notes\n    =====\n\n    The Clebsch-Gordan coefficient will be evaluated via its relation\n    to Wigner 3j symbols:\n\n    .. math::\n\n        \\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle\n        =(-1)^{j_1-j_2+m_3} \\\\sqrt{2j_3+1}\n        \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,-m_3)\n\n    See also the documentation on Wigner 3j symbols which exhibit much\n    higher symmetry relations than the Clebsch-Gordan coefficient.\n\n    Authors\n    =======\n\n    - Jens Rasch (2009-03-24): initial version\n    \"\"\"\n    res = (-1) ** sympify(j_1 - j_2 + m_3) * sqrt(2 * j_3 + 1) * wigner_3j(j_1, j_2, j_3, m_1, m_2, -m_3)\n    return res",
        "mutated": [
            "def clebsch_gordan(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n    '\\n    Calculates the Clebsch-Gordan coefficient.\\n    `\\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle`.\\n\\n    The reference for this function is [Edmonds74]_.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.physics.wigner import clebsch_gordan\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 2, S(3)/2, S(1)/2, 2)\\n    1\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, S(3)/2, -S(1)/2, 1)\\n    sqrt(3)/2\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, -S(1)/2, S(1)/2, 0)\\n    -sqrt(2)/2\\n\\n    Notes\\n    =====\\n\\n    The Clebsch-Gordan coefficient will be evaluated via its relation\\n    to Wigner 3j symbols:\\n\\n    .. math::\\n\\n        \\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle\\n        =(-1)^{j_1-j_2+m_3} \\\\sqrt{2j_3+1}\\n        \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,-m_3)\\n\\n    See also the documentation on Wigner 3j symbols which exhibit much\\n    higher symmetry relations than the Clebsch-Gordan coefficient.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    res = (-1) ** sympify(j_1 - j_2 + m_3) * sqrt(2 * j_3 + 1) * wigner_3j(j_1, j_2, j_3, m_1, m_2, -m_3)\n    return res",
            "def clebsch_gordan(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculates the Clebsch-Gordan coefficient.\\n    `\\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle`.\\n\\n    The reference for this function is [Edmonds74]_.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.physics.wigner import clebsch_gordan\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 2, S(3)/2, S(1)/2, 2)\\n    1\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, S(3)/2, -S(1)/2, 1)\\n    sqrt(3)/2\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, -S(1)/2, S(1)/2, 0)\\n    -sqrt(2)/2\\n\\n    Notes\\n    =====\\n\\n    The Clebsch-Gordan coefficient will be evaluated via its relation\\n    to Wigner 3j symbols:\\n\\n    .. math::\\n\\n        \\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle\\n        =(-1)^{j_1-j_2+m_3} \\\\sqrt{2j_3+1}\\n        \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,-m_3)\\n\\n    See also the documentation on Wigner 3j symbols which exhibit much\\n    higher symmetry relations than the Clebsch-Gordan coefficient.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    res = (-1) ** sympify(j_1 - j_2 + m_3) * sqrt(2 * j_3 + 1) * wigner_3j(j_1, j_2, j_3, m_1, m_2, -m_3)\n    return res",
            "def clebsch_gordan(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculates the Clebsch-Gordan coefficient.\\n    `\\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle`.\\n\\n    The reference for this function is [Edmonds74]_.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.physics.wigner import clebsch_gordan\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 2, S(3)/2, S(1)/2, 2)\\n    1\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, S(3)/2, -S(1)/2, 1)\\n    sqrt(3)/2\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, -S(1)/2, S(1)/2, 0)\\n    -sqrt(2)/2\\n\\n    Notes\\n    =====\\n\\n    The Clebsch-Gordan coefficient will be evaluated via its relation\\n    to Wigner 3j symbols:\\n\\n    .. math::\\n\\n        \\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle\\n        =(-1)^{j_1-j_2+m_3} \\\\sqrt{2j_3+1}\\n        \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,-m_3)\\n\\n    See also the documentation on Wigner 3j symbols which exhibit much\\n    higher symmetry relations than the Clebsch-Gordan coefficient.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    res = (-1) ** sympify(j_1 - j_2 + m_3) * sqrt(2 * j_3 + 1) * wigner_3j(j_1, j_2, j_3, m_1, m_2, -m_3)\n    return res",
            "def clebsch_gordan(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculates the Clebsch-Gordan coefficient.\\n    `\\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle`.\\n\\n    The reference for this function is [Edmonds74]_.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.physics.wigner import clebsch_gordan\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 2, S(3)/2, S(1)/2, 2)\\n    1\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, S(3)/2, -S(1)/2, 1)\\n    sqrt(3)/2\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, -S(1)/2, S(1)/2, 0)\\n    -sqrt(2)/2\\n\\n    Notes\\n    =====\\n\\n    The Clebsch-Gordan coefficient will be evaluated via its relation\\n    to Wigner 3j symbols:\\n\\n    .. math::\\n\\n        \\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle\\n        =(-1)^{j_1-j_2+m_3} \\\\sqrt{2j_3+1}\\n        \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,-m_3)\\n\\n    See also the documentation on Wigner 3j symbols which exhibit much\\n    higher symmetry relations than the Clebsch-Gordan coefficient.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    res = (-1) ** sympify(j_1 - j_2 + m_3) * sqrt(2 * j_3 + 1) * wigner_3j(j_1, j_2, j_3, m_1, m_2, -m_3)\n    return res",
            "def clebsch_gordan(j_1, j_2, j_3, m_1, m_2, m_3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculates the Clebsch-Gordan coefficient.\\n    `\\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle`.\\n\\n    The reference for this function is [Edmonds74]_.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, j_2, j_3, m_1, m_2, m_3 :\\n        Integer or half integer.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.physics.wigner import clebsch_gordan\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 2, S(3)/2, S(1)/2, 2)\\n    1\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, S(3)/2, -S(1)/2, 1)\\n    sqrt(3)/2\\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, -S(1)/2, S(1)/2, 0)\\n    -sqrt(2)/2\\n\\n    Notes\\n    =====\\n\\n    The Clebsch-Gordan coefficient will be evaluated via its relation\\n    to Wigner 3j symbols:\\n\\n    .. math::\\n\\n        \\\\left\\\\langle j_1 m_1 \\\\; j_2 m_2 | j_3 m_3 \\\\right\\\\rangle\\n        =(-1)^{j_1-j_2+m_3} \\\\sqrt{2j_3+1}\\n        \\\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,-m_3)\\n\\n    See also the documentation on Wigner 3j symbols which exhibit much\\n    higher symmetry relations than the Clebsch-Gordan coefficient.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    res = (-1) ** sympify(j_1 - j_2 + m_3) * sqrt(2 * j_3 + 1) * wigner_3j(j_1, j_2, j_3, m_1, m_2, -m_3)\n    return res"
        ]
    },
    {
        "func_name": "_big_delta_coeff",
        "original": "def _big_delta_coeff(aa, bb, cc, prec=None):\n    \"\"\"\n    Calculates the Delta coefficient of the 3 angular momenta for\n    Racah symbols. Also checks that the differences are of integer\n    value.\n\n    Parameters\n    ==========\n\n    aa :\n        First angular momentum, integer or half integer.\n    bb :\n        Second angular momentum, integer or half integer.\n    cc :\n        Third angular momentum, integer or half integer.\n    prec :\n        Precision of the ``sqrt()`` calculation.\n\n    Returns\n    =======\n\n    double : Value of the Delta coefficient.\n\n    Examples\n    ========\n\n        sage: from sage.functions.wigner import _big_delta_coeff\n        sage: _big_delta_coeff(1,1,1)\n        1/2*sqrt(1/6)\n    \"\"\"\n    if not int_valued(aa + bb - cc):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(aa + cc - bb):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(bb + cc - aa):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if aa + bb - cc < 0:\n        return S.Zero\n    if aa + cc - bb < 0:\n        return S.Zero\n    if bb + cc - aa < 0:\n        return S.Zero\n    maxfact = max(aa + bb - cc, aa + cc - bb, bb + cc - aa, aa + bb + cc + 1)\n    _calc_factlist(maxfact)\n    argsqrt = Integer(_Factlist[int(aa + bb - cc)] * _Factlist[int(aa + cc - bb)] * _Factlist[int(bb + cc - aa)]) / Integer(_Factlist[int(aa + bb + cc + 1)])\n    ressqrt = sqrt(argsqrt)\n    if prec:\n        ressqrt = ressqrt.evalf(prec).as_real_imag()[0]\n    return ressqrt",
        "mutated": [
            "def _big_delta_coeff(aa, bb, cc, prec=None):\n    if False:\n        i = 10\n    '\\n    Calculates the Delta coefficient of the 3 angular momenta for\\n    Racah symbols. Also checks that the differences are of integer\\n    value.\\n\\n    Parameters\\n    ==========\\n\\n    aa :\\n        First angular momentum, integer or half integer.\\n    bb :\\n        Second angular momentum, integer or half integer.\\n    cc :\\n        Third angular momentum, integer or half integer.\\n    prec :\\n        Precision of the ``sqrt()`` calculation.\\n\\n    Returns\\n    =======\\n\\n    double : Value of the Delta coefficient.\\n\\n    Examples\\n    ========\\n\\n        sage: from sage.functions.wigner import _big_delta_coeff\\n        sage: _big_delta_coeff(1,1,1)\\n        1/2*sqrt(1/6)\\n    '\n    if not int_valued(aa + bb - cc):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(aa + cc - bb):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(bb + cc - aa):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if aa + bb - cc < 0:\n        return S.Zero\n    if aa + cc - bb < 0:\n        return S.Zero\n    if bb + cc - aa < 0:\n        return S.Zero\n    maxfact = max(aa + bb - cc, aa + cc - bb, bb + cc - aa, aa + bb + cc + 1)\n    _calc_factlist(maxfact)\n    argsqrt = Integer(_Factlist[int(aa + bb - cc)] * _Factlist[int(aa + cc - bb)] * _Factlist[int(bb + cc - aa)]) / Integer(_Factlist[int(aa + bb + cc + 1)])\n    ressqrt = sqrt(argsqrt)\n    if prec:\n        ressqrt = ressqrt.evalf(prec).as_real_imag()[0]\n    return ressqrt",
            "def _big_delta_coeff(aa, bb, cc, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculates the Delta coefficient of the 3 angular momenta for\\n    Racah symbols. Also checks that the differences are of integer\\n    value.\\n\\n    Parameters\\n    ==========\\n\\n    aa :\\n        First angular momentum, integer or half integer.\\n    bb :\\n        Second angular momentum, integer or half integer.\\n    cc :\\n        Third angular momentum, integer or half integer.\\n    prec :\\n        Precision of the ``sqrt()`` calculation.\\n\\n    Returns\\n    =======\\n\\n    double : Value of the Delta coefficient.\\n\\n    Examples\\n    ========\\n\\n        sage: from sage.functions.wigner import _big_delta_coeff\\n        sage: _big_delta_coeff(1,1,1)\\n        1/2*sqrt(1/6)\\n    '\n    if not int_valued(aa + bb - cc):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(aa + cc - bb):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(bb + cc - aa):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if aa + bb - cc < 0:\n        return S.Zero\n    if aa + cc - bb < 0:\n        return S.Zero\n    if bb + cc - aa < 0:\n        return S.Zero\n    maxfact = max(aa + bb - cc, aa + cc - bb, bb + cc - aa, aa + bb + cc + 1)\n    _calc_factlist(maxfact)\n    argsqrt = Integer(_Factlist[int(aa + bb - cc)] * _Factlist[int(aa + cc - bb)] * _Factlist[int(bb + cc - aa)]) / Integer(_Factlist[int(aa + bb + cc + 1)])\n    ressqrt = sqrt(argsqrt)\n    if prec:\n        ressqrt = ressqrt.evalf(prec).as_real_imag()[0]\n    return ressqrt",
            "def _big_delta_coeff(aa, bb, cc, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculates the Delta coefficient of the 3 angular momenta for\\n    Racah symbols. Also checks that the differences are of integer\\n    value.\\n\\n    Parameters\\n    ==========\\n\\n    aa :\\n        First angular momentum, integer or half integer.\\n    bb :\\n        Second angular momentum, integer or half integer.\\n    cc :\\n        Third angular momentum, integer or half integer.\\n    prec :\\n        Precision of the ``sqrt()`` calculation.\\n\\n    Returns\\n    =======\\n\\n    double : Value of the Delta coefficient.\\n\\n    Examples\\n    ========\\n\\n        sage: from sage.functions.wigner import _big_delta_coeff\\n        sage: _big_delta_coeff(1,1,1)\\n        1/2*sqrt(1/6)\\n    '\n    if not int_valued(aa + bb - cc):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(aa + cc - bb):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(bb + cc - aa):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if aa + bb - cc < 0:\n        return S.Zero\n    if aa + cc - bb < 0:\n        return S.Zero\n    if bb + cc - aa < 0:\n        return S.Zero\n    maxfact = max(aa + bb - cc, aa + cc - bb, bb + cc - aa, aa + bb + cc + 1)\n    _calc_factlist(maxfact)\n    argsqrt = Integer(_Factlist[int(aa + bb - cc)] * _Factlist[int(aa + cc - bb)] * _Factlist[int(bb + cc - aa)]) / Integer(_Factlist[int(aa + bb + cc + 1)])\n    ressqrt = sqrt(argsqrt)\n    if prec:\n        ressqrt = ressqrt.evalf(prec).as_real_imag()[0]\n    return ressqrt",
            "def _big_delta_coeff(aa, bb, cc, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculates the Delta coefficient of the 3 angular momenta for\\n    Racah symbols. Also checks that the differences are of integer\\n    value.\\n\\n    Parameters\\n    ==========\\n\\n    aa :\\n        First angular momentum, integer or half integer.\\n    bb :\\n        Second angular momentum, integer or half integer.\\n    cc :\\n        Third angular momentum, integer or half integer.\\n    prec :\\n        Precision of the ``sqrt()`` calculation.\\n\\n    Returns\\n    =======\\n\\n    double : Value of the Delta coefficient.\\n\\n    Examples\\n    ========\\n\\n        sage: from sage.functions.wigner import _big_delta_coeff\\n        sage: _big_delta_coeff(1,1,1)\\n        1/2*sqrt(1/6)\\n    '\n    if not int_valued(aa + bb - cc):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(aa + cc - bb):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(bb + cc - aa):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if aa + bb - cc < 0:\n        return S.Zero\n    if aa + cc - bb < 0:\n        return S.Zero\n    if bb + cc - aa < 0:\n        return S.Zero\n    maxfact = max(aa + bb - cc, aa + cc - bb, bb + cc - aa, aa + bb + cc + 1)\n    _calc_factlist(maxfact)\n    argsqrt = Integer(_Factlist[int(aa + bb - cc)] * _Factlist[int(aa + cc - bb)] * _Factlist[int(bb + cc - aa)]) / Integer(_Factlist[int(aa + bb + cc + 1)])\n    ressqrt = sqrt(argsqrt)\n    if prec:\n        ressqrt = ressqrt.evalf(prec).as_real_imag()[0]\n    return ressqrt",
            "def _big_delta_coeff(aa, bb, cc, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculates the Delta coefficient of the 3 angular momenta for\\n    Racah symbols. Also checks that the differences are of integer\\n    value.\\n\\n    Parameters\\n    ==========\\n\\n    aa :\\n        First angular momentum, integer or half integer.\\n    bb :\\n        Second angular momentum, integer or half integer.\\n    cc :\\n        Third angular momentum, integer or half integer.\\n    prec :\\n        Precision of the ``sqrt()`` calculation.\\n\\n    Returns\\n    =======\\n\\n    double : Value of the Delta coefficient.\\n\\n    Examples\\n    ========\\n\\n        sage: from sage.functions.wigner import _big_delta_coeff\\n        sage: _big_delta_coeff(1,1,1)\\n        1/2*sqrt(1/6)\\n    '\n    if not int_valued(aa + bb - cc):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(aa + cc - bb):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if not int_valued(bb + cc - aa):\n        raise ValueError('j values must be integer or half integer and fulfill the triangle relation')\n    if aa + bb - cc < 0:\n        return S.Zero\n    if aa + cc - bb < 0:\n        return S.Zero\n    if bb + cc - aa < 0:\n        return S.Zero\n    maxfact = max(aa + bb - cc, aa + cc - bb, bb + cc - aa, aa + bb + cc + 1)\n    _calc_factlist(maxfact)\n    argsqrt = Integer(_Factlist[int(aa + bb - cc)] * _Factlist[int(aa + cc - bb)] * _Factlist[int(bb + cc - aa)]) / Integer(_Factlist[int(aa + bb + cc + 1)])\n    ressqrt = sqrt(argsqrt)\n    if prec:\n        ressqrt = ressqrt.evalf(prec).as_real_imag()[0]\n    return ressqrt"
        ]
    },
    {
        "func_name": "racah",
        "original": "def racah(aa, bb, cc, dd, ee, ff, prec=None):\n    \"\"\"\n    Calculate the Racah symbol `W(a,b,c,d;e,f)`.\n\n    Parameters\n    ==========\n\n    a, ..., f :\n        Integer or half integer.\n    prec :\n        Precision, default: ``None``. Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number\n    (if ``prec=None``), or real number if a precision is given.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import racah\n    >>> racah(3,3,3,3,3,3)\n    -1/14\n\n    Notes\n    =====\n\n    The Racah symbol is related to the Wigner 6j symbol:\n\n    .. math::\n\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\n       =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\n\n    Please see the 6j symbol for its much richer symmetries and for\n    additional properties.\n\n    Algorithm\n    =========\n\n    This function uses the algorithm of [Edmonds74]_ to calculate the\n    value of the 6j symbol exactly. Note that the formula contains\n    alternating sums over large factorials and is therefore unsuitable\n    for finite precision arithmetic and only useful for a computer\n    algebra system [Rasch03]_.\n\n    Authors\n    =======\n\n    - Jens Rasch (2009-03-24): initial version\n    \"\"\"\n    prefac = _big_delta_coeff(aa, bb, ee, prec) * _big_delta_coeff(cc, dd, ee, prec) * _big_delta_coeff(aa, cc, ff, prec) * _big_delta_coeff(bb, dd, ff, prec)\n    if prefac == 0:\n        return S.Zero\n    imin = max(aa + bb + ee, cc + dd + ee, aa + cc + ff, bb + dd + ff)\n    imax = min(aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    maxfact = max(imax + 1, aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    _calc_factlist(maxfact)\n    sumres = 0\n    for kk in range(int(imin), int(imax) + 1):\n        den = _Factlist[int(kk - aa - bb - ee)] * _Factlist[int(kk - cc - dd - ee)] * _Factlist[int(kk - aa - cc - ff)] * _Factlist[int(kk - bb - dd - ff)] * _Factlist[int(aa + bb + cc + dd - kk)] * _Factlist[int(aa + dd + ee + ff - kk)] * _Factlist[int(bb + cc + ee + ff - kk)]\n        sumres = sumres + Integer((-1) ** kk * _Factlist[kk + 1]) / den\n    res = prefac * sumres * (-1) ** int(aa + bb + cc + dd)\n    return res",
        "mutated": [
            "def racah(aa, bb, cc, dd, ee, ff, prec=None):\n    if False:\n        i = 10\n    '\\n    Calculate the Racah symbol `W(a,b,c,d;e,f)`.\\n\\n    Parameters\\n    ==========\\n\\n    a, ..., f :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import racah\\n    >>> racah(3,3,3,3,3,3)\\n    -1/14\\n\\n    Notes\\n    =====\\n\\n    The Racah symbol is related to the Wigner 6j symbol:\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n       =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    Please see the 6j symbol for its much richer symmetries and for\\n    additional properties.\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    prefac = _big_delta_coeff(aa, bb, ee, prec) * _big_delta_coeff(cc, dd, ee, prec) * _big_delta_coeff(aa, cc, ff, prec) * _big_delta_coeff(bb, dd, ff, prec)\n    if prefac == 0:\n        return S.Zero\n    imin = max(aa + bb + ee, cc + dd + ee, aa + cc + ff, bb + dd + ff)\n    imax = min(aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    maxfact = max(imax + 1, aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    _calc_factlist(maxfact)\n    sumres = 0\n    for kk in range(int(imin), int(imax) + 1):\n        den = _Factlist[int(kk - aa - bb - ee)] * _Factlist[int(kk - cc - dd - ee)] * _Factlist[int(kk - aa - cc - ff)] * _Factlist[int(kk - bb - dd - ff)] * _Factlist[int(aa + bb + cc + dd - kk)] * _Factlist[int(aa + dd + ee + ff - kk)] * _Factlist[int(bb + cc + ee + ff - kk)]\n        sumres = sumres + Integer((-1) ** kk * _Factlist[kk + 1]) / den\n    res = prefac * sumres * (-1) ** int(aa + bb + cc + dd)\n    return res",
            "def racah(aa, bb, cc, dd, ee, ff, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the Racah symbol `W(a,b,c,d;e,f)`.\\n\\n    Parameters\\n    ==========\\n\\n    a, ..., f :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import racah\\n    >>> racah(3,3,3,3,3,3)\\n    -1/14\\n\\n    Notes\\n    =====\\n\\n    The Racah symbol is related to the Wigner 6j symbol:\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n       =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    Please see the 6j symbol for its much richer symmetries and for\\n    additional properties.\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    prefac = _big_delta_coeff(aa, bb, ee, prec) * _big_delta_coeff(cc, dd, ee, prec) * _big_delta_coeff(aa, cc, ff, prec) * _big_delta_coeff(bb, dd, ff, prec)\n    if prefac == 0:\n        return S.Zero\n    imin = max(aa + bb + ee, cc + dd + ee, aa + cc + ff, bb + dd + ff)\n    imax = min(aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    maxfact = max(imax + 1, aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    _calc_factlist(maxfact)\n    sumres = 0\n    for kk in range(int(imin), int(imax) + 1):\n        den = _Factlist[int(kk - aa - bb - ee)] * _Factlist[int(kk - cc - dd - ee)] * _Factlist[int(kk - aa - cc - ff)] * _Factlist[int(kk - bb - dd - ff)] * _Factlist[int(aa + bb + cc + dd - kk)] * _Factlist[int(aa + dd + ee + ff - kk)] * _Factlist[int(bb + cc + ee + ff - kk)]\n        sumres = sumres + Integer((-1) ** kk * _Factlist[kk + 1]) / den\n    res = prefac * sumres * (-1) ** int(aa + bb + cc + dd)\n    return res",
            "def racah(aa, bb, cc, dd, ee, ff, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the Racah symbol `W(a,b,c,d;e,f)`.\\n\\n    Parameters\\n    ==========\\n\\n    a, ..., f :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import racah\\n    >>> racah(3,3,3,3,3,3)\\n    -1/14\\n\\n    Notes\\n    =====\\n\\n    The Racah symbol is related to the Wigner 6j symbol:\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n       =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    Please see the 6j symbol for its much richer symmetries and for\\n    additional properties.\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    prefac = _big_delta_coeff(aa, bb, ee, prec) * _big_delta_coeff(cc, dd, ee, prec) * _big_delta_coeff(aa, cc, ff, prec) * _big_delta_coeff(bb, dd, ff, prec)\n    if prefac == 0:\n        return S.Zero\n    imin = max(aa + bb + ee, cc + dd + ee, aa + cc + ff, bb + dd + ff)\n    imax = min(aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    maxfact = max(imax + 1, aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    _calc_factlist(maxfact)\n    sumres = 0\n    for kk in range(int(imin), int(imax) + 1):\n        den = _Factlist[int(kk - aa - bb - ee)] * _Factlist[int(kk - cc - dd - ee)] * _Factlist[int(kk - aa - cc - ff)] * _Factlist[int(kk - bb - dd - ff)] * _Factlist[int(aa + bb + cc + dd - kk)] * _Factlist[int(aa + dd + ee + ff - kk)] * _Factlist[int(bb + cc + ee + ff - kk)]\n        sumres = sumres + Integer((-1) ** kk * _Factlist[kk + 1]) / den\n    res = prefac * sumres * (-1) ** int(aa + bb + cc + dd)\n    return res",
            "def racah(aa, bb, cc, dd, ee, ff, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the Racah symbol `W(a,b,c,d;e,f)`.\\n\\n    Parameters\\n    ==========\\n\\n    a, ..., f :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import racah\\n    >>> racah(3,3,3,3,3,3)\\n    -1/14\\n\\n    Notes\\n    =====\\n\\n    The Racah symbol is related to the Wigner 6j symbol:\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n       =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    Please see the 6j symbol for its much richer symmetries and for\\n    additional properties.\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    prefac = _big_delta_coeff(aa, bb, ee, prec) * _big_delta_coeff(cc, dd, ee, prec) * _big_delta_coeff(aa, cc, ff, prec) * _big_delta_coeff(bb, dd, ff, prec)\n    if prefac == 0:\n        return S.Zero\n    imin = max(aa + bb + ee, cc + dd + ee, aa + cc + ff, bb + dd + ff)\n    imax = min(aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    maxfact = max(imax + 1, aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    _calc_factlist(maxfact)\n    sumres = 0\n    for kk in range(int(imin), int(imax) + 1):\n        den = _Factlist[int(kk - aa - bb - ee)] * _Factlist[int(kk - cc - dd - ee)] * _Factlist[int(kk - aa - cc - ff)] * _Factlist[int(kk - bb - dd - ff)] * _Factlist[int(aa + bb + cc + dd - kk)] * _Factlist[int(aa + dd + ee + ff - kk)] * _Factlist[int(bb + cc + ee + ff - kk)]\n        sumres = sumres + Integer((-1) ** kk * _Factlist[kk + 1]) / den\n    res = prefac * sumres * (-1) ** int(aa + bb + cc + dd)\n    return res",
            "def racah(aa, bb, cc, dd, ee, ff, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the Racah symbol `W(a,b,c,d;e,f)`.\\n\\n    Parameters\\n    ==========\\n\\n    a, ..., f :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import racah\\n    >>> racah(3,3,3,3,3,3)\\n    -1/14\\n\\n    Notes\\n    =====\\n\\n    The Racah symbol is related to the Wigner 6j symbol:\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n       =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    Please see the 6j symbol for its much richer symmetries and for\\n    additional properties.\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    - Jens Rasch (2009-03-24): initial version\\n    '\n    prefac = _big_delta_coeff(aa, bb, ee, prec) * _big_delta_coeff(cc, dd, ee, prec) * _big_delta_coeff(aa, cc, ff, prec) * _big_delta_coeff(bb, dd, ff, prec)\n    if prefac == 0:\n        return S.Zero\n    imin = max(aa + bb + ee, cc + dd + ee, aa + cc + ff, bb + dd + ff)\n    imax = min(aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    maxfact = max(imax + 1, aa + bb + cc + dd, aa + dd + ee + ff, bb + cc + ee + ff)\n    _calc_factlist(maxfact)\n    sumres = 0\n    for kk in range(int(imin), int(imax) + 1):\n        den = _Factlist[int(kk - aa - bb - ee)] * _Factlist[int(kk - cc - dd - ee)] * _Factlist[int(kk - aa - cc - ff)] * _Factlist[int(kk - bb - dd - ff)] * _Factlist[int(aa + bb + cc + dd - kk)] * _Factlist[int(aa + dd + ee + ff - kk)] * _Factlist[int(bb + cc + ee + ff - kk)]\n        sumres = sumres + Integer((-1) ** kk * _Factlist[kk + 1]) / den\n    res = prefac * sumres * (-1) ** int(aa + bb + cc + dd)\n    return res"
        ]
    },
    {
        "func_name": "wigner_6j",
        "original": "def wigner_6j(j_1, j_2, j_3, j_4, j_5, j_6, prec=None):\n    \"\"\"\n    Calculate the Wigner 6j symbol `\\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)`.\n\n    Parameters\n    ==========\n\n    j_1, ..., j_6 :\n        Integer or half integer.\n    prec :\n        Precision, default: ``None``. Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number\n    (if ``prec=None``), or real number if a precision is given.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import wigner_6j\n    >>> wigner_6j(3,3,3,3,3,3)\n    -1/14\n    >>> wigner_6j(5,5,5,5,5,5)\n    1/52\n\n    It is an error to have arguments that are not integer or half\n    integer values or do not fulfill the triangle relation::\n\n        sage: wigner_6j(2.5,2.5,2.5,2.5,2.5,2.5)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\n        sage: wigner_6j(0.5,0.5,1.1,0.5,0.5,1.1)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\n\n    Notes\n    =====\n\n    The Wigner 6j symbol is related to the Racah symbol but exhibits\n    more symmetries as detailed below.\n\n    .. math::\n\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\n        =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\n\n    The Wigner 6j symbol obeys the following symmetry rules:\n\n    - Wigner 6j symbols are left invariant under any permutation of\n      the columns:\n\n      .. math::\n\n         \\\\begin{aligned}\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\n          &=\\\\operatorname{Wigner6j}(j_3,j_1,j_2,j_6,j_4,j_5) \\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_3,j_1,j_5,j_6,j_4) \\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_3,j_2,j_1,j_6,j_5,j_4) \\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_1,j_3,j_2,j_4,j_6,j_5) \\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_1,j_3,j_5,j_4,j_6)\n         \\\\end{aligned}\n\n    - They are invariant under the exchange of the upper and lower\n      arguments in each of any two columns, i.e.\n\n      .. math::\n\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\n          =\\\\operatorname{Wigner6j}(j_1,j_5,j_6,j_4,j_2,j_3)\n          =\\\\operatorname{Wigner6j}(j_4,j_2,j_6,j_1,j_5,j_3)\n          =\\\\operatorname{Wigner6j}(j_4,j_5,j_3,j_1,j_2,j_6)\n\n    - additional 6 symmetries [Regge59]_ giving rise to 144 symmetries\n      in total\n\n    - only non-zero if any triple of `j`'s fulfill a triangle relation\n\n    Algorithm\n    =========\n\n    This function uses the algorithm of [Edmonds74]_ to calculate the\n    value of the 6j symbol exactly. Note that the formula contains\n    alternating sums over large factorials and is therefore unsuitable\n    for finite precision arithmetic and only useful for a computer\n    algebra system [Rasch03]_.\n\n    \"\"\"\n    res = (-1) ** int(j_1 + j_2 + j_4 + j_5) * racah(j_1, j_2, j_5, j_4, j_3, j_6, prec)\n    return res",
        "mutated": [
            "def wigner_6j(j_1, j_2, j_3, j_4, j_5, j_6, prec=None):\n    if False:\n        i = 10\n    \"\\n    Calculate the Wigner 6j symbol `\\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_6 :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_6j\\n    >>> wigner_6j(3,3,3,3,3,3)\\n    -1/14\\n    >>> wigner_6j(5,5,5,5,5,5)\\n    1/52\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_6j(2.5,2.5,2.5,2.5,2.5,2.5)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_6j(0.5,0.5,1.1,0.5,0.5,1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Notes\\n    =====\\n\\n    The Wigner 6j symbol is related to the Racah symbol but exhibits\\n    more symmetries as detailed below.\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n        =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    The Wigner 6j symbol obeys the following symmetry rules:\\n\\n    - Wigner 6j symbols are left invariant under any permutation of\\n      the columns:\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          &=\\\\operatorname{Wigner6j}(j_3,j_1,j_2,j_6,j_4,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_3,j_1,j_5,j_6,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_3,j_2,j_1,j_6,j_5,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_1,j_3,j_2,j_4,j_6,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_1,j_3,j_5,j_4,j_6)\\n         \\\\end{aligned}\\n\\n    - They are invariant under the exchange of the upper and lower\\n      arguments in each of any two columns, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          =\\\\operatorname{Wigner6j}(j_1,j_5,j_6,j_4,j_2,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_2,j_6,j_1,j_5,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_5,j_3,j_1,j_2,j_6)\\n\\n    - additional 6 symmetries [Regge59]_ giving rise to 144 symmetries\\n      in total\\n\\n    - only non-zero if any triple of `j`'s fulfill a triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    \"\n    res = (-1) ** int(j_1 + j_2 + j_4 + j_5) * racah(j_1, j_2, j_5, j_4, j_3, j_6, prec)\n    return res",
            "def wigner_6j(j_1, j_2, j_3, j_4, j_5, j_6, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Calculate the Wigner 6j symbol `\\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_6 :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_6j\\n    >>> wigner_6j(3,3,3,3,3,3)\\n    -1/14\\n    >>> wigner_6j(5,5,5,5,5,5)\\n    1/52\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_6j(2.5,2.5,2.5,2.5,2.5,2.5)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_6j(0.5,0.5,1.1,0.5,0.5,1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Notes\\n    =====\\n\\n    The Wigner 6j symbol is related to the Racah symbol but exhibits\\n    more symmetries as detailed below.\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n        =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    The Wigner 6j symbol obeys the following symmetry rules:\\n\\n    - Wigner 6j symbols are left invariant under any permutation of\\n      the columns:\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          &=\\\\operatorname{Wigner6j}(j_3,j_1,j_2,j_6,j_4,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_3,j_1,j_5,j_6,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_3,j_2,j_1,j_6,j_5,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_1,j_3,j_2,j_4,j_6,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_1,j_3,j_5,j_4,j_6)\\n         \\\\end{aligned}\\n\\n    - They are invariant under the exchange of the upper and lower\\n      arguments in each of any two columns, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          =\\\\operatorname{Wigner6j}(j_1,j_5,j_6,j_4,j_2,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_2,j_6,j_1,j_5,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_5,j_3,j_1,j_2,j_6)\\n\\n    - additional 6 symmetries [Regge59]_ giving rise to 144 symmetries\\n      in total\\n\\n    - only non-zero if any triple of `j`'s fulfill a triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    \"\n    res = (-1) ** int(j_1 + j_2 + j_4 + j_5) * racah(j_1, j_2, j_5, j_4, j_3, j_6, prec)\n    return res",
            "def wigner_6j(j_1, j_2, j_3, j_4, j_5, j_6, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Calculate the Wigner 6j symbol `\\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_6 :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_6j\\n    >>> wigner_6j(3,3,3,3,3,3)\\n    -1/14\\n    >>> wigner_6j(5,5,5,5,5,5)\\n    1/52\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_6j(2.5,2.5,2.5,2.5,2.5,2.5)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_6j(0.5,0.5,1.1,0.5,0.5,1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Notes\\n    =====\\n\\n    The Wigner 6j symbol is related to the Racah symbol but exhibits\\n    more symmetries as detailed below.\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n        =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    The Wigner 6j symbol obeys the following symmetry rules:\\n\\n    - Wigner 6j symbols are left invariant under any permutation of\\n      the columns:\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          &=\\\\operatorname{Wigner6j}(j_3,j_1,j_2,j_6,j_4,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_3,j_1,j_5,j_6,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_3,j_2,j_1,j_6,j_5,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_1,j_3,j_2,j_4,j_6,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_1,j_3,j_5,j_4,j_6)\\n         \\\\end{aligned}\\n\\n    - They are invariant under the exchange of the upper and lower\\n      arguments in each of any two columns, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          =\\\\operatorname{Wigner6j}(j_1,j_5,j_6,j_4,j_2,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_2,j_6,j_1,j_5,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_5,j_3,j_1,j_2,j_6)\\n\\n    - additional 6 symmetries [Regge59]_ giving rise to 144 symmetries\\n      in total\\n\\n    - only non-zero if any triple of `j`'s fulfill a triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    \"\n    res = (-1) ** int(j_1 + j_2 + j_4 + j_5) * racah(j_1, j_2, j_5, j_4, j_3, j_6, prec)\n    return res",
            "def wigner_6j(j_1, j_2, j_3, j_4, j_5, j_6, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Calculate the Wigner 6j symbol `\\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_6 :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_6j\\n    >>> wigner_6j(3,3,3,3,3,3)\\n    -1/14\\n    >>> wigner_6j(5,5,5,5,5,5)\\n    1/52\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_6j(2.5,2.5,2.5,2.5,2.5,2.5)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_6j(0.5,0.5,1.1,0.5,0.5,1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Notes\\n    =====\\n\\n    The Wigner 6j symbol is related to the Racah symbol but exhibits\\n    more symmetries as detailed below.\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n        =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    The Wigner 6j symbol obeys the following symmetry rules:\\n\\n    - Wigner 6j symbols are left invariant under any permutation of\\n      the columns:\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          &=\\\\operatorname{Wigner6j}(j_3,j_1,j_2,j_6,j_4,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_3,j_1,j_5,j_6,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_3,j_2,j_1,j_6,j_5,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_1,j_3,j_2,j_4,j_6,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_1,j_3,j_5,j_4,j_6)\\n         \\\\end{aligned}\\n\\n    - They are invariant under the exchange of the upper and lower\\n      arguments in each of any two columns, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          =\\\\operatorname{Wigner6j}(j_1,j_5,j_6,j_4,j_2,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_2,j_6,j_1,j_5,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_5,j_3,j_1,j_2,j_6)\\n\\n    - additional 6 symmetries [Regge59]_ giving rise to 144 symmetries\\n      in total\\n\\n    - only non-zero if any triple of `j`'s fulfill a triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    \"\n    res = (-1) ** int(j_1 + j_2 + j_4 + j_5) * racah(j_1, j_2, j_5, j_4, j_3, j_6, prec)\n    return res",
            "def wigner_6j(j_1, j_2, j_3, j_4, j_5, j_6, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Calculate the Wigner 6j symbol `\\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_6 :\\n        Integer or half integer.\\n    prec :\\n        Precision, default: ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_6j\\n    >>> wigner_6j(3,3,3,3,3,3)\\n    -1/14\\n    >>> wigner_6j(5,5,5,5,5,5)\\n    1/52\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_6j(2.5,2.5,2.5,2.5,2.5,2.5)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_6j(0.5,0.5,1.1,0.5,0.5,1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Notes\\n    =====\\n\\n    The Wigner 6j symbol is related to the Racah symbol but exhibits\\n    more symmetries as detailed below.\\n\\n    .. math::\\n\\n       \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n        =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\\n\\n    The Wigner 6j symbol obeys the following symmetry rules:\\n\\n    - Wigner 6j symbols are left invariant under any permutation of\\n      the columns:\\n\\n      .. math::\\n\\n         \\\\begin{aligned}\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          &=\\\\operatorname{Wigner6j}(j_3,j_1,j_2,j_6,j_4,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_3,j_1,j_5,j_6,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_3,j_2,j_1,j_6,j_5,j_4) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_1,j_3,j_2,j_4,j_6,j_5) \\\\\\\\\\n          &=\\\\operatorname{Wigner6j}(j_2,j_1,j_3,j_5,j_4,j_6)\\n         \\\\end{aligned}\\n\\n    - They are invariant under the exchange of the upper and lower\\n      arguments in each of any two columns, i.e.\\n\\n      .. math::\\n\\n         \\\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\\n          =\\\\operatorname{Wigner6j}(j_1,j_5,j_6,j_4,j_2,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_2,j_6,j_1,j_5,j_3)\\n          =\\\\operatorname{Wigner6j}(j_4,j_5,j_3,j_1,j_2,j_6)\\n\\n    - additional 6 symmetries [Regge59]_ giving rise to 144 symmetries\\n      in total\\n\\n    - only non-zero if any triple of `j`'s fulfill a triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 6j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n\\n    \"\n    res = (-1) ** int(j_1 + j_2 + j_4 + j_5) * racah(j_1, j_2, j_5, j_4, j_3, j_6, prec)\n    return res"
        ]
    },
    {
        "func_name": "wigner_9j",
        "original": "def wigner_9j(j_1, j_2, j_3, j_4, j_5, j_6, j_7, j_8, j_9, prec=None):\n    \"\"\"\n    Calculate the Wigner 9j symbol\n    `\\\\operatorname{Wigner9j}(j_1,j_2,j_3,j_4,j_5,j_6,j_7,j_8,j_9)`.\n\n    Parameters\n    ==========\n\n    j_1, ..., j_9 :\n        Integer or half integer.\n    prec : precision, default\n        ``None``. Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number\n    (if ``prec=None``), or real number if a precision is given.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import wigner_9j\n    >>> wigner_9j(1,1,1, 1,1,1, 1,1,0, prec=64) # ==1/18\n    0.05555555...\n\n    >>> wigner_9j(1/2,1/2,0, 1/2,3/2,1, 0,1,1, prec=64) # ==1/6\n    0.1666666...\n\n    It is an error to have arguments that are not integer or half\n    integer values or do not fulfill the triangle relation::\n\n        sage: wigner_9j(0.5,0.5,0.5, 0.5,0.5,0.5, 0.5,0.5,0.5,prec=64)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\n        sage: wigner_9j(1,1,1, 0.5,1,1.5, 0.5,1,2.5,prec=64)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\n\n    Algorithm\n    =========\n\n    This function uses the algorithm of [Edmonds74]_ to calculate the\n    value of the 3j symbol exactly. Note that the formula contains\n    alternating sums over large factorials and is therefore unsuitable\n    for finite precision arithmetic and only useful for a computer\n    algebra system [Rasch03]_.\n    \"\"\"\n    imax = int(min(j_1 + j_9, j_2 + j_6, j_4 + j_8) * 2)\n    imin = imax % 2\n    sumres = 0\n    for kk in range(imin, int(imax) + 1, 2):\n        sumres = sumres + (kk + 1) * racah(j_1, j_2, j_9, j_6, j_3, kk / 2, prec) * racah(j_4, j_6, j_8, j_2, j_5, kk / 2, prec) * racah(j_1, j_4, j_9, j_8, j_7, kk / 2, prec)\n    return sumres",
        "mutated": [
            "def wigner_9j(j_1, j_2, j_3, j_4, j_5, j_6, j_7, j_8, j_9, prec=None):\n    if False:\n        i = 10\n    '\\n    Calculate the Wigner 9j symbol\\n    `\\\\operatorname{Wigner9j}(j_1,j_2,j_3,j_4,j_5,j_6,j_7,j_8,j_9)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_9 :\\n        Integer or half integer.\\n    prec : precision, default\\n        ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_9j\\n    >>> wigner_9j(1,1,1, 1,1,1, 1,1,0, prec=64) # ==1/18\\n    0.05555555...\\n\\n    >>> wigner_9j(1/2,1/2,0, 1/2,3/2,1, 0,1,1, prec=64) # ==1/6\\n    0.1666666...\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_9j(0.5,0.5,0.5, 0.5,0.5,0.5, 0.5,0.5,0.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_9j(1,1,1, 0.5,1,1.5, 0.5,1,2.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n    '\n    imax = int(min(j_1 + j_9, j_2 + j_6, j_4 + j_8) * 2)\n    imin = imax % 2\n    sumres = 0\n    for kk in range(imin, int(imax) + 1, 2):\n        sumres = sumres + (kk + 1) * racah(j_1, j_2, j_9, j_6, j_3, kk / 2, prec) * racah(j_4, j_6, j_8, j_2, j_5, kk / 2, prec) * racah(j_1, j_4, j_9, j_8, j_7, kk / 2, prec)\n    return sumres",
            "def wigner_9j(j_1, j_2, j_3, j_4, j_5, j_6, j_7, j_8, j_9, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the Wigner 9j symbol\\n    `\\\\operatorname{Wigner9j}(j_1,j_2,j_3,j_4,j_5,j_6,j_7,j_8,j_9)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_9 :\\n        Integer or half integer.\\n    prec : precision, default\\n        ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_9j\\n    >>> wigner_9j(1,1,1, 1,1,1, 1,1,0, prec=64) # ==1/18\\n    0.05555555...\\n\\n    >>> wigner_9j(1/2,1/2,0, 1/2,3/2,1, 0,1,1, prec=64) # ==1/6\\n    0.1666666...\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_9j(0.5,0.5,0.5, 0.5,0.5,0.5, 0.5,0.5,0.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_9j(1,1,1, 0.5,1,1.5, 0.5,1,2.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n    '\n    imax = int(min(j_1 + j_9, j_2 + j_6, j_4 + j_8) * 2)\n    imin = imax % 2\n    sumres = 0\n    for kk in range(imin, int(imax) + 1, 2):\n        sumres = sumres + (kk + 1) * racah(j_1, j_2, j_9, j_6, j_3, kk / 2, prec) * racah(j_4, j_6, j_8, j_2, j_5, kk / 2, prec) * racah(j_1, j_4, j_9, j_8, j_7, kk / 2, prec)\n    return sumres",
            "def wigner_9j(j_1, j_2, j_3, j_4, j_5, j_6, j_7, j_8, j_9, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the Wigner 9j symbol\\n    `\\\\operatorname{Wigner9j}(j_1,j_2,j_3,j_4,j_5,j_6,j_7,j_8,j_9)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_9 :\\n        Integer or half integer.\\n    prec : precision, default\\n        ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_9j\\n    >>> wigner_9j(1,1,1, 1,1,1, 1,1,0, prec=64) # ==1/18\\n    0.05555555...\\n\\n    >>> wigner_9j(1/2,1/2,0, 1/2,3/2,1, 0,1,1, prec=64) # ==1/6\\n    0.1666666...\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_9j(0.5,0.5,0.5, 0.5,0.5,0.5, 0.5,0.5,0.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_9j(1,1,1, 0.5,1,1.5, 0.5,1,2.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n    '\n    imax = int(min(j_1 + j_9, j_2 + j_6, j_4 + j_8) * 2)\n    imin = imax % 2\n    sumres = 0\n    for kk in range(imin, int(imax) + 1, 2):\n        sumres = sumres + (kk + 1) * racah(j_1, j_2, j_9, j_6, j_3, kk / 2, prec) * racah(j_4, j_6, j_8, j_2, j_5, kk / 2, prec) * racah(j_1, j_4, j_9, j_8, j_7, kk / 2, prec)\n    return sumres",
            "def wigner_9j(j_1, j_2, j_3, j_4, j_5, j_6, j_7, j_8, j_9, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the Wigner 9j symbol\\n    `\\\\operatorname{Wigner9j}(j_1,j_2,j_3,j_4,j_5,j_6,j_7,j_8,j_9)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_9 :\\n        Integer or half integer.\\n    prec : precision, default\\n        ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_9j\\n    >>> wigner_9j(1,1,1, 1,1,1, 1,1,0, prec=64) # ==1/18\\n    0.05555555...\\n\\n    >>> wigner_9j(1/2,1/2,0, 1/2,3/2,1, 0,1,1, prec=64) # ==1/6\\n    0.1666666...\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_9j(0.5,0.5,0.5, 0.5,0.5,0.5, 0.5,0.5,0.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_9j(1,1,1, 0.5,1,1.5, 0.5,1,2.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n    '\n    imax = int(min(j_1 + j_9, j_2 + j_6, j_4 + j_8) * 2)\n    imin = imax % 2\n    sumres = 0\n    for kk in range(imin, int(imax) + 1, 2):\n        sumres = sumres + (kk + 1) * racah(j_1, j_2, j_9, j_6, j_3, kk / 2, prec) * racah(j_4, j_6, j_8, j_2, j_5, kk / 2, prec) * racah(j_1, j_4, j_9, j_8, j_7, kk / 2, prec)\n    return sumres",
            "def wigner_9j(j_1, j_2, j_3, j_4, j_5, j_6, j_7, j_8, j_9, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the Wigner 9j symbol\\n    `\\\\operatorname{Wigner9j}(j_1,j_2,j_3,j_4,j_5,j_6,j_7,j_8,j_9)`.\\n\\n    Parameters\\n    ==========\\n\\n    j_1, ..., j_9 :\\n        Integer or half integer.\\n    prec : precision, default\\n        ``None``. Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import wigner_9j\\n    >>> wigner_9j(1,1,1, 1,1,1, 1,1,0, prec=64) # ==1/18\\n    0.05555555...\\n\\n    >>> wigner_9j(1/2,1/2,0, 1/2,3/2,1, 0,1,1, prec=64) # ==1/6\\n    0.1666666...\\n\\n    It is an error to have arguments that are not integer or half\\n    integer values or do not fulfill the triangle relation::\\n\\n        sage: wigner_9j(0.5,0.5,0.5, 0.5,0.5,0.5, 0.5,0.5,0.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n        sage: wigner_9j(1,1,1, 0.5,1,1.5, 0.5,1,2.5,prec=64)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\\n\\n    Algorithm\\n    =========\\n\\n    This function uses the algorithm of [Edmonds74]_ to calculate the\\n    value of the 3j symbol exactly. Note that the formula contains\\n    alternating sums over large factorials and is therefore unsuitable\\n    for finite precision arithmetic and only useful for a computer\\n    algebra system [Rasch03]_.\\n    '\n    imax = int(min(j_1 + j_9, j_2 + j_6, j_4 + j_8) * 2)\n    imin = imax % 2\n    sumres = 0\n    for kk in range(imin, int(imax) + 1, 2):\n        sumres = sumres + (kk + 1) * racah(j_1, j_2, j_9, j_6, j_3, kk / 2, prec) * racah(j_4, j_6, j_8, j_2, j_5, kk / 2, prec) * racah(j_1, j_4, j_9, j_8, j_7, kk / 2, prec)\n    return sumres"
        ]
    },
    {
        "func_name": "gaunt",
        "original": "def gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    \"\"\"\n    Calculate the Gaunt coefficient.\n\n    Explanation\n    ===========\n\n    The Gaunt coefficient is defined as the integral over three\n    spherical harmonics:\n\n    .. math::\n\n        \\\\begin{aligned}\n        \\\\operatorname{Gaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\n        &=\\\\int Y_{l_1,m_1}(\\\\Omega)\n         Y_{l_2,m_2}(\\\\Omega) Y_{l_3,m_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\n        &=\\\\sqrt{\\\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\\\pi}}\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,0,0,0)\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,m_1,m_2,m_3)\n        \\\\end{aligned}\n\n    Parameters\n    ==========\n\n    l_1, l_2, l_3, m_1, m_2, m_3 :\n        Integer.\n    prec - precision, default: ``None``.\n        Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number\n    (if ``prec=None``), or real number if a precision is given.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import gaunt\n    >>> gaunt(1,0,1,1,0,-1)\n    -1/(2*sqrt(pi))\n    >>> gaunt(1000,1000,1200,9,3,-12).n(64)\n    0.00689500421922113448...\n\n    It is an error to use non-integer values for `l` and `m`::\n\n        sage: gaunt(1.2,0,1.2,0,0,0)\n        Traceback (most recent call last):\n        ...\n        ValueError: l values must be integer\n        sage: gaunt(1,0,1,1.1,0,-1.1)\n        Traceback (most recent call last):\n        ...\n        ValueError: m values must be integer\n\n    Notes\n    =====\n\n    The Gaunt coefficient obeys the following symmetry rules:\n\n    - invariant under any permutation of the columns\n\n      .. math::\n        \\\\begin{aligned}\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\n          &=Y(l_3,l_1,l_2,m_3,m_1,m_2) \\\\\\\\\n          &=Y(l_2,l_3,l_1,m_2,m_3,m_1) \\\\\\\\\n          &=Y(l_3,l_2,l_1,m_3,m_2,m_1) \\\\\\\\\n          &=Y(l_1,l_3,l_2,m_1,m_3,m_2) \\\\\\\\\n          &=Y(l_2,l_1,l_3,m_2,m_1,m_3)\n        \\\\end{aligned}\n\n    - invariant under space inflection, i.e.\n\n      .. math::\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\n          =Y(l_1,l_2,l_3,-m_1,-m_2,-m_3)\n\n    - symmetric with respect to the 72 Regge symmetries as inherited\n      for the `3j` symbols [Regge58]_\n\n    - zero for `l_1`, `l_2`, `l_3` not fulfilling triangle relation\n\n    - zero for violating any one of the conditions: `l_1 \\\\ge |m_1|`,\n      `l_2 \\\\ge |m_2|`, `l_3 \\\\ge |m_3|`\n\n    - non-zero only for an even sum of the `l_i`, i.e.\n      `L = l_1 + l_2 + l_3 = 2n` for `n` in `\\\\mathbb{N}`\n\n    Algorithms\n    ==========\n\n    This function uses the algorithm of [Liberatodebrito82]_ to\n    calculate the value of the Gaunt coefficient exactly. Note that\n    the formula contains alternating sums over large factorials and is\n    therefore unsuitable for finite precision arithmetic and only\n    useful for a computer algebra system [Rasch03]_.\n\n    Authors\n    =======\n\n    Jens Rasch (2009-03-24): initial version for Sage.\n    \"\"\"\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if l_1 + l_2 - l_3 < 0:\n        return S.Zero\n    if l_1 - l_2 + l_3 < 0:\n        return S.Zero\n    if -l_1 + l_2 + l_3 < 0:\n        return S.Zero\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    if abs(m_1) > l_1 or abs(m_2) > l_2 or abs(m_3) > l_3:\n        return S.Zero\n    (bigL, remL) = divmod(l_1 + l_2 + l_3, 2)\n    if remL % 2:\n        return S.Zero\n    imin = max(-l_3 + l_1 + m_2, -l_3 + l_2 - m_1, 0)\n    imax = min(l_2 + m_2, l_1 - m_1, l_1 + l_2 - l_3)\n    _calc_factlist(max(l_1 + l_2 + l_3 + 1, imax + 1))\n    ressqrt = sqrt((2 * l_1 + 1) * (2 * l_2 + 1) * (2 * l_3 + 1) * _Factlist[l_1 - m_1] * _Factlist[l_1 + m_1] * _Factlist[l_2 - m_2] * _Factlist[l_2 + m_2] * _Factlist[l_3 - m_3] * _Factlist[l_3 + m_3] / (4 * pi))\n    prefac = Integer(_Factlist[bigL] * _Factlist[l_2 - l_1 + l_3] * _Factlist[l_1 - l_2 + l_3] * _Factlist[l_1 + l_2 - l_3]) / _Factlist[2 * bigL + 1] / (_Factlist[bigL - l_1] * _Factlist[bigL - l_2] * _Factlist[bigL - l_3])\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[ii + l_3 - l_1 - m_2] * _Factlist[l_2 + m_2 - ii] * _Factlist[l_1 - ii - m_1] * _Factlist[ii + l_3 - l_2 + m_1] * _Factlist[l_1 + l_2 - l_3 - ii]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * prefac * sumres * Integer((-1) ** (bigL + l_3 + m_1 - m_2))\n    if prec is not None:\n        res = res.n(prec)\n    return res",
        "mutated": [
            "def gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n    '\\n    Calculate the Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The Gaunt coefficient is defined as the integral over three\\n    spherical harmonics:\\n\\n    .. math::\\n\\n        \\\\begin{aligned}\\n        \\\\operatorname{Gaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Y_{l_1,m_1}(\\\\Omega)\\n         Y_{l_2,m_2}(\\\\Omega) Y_{l_3,m_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sqrt{\\\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\\\pi}}\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,0,0,0)\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import gaunt\\n    >>> gaunt(1,0,1,1,0,-1)\\n    -1/(2*sqrt(pi))\\n    >>> gaunt(1000,1000,1200,9,3,-12).n(64)\\n    0.00689500421922113448...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n\\n        sage: gaunt(1.2,0,1.2,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        sage: gaunt(1,0,1,1.1,0,-1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The Gaunt coefficient obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns\\n\\n      .. math::\\n        \\\\begin{aligned}\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          &=Y(l_3,l_1,l_2,m_3,m_1,m_2) \\\\\\\\\\n          &=Y(l_2,l_3,l_1,m_2,m_3,m_1) \\\\\\\\\\n          &=Y(l_3,l_2,l_1,m_3,m_2,m_1) \\\\\\\\\\n          &=Y(l_1,l_3,l_2,m_1,m_3,m_2) \\\\\\\\\\n          &=Y(l_2,l_1,l_3,m_2,m_1,m_3)\\n        \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          =Y(l_1,l_2,l_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 Regge symmetries as inherited\\n      for the `3j` symbols [Regge58]_\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfilling triangle relation\\n\\n    - zero for violating any one of the conditions: `l_1 \\\\ge |m_1|`,\\n      `l_2 \\\\ge |m_2|`, `l_3 \\\\ge |m_3|`\\n\\n    - non-zero only for an even sum of the `l_i`, i.e.\\n      `L = l_1 + l_2 + l_3 = 2n` for `n` in `\\\\mathbb{N}`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithm of [Liberatodebrito82]_ to\\n    calculate the value of the Gaunt coefficient exactly. Note that\\n    the formula contains alternating sums over large factorials and is\\n    therefore unsuitable for finite precision arithmetic and only\\n    useful for a computer algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    Jens Rasch (2009-03-24): initial version for Sage.\\n    '\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if l_1 + l_2 - l_3 < 0:\n        return S.Zero\n    if l_1 - l_2 + l_3 < 0:\n        return S.Zero\n    if -l_1 + l_2 + l_3 < 0:\n        return S.Zero\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    if abs(m_1) > l_1 or abs(m_2) > l_2 or abs(m_3) > l_3:\n        return S.Zero\n    (bigL, remL) = divmod(l_1 + l_2 + l_3, 2)\n    if remL % 2:\n        return S.Zero\n    imin = max(-l_3 + l_1 + m_2, -l_3 + l_2 - m_1, 0)\n    imax = min(l_2 + m_2, l_1 - m_1, l_1 + l_2 - l_3)\n    _calc_factlist(max(l_1 + l_2 + l_3 + 1, imax + 1))\n    ressqrt = sqrt((2 * l_1 + 1) * (2 * l_2 + 1) * (2 * l_3 + 1) * _Factlist[l_1 - m_1] * _Factlist[l_1 + m_1] * _Factlist[l_2 - m_2] * _Factlist[l_2 + m_2] * _Factlist[l_3 - m_3] * _Factlist[l_3 + m_3] / (4 * pi))\n    prefac = Integer(_Factlist[bigL] * _Factlist[l_2 - l_1 + l_3] * _Factlist[l_1 - l_2 + l_3] * _Factlist[l_1 + l_2 - l_3]) / _Factlist[2 * bigL + 1] / (_Factlist[bigL - l_1] * _Factlist[bigL - l_2] * _Factlist[bigL - l_3])\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[ii + l_3 - l_1 - m_2] * _Factlist[l_2 + m_2 - ii] * _Factlist[l_1 - ii - m_1] * _Factlist[ii + l_3 - l_2 + m_1] * _Factlist[l_1 + l_2 - l_3 - ii]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * prefac * sumres * Integer((-1) ** (bigL + l_3 + m_1 - m_2))\n    if prec is not None:\n        res = res.n(prec)\n    return res",
            "def gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate the Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The Gaunt coefficient is defined as the integral over three\\n    spherical harmonics:\\n\\n    .. math::\\n\\n        \\\\begin{aligned}\\n        \\\\operatorname{Gaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Y_{l_1,m_1}(\\\\Omega)\\n         Y_{l_2,m_2}(\\\\Omega) Y_{l_3,m_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sqrt{\\\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\\\pi}}\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,0,0,0)\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import gaunt\\n    >>> gaunt(1,0,1,1,0,-1)\\n    -1/(2*sqrt(pi))\\n    >>> gaunt(1000,1000,1200,9,3,-12).n(64)\\n    0.00689500421922113448...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n\\n        sage: gaunt(1.2,0,1.2,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        sage: gaunt(1,0,1,1.1,0,-1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The Gaunt coefficient obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns\\n\\n      .. math::\\n        \\\\begin{aligned}\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          &=Y(l_3,l_1,l_2,m_3,m_1,m_2) \\\\\\\\\\n          &=Y(l_2,l_3,l_1,m_2,m_3,m_1) \\\\\\\\\\n          &=Y(l_3,l_2,l_1,m_3,m_2,m_1) \\\\\\\\\\n          &=Y(l_1,l_3,l_2,m_1,m_3,m_2) \\\\\\\\\\n          &=Y(l_2,l_1,l_3,m_2,m_1,m_3)\\n        \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          =Y(l_1,l_2,l_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 Regge symmetries as inherited\\n      for the `3j` symbols [Regge58]_\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfilling triangle relation\\n\\n    - zero for violating any one of the conditions: `l_1 \\\\ge |m_1|`,\\n      `l_2 \\\\ge |m_2|`, `l_3 \\\\ge |m_3|`\\n\\n    - non-zero only for an even sum of the `l_i`, i.e.\\n      `L = l_1 + l_2 + l_3 = 2n` for `n` in `\\\\mathbb{N}`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithm of [Liberatodebrito82]_ to\\n    calculate the value of the Gaunt coefficient exactly. Note that\\n    the formula contains alternating sums over large factorials and is\\n    therefore unsuitable for finite precision arithmetic and only\\n    useful for a computer algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    Jens Rasch (2009-03-24): initial version for Sage.\\n    '\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if l_1 + l_2 - l_3 < 0:\n        return S.Zero\n    if l_1 - l_2 + l_3 < 0:\n        return S.Zero\n    if -l_1 + l_2 + l_3 < 0:\n        return S.Zero\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    if abs(m_1) > l_1 or abs(m_2) > l_2 or abs(m_3) > l_3:\n        return S.Zero\n    (bigL, remL) = divmod(l_1 + l_2 + l_3, 2)\n    if remL % 2:\n        return S.Zero\n    imin = max(-l_3 + l_1 + m_2, -l_3 + l_2 - m_1, 0)\n    imax = min(l_2 + m_2, l_1 - m_1, l_1 + l_2 - l_3)\n    _calc_factlist(max(l_1 + l_2 + l_3 + 1, imax + 1))\n    ressqrt = sqrt((2 * l_1 + 1) * (2 * l_2 + 1) * (2 * l_3 + 1) * _Factlist[l_1 - m_1] * _Factlist[l_1 + m_1] * _Factlist[l_2 - m_2] * _Factlist[l_2 + m_2] * _Factlist[l_3 - m_3] * _Factlist[l_3 + m_3] / (4 * pi))\n    prefac = Integer(_Factlist[bigL] * _Factlist[l_2 - l_1 + l_3] * _Factlist[l_1 - l_2 + l_3] * _Factlist[l_1 + l_2 - l_3]) / _Factlist[2 * bigL + 1] / (_Factlist[bigL - l_1] * _Factlist[bigL - l_2] * _Factlist[bigL - l_3])\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[ii + l_3 - l_1 - m_2] * _Factlist[l_2 + m_2 - ii] * _Factlist[l_1 - ii - m_1] * _Factlist[ii + l_3 - l_2 + m_1] * _Factlist[l_1 + l_2 - l_3 - ii]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * prefac * sumres * Integer((-1) ** (bigL + l_3 + m_1 - m_2))\n    if prec is not None:\n        res = res.n(prec)\n    return res",
            "def gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate the Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The Gaunt coefficient is defined as the integral over three\\n    spherical harmonics:\\n\\n    .. math::\\n\\n        \\\\begin{aligned}\\n        \\\\operatorname{Gaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Y_{l_1,m_1}(\\\\Omega)\\n         Y_{l_2,m_2}(\\\\Omega) Y_{l_3,m_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sqrt{\\\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\\\pi}}\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,0,0,0)\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import gaunt\\n    >>> gaunt(1,0,1,1,0,-1)\\n    -1/(2*sqrt(pi))\\n    >>> gaunt(1000,1000,1200,9,3,-12).n(64)\\n    0.00689500421922113448...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n\\n        sage: gaunt(1.2,0,1.2,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        sage: gaunt(1,0,1,1.1,0,-1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The Gaunt coefficient obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns\\n\\n      .. math::\\n        \\\\begin{aligned}\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          &=Y(l_3,l_1,l_2,m_3,m_1,m_2) \\\\\\\\\\n          &=Y(l_2,l_3,l_1,m_2,m_3,m_1) \\\\\\\\\\n          &=Y(l_3,l_2,l_1,m_3,m_2,m_1) \\\\\\\\\\n          &=Y(l_1,l_3,l_2,m_1,m_3,m_2) \\\\\\\\\\n          &=Y(l_2,l_1,l_3,m_2,m_1,m_3)\\n        \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          =Y(l_1,l_2,l_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 Regge symmetries as inherited\\n      for the `3j` symbols [Regge58]_\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfilling triangle relation\\n\\n    - zero for violating any one of the conditions: `l_1 \\\\ge |m_1|`,\\n      `l_2 \\\\ge |m_2|`, `l_3 \\\\ge |m_3|`\\n\\n    - non-zero only for an even sum of the `l_i`, i.e.\\n      `L = l_1 + l_2 + l_3 = 2n` for `n` in `\\\\mathbb{N}`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithm of [Liberatodebrito82]_ to\\n    calculate the value of the Gaunt coefficient exactly. Note that\\n    the formula contains alternating sums over large factorials and is\\n    therefore unsuitable for finite precision arithmetic and only\\n    useful for a computer algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    Jens Rasch (2009-03-24): initial version for Sage.\\n    '\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if l_1 + l_2 - l_3 < 0:\n        return S.Zero\n    if l_1 - l_2 + l_3 < 0:\n        return S.Zero\n    if -l_1 + l_2 + l_3 < 0:\n        return S.Zero\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    if abs(m_1) > l_1 or abs(m_2) > l_2 or abs(m_3) > l_3:\n        return S.Zero\n    (bigL, remL) = divmod(l_1 + l_2 + l_3, 2)\n    if remL % 2:\n        return S.Zero\n    imin = max(-l_3 + l_1 + m_2, -l_3 + l_2 - m_1, 0)\n    imax = min(l_2 + m_2, l_1 - m_1, l_1 + l_2 - l_3)\n    _calc_factlist(max(l_1 + l_2 + l_3 + 1, imax + 1))\n    ressqrt = sqrt((2 * l_1 + 1) * (2 * l_2 + 1) * (2 * l_3 + 1) * _Factlist[l_1 - m_1] * _Factlist[l_1 + m_1] * _Factlist[l_2 - m_2] * _Factlist[l_2 + m_2] * _Factlist[l_3 - m_3] * _Factlist[l_3 + m_3] / (4 * pi))\n    prefac = Integer(_Factlist[bigL] * _Factlist[l_2 - l_1 + l_3] * _Factlist[l_1 - l_2 + l_3] * _Factlist[l_1 + l_2 - l_3]) / _Factlist[2 * bigL + 1] / (_Factlist[bigL - l_1] * _Factlist[bigL - l_2] * _Factlist[bigL - l_3])\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[ii + l_3 - l_1 - m_2] * _Factlist[l_2 + m_2 - ii] * _Factlist[l_1 - ii - m_1] * _Factlist[ii + l_3 - l_2 + m_1] * _Factlist[l_1 + l_2 - l_3 - ii]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * prefac * sumres * Integer((-1) ** (bigL + l_3 + m_1 - m_2))\n    if prec is not None:\n        res = res.n(prec)\n    return res",
            "def gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate the Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The Gaunt coefficient is defined as the integral over three\\n    spherical harmonics:\\n\\n    .. math::\\n\\n        \\\\begin{aligned}\\n        \\\\operatorname{Gaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Y_{l_1,m_1}(\\\\Omega)\\n         Y_{l_2,m_2}(\\\\Omega) Y_{l_3,m_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sqrt{\\\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\\\pi}}\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,0,0,0)\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import gaunt\\n    >>> gaunt(1,0,1,1,0,-1)\\n    -1/(2*sqrt(pi))\\n    >>> gaunt(1000,1000,1200,9,3,-12).n(64)\\n    0.00689500421922113448...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n\\n        sage: gaunt(1.2,0,1.2,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        sage: gaunt(1,0,1,1.1,0,-1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The Gaunt coefficient obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns\\n\\n      .. math::\\n        \\\\begin{aligned}\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          &=Y(l_3,l_1,l_2,m_3,m_1,m_2) \\\\\\\\\\n          &=Y(l_2,l_3,l_1,m_2,m_3,m_1) \\\\\\\\\\n          &=Y(l_3,l_2,l_1,m_3,m_2,m_1) \\\\\\\\\\n          &=Y(l_1,l_3,l_2,m_1,m_3,m_2) \\\\\\\\\\n          &=Y(l_2,l_1,l_3,m_2,m_1,m_3)\\n        \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          =Y(l_1,l_2,l_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 Regge symmetries as inherited\\n      for the `3j` symbols [Regge58]_\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfilling triangle relation\\n\\n    - zero for violating any one of the conditions: `l_1 \\\\ge |m_1|`,\\n      `l_2 \\\\ge |m_2|`, `l_3 \\\\ge |m_3|`\\n\\n    - non-zero only for an even sum of the `l_i`, i.e.\\n      `L = l_1 + l_2 + l_3 = 2n` for `n` in `\\\\mathbb{N}`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithm of [Liberatodebrito82]_ to\\n    calculate the value of the Gaunt coefficient exactly. Note that\\n    the formula contains alternating sums over large factorials and is\\n    therefore unsuitable for finite precision arithmetic and only\\n    useful for a computer algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    Jens Rasch (2009-03-24): initial version for Sage.\\n    '\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if l_1 + l_2 - l_3 < 0:\n        return S.Zero\n    if l_1 - l_2 + l_3 < 0:\n        return S.Zero\n    if -l_1 + l_2 + l_3 < 0:\n        return S.Zero\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    if abs(m_1) > l_1 or abs(m_2) > l_2 or abs(m_3) > l_3:\n        return S.Zero\n    (bigL, remL) = divmod(l_1 + l_2 + l_3, 2)\n    if remL % 2:\n        return S.Zero\n    imin = max(-l_3 + l_1 + m_2, -l_3 + l_2 - m_1, 0)\n    imax = min(l_2 + m_2, l_1 - m_1, l_1 + l_2 - l_3)\n    _calc_factlist(max(l_1 + l_2 + l_3 + 1, imax + 1))\n    ressqrt = sqrt((2 * l_1 + 1) * (2 * l_2 + 1) * (2 * l_3 + 1) * _Factlist[l_1 - m_1] * _Factlist[l_1 + m_1] * _Factlist[l_2 - m_2] * _Factlist[l_2 + m_2] * _Factlist[l_3 - m_3] * _Factlist[l_3 + m_3] / (4 * pi))\n    prefac = Integer(_Factlist[bigL] * _Factlist[l_2 - l_1 + l_3] * _Factlist[l_1 - l_2 + l_3] * _Factlist[l_1 + l_2 - l_3]) / _Factlist[2 * bigL + 1] / (_Factlist[bigL - l_1] * _Factlist[bigL - l_2] * _Factlist[bigL - l_3])\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[ii + l_3 - l_1 - m_2] * _Factlist[l_2 + m_2 - ii] * _Factlist[l_1 - ii - m_1] * _Factlist[ii + l_3 - l_2 + m_1] * _Factlist[l_1 + l_2 - l_3 - ii]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * prefac * sumres * Integer((-1) ** (bigL + l_3 + m_1 - m_2))\n    if prec is not None:\n        res = res.n(prec)\n    return res",
            "def gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate the Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The Gaunt coefficient is defined as the integral over three\\n    spherical harmonics:\\n\\n    .. math::\\n\\n        \\\\begin{aligned}\\n        \\\\operatorname{Gaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Y_{l_1,m_1}(\\\\Omega)\\n         Y_{l_2,m_2}(\\\\Omega) Y_{l_3,m_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sqrt{\\\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\\\pi}}\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,0,0,0)\\n         \\\\operatorname{Wigner3j}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number\\n    (if ``prec=None``), or real number if a precision is given.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import gaunt\\n    >>> gaunt(1,0,1,1,0,-1)\\n    -1/(2*sqrt(pi))\\n    >>> gaunt(1000,1000,1200,9,3,-12).n(64)\\n    0.00689500421922113448...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n\\n        sage: gaunt(1.2,0,1.2,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        sage: gaunt(1,0,1,1.1,0,-1.1)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The Gaunt coefficient obeys the following symmetry rules:\\n\\n    - invariant under any permutation of the columns\\n\\n      .. math::\\n        \\\\begin{aligned}\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          &=Y(l_3,l_1,l_2,m_3,m_1,m_2) \\\\\\\\\\n          &=Y(l_2,l_3,l_1,m_2,m_3,m_1) \\\\\\\\\\n          &=Y(l_3,l_2,l_1,m_3,m_2,m_1) \\\\\\\\\\n          &=Y(l_1,l_3,l_2,m_1,m_3,m_2) \\\\\\\\\\n          &=Y(l_2,l_1,l_3,m_2,m_1,m_3)\\n        \\\\end{aligned}\\n\\n    - invariant under space inflection, i.e.\\n\\n      .. math::\\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\\n          =Y(l_1,l_2,l_3,-m_1,-m_2,-m_3)\\n\\n    - symmetric with respect to the 72 Regge symmetries as inherited\\n      for the `3j` symbols [Regge58]_\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfilling triangle relation\\n\\n    - zero for violating any one of the conditions: `l_1 \\\\ge |m_1|`,\\n      `l_2 \\\\ge |m_2|`, `l_3 \\\\ge |m_3|`\\n\\n    - non-zero only for an even sum of the `l_i`, i.e.\\n      `L = l_1 + l_2 + l_3 = 2n` for `n` in `\\\\mathbb{N}`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithm of [Liberatodebrito82]_ to\\n    calculate the value of the Gaunt coefficient exactly. Note that\\n    the formula contains alternating sums over large factorials and is\\n    therefore unsuitable for finite precision arithmetic and only\\n    useful for a computer algebra system [Rasch03]_.\\n\\n    Authors\\n    =======\\n\\n    Jens Rasch (2009-03-24): initial version for Sage.\\n    '\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if l_1 + l_2 - l_3 < 0:\n        return S.Zero\n    if l_1 - l_2 + l_3 < 0:\n        return S.Zero\n    if -l_1 + l_2 + l_3 < 0:\n        return S.Zero\n    if m_1 + m_2 + m_3 != 0:\n        return S.Zero\n    if abs(m_1) > l_1 or abs(m_2) > l_2 or abs(m_3) > l_3:\n        return S.Zero\n    (bigL, remL) = divmod(l_1 + l_2 + l_3, 2)\n    if remL % 2:\n        return S.Zero\n    imin = max(-l_3 + l_1 + m_2, -l_3 + l_2 - m_1, 0)\n    imax = min(l_2 + m_2, l_1 - m_1, l_1 + l_2 - l_3)\n    _calc_factlist(max(l_1 + l_2 + l_3 + 1, imax + 1))\n    ressqrt = sqrt((2 * l_1 + 1) * (2 * l_2 + 1) * (2 * l_3 + 1) * _Factlist[l_1 - m_1] * _Factlist[l_1 + m_1] * _Factlist[l_2 - m_2] * _Factlist[l_2 + m_2] * _Factlist[l_3 - m_3] * _Factlist[l_3 + m_3] / (4 * pi))\n    prefac = Integer(_Factlist[bigL] * _Factlist[l_2 - l_1 + l_3] * _Factlist[l_1 - l_2 + l_3] * _Factlist[l_1 + l_2 - l_3]) / _Factlist[2 * bigL + 1] / (_Factlist[bigL - l_1] * _Factlist[bigL - l_2] * _Factlist[bigL - l_3])\n    sumres = 0\n    for ii in range(int(imin), int(imax) + 1):\n        den = _Factlist[ii] * _Factlist[ii + l_3 - l_1 - m_2] * _Factlist[l_2 + m_2 - ii] * _Factlist[l_1 - ii - m_1] * _Factlist[ii + l_3 - l_2 + m_1] * _Factlist[l_1 + l_2 - l_3 - ii]\n        sumres = sumres + Integer((-1) ** ii) / den\n    res = ressqrt * prefac * sumres * Integer((-1) ** (bigL + l_3 + m_1 - m_2))\n    if prec is not None:\n        res = res.n(prec)\n    return res"
        ]
    },
    {
        "func_name": "real_gaunt",
        "original": "def real_gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    \"\"\"\n    Calculate the real Gaunt coefficient.\n\n    Explanation\n    ===========\n\n    The real Gaunt coefficient is defined as the integral over three\n    real spherical harmonics:\n\n    .. math::\n        \\\\begin{aligned}\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\n        \\\\end{aligned}\n\n    Alternatively, it can be defined in terms of the standard Gaunt\n    coefficient by relating the real spherical harmonics to the standard\n    spherical harmonics via a unitary transformation `U`, i.e.\n    `Z^{m}_{l}(\\\\Omega)=\\\\sum_{m'}U^{m}_{m'}Y^{m'}_{l}(\\\\Omega)` [Homeier96]_.\n    The real Gaunt coefficient is then defined as\n\n    .. math::\n        \\\\begin{aligned}\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\n        &=\\\\sum_{m'_1 m'_2 m'_3} U^{m_1}_{m'_1}U^{m_2}_{m'_2}U^{m_3}_{m'_3}\n         \\\\operatorname{Gaunt}(l_1,l_2,l_3,m'_1,m'_2,m'_3)\n        \\\\end{aligned}\n\n    The unitary matrix `U` has components\n\n    .. math::\n        \\\\begin{aligned}\n        U^m_{m'} = \\\\delta_{|m||m'|}*(\\\\delta_{m'0}\\\\delta_{m0} + \\\\frac{1}{\\\\sqrt{2}}\\\\big[\\\\Theta(m)\n        \\\\big(\\\\delta_{m'm}+(-1)^{m'}\\\\delta_{m'-m}\\\\big)+i\\\\Theta(-m)\\\\big((-1)^{-m}\n        \\\\delta_{m'-m}-\\\\delta_{m'm}*(-1)^{m'-m}\\\\big)\\\\big])\n        \\\\end{aligned}\n\n    where `\\\\delta_{ij}` is the Kronecker delta symbol and `\\\\Theta` is a step\n    function defined as\n\n    .. math::\n        \\\\begin{aligned}\n        \\\\Theta(x) = \\\\begin{cases} 1 \\\\,\\\\text{for}\\\\, x > 0 \\\\\\\\ 0 \\\\,\\\\text{for}\\\\, x \\\\leq 0 \\\\end{cases}\n        \\\\end{aligned}\n\n    Parameters\n    ==========\n\n    l_1, l_2, l_3, m_1, m_2, m_3 :\n        Integer.\n\n    prec - precision, default: ``None``.\n        Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import real_gaunt\n    >>> real_gaunt(2,2,4,-1,-1,0)\n    -2/(7*sqrt(pi))\n    >>> real_gaunt(10,10,20,-9,-9,0).n(64)\n    -0.00002480019791932209313156167...\n\n    It is an error to use non-integer values for `l` and `m`::\n        real_gaunt(2.8,0.5,1.3,0,0,0)\n        Traceback (most recent call last):\n        ...\n        ValueError: l values must be integer\n        real_gaunt(2,2,4,0.7,1,-3.4)\n        Traceback (most recent call last):\n        ...\n        ValueError: m values must be integer\n\n    Notes\n    =====\n\n    The real Gaunt coefficient inherits from the standard Gaunt coefficient,\n    the invariance under any permutation of the pairs `(l_i, m_i)` and the\n    requirement that the sum of the `l_i` be even to yield a non-zero value.\n    It also obeys the following symmetry rules:\n\n    - zero for `l_1`, `l_2`, `l_3` not fulfiling the condition\n      `l_1 \\\\in \\\\{l_{\\\\text{max}}, l_{\\\\text{max}}-2, \\\\ldots, l_{\\\\text{min}}\\\\}`,\n      where `l_{\\\\text{max}} = l_2+l_3`,\n\n      .. math::\n          \\\\begin{aligned}\n          l_{\\\\text{min}} = \\\\begin{cases} \\\\kappa(l_2, l_3, m_2, m_3) & \\\\text{if}\\\\,\n          \\\\kappa(l_2, l_3, m_2, m_3) + l_{\\\\text{max}}\\\\, \\\\text{is even} \\\\\\\\\n          \\\\kappa(l_2, l_3, m_2, m_3)+1 & \\\\text{if}\\\\, \\\\kappa(l_2, l_3, m_2, m_3) +\n          l_{\\\\text{max}}\\\\, \\\\text{is odd}\\\\end{cases}\n          \\\\end{aligned}\n\n      and `\\\\kappa(l_2, l_3, m_2, m_3) = \\\\max{\\\\big(|l_2-l_3|, \\\\min{\\\\big(|m_2+m_3|,\n      |m_2-m_3|\\\\big)}\\\\big)}`\n\n    - zero for an odd number of negative `m_i`\n\n    Algorithms\n    ==========\n\n    This function uses the algorithms of [Homeier96]_ and [Rasch03]_ to\n    calculate the value of the real Gaunt coefficient exactly. Note that\n    the formula used in [Rasch03]_ contains alternating sums over large\n    factorials and is therefore unsuitable for finite precision arithmetic\n    and only useful for a computer algebra system [Rasch03]_. However, this\n    function can in principle use any algorithm that computes the Gaunt\n    coefficient, so it is suitable for finite precision arithmetic in so far\n    as the algorithm which computes the Gaunt coefficient is.\n    \"\"\"\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if sum((1 for i in (m_1, m_2, m_3) if i < 0)) % 2:\n        return S.Zero\n    if (l_1 + l_2 + l_3) % 2:\n        return S.Zero\n    lmax = l_2 + l_3\n    lmin = max(abs(l_2 - l_3), min(abs(m_2 + m_3), abs(m_2 - m_3)))\n    if (lmin + lmax) % 2:\n        lmin += 1\n    if lmin not in range(lmax, lmin - 2, -2):\n        return S.Zero\n    kron_del = lambda i, j: 1 if i == j else 0\n    s = lambda e: -1 if e % 2 else 1\n    A = lambda a, b: -kron_del(a, b) * s(a - b) + kron_del(a, -b) * s(b) if b < 0 else 0\n    B = lambda a, b: kron_del(a, b) + kron_del(a, -b) * s(a) if b > 0 else 0\n    C = lambda a, b: kron_del(abs(a), abs(b)) * (kron_del(a, 0) * kron_del(b, 0) + (B(a, b) + I * A(a, b)) / sqrt(2))\n    ugnt = 0\n    for i in range(-l_1, l_1 + 1):\n        U1 = C(i, m_1)\n        for j in range(-l_2, l_2 + 1):\n            U2 = C(j, m_2)\n            U3 = C(-i - j, m_3)\n            ugnt = ugnt + re(U1 * U2 * U3) * gaunt(l_1, l_2, l_3, i, j, -i - j)\n    if prec is not None:\n        ugnt = ugnt.n(prec)\n    return ugnt",
        "mutated": [
            "def real_gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n    \"\\n    Calculate the real Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The real Gaunt coefficient is defined as the integral over three\\n    real spherical harmonics:\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        \\\\end{aligned}\\n\\n    Alternatively, it can be defined in terms of the standard Gaunt\\n    coefficient by relating the real spherical harmonics to the standard\\n    spherical harmonics via a unitary transformation `U`, i.e.\\n    `Z^{m}_{l}(\\\\Omega)=\\\\sum_{m'}U^{m}_{m'}Y^{m'}_{l}(\\\\Omega)` [Homeier96]_.\\n    The real Gaunt coefficient is then defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sum_{m'_1 m'_2 m'_3} U^{m_1}_{m'_1}U^{m_2}_{m'_2}U^{m_3}_{m'_3}\\n         \\\\operatorname{Gaunt}(l_1,l_2,l_3,m'_1,m'_2,m'_3)\\n        \\\\end{aligned}\\n\\n    The unitary matrix `U` has components\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        U^m_{m'} = \\\\delta_{|m||m'|}*(\\\\delta_{m'0}\\\\delta_{m0} + \\\\frac{1}{\\\\sqrt{2}}\\\\big[\\\\Theta(m)\\n        \\\\big(\\\\delta_{m'm}+(-1)^{m'}\\\\delta_{m'-m}\\\\big)+i\\\\Theta(-m)\\\\big((-1)^{-m}\\n        \\\\delta_{m'-m}-\\\\delta_{m'm}*(-1)^{m'-m}\\\\big)\\\\big])\\n        \\\\end{aligned}\\n\\n    where `\\\\delta_{ij}` is the Kronecker delta symbol and `\\\\Theta` is a step\\n    function defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\Theta(x) = \\\\begin{cases} 1 \\\\,\\\\text{for}\\\\, x > 0 \\\\\\\\ 0 \\\\,\\\\text{for}\\\\, x \\\\leq 0 \\\\end{cases}\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import real_gaunt\\n    >>> real_gaunt(2,2,4,-1,-1,0)\\n    -2/(7*sqrt(pi))\\n    >>> real_gaunt(10,10,20,-9,-9,0).n(64)\\n    -0.00002480019791932209313156167...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n        real_gaunt(2.8,0.5,1.3,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        real_gaunt(2,2,4,0.7,1,-3.4)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The real Gaunt coefficient inherits from the standard Gaunt coefficient,\\n    the invariance under any permutation of the pairs `(l_i, m_i)` and the\\n    requirement that the sum of the `l_i` be even to yield a non-zero value.\\n    It also obeys the following symmetry rules:\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfiling the condition\\n      `l_1 \\\\in \\\\{l_{\\\\text{max}}, l_{\\\\text{max}}-2, \\\\ldots, l_{\\\\text{min}}\\\\}`,\\n      where `l_{\\\\text{max}} = l_2+l_3`,\\n\\n      .. math::\\n          \\\\begin{aligned}\\n          l_{\\\\text{min}} = \\\\begin{cases} \\\\kappa(l_2, l_3, m_2, m_3) & \\\\text{if}\\\\,\\n          \\\\kappa(l_2, l_3, m_2, m_3) + l_{\\\\text{max}}\\\\, \\\\text{is even} \\\\\\\\\\n          \\\\kappa(l_2, l_3, m_2, m_3)+1 & \\\\text{if}\\\\, \\\\kappa(l_2, l_3, m_2, m_3) +\\n          l_{\\\\text{max}}\\\\, \\\\text{is odd}\\\\end{cases}\\n          \\\\end{aligned}\\n\\n      and `\\\\kappa(l_2, l_3, m_2, m_3) = \\\\max{\\\\big(|l_2-l_3|, \\\\min{\\\\big(|m_2+m_3|,\\n      |m_2-m_3|\\\\big)}\\\\big)}`\\n\\n    - zero for an odd number of negative `m_i`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithms of [Homeier96]_ and [Rasch03]_ to\\n    calculate the value of the real Gaunt coefficient exactly. Note that\\n    the formula used in [Rasch03]_ contains alternating sums over large\\n    factorials and is therefore unsuitable for finite precision arithmetic\\n    and only useful for a computer algebra system [Rasch03]_. However, this\\n    function can in principle use any algorithm that computes the Gaunt\\n    coefficient, so it is suitable for finite precision arithmetic in so far\\n    as the algorithm which computes the Gaunt coefficient is.\\n    \"\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if sum((1 for i in (m_1, m_2, m_3) if i < 0)) % 2:\n        return S.Zero\n    if (l_1 + l_2 + l_3) % 2:\n        return S.Zero\n    lmax = l_2 + l_3\n    lmin = max(abs(l_2 - l_3), min(abs(m_2 + m_3), abs(m_2 - m_3)))\n    if (lmin + lmax) % 2:\n        lmin += 1\n    if lmin not in range(lmax, lmin - 2, -2):\n        return S.Zero\n    kron_del = lambda i, j: 1 if i == j else 0\n    s = lambda e: -1 if e % 2 else 1\n    A = lambda a, b: -kron_del(a, b) * s(a - b) + kron_del(a, -b) * s(b) if b < 0 else 0\n    B = lambda a, b: kron_del(a, b) + kron_del(a, -b) * s(a) if b > 0 else 0\n    C = lambda a, b: kron_del(abs(a), abs(b)) * (kron_del(a, 0) * kron_del(b, 0) + (B(a, b) + I * A(a, b)) / sqrt(2))\n    ugnt = 0\n    for i in range(-l_1, l_1 + 1):\n        U1 = C(i, m_1)\n        for j in range(-l_2, l_2 + 1):\n            U2 = C(j, m_2)\n            U3 = C(-i - j, m_3)\n            ugnt = ugnt + re(U1 * U2 * U3) * gaunt(l_1, l_2, l_3, i, j, -i - j)\n    if prec is not None:\n        ugnt = ugnt.n(prec)\n    return ugnt",
            "def real_gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Calculate the real Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The real Gaunt coefficient is defined as the integral over three\\n    real spherical harmonics:\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        \\\\end{aligned}\\n\\n    Alternatively, it can be defined in terms of the standard Gaunt\\n    coefficient by relating the real spherical harmonics to the standard\\n    spherical harmonics via a unitary transformation `U`, i.e.\\n    `Z^{m}_{l}(\\\\Omega)=\\\\sum_{m'}U^{m}_{m'}Y^{m'}_{l}(\\\\Omega)` [Homeier96]_.\\n    The real Gaunt coefficient is then defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sum_{m'_1 m'_2 m'_3} U^{m_1}_{m'_1}U^{m_2}_{m'_2}U^{m_3}_{m'_3}\\n         \\\\operatorname{Gaunt}(l_1,l_2,l_3,m'_1,m'_2,m'_3)\\n        \\\\end{aligned}\\n\\n    The unitary matrix `U` has components\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        U^m_{m'} = \\\\delta_{|m||m'|}*(\\\\delta_{m'0}\\\\delta_{m0} + \\\\frac{1}{\\\\sqrt{2}}\\\\big[\\\\Theta(m)\\n        \\\\big(\\\\delta_{m'm}+(-1)^{m'}\\\\delta_{m'-m}\\\\big)+i\\\\Theta(-m)\\\\big((-1)^{-m}\\n        \\\\delta_{m'-m}-\\\\delta_{m'm}*(-1)^{m'-m}\\\\big)\\\\big])\\n        \\\\end{aligned}\\n\\n    where `\\\\delta_{ij}` is the Kronecker delta symbol and `\\\\Theta` is a step\\n    function defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\Theta(x) = \\\\begin{cases} 1 \\\\,\\\\text{for}\\\\, x > 0 \\\\\\\\ 0 \\\\,\\\\text{for}\\\\, x \\\\leq 0 \\\\end{cases}\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import real_gaunt\\n    >>> real_gaunt(2,2,4,-1,-1,0)\\n    -2/(7*sqrt(pi))\\n    >>> real_gaunt(10,10,20,-9,-9,0).n(64)\\n    -0.00002480019791932209313156167...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n        real_gaunt(2.8,0.5,1.3,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        real_gaunt(2,2,4,0.7,1,-3.4)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The real Gaunt coefficient inherits from the standard Gaunt coefficient,\\n    the invariance under any permutation of the pairs `(l_i, m_i)` and the\\n    requirement that the sum of the `l_i` be even to yield a non-zero value.\\n    It also obeys the following symmetry rules:\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfiling the condition\\n      `l_1 \\\\in \\\\{l_{\\\\text{max}}, l_{\\\\text{max}}-2, \\\\ldots, l_{\\\\text{min}}\\\\}`,\\n      where `l_{\\\\text{max}} = l_2+l_3`,\\n\\n      .. math::\\n          \\\\begin{aligned}\\n          l_{\\\\text{min}} = \\\\begin{cases} \\\\kappa(l_2, l_3, m_2, m_3) & \\\\text{if}\\\\,\\n          \\\\kappa(l_2, l_3, m_2, m_3) + l_{\\\\text{max}}\\\\, \\\\text{is even} \\\\\\\\\\n          \\\\kappa(l_2, l_3, m_2, m_3)+1 & \\\\text{if}\\\\, \\\\kappa(l_2, l_3, m_2, m_3) +\\n          l_{\\\\text{max}}\\\\, \\\\text{is odd}\\\\end{cases}\\n          \\\\end{aligned}\\n\\n      and `\\\\kappa(l_2, l_3, m_2, m_3) = \\\\max{\\\\big(|l_2-l_3|, \\\\min{\\\\big(|m_2+m_3|,\\n      |m_2-m_3|\\\\big)}\\\\big)}`\\n\\n    - zero for an odd number of negative `m_i`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithms of [Homeier96]_ and [Rasch03]_ to\\n    calculate the value of the real Gaunt coefficient exactly. Note that\\n    the formula used in [Rasch03]_ contains alternating sums over large\\n    factorials and is therefore unsuitable for finite precision arithmetic\\n    and only useful for a computer algebra system [Rasch03]_. However, this\\n    function can in principle use any algorithm that computes the Gaunt\\n    coefficient, so it is suitable for finite precision arithmetic in so far\\n    as the algorithm which computes the Gaunt coefficient is.\\n    \"\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if sum((1 for i in (m_1, m_2, m_3) if i < 0)) % 2:\n        return S.Zero\n    if (l_1 + l_2 + l_3) % 2:\n        return S.Zero\n    lmax = l_2 + l_3\n    lmin = max(abs(l_2 - l_3), min(abs(m_2 + m_3), abs(m_2 - m_3)))\n    if (lmin + lmax) % 2:\n        lmin += 1\n    if lmin not in range(lmax, lmin - 2, -2):\n        return S.Zero\n    kron_del = lambda i, j: 1 if i == j else 0\n    s = lambda e: -1 if e % 2 else 1\n    A = lambda a, b: -kron_del(a, b) * s(a - b) + kron_del(a, -b) * s(b) if b < 0 else 0\n    B = lambda a, b: kron_del(a, b) + kron_del(a, -b) * s(a) if b > 0 else 0\n    C = lambda a, b: kron_del(abs(a), abs(b)) * (kron_del(a, 0) * kron_del(b, 0) + (B(a, b) + I * A(a, b)) / sqrt(2))\n    ugnt = 0\n    for i in range(-l_1, l_1 + 1):\n        U1 = C(i, m_1)\n        for j in range(-l_2, l_2 + 1):\n            U2 = C(j, m_2)\n            U3 = C(-i - j, m_3)\n            ugnt = ugnt + re(U1 * U2 * U3) * gaunt(l_1, l_2, l_3, i, j, -i - j)\n    if prec is not None:\n        ugnt = ugnt.n(prec)\n    return ugnt",
            "def real_gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Calculate the real Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The real Gaunt coefficient is defined as the integral over three\\n    real spherical harmonics:\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        \\\\end{aligned}\\n\\n    Alternatively, it can be defined in terms of the standard Gaunt\\n    coefficient by relating the real spherical harmonics to the standard\\n    spherical harmonics via a unitary transformation `U`, i.e.\\n    `Z^{m}_{l}(\\\\Omega)=\\\\sum_{m'}U^{m}_{m'}Y^{m'}_{l}(\\\\Omega)` [Homeier96]_.\\n    The real Gaunt coefficient is then defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sum_{m'_1 m'_2 m'_3} U^{m_1}_{m'_1}U^{m_2}_{m'_2}U^{m_3}_{m'_3}\\n         \\\\operatorname{Gaunt}(l_1,l_2,l_3,m'_1,m'_2,m'_3)\\n        \\\\end{aligned}\\n\\n    The unitary matrix `U` has components\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        U^m_{m'} = \\\\delta_{|m||m'|}*(\\\\delta_{m'0}\\\\delta_{m0} + \\\\frac{1}{\\\\sqrt{2}}\\\\big[\\\\Theta(m)\\n        \\\\big(\\\\delta_{m'm}+(-1)^{m'}\\\\delta_{m'-m}\\\\big)+i\\\\Theta(-m)\\\\big((-1)^{-m}\\n        \\\\delta_{m'-m}-\\\\delta_{m'm}*(-1)^{m'-m}\\\\big)\\\\big])\\n        \\\\end{aligned}\\n\\n    where `\\\\delta_{ij}` is the Kronecker delta symbol and `\\\\Theta` is a step\\n    function defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\Theta(x) = \\\\begin{cases} 1 \\\\,\\\\text{for}\\\\, x > 0 \\\\\\\\ 0 \\\\,\\\\text{for}\\\\, x \\\\leq 0 \\\\end{cases}\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import real_gaunt\\n    >>> real_gaunt(2,2,4,-1,-1,0)\\n    -2/(7*sqrt(pi))\\n    >>> real_gaunt(10,10,20,-9,-9,0).n(64)\\n    -0.00002480019791932209313156167...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n        real_gaunt(2.8,0.5,1.3,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        real_gaunt(2,2,4,0.7,1,-3.4)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The real Gaunt coefficient inherits from the standard Gaunt coefficient,\\n    the invariance under any permutation of the pairs `(l_i, m_i)` and the\\n    requirement that the sum of the `l_i` be even to yield a non-zero value.\\n    It also obeys the following symmetry rules:\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfiling the condition\\n      `l_1 \\\\in \\\\{l_{\\\\text{max}}, l_{\\\\text{max}}-2, \\\\ldots, l_{\\\\text{min}}\\\\}`,\\n      where `l_{\\\\text{max}} = l_2+l_3`,\\n\\n      .. math::\\n          \\\\begin{aligned}\\n          l_{\\\\text{min}} = \\\\begin{cases} \\\\kappa(l_2, l_3, m_2, m_3) & \\\\text{if}\\\\,\\n          \\\\kappa(l_2, l_3, m_2, m_3) + l_{\\\\text{max}}\\\\, \\\\text{is even} \\\\\\\\\\n          \\\\kappa(l_2, l_3, m_2, m_3)+1 & \\\\text{if}\\\\, \\\\kappa(l_2, l_3, m_2, m_3) +\\n          l_{\\\\text{max}}\\\\, \\\\text{is odd}\\\\end{cases}\\n          \\\\end{aligned}\\n\\n      and `\\\\kappa(l_2, l_3, m_2, m_3) = \\\\max{\\\\big(|l_2-l_3|, \\\\min{\\\\big(|m_2+m_3|,\\n      |m_2-m_3|\\\\big)}\\\\big)}`\\n\\n    - zero for an odd number of negative `m_i`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithms of [Homeier96]_ and [Rasch03]_ to\\n    calculate the value of the real Gaunt coefficient exactly. Note that\\n    the formula used in [Rasch03]_ contains alternating sums over large\\n    factorials and is therefore unsuitable for finite precision arithmetic\\n    and only useful for a computer algebra system [Rasch03]_. However, this\\n    function can in principle use any algorithm that computes the Gaunt\\n    coefficient, so it is suitable for finite precision arithmetic in so far\\n    as the algorithm which computes the Gaunt coefficient is.\\n    \"\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if sum((1 for i in (m_1, m_2, m_3) if i < 0)) % 2:\n        return S.Zero\n    if (l_1 + l_2 + l_3) % 2:\n        return S.Zero\n    lmax = l_2 + l_3\n    lmin = max(abs(l_2 - l_3), min(abs(m_2 + m_3), abs(m_2 - m_3)))\n    if (lmin + lmax) % 2:\n        lmin += 1\n    if lmin not in range(lmax, lmin - 2, -2):\n        return S.Zero\n    kron_del = lambda i, j: 1 if i == j else 0\n    s = lambda e: -1 if e % 2 else 1\n    A = lambda a, b: -kron_del(a, b) * s(a - b) + kron_del(a, -b) * s(b) if b < 0 else 0\n    B = lambda a, b: kron_del(a, b) + kron_del(a, -b) * s(a) if b > 0 else 0\n    C = lambda a, b: kron_del(abs(a), abs(b)) * (kron_del(a, 0) * kron_del(b, 0) + (B(a, b) + I * A(a, b)) / sqrt(2))\n    ugnt = 0\n    for i in range(-l_1, l_1 + 1):\n        U1 = C(i, m_1)\n        for j in range(-l_2, l_2 + 1):\n            U2 = C(j, m_2)\n            U3 = C(-i - j, m_3)\n            ugnt = ugnt + re(U1 * U2 * U3) * gaunt(l_1, l_2, l_3, i, j, -i - j)\n    if prec is not None:\n        ugnt = ugnt.n(prec)\n    return ugnt",
            "def real_gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Calculate the real Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The real Gaunt coefficient is defined as the integral over three\\n    real spherical harmonics:\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        \\\\end{aligned}\\n\\n    Alternatively, it can be defined in terms of the standard Gaunt\\n    coefficient by relating the real spherical harmonics to the standard\\n    spherical harmonics via a unitary transformation `U`, i.e.\\n    `Z^{m}_{l}(\\\\Omega)=\\\\sum_{m'}U^{m}_{m'}Y^{m'}_{l}(\\\\Omega)` [Homeier96]_.\\n    The real Gaunt coefficient is then defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sum_{m'_1 m'_2 m'_3} U^{m_1}_{m'_1}U^{m_2}_{m'_2}U^{m_3}_{m'_3}\\n         \\\\operatorname{Gaunt}(l_1,l_2,l_3,m'_1,m'_2,m'_3)\\n        \\\\end{aligned}\\n\\n    The unitary matrix `U` has components\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        U^m_{m'} = \\\\delta_{|m||m'|}*(\\\\delta_{m'0}\\\\delta_{m0} + \\\\frac{1}{\\\\sqrt{2}}\\\\big[\\\\Theta(m)\\n        \\\\big(\\\\delta_{m'm}+(-1)^{m'}\\\\delta_{m'-m}\\\\big)+i\\\\Theta(-m)\\\\big((-1)^{-m}\\n        \\\\delta_{m'-m}-\\\\delta_{m'm}*(-1)^{m'-m}\\\\big)\\\\big])\\n        \\\\end{aligned}\\n\\n    where `\\\\delta_{ij}` is the Kronecker delta symbol and `\\\\Theta` is a step\\n    function defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\Theta(x) = \\\\begin{cases} 1 \\\\,\\\\text{for}\\\\, x > 0 \\\\\\\\ 0 \\\\,\\\\text{for}\\\\, x \\\\leq 0 \\\\end{cases}\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import real_gaunt\\n    >>> real_gaunt(2,2,4,-1,-1,0)\\n    -2/(7*sqrt(pi))\\n    >>> real_gaunt(10,10,20,-9,-9,0).n(64)\\n    -0.00002480019791932209313156167...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n        real_gaunt(2.8,0.5,1.3,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        real_gaunt(2,2,4,0.7,1,-3.4)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The real Gaunt coefficient inherits from the standard Gaunt coefficient,\\n    the invariance under any permutation of the pairs `(l_i, m_i)` and the\\n    requirement that the sum of the `l_i` be even to yield a non-zero value.\\n    It also obeys the following symmetry rules:\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfiling the condition\\n      `l_1 \\\\in \\\\{l_{\\\\text{max}}, l_{\\\\text{max}}-2, \\\\ldots, l_{\\\\text{min}}\\\\}`,\\n      where `l_{\\\\text{max}} = l_2+l_3`,\\n\\n      .. math::\\n          \\\\begin{aligned}\\n          l_{\\\\text{min}} = \\\\begin{cases} \\\\kappa(l_2, l_3, m_2, m_3) & \\\\text{if}\\\\,\\n          \\\\kappa(l_2, l_3, m_2, m_3) + l_{\\\\text{max}}\\\\, \\\\text{is even} \\\\\\\\\\n          \\\\kappa(l_2, l_3, m_2, m_3)+1 & \\\\text{if}\\\\, \\\\kappa(l_2, l_3, m_2, m_3) +\\n          l_{\\\\text{max}}\\\\, \\\\text{is odd}\\\\end{cases}\\n          \\\\end{aligned}\\n\\n      and `\\\\kappa(l_2, l_3, m_2, m_3) = \\\\max{\\\\big(|l_2-l_3|, \\\\min{\\\\big(|m_2+m_3|,\\n      |m_2-m_3|\\\\big)}\\\\big)}`\\n\\n    - zero for an odd number of negative `m_i`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithms of [Homeier96]_ and [Rasch03]_ to\\n    calculate the value of the real Gaunt coefficient exactly. Note that\\n    the formula used in [Rasch03]_ contains alternating sums over large\\n    factorials and is therefore unsuitable for finite precision arithmetic\\n    and only useful for a computer algebra system [Rasch03]_. However, this\\n    function can in principle use any algorithm that computes the Gaunt\\n    coefficient, so it is suitable for finite precision arithmetic in so far\\n    as the algorithm which computes the Gaunt coefficient is.\\n    \"\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if sum((1 for i in (m_1, m_2, m_3) if i < 0)) % 2:\n        return S.Zero\n    if (l_1 + l_2 + l_3) % 2:\n        return S.Zero\n    lmax = l_2 + l_3\n    lmin = max(abs(l_2 - l_3), min(abs(m_2 + m_3), abs(m_2 - m_3)))\n    if (lmin + lmax) % 2:\n        lmin += 1\n    if lmin not in range(lmax, lmin - 2, -2):\n        return S.Zero\n    kron_del = lambda i, j: 1 if i == j else 0\n    s = lambda e: -1 if e % 2 else 1\n    A = lambda a, b: -kron_del(a, b) * s(a - b) + kron_del(a, -b) * s(b) if b < 0 else 0\n    B = lambda a, b: kron_del(a, b) + kron_del(a, -b) * s(a) if b > 0 else 0\n    C = lambda a, b: kron_del(abs(a), abs(b)) * (kron_del(a, 0) * kron_del(b, 0) + (B(a, b) + I * A(a, b)) / sqrt(2))\n    ugnt = 0\n    for i in range(-l_1, l_1 + 1):\n        U1 = C(i, m_1)\n        for j in range(-l_2, l_2 + 1):\n            U2 = C(j, m_2)\n            U3 = C(-i - j, m_3)\n            ugnt = ugnt + re(U1 * U2 * U3) * gaunt(l_1, l_2, l_3, i, j, -i - j)\n    if prec is not None:\n        ugnt = ugnt.n(prec)\n    return ugnt",
            "def real_gaunt(l_1, l_2, l_3, m_1, m_2, m_3, prec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Calculate the real Gaunt coefficient.\\n\\n    Explanation\\n    ===========\\n\\n    The real Gaunt coefficient is defined as the integral over three\\n    real spherical harmonics:\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        \\\\end{aligned}\\n\\n    Alternatively, it can be defined in terms of the standard Gaunt\\n    coefficient by relating the real spherical harmonics to the standard\\n    spherical harmonics via a unitary transformation `U`, i.e.\\n    `Z^{m}_{l}(\\\\Omega)=\\\\sum_{m'}U^{m}_{m'}Y^{m'}_{l}(\\\\Omega)` [Homeier96]_.\\n    The real Gaunt coefficient is then defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\\n        &=\\\\int Z^{m_1}_{l_1}(\\\\Omega)\\n         Z^{m_2}_{l_2}(\\\\Omega) Z^{m_3}_{l_3}(\\\\Omega) \\\\,d\\\\Omega \\\\\\\\\\n        &=\\\\sum_{m'_1 m'_2 m'_3} U^{m_1}_{m'_1}U^{m_2}_{m'_2}U^{m_3}_{m'_3}\\n         \\\\operatorname{Gaunt}(l_1,l_2,l_3,m'_1,m'_2,m'_3)\\n        \\\\end{aligned}\\n\\n    The unitary matrix `U` has components\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        U^m_{m'} = \\\\delta_{|m||m'|}*(\\\\delta_{m'0}\\\\delta_{m0} + \\\\frac{1}{\\\\sqrt{2}}\\\\big[\\\\Theta(m)\\n        \\\\big(\\\\delta_{m'm}+(-1)^{m'}\\\\delta_{m'-m}\\\\big)+i\\\\Theta(-m)\\\\big((-1)^{-m}\\n        \\\\delta_{m'-m}-\\\\delta_{m'm}*(-1)^{m'-m}\\\\big)\\\\big])\\n        \\\\end{aligned}\\n\\n    where `\\\\delta_{ij}` is the Kronecker delta symbol and `\\\\Theta` is a step\\n    function defined as\\n\\n    .. math::\\n        \\\\begin{aligned}\\n        \\\\Theta(x) = \\\\begin{cases} 1 \\\\,\\\\text{for}\\\\, x > 0 \\\\\\\\ 0 \\\\,\\\\text{for}\\\\, x \\\\leq 0 \\\\end{cases}\\n        \\\\end{aligned}\\n\\n    Parameters\\n    ==========\\n\\n    l_1, l_2, l_3, m_1, m_2, m_3 :\\n        Integer.\\n\\n    prec - precision, default: ``None``.\\n        Providing a precision can\\n        drastically speed up the calculation.\\n\\n    Returns\\n    =======\\n\\n    Rational number times the square root of a rational number.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.physics.wigner import real_gaunt\\n    >>> real_gaunt(2,2,4,-1,-1,0)\\n    -2/(7*sqrt(pi))\\n    >>> real_gaunt(10,10,20,-9,-9,0).n(64)\\n    -0.00002480019791932209313156167...\\n\\n    It is an error to use non-integer values for `l` and `m`::\\n        real_gaunt(2.8,0.5,1.3,0,0,0)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: l values must be integer\\n        real_gaunt(2,2,4,0.7,1,-3.4)\\n        Traceback (most recent call last):\\n        ...\\n        ValueError: m values must be integer\\n\\n    Notes\\n    =====\\n\\n    The real Gaunt coefficient inherits from the standard Gaunt coefficient,\\n    the invariance under any permutation of the pairs `(l_i, m_i)` and the\\n    requirement that the sum of the `l_i` be even to yield a non-zero value.\\n    It also obeys the following symmetry rules:\\n\\n    - zero for `l_1`, `l_2`, `l_3` not fulfiling the condition\\n      `l_1 \\\\in \\\\{l_{\\\\text{max}}, l_{\\\\text{max}}-2, \\\\ldots, l_{\\\\text{min}}\\\\}`,\\n      where `l_{\\\\text{max}} = l_2+l_3`,\\n\\n      .. math::\\n          \\\\begin{aligned}\\n          l_{\\\\text{min}} = \\\\begin{cases} \\\\kappa(l_2, l_3, m_2, m_3) & \\\\text{if}\\\\,\\n          \\\\kappa(l_2, l_3, m_2, m_3) + l_{\\\\text{max}}\\\\, \\\\text{is even} \\\\\\\\\\n          \\\\kappa(l_2, l_3, m_2, m_3)+1 & \\\\text{if}\\\\, \\\\kappa(l_2, l_3, m_2, m_3) +\\n          l_{\\\\text{max}}\\\\, \\\\text{is odd}\\\\end{cases}\\n          \\\\end{aligned}\\n\\n      and `\\\\kappa(l_2, l_3, m_2, m_3) = \\\\max{\\\\big(|l_2-l_3|, \\\\min{\\\\big(|m_2+m_3|,\\n      |m_2-m_3|\\\\big)}\\\\big)}`\\n\\n    - zero for an odd number of negative `m_i`\\n\\n    Algorithms\\n    ==========\\n\\n    This function uses the algorithms of [Homeier96]_ and [Rasch03]_ to\\n    calculate the value of the real Gaunt coefficient exactly. Note that\\n    the formula used in [Rasch03]_ contains alternating sums over large\\n    factorials and is therefore unsuitable for finite precision arithmetic\\n    and only useful for a computer algebra system [Rasch03]_. However, this\\n    function can in principle use any algorithm that computes the Gaunt\\n    coefficient, so it is suitable for finite precision arithmetic in so far\\n    as the algorithm which computes the Gaunt coefficient is.\\n    \"\n    (l_1, l_2, l_3, m_1, m_2, m_3) = [as_int(i) for i in (l_1, l_2, l_3, m_1, m_2, m_3)]\n    if sum((1 for i in (m_1, m_2, m_3) if i < 0)) % 2:\n        return S.Zero\n    if (l_1 + l_2 + l_3) % 2:\n        return S.Zero\n    lmax = l_2 + l_3\n    lmin = max(abs(l_2 - l_3), min(abs(m_2 + m_3), abs(m_2 - m_3)))\n    if (lmin + lmax) % 2:\n        lmin += 1\n    if lmin not in range(lmax, lmin - 2, -2):\n        return S.Zero\n    kron_del = lambda i, j: 1 if i == j else 0\n    s = lambda e: -1 if e % 2 else 1\n    A = lambda a, b: -kron_del(a, b) * s(a - b) + kron_del(a, -b) * s(b) if b < 0 else 0\n    B = lambda a, b: kron_del(a, b) + kron_del(a, -b) * s(a) if b > 0 else 0\n    C = lambda a, b: kron_del(abs(a), abs(b)) * (kron_del(a, 0) * kron_del(b, 0) + (B(a, b) + I * A(a, b)) / sqrt(2))\n    ugnt = 0\n    for i in range(-l_1, l_1 + 1):\n        U1 = C(i, m_1)\n        for j in range(-l_2, l_2 + 1):\n            U2 = C(j, m_2)\n            U3 = C(-i - j, m_3)\n            ugnt = ugnt + re(U1 * U2 * U3) * gaunt(l_1, l_2, l_3, i, j, -i - j)\n    if prec is not None:\n        ugnt = ugnt.n(prec)\n    return ugnt"
        ]
    },
    {
        "func_name": "doit",
        "original": "def doit(self, **hints):\n    if all((obj.is_number for obj in self.args)):\n        return wigner_3j(*self.args)\n    else:\n        return self",
        "mutated": [
            "def doit(self, **hints):\n    if False:\n        i = 10\n    if all((obj.is_number for obj in self.args)):\n        return wigner_3j(*self.args)\n    else:\n        return self",
            "def doit(self, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if all((obj.is_number for obj in self.args)):\n        return wigner_3j(*self.args)\n    else:\n        return self",
            "def doit(self, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if all((obj.is_number for obj in self.args)):\n        return wigner_3j(*self.args)\n    else:\n        return self",
            "def doit(self, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if all((obj.is_number for obj in self.args)):\n        return wigner_3j(*self.args)\n    else:\n        return self",
            "def doit(self, **hints):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if all((obj.is_number for obj in self.args)):\n        return wigner_3j(*self.args)\n    else:\n        return self"
        ]
    },
    {
        "func_name": "alpha",
        "original": "def alpha(l, m, j, p, k):\n    return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)",
        "mutated": [
            "def alpha(l, m, j, p, k):\n    if False:\n        i = 10\n    return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)",
            "def alpha(l, m, j, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)",
            "def alpha(l, m, j, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)",
            "def alpha(l, m, j, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)",
            "def alpha(l, m, j, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)"
        ]
    },
    {
        "func_name": "dot_rot_grad_Ynm",
        "original": "def dot_rot_grad_Ynm(j, p, l, m, theta, phi):\n    \"\"\"\n    Returns dot product of rotational gradients of spherical harmonics.\n\n    Explanation\n    ===========\n\n    This function returns the right hand side of the following expression:\n\n    .. math ::\n        \\\\vec{R}Y{_j^{p}} \\\\cdot \\\\vec{R}Y{_l^{m}} = (-1)^{m+p}\n        \\\\sum\\\\limits_{k=|l-j|}^{l+j}Y{_k^{m+p}}  * \\\\alpha_{l,m,j,p,k} *\n        \\\\frac{1}{2} (k^2-j^2-l^2+k-j-l)\n\n\n    Arguments\n    =========\n\n    j, p, l, m .... indices in spherical harmonics (expressions or integers)\n    theta, phi .... angle arguments in spherical harmonics\n\n    Example\n    =======\n\n    >>> from sympy import symbols\n    >>> from sympy.physics.wigner import dot_rot_grad_Ynm\n    >>> theta, phi = symbols(\"theta phi\")\n    >>> dot_rot_grad_Ynm(3, 2, 2, 0, theta, phi).doit()\n    3*sqrt(55)*Ynm(5, 2, theta, phi)/(11*sqrt(pi))\n\n    \"\"\"\n    j = sympify(j)\n    p = sympify(p)\n    l = sympify(l)\n    m = sympify(m)\n    theta = sympify(theta)\n    phi = sympify(phi)\n    k = Dummy('k')\n\n    def alpha(l, m, j, p, k):\n        return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)\n    return S.NegativeOne ** (m + p) * Sum(Ynm(k, m + p, theta, phi) * alpha(l, m, j, p, k) / 2 * (k ** 2 - j ** 2 - l ** 2 + k - j - l), (k, abs(l - j), l + j))",
        "mutated": [
            "def dot_rot_grad_Ynm(j, p, l, m, theta, phi):\n    if False:\n        i = 10\n    '\\n    Returns dot product of rotational gradients of spherical harmonics.\\n\\n    Explanation\\n    ===========\\n\\n    This function returns the right hand side of the following expression:\\n\\n    .. math ::\\n        \\\\vec{R}Y{_j^{p}} \\\\cdot \\\\vec{R}Y{_l^{m}} = (-1)^{m+p}\\n        \\\\sum\\\\limits_{k=|l-j|}^{l+j}Y{_k^{m+p}}  * \\\\alpha_{l,m,j,p,k} *\\n        \\\\frac{1}{2} (k^2-j^2-l^2+k-j-l)\\n\\n\\n    Arguments\\n    =========\\n\\n    j, p, l, m .... indices in spherical harmonics (expressions or integers)\\n    theta, phi .... angle arguments in spherical harmonics\\n\\n    Example\\n    =======\\n\\n    >>> from sympy import symbols\\n    >>> from sympy.physics.wigner import dot_rot_grad_Ynm\\n    >>> theta, phi = symbols(\"theta phi\")\\n    >>> dot_rot_grad_Ynm(3, 2, 2, 0, theta, phi).doit()\\n    3*sqrt(55)*Ynm(5, 2, theta, phi)/(11*sqrt(pi))\\n\\n    '\n    j = sympify(j)\n    p = sympify(p)\n    l = sympify(l)\n    m = sympify(m)\n    theta = sympify(theta)\n    phi = sympify(phi)\n    k = Dummy('k')\n\n    def alpha(l, m, j, p, k):\n        return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)\n    return S.NegativeOne ** (m + p) * Sum(Ynm(k, m + p, theta, phi) * alpha(l, m, j, p, k) / 2 * (k ** 2 - j ** 2 - l ** 2 + k - j - l), (k, abs(l - j), l + j))",
            "def dot_rot_grad_Ynm(j, p, l, m, theta, phi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns dot product of rotational gradients of spherical harmonics.\\n\\n    Explanation\\n    ===========\\n\\n    This function returns the right hand side of the following expression:\\n\\n    .. math ::\\n        \\\\vec{R}Y{_j^{p}} \\\\cdot \\\\vec{R}Y{_l^{m}} = (-1)^{m+p}\\n        \\\\sum\\\\limits_{k=|l-j|}^{l+j}Y{_k^{m+p}}  * \\\\alpha_{l,m,j,p,k} *\\n        \\\\frac{1}{2} (k^2-j^2-l^2+k-j-l)\\n\\n\\n    Arguments\\n    =========\\n\\n    j, p, l, m .... indices in spherical harmonics (expressions or integers)\\n    theta, phi .... angle arguments in spherical harmonics\\n\\n    Example\\n    =======\\n\\n    >>> from sympy import symbols\\n    >>> from sympy.physics.wigner import dot_rot_grad_Ynm\\n    >>> theta, phi = symbols(\"theta phi\")\\n    >>> dot_rot_grad_Ynm(3, 2, 2, 0, theta, phi).doit()\\n    3*sqrt(55)*Ynm(5, 2, theta, phi)/(11*sqrt(pi))\\n\\n    '\n    j = sympify(j)\n    p = sympify(p)\n    l = sympify(l)\n    m = sympify(m)\n    theta = sympify(theta)\n    phi = sympify(phi)\n    k = Dummy('k')\n\n    def alpha(l, m, j, p, k):\n        return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)\n    return S.NegativeOne ** (m + p) * Sum(Ynm(k, m + p, theta, phi) * alpha(l, m, j, p, k) / 2 * (k ** 2 - j ** 2 - l ** 2 + k - j - l), (k, abs(l - j), l + j))",
            "def dot_rot_grad_Ynm(j, p, l, m, theta, phi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns dot product of rotational gradients of spherical harmonics.\\n\\n    Explanation\\n    ===========\\n\\n    This function returns the right hand side of the following expression:\\n\\n    .. math ::\\n        \\\\vec{R}Y{_j^{p}} \\\\cdot \\\\vec{R}Y{_l^{m}} = (-1)^{m+p}\\n        \\\\sum\\\\limits_{k=|l-j|}^{l+j}Y{_k^{m+p}}  * \\\\alpha_{l,m,j,p,k} *\\n        \\\\frac{1}{2} (k^2-j^2-l^2+k-j-l)\\n\\n\\n    Arguments\\n    =========\\n\\n    j, p, l, m .... indices in spherical harmonics (expressions or integers)\\n    theta, phi .... angle arguments in spherical harmonics\\n\\n    Example\\n    =======\\n\\n    >>> from sympy import symbols\\n    >>> from sympy.physics.wigner import dot_rot_grad_Ynm\\n    >>> theta, phi = symbols(\"theta phi\")\\n    >>> dot_rot_grad_Ynm(3, 2, 2, 0, theta, phi).doit()\\n    3*sqrt(55)*Ynm(5, 2, theta, phi)/(11*sqrt(pi))\\n\\n    '\n    j = sympify(j)\n    p = sympify(p)\n    l = sympify(l)\n    m = sympify(m)\n    theta = sympify(theta)\n    phi = sympify(phi)\n    k = Dummy('k')\n\n    def alpha(l, m, j, p, k):\n        return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)\n    return S.NegativeOne ** (m + p) * Sum(Ynm(k, m + p, theta, phi) * alpha(l, m, j, p, k) / 2 * (k ** 2 - j ** 2 - l ** 2 + k - j - l), (k, abs(l - j), l + j))",
            "def dot_rot_grad_Ynm(j, p, l, m, theta, phi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns dot product of rotational gradients of spherical harmonics.\\n\\n    Explanation\\n    ===========\\n\\n    This function returns the right hand side of the following expression:\\n\\n    .. math ::\\n        \\\\vec{R}Y{_j^{p}} \\\\cdot \\\\vec{R}Y{_l^{m}} = (-1)^{m+p}\\n        \\\\sum\\\\limits_{k=|l-j|}^{l+j}Y{_k^{m+p}}  * \\\\alpha_{l,m,j,p,k} *\\n        \\\\frac{1}{2} (k^2-j^2-l^2+k-j-l)\\n\\n\\n    Arguments\\n    =========\\n\\n    j, p, l, m .... indices in spherical harmonics (expressions or integers)\\n    theta, phi .... angle arguments in spherical harmonics\\n\\n    Example\\n    =======\\n\\n    >>> from sympy import symbols\\n    >>> from sympy.physics.wigner import dot_rot_grad_Ynm\\n    >>> theta, phi = symbols(\"theta phi\")\\n    >>> dot_rot_grad_Ynm(3, 2, 2, 0, theta, phi).doit()\\n    3*sqrt(55)*Ynm(5, 2, theta, phi)/(11*sqrt(pi))\\n\\n    '\n    j = sympify(j)\n    p = sympify(p)\n    l = sympify(l)\n    m = sympify(m)\n    theta = sympify(theta)\n    phi = sympify(phi)\n    k = Dummy('k')\n\n    def alpha(l, m, j, p, k):\n        return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)\n    return S.NegativeOne ** (m + p) * Sum(Ynm(k, m + p, theta, phi) * alpha(l, m, j, p, k) / 2 * (k ** 2 - j ** 2 - l ** 2 + k - j - l), (k, abs(l - j), l + j))",
            "def dot_rot_grad_Ynm(j, p, l, m, theta, phi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns dot product of rotational gradients of spherical harmonics.\\n\\n    Explanation\\n    ===========\\n\\n    This function returns the right hand side of the following expression:\\n\\n    .. math ::\\n        \\\\vec{R}Y{_j^{p}} \\\\cdot \\\\vec{R}Y{_l^{m}} = (-1)^{m+p}\\n        \\\\sum\\\\limits_{k=|l-j|}^{l+j}Y{_k^{m+p}}  * \\\\alpha_{l,m,j,p,k} *\\n        \\\\frac{1}{2} (k^2-j^2-l^2+k-j-l)\\n\\n\\n    Arguments\\n    =========\\n\\n    j, p, l, m .... indices in spherical harmonics (expressions or integers)\\n    theta, phi .... angle arguments in spherical harmonics\\n\\n    Example\\n    =======\\n\\n    >>> from sympy import symbols\\n    >>> from sympy.physics.wigner import dot_rot_grad_Ynm\\n    >>> theta, phi = symbols(\"theta phi\")\\n    >>> dot_rot_grad_Ynm(3, 2, 2, 0, theta, phi).doit()\\n    3*sqrt(55)*Ynm(5, 2, theta, phi)/(11*sqrt(pi))\\n\\n    '\n    j = sympify(j)\n    p = sympify(p)\n    l = sympify(l)\n    m = sympify(m)\n    theta = sympify(theta)\n    phi = sympify(phi)\n    k = Dummy('k')\n\n    def alpha(l, m, j, p, k):\n        return sqrt((2 * l + 1) * (2 * j + 1) * (2 * k + 1) / (4 * pi)) * Wigner3j(j, l, k, S.Zero, S.Zero, S.Zero) * Wigner3j(j, l, k, p, m, -m - p)\n    return S.NegativeOne ** (m + p) * Sum(Ynm(k, m + p, theta, phi) * alpha(l, m, j, p, k) / 2 * (k ** 2 - j ** 2 - l ** 2 + k - j - l), (k, abs(l - j), l + j))"
        ]
    },
    {
        "func_name": "wigner_d_small",
        "original": "def wigner_d_small(J, beta):\n    \"\"\"Return the small Wigner d matrix for angular momentum J.\n\n    Explanation\n    ===========\n\n    J : An integer, half-integer, or SymPy symbol for the total angular\n        momentum of the angular momentum space being rotated.\n    beta : A real number representing the Euler angle of rotation about\n        the so-called line of nodes. See [Edmonds74]_.\n\n    Returns\n    =======\n\n    A matrix representing the corresponding Euler angle rotation( in the basis\n    of eigenvectors of `J_z`).\n\n    .. math ::\n        \\\\mathcal{d}_{\\\\beta} = \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\n\n    The components are calculated using the general form [Edmonds74]_,\n    equation 4.1.15.\n\n    Examples\n    ========\n\n    >>> from sympy import Integer, symbols, pi, pprint\n    >>> from sympy.physics.wigner import wigner_d_small\n    >>> half = 1/Integer(2)\n    >>> beta = symbols(\"beta\", real=True)\n    >>> pprint(wigner_d_small(half, beta), use_unicode=True)\n    \u23a1   \u239b\u03b2\u239e      \u239b\u03b2\u239e\u23a4\n    \u23a2cos\u239c\u2500\u239f   sin\u239c\u2500\u239f\u23a5\n    \u23a2   \u239d2\u23a0      \u239d2\u23a0\u23a5\n    \u23a2               \u23a5\n    \u23a2    \u239b\u03b2\u239e     \u239b\u03b2\u239e\u23a5\n    \u23a2-sin\u239c\u2500\u239f  cos\u239c\u2500\u239f\u23a5\n    \u23a3    \u239d2\u23a0     \u239d2\u23a0\u23a6\n\n    >>> pprint(wigner_d_small(2*half, beta), use_unicode=True)\n    \u23a1        2\u239b\u03b2\u239e              \u239b\u03b2\u239e    \u239b\u03b2\u239e           2\u239b\u03b2\u239e     \u23a4\n    \u23a2     cos \u239c\u2500\u239f        \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f        sin \u239c\u2500\u239f     \u23a5\n    \u23a2         \u239d2\u23a0              \u239d2\u23a0    \u239d2\u23a0            \u239d2\u23a0     \u23a5\n    \u23a2                                                        \u23a5\n    \u23a2       \u239b\u03b2\u239e    \u239b\u03b2\u239e       2\u239b\u03b2\u239e      2\u239b\u03b2\u239e        \u239b\u03b2\u239e    \u239b\u03b2\u239e\u23a5\n    \u23a2-\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f  - sin \u239c\u2500\u239f + cos \u239c\u2500\u239f  \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f\u23a5\n    \u23a2       \u239d2\u23a0    \u239d2\u23a0        \u239d2\u23a0       \u239d2\u23a0        \u239d2\u23a0    \u239d2\u23a0\u23a5\n    \u23a2                                                        \u23a5\n    \u23a2        2\u239b\u03b2\u239e               \u239b\u03b2\u239e    \u239b\u03b2\u239e          2\u239b\u03b2\u239e     \u23a5\n    \u23a2     sin \u239c\u2500\u239f        -\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f       cos \u239c\u2500\u239f     \u23a5\n    \u23a3         \u239d2\u23a0               \u239d2\u23a0    \u239d2\u23a0           \u239d2\u23a0     \u23a6\n\n    From table 4 in [Edmonds74]_\n\n    >>> pprint(wigner_d_small(half, beta).subs({beta:pi/2}), use_unicode=True)\n    \u23a1 \u221a2   \u221a2\u23a4\n    \u23a2 \u2500\u2500   \u2500\u2500\u23a5\n    \u23a2 2    2 \u23a5\n    \u23a2        \u23a5\n    \u23a2-\u221a2   \u221a2\u23a5\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\n    \u23a3 2    2 \u23a6\n\n    >>> pprint(wigner_d_small(2*half, beta).subs({beta:pi/2}),\n    ... use_unicode=True)\n    \u23a1       \u221a2      \u23a4\n    \u23a21/2    \u2500\u2500   1/2\u23a5\n    \u23a2       2       \u23a5\n    \u23a2               \u23a5\n    \u23a2-\u221a2         \u221a2 \u23a5\n    \u23a2\u2500\u2500\u2500\u2500   0    \u2500\u2500 \u23a5\n    \u23a2 2          2  \u23a5\n    \u23a2               \u23a5\n    \u23a2      -\u221a2      \u23a5\n    \u23a21/2   \u2500\u2500\u2500\u2500  1/2\u23a5\n    \u23a3       2       \u23a6\n\n    >>> pprint(wigner_d_small(3*half, beta).subs({beta:pi/2}),\n    ... use_unicode=True)\n    \u23a1 \u221a2    \u221a6    \u221a6   \u221a2\u23a4\n    \u23a2 \u2500\u2500    \u2500\u2500    \u2500\u2500   \u2500\u2500\u23a5\n    \u23a2 4     4     4    4 \u23a5\n    \u23a2                    \u23a5\n    \u23a2-\u221a6   -\u221a2    \u221a2   \u221a6\u23a5\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u23a5\n    \u23a2 4     4     4    4 \u23a5\n    \u23a2                    \u23a5\n    \u23a2 \u221a6   -\u221a2   -\u221a2   \u221a6\u23a5\n    \u23a2 \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\n    \u23a2 4     4     4    4 \u23a5\n    \u23a2                    \u23a5\n    \u23a2-\u221a2    \u221a6   -\u221a6   \u221a2\u23a5\n    \u23a2\u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\n    \u23a3 4     4     4    4 \u23a6\n\n    >>> pprint(wigner_d_small(4*half, beta).subs({beta:pi/2}),\n    ... use_unicode=True)\n    \u23a1             \u221a6            \u23a4\n    \u23a21/4   1/2    \u2500\u2500   1/2   1/4\u23a5\n    \u23a2             4             \u23a5\n    \u23a2                           \u23a5\n    \u23a2-1/2  -1/2   0    1/2   1/2\u23a5\n    \u23a2                           \u23a5\n    \u23a2 \u221a6                     \u221a6 \u23a5\n    \u23a2 \u2500\u2500    0    -1/2   0    \u2500\u2500 \u23a5\n    \u23a2 4                      4  \u23a5\n    \u23a2                           \u23a5\n    \u23a2-1/2  1/2    0    -1/2  1/2\u23a5\n    \u23a2                           \u23a5\n    \u23a2             \u221a6            \u23a5\n    \u23a21/4   -1/2   \u2500\u2500   -1/2  1/4\u23a5\n    \u23a3             4             \u23a6\n\n    \"\"\"\n    M = [J - i for i in range(2 * J + 1)]\n    d = zeros(2 * J + 1)\n    for (i, Mi) in enumerate(M):\n        for (j, Mj) in enumerate(M):\n            sigmamax = min([J - Mi, J - Mj])\n            sigmamin = max([0, -Mi - Mj])\n            dij = sqrt(factorial(J + Mi) * factorial(J - Mi) / factorial(J + Mj) / factorial(J - Mj))\n            terms = [(-1) ** (J - Mi - s) * binomial(J + Mj, J - Mi - s) * binomial(J - Mj, s) * cos(beta / 2) ** (2 * s + Mi + Mj) * sin(beta / 2) ** (2 * J - 2 * s - Mj - Mi) for s in range(sigmamin, sigmamax + 1)]\n            d[i, j] = dij * Add(*terms)\n    return ImmutableMatrix(d)",
        "mutated": [
            "def wigner_d_small(J, beta):\n    if False:\n        i = 10\n    'Return the small Wigner d matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J : An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    beta : A real number representing the Euler angle of rotation about\\n        the so-called line of nodes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{d}_{\\\\beta} = \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.15.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Integer, symbols, pi, pprint\\n    >>> from sympy.physics.wigner import wigner_d_small\\n    >>> half = 1/Integer(2)\\n    >>> beta = symbols(\"beta\", real=True)\\n    >>> pprint(wigner_d_small(half, beta), use_unicode=True)\\n    \u23a1   \u239b\u03b2\u239e      \u239b\u03b2\u239e\u23a4\\n    \u23a2cos\u239c\u2500\u239f   sin\u239c\u2500\u239f\u23a5\\n    \u23a2   \u239d2\u23a0      \u239d2\u23a0\u23a5\\n    \u23a2               \u23a5\\n    \u23a2    \u239b\u03b2\u239e     \u239b\u03b2\u239e\u23a5\\n    \u23a2-sin\u239c\u2500\u239f  cos\u239c\u2500\u239f\u23a5\\n    \u23a3    \u239d2\u23a0     \u239d2\u23a0\u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta), use_unicode=True)\\n    \u23a1        2\u239b\u03b2\u239e              \u239b\u03b2\u239e    \u239b\u03b2\u239e           2\u239b\u03b2\u239e     \u23a4\\n    \u23a2     cos \u239c\u2500\u239f        \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f        sin \u239c\u2500\u239f     \u23a5\\n    \u23a2         \u239d2\u23a0              \u239d2\u23a0    \u239d2\u23a0            \u239d2\u23a0     \u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2       \u239b\u03b2\u239e    \u239b\u03b2\u239e       2\u239b\u03b2\u239e      2\u239b\u03b2\u239e        \u239b\u03b2\u239e    \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f  - sin \u239c\u2500\u239f + cos \u239c\u2500\u239f  \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a2       \u239d2\u23a0    \u239d2\u23a0        \u239d2\u23a0       \u239d2\u23a0        \u239d2\u23a0    \u239d2\u23a0\u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2        2\u239b\u03b2\u239e               \u239b\u03b2\u239e    \u239b\u03b2\u239e          2\u239b\u03b2\u239e     \u23a5\\n    \u23a2     sin \u239c\u2500\u239f        -\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f       cos \u239c\u2500\u239f     \u23a5\\n    \u23a3         \u239d2\u23a0               \u239d2\u23a0    \u239d2\u23a0           \u239d2\u23a0     \u23a6\\n\\n    From table 4 in [Edmonds74]_\\n\\n    >>> pprint(wigner_d_small(half, beta).subs({beta:pi/2}), use_unicode=True)\\n    \u23a1 \u221a2   \u221a2\u23a4\\n    \u23a2 \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 2    2 \u23a5\\n    \u23a2        \u23a5\\n    \u23a2-\u221a2   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 2    2 \u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1       \u221a2      \u23a4\\n    \u23a21/2    \u2500\u2500   1/2\u23a5\\n    \u23a2       2       \u23a5\\n    \u23a2               \u23a5\\n    \u23a2-\u221a2         \u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   0    \u2500\u2500 \u23a5\\n    \u23a2 2          2  \u23a5\\n    \u23a2               \u23a5\\n    \u23a2      -\u221a2      \u23a5\\n    \u23a21/2   \u2500\u2500\u2500\u2500  1/2\u23a5\\n    \u23a3       2       \u23a6\\n\\n    >>> pprint(wigner_d_small(3*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1 \u221a2    \u221a6    \u221a6   \u221a2\u23a4\\n    \u23a2 \u2500\u2500    \u2500\u2500    \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a6   -\u221a2    \u221a2   \u221a6\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2 \u221a6   -\u221a2   -\u221a2   \u221a6\u23a5\\n    \u23a2 \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a2    \u221a6   -\u221a6   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 4     4     4    4 \u23a6\\n\\n    >>> pprint(wigner_d_small(4*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1             \u221a6            \u23a4\\n    \u23a21/4   1/2    \u2500\u2500   1/2   1/4\u23a5\\n    \u23a2             4             \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  -1/2   0    1/2   1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2 \u221a6                     \u221a6 \u23a5\\n    \u23a2 \u2500\u2500    0    -1/2   0    \u2500\u2500 \u23a5\\n    \u23a2 4                      4  \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  1/2    0    -1/2  1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2             \u221a6            \u23a5\\n    \u23a21/4   -1/2   \u2500\u2500   -1/2  1/4\u23a5\\n    \u23a3             4             \u23a6\\n\\n    '\n    M = [J - i for i in range(2 * J + 1)]\n    d = zeros(2 * J + 1)\n    for (i, Mi) in enumerate(M):\n        for (j, Mj) in enumerate(M):\n            sigmamax = min([J - Mi, J - Mj])\n            sigmamin = max([0, -Mi - Mj])\n            dij = sqrt(factorial(J + Mi) * factorial(J - Mi) / factorial(J + Mj) / factorial(J - Mj))\n            terms = [(-1) ** (J - Mi - s) * binomial(J + Mj, J - Mi - s) * binomial(J - Mj, s) * cos(beta / 2) ** (2 * s + Mi + Mj) * sin(beta / 2) ** (2 * J - 2 * s - Mj - Mi) for s in range(sigmamin, sigmamax + 1)]\n            d[i, j] = dij * Add(*terms)\n    return ImmutableMatrix(d)",
            "def wigner_d_small(J, beta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the small Wigner d matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J : An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    beta : A real number representing the Euler angle of rotation about\\n        the so-called line of nodes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{d}_{\\\\beta} = \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.15.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Integer, symbols, pi, pprint\\n    >>> from sympy.physics.wigner import wigner_d_small\\n    >>> half = 1/Integer(2)\\n    >>> beta = symbols(\"beta\", real=True)\\n    >>> pprint(wigner_d_small(half, beta), use_unicode=True)\\n    \u23a1   \u239b\u03b2\u239e      \u239b\u03b2\u239e\u23a4\\n    \u23a2cos\u239c\u2500\u239f   sin\u239c\u2500\u239f\u23a5\\n    \u23a2   \u239d2\u23a0      \u239d2\u23a0\u23a5\\n    \u23a2               \u23a5\\n    \u23a2    \u239b\u03b2\u239e     \u239b\u03b2\u239e\u23a5\\n    \u23a2-sin\u239c\u2500\u239f  cos\u239c\u2500\u239f\u23a5\\n    \u23a3    \u239d2\u23a0     \u239d2\u23a0\u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta), use_unicode=True)\\n    \u23a1        2\u239b\u03b2\u239e              \u239b\u03b2\u239e    \u239b\u03b2\u239e           2\u239b\u03b2\u239e     \u23a4\\n    \u23a2     cos \u239c\u2500\u239f        \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f        sin \u239c\u2500\u239f     \u23a5\\n    \u23a2         \u239d2\u23a0              \u239d2\u23a0    \u239d2\u23a0            \u239d2\u23a0     \u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2       \u239b\u03b2\u239e    \u239b\u03b2\u239e       2\u239b\u03b2\u239e      2\u239b\u03b2\u239e        \u239b\u03b2\u239e    \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f  - sin \u239c\u2500\u239f + cos \u239c\u2500\u239f  \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a2       \u239d2\u23a0    \u239d2\u23a0        \u239d2\u23a0       \u239d2\u23a0        \u239d2\u23a0    \u239d2\u23a0\u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2        2\u239b\u03b2\u239e               \u239b\u03b2\u239e    \u239b\u03b2\u239e          2\u239b\u03b2\u239e     \u23a5\\n    \u23a2     sin \u239c\u2500\u239f        -\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f       cos \u239c\u2500\u239f     \u23a5\\n    \u23a3         \u239d2\u23a0               \u239d2\u23a0    \u239d2\u23a0           \u239d2\u23a0     \u23a6\\n\\n    From table 4 in [Edmonds74]_\\n\\n    >>> pprint(wigner_d_small(half, beta).subs({beta:pi/2}), use_unicode=True)\\n    \u23a1 \u221a2   \u221a2\u23a4\\n    \u23a2 \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 2    2 \u23a5\\n    \u23a2        \u23a5\\n    \u23a2-\u221a2   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 2    2 \u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1       \u221a2      \u23a4\\n    \u23a21/2    \u2500\u2500   1/2\u23a5\\n    \u23a2       2       \u23a5\\n    \u23a2               \u23a5\\n    \u23a2-\u221a2         \u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   0    \u2500\u2500 \u23a5\\n    \u23a2 2          2  \u23a5\\n    \u23a2               \u23a5\\n    \u23a2      -\u221a2      \u23a5\\n    \u23a21/2   \u2500\u2500\u2500\u2500  1/2\u23a5\\n    \u23a3       2       \u23a6\\n\\n    >>> pprint(wigner_d_small(3*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1 \u221a2    \u221a6    \u221a6   \u221a2\u23a4\\n    \u23a2 \u2500\u2500    \u2500\u2500    \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a6   -\u221a2    \u221a2   \u221a6\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2 \u221a6   -\u221a2   -\u221a2   \u221a6\u23a5\\n    \u23a2 \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a2    \u221a6   -\u221a6   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 4     4     4    4 \u23a6\\n\\n    >>> pprint(wigner_d_small(4*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1             \u221a6            \u23a4\\n    \u23a21/4   1/2    \u2500\u2500   1/2   1/4\u23a5\\n    \u23a2             4             \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  -1/2   0    1/2   1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2 \u221a6                     \u221a6 \u23a5\\n    \u23a2 \u2500\u2500    0    -1/2   0    \u2500\u2500 \u23a5\\n    \u23a2 4                      4  \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  1/2    0    -1/2  1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2             \u221a6            \u23a5\\n    \u23a21/4   -1/2   \u2500\u2500   -1/2  1/4\u23a5\\n    \u23a3             4             \u23a6\\n\\n    '\n    M = [J - i for i in range(2 * J + 1)]\n    d = zeros(2 * J + 1)\n    for (i, Mi) in enumerate(M):\n        for (j, Mj) in enumerate(M):\n            sigmamax = min([J - Mi, J - Mj])\n            sigmamin = max([0, -Mi - Mj])\n            dij = sqrt(factorial(J + Mi) * factorial(J - Mi) / factorial(J + Mj) / factorial(J - Mj))\n            terms = [(-1) ** (J - Mi - s) * binomial(J + Mj, J - Mi - s) * binomial(J - Mj, s) * cos(beta / 2) ** (2 * s + Mi + Mj) * sin(beta / 2) ** (2 * J - 2 * s - Mj - Mi) for s in range(sigmamin, sigmamax + 1)]\n            d[i, j] = dij * Add(*terms)\n    return ImmutableMatrix(d)",
            "def wigner_d_small(J, beta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the small Wigner d matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J : An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    beta : A real number representing the Euler angle of rotation about\\n        the so-called line of nodes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{d}_{\\\\beta} = \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.15.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Integer, symbols, pi, pprint\\n    >>> from sympy.physics.wigner import wigner_d_small\\n    >>> half = 1/Integer(2)\\n    >>> beta = symbols(\"beta\", real=True)\\n    >>> pprint(wigner_d_small(half, beta), use_unicode=True)\\n    \u23a1   \u239b\u03b2\u239e      \u239b\u03b2\u239e\u23a4\\n    \u23a2cos\u239c\u2500\u239f   sin\u239c\u2500\u239f\u23a5\\n    \u23a2   \u239d2\u23a0      \u239d2\u23a0\u23a5\\n    \u23a2               \u23a5\\n    \u23a2    \u239b\u03b2\u239e     \u239b\u03b2\u239e\u23a5\\n    \u23a2-sin\u239c\u2500\u239f  cos\u239c\u2500\u239f\u23a5\\n    \u23a3    \u239d2\u23a0     \u239d2\u23a0\u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta), use_unicode=True)\\n    \u23a1        2\u239b\u03b2\u239e              \u239b\u03b2\u239e    \u239b\u03b2\u239e           2\u239b\u03b2\u239e     \u23a4\\n    \u23a2     cos \u239c\u2500\u239f        \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f        sin \u239c\u2500\u239f     \u23a5\\n    \u23a2         \u239d2\u23a0              \u239d2\u23a0    \u239d2\u23a0            \u239d2\u23a0     \u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2       \u239b\u03b2\u239e    \u239b\u03b2\u239e       2\u239b\u03b2\u239e      2\u239b\u03b2\u239e        \u239b\u03b2\u239e    \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f  - sin \u239c\u2500\u239f + cos \u239c\u2500\u239f  \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a2       \u239d2\u23a0    \u239d2\u23a0        \u239d2\u23a0       \u239d2\u23a0        \u239d2\u23a0    \u239d2\u23a0\u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2        2\u239b\u03b2\u239e               \u239b\u03b2\u239e    \u239b\u03b2\u239e          2\u239b\u03b2\u239e     \u23a5\\n    \u23a2     sin \u239c\u2500\u239f        -\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f       cos \u239c\u2500\u239f     \u23a5\\n    \u23a3         \u239d2\u23a0               \u239d2\u23a0    \u239d2\u23a0           \u239d2\u23a0     \u23a6\\n\\n    From table 4 in [Edmonds74]_\\n\\n    >>> pprint(wigner_d_small(half, beta).subs({beta:pi/2}), use_unicode=True)\\n    \u23a1 \u221a2   \u221a2\u23a4\\n    \u23a2 \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 2    2 \u23a5\\n    \u23a2        \u23a5\\n    \u23a2-\u221a2   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 2    2 \u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1       \u221a2      \u23a4\\n    \u23a21/2    \u2500\u2500   1/2\u23a5\\n    \u23a2       2       \u23a5\\n    \u23a2               \u23a5\\n    \u23a2-\u221a2         \u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   0    \u2500\u2500 \u23a5\\n    \u23a2 2          2  \u23a5\\n    \u23a2               \u23a5\\n    \u23a2      -\u221a2      \u23a5\\n    \u23a21/2   \u2500\u2500\u2500\u2500  1/2\u23a5\\n    \u23a3       2       \u23a6\\n\\n    >>> pprint(wigner_d_small(3*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1 \u221a2    \u221a6    \u221a6   \u221a2\u23a4\\n    \u23a2 \u2500\u2500    \u2500\u2500    \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a6   -\u221a2    \u221a2   \u221a6\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2 \u221a6   -\u221a2   -\u221a2   \u221a6\u23a5\\n    \u23a2 \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a2    \u221a6   -\u221a6   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 4     4     4    4 \u23a6\\n\\n    >>> pprint(wigner_d_small(4*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1             \u221a6            \u23a4\\n    \u23a21/4   1/2    \u2500\u2500   1/2   1/4\u23a5\\n    \u23a2             4             \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  -1/2   0    1/2   1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2 \u221a6                     \u221a6 \u23a5\\n    \u23a2 \u2500\u2500    0    -1/2   0    \u2500\u2500 \u23a5\\n    \u23a2 4                      4  \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  1/2    0    -1/2  1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2             \u221a6            \u23a5\\n    \u23a21/4   -1/2   \u2500\u2500   -1/2  1/4\u23a5\\n    \u23a3             4             \u23a6\\n\\n    '\n    M = [J - i for i in range(2 * J + 1)]\n    d = zeros(2 * J + 1)\n    for (i, Mi) in enumerate(M):\n        for (j, Mj) in enumerate(M):\n            sigmamax = min([J - Mi, J - Mj])\n            sigmamin = max([0, -Mi - Mj])\n            dij = sqrt(factorial(J + Mi) * factorial(J - Mi) / factorial(J + Mj) / factorial(J - Mj))\n            terms = [(-1) ** (J - Mi - s) * binomial(J + Mj, J - Mi - s) * binomial(J - Mj, s) * cos(beta / 2) ** (2 * s + Mi + Mj) * sin(beta / 2) ** (2 * J - 2 * s - Mj - Mi) for s in range(sigmamin, sigmamax + 1)]\n            d[i, j] = dij * Add(*terms)\n    return ImmutableMatrix(d)",
            "def wigner_d_small(J, beta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the small Wigner d matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J : An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    beta : A real number representing the Euler angle of rotation about\\n        the so-called line of nodes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{d}_{\\\\beta} = \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.15.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Integer, symbols, pi, pprint\\n    >>> from sympy.physics.wigner import wigner_d_small\\n    >>> half = 1/Integer(2)\\n    >>> beta = symbols(\"beta\", real=True)\\n    >>> pprint(wigner_d_small(half, beta), use_unicode=True)\\n    \u23a1   \u239b\u03b2\u239e      \u239b\u03b2\u239e\u23a4\\n    \u23a2cos\u239c\u2500\u239f   sin\u239c\u2500\u239f\u23a5\\n    \u23a2   \u239d2\u23a0      \u239d2\u23a0\u23a5\\n    \u23a2               \u23a5\\n    \u23a2    \u239b\u03b2\u239e     \u239b\u03b2\u239e\u23a5\\n    \u23a2-sin\u239c\u2500\u239f  cos\u239c\u2500\u239f\u23a5\\n    \u23a3    \u239d2\u23a0     \u239d2\u23a0\u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta), use_unicode=True)\\n    \u23a1        2\u239b\u03b2\u239e              \u239b\u03b2\u239e    \u239b\u03b2\u239e           2\u239b\u03b2\u239e     \u23a4\\n    \u23a2     cos \u239c\u2500\u239f        \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f        sin \u239c\u2500\u239f     \u23a5\\n    \u23a2         \u239d2\u23a0              \u239d2\u23a0    \u239d2\u23a0            \u239d2\u23a0     \u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2       \u239b\u03b2\u239e    \u239b\u03b2\u239e       2\u239b\u03b2\u239e      2\u239b\u03b2\u239e        \u239b\u03b2\u239e    \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f  - sin \u239c\u2500\u239f + cos \u239c\u2500\u239f  \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a2       \u239d2\u23a0    \u239d2\u23a0        \u239d2\u23a0       \u239d2\u23a0        \u239d2\u23a0    \u239d2\u23a0\u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2        2\u239b\u03b2\u239e               \u239b\u03b2\u239e    \u239b\u03b2\u239e          2\u239b\u03b2\u239e     \u23a5\\n    \u23a2     sin \u239c\u2500\u239f        -\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f       cos \u239c\u2500\u239f     \u23a5\\n    \u23a3         \u239d2\u23a0               \u239d2\u23a0    \u239d2\u23a0           \u239d2\u23a0     \u23a6\\n\\n    From table 4 in [Edmonds74]_\\n\\n    >>> pprint(wigner_d_small(half, beta).subs({beta:pi/2}), use_unicode=True)\\n    \u23a1 \u221a2   \u221a2\u23a4\\n    \u23a2 \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 2    2 \u23a5\\n    \u23a2        \u23a5\\n    \u23a2-\u221a2   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 2    2 \u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1       \u221a2      \u23a4\\n    \u23a21/2    \u2500\u2500   1/2\u23a5\\n    \u23a2       2       \u23a5\\n    \u23a2               \u23a5\\n    \u23a2-\u221a2         \u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   0    \u2500\u2500 \u23a5\\n    \u23a2 2          2  \u23a5\\n    \u23a2               \u23a5\\n    \u23a2      -\u221a2      \u23a5\\n    \u23a21/2   \u2500\u2500\u2500\u2500  1/2\u23a5\\n    \u23a3       2       \u23a6\\n\\n    >>> pprint(wigner_d_small(3*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1 \u221a2    \u221a6    \u221a6   \u221a2\u23a4\\n    \u23a2 \u2500\u2500    \u2500\u2500    \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a6   -\u221a2    \u221a2   \u221a6\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2 \u221a6   -\u221a2   -\u221a2   \u221a6\u23a5\\n    \u23a2 \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a2    \u221a6   -\u221a6   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 4     4     4    4 \u23a6\\n\\n    >>> pprint(wigner_d_small(4*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1             \u221a6            \u23a4\\n    \u23a21/4   1/2    \u2500\u2500   1/2   1/4\u23a5\\n    \u23a2             4             \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  -1/2   0    1/2   1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2 \u221a6                     \u221a6 \u23a5\\n    \u23a2 \u2500\u2500    0    -1/2   0    \u2500\u2500 \u23a5\\n    \u23a2 4                      4  \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  1/2    0    -1/2  1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2             \u221a6            \u23a5\\n    \u23a21/4   -1/2   \u2500\u2500   -1/2  1/4\u23a5\\n    \u23a3             4             \u23a6\\n\\n    '\n    M = [J - i for i in range(2 * J + 1)]\n    d = zeros(2 * J + 1)\n    for (i, Mi) in enumerate(M):\n        for (j, Mj) in enumerate(M):\n            sigmamax = min([J - Mi, J - Mj])\n            sigmamin = max([0, -Mi - Mj])\n            dij = sqrt(factorial(J + Mi) * factorial(J - Mi) / factorial(J + Mj) / factorial(J - Mj))\n            terms = [(-1) ** (J - Mi - s) * binomial(J + Mj, J - Mi - s) * binomial(J - Mj, s) * cos(beta / 2) ** (2 * s + Mi + Mj) * sin(beta / 2) ** (2 * J - 2 * s - Mj - Mi) for s in range(sigmamin, sigmamax + 1)]\n            d[i, j] = dij * Add(*terms)\n    return ImmutableMatrix(d)",
            "def wigner_d_small(J, beta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the small Wigner d matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J : An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    beta : A real number representing the Euler angle of rotation about\\n        the so-called line of nodes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{d}_{\\\\beta} = \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.15.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Integer, symbols, pi, pprint\\n    >>> from sympy.physics.wigner import wigner_d_small\\n    >>> half = 1/Integer(2)\\n    >>> beta = symbols(\"beta\", real=True)\\n    >>> pprint(wigner_d_small(half, beta), use_unicode=True)\\n    \u23a1   \u239b\u03b2\u239e      \u239b\u03b2\u239e\u23a4\\n    \u23a2cos\u239c\u2500\u239f   sin\u239c\u2500\u239f\u23a5\\n    \u23a2   \u239d2\u23a0      \u239d2\u23a0\u23a5\\n    \u23a2               \u23a5\\n    \u23a2    \u239b\u03b2\u239e     \u239b\u03b2\u239e\u23a5\\n    \u23a2-sin\u239c\u2500\u239f  cos\u239c\u2500\u239f\u23a5\\n    \u23a3    \u239d2\u23a0     \u239d2\u23a0\u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta), use_unicode=True)\\n    \u23a1        2\u239b\u03b2\u239e              \u239b\u03b2\u239e    \u239b\u03b2\u239e           2\u239b\u03b2\u239e     \u23a4\\n    \u23a2     cos \u239c\u2500\u239f        \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f        sin \u239c\u2500\u239f     \u23a5\\n    \u23a2         \u239d2\u23a0              \u239d2\u23a0    \u239d2\u23a0            \u239d2\u23a0     \u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2       \u239b\u03b2\u239e    \u239b\u03b2\u239e       2\u239b\u03b2\u239e      2\u239b\u03b2\u239e        \u239b\u03b2\u239e    \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f  - sin \u239c\u2500\u239f + cos \u239c\u2500\u239f  \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a2       \u239d2\u23a0    \u239d2\u23a0        \u239d2\u23a0       \u239d2\u23a0        \u239d2\u23a0    \u239d2\u23a0\u23a5\\n    \u23a2                                                        \u23a5\\n    \u23a2        2\u239b\u03b2\u239e               \u239b\u03b2\u239e    \u239b\u03b2\u239e          2\u239b\u03b2\u239e     \u23a5\\n    \u23a2     sin \u239c\u2500\u239f        -\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f       cos \u239c\u2500\u239f     \u23a5\\n    \u23a3         \u239d2\u23a0               \u239d2\u23a0    \u239d2\u23a0           \u239d2\u23a0     \u23a6\\n\\n    From table 4 in [Edmonds74]_\\n\\n    >>> pprint(wigner_d_small(half, beta).subs({beta:pi/2}), use_unicode=True)\\n    \u23a1 \u221a2   \u221a2\u23a4\\n    \u23a2 \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 2    2 \u23a5\\n    \u23a2        \u23a5\\n    \u23a2-\u221a2   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 2    2 \u23a6\\n\\n    >>> pprint(wigner_d_small(2*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1       \u221a2      \u23a4\\n    \u23a21/2    \u2500\u2500   1/2\u23a5\\n    \u23a2       2       \u23a5\\n    \u23a2               \u23a5\\n    \u23a2-\u221a2         \u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   0    \u2500\u2500 \u23a5\\n    \u23a2 2          2  \u23a5\\n    \u23a2               \u23a5\\n    \u23a2      -\u221a2      \u23a5\\n    \u23a21/2   \u2500\u2500\u2500\u2500  1/2\u23a5\\n    \u23a3       2       \u23a6\\n\\n    >>> pprint(wigner_d_small(3*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1 \u221a2    \u221a6    \u221a6   \u221a2\u23a4\\n    \u23a2 \u2500\u2500    \u2500\u2500    \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a6   -\u221a2    \u221a2   \u221a6\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2 \u221a6   -\u221a2   -\u221a2   \u221a6\u23a5\\n    \u23a2 \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a2 4     4     4    4 \u23a5\\n    \u23a2                    \u23a5\\n    \u23a2-\u221a2    \u221a6   -\u221a6   \u221a2\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\\n    \u23a3 4     4     4    4 \u23a6\\n\\n    >>> pprint(wigner_d_small(4*half, beta).subs({beta:pi/2}),\\n    ... use_unicode=True)\\n    \u23a1             \u221a6            \u23a4\\n    \u23a21/4   1/2    \u2500\u2500   1/2   1/4\u23a5\\n    \u23a2             4             \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  -1/2   0    1/2   1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2 \u221a6                     \u221a6 \u23a5\\n    \u23a2 \u2500\u2500    0    -1/2   0    \u2500\u2500 \u23a5\\n    \u23a2 4                      4  \u23a5\\n    \u23a2                           \u23a5\\n    \u23a2-1/2  1/2    0    -1/2  1/2\u23a5\\n    \u23a2                           \u23a5\\n    \u23a2             \u221a6            \u23a5\\n    \u23a21/4   -1/2   \u2500\u2500   -1/2  1/4\u23a5\\n    \u23a3             4             \u23a6\\n\\n    '\n    M = [J - i for i in range(2 * J + 1)]\n    d = zeros(2 * J + 1)\n    for (i, Mi) in enumerate(M):\n        for (j, Mj) in enumerate(M):\n            sigmamax = min([J - Mi, J - Mj])\n            sigmamin = max([0, -Mi - Mj])\n            dij = sqrt(factorial(J + Mi) * factorial(J - Mi) / factorial(J + Mj) / factorial(J - Mj))\n            terms = [(-1) ** (J - Mi - s) * binomial(J + Mj, J - Mi - s) * binomial(J - Mj, s) * cos(beta / 2) ** (2 * s + Mi + Mj) * sin(beta / 2) ** (2 * J - 2 * s - Mj - Mi) for s in range(sigmamin, sigmamax + 1)]\n            d[i, j] = dij * Add(*terms)\n    return ImmutableMatrix(d)"
        ]
    },
    {
        "func_name": "wigner_d",
        "original": "def wigner_d(J, alpha, beta, gamma):\n    \"\"\"Return the Wigner D matrix for angular momentum J.\n\n    Explanation\n    ===========\n\n    J :\n        An integer, half-integer, or SymPy symbol for the total angular\n        momentum of the angular momentum space being rotated.\n    alpha, beta, gamma - Real numbers representing the Euler.\n        Angles of rotation about the so-called vertical, line of nodes, and\n        figure axes. See [Edmonds74]_.\n\n    Returns\n    =======\n\n    A matrix representing the corresponding Euler angle rotation( in the basis\n    of eigenvectors of `J_z`).\n\n    .. math ::\n        \\\\mathcal{D}_{\\\\alpha \\\\beta \\\\gamma} =\n        \\\\exp\\\\big( \\\\frac{i\\\\alpha}{\\\\hbar} J_z\\\\big)\n        \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\n        \\\\exp\\\\big( \\\\frac{i\\\\gamma}{\\\\hbar} J_z\\\\big)\n\n    The components are calculated using the general form [Edmonds74]_,\n    equation 4.1.12.\n\n    Examples\n    ========\n\n    The simplest possible example:\n\n    >>> from sympy.physics.wigner import wigner_d\n    >>> from sympy import Integer, symbols, pprint\n    >>> half = 1/Integer(2)\n    >>> alpha, beta, gamma = symbols(\"alpha, beta, gamma\", real=True)\n    >>> pprint(wigner_d(half, alpha, beta, gamma), use_unicode=True)\n    \u23a1  \u2148\u22c5\u03b1  \u2148\u22c5\u03b3             \u2148\u22c5\u03b1  -\u2148\u22c5\u03b3         \u23a4\n    \u23a2  \u2500\u2500\u2500  \u2500\u2500\u2500             \u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500        \u23a5\n    \u23a2   2    2     \u239b\u03b2\u239e       2     2      \u239b\u03b2\u239e \u23a5\n    \u23a2 \u212f   \u22c5\u212f   \u22c5cos\u239c\u2500\u239f     \u212f   \u22c5\u212f     \u22c5sin\u239c\u2500\u239f \u23a5\n    \u23a2              \u239d2\u23a0                    \u239d2\u23a0 \u23a5\n    \u23a2                                         \u23a5\n    \u23a2  -\u2148\u22c5\u03b1   \u2148\u22c5\u03b3          -\u2148\u22c5\u03b1   -\u2148\u22c5\u03b3        \u23a5\n    \u23a2  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500          \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500       \u23a5\n    \u23a2    2     2     \u239b\u03b2\u239e     2      2      \u239b\u03b2\u239e\u23a5\n    \u23a2-\u212f     \u22c5\u212f   \u22c5sin\u239c\u2500\u239f  \u212f     \u22c5\u212f     \u22c5cos\u239c\u2500\u239f\u23a5\n    \u23a3                \u239d2\u23a0                   \u239d2\u23a0\u23a6\n\n    \"\"\"\n    d = wigner_d_small(J, beta)\n    M = [J - i for i in range(2 * J + 1)]\n    D = [[exp(I * Mi * alpha) * d[i, j] * exp(I * Mj * gamma) for (j, Mj) in enumerate(M)] for (i, Mi) in enumerate(M)]\n    return ImmutableMatrix(D)",
        "mutated": [
            "def wigner_d(J, alpha, beta, gamma):\n    if False:\n        i = 10\n    'Return the Wigner D matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J :\\n        An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    alpha, beta, gamma - Real numbers representing the Euler.\\n        Angles of rotation about the so-called vertical, line of nodes, and\\n        figure axes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{D}_{\\\\alpha \\\\beta \\\\gamma} =\\n        \\\\exp\\\\big( \\\\frac{i\\\\alpha}{\\\\hbar} J_z\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\gamma}{\\\\hbar} J_z\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.12.\\n\\n    Examples\\n    ========\\n\\n    The simplest possible example:\\n\\n    >>> from sympy.physics.wigner import wigner_d\\n    >>> from sympy import Integer, symbols, pprint\\n    >>> half = 1/Integer(2)\\n    >>> alpha, beta, gamma = symbols(\"alpha, beta, gamma\", real=True)\\n    >>> pprint(wigner_d(half, alpha, beta, gamma), use_unicode=True)\\n    \u23a1  \u2148\u22c5\u03b1  \u2148\u22c5\u03b3             \u2148\u22c5\u03b1  -\u2148\u22c5\u03b3         \u23a4\\n    \u23a2  \u2500\u2500\u2500  \u2500\u2500\u2500             \u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500        \u23a5\\n    \u23a2   2    2     \u239b\u03b2\u239e       2     2      \u239b\u03b2\u239e \u23a5\\n    \u23a2 \u212f   \u22c5\u212f   \u22c5cos\u239c\u2500\u239f     \u212f   \u22c5\u212f     \u22c5sin\u239c\u2500\u239f \u23a5\\n    \u23a2              \u239d2\u23a0                    \u239d2\u23a0 \u23a5\\n    \u23a2                                         \u23a5\\n    \u23a2  -\u2148\u22c5\u03b1   \u2148\u22c5\u03b3          -\u2148\u22c5\u03b1   -\u2148\u22c5\u03b3        \u23a5\\n    \u23a2  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500          \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500       \u23a5\\n    \u23a2    2     2     \u239b\u03b2\u239e     2      2      \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u212f     \u22c5\u212f   \u22c5sin\u239c\u2500\u239f  \u212f     \u22c5\u212f     \u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a3                \u239d2\u23a0                   \u239d2\u23a0\u23a6\\n\\n    '\n    d = wigner_d_small(J, beta)\n    M = [J - i for i in range(2 * J + 1)]\n    D = [[exp(I * Mi * alpha) * d[i, j] * exp(I * Mj * gamma) for (j, Mj) in enumerate(M)] for (i, Mi) in enumerate(M)]\n    return ImmutableMatrix(D)",
            "def wigner_d(J, alpha, beta, gamma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the Wigner D matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J :\\n        An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    alpha, beta, gamma - Real numbers representing the Euler.\\n        Angles of rotation about the so-called vertical, line of nodes, and\\n        figure axes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{D}_{\\\\alpha \\\\beta \\\\gamma} =\\n        \\\\exp\\\\big( \\\\frac{i\\\\alpha}{\\\\hbar} J_z\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\gamma}{\\\\hbar} J_z\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.12.\\n\\n    Examples\\n    ========\\n\\n    The simplest possible example:\\n\\n    >>> from sympy.physics.wigner import wigner_d\\n    >>> from sympy import Integer, symbols, pprint\\n    >>> half = 1/Integer(2)\\n    >>> alpha, beta, gamma = symbols(\"alpha, beta, gamma\", real=True)\\n    >>> pprint(wigner_d(half, alpha, beta, gamma), use_unicode=True)\\n    \u23a1  \u2148\u22c5\u03b1  \u2148\u22c5\u03b3             \u2148\u22c5\u03b1  -\u2148\u22c5\u03b3         \u23a4\\n    \u23a2  \u2500\u2500\u2500  \u2500\u2500\u2500             \u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500        \u23a5\\n    \u23a2   2    2     \u239b\u03b2\u239e       2     2      \u239b\u03b2\u239e \u23a5\\n    \u23a2 \u212f   \u22c5\u212f   \u22c5cos\u239c\u2500\u239f     \u212f   \u22c5\u212f     \u22c5sin\u239c\u2500\u239f \u23a5\\n    \u23a2              \u239d2\u23a0                    \u239d2\u23a0 \u23a5\\n    \u23a2                                         \u23a5\\n    \u23a2  -\u2148\u22c5\u03b1   \u2148\u22c5\u03b3          -\u2148\u22c5\u03b1   -\u2148\u22c5\u03b3        \u23a5\\n    \u23a2  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500          \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500       \u23a5\\n    \u23a2    2     2     \u239b\u03b2\u239e     2      2      \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u212f     \u22c5\u212f   \u22c5sin\u239c\u2500\u239f  \u212f     \u22c5\u212f     \u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a3                \u239d2\u23a0                   \u239d2\u23a0\u23a6\\n\\n    '\n    d = wigner_d_small(J, beta)\n    M = [J - i for i in range(2 * J + 1)]\n    D = [[exp(I * Mi * alpha) * d[i, j] * exp(I * Mj * gamma) for (j, Mj) in enumerate(M)] for (i, Mi) in enumerate(M)]\n    return ImmutableMatrix(D)",
            "def wigner_d(J, alpha, beta, gamma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the Wigner D matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J :\\n        An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    alpha, beta, gamma - Real numbers representing the Euler.\\n        Angles of rotation about the so-called vertical, line of nodes, and\\n        figure axes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{D}_{\\\\alpha \\\\beta \\\\gamma} =\\n        \\\\exp\\\\big( \\\\frac{i\\\\alpha}{\\\\hbar} J_z\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\gamma}{\\\\hbar} J_z\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.12.\\n\\n    Examples\\n    ========\\n\\n    The simplest possible example:\\n\\n    >>> from sympy.physics.wigner import wigner_d\\n    >>> from sympy import Integer, symbols, pprint\\n    >>> half = 1/Integer(2)\\n    >>> alpha, beta, gamma = symbols(\"alpha, beta, gamma\", real=True)\\n    >>> pprint(wigner_d(half, alpha, beta, gamma), use_unicode=True)\\n    \u23a1  \u2148\u22c5\u03b1  \u2148\u22c5\u03b3             \u2148\u22c5\u03b1  -\u2148\u22c5\u03b3         \u23a4\\n    \u23a2  \u2500\u2500\u2500  \u2500\u2500\u2500             \u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500        \u23a5\\n    \u23a2   2    2     \u239b\u03b2\u239e       2     2      \u239b\u03b2\u239e \u23a5\\n    \u23a2 \u212f   \u22c5\u212f   \u22c5cos\u239c\u2500\u239f     \u212f   \u22c5\u212f     \u22c5sin\u239c\u2500\u239f \u23a5\\n    \u23a2              \u239d2\u23a0                    \u239d2\u23a0 \u23a5\\n    \u23a2                                         \u23a5\\n    \u23a2  -\u2148\u22c5\u03b1   \u2148\u22c5\u03b3          -\u2148\u22c5\u03b1   -\u2148\u22c5\u03b3        \u23a5\\n    \u23a2  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500          \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500       \u23a5\\n    \u23a2    2     2     \u239b\u03b2\u239e     2      2      \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u212f     \u22c5\u212f   \u22c5sin\u239c\u2500\u239f  \u212f     \u22c5\u212f     \u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a3                \u239d2\u23a0                   \u239d2\u23a0\u23a6\\n\\n    '\n    d = wigner_d_small(J, beta)\n    M = [J - i for i in range(2 * J + 1)]\n    D = [[exp(I * Mi * alpha) * d[i, j] * exp(I * Mj * gamma) for (j, Mj) in enumerate(M)] for (i, Mi) in enumerate(M)]\n    return ImmutableMatrix(D)",
            "def wigner_d(J, alpha, beta, gamma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the Wigner D matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J :\\n        An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    alpha, beta, gamma - Real numbers representing the Euler.\\n        Angles of rotation about the so-called vertical, line of nodes, and\\n        figure axes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{D}_{\\\\alpha \\\\beta \\\\gamma} =\\n        \\\\exp\\\\big( \\\\frac{i\\\\alpha}{\\\\hbar} J_z\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\gamma}{\\\\hbar} J_z\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.12.\\n\\n    Examples\\n    ========\\n\\n    The simplest possible example:\\n\\n    >>> from sympy.physics.wigner import wigner_d\\n    >>> from sympy import Integer, symbols, pprint\\n    >>> half = 1/Integer(2)\\n    >>> alpha, beta, gamma = symbols(\"alpha, beta, gamma\", real=True)\\n    >>> pprint(wigner_d(half, alpha, beta, gamma), use_unicode=True)\\n    \u23a1  \u2148\u22c5\u03b1  \u2148\u22c5\u03b3             \u2148\u22c5\u03b1  -\u2148\u22c5\u03b3         \u23a4\\n    \u23a2  \u2500\u2500\u2500  \u2500\u2500\u2500             \u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500        \u23a5\\n    \u23a2   2    2     \u239b\u03b2\u239e       2     2      \u239b\u03b2\u239e \u23a5\\n    \u23a2 \u212f   \u22c5\u212f   \u22c5cos\u239c\u2500\u239f     \u212f   \u22c5\u212f     \u22c5sin\u239c\u2500\u239f \u23a5\\n    \u23a2              \u239d2\u23a0                    \u239d2\u23a0 \u23a5\\n    \u23a2                                         \u23a5\\n    \u23a2  -\u2148\u22c5\u03b1   \u2148\u22c5\u03b3          -\u2148\u22c5\u03b1   -\u2148\u22c5\u03b3        \u23a5\\n    \u23a2  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500          \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500       \u23a5\\n    \u23a2    2     2     \u239b\u03b2\u239e     2      2      \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u212f     \u22c5\u212f   \u22c5sin\u239c\u2500\u239f  \u212f     \u22c5\u212f     \u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a3                \u239d2\u23a0                   \u239d2\u23a0\u23a6\\n\\n    '\n    d = wigner_d_small(J, beta)\n    M = [J - i for i in range(2 * J + 1)]\n    D = [[exp(I * Mi * alpha) * d[i, j] * exp(I * Mj * gamma) for (j, Mj) in enumerate(M)] for (i, Mi) in enumerate(M)]\n    return ImmutableMatrix(D)",
            "def wigner_d(J, alpha, beta, gamma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the Wigner D matrix for angular momentum J.\\n\\n    Explanation\\n    ===========\\n\\n    J :\\n        An integer, half-integer, or SymPy symbol for the total angular\\n        momentum of the angular momentum space being rotated.\\n    alpha, beta, gamma - Real numbers representing the Euler.\\n        Angles of rotation about the so-called vertical, line of nodes, and\\n        figure axes. See [Edmonds74]_.\\n\\n    Returns\\n    =======\\n\\n    A matrix representing the corresponding Euler angle rotation( in the basis\\n    of eigenvectors of `J_z`).\\n\\n    .. math ::\\n        \\\\mathcal{D}_{\\\\alpha \\\\beta \\\\gamma} =\\n        \\\\exp\\\\big( \\\\frac{i\\\\alpha}{\\\\hbar} J_z\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\beta}{\\\\hbar} J_y\\\\big)\\n        \\\\exp\\\\big( \\\\frac{i\\\\gamma}{\\\\hbar} J_z\\\\big)\\n\\n    The components are calculated using the general form [Edmonds74]_,\\n    equation 4.1.12.\\n\\n    Examples\\n    ========\\n\\n    The simplest possible example:\\n\\n    >>> from sympy.physics.wigner import wigner_d\\n    >>> from sympy import Integer, symbols, pprint\\n    >>> half = 1/Integer(2)\\n    >>> alpha, beta, gamma = symbols(\"alpha, beta, gamma\", real=True)\\n    >>> pprint(wigner_d(half, alpha, beta, gamma), use_unicode=True)\\n    \u23a1  \u2148\u22c5\u03b1  \u2148\u22c5\u03b3             \u2148\u22c5\u03b1  -\u2148\u22c5\u03b3         \u23a4\\n    \u23a2  \u2500\u2500\u2500  \u2500\u2500\u2500             \u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500        \u23a5\\n    \u23a2   2    2     \u239b\u03b2\u239e       2     2      \u239b\u03b2\u239e \u23a5\\n    \u23a2 \u212f   \u22c5\u212f   \u22c5cos\u239c\u2500\u239f     \u212f   \u22c5\u212f     \u22c5sin\u239c\u2500\u239f \u23a5\\n    \u23a2              \u239d2\u23a0                    \u239d2\u23a0 \u23a5\\n    \u23a2                                         \u23a5\\n    \u23a2  -\u2148\u22c5\u03b1   \u2148\u22c5\u03b3          -\u2148\u22c5\u03b1   -\u2148\u22c5\u03b3        \u23a5\\n    \u23a2  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500          \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500       \u23a5\\n    \u23a2    2     2     \u239b\u03b2\u239e     2      2      \u239b\u03b2\u239e\u23a5\\n    \u23a2-\u212f     \u22c5\u212f   \u22c5sin\u239c\u2500\u239f  \u212f     \u22c5\u212f     \u22c5cos\u239c\u2500\u239f\u23a5\\n    \u23a3                \u239d2\u23a0                   \u239d2\u23a0\u23a6\\n\\n    '\n    d = wigner_d_small(J, beta)\n    M = [J - i for i in range(2 * J + 1)]\n    D = [[exp(I * Mi * alpha) * d[i, j] * exp(I * Mj * gamma) for (j, Mj) in enumerate(M)] for (i, Mi) in enumerate(M)]\n    return ImmutableMatrix(D)"
        ]
    }
]