[
    {
        "func_name": "reformat_samples",
        "original": "def reformat_samples(seq2seq_obj, num_beams, batch_size):\n    samples = [[seq2seq_obj.candidates[bb][:, ex] for bb in range(num_beams)] for ex in range(batch_size)]\n    examples = []\n    for ex in range(batch_size):\n        examples.append(np.vstack([samples[ex][ii] for ii in range(num_beams)]))\n    return examples",
        "mutated": [
            "def reformat_samples(seq2seq_obj, num_beams, batch_size):\n    if False:\n        i = 10\n    samples = [[seq2seq_obj.candidates[bb][:, ex] for bb in range(num_beams)] for ex in range(batch_size)]\n    examples = []\n    for ex in range(batch_size):\n        examples.append(np.vstack([samples[ex][ii] for ii in range(num_beams)]))\n    return examples",
            "def reformat_samples(seq2seq_obj, num_beams, batch_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    samples = [[seq2seq_obj.candidates[bb][:, ex] for bb in range(num_beams)] for ex in range(batch_size)]\n    examples = []\n    for ex in range(batch_size):\n        examples.append(np.vstack([samples[ex][ii] for ii in range(num_beams)]))\n    return examples",
            "def reformat_samples(seq2seq_obj, num_beams, batch_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    samples = [[seq2seq_obj.candidates[bb][:, ex] for bb in range(num_beams)] for ex in range(batch_size)]\n    examples = []\n    for ex in range(batch_size):\n        examples.append(np.vstack([samples[ex][ii] for ii in range(num_beams)]))\n    return examples",
            "def reformat_samples(seq2seq_obj, num_beams, batch_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    samples = [[seq2seq_obj.candidates[bb][:, ex] for bb in range(num_beams)] for ex in range(batch_size)]\n    examples = []\n    for ex in range(batch_size):\n        examples.append(np.vstack([samples[ex][ii] for ii in range(num_beams)]))\n    return examples",
            "def reformat_samples(seq2seq_obj, num_beams, batch_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    samples = [[seq2seq_obj.candidates[bb][:, ex] for bb in range(num_beams)] for ex in range(batch_size)]\n    examples = []\n    for ex in range(batch_size):\n        examples.append(np.vstack([samples[ex][ii] for ii in range(num_beams)]))\n    return examples"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.i = -1\n    z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n    z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n    z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n    z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n    z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n    z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n    z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n    z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n    self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.i = -1\n    z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n    z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n    z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n    z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n    z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n    z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n    z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n    z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n    self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.i = -1\n    z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n    z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n    z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n    z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n    z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n    z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n    z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n    z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n    self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.i = -1\n    z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n    z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n    z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n    z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n    z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n    z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n    z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n    z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n    self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.i = -1\n    z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n    z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n    z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n    z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n    z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n    z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n    z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n    z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n    self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.i = -1\n    z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n    z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n    z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n    z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n    z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n    z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n    z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n    z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n    z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n    self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]"
        ]
    },
    {
        "func_name": "fprop",
        "original": "def fprop(self, z, inference=True, init_state=None):\n    self.i += 1\n    return self.z_list[self.i]",
        "mutated": [
            "def fprop(self, z, inference=True, init_state=None):\n    if False:\n        i = 10\n    self.i += 1\n    return self.z_list[self.i]",
            "def fprop(self, z, inference=True, init_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.i += 1\n    return self.z_list[self.i]",
            "def fprop(self, z, inference=True, init_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.i += 1\n    return self.z_list[self.i]",
            "def fprop(self, z, inference=True, init_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.i += 1\n    return self.z_list[self.i]",
            "def fprop(self, z, inference=True, init_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.i += 1\n    return self.z_list[self.i]"
        ]
    },
    {
        "func_name": "final_state",
        "original": "def final_state():\n    return be.zeros_like(decoder.h[-1])",
        "mutated": [
            "def final_state():\n    if False:\n        i = 10\n    return be.zeros_like(decoder.h[-1])",
            "def final_state():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return be.zeros_like(decoder.h[-1])",
            "def final_state():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return be.zeros_like(decoder.h[-1])",
            "def final_state():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return be.zeros_like(decoder.h[-1])",
            "def final_state():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return be.zeros_like(decoder.h[-1])"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.shape = (nout, time_steps)\n    self.decoder_shape = (nout, time_steps)",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.shape = (nout, time_steps)\n    self.decoder_shape = (nout, time_steps)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.shape = (nout, time_steps)\n    self.decoder_shape = (nout, time_steps)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.shape = (nout, time_steps)\n    self.decoder_shape = (nout, time_steps)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.shape = (nout, time_steps)\n    self.decoder_shape = (nout, time_steps)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.shape = (nout, time_steps)\n    self.decoder_shape = (nout, time_steps)"
        ]
    },
    {
        "func_name": "test_beamsearch",
        "original": "def test_beamsearch(backend_default):\n    \"\"\"\n    Simlulated beam search on a minibatch of 2, for 4 time steps. The\n    LSTM states are real but the \"softmax outputs\" z are hardcoded and\n    not taken from  the network.\n    There are 6 tokens the network outputs, and they have probabilities\n    like exp(1), exp(5), exp(7)\n\n    The test asserts that the score_lists assigned by _beamsearch_step(z_list)\n    are equal to the probabilities computed manually adding probabilities\n    to z_list.\n    \"\"\"\n    be = backend_default\n    batch_size = 2\n    be.bsz = batch_size\n    time_steps = 4\n    nout = 6\n    num_beams = 3\n    activation = Tanh()\n    gate_activation = Logistic()\n    init_ary = np.eye(nout)\n    init = Array(init_ary)\n    encoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Enc')\n    decoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Dec')\n\n    class DummyFProp:\n        \"\"\"\n        Constructs an artificial beam search example with known correct outputs.\n        This is called inside a nested loop over steps, num_life. In the first\n        time step there is one life beam, after that, 3 life beams per step.\n        There are 4 time steps total. Each beamsearch_step builds one list over\n        num_life beams.\n\n        At t=0, the winners for ex0 are 1, 4, 5 (indexed by their position) and\n        winners for ex1 are 2,4,5. From there we continue the beam for ex0:\n            12, 13, 14              6+2=8 6+3=9  6+2=8\n            40, 43, 45  with scores 5+4=9 5+3=8  5+7=12 three new winners 45, 52, 55\n            50, 52, 55              5+4=9 5+6=11 5+5=10\n\n        for ex2\n            1 4 5  with scores   5 4 7\n        we get the three winners 1, 4, 5 and continue (just taking the\n        3 in order, no sorting)\n            10 12 13 14 (not unique!)  5+2=7  5+2=7  5+3=8\n            41 42 43       with scores 4+6=10 4+5=9  4+7=11 winners  43 51 52\n            51 52 53                   7+4=11 7+6=13 7+3=10 scores   11 11 13\n        continue from the three winners 43 51 52\n            431 433 434             11+10=21 11+3=14 11+9=20\n            511 512 513 with scores 11+6=17  11+5=16 11+7=18  winners 431 434 520\n            520 521 522             13+8=21  13+4=17 13+6=19  scores   21  20  21\n        continue from three winners 431 511 513 (going along beams, the matches\n        in a beam)\n            4310 4312 4313 4314             21+2=23  21+2=23 21+3=24 21+10=31 (not unique!)\n            4341 4342 4343      with scores 20+10=30 20+5=25 20+7=27        winners 4314 4341 5204\n            5200 5202 5204                  21+8=29  21+6=27 21+10=31       scores    31   30   31\n        overall winners are 4314 4341 5204\n\n        \"\"\"\n\n        def __init__(self):\n            self.i = -1\n            z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n            z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n            z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n            z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n            z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n            z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n            z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n            z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n            self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]\n\n        def fprop(self, z, inference=True, init_state=None):\n            self.i += 1\n            return self.z_list[self.i]\n\n    def final_state():\n        return be.zeros_like(decoder.h[-1])\n\n    class InObj(NervanaObject):\n\n        def __init__(self):\n            self.shape = (nout, time_steps)\n            self.decoder_shape = (nout, time_steps)\n    decoder.fprop = DummyFProp().fprop\n    layers = Seq2Seq([encoder, decoder], decoder_connections=[0])\n    layers.decoder._recurrent[0].final_state = final_state\n    in_obj = InObj()\n    layers.configure(in_obj)\n    layers.allocate()\n    layers.allocate_deltas(None)\n    beamsearch = BeamSearch(layers)\n    inputs = be.iobuf(in_obj.shape)\n    beamsearch.beamsearch(inputs, num_beams=num_beams)\n    ex0 = np.array([[1, 5, 4, 1], [1, 2, 1, 5], [1, 5, 3, 4]])\n    ex1 = np.array([[5, 1, 4, 4], [5, 1, 1, 1], [5, 2, 0, 4]])\n    examples = reformat_samples(beamsearch, num_beams, batch_size)\n    assert allclose_with_out(examples[0], ex0)\n    assert allclose_with_out(examples[1], ex1)",
        "mutated": [
            "def test_beamsearch(backend_default):\n    if False:\n        i = 10\n    '\\n    Simlulated beam search on a minibatch of 2, for 4 time steps. The\\n    LSTM states are real but the \"softmax outputs\" z are hardcoded and\\n    not taken from  the network.\\n    There are 6 tokens the network outputs, and they have probabilities\\n    like exp(1), exp(5), exp(7)\\n\\n    The test asserts that the score_lists assigned by _beamsearch_step(z_list)\\n    are equal to the probabilities computed manually adding probabilities\\n    to z_list.\\n    '\n    be = backend_default\n    batch_size = 2\n    be.bsz = batch_size\n    time_steps = 4\n    nout = 6\n    num_beams = 3\n    activation = Tanh()\n    gate_activation = Logistic()\n    init_ary = np.eye(nout)\n    init = Array(init_ary)\n    encoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Enc')\n    decoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Dec')\n\n    class DummyFProp:\n        \"\"\"\n        Constructs an artificial beam search example with known correct outputs.\n        This is called inside a nested loop over steps, num_life. In the first\n        time step there is one life beam, after that, 3 life beams per step.\n        There are 4 time steps total. Each beamsearch_step builds one list over\n        num_life beams.\n\n        At t=0, the winners for ex0 are 1, 4, 5 (indexed by their position) and\n        winners for ex1 are 2,4,5. From there we continue the beam for ex0:\n            12, 13, 14              6+2=8 6+3=9  6+2=8\n            40, 43, 45  with scores 5+4=9 5+3=8  5+7=12 three new winners 45, 52, 55\n            50, 52, 55              5+4=9 5+6=11 5+5=10\n\n        for ex2\n            1 4 5  with scores   5 4 7\n        we get the three winners 1, 4, 5 and continue (just taking the\n        3 in order, no sorting)\n            10 12 13 14 (not unique!)  5+2=7  5+2=7  5+3=8\n            41 42 43       with scores 4+6=10 4+5=9  4+7=11 winners  43 51 52\n            51 52 53                   7+4=11 7+6=13 7+3=10 scores   11 11 13\n        continue from the three winners 43 51 52\n            431 433 434             11+10=21 11+3=14 11+9=20\n            511 512 513 with scores 11+6=17  11+5=16 11+7=18  winners 431 434 520\n            520 521 522             13+8=21  13+4=17 13+6=19  scores   21  20  21\n        continue from three winners 431 511 513 (going along beams, the matches\n        in a beam)\n            4310 4312 4313 4314             21+2=23  21+2=23 21+3=24 21+10=31 (not unique!)\n            4341 4342 4343      with scores 20+10=30 20+5=25 20+7=27        winners 4314 4341 5204\n            5200 5202 5204                  21+8=29  21+6=27 21+10=31       scores    31   30   31\n        overall winners are 4314 4341 5204\n\n        \"\"\"\n\n        def __init__(self):\n            self.i = -1\n            z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n            z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n            z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n            z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n            z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n            z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n            z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n            z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n            self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]\n\n        def fprop(self, z, inference=True, init_state=None):\n            self.i += 1\n            return self.z_list[self.i]\n\n    def final_state():\n        return be.zeros_like(decoder.h[-1])\n\n    class InObj(NervanaObject):\n\n        def __init__(self):\n            self.shape = (nout, time_steps)\n            self.decoder_shape = (nout, time_steps)\n    decoder.fprop = DummyFProp().fprop\n    layers = Seq2Seq([encoder, decoder], decoder_connections=[0])\n    layers.decoder._recurrent[0].final_state = final_state\n    in_obj = InObj()\n    layers.configure(in_obj)\n    layers.allocate()\n    layers.allocate_deltas(None)\n    beamsearch = BeamSearch(layers)\n    inputs = be.iobuf(in_obj.shape)\n    beamsearch.beamsearch(inputs, num_beams=num_beams)\n    ex0 = np.array([[1, 5, 4, 1], [1, 2, 1, 5], [1, 5, 3, 4]])\n    ex1 = np.array([[5, 1, 4, 4], [5, 1, 1, 1], [5, 2, 0, 4]])\n    examples = reformat_samples(beamsearch, num_beams, batch_size)\n    assert allclose_with_out(examples[0], ex0)\n    assert allclose_with_out(examples[1], ex1)",
            "def test_beamsearch(backend_default):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Simlulated beam search on a minibatch of 2, for 4 time steps. The\\n    LSTM states are real but the \"softmax outputs\" z are hardcoded and\\n    not taken from  the network.\\n    There are 6 tokens the network outputs, and they have probabilities\\n    like exp(1), exp(5), exp(7)\\n\\n    The test asserts that the score_lists assigned by _beamsearch_step(z_list)\\n    are equal to the probabilities computed manually adding probabilities\\n    to z_list.\\n    '\n    be = backend_default\n    batch_size = 2\n    be.bsz = batch_size\n    time_steps = 4\n    nout = 6\n    num_beams = 3\n    activation = Tanh()\n    gate_activation = Logistic()\n    init_ary = np.eye(nout)\n    init = Array(init_ary)\n    encoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Enc')\n    decoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Dec')\n\n    class DummyFProp:\n        \"\"\"\n        Constructs an artificial beam search example with known correct outputs.\n        This is called inside a nested loop over steps, num_life. In the first\n        time step there is one life beam, after that, 3 life beams per step.\n        There are 4 time steps total. Each beamsearch_step builds one list over\n        num_life beams.\n\n        At t=0, the winners for ex0 are 1, 4, 5 (indexed by their position) and\n        winners for ex1 are 2,4,5. From there we continue the beam for ex0:\n            12, 13, 14              6+2=8 6+3=9  6+2=8\n            40, 43, 45  with scores 5+4=9 5+3=8  5+7=12 three new winners 45, 52, 55\n            50, 52, 55              5+4=9 5+6=11 5+5=10\n\n        for ex2\n            1 4 5  with scores   5 4 7\n        we get the three winners 1, 4, 5 and continue (just taking the\n        3 in order, no sorting)\n            10 12 13 14 (not unique!)  5+2=7  5+2=7  5+3=8\n            41 42 43       with scores 4+6=10 4+5=9  4+7=11 winners  43 51 52\n            51 52 53                   7+4=11 7+6=13 7+3=10 scores   11 11 13\n        continue from the three winners 43 51 52\n            431 433 434             11+10=21 11+3=14 11+9=20\n            511 512 513 with scores 11+6=17  11+5=16 11+7=18  winners 431 434 520\n            520 521 522             13+8=21  13+4=17 13+6=19  scores   21  20  21\n        continue from three winners 431 511 513 (going along beams, the matches\n        in a beam)\n            4310 4312 4313 4314             21+2=23  21+2=23 21+3=24 21+10=31 (not unique!)\n            4341 4342 4343      with scores 20+10=30 20+5=25 20+7=27        winners 4314 4341 5204\n            5200 5202 5204                  21+8=29  21+6=27 21+10=31       scores    31   30   31\n        overall winners are 4314 4341 5204\n\n        \"\"\"\n\n        def __init__(self):\n            self.i = -1\n            z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n            z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n            z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n            z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n            z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n            z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n            z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n            z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n            self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]\n\n        def fprop(self, z, inference=True, init_state=None):\n            self.i += 1\n            return self.z_list[self.i]\n\n    def final_state():\n        return be.zeros_like(decoder.h[-1])\n\n    class InObj(NervanaObject):\n\n        def __init__(self):\n            self.shape = (nout, time_steps)\n            self.decoder_shape = (nout, time_steps)\n    decoder.fprop = DummyFProp().fprop\n    layers = Seq2Seq([encoder, decoder], decoder_connections=[0])\n    layers.decoder._recurrent[0].final_state = final_state\n    in_obj = InObj()\n    layers.configure(in_obj)\n    layers.allocate()\n    layers.allocate_deltas(None)\n    beamsearch = BeamSearch(layers)\n    inputs = be.iobuf(in_obj.shape)\n    beamsearch.beamsearch(inputs, num_beams=num_beams)\n    ex0 = np.array([[1, 5, 4, 1], [1, 2, 1, 5], [1, 5, 3, 4]])\n    ex1 = np.array([[5, 1, 4, 4], [5, 1, 1, 1], [5, 2, 0, 4]])\n    examples = reformat_samples(beamsearch, num_beams, batch_size)\n    assert allclose_with_out(examples[0], ex0)\n    assert allclose_with_out(examples[1], ex1)",
            "def test_beamsearch(backend_default):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Simlulated beam search on a minibatch of 2, for 4 time steps. The\\n    LSTM states are real but the \"softmax outputs\" z are hardcoded and\\n    not taken from  the network.\\n    There are 6 tokens the network outputs, and they have probabilities\\n    like exp(1), exp(5), exp(7)\\n\\n    The test asserts that the score_lists assigned by _beamsearch_step(z_list)\\n    are equal to the probabilities computed manually adding probabilities\\n    to z_list.\\n    '\n    be = backend_default\n    batch_size = 2\n    be.bsz = batch_size\n    time_steps = 4\n    nout = 6\n    num_beams = 3\n    activation = Tanh()\n    gate_activation = Logistic()\n    init_ary = np.eye(nout)\n    init = Array(init_ary)\n    encoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Enc')\n    decoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Dec')\n\n    class DummyFProp:\n        \"\"\"\n        Constructs an artificial beam search example with known correct outputs.\n        This is called inside a nested loop over steps, num_life. In the first\n        time step there is one life beam, after that, 3 life beams per step.\n        There are 4 time steps total. Each beamsearch_step builds one list over\n        num_life beams.\n\n        At t=0, the winners for ex0 are 1, 4, 5 (indexed by their position) and\n        winners for ex1 are 2,4,5. From there we continue the beam for ex0:\n            12, 13, 14              6+2=8 6+3=9  6+2=8\n            40, 43, 45  with scores 5+4=9 5+3=8  5+7=12 three new winners 45, 52, 55\n            50, 52, 55              5+4=9 5+6=11 5+5=10\n\n        for ex2\n            1 4 5  with scores   5 4 7\n        we get the three winners 1, 4, 5 and continue (just taking the\n        3 in order, no sorting)\n            10 12 13 14 (not unique!)  5+2=7  5+2=7  5+3=8\n            41 42 43       with scores 4+6=10 4+5=9  4+7=11 winners  43 51 52\n            51 52 53                   7+4=11 7+6=13 7+3=10 scores   11 11 13\n        continue from the three winners 43 51 52\n            431 433 434             11+10=21 11+3=14 11+9=20\n            511 512 513 with scores 11+6=17  11+5=16 11+7=18  winners 431 434 520\n            520 521 522             13+8=21  13+4=17 13+6=19  scores   21  20  21\n        continue from three winners 431 511 513 (going along beams, the matches\n        in a beam)\n            4310 4312 4313 4314             21+2=23  21+2=23 21+3=24 21+10=31 (not unique!)\n            4341 4342 4343      with scores 20+10=30 20+5=25 20+7=27        winners 4314 4341 5204\n            5200 5202 5204                  21+8=29  21+6=27 21+10=31       scores    31   30   31\n        overall winners are 4314 4341 5204\n\n        \"\"\"\n\n        def __init__(self):\n            self.i = -1\n            z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n            z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n            z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n            z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n            z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n            z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n            z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n            z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n            self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]\n\n        def fprop(self, z, inference=True, init_state=None):\n            self.i += 1\n            return self.z_list[self.i]\n\n    def final_state():\n        return be.zeros_like(decoder.h[-1])\n\n    class InObj(NervanaObject):\n\n        def __init__(self):\n            self.shape = (nout, time_steps)\n            self.decoder_shape = (nout, time_steps)\n    decoder.fprop = DummyFProp().fprop\n    layers = Seq2Seq([encoder, decoder], decoder_connections=[0])\n    layers.decoder._recurrent[0].final_state = final_state\n    in_obj = InObj()\n    layers.configure(in_obj)\n    layers.allocate()\n    layers.allocate_deltas(None)\n    beamsearch = BeamSearch(layers)\n    inputs = be.iobuf(in_obj.shape)\n    beamsearch.beamsearch(inputs, num_beams=num_beams)\n    ex0 = np.array([[1, 5, 4, 1], [1, 2, 1, 5], [1, 5, 3, 4]])\n    ex1 = np.array([[5, 1, 4, 4], [5, 1, 1, 1], [5, 2, 0, 4]])\n    examples = reformat_samples(beamsearch, num_beams, batch_size)\n    assert allclose_with_out(examples[0], ex0)\n    assert allclose_with_out(examples[1], ex1)",
            "def test_beamsearch(backend_default):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Simlulated beam search on a minibatch of 2, for 4 time steps. The\\n    LSTM states are real but the \"softmax outputs\" z are hardcoded and\\n    not taken from  the network.\\n    There are 6 tokens the network outputs, and they have probabilities\\n    like exp(1), exp(5), exp(7)\\n\\n    The test asserts that the score_lists assigned by _beamsearch_step(z_list)\\n    are equal to the probabilities computed manually adding probabilities\\n    to z_list.\\n    '\n    be = backend_default\n    batch_size = 2\n    be.bsz = batch_size\n    time_steps = 4\n    nout = 6\n    num_beams = 3\n    activation = Tanh()\n    gate_activation = Logistic()\n    init_ary = np.eye(nout)\n    init = Array(init_ary)\n    encoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Enc')\n    decoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Dec')\n\n    class DummyFProp:\n        \"\"\"\n        Constructs an artificial beam search example with known correct outputs.\n        This is called inside a nested loop over steps, num_life. In the first\n        time step there is one life beam, after that, 3 life beams per step.\n        There are 4 time steps total. Each beamsearch_step builds one list over\n        num_life beams.\n\n        At t=0, the winners for ex0 are 1, 4, 5 (indexed by their position) and\n        winners for ex1 are 2,4,5. From there we continue the beam for ex0:\n            12, 13, 14              6+2=8 6+3=9  6+2=8\n            40, 43, 45  with scores 5+4=9 5+3=8  5+7=12 three new winners 45, 52, 55\n            50, 52, 55              5+4=9 5+6=11 5+5=10\n\n        for ex2\n            1 4 5  with scores   5 4 7\n        we get the three winners 1, 4, 5 and continue (just taking the\n        3 in order, no sorting)\n            10 12 13 14 (not unique!)  5+2=7  5+2=7  5+3=8\n            41 42 43       with scores 4+6=10 4+5=9  4+7=11 winners  43 51 52\n            51 52 53                   7+4=11 7+6=13 7+3=10 scores   11 11 13\n        continue from the three winners 43 51 52\n            431 433 434             11+10=21 11+3=14 11+9=20\n            511 512 513 with scores 11+6=17  11+5=16 11+7=18  winners 431 434 520\n            520 521 522             13+8=21  13+4=17 13+6=19  scores   21  20  21\n        continue from three winners 431 511 513 (going along beams, the matches\n        in a beam)\n            4310 4312 4313 4314             21+2=23  21+2=23 21+3=24 21+10=31 (not unique!)\n            4341 4342 4343      with scores 20+10=30 20+5=25 20+7=27        winners 4314 4341 5204\n            5200 5202 5204                  21+8=29  21+6=27 21+10=31       scores    31   30   31\n        overall winners are 4314 4341 5204\n\n        \"\"\"\n\n        def __init__(self):\n            self.i = -1\n            z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n            z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n            z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n            z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n            z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n            z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n            z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n            z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n            self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]\n\n        def fprop(self, z, inference=True, init_state=None):\n            self.i += 1\n            return self.z_list[self.i]\n\n    def final_state():\n        return be.zeros_like(decoder.h[-1])\n\n    class InObj(NervanaObject):\n\n        def __init__(self):\n            self.shape = (nout, time_steps)\n            self.decoder_shape = (nout, time_steps)\n    decoder.fprop = DummyFProp().fprop\n    layers = Seq2Seq([encoder, decoder], decoder_connections=[0])\n    layers.decoder._recurrent[0].final_state = final_state\n    in_obj = InObj()\n    layers.configure(in_obj)\n    layers.allocate()\n    layers.allocate_deltas(None)\n    beamsearch = BeamSearch(layers)\n    inputs = be.iobuf(in_obj.shape)\n    beamsearch.beamsearch(inputs, num_beams=num_beams)\n    ex0 = np.array([[1, 5, 4, 1], [1, 2, 1, 5], [1, 5, 3, 4]])\n    ex1 = np.array([[5, 1, 4, 4], [5, 1, 1, 1], [5, 2, 0, 4]])\n    examples = reformat_samples(beamsearch, num_beams, batch_size)\n    assert allclose_with_out(examples[0], ex0)\n    assert allclose_with_out(examples[1], ex1)",
            "def test_beamsearch(backend_default):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Simlulated beam search on a minibatch of 2, for 4 time steps. The\\n    LSTM states are real but the \"softmax outputs\" z are hardcoded and\\n    not taken from  the network.\\n    There are 6 tokens the network outputs, and they have probabilities\\n    like exp(1), exp(5), exp(7)\\n\\n    The test asserts that the score_lists assigned by _beamsearch_step(z_list)\\n    are equal to the probabilities computed manually adding probabilities\\n    to z_list.\\n    '\n    be = backend_default\n    batch_size = 2\n    be.bsz = batch_size\n    time_steps = 4\n    nout = 6\n    num_beams = 3\n    activation = Tanh()\n    gate_activation = Logistic()\n    init_ary = np.eye(nout)\n    init = Array(init_ary)\n    encoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Enc')\n    decoder = LSTM(nout, init, activation=activation, gate_activation=gate_activation, name='Dec')\n\n    class DummyFProp:\n        \"\"\"\n        Constructs an artificial beam search example with known correct outputs.\n        This is called inside a nested loop over steps, num_life. In the first\n        time step there is one life beam, after that, 3 life beams per step.\n        There are 4 time steps total. Each beamsearch_step builds one list over\n        num_life beams.\n\n        At t=0, the winners for ex0 are 1, 4, 5 (indexed by their position) and\n        winners for ex1 are 2,4,5. From there we continue the beam for ex0:\n            12, 13, 14              6+2=8 6+3=9  6+2=8\n            40, 43, 45  with scores 5+4=9 5+3=8  5+7=12 three new winners 45, 52, 55\n            50, 52, 55              5+4=9 5+6=11 5+5=10\n\n        for ex2\n            1 4 5  with scores   5 4 7\n        we get the three winners 1, 4, 5 and continue (just taking the\n        3 in order, no sorting)\n            10 12 13 14 (not unique!)  5+2=7  5+2=7  5+3=8\n            41 42 43       with scores 4+6=10 4+5=9  4+7=11 winners  43 51 52\n            51 52 53                   7+4=11 7+6=13 7+3=10 scores   11 11 13\n        continue from the three winners 43 51 52\n            431 433 434             11+10=21 11+3=14 11+9=20\n            511 512 513 with scores 11+6=17  11+5=16 11+7=18  winners 431 434 520\n            520 521 522             13+8=21  13+4=17 13+6=19  scores   21  20  21\n        continue from three winners 431 511 513 (going along beams, the matches\n        in a beam)\n            4310 4312 4313 4314             21+2=23  21+2=23 21+3=24 21+10=31 (not unique!)\n            4341 4342 4343      with scores 20+10=30 20+5=25 20+7=27        winners 4314 4341 5204\n            5200 5202 5204                  21+8=29  21+6=27 21+10=31       scores    31   30   31\n        overall winners are 4314 4341 5204\n\n        \"\"\"\n\n        def __init__(self):\n            self.i = -1\n            z = be.array(np.exp(np.array([[1, 6, 2, 1, 5, 5], [1, 5, 2, 2, 4, 7]]))).T\n            z1 = be.array(np.exp(np.array([[1, 1, 2, 3, 2, 1], [2, 1, 2, 3, 2, 1]]))).T\n            z2 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z3 = be.array(np.exp(np.array([[4, 1, 6, 3, 1, 5], [1, 4, 6, 3, 2, 1]]))).T\n            z4 = be.array(np.exp(np.array([[1, 1, 2, 10, 9, 1], [2, 10, 2, 3, 9, 1]]))).T\n            z5 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 7], [2, 6, 5, 7, 2, 4]]))).T\n            z6 = be.array(np.exp(np.array([[4, 8, 6, 3, 1, 5], [8, 4, 6, 3, 1, 1]]))).T\n            z7 = be.array(np.exp(np.array([[1, 10, 2, 1, 1, 1], [2, 1, 2, 3, 10, 1]]))).T\n            z8 = be.array(np.exp(np.array([[4, 1, 2, 3, 1, 10], [2, 10, 5, 7, 2, 4]]))).T\n            z9 = be.array(np.exp(np.array([[4, 8, 6, 3, 10, 5], [8, 4, 6, 3, 10, 1]]))).T\n            self.z_list = [z, z1, z2, z3, z4, z5, z6, z7, z8, z9]\n\n        def fprop(self, z, inference=True, init_state=None):\n            self.i += 1\n            return self.z_list[self.i]\n\n    def final_state():\n        return be.zeros_like(decoder.h[-1])\n\n    class InObj(NervanaObject):\n\n        def __init__(self):\n            self.shape = (nout, time_steps)\n            self.decoder_shape = (nout, time_steps)\n    decoder.fprop = DummyFProp().fprop\n    layers = Seq2Seq([encoder, decoder], decoder_connections=[0])\n    layers.decoder._recurrent[0].final_state = final_state\n    in_obj = InObj()\n    layers.configure(in_obj)\n    layers.allocate()\n    layers.allocate_deltas(None)\n    beamsearch = BeamSearch(layers)\n    inputs = be.iobuf(in_obj.shape)\n    beamsearch.beamsearch(inputs, num_beams=num_beams)\n    ex0 = np.array([[1, 5, 4, 1], [1, 2, 1, 5], [1, 5, 3, 4]])\n    ex1 = np.array([[5, 1, 4, 4], [5, 1, 1, 1], [5, 2, 0, 4]])\n    examples = reformat_samples(beamsearch, num_beams, batch_size)\n    assert allclose_with_out(examples[0], ex0)\n    assert allclose_with_out(examples[1], ex1)"
        ]
    }
]