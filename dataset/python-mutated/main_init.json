[
    {
        "func_name": "configure_parser",
        "original": "def configure_parser(sub_parsers: _SubParsersAction, **kwargs) -> ArgumentParser:\n    from ..auxlib.ish import dals\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..common.compat import on_win\n    from ..common.constants import NULL\n    from .helpers import add_parser_json\n    summary = 'Initialize conda for shell interaction.'\n    description = summary\n    epilog = dals(\"\\n        Key parts of conda's functionality require that it interact directly with the shell\\n        within which conda is being invoked. The `conda activate` and `conda deactivate` commands\\n        specifically are shell-level commands. That is, they affect the state (e.g. environment\\n        variables) of the shell context being interacted with. Other core commands, like\\n        `conda create` and `conda install`, also necessarily interact with the shell environment.\\n        They're therefore implemented in ways specific to each shell. Each shell must be configured\\n        to make use of them.\\n\\n        This command makes changes to your system that are specific and customized for each shell.\\n        To see the specific files and locations on your system that will be affected before, use\\n        the '--dry-run' flag.  To see the exact changes that are being or will be made to each\\n        location, use the '--verbose' flag.\\n\\n        IMPORTANT: After running `conda init`, most shells will need to be closed and restarted for\\n        changes to take effect.\\n\\n        \")\n    p = sub_parsers.add_parser('init', help=summary, description=description, epilog=epilog, **kwargs)\n    p.add_argument('--dev', action='store_true', help=SUPPRESS, default=NULL)\n    p.add_argument('--all', action='store_true', help='Initialize all currently available shells.', default=NULL)\n    setup_type_group = p.add_argument_group('setup type')\n    setup_type_group.add_argument('--install', action='store_true', help=SUPPRESS, default=NULL)\n    setup_type_group.add_argument('--user', action='store_true', dest='user', help='Initialize conda for the current user (default).', default=True)\n    setup_type_group.add_argument('--no-user', action='store_false', dest='user', help=\"Don't initialize conda for the current user.\")\n    setup_type_group.add_argument('--system', action='store_true', help='Initialize conda for all users on the system.', default=NULL)\n    setup_type_group.add_argument('--reverse', action='store_true', help='Undo effects of last conda init.', default=NULL)\n    p.add_argument('shells', nargs='*', choices=COMPATIBLE_SHELLS, metavar='SHELLS', help=f\"One or more shells to be initialized. If not given, the default value is 'bash' on unix and 'cmd.exe' & 'powershell' on Windows. Use the '--all' flag to initialize all shells. Available shells: {sorted(COMPATIBLE_SHELLS)}\", default=['cmd.exe', 'powershell'] if on_win else ['bash'])\n    if on_win:\n        p.add_argument('--anaconda-prompt', action='store_true', help=\"Add an 'Anaconda Prompt' icon to your desktop.\", default=NULL)\n    add_parser_json(p)\n    p.add_argument('-d', '--dry-run', action='store_true', help='Only display what would have been done.')\n    p.set_defaults(func='conda.cli.main_init.execute')\n    return p",
        "mutated": [
            "def configure_parser(sub_parsers: _SubParsersAction, **kwargs) -> ArgumentParser:\n    if False:\n        i = 10\n    from ..auxlib.ish import dals\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..common.compat import on_win\n    from ..common.constants import NULL\n    from .helpers import add_parser_json\n    summary = 'Initialize conda for shell interaction.'\n    description = summary\n    epilog = dals(\"\\n        Key parts of conda's functionality require that it interact directly with the shell\\n        within which conda is being invoked. The `conda activate` and `conda deactivate` commands\\n        specifically are shell-level commands. That is, they affect the state (e.g. environment\\n        variables) of the shell context being interacted with. Other core commands, like\\n        `conda create` and `conda install`, also necessarily interact with the shell environment.\\n        They're therefore implemented in ways specific to each shell. Each shell must be configured\\n        to make use of them.\\n\\n        This command makes changes to your system that are specific and customized for each shell.\\n        To see the specific files and locations on your system that will be affected before, use\\n        the '--dry-run' flag.  To see the exact changes that are being or will be made to each\\n        location, use the '--verbose' flag.\\n\\n        IMPORTANT: After running `conda init`, most shells will need to be closed and restarted for\\n        changes to take effect.\\n\\n        \")\n    p = sub_parsers.add_parser('init', help=summary, description=description, epilog=epilog, **kwargs)\n    p.add_argument('--dev', action='store_true', help=SUPPRESS, default=NULL)\n    p.add_argument('--all', action='store_true', help='Initialize all currently available shells.', default=NULL)\n    setup_type_group = p.add_argument_group('setup type')\n    setup_type_group.add_argument('--install', action='store_true', help=SUPPRESS, default=NULL)\n    setup_type_group.add_argument('--user', action='store_true', dest='user', help='Initialize conda for the current user (default).', default=True)\n    setup_type_group.add_argument('--no-user', action='store_false', dest='user', help=\"Don't initialize conda for the current user.\")\n    setup_type_group.add_argument('--system', action='store_true', help='Initialize conda for all users on the system.', default=NULL)\n    setup_type_group.add_argument('--reverse', action='store_true', help='Undo effects of last conda init.', default=NULL)\n    p.add_argument('shells', nargs='*', choices=COMPATIBLE_SHELLS, metavar='SHELLS', help=f\"One or more shells to be initialized. If not given, the default value is 'bash' on unix and 'cmd.exe' & 'powershell' on Windows. Use the '--all' flag to initialize all shells. Available shells: {sorted(COMPATIBLE_SHELLS)}\", default=['cmd.exe', 'powershell'] if on_win else ['bash'])\n    if on_win:\n        p.add_argument('--anaconda-prompt', action='store_true', help=\"Add an 'Anaconda Prompt' icon to your desktop.\", default=NULL)\n    add_parser_json(p)\n    p.add_argument('-d', '--dry-run', action='store_true', help='Only display what would have been done.')\n    p.set_defaults(func='conda.cli.main_init.execute')\n    return p",
            "def configure_parser(sub_parsers: _SubParsersAction, **kwargs) -> ArgumentParser:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from ..auxlib.ish import dals\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..common.compat import on_win\n    from ..common.constants import NULL\n    from .helpers import add_parser_json\n    summary = 'Initialize conda for shell interaction.'\n    description = summary\n    epilog = dals(\"\\n        Key parts of conda's functionality require that it interact directly with the shell\\n        within which conda is being invoked. The `conda activate` and `conda deactivate` commands\\n        specifically are shell-level commands. That is, they affect the state (e.g. environment\\n        variables) of the shell context being interacted with. Other core commands, like\\n        `conda create` and `conda install`, also necessarily interact with the shell environment.\\n        They're therefore implemented in ways specific to each shell. Each shell must be configured\\n        to make use of them.\\n\\n        This command makes changes to your system that are specific and customized for each shell.\\n        To see the specific files and locations on your system that will be affected before, use\\n        the '--dry-run' flag.  To see the exact changes that are being or will be made to each\\n        location, use the '--verbose' flag.\\n\\n        IMPORTANT: After running `conda init`, most shells will need to be closed and restarted for\\n        changes to take effect.\\n\\n        \")\n    p = sub_parsers.add_parser('init', help=summary, description=description, epilog=epilog, **kwargs)\n    p.add_argument('--dev', action='store_true', help=SUPPRESS, default=NULL)\n    p.add_argument('--all', action='store_true', help='Initialize all currently available shells.', default=NULL)\n    setup_type_group = p.add_argument_group('setup type')\n    setup_type_group.add_argument('--install', action='store_true', help=SUPPRESS, default=NULL)\n    setup_type_group.add_argument('--user', action='store_true', dest='user', help='Initialize conda for the current user (default).', default=True)\n    setup_type_group.add_argument('--no-user', action='store_false', dest='user', help=\"Don't initialize conda for the current user.\")\n    setup_type_group.add_argument('--system', action='store_true', help='Initialize conda for all users on the system.', default=NULL)\n    setup_type_group.add_argument('--reverse', action='store_true', help='Undo effects of last conda init.', default=NULL)\n    p.add_argument('shells', nargs='*', choices=COMPATIBLE_SHELLS, metavar='SHELLS', help=f\"One or more shells to be initialized. If not given, the default value is 'bash' on unix and 'cmd.exe' & 'powershell' on Windows. Use the '--all' flag to initialize all shells. Available shells: {sorted(COMPATIBLE_SHELLS)}\", default=['cmd.exe', 'powershell'] if on_win else ['bash'])\n    if on_win:\n        p.add_argument('--anaconda-prompt', action='store_true', help=\"Add an 'Anaconda Prompt' icon to your desktop.\", default=NULL)\n    add_parser_json(p)\n    p.add_argument('-d', '--dry-run', action='store_true', help='Only display what would have been done.')\n    p.set_defaults(func='conda.cli.main_init.execute')\n    return p",
            "def configure_parser(sub_parsers: _SubParsersAction, **kwargs) -> ArgumentParser:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from ..auxlib.ish import dals\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..common.compat import on_win\n    from ..common.constants import NULL\n    from .helpers import add_parser_json\n    summary = 'Initialize conda for shell interaction.'\n    description = summary\n    epilog = dals(\"\\n        Key parts of conda's functionality require that it interact directly with the shell\\n        within which conda is being invoked. The `conda activate` and `conda deactivate` commands\\n        specifically are shell-level commands. That is, they affect the state (e.g. environment\\n        variables) of the shell context being interacted with. Other core commands, like\\n        `conda create` and `conda install`, also necessarily interact with the shell environment.\\n        They're therefore implemented in ways specific to each shell. Each shell must be configured\\n        to make use of them.\\n\\n        This command makes changes to your system that are specific and customized for each shell.\\n        To see the specific files and locations on your system that will be affected before, use\\n        the '--dry-run' flag.  To see the exact changes that are being or will be made to each\\n        location, use the '--verbose' flag.\\n\\n        IMPORTANT: After running `conda init`, most shells will need to be closed and restarted for\\n        changes to take effect.\\n\\n        \")\n    p = sub_parsers.add_parser('init', help=summary, description=description, epilog=epilog, **kwargs)\n    p.add_argument('--dev', action='store_true', help=SUPPRESS, default=NULL)\n    p.add_argument('--all', action='store_true', help='Initialize all currently available shells.', default=NULL)\n    setup_type_group = p.add_argument_group('setup type')\n    setup_type_group.add_argument('--install', action='store_true', help=SUPPRESS, default=NULL)\n    setup_type_group.add_argument('--user', action='store_true', dest='user', help='Initialize conda for the current user (default).', default=True)\n    setup_type_group.add_argument('--no-user', action='store_false', dest='user', help=\"Don't initialize conda for the current user.\")\n    setup_type_group.add_argument('--system', action='store_true', help='Initialize conda for all users on the system.', default=NULL)\n    setup_type_group.add_argument('--reverse', action='store_true', help='Undo effects of last conda init.', default=NULL)\n    p.add_argument('shells', nargs='*', choices=COMPATIBLE_SHELLS, metavar='SHELLS', help=f\"One or more shells to be initialized. If not given, the default value is 'bash' on unix and 'cmd.exe' & 'powershell' on Windows. Use the '--all' flag to initialize all shells. Available shells: {sorted(COMPATIBLE_SHELLS)}\", default=['cmd.exe', 'powershell'] if on_win else ['bash'])\n    if on_win:\n        p.add_argument('--anaconda-prompt', action='store_true', help=\"Add an 'Anaconda Prompt' icon to your desktop.\", default=NULL)\n    add_parser_json(p)\n    p.add_argument('-d', '--dry-run', action='store_true', help='Only display what would have been done.')\n    p.set_defaults(func='conda.cli.main_init.execute')\n    return p",
            "def configure_parser(sub_parsers: _SubParsersAction, **kwargs) -> ArgumentParser:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from ..auxlib.ish import dals\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..common.compat import on_win\n    from ..common.constants import NULL\n    from .helpers import add_parser_json\n    summary = 'Initialize conda for shell interaction.'\n    description = summary\n    epilog = dals(\"\\n        Key parts of conda's functionality require that it interact directly with the shell\\n        within which conda is being invoked. The `conda activate` and `conda deactivate` commands\\n        specifically are shell-level commands. That is, they affect the state (e.g. environment\\n        variables) of the shell context being interacted with. Other core commands, like\\n        `conda create` and `conda install`, also necessarily interact with the shell environment.\\n        They're therefore implemented in ways specific to each shell. Each shell must be configured\\n        to make use of them.\\n\\n        This command makes changes to your system that are specific and customized for each shell.\\n        To see the specific files and locations on your system that will be affected before, use\\n        the '--dry-run' flag.  To see the exact changes that are being or will be made to each\\n        location, use the '--verbose' flag.\\n\\n        IMPORTANT: After running `conda init`, most shells will need to be closed and restarted for\\n        changes to take effect.\\n\\n        \")\n    p = sub_parsers.add_parser('init', help=summary, description=description, epilog=epilog, **kwargs)\n    p.add_argument('--dev', action='store_true', help=SUPPRESS, default=NULL)\n    p.add_argument('--all', action='store_true', help='Initialize all currently available shells.', default=NULL)\n    setup_type_group = p.add_argument_group('setup type')\n    setup_type_group.add_argument('--install', action='store_true', help=SUPPRESS, default=NULL)\n    setup_type_group.add_argument('--user', action='store_true', dest='user', help='Initialize conda for the current user (default).', default=True)\n    setup_type_group.add_argument('--no-user', action='store_false', dest='user', help=\"Don't initialize conda for the current user.\")\n    setup_type_group.add_argument('--system', action='store_true', help='Initialize conda for all users on the system.', default=NULL)\n    setup_type_group.add_argument('--reverse', action='store_true', help='Undo effects of last conda init.', default=NULL)\n    p.add_argument('shells', nargs='*', choices=COMPATIBLE_SHELLS, metavar='SHELLS', help=f\"One or more shells to be initialized. If not given, the default value is 'bash' on unix and 'cmd.exe' & 'powershell' on Windows. Use the '--all' flag to initialize all shells. Available shells: {sorted(COMPATIBLE_SHELLS)}\", default=['cmd.exe', 'powershell'] if on_win else ['bash'])\n    if on_win:\n        p.add_argument('--anaconda-prompt', action='store_true', help=\"Add an 'Anaconda Prompt' icon to your desktop.\", default=NULL)\n    add_parser_json(p)\n    p.add_argument('-d', '--dry-run', action='store_true', help='Only display what would have been done.')\n    p.set_defaults(func='conda.cli.main_init.execute')\n    return p",
            "def configure_parser(sub_parsers: _SubParsersAction, **kwargs) -> ArgumentParser:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from ..auxlib.ish import dals\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..common.compat import on_win\n    from ..common.constants import NULL\n    from .helpers import add_parser_json\n    summary = 'Initialize conda for shell interaction.'\n    description = summary\n    epilog = dals(\"\\n        Key parts of conda's functionality require that it interact directly with the shell\\n        within which conda is being invoked. The `conda activate` and `conda deactivate` commands\\n        specifically are shell-level commands. That is, they affect the state (e.g. environment\\n        variables) of the shell context being interacted with. Other core commands, like\\n        `conda create` and `conda install`, also necessarily interact with the shell environment.\\n        They're therefore implemented in ways specific to each shell. Each shell must be configured\\n        to make use of them.\\n\\n        This command makes changes to your system that are specific and customized for each shell.\\n        To see the specific files and locations on your system that will be affected before, use\\n        the '--dry-run' flag.  To see the exact changes that are being or will be made to each\\n        location, use the '--verbose' flag.\\n\\n        IMPORTANT: After running `conda init`, most shells will need to be closed and restarted for\\n        changes to take effect.\\n\\n        \")\n    p = sub_parsers.add_parser('init', help=summary, description=description, epilog=epilog, **kwargs)\n    p.add_argument('--dev', action='store_true', help=SUPPRESS, default=NULL)\n    p.add_argument('--all', action='store_true', help='Initialize all currently available shells.', default=NULL)\n    setup_type_group = p.add_argument_group('setup type')\n    setup_type_group.add_argument('--install', action='store_true', help=SUPPRESS, default=NULL)\n    setup_type_group.add_argument('--user', action='store_true', dest='user', help='Initialize conda for the current user (default).', default=True)\n    setup_type_group.add_argument('--no-user', action='store_false', dest='user', help=\"Don't initialize conda for the current user.\")\n    setup_type_group.add_argument('--system', action='store_true', help='Initialize conda for all users on the system.', default=NULL)\n    setup_type_group.add_argument('--reverse', action='store_true', help='Undo effects of last conda init.', default=NULL)\n    p.add_argument('shells', nargs='*', choices=COMPATIBLE_SHELLS, metavar='SHELLS', help=f\"One or more shells to be initialized. If not given, the default value is 'bash' on unix and 'cmd.exe' & 'powershell' on Windows. Use the '--all' flag to initialize all shells. Available shells: {sorted(COMPATIBLE_SHELLS)}\", default=['cmd.exe', 'powershell'] if on_win else ['bash'])\n    if on_win:\n        p.add_argument('--anaconda-prompt', action='store_true', help=\"Add an 'Anaconda Prompt' icon to your desktop.\", default=NULL)\n    add_parser_json(p)\n    p.add_argument('-d', '--dry-run', action='store_true', help='Only display what would have been done.')\n    p.set_defaults(func='conda.cli.main_init.execute')\n    return p"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(args: Namespace, parser: ArgumentParser) -> int:\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..base.context import context\n    from ..common.compat import on_win\n    from ..core.initialize import initialize, initialize_dev, install\n    from ..exceptions import ArgumentError\n    if args.install:\n        return install(context.conda_prefix)\n    selected_shells: tuple[str, ...]\n    if args.all:\n        selected_shells = COMPATIBLE_SHELLS\n    else:\n        selected_shells = tuple(args.shells)\n    if args.dev:\n        if len(selected_shells) != 1:\n            raise ArgumentError('--dev can only handle one shell at a time right now')\n        return initialize_dev(selected_shells[0])\n    else:\n        for_user = args.user and (not args.system)\n        anaconda_prompt = on_win and args.anaconda_prompt\n        return initialize(context.conda_prefix, selected_shells, for_user, args.system, anaconda_prompt, args.reverse)",
        "mutated": [
            "def execute(args: Namespace, parser: ArgumentParser) -> int:\n    if False:\n        i = 10\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..base.context import context\n    from ..common.compat import on_win\n    from ..core.initialize import initialize, initialize_dev, install\n    from ..exceptions import ArgumentError\n    if args.install:\n        return install(context.conda_prefix)\n    selected_shells: tuple[str, ...]\n    if args.all:\n        selected_shells = COMPATIBLE_SHELLS\n    else:\n        selected_shells = tuple(args.shells)\n    if args.dev:\n        if len(selected_shells) != 1:\n            raise ArgumentError('--dev can only handle one shell at a time right now')\n        return initialize_dev(selected_shells[0])\n    else:\n        for_user = args.user and (not args.system)\n        anaconda_prompt = on_win and args.anaconda_prompt\n        return initialize(context.conda_prefix, selected_shells, for_user, args.system, anaconda_prompt, args.reverse)",
            "def execute(args: Namespace, parser: ArgumentParser) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..base.context import context\n    from ..common.compat import on_win\n    from ..core.initialize import initialize, initialize_dev, install\n    from ..exceptions import ArgumentError\n    if args.install:\n        return install(context.conda_prefix)\n    selected_shells: tuple[str, ...]\n    if args.all:\n        selected_shells = COMPATIBLE_SHELLS\n    else:\n        selected_shells = tuple(args.shells)\n    if args.dev:\n        if len(selected_shells) != 1:\n            raise ArgumentError('--dev can only handle one shell at a time right now')\n        return initialize_dev(selected_shells[0])\n    else:\n        for_user = args.user and (not args.system)\n        anaconda_prompt = on_win and args.anaconda_prompt\n        return initialize(context.conda_prefix, selected_shells, for_user, args.system, anaconda_prompt, args.reverse)",
            "def execute(args: Namespace, parser: ArgumentParser) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..base.context import context\n    from ..common.compat import on_win\n    from ..core.initialize import initialize, initialize_dev, install\n    from ..exceptions import ArgumentError\n    if args.install:\n        return install(context.conda_prefix)\n    selected_shells: tuple[str, ...]\n    if args.all:\n        selected_shells = COMPATIBLE_SHELLS\n    else:\n        selected_shells = tuple(args.shells)\n    if args.dev:\n        if len(selected_shells) != 1:\n            raise ArgumentError('--dev can only handle one shell at a time right now')\n        return initialize_dev(selected_shells[0])\n    else:\n        for_user = args.user and (not args.system)\n        anaconda_prompt = on_win and args.anaconda_prompt\n        return initialize(context.conda_prefix, selected_shells, for_user, args.system, anaconda_prompt, args.reverse)",
            "def execute(args: Namespace, parser: ArgumentParser) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..base.context import context\n    from ..common.compat import on_win\n    from ..core.initialize import initialize, initialize_dev, install\n    from ..exceptions import ArgumentError\n    if args.install:\n        return install(context.conda_prefix)\n    selected_shells: tuple[str, ...]\n    if args.all:\n        selected_shells = COMPATIBLE_SHELLS\n    else:\n        selected_shells = tuple(args.shells)\n    if args.dev:\n        if len(selected_shells) != 1:\n            raise ArgumentError('--dev can only handle one shell at a time right now')\n        return initialize_dev(selected_shells[0])\n    else:\n        for_user = args.user and (not args.system)\n        anaconda_prompt = on_win and args.anaconda_prompt\n        return initialize(context.conda_prefix, selected_shells, for_user, args.system, anaconda_prompt, args.reverse)",
            "def execute(args: Namespace, parser: ArgumentParser) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from ..base.constants import COMPATIBLE_SHELLS\n    from ..base.context import context\n    from ..common.compat import on_win\n    from ..core.initialize import initialize, initialize_dev, install\n    from ..exceptions import ArgumentError\n    if args.install:\n        return install(context.conda_prefix)\n    selected_shells: tuple[str, ...]\n    if args.all:\n        selected_shells = COMPATIBLE_SHELLS\n    else:\n        selected_shells = tuple(args.shells)\n    if args.dev:\n        if len(selected_shells) != 1:\n            raise ArgumentError('--dev can only handle one shell at a time right now')\n        return initialize_dev(selected_shells[0])\n    else:\n        for_user = args.user and (not args.system)\n        anaconda_prompt = on_win and args.anaconda_prompt\n        return initialize(context.conda_prefix, selected_shells, for_user, args.system, anaconda_prompt, args.reverse)"
        ]
    }
]