[
    {
        "func_name": "date_range",
        "original": "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    ...",
        "mutated": [
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=..., name: str | None=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "date_range",
        "original": "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True], name: str | None=...) -> Series:\n    ...",
        "mutated": [
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True], name: str | None=...) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "date_range",
        "original": "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool, name: str | None=...) -> Series | Expr:\n    ...",
        "mutated": [
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool, name: str | None=...) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "date_range",
        "original": "@deprecate_renamed_parameter('low', 'start', version='0.18.0')\n@deprecate_renamed_parameter('high', 'end', version='0.18.0')\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False, name: str | None=None) -> Series | Expr:\n    \"\"\"\n    Generate a date range.\n\n    Parameters\n    ----------\n    start\n        Lower bound of the date range.\n    end\n        Upper bound of the date range.\n    interval\n        Interval of the range periods, specified as a Python `timedelta` object\n        or using the Polars duration string language (see \"Notes\" section below).\n    closed : {'both', 'left', 'right', 'none'}\n        Define which sides of the range are closed (inclusive).\n    time_unit : {None, 'ns', 'us', 'ms'}\n        Time unit of the resulting `Datetime` data type.\n        Only takes effect if the output column is of type `Datetime`.\n    time_zone\n        Time zone of the resulting `Datetime` data type.\n        Only takes effect if the output column is of type `Datetime`.\n    eager\n        Evaluate immediately and return a `Series`.\n        If set to `False` (default), return an expression instead.\n    name\n        Name of the output column.\n\n        .. deprecated:: 0.18.0\n            This argument is deprecated. Use the `alias` method instead.\n\n    Returns\n    -------\n    Expr or Series\n        Column of data type :class:`Date` or :class:`Datetime`.\n\n    Notes\n    -----\n    1) If both `start` and `end` are passed as date types (not datetime), and the\n       interval granularity is no finer than 1d, the returned range is also of\n       type date. All other permutations return a datetime Series.\n\n       .. deprecated:: 0.19.3\n           In a future version of Polars, `date_range` will always return a `Date`.\n           Please use :func:`datetime_range` if you want a `Datetime` instead.\n\n    2) `interval` is created according to the following string language:\n\n       - 1ns   (1 nanosecond)\n       - 1us   (1 microsecond)\n       - 1ms   (1 millisecond)\n       - 1s    (1 second)\n       - 1m    (1 minute)\n       - 1h    (1 hour)\n       - 1d    (1 calendar day)\n       - 1w    (1 calendar week)\n       - 1mo   (1 calendar month)\n       - 1q    (1 calendar quarter)\n       - 1y    (1 calendar year)\n\n       Or combine them:\n       \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\n\n       By \"calendar day\", we mean the corresponding time on the next day (which may\n       not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\n       \"calendar month\", \"calendar quarter\", and \"calendar year\".\n\n    Examples\n    --------\n    Using Polars duration string to specify the interval:\n\n    >>> from datetime import date\n    >>> pl.date_range(date(2022, 1, 1), date(2022, 3, 1), \"1mo\", eager=True)\n    shape: (3,)\n    Series: 'date' [date]\n    [\n        2022-01-01\n        2022-02-01\n        2022-03-01\n    ]\n\n    Using `timedelta` object to specify the interval:\n\n    >>> from datetime import timedelta\n    >>> pl.date_range(\n    ...     date(1985, 1, 1),\n    ...     date(1985, 1, 10),\n    ...     timedelta(days=2),\n    ...     eager=True,\n    ... )\n    shape: (5,)\n    Series: 'date' [date]\n    [\n        1985-01-01\n        1985-01-03\n        1985-01-05\n        1985-01-07\n        1985-01-09\n    ]\n\n    \"\"\"\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_range(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
        "mutated": [
            "@deprecate_renamed_parameter('low', 'start', version='0.18.0')\n@deprecate_renamed_parameter('high', 'end', version='0.18.0')\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n    '\\n    Generate a date range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type :class:`Date` or :class:`Datetime`.\\n\\n    Notes\\n    -----\\n    1) If both `start` and `end` are passed as date types (not datetime), and the\\n       interval granularity is no finer than 1d, the returned range is also of\\n       type date. All other permutations return a datetime Series.\\n\\n       .. deprecated:: 0.19.3\\n           In a future version of Polars, `date_range` will always return a `Date`.\\n           Please use :func:`datetime_range` if you want a `Datetime` instead.\\n\\n    2) `interval` is created according to the following string language:\\n\\n       - 1ns   (1 nanosecond)\\n       - 1us   (1 microsecond)\\n       - 1ms   (1 millisecond)\\n       - 1s    (1 second)\\n       - 1m    (1 minute)\\n       - 1h    (1 hour)\\n       - 1d    (1 calendar day)\\n       - 1w    (1 calendar week)\\n       - 1mo   (1 calendar month)\\n       - 1q    (1 calendar quarter)\\n       - 1y    (1 calendar year)\\n\\n       Or combine them:\\n       \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n       By \"calendar day\", we mean the corresponding time on the next day (which may\\n       not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n       \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    Using Polars duration string to specify the interval:\\n\\n    >>> from datetime import date\\n    >>> pl.date_range(date(2022, 1, 1), date(2022, 3, 1), \"1mo\", eager=True)\\n    shape: (3,)\\n    Series: \\'date\\' [date]\\n    [\\n        2022-01-01\\n        2022-02-01\\n        2022-03-01\\n    ]\\n\\n    Using `timedelta` object to specify the interval:\\n\\n    >>> from datetime import timedelta\\n    >>> pl.date_range(\\n    ...     date(1985, 1, 1),\\n    ...     date(1985, 1, 10),\\n    ...     timedelta(days=2),\\n    ...     eager=True,\\n    ... )\\n    shape: (5,)\\n    Series: \\'date\\' [date]\\n    [\\n        1985-01-01\\n        1985-01-03\\n        1985-01-05\\n        1985-01-07\\n        1985-01-09\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_range(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "@deprecate_renamed_parameter('low', 'start', version='0.18.0')\n@deprecate_renamed_parameter('high', 'end', version='0.18.0')\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate a date range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type :class:`Date` or :class:`Datetime`.\\n\\n    Notes\\n    -----\\n    1) If both `start` and `end` are passed as date types (not datetime), and the\\n       interval granularity is no finer than 1d, the returned range is also of\\n       type date. All other permutations return a datetime Series.\\n\\n       .. deprecated:: 0.19.3\\n           In a future version of Polars, `date_range` will always return a `Date`.\\n           Please use :func:`datetime_range` if you want a `Datetime` instead.\\n\\n    2) `interval` is created according to the following string language:\\n\\n       - 1ns   (1 nanosecond)\\n       - 1us   (1 microsecond)\\n       - 1ms   (1 millisecond)\\n       - 1s    (1 second)\\n       - 1m    (1 minute)\\n       - 1h    (1 hour)\\n       - 1d    (1 calendar day)\\n       - 1w    (1 calendar week)\\n       - 1mo   (1 calendar month)\\n       - 1q    (1 calendar quarter)\\n       - 1y    (1 calendar year)\\n\\n       Or combine them:\\n       \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n       By \"calendar day\", we mean the corresponding time on the next day (which may\\n       not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n       \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    Using Polars duration string to specify the interval:\\n\\n    >>> from datetime import date\\n    >>> pl.date_range(date(2022, 1, 1), date(2022, 3, 1), \"1mo\", eager=True)\\n    shape: (3,)\\n    Series: \\'date\\' [date]\\n    [\\n        2022-01-01\\n        2022-02-01\\n        2022-03-01\\n    ]\\n\\n    Using `timedelta` object to specify the interval:\\n\\n    >>> from datetime import timedelta\\n    >>> pl.date_range(\\n    ...     date(1985, 1, 1),\\n    ...     date(1985, 1, 10),\\n    ...     timedelta(days=2),\\n    ...     eager=True,\\n    ... )\\n    shape: (5,)\\n    Series: \\'date\\' [date]\\n    [\\n        1985-01-01\\n        1985-01-03\\n        1985-01-05\\n        1985-01-07\\n        1985-01-09\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_range(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "@deprecate_renamed_parameter('low', 'start', version='0.18.0')\n@deprecate_renamed_parameter('high', 'end', version='0.18.0')\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate a date range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type :class:`Date` or :class:`Datetime`.\\n\\n    Notes\\n    -----\\n    1) If both `start` and `end` are passed as date types (not datetime), and the\\n       interval granularity is no finer than 1d, the returned range is also of\\n       type date. All other permutations return a datetime Series.\\n\\n       .. deprecated:: 0.19.3\\n           In a future version of Polars, `date_range` will always return a `Date`.\\n           Please use :func:`datetime_range` if you want a `Datetime` instead.\\n\\n    2) `interval` is created according to the following string language:\\n\\n       - 1ns   (1 nanosecond)\\n       - 1us   (1 microsecond)\\n       - 1ms   (1 millisecond)\\n       - 1s    (1 second)\\n       - 1m    (1 minute)\\n       - 1h    (1 hour)\\n       - 1d    (1 calendar day)\\n       - 1w    (1 calendar week)\\n       - 1mo   (1 calendar month)\\n       - 1q    (1 calendar quarter)\\n       - 1y    (1 calendar year)\\n\\n       Or combine them:\\n       \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n       By \"calendar day\", we mean the corresponding time on the next day (which may\\n       not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n       \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    Using Polars duration string to specify the interval:\\n\\n    >>> from datetime import date\\n    >>> pl.date_range(date(2022, 1, 1), date(2022, 3, 1), \"1mo\", eager=True)\\n    shape: (3,)\\n    Series: \\'date\\' [date]\\n    [\\n        2022-01-01\\n        2022-02-01\\n        2022-03-01\\n    ]\\n\\n    Using `timedelta` object to specify the interval:\\n\\n    >>> from datetime import timedelta\\n    >>> pl.date_range(\\n    ...     date(1985, 1, 1),\\n    ...     date(1985, 1, 10),\\n    ...     timedelta(days=2),\\n    ...     eager=True,\\n    ... )\\n    shape: (5,)\\n    Series: \\'date\\' [date]\\n    [\\n        1985-01-01\\n        1985-01-03\\n        1985-01-05\\n        1985-01-07\\n        1985-01-09\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_range(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "@deprecate_renamed_parameter('low', 'start', version='0.18.0')\n@deprecate_renamed_parameter('high', 'end', version='0.18.0')\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate a date range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type :class:`Date` or :class:`Datetime`.\\n\\n    Notes\\n    -----\\n    1) If both `start` and `end` are passed as date types (not datetime), and the\\n       interval granularity is no finer than 1d, the returned range is also of\\n       type date. All other permutations return a datetime Series.\\n\\n       .. deprecated:: 0.19.3\\n           In a future version of Polars, `date_range` will always return a `Date`.\\n           Please use :func:`datetime_range` if you want a `Datetime` instead.\\n\\n    2) `interval` is created according to the following string language:\\n\\n       - 1ns   (1 nanosecond)\\n       - 1us   (1 microsecond)\\n       - 1ms   (1 millisecond)\\n       - 1s    (1 second)\\n       - 1m    (1 minute)\\n       - 1h    (1 hour)\\n       - 1d    (1 calendar day)\\n       - 1w    (1 calendar week)\\n       - 1mo   (1 calendar month)\\n       - 1q    (1 calendar quarter)\\n       - 1y    (1 calendar year)\\n\\n       Or combine them:\\n       \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n       By \"calendar day\", we mean the corresponding time on the next day (which may\\n       not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n       \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    Using Polars duration string to specify the interval:\\n\\n    >>> from datetime import date\\n    >>> pl.date_range(date(2022, 1, 1), date(2022, 3, 1), \"1mo\", eager=True)\\n    shape: (3,)\\n    Series: \\'date\\' [date]\\n    [\\n        2022-01-01\\n        2022-02-01\\n        2022-03-01\\n    ]\\n\\n    Using `timedelta` object to specify the interval:\\n\\n    >>> from datetime import timedelta\\n    >>> pl.date_range(\\n    ...     date(1985, 1, 1),\\n    ...     date(1985, 1, 10),\\n    ...     timedelta(days=2),\\n    ...     eager=True,\\n    ... )\\n    shape: (5,)\\n    Series: \\'date\\' [date]\\n    [\\n        1985-01-01\\n        1985-01-03\\n        1985-01-05\\n        1985-01-07\\n        1985-01-09\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_range(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "@deprecate_renamed_parameter('low', 'start', version='0.18.0')\n@deprecate_renamed_parameter('high', 'end', version='0.18.0')\ndef date_range(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False, name: str | None=None) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate a date range.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n    name\\n        Name of the output column.\\n\\n        .. deprecated:: 0.18.0\\n            This argument is deprecated. Use the `alias` method instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type :class:`Date` or :class:`Datetime`.\\n\\n    Notes\\n    -----\\n    1) If both `start` and `end` are passed as date types (not datetime), and the\\n       interval granularity is no finer than 1d, the returned range is also of\\n       type date. All other permutations return a datetime Series.\\n\\n       .. deprecated:: 0.19.3\\n           In a future version of Polars, `date_range` will always return a `Date`.\\n           Please use :func:`datetime_range` if you want a `Datetime` instead.\\n\\n    2) `interval` is created according to the following string language:\\n\\n       - 1ns   (1 nanosecond)\\n       - 1us   (1 microsecond)\\n       - 1ms   (1 millisecond)\\n       - 1s    (1 second)\\n       - 1m    (1 minute)\\n       - 1h    (1 hour)\\n       - 1d    (1 calendar day)\\n       - 1w    (1 calendar week)\\n       - 1mo   (1 calendar month)\\n       - 1q    (1 calendar quarter)\\n       - 1y    (1 calendar year)\\n\\n       Or combine them:\\n       \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n       By \"calendar day\", we mean the corresponding time on the next day (which may\\n       not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n       \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    Using Polars duration string to specify the interval:\\n\\n    >>> from datetime import date\\n    >>> pl.date_range(date(2022, 1, 1), date(2022, 3, 1), \"1mo\", eager=True)\\n    shape: (3,)\\n    Series: \\'date\\' [date]\\n    [\\n        2022-01-01\\n        2022-02-01\\n        2022-03-01\\n    ]\\n\\n    Using `timedelta` object to specify the interval:\\n\\n    >>> from datetime import timedelta\\n    >>> pl.date_range(\\n    ...     date(1985, 1, 1),\\n    ...     date(1985, 1, 10),\\n    ...     timedelta(days=2),\\n    ...     eager=True,\\n    ... )\\n    shape: (5,)\\n    Series: \\'date\\' [date]\\n    [\\n        1985-01-01\\n        1985-01-03\\n        1985-01-05\\n        1985-01-07\\n        1985-01-09\\n    ]\\n\\n    '\n    interval = deprecate_saturating(interval)\n    if name is not None:\n        issue_deprecation_warning('the `name` argument is deprecated. Use the `alias` method instead.', version='0.18.0')\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_range(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if name is not None:\n        result = result.alias(name)\n    if eager:\n        return F.select(result).to_series()\n    return result"
        ]
    },
    {
        "func_name": "date_ranges",
        "original": "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=...) -> Expr:\n    ...",
        "mutated": [
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[False]=...) -> Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "date_ranges",
        "original": "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True]) -> Series:\n    ...",
        "mutated": [
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: Literal[True]) -> Series:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "date_ranges",
        "original": "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool) -> Series | Expr:\n    ...",
        "mutated": [
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta=..., *, closed: ClosedInterval=..., time_unit: TimeUnit | None=..., time_zone: str | None=..., eager: bool) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "date_ranges",
        "original": "def date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False) -> Series | Expr:\n    \"\"\"\n    Create a column of date ranges.\n\n    Parameters\n    ----------\n    start\n        Lower bound of the date range.\n    end\n        Upper bound of the date range.\n    interval\n        Interval of the range periods, specified as a Python `timedelta` object\n        or using the Polars duration string language (see \"Notes\" section below).\n    closed : {'both', 'left', 'right', 'none'}\n        Define which sides of the range are closed (inclusive).\n    time_unit : {None, 'ns', 'us', 'ms'}\n        Time unit of the resulting `Datetime` data type.\n        Only takes effect if the output column is of type `Datetime`.\n    time_zone\n        Time zone of the resulting `Datetime` data type.\n        Only takes effect if the output column is of type `Datetime`.\n    eager\n        Evaluate immediately and return a `Series`.\n        If set to `False` (default), return an expression instead.\n\n    Returns\n    -------\n    Expr or Series\n        Column of data type `List(Date)` or `List(Datetime)`.\n\n    Notes\n    -----\n    `interval` is created according to the following string language:\n\n    - 1ns   (1 nanosecond)\n    - 1us   (1 microsecond)\n    - 1ms   (1 millisecond)\n    - 1s    (1 second)\n    - 1m    (1 minute)\n    - 1h    (1 hour)\n    - 1d    (1 calendar day)\n    - 1w    (1 calendar week)\n    - 1mo   (1 calendar month)\n    - 1q    (1 calendar quarter)\n    - 1y    (1 calendar year)\n\n    Or combine them:\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\n\n    By \"calendar day\", we mean the corresponding time on the next day (which may\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\n\n    Examples\n    --------\n    >>> from datetime import date\n    >>> df = pl.DataFrame(\n    ...     {\n    ...         \"start\": [date(2022, 1, 1), date(2022, 1, 2)],\n    ...         \"end\": date(2022, 1, 3),\n    ...     }\n    ... )\n    >>> df.with_columns(pl.date_ranges(\"start\", \"end\"))\n    shape: (2, 3)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 start      \u2506 end        \u2506 date_range                        \u2502\n    \u2502 ---        \u2506 ---        \u2506 ---                               \u2502\n    \u2502 date       \u2506 date       \u2506 list[date]                        \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 2022-01-01 \u2506 2022-01-03 \u2506 [2022-01-01, 2022-01-02, 2022-01\u2026 \u2502\n    \u2502 2022-01-02 \u2506 2022-01-03 \u2506 [2022-01-02, 2022-01-03]          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_ranges(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if eager:\n        return F.select(result).to_series()\n    return result",
        "mutated": [
            "def date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n    '\\n    Create a column of date ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Date)` or `List(Datetime)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [date(2022, 1, 1), date(2022, 1, 2)],\\n    ...         \"end\": date(2022, 1, 3),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.date_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start      \u2506 end        \u2506 date_range                        \u2502\\n    \u2502 ---        \u2506 ---        \u2506 ---                               \u2502\\n    \u2502 date       \u2506 date       \u2506 list[date]                        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 \u2506 2022-01-03 \u2506 [2022-01-01, 2022-01-02, 2022-01\u2026 \u2502\\n    \u2502 2022-01-02 \u2506 2022-01-03 \u2506 [2022-01-02, 2022-01-03]          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_ranges(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create a column of date ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Date)` or `List(Datetime)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [date(2022, 1, 1), date(2022, 1, 2)],\\n    ...         \"end\": date(2022, 1, 3),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.date_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start      \u2506 end        \u2506 date_range                        \u2502\\n    \u2502 ---        \u2506 ---        \u2506 ---                               \u2502\\n    \u2502 date       \u2506 date       \u2506 list[date]                        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 \u2506 2022-01-03 \u2506 [2022-01-01, 2022-01-02, 2022-01\u2026 \u2502\\n    \u2502 2022-01-02 \u2506 2022-01-03 \u2506 [2022-01-02, 2022-01-03]          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_ranges(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create a column of date ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Date)` or `List(Datetime)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [date(2022, 1, 1), date(2022, 1, 2)],\\n    ...         \"end\": date(2022, 1, 3),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.date_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start      \u2506 end        \u2506 date_range                        \u2502\\n    \u2502 ---        \u2506 ---        \u2506 ---                               \u2502\\n    \u2502 date       \u2506 date       \u2506 list[date]                        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 \u2506 2022-01-03 \u2506 [2022-01-01, 2022-01-02, 2022-01\u2026 \u2502\\n    \u2502 2022-01-02 \u2506 2022-01-03 \u2506 [2022-01-02, 2022-01-03]          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_ranges(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create a column of date ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Date)` or `List(Datetime)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [date(2022, 1, 1), date(2022, 1, 2)],\\n    ...         \"end\": date(2022, 1, 3),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.date_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start      \u2506 end        \u2506 date_range                        \u2502\\n    \u2502 ---        \u2506 ---        \u2506 ---                               \u2502\\n    \u2502 date       \u2506 date       \u2506 list[date]                        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 \u2506 2022-01-03 \u2506 [2022-01-01, 2022-01-02, 2022-01\u2026 \u2502\\n    \u2502 2022-01-02 \u2506 2022-01-03 \u2506 [2022-01-02, 2022-01-03]          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_ranges(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if eager:\n        return F.select(result).to_series()\n    return result",
            "def date_ranges(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str | timedelta='1d', *, closed: ClosedInterval='both', time_unit: TimeUnit | None=None, time_zone: str | None=None, eager: bool=False) -> Series | Expr:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create a column of date ranges.\\n\\n    Parameters\\n    ----------\\n    start\\n        Lower bound of the date range.\\n    end\\n        Upper bound of the date range.\\n    interval\\n        Interval of the range periods, specified as a Python `timedelta` object\\n        or using the Polars duration string language (see \"Notes\" section below).\\n    closed : {\\'both\\', \\'left\\', \\'right\\', \\'none\\'}\\n        Define which sides of the range are closed (inclusive).\\n    time_unit : {None, \\'ns\\', \\'us\\', \\'ms\\'}\\n        Time unit of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    time_zone\\n        Time zone of the resulting `Datetime` data type.\\n        Only takes effect if the output column is of type `Datetime`.\\n    eager\\n        Evaluate immediately and return a `Series`.\\n        If set to `False` (default), return an expression instead.\\n\\n    Returns\\n    -------\\n    Expr or Series\\n        Column of data type `List(Date)` or `List(Datetime)`.\\n\\n    Notes\\n    -----\\n    `interval` is created according to the following string language:\\n\\n    - 1ns   (1 nanosecond)\\n    - 1us   (1 microsecond)\\n    - 1ms   (1 millisecond)\\n    - 1s    (1 second)\\n    - 1m    (1 minute)\\n    - 1h    (1 hour)\\n    - 1d    (1 calendar day)\\n    - 1w    (1 calendar week)\\n    - 1mo   (1 calendar month)\\n    - 1q    (1 calendar quarter)\\n    - 1y    (1 calendar year)\\n\\n    Or combine them:\\n    \"3d12h4m25s\" # 3 days, 12 hours, 4 minutes, and 25 seconds\\n\\n    By \"calendar day\", we mean the corresponding time on the next day (which may\\n    not be 24 hours, due to daylight savings). Similarly for \"calendar week\",\\n    \"calendar month\", \"calendar quarter\", and \"calendar year\".\\n\\n    Examples\\n    --------\\n    >>> from datetime import date\\n    >>> df = pl.DataFrame(\\n    ...     {\\n    ...         \"start\": [date(2022, 1, 1), date(2022, 1, 2)],\\n    ...         \"end\": date(2022, 1, 3),\\n    ...     }\\n    ... )\\n    >>> df.with_columns(pl.date_ranges(\"start\", \"end\"))\\n    shape: (2, 3)\\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n    \u2502 start      \u2506 end        \u2506 date_range                        \u2502\\n    \u2502 ---        \u2506 ---        \u2506 ---                               \u2502\\n    \u2502 date       \u2506 date       \u2506 list[date]                        \u2502\\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n    \u2502 2022-01-01 \u2506 2022-01-03 \u2506 [2022-01-01, 2022-01-02, 2022-01\u2026 \u2502\\n    \u2502 2022-01-02 \u2506 2022-01-03 \u2506 [2022-01-02, 2022-01-03]          \u2502\\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    '\n    interval = deprecate_saturating(interval)\n    interval = parse_interval_argument(interval)\n    if time_unit is None and 'ns' in interval:\n        time_unit = 'ns'\n    _warn_for_deprecated_date_range_use(start, end, interval, time_unit, time_zone)\n    start_pyexpr = parse_as_expression(start)\n    end_pyexpr = parse_as_expression(end)\n    result = wrap_expr(plr.date_ranges(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone))\n    if eager:\n        return F.select(result).to_series()\n    return result"
        ]
    },
    {
        "func_name": "_warn_for_deprecated_date_range_use",
        "original": "def _warn_for_deprecated_date_range_use(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str, time_unit: TimeUnit | None, time_zone: str | None) -> None:\n    if isinstance(start, datetime) or isinstance(end, datetime) or time_unit is not None or (time_zone is not None) or ('h' in interval) or ('m' in interval.replace('mo', '')) or ('s' in interval.replace('saturating', '')):\n        issue_deprecation_warning('Creating Datetime ranges using `date_range(s)` is deprecated. Use `datetime_range(s)` instead.', version='0.19.3')",
        "mutated": [
            "def _warn_for_deprecated_date_range_use(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str, time_unit: TimeUnit | None, time_zone: str | None) -> None:\n    if False:\n        i = 10\n    if isinstance(start, datetime) or isinstance(end, datetime) or time_unit is not None or (time_zone is not None) or ('h' in interval) or ('m' in interval.replace('mo', '')) or ('s' in interval.replace('saturating', '')):\n        issue_deprecation_warning('Creating Datetime ranges using `date_range(s)` is deprecated. Use `datetime_range(s)` instead.', version='0.19.3')",
            "def _warn_for_deprecated_date_range_use(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str, time_unit: TimeUnit | None, time_zone: str | None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(start, datetime) or isinstance(end, datetime) or time_unit is not None or (time_zone is not None) or ('h' in interval) or ('m' in interval.replace('mo', '')) or ('s' in interval.replace('saturating', '')):\n        issue_deprecation_warning('Creating Datetime ranges using `date_range(s)` is deprecated. Use `datetime_range(s)` instead.', version='0.19.3')",
            "def _warn_for_deprecated_date_range_use(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str, time_unit: TimeUnit | None, time_zone: str | None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(start, datetime) or isinstance(end, datetime) or time_unit is not None or (time_zone is not None) or ('h' in interval) or ('m' in interval.replace('mo', '')) or ('s' in interval.replace('saturating', '')):\n        issue_deprecation_warning('Creating Datetime ranges using `date_range(s)` is deprecated. Use `datetime_range(s)` instead.', version='0.19.3')",
            "def _warn_for_deprecated_date_range_use(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str, time_unit: TimeUnit | None, time_zone: str | None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(start, datetime) or isinstance(end, datetime) or time_unit is not None or (time_zone is not None) or ('h' in interval) or ('m' in interval.replace('mo', '')) or ('s' in interval.replace('saturating', '')):\n        issue_deprecation_warning('Creating Datetime ranges using `date_range(s)` is deprecated. Use `datetime_range(s)` instead.', version='0.19.3')",
            "def _warn_for_deprecated_date_range_use(start: date | datetime | IntoExprColumn, end: date | datetime | IntoExprColumn, interval: str, time_unit: TimeUnit | None, time_zone: str | None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(start, datetime) or isinstance(end, datetime) or time_unit is not None or (time_zone is not None) or ('h' in interval) or ('m' in interval.replace('mo', '')) or ('s' in interval.replace('saturating', '')):\n        issue_deprecation_warning('Creating Datetime ranges using `date_range(s)` is deprecated. Use `datetime_range(s)` instead.', version='0.19.3')"
        ]
    }
]