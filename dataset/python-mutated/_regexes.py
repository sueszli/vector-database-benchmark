import textwrap

def _ind(text, level=1, edges='both'):
    if False:
        print('Hello World!')
    indent = '    ' * level
    text = textwrap.indent(text, indent)
    if edges == 'pre' or edges == 'both':
        text = '\n' + indent + text.lstrip()
    if edges == 'post' or edges == 'both':
        text = text.rstrip() + '\n' + '    ' * (level - 1)
    return text
HEX = '(?: [0-9a-zA-Z] )'
STRING_LITERAL = textwrap.dedent(f"""\n    (?:\n        # character literal\n        (?:\n            ['] [^'] [']\n            |\n            ['] \\\\ . [']\n            |\n            ['] \\\\x{HEX}{HEX} [']\n            |\n            ['] \\\\0\\d\\d [']\n            |\n            (?:\n                ['] \\\\o[01]\\d\\d [']\n                |\n                ['] \\\\o2[0-4]\\d [']\n                |\n                ['] \\\\o25[0-5] [']\n             )\n         )\n        |\n        # string literal\n        (?:\n            ["] (?: [^"\\\\]* \\\\ . )* [^"\\\\]* ["]\n         )\n        # end string literal\n     )\n    """)
_KEYWORD = textwrap.dedent('\n    (?:\n        \\b\n        (?:\n            auto |\n            extern |\n            register |\n            static |\n            typedef |\n\n            const |\n            volatile |\n\n            signed |\n            unsigned |\n            char |\n            short |\n            int |\n            long |\n            float |\n            double |\n            void |\n\n            struct |\n            union |\n            enum |\n\n            goto |\n            return |\n            sizeof |\n            break |\n            continue |\n            if |\n            else |\n            for |\n            do |\n            while |\n            switch |\n            case |\n            default |\n            entry\n         )\n        \\b\n     )\n    ')
KEYWORD = f'\n    # keyword\n    {_KEYWORD}\n    # end keyword\n    '
_KEYWORD = ''.join(_KEYWORD.split())
IDENTIFIER = '(?: [a-zA-Z_][a-zA-Z0-9_]* )'
STRICT_IDENTIFIER = f'(?: (?! {_KEYWORD} ) \\b {IDENTIFIER} \\b )'
ANON_IDENTIFIER = f'(?: (?! {_KEYWORD} ) \\b {IDENTIFIER} (?: - \\d+ )? \\b )'
SIMPLE_TYPE = textwrap.dedent(f'\n    # simple type\n    (?:\n        \\b\n        (?:\n            void\n            |\n            (?: signed | unsigned )  # implies int\n            |\n            (?:\n                (?: (?: signed | unsigned ) \\s+ )?\n                (?: (?: long | short ) \\s+ )?\n                (?: char | short | int | long | float | double )\n             )\n         )\n        \\b\n     )\n    # end simple type\n    ')
COMPOUND_TYPE_KIND = '(?: \\b (?: struct | union | enum ) \\b )'
_STORAGE = 'auto register static extern'.split()
STORAGE_CLASS = f"(?: \\b (?: {' | '.join(_STORAGE)} ) \\b )"
TYPE_QUALIFIER = '(?: \\b (?: const | volatile ) \\b )'
PTR_QUALIFIER = f'(?: [*] (?: \\s* {TYPE_QUALIFIER} )? )'
TYPE_SPEC = textwrap.dedent(f'\n    # type spec\n    (?:\n        {_ind(SIMPLE_TYPE, 2)}\n        |\n        (?:\n            [_]*typeof[_]*\n            \\s* [(]\n            (?: \\s* [*&] )*\n            \\s* {STRICT_IDENTIFIER}\n            \\s* [)]\n         )\n        |\n        # reference to a compound type\n        (?:\n            {COMPOUND_TYPE_KIND}\n            (?: \\s* {ANON_IDENTIFIER} )?\n         )\n        |\n        # reference to a typedef\n        {STRICT_IDENTIFIER}\n     )\n    # end type spec\n    ')
DECLARATOR = textwrap.dedent(f'\n    # declarator  (possibly abstract)\n    (?:\n        (?: {PTR_QUALIFIER} \\s* )*\n        (?:\n            (?:\n                (?:  # <IDENTIFIER>\n                    {STRICT_IDENTIFIER}\n                )\n                (?: \\s* \\[ (?: \\s* [^\\]]+ \\s* )? [\\]] )*  # arrays\n             )\n            |\n            (?:\n                [(] \\s*\n                (?:  # <WRAPPED_IDENTIFIER>\n                    {STRICT_IDENTIFIER}\n                )\n                (?: \\s* \\[ (?: \\s* [^\\]]+ \\s* )? [\\]] )*  # arrays\n                \\s* [)]\n             )\n            |\n            # func ptr\n            (?:\n                [(] (?: \\s* {PTR_QUALIFIER} )? \\s*\n                (?:  # <FUNC_IDENTIFIER>\n                    {STRICT_IDENTIFIER}\n                )\n                (?: \\s* \\[ (?: \\s* [^\\]]+ \\s* )? [\\]] )*  # arrays\n                \\s* [)]\n                # We allow for a single level of paren nesting in parameters.\n                \\s* [(] (?: [^()]* [(] [^)]* [)] )* [^)]* [)]\n             )\n         )\n     )\n    # end declarator\n    ')
VAR_DECL = textwrap.dedent(f'\n    # var decl (and typedef and func return type)\n    (?:\n        (?:\n            (?:  # <STORAGE>\n                {STORAGE_CLASS}\n            )\n            \\s*\n        )?\n        (?:\n            (?:  # <TYPE_QUAL>\n                {TYPE_QUALIFIER}\n            )\n            \\s*\n         )?\n        (?:\n            (?:  # <TYPE_SPEC>\n                {_ind(TYPE_SPEC, 4)}\n            )\n         )\n        \\s*\n        (?:\n            (?:  # <DECLARATOR>\n                {_ind(DECLARATOR, 4)}\n            )\n         )\n     )\n    # end var decl\n    ')
INITIALIZER = textwrap.dedent(f"""\n    # initializer\n    (?:\n        (?:\n            [(]\n            # no nested parens (e.g. func ptr)\n            [^)]*\n            [)]\n            \\s*\n         )?\n        (?:\n            # a string literal\n            (?:\n                (?: {_ind(STRING_LITERAL, 4)} \\s* )*\n                {_ind(STRING_LITERAL, 4)}\n             )\n            |\n\n            # a simple initializer\n            (?:\n                (?:\n                    [^'",;{{]*\n                    {_ind(STRING_LITERAL, 4)}\n                 )*\n                [^'",;{{]*\n             )\n            |\n\n            # a struct/array literal\n            (?:\n                # We only expect compound initializers with\n                # single-variable declarations.\n                {{\n                (?:\n                    [^'";]*?\n                    {_ind(STRING_LITERAL, 5)}\n                 )*\n                [^'";]*?\n                }}\n                (?= \\s* ; )  # Note this lookahead.\n             )\n         )\n     )\n    # end initializer\n    """)
STRUCT_MEMBER_DECL = textwrap.dedent(f"\n    (?:\n        # inline compound type decl\n        (?:\n            (?:  # <COMPOUND_TYPE_KIND>\n                {COMPOUND_TYPE_KIND}\n             )\n            (?:\n                \\s+\n                (?:  # <COMPOUND_TYPE_NAME>\n                    {STRICT_IDENTIFIER}\n                 )\n             )?\n            \\s* {{\n         )\n        |\n        (?:\n            # typed member\n            (?:\n                # Technically it doesn't have to have a type...\n                (?:  # <SPECIFIER_QUALIFIER>\n                    (?: {TYPE_QUALIFIER} \\s* )?\n                    {_ind(TYPE_SPEC, 5)}\n                 )\n                (?:\n                    # If it doesn't have a declarator then it will have\n                    # a size and vice versa.\n                    \\s*\n                    (?:  # <DECLARATOR>\n                        {_ind(DECLARATOR, 6)}\n                     )\n                 )?\n            )\n\n            # sized member\n            (?:\n                \\s* [:] \\s*\n                (?:  # <SIZE>\n                    \\d+\n                 )\n             )?\n            \\s*\n            (?:  # <ENDING>\n                [,;]\n             )\n         )\n        |\n        (?:\n            \\s*\n            (?:  # <CLOSE>\n                }}\n             )\n         )\n     )\n    ")
ENUM_MEMBER_DECL = textwrap.dedent(f"""\n    (?:\n        (?:\n            \\s*\n            (?:  # <CLOSE>\n                }}\n             )\n         )\n        |\n        (?:\n            \\s*\n            (?:  # <NAME>\n                {IDENTIFIER}\n             )\n            (?:\n                \\s* = \\s*\n                (?:  # <INIT>\n                    {_ind(STRING_LITERAL, 4)}\n                    |\n                    [^'",}}]+\n                 )\n             )?\n            \\s*\n            (?:  # <ENDING>\n                , | }}\n             )\n         )\n     )\n    """)
SIMPLE_STMT_BODY = textwrap.dedent(f"""\n    # simple statement body\n    (?:\n        (?:\n            [^'"{{}};]*\n            {_ind(STRING_LITERAL, 3)}\n         )*\n        [^'"{{}};]*\n        #(?= [;{{] )  # Note this lookahead.\n     )\n    # end simple statement body\n    """)
SIMPLE_STMT = textwrap.dedent(f"""\n    # simple statement\n    (?:\n        (?:  # <SIMPLE_STMT>\n            # stmt-inline "initializer"\n            (?:\n                return \\b\n                (?:\n                    \\s*\n                    {_ind(INITIALIZER, 5)}\n                )?\n             )\n            |\n            # variable assignment\n            (?:\n                (?: [*] \\s* )?\n                (?:\n                    {STRICT_IDENTIFIER} \\s*\n                    (?: . | -> ) \\s*\n                 )*\n                {STRICT_IDENTIFIER}\n                (?: \\s* \\[ \\s* \\d+ \\s* \\] )?\n                \\s* = \\s*\n                {_ind(INITIALIZER, 4)}\n             )\n            |\n            # catchall return statement\n            (?:\n                return \\b\n                (?:\n                    (?:\n                        [^'";]*\n                        {_ind(STRING_LITERAL, 6)}\n                     )*\n                    \\s* [^'";]*\n                 )?\n             )\n            |\n            # simple statement\n            (?:\n                {_ind(SIMPLE_STMT_BODY, 4)}\n             )\n         )\n        \\s*\n        (?:  # <SIMPLE_ENDING>\n            ;\n         )\n     )\n    # end simple statement\n    """)
COMPOUND_STMT = textwrap.dedent(f"""\n    # compound statement\n    (?:\n        \\b\n        (?:\n            (?:\n                (?:  # <COMPOUND_BARE>\n                    else | do\n                 )\n                \\b\n             )\n            |\n            (?:\n                (?:  # <COMPOUND_LABELED>\n                    (?:\n                        case \\b\n                        (?:\n                            [^'":]*\n                            {_ind(STRING_LITERAL, 7)}\n                         )*\n                        \\s* [^'":]*\n                     )\n                    |\n                    default\n                    |\n                    {STRICT_IDENTIFIER}\n                 )\n                \\s* [:]\n             )\n            |\n            (?:\n                (?:  # <COMPOUND_PAREN>\n                    for | while | if | switch\n                 )\n                \\s* (?= [(] )  # Note this lookahead.\n             )\n         )\n        \\s*\n     )\n    # end compound statement\n    """)
LOCAL = textwrap.dedent(f"""\n    (?:\n        # an empty statement\n        (?:  # <EMPTY>\n            ;\n         )\n        |\n        # inline type decl\n        (?:\n            (?:\n                (?:  # <INLINE_LEADING>\n                    [^;{{}}]+?\n                 )\n                \\s*\n             )?\n            (?:  # <INLINE_PRE>\n                (?: {STORAGE_CLASS} \\s* )?\n                (?: {TYPE_QUALIFIER} \\s* )?\n             )?  # </INLINE_PRE>\n            (?:  # <INLINE_KIND>\n                {COMPOUND_TYPE_KIND}\n             )\n            (?:\n                \\s+\n                (?:  # <INLINE_NAME>\n                    {STRICT_IDENTIFIER}\n                 )\n             )?\n            \\s* {{\n         )\n        |\n        # var decl\n        (?:\n            (?:  # <STORAGE>\n                {STORAGE_CLASS}\n             )?  # </STORAGE>\n            (?:\n                \\s*\n                (?:  # <VAR_DECL>\n                    {_ind(VAR_DECL, 5)}\n                 )\n             )\n            (?:\n                (?:\n                    # initializer\n                    # We expect only basic initializers.\n                    \\s* = \\s*\n                    (?:  # <VAR_INIT>\n                        {_ind(INITIALIZER, 6)}\n                     )\n                 )?\n                (?:\n                    \\s*\n                    (?:  # <VAR_ENDING>\n                        [,;]\n                     )\n                 )\n             )\n         )\n        |\n        {_ind(COMPOUND_STMT, 2)}\n        |\n        # start-of-block\n        (?:\n            (?:  # <BLOCK_LEADING>\n                (?:\n                    [^'"{{}};]*\n                    {_ind(STRING_LITERAL, 5)}\n                 )*\n                [^'"{{}};]*\n                # Presumably we will not see "== {{".\n                [^\\s='"{{}});]\n                \\s*\n             )?  # </BLOCK_LEADING>\n            (?:  # <BLOCK_OPEN>\n                {{\n             )\n         )\n        |\n        {_ind(SIMPLE_STMT, 2)}\n        |\n        # end-of-block\n        (?:  # <BLOCK_CLOSE>\n            }}\n         )\n     )\n    """)
LOCAL_STATICS = textwrap.dedent(f"""\n    (?:\n        # inline type decl\n        (?:\n            (?:\n                (?:  # <INLINE_LEADING>\n                    [^;{{}}]+?\n                 )\n                \\s*\n             )?\n            (?:  # <INLINE_PRE>\n                (?: {STORAGE_CLASS} \\s* )?\n                (?: {TYPE_QUALIFIER} \\s* )?\n             )?\n            (?:  # <INLINE_KIND>\n                {COMPOUND_TYPE_KIND}\n             )\n            (?:\n                \\s+\n                (?:  # <INLINE_NAME>\n                    {STRICT_IDENTIFIER}\n                 )\n             )?\n            \\s* {{\n         )\n        |\n        # var decl\n        (?:\n            # We only look for static variables.\n            (?:  # <STATIC_DECL>\n                static \\b\n                (?: \\s* {TYPE_QUALIFIER} )?\n                \\s* {_ind(TYPE_SPEC, 4)}\n                \\s* {_ind(DECLARATOR, 4)}\n             )\n            \\s*\n            (?:\n                (?:  # <STATIC_INIT>\n                    = \\s*\n                    {_ind(INITIALIZER, 4)}\n                    \\s*\n                    [,;{{]\n                 )\n                |\n                (?:  # <STATIC_ENDING>\n                    [,;]\n                 )\n             )\n         )\n        |\n        # everything else\n        (?:\n            (?:  # <DELIM_LEADING>\n                (?:\n                    [^'"{{}};]*\n                    {_ind(STRING_LITERAL, 4)}\n                 )*\n                \\s* [^'"{{}};]*\n             )\n            (?:\n                (?:  # <BLOCK_OPEN>\n                    {{\n                 )\n                |\n                (?:  # <BLOCK_CLOSE>\n                    }}\n                 )\n                |\n                (?:  # <STMT_END>\n                    ;\n                 )\n             )\n         )\n     )\n    """)
GLOBAL = textwrap.dedent(f"\n    (?:\n        # an empty statement\n        (?:  # <EMPTY>\n            ;\n         )\n        |\n\n        # compound type decl (maybe inline)\n        (?:\n            (?:\n                (?:  # <COMPOUND_LEADING>\n                    [^;{{}}]+?\n                 )\n                 \\s*\n             )?\n            (?:  # <COMPOUND_KIND>\n                {COMPOUND_TYPE_KIND}\n             )\n            (?:\n                \\s+\n                (?:  # <COMPOUND_NAME>\n                    {STRICT_IDENTIFIER}\n                 )\n             )?\n            \\s* {{\n         )\n        |\n        # bogus inline decl artifact\n        # This simplifies resolving the relative syntactic ambiguity of\n        # inline structs.\n        (?:\n            (?:  # <FORWARD_KIND>\n                {COMPOUND_TYPE_KIND}\n             )\n            \\s*\n            (?:  # <FORWARD_NAME>\n                {ANON_IDENTIFIER}\n             )\n            (?:  # <MAYBE_INLINE_ACTUAL>\n                [^=,;({{[*\\]]*\n                [=,;({{]\n             )\n         )\n        |\n\n        # typedef\n        (?:\n            \\b typedef \\b \\s*\n            (?:  # <TYPEDEF_DECL>\n                {_ind(VAR_DECL, 4)}\n             )\n            (?:\n                # We expect no inline type definitions in the parameters.\n                \\s* [(] \\s*\n                (?:  # <TYPEDEF_FUNC_PARAMS>\n                    [^{{;]*\n                 )\n                \\s* [)]\n             )?\n            \\s* ;\n         )\n        |\n\n        # func decl/definition & var decls\n        # XXX dedicated pattern for funcs (more restricted)?\n        (?:\n            (?:\n                (?:  # <VAR_STORAGE>\n                    {STORAGE_CLASS}\n                 )\n                \\s*\n             )?\n            (?:\n                (?:  # <FUNC_INLINE>\n                    \\b inline \\b\n                 )\n                \\s*\n             )?\n            (?:  # <VAR_DECL>\n                {_ind(VAR_DECL, 4)}\n             )\n            (?:\n                # func decl / definition\n                (?:\n                    (?:\n                        # We expect no inline type definitions in the parameters.\n                        \\s* [(] \\s*\n                        (?:  # <FUNC_PARAMS>\n                            [^{{;]*\n                         )\n                        \\s* [)] \\s*\n                        (?:  # <FUNC_DELIM>\n                            [{{;]\n                         )\n                     )\n                    |\n                    (?:\n                        # This is some old-school syntax!\n                        \\s* [(] \\s*\n                        # We throw away the bare names:\n                        {STRICT_IDENTIFIER}\n                        (?: \\s* , \\s* {STRICT_IDENTIFIER} )*\n                        \\s* [)] \\s*\n\n                        # We keep the trailing param declarations:\n                        (?:  # <FUNC_LEGACY_PARAMS>\n                            # There's at least one!\n                            (?: {TYPE_QUALIFIER} \\s* )?\n                            {_ind(TYPE_SPEC, 7)}\n                            \\s*\n                            {_ind(DECLARATOR, 7)}\n                            \\s* ;\n                            (?:\n                                \\s*\n                                (?: {TYPE_QUALIFIER} \\s* )?\n                                {_ind(TYPE_SPEC, 8)}\n                                \\s*\n                                {_ind(DECLARATOR, 8)}\n                                \\s* ;\n                             )*\n                         )\n                        \\s* {{\n                     )\n                 )\n                |\n                # var / typedef\n                (?:\n                    (?:\n                        # initializer\n                        # We expect only basic initializers.\n                        \\s* = \\s*\n                        (?:  # <VAR_INIT>\n                            {_ind(INITIALIZER, 6)}\n                         )\n                     )?\n                    \\s*\n                    (?:  # <VAR_ENDING>\n                        [,;]\n                     )\n                 )\n             )\n         )\n     )\n    ")