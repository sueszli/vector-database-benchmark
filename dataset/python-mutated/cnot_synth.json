[
    {
        "func_name": "synth_cnot_count_full_pmh",
        "original": "def synth_cnot_count_full_pmh(state, section_size=2):\n    \"\"\"\n    Synthesize linear reversible circuits for all-to-all architecture\n    using Patel, Markov and Hayes method.\n\n    This function is an implementation of the Patel, Markov and Hayes algorithm from [1]\n    for optimal synthesis of linear reversible circuits for all-to-all architecture,\n    as specified by an n x n matrix.\n\n    Args:\n        state (list[list] or ndarray): n x n boolean invertible matrix, describing the state\n            of the input circuit\n        section_size (int): the size of each section, used in the\n            Patel\u2013Markov\u2013Hayes algorithm [1]. section_size must be a factor of num_qubits.\n\n    Returns:\n        QuantumCircuit: a CX-only circuit implementing the linear transformation.\n\n    Raises:\n        QiskitError: when variable \"state\" isn't of type numpy.ndarray\n\n    References:\n        1. Patel, Ketan N., Igor L. Markov, and John P. Hayes,\n           *Optimal synthesis of linear reversible circuits*,\n           Quantum Information & Computation 8.3 (2008): 282-294.\n           `arXiv:quant-ph/0302002 [quant-ph] <https://arxiv.org/abs/quant-ph/0302002>`_\n    \"\"\"\n    if not isinstance(state, (list, np.ndarray)):\n        raise QiskitError('state should be of type list or numpy.ndarray, but was of the type {}'.format(type(state)))\n    state = np.array(state)\n    [state, circuit_l] = _lwr_cnot_synth(state, section_size)\n    state = np.transpose(state)\n    [state, circuit_u] = _lwr_cnot_synth(state, section_size)\n    circuit_l.reverse()\n    for i in circuit_u:\n        i.reverse()\n    circ = QuantumCircuit(state.shape[0])\n    for i in circuit_u + circuit_l:\n        circ.cx(i[0], i[1])\n    return circ",
        "mutated": [
            "def synth_cnot_count_full_pmh(state, section_size=2):\n    if False:\n        i = 10\n    '\\n    Synthesize linear reversible circuits for all-to-all architecture\\n    using Patel, Markov and Hayes method.\\n\\n    This function is an implementation of the Patel, Markov and Hayes algorithm from [1]\\n    for optimal synthesis of linear reversible circuits for all-to-all architecture,\\n    as specified by an n x n matrix.\\n\\n    Args:\\n        state (list[list] or ndarray): n x n boolean invertible matrix, describing the state\\n            of the input circuit\\n        section_size (int): the size of each section, used in the\\n            Patel\u2013Markov\u2013Hayes algorithm [1]. section_size must be a factor of num_qubits.\\n\\n    Returns:\\n        QuantumCircuit: a CX-only circuit implementing the linear transformation.\\n\\n    Raises:\\n        QiskitError: when variable \"state\" isn\\'t of type numpy.ndarray\\n\\n    References:\\n        1. Patel, Ketan N., Igor L. Markov, and John P. Hayes,\\n           *Optimal synthesis of linear reversible circuits*,\\n           Quantum Information & Computation 8.3 (2008): 282-294.\\n           `arXiv:quant-ph/0302002 [quant-ph] <https://arxiv.org/abs/quant-ph/0302002>`_\\n    '\n    if not isinstance(state, (list, np.ndarray)):\n        raise QiskitError('state should be of type list or numpy.ndarray, but was of the type {}'.format(type(state)))\n    state = np.array(state)\n    [state, circuit_l] = _lwr_cnot_synth(state, section_size)\n    state = np.transpose(state)\n    [state, circuit_u] = _lwr_cnot_synth(state, section_size)\n    circuit_l.reverse()\n    for i in circuit_u:\n        i.reverse()\n    circ = QuantumCircuit(state.shape[0])\n    for i in circuit_u + circuit_l:\n        circ.cx(i[0], i[1])\n    return circ",
            "def synth_cnot_count_full_pmh(state, section_size=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Synthesize linear reversible circuits for all-to-all architecture\\n    using Patel, Markov and Hayes method.\\n\\n    This function is an implementation of the Patel, Markov and Hayes algorithm from [1]\\n    for optimal synthesis of linear reversible circuits for all-to-all architecture,\\n    as specified by an n x n matrix.\\n\\n    Args:\\n        state (list[list] or ndarray): n x n boolean invertible matrix, describing the state\\n            of the input circuit\\n        section_size (int): the size of each section, used in the\\n            Patel\u2013Markov\u2013Hayes algorithm [1]. section_size must be a factor of num_qubits.\\n\\n    Returns:\\n        QuantumCircuit: a CX-only circuit implementing the linear transformation.\\n\\n    Raises:\\n        QiskitError: when variable \"state\" isn\\'t of type numpy.ndarray\\n\\n    References:\\n        1. Patel, Ketan N., Igor L. Markov, and John P. Hayes,\\n           *Optimal synthesis of linear reversible circuits*,\\n           Quantum Information & Computation 8.3 (2008): 282-294.\\n           `arXiv:quant-ph/0302002 [quant-ph] <https://arxiv.org/abs/quant-ph/0302002>`_\\n    '\n    if not isinstance(state, (list, np.ndarray)):\n        raise QiskitError('state should be of type list or numpy.ndarray, but was of the type {}'.format(type(state)))\n    state = np.array(state)\n    [state, circuit_l] = _lwr_cnot_synth(state, section_size)\n    state = np.transpose(state)\n    [state, circuit_u] = _lwr_cnot_synth(state, section_size)\n    circuit_l.reverse()\n    for i in circuit_u:\n        i.reverse()\n    circ = QuantumCircuit(state.shape[0])\n    for i in circuit_u + circuit_l:\n        circ.cx(i[0], i[1])\n    return circ",
            "def synth_cnot_count_full_pmh(state, section_size=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Synthesize linear reversible circuits for all-to-all architecture\\n    using Patel, Markov and Hayes method.\\n\\n    This function is an implementation of the Patel, Markov and Hayes algorithm from [1]\\n    for optimal synthesis of linear reversible circuits for all-to-all architecture,\\n    as specified by an n x n matrix.\\n\\n    Args:\\n        state (list[list] or ndarray): n x n boolean invertible matrix, describing the state\\n            of the input circuit\\n        section_size (int): the size of each section, used in the\\n            Patel\u2013Markov\u2013Hayes algorithm [1]. section_size must be a factor of num_qubits.\\n\\n    Returns:\\n        QuantumCircuit: a CX-only circuit implementing the linear transformation.\\n\\n    Raises:\\n        QiskitError: when variable \"state\" isn\\'t of type numpy.ndarray\\n\\n    References:\\n        1. Patel, Ketan N., Igor L. Markov, and John P. Hayes,\\n           *Optimal synthesis of linear reversible circuits*,\\n           Quantum Information & Computation 8.3 (2008): 282-294.\\n           `arXiv:quant-ph/0302002 [quant-ph] <https://arxiv.org/abs/quant-ph/0302002>`_\\n    '\n    if not isinstance(state, (list, np.ndarray)):\n        raise QiskitError('state should be of type list or numpy.ndarray, but was of the type {}'.format(type(state)))\n    state = np.array(state)\n    [state, circuit_l] = _lwr_cnot_synth(state, section_size)\n    state = np.transpose(state)\n    [state, circuit_u] = _lwr_cnot_synth(state, section_size)\n    circuit_l.reverse()\n    for i in circuit_u:\n        i.reverse()\n    circ = QuantumCircuit(state.shape[0])\n    for i in circuit_u + circuit_l:\n        circ.cx(i[0], i[1])\n    return circ",
            "def synth_cnot_count_full_pmh(state, section_size=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Synthesize linear reversible circuits for all-to-all architecture\\n    using Patel, Markov and Hayes method.\\n\\n    This function is an implementation of the Patel, Markov and Hayes algorithm from [1]\\n    for optimal synthesis of linear reversible circuits for all-to-all architecture,\\n    as specified by an n x n matrix.\\n\\n    Args:\\n        state (list[list] or ndarray): n x n boolean invertible matrix, describing the state\\n            of the input circuit\\n        section_size (int): the size of each section, used in the\\n            Patel\u2013Markov\u2013Hayes algorithm [1]. section_size must be a factor of num_qubits.\\n\\n    Returns:\\n        QuantumCircuit: a CX-only circuit implementing the linear transformation.\\n\\n    Raises:\\n        QiskitError: when variable \"state\" isn\\'t of type numpy.ndarray\\n\\n    References:\\n        1. Patel, Ketan N., Igor L. Markov, and John P. Hayes,\\n           *Optimal synthesis of linear reversible circuits*,\\n           Quantum Information & Computation 8.3 (2008): 282-294.\\n           `arXiv:quant-ph/0302002 [quant-ph] <https://arxiv.org/abs/quant-ph/0302002>`_\\n    '\n    if not isinstance(state, (list, np.ndarray)):\n        raise QiskitError('state should be of type list or numpy.ndarray, but was of the type {}'.format(type(state)))\n    state = np.array(state)\n    [state, circuit_l] = _lwr_cnot_synth(state, section_size)\n    state = np.transpose(state)\n    [state, circuit_u] = _lwr_cnot_synth(state, section_size)\n    circuit_l.reverse()\n    for i in circuit_u:\n        i.reverse()\n    circ = QuantumCircuit(state.shape[0])\n    for i in circuit_u + circuit_l:\n        circ.cx(i[0], i[1])\n    return circ",
            "def synth_cnot_count_full_pmh(state, section_size=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Synthesize linear reversible circuits for all-to-all architecture\\n    using Patel, Markov and Hayes method.\\n\\n    This function is an implementation of the Patel, Markov and Hayes algorithm from [1]\\n    for optimal synthesis of linear reversible circuits for all-to-all architecture,\\n    as specified by an n x n matrix.\\n\\n    Args:\\n        state (list[list] or ndarray): n x n boolean invertible matrix, describing the state\\n            of the input circuit\\n        section_size (int): the size of each section, used in the\\n            Patel\u2013Markov\u2013Hayes algorithm [1]. section_size must be a factor of num_qubits.\\n\\n    Returns:\\n        QuantumCircuit: a CX-only circuit implementing the linear transformation.\\n\\n    Raises:\\n        QiskitError: when variable \"state\" isn\\'t of type numpy.ndarray\\n\\n    References:\\n        1. Patel, Ketan N., Igor L. Markov, and John P. Hayes,\\n           *Optimal synthesis of linear reversible circuits*,\\n           Quantum Information & Computation 8.3 (2008): 282-294.\\n           `arXiv:quant-ph/0302002 [quant-ph] <https://arxiv.org/abs/quant-ph/0302002>`_\\n    '\n    if not isinstance(state, (list, np.ndarray)):\n        raise QiskitError('state should be of type list or numpy.ndarray, but was of the type {}'.format(type(state)))\n    state = np.array(state)\n    [state, circuit_l] = _lwr_cnot_synth(state, section_size)\n    state = np.transpose(state)\n    [state, circuit_u] = _lwr_cnot_synth(state, section_size)\n    circuit_l.reverse()\n    for i in circuit_u:\n        i.reverse()\n    circ = QuantumCircuit(state.shape[0])\n    for i in circuit_u + circuit_l:\n        circ.cx(i[0], i[1])\n    return circ"
        ]
    },
    {
        "func_name": "_lwr_cnot_synth",
        "original": "def _lwr_cnot_synth(state, section_size):\n    \"\"\"\n    This function is a helper function of the algorithm for optimal synthesis\n    of linear reversible circuits (the Patel\u2013Markov\u2013Hayes algorithm). It works\n    like gaussian elimination, except that it works a lot faster, and requires\n    fewer steps (and therefore fewer CNOTs). It takes the matrix \"state\" and\n    splits it into sections of size section_size. Then it eliminates all non-zero\n    sub-rows within each section, which are the same as a non-zero sub-row\n    above. Once this has been done, it continues with normal gaussian elimination.\n    The benefit is that with small section sizes (m), most of the sub-rows will\n    be cleared in the first step, resulting in a factor m fewer row row operations\n    during Gaussian elimination.\n\n    The algorithm is described in detail in the following paper\n    \"Optimal synthesis of linear reversible circuits.\"\n    Patel, Ketan N., Igor L. Markov, and John P. Hayes.\n    Quantum Information & Computation 8.3 (2008): 282-294.\n\n    Note:\n    This implementation tweaks the Patel, Markov, and Hayes algorithm by adding\n    a \"back reduce\" which adds rows below the pivot row with a high degree of\n    overlap back to it. The intuition is to avoid a high-weight pivot row\n    increasing the weight of lower rows.\n\n    Args:\n        state (ndarray): n x n matrix, describing a linear quantum circuit\n        section_size (int): the section size the matrix columns are divided into\n\n    Returns:\n        numpy.matrix: n by n matrix, describing the state of the output circuit\n        list: a k by 2 list of C-NOT operations that need to be applied\n    \"\"\"\n    circuit = []\n    num_qubits = state.shape[0]\n    cutoff = 1\n    for sec in range(1, int(np.floor(num_qubits / section_size) + 1)):\n        patt = {}\n        for row in range((sec - 1) * section_size, num_qubits):\n            sub_row_patt = copy.deepcopy(state[row, (sec - 1) * section_size:sec * section_size])\n            if np.sum(sub_row_patt) == 0:\n                continue\n            if str(sub_row_patt) not in patt:\n                patt[str(sub_row_patt)] = row\n            else:\n                state[row, :] ^= state[patt[str(sub_row_patt)], :]\n                circuit.append([patt[str(sub_row_patt)], row])\n        for col in range((sec - 1) * section_size, sec * section_size):\n            diag_one = 1\n            if state[col, col] == 0:\n                diag_one = 0\n            for row in range(col + 1, num_qubits):\n                if state[row, col] == 1:\n                    if diag_one == 0:\n                        state[col, :] ^= state[row, :]\n                        circuit.append([row, col])\n                        diag_one = 1\n                    state[row, :] ^= state[col, :]\n                    circuit.append([col, row])\n                if sum(state[col, :] & state[row, :]) > cutoff:\n                    state[col, :] ^= state[row, :]\n                    circuit.append([row, col])\n    return [state, circuit]",
        "mutated": [
            "def _lwr_cnot_synth(state, section_size):\n    if False:\n        i = 10\n    '\\n    This function is a helper function of the algorithm for optimal synthesis\\n    of linear reversible circuits (the Patel\u2013Markov\u2013Hayes algorithm). It works\\n    like gaussian elimination, except that it works a lot faster, and requires\\n    fewer steps (and therefore fewer CNOTs). It takes the matrix \"state\" and\\n    splits it into sections of size section_size. Then it eliminates all non-zero\\n    sub-rows within each section, which are the same as a non-zero sub-row\\n    above. Once this has been done, it continues with normal gaussian elimination.\\n    The benefit is that with small section sizes (m), most of the sub-rows will\\n    be cleared in the first step, resulting in a factor m fewer row row operations\\n    during Gaussian elimination.\\n\\n    The algorithm is described in detail in the following paper\\n    \"Optimal synthesis of linear reversible circuits.\"\\n    Patel, Ketan N., Igor L. Markov, and John P. Hayes.\\n    Quantum Information & Computation 8.3 (2008): 282-294.\\n\\n    Note:\\n    This implementation tweaks the Patel, Markov, and Hayes algorithm by adding\\n    a \"back reduce\" which adds rows below the pivot row with a high degree of\\n    overlap back to it. The intuition is to avoid a high-weight pivot row\\n    increasing the weight of lower rows.\\n\\n    Args:\\n        state (ndarray): n x n matrix, describing a linear quantum circuit\\n        section_size (int): the section size the matrix columns are divided into\\n\\n    Returns:\\n        numpy.matrix: n by n matrix, describing the state of the output circuit\\n        list: a k by 2 list of C-NOT operations that need to be applied\\n    '\n    circuit = []\n    num_qubits = state.shape[0]\n    cutoff = 1\n    for sec in range(1, int(np.floor(num_qubits / section_size) + 1)):\n        patt = {}\n        for row in range((sec - 1) * section_size, num_qubits):\n            sub_row_patt = copy.deepcopy(state[row, (sec - 1) * section_size:sec * section_size])\n            if np.sum(sub_row_patt) == 0:\n                continue\n            if str(sub_row_patt) not in patt:\n                patt[str(sub_row_patt)] = row\n            else:\n                state[row, :] ^= state[patt[str(sub_row_patt)], :]\n                circuit.append([patt[str(sub_row_patt)], row])\n        for col in range((sec - 1) * section_size, sec * section_size):\n            diag_one = 1\n            if state[col, col] == 0:\n                diag_one = 0\n            for row in range(col + 1, num_qubits):\n                if state[row, col] == 1:\n                    if diag_one == 0:\n                        state[col, :] ^= state[row, :]\n                        circuit.append([row, col])\n                        diag_one = 1\n                    state[row, :] ^= state[col, :]\n                    circuit.append([col, row])\n                if sum(state[col, :] & state[row, :]) > cutoff:\n                    state[col, :] ^= state[row, :]\n                    circuit.append([row, col])\n    return [state, circuit]",
            "def _lwr_cnot_synth(state, section_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    This function is a helper function of the algorithm for optimal synthesis\\n    of linear reversible circuits (the Patel\u2013Markov\u2013Hayes algorithm). It works\\n    like gaussian elimination, except that it works a lot faster, and requires\\n    fewer steps (and therefore fewer CNOTs). It takes the matrix \"state\" and\\n    splits it into sections of size section_size. Then it eliminates all non-zero\\n    sub-rows within each section, which are the same as a non-zero sub-row\\n    above. Once this has been done, it continues with normal gaussian elimination.\\n    The benefit is that with small section sizes (m), most of the sub-rows will\\n    be cleared in the first step, resulting in a factor m fewer row row operations\\n    during Gaussian elimination.\\n\\n    The algorithm is described in detail in the following paper\\n    \"Optimal synthesis of linear reversible circuits.\"\\n    Patel, Ketan N., Igor L. Markov, and John P. Hayes.\\n    Quantum Information & Computation 8.3 (2008): 282-294.\\n\\n    Note:\\n    This implementation tweaks the Patel, Markov, and Hayes algorithm by adding\\n    a \"back reduce\" which adds rows below the pivot row with a high degree of\\n    overlap back to it. The intuition is to avoid a high-weight pivot row\\n    increasing the weight of lower rows.\\n\\n    Args:\\n        state (ndarray): n x n matrix, describing a linear quantum circuit\\n        section_size (int): the section size the matrix columns are divided into\\n\\n    Returns:\\n        numpy.matrix: n by n matrix, describing the state of the output circuit\\n        list: a k by 2 list of C-NOT operations that need to be applied\\n    '\n    circuit = []\n    num_qubits = state.shape[0]\n    cutoff = 1\n    for sec in range(1, int(np.floor(num_qubits / section_size) + 1)):\n        patt = {}\n        for row in range((sec - 1) * section_size, num_qubits):\n            sub_row_patt = copy.deepcopy(state[row, (sec - 1) * section_size:sec * section_size])\n            if np.sum(sub_row_patt) == 0:\n                continue\n            if str(sub_row_patt) not in patt:\n                patt[str(sub_row_patt)] = row\n            else:\n                state[row, :] ^= state[patt[str(sub_row_patt)], :]\n                circuit.append([patt[str(sub_row_patt)], row])\n        for col in range((sec - 1) * section_size, sec * section_size):\n            diag_one = 1\n            if state[col, col] == 0:\n                diag_one = 0\n            for row in range(col + 1, num_qubits):\n                if state[row, col] == 1:\n                    if diag_one == 0:\n                        state[col, :] ^= state[row, :]\n                        circuit.append([row, col])\n                        diag_one = 1\n                    state[row, :] ^= state[col, :]\n                    circuit.append([col, row])\n                if sum(state[col, :] & state[row, :]) > cutoff:\n                    state[col, :] ^= state[row, :]\n                    circuit.append([row, col])\n    return [state, circuit]",
            "def _lwr_cnot_synth(state, section_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    This function is a helper function of the algorithm for optimal synthesis\\n    of linear reversible circuits (the Patel\u2013Markov\u2013Hayes algorithm). It works\\n    like gaussian elimination, except that it works a lot faster, and requires\\n    fewer steps (and therefore fewer CNOTs). It takes the matrix \"state\" and\\n    splits it into sections of size section_size. Then it eliminates all non-zero\\n    sub-rows within each section, which are the same as a non-zero sub-row\\n    above. Once this has been done, it continues with normal gaussian elimination.\\n    The benefit is that with small section sizes (m), most of the sub-rows will\\n    be cleared in the first step, resulting in a factor m fewer row row operations\\n    during Gaussian elimination.\\n\\n    The algorithm is described in detail in the following paper\\n    \"Optimal synthesis of linear reversible circuits.\"\\n    Patel, Ketan N., Igor L. Markov, and John P. Hayes.\\n    Quantum Information & Computation 8.3 (2008): 282-294.\\n\\n    Note:\\n    This implementation tweaks the Patel, Markov, and Hayes algorithm by adding\\n    a \"back reduce\" which adds rows below the pivot row with a high degree of\\n    overlap back to it. The intuition is to avoid a high-weight pivot row\\n    increasing the weight of lower rows.\\n\\n    Args:\\n        state (ndarray): n x n matrix, describing a linear quantum circuit\\n        section_size (int): the section size the matrix columns are divided into\\n\\n    Returns:\\n        numpy.matrix: n by n matrix, describing the state of the output circuit\\n        list: a k by 2 list of C-NOT operations that need to be applied\\n    '\n    circuit = []\n    num_qubits = state.shape[0]\n    cutoff = 1\n    for sec in range(1, int(np.floor(num_qubits / section_size) + 1)):\n        patt = {}\n        for row in range((sec - 1) * section_size, num_qubits):\n            sub_row_patt = copy.deepcopy(state[row, (sec - 1) * section_size:sec * section_size])\n            if np.sum(sub_row_patt) == 0:\n                continue\n            if str(sub_row_patt) not in patt:\n                patt[str(sub_row_patt)] = row\n            else:\n                state[row, :] ^= state[patt[str(sub_row_patt)], :]\n                circuit.append([patt[str(sub_row_patt)], row])\n        for col in range((sec - 1) * section_size, sec * section_size):\n            diag_one = 1\n            if state[col, col] == 0:\n                diag_one = 0\n            for row in range(col + 1, num_qubits):\n                if state[row, col] == 1:\n                    if diag_one == 0:\n                        state[col, :] ^= state[row, :]\n                        circuit.append([row, col])\n                        diag_one = 1\n                    state[row, :] ^= state[col, :]\n                    circuit.append([col, row])\n                if sum(state[col, :] & state[row, :]) > cutoff:\n                    state[col, :] ^= state[row, :]\n                    circuit.append([row, col])\n    return [state, circuit]",
            "def _lwr_cnot_synth(state, section_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    This function is a helper function of the algorithm for optimal synthesis\\n    of linear reversible circuits (the Patel\u2013Markov\u2013Hayes algorithm). It works\\n    like gaussian elimination, except that it works a lot faster, and requires\\n    fewer steps (and therefore fewer CNOTs). It takes the matrix \"state\" and\\n    splits it into sections of size section_size. Then it eliminates all non-zero\\n    sub-rows within each section, which are the same as a non-zero sub-row\\n    above. Once this has been done, it continues with normal gaussian elimination.\\n    The benefit is that with small section sizes (m), most of the sub-rows will\\n    be cleared in the first step, resulting in a factor m fewer row row operations\\n    during Gaussian elimination.\\n\\n    The algorithm is described in detail in the following paper\\n    \"Optimal synthesis of linear reversible circuits.\"\\n    Patel, Ketan N., Igor L. Markov, and John P. Hayes.\\n    Quantum Information & Computation 8.3 (2008): 282-294.\\n\\n    Note:\\n    This implementation tweaks the Patel, Markov, and Hayes algorithm by adding\\n    a \"back reduce\" which adds rows below the pivot row with a high degree of\\n    overlap back to it. The intuition is to avoid a high-weight pivot row\\n    increasing the weight of lower rows.\\n\\n    Args:\\n        state (ndarray): n x n matrix, describing a linear quantum circuit\\n        section_size (int): the section size the matrix columns are divided into\\n\\n    Returns:\\n        numpy.matrix: n by n matrix, describing the state of the output circuit\\n        list: a k by 2 list of C-NOT operations that need to be applied\\n    '\n    circuit = []\n    num_qubits = state.shape[0]\n    cutoff = 1\n    for sec in range(1, int(np.floor(num_qubits / section_size) + 1)):\n        patt = {}\n        for row in range((sec - 1) * section_size, num_qubits):\n            sub_row_patt = copy.deepcopy(state[row, (sec - 1) * section_size:sec * section_size])\n            if np.sum(sub_row_patt) == 0:\n                continue\n            if str(sub_row_patt) not in patt:\n                patt[str(sub_row_patt)] = row\n            else:\n                state[row, :] ^= state[patt[str(sub_row_patt)], :]\n                circuit.append([patt[str(sub_row_patt)], row])\n        for col in range((sec - 1) * section_size, sec * section_size):\n            diag_one = 1\n            if state[col, col] == 0:\n                diag_one = 0\n            for row in range(col + 1, num_qubits):\n                if state[row, col] == 1:\n                    if diag_one == 0:\n                        state[col, :] ^= state[row, :]\n                        circuit.append([row, col])\n                        diag_one = 1\n                    state[row, :] ^= state[col, :]\n                    circuit.append([col, row])\n                if sum(state[col, :] & state[row, :]) > cutoff:\n                    state[col, :] ^= state[row, :]\n                    circuit.append([row, col])\n    return [state, circuit]",
            "def _lwr_cnot_synth(state, section_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    This function is a helper function of the algorithm for optimal synthesis\\n    of linear reversible circuits (the Patel\u2013Markov\u2013Hayes algorithm). It works\\n    like gaussian elimination, except that it works a lot faster, and requires\\n    fewer steps (and therefore fewer CNOTs). It takes the matrix \"state\" and\\n    splits it into sections of size section_size. Then it eliminates all non-zero\\n    sub-rows within each section, which are the same as a non-zero sub-row\\n    above. Once this has been done, it continues with normal gaussian elimination.\\n    The benefit is that with small section sizes (m), most of the sub-rows will\\n    be cleared in the first step, resulting in a factor m fewer row row operations\\n    during Gaussian elimination.\\n\\n    The algorithm is described in detail in the following paper\\n    \"Optimal synthesis of linear reversible circuits.\"\\n    Patel, Ketan N., Igor L. Markov, and John P. Hayes.\\n    Quantum Information & Computation 8.3 (2008): 282-294.\\n\\n    Note:\\n    This implementation tweaks the Patel, Markov, and Hayes algorithm by adding\\n    a \"back reduce\" which adds rows below the pivot row with a high degree of\\n    overlap back to it. The intuition is to avoid a high-weight pivot row\\n    increasing the weight of lower rows.\\n\\n    Args:\\n        state (ndarray): n x n matrix, describing a linear quantum circuit\\n        section_size (int): the section size the matrix columns are divided into\\n\\n    Returns:\\n        numpy.matrix: n by n matrix, describing the state of the output circuit\\n        list: a k by 2 list of C-NOT operations that need to be applied\\n    '\n    circuit = []\n    num_qubits = state.shape[0]\n    cutoff = 1\n    for sec in range(1, int(np.floor(num_qubits / section_size) + 1)):\n        patt = {}\n        for row in range((sec - 1) * section_size, num_qubits):\n            sub_row_patt = copy.deepcopy(state[row, (sec - 1) * section_size:sec * section_size])\n            if np.sum(sub_row_patt) == 0:\n                continue\n            if str(sub_row_patt) not in patt:\n                patt[str(sub_row_patt)] = row\n            else:\n                state[row, :] ^= state[patt[str(sub_row_patt)], :]\n                circuit.append([patt[str(sub_row_patt)], row])\n        for col in range((sec - 1) * section_size, sec * section_size):\n            diag_one = 1\n            if state[col, col] == 0:\n                diag_one = 0\n            for row in range(col + 1, num_qubits):\n                if state[row, col] == 1:\n                    if diag_one == 0:\n                        state[col, :] ^= state[row, :]\n                        circuit.append([row, col])\n                        diag_one = 1\n                    state[row, :] ^= state[col, :]\n                    circuit.append([col, row])\n                if sum(state[col, :] & state[row, :]) > cutoff:\n                    state[col, :] ^= state[row, :]\n                    circuit.append([row, col])\n    return [state, circuit]"
        ]
    }
]