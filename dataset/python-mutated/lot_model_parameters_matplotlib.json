[
    {
        "func_name": "plot_parameters",
        "original": "def plot_parameters(m, plot_configuration, quantile=0.5, weekly_start=0, yearly_start=0, figsize=None, df_name=None, forecast_in_focus=None):\n    \"\"\"Plot the parameters that the model is composed of, visually.\n\n    Parameters\n    ----------\n        m : NeuralProphet\n            Fitted model\n        plot_configuration: dict\n            dict of configured parameters to plot\n        quantile : float\n            The quantile for which the model parameters are to be plotted\n        weekly_start : int\n            Specifying the start day of the weekly seasonality plot\n\n            Options\n                * (default) ``weekly_start = 0``: starts the week on Sunday\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\n        yearly_start : int\n            Specifying the start day of the yearly seasonality plot.\n\n            Options\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\n        figsize : tuple\n            Width, height in inches.\n\n            Note\n            ----\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\n        df_name : str\n            Name of dataframe to refer to data params from original keys of train dataframes\n\n            Note\n            ----\n            Only used for local normalization in global modeling\n        forecast_in_focus: int\n            optinal, i-th step ahead forecast to plot\n\n            Note\n            ----\n            None (default): plot self.highlight_forecast_step_n by default\n\n    Returns\n    -------\n        matplotlib.pyplot.figure\n            Figure showing the NeuralProphet parameters\n\n    Examples\n    --------\n    Base usage of :meth:`plot_parameters`\n\n    >>> from neuralprophet import NeuralProphet\n    >>> m = NeuralProphet()\n    >>> metrics = m.fit(df, freq=\"D\")\n    >>> future = m.make_future_dataframe(df=df, periods=365)\n    >>> forecast = m.predict(df=future)\n    >>> m.plot_parameters()\n\n    \"\"\"\n    components_to_plot = plot_configuration['components_list']\n    additive_future_regressors = plot_configuration['additive_future_regressors']\n    additive_events = plot_configuration['additive_events']\n    multiplicative_future_regressors = plot_configuration['multiplicative_future_regressors']\n    multiplicative_events = plot_configuration['multiplicative_events']\n    lagged_scalar_regressors = plot_configuration['lagged_scalar_regressors']\n    overwriting_unknown_data_normalization = plot_configuration['overwriting_unknown_data_normalization']\n    npanel = len(components_to_plot)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    for (ax, comp) in zip(axes, components_to_plot):\n        plot_name = comp['plot_name'].lower()\n        if plot_name.startswith('trend'):\n            if 'change' in plot_name:\n                plot_trend_change(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n            else:\n                plot_trend(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n        elif plot_name.startswith('seasonality'):\n            name = comp['comp_name']\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if name.lower() == 'weekly' or m.config_seasonality.periods[name].period == 7:\n                plot_weekly(m=m, quantile=quantile, ax=ax, weekly_start=weekly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'yearly' or m.config_seasonality.periods[name].period == 365.25:\n                plot_yearly(m=m, quantile=quantile, ax=ax, yearly_start=yearly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'daily' or m.config_seasonality.periods[name].period == 1:\n                plot_daily(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n            else:\n                plot_custom_season(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n        elif plot_name == 'lagged weights':\n            plot_lagged_weights(weights=comp['weights'], comp_name=comp['comp_name'], focus=comp['focus'], ax=ax)\n        else:\n            if plot_name == 'additive future regressor':\n                weights = additive_future_regressors\n            elif plot_name == 'multiplicative future regressor':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_future_regressors\n            elif plot_name == 'lagged scalar regressor':\n                weights = lagged_scalar_regressors\n            elif plot_name == 'additive event':\n                weights = additive_events\n            elif plot_name == 'multiplicative event':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_events\n            plot_scalar_weights(weights=weights, plot_name=comp['plot_name'], focus=forecast_in_focus, ax=ax)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    if overwriting_unknown_data_normalization:\n        m.config_normalization.unknown_data_normalization = False\n    return fig",
        "mutated": [
            "def plot_parameters(m, plot_configuration, quantile=0.5, weekly_start=0, yearly_start=0, figsize=None, df_name=None, forecast_in_focus=None):\n    if False:\n        i = 10\n    'Plot the parameters that the model is composed of, visually.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        plot_configuration: dict\\n            dict of configured parameters to plot\\n        quantile : float\\n            The quantile for which the model parameters are to be plotted\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot.\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n        forecast_in_focus: int\\n            optinal, i-th step ahead forecast to plot\\n\\n            Note\\n            ----\\n            None (default): plot self.highlight_forecast_step_n by default\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet parameters\\n\\n    Examples\\n    --------\\n    Base usage of :meth:`plot_parameters`\\n\\n    >>> from neuralprophet import NeuralProphet\\n    >>> m = NeuralProphet()\\n    >>> metrics = m.fit(df, freq=\"D\")\\n    >>> future = m.make_future_dataframe(df=df, periods=365)\\n    >>> forecast = m.predict(df=future)\\n    >>> m.plot_parameters()\\n\\n    '\n    components_to_plot = plot_configuration['components_list']\n    additive_future_regressors = plot_configuration['additive_future_regressors']\n    additive_events = plot_configuration['additive_events']\n    multiplicative_future_regressors = plot_configuration['multiplicative_future_regressors']\n    multiplicative_events = plot_configuration['multiplicative_events']\n    lagged_scalar_regressors = plot_configuration['lagged_scalar_regressors']\n    overwriting_unknown_data_normalization = plot_configuration['overwriting_unknown_data_normalization']\n    npanel = len(components_to_plot)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    for (ax, comp) in zip(axes, components_to_plot):\n        plot_name = comp['plot_name'].lower()\n        if plot_name.startswith('trend'):\n            if 'change' in plot_name:\n                plot_trend_change(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n            else:\n                plot_trend(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n        elif plot_name.startswith('seasonality'):\n            name = comp['comp_name']\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if name.lower() == 'weekly' or m.config_seasonality.periods[name].period == 7:\n                plot_weekly(m=m, quantile=quantile, ax=ax, weekly_start=weekly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'yearly' or m.config_seasonality.periods[name].period == 365.25:\n                plot_yearly(m=m, quantile=quantile, ax=ax, yearly_start=yearly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'daily' or m.config_seasonality.periods[name].period == 1:\n                plot_daily(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n            else:\n                plot_custom_season(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n        elif plot_name == 'lagged weights':\n            plot_lagged_weights(weights=comp['weights'], comp_name=comp['comp_name'], focus=comp['focus'], ax=ax)\n        else:\n            if plot_name == 'additive future regressor':\n                weights = additive_future_regressors\n            elif plot_name == 'multiplicative future regressor':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_future_regressors\n            elif plot_name == 'lagged scalar regressor':\n                weights = lagged_scalar_regressors\n            elif plot_name == 'additive event':\n                weights = additive_events\n            elif plot_name == 'multiplicative event':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_events\n            plot_scalar_weights(weights=weights, plot_name=comp['plot_name'], focus=forecast_in_focus, ax=ax)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    if overwriting_unknown_data_normalization:\n        m.config_normalization.unknown_data_normalization = False\n    return fig",
            "def plot_parameters(m, plot_configuration, quantile=0.5, weekly_start=0, yearly_start=0, figsize=None, df_name=None, forecast_in_focus=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the parameters that the model is composed of, visually.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        plot_configuration: dict\\n            dict of configured parameters to plot\\n        quantile : float\\n            The quantile for which the model parameters are to be plotted\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot.\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n        forecast_in_focus: int\\n            optinal, i-th step ahead forecast to plot\\n\\n            Note\\n            ----\\n            None (default): plot self.highlight_forecast_step_n by default\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet parameters\\n\\n    Examples\\n    --------\\n    Base usage of :meth:`plot_parameters`\\n\\n    >>> from neuralprophet import NeuralProphet\\n    >>> m = NeuralProphet()\\n    >>> metrics = m.fit(df, freq=\"D\")\\n    >>> future = m.make_future_dataframe(df=df, periods=365)\\n    >>> forecast = m.predict(df=future)\\n    >>> m.plot_parameters()\\n\\n    '\n    components_to_plot = plot_configuration['components_list']\n    additive_future_regressors = plot_configuration['additive_future_regressors']\n    additive_events = plot_configuration['additive_events']\n    multiplicative_future_regressors = plot_configuration['multiplicative_future_regressors']\n    multiplicative_events = plot_configuration['multiplicative_events']\n    lagged_scalar_regressors = plot_configuration['lagged_scalar_regressors']\n    overwriting_unknown_data_normalization = plot_configuration['overwriting_unknown_data_normalization']\n    npanel = len(components_to_plot)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    for (ax, comp) in zip(axes, components_to_plot):\n        plot_name = comp['plot_name'].lower()\n        if plot_name.startswith('trend'):\n            if 'change' in plot_name:\n                plot_trend_change(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n            else:\n                plot_trend(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n        elif plot_name.startswith('seasonality'):\n            name = comp['comp_name']\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if name.lower() == 'weekly' or m.config_seasonality.periods[name].period == 7:\n                plot_weekly(m=m, quantile=quantile, ax=ax, weekly_start=weekly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'yearly' or m.config_seasonality.periods[name].period == 365.25:\n                plot_yearly(m=m, quantile=quantile, ax=ax, yearly_start=yearly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'daily' or m.config_seasonality.periods[name].period == 1:\n                plot_daily(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n            else:\n                plot_custom_season(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n        elif plot_name == 'lagged weights':\n            plot_lagged_weights(weights=comp['weights'], comp_name=comp['comp_name'], focus=comp['focus'], ax=ax)\n        else:\n            if plot_name == 'additive future regressor':\n                weights = additive_future_regressors\n            elif plot_name == 'multiplicative future regressor':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_future_regressors\n            elif plot_name == 'lagged scalar regressor':\n                weights = lagged_scalar_regressors\n            elif plot_name == 'additive event':\n                weights = additive_events\n            elif plot_name == 'multiplicative event':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_events\n            plot_scalar_weights(weights=weights, plot_name=comp['plot_name'], focus=forecast_in_focus, ax=ax)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    if overwriting_unknown_data_normalization:\n        m.config_normalization.unknown_data_normalization = False\n    return fig",
            "def plot_parameters(m, plot_configuration, quantile=0.5, weekly_start=0, yearly_start=0, figsize=None, df_name=None, forecast_in_focus=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the parameters that the model is composed of, visually.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        plot_configuration: dict\\n            dict of configured parameters to plot\\n        quantile : float\\n            The quantile for which the model parameters are to be plotted\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot.\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n        forecast_in_focus: int\\n            optinal, i-th step ahead forecast to plot\\n\\n            Note\\n            ----\\n            None (default): plot self.highlight_forecast_step_n by default\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet parameters\\n\\n    Examples\\n    --------\\n    Base usage of :meth:`plot_parameters`\\n\\n    >>> from neuralprophet import NeuralProphet\\n    >>> m = NeuralProphet()\\n    >>> metrics = m.fit(df, freq=\"D\")\\n    >>> future = m.make_future_dataframe(df=df, periods=365)\\n    >>> forecast = m.predict(df=future)\\n    >>> m.plot_parameters()\\n\\n    '\n    components_to_plot = plot_configuration['components_list']\n    additive_future_regressors = plot_configuration['additive_future_regressors']\n    additive_events = plot_configuration['additive_events']\n    multiplicative_future_regressors = plot_configuration['multiplicative_future_regressors']\n    multiplicative_events = plot_configuration['multiplicative_events']\n    lagged_scalar_regressors = plot_configuration['lagged_scalar_regressors']\n    overwriting_unknown_data_normalization = plot_configuration['overwriting_unknown_data_normalization']\n    npanel = len(components_to_plot)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    for (ax, comp) in zip(axes, components_to_plot):\n        plot_name = comp['plot_name'].lower()\n        if plot_name.startswith('trend'):\n            if 'change' in plot_name:\n                plot_trend_change(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n            else:\n                plot_trend(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n        elif plot_name.startswith('seasonality'):\n            name = comp['comp_name']\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if name.lower() == 'weekly' or m.config_seasonality.periods[name].period == 7:\n                plot_weekly(m=m, quantile=quantile, ax=ax, weekly_start=weekly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'yearly' or m.config_seasonality.periods[name].period == 365.25:\n                plot_yearly(m=m, quantile=quantile, ax=ax, yearly_start=yearly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'daily' or m.config_seasonality.periods[name].period == 1:\n                plot_daily(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n            else:\n                plot_custom_season(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n        elif plot_name == 'lagged weights':\n            plot_lagged_weights(weights=comp['weights'], comp_name=comp['comp_name'], focus=comp['focus'], ax=ax)\n        else:\n            if plot_name == 'additive future regressor':\n                weights = additive_future_regressors\n            elif plot_name == 'multiplicative future regressor':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_future_regressors\n            elif plot_name == 'lagged scalar regressor':\n                weights = lagged_scalar_regressors\n            elif plot_name == 'additive event':\n                weights = additive_events\n            elif plot_name == 'multiplicative event':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_events\n            plot_scalar_weights(weights=weights, plot_name=comp['plot_name'], focus=forecast_in_focus, ax=ax)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    if overwriting_unknown_data_normalization:\n        m.config_normalization.unknown_data_normalization = False\n    return fig",
            "def plot_parameters(m, plot_configuration, quantile=0.5, weekly_start=0, yearly_start=0, figsize=None, df_name=None, forecast_in_focus=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the parameters that the model is composed of, visually.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        plot_configuration: dict\\n            dict of configured parameters to plot\\n        quantile : float\\n            The quantile for which the model parameters are to be plotted\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot.\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n        forecast_in_focus: int\\n            optinal, i-th step ahead forecast to plot\\n\\n            Note\\n            ----\\n            None (default): plot self.highlight_forecast_step_n by default\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet parameters\\n\\n    Examples\\n    --------\\n    Base usage of :meth:`plot_parameters`\\n\\n    >>> from neuralprophet import NeuralProphet\\n    >>> m = NeuralProphet()\\n    >>> metrics = m.fit(df, freq=\"D\")\\n    >>> future = m.make_future_dataframe(df=df, periods=365)\\n    >>> forecast = m.predict(df=future)\\n    >>> m.plot_parameters()\\n\\n    '\n    components_to_plot = plot_configuration['components_list']\n    additive_future_regressors = plot_configuration['additive_future_regressors']\n    additive_events = plot_configuration['additive_events']\n    multiplicative_future_regressors = plot_configuration['multiplicative_future_regressors']\n    multiplicative_events = plot_configuration['multiplicative_events']\n    lagged_scalar_regressors = plot_configuration['lagged_scalar_regressors']\n    overwriting_unknown_data_normalization = plot_configuration['overwriting_unknown_data_normalization']\n    npanel = len(components_to_plot)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    for (ax, comp) in zip(axes, components_to_plot):\n        plot_name = comp['plot_name'].lower()\n        if plot_name.startswith('trend'):\n            if 'change' in plot_name:\n                plot_trend_change(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n            else:\n                plot_trend(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n        elif plot_name.startswith('seasonality'):\n            name = comp['comp_name']\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if name.lower() == 'weekly' or m.config_seasonality.periods[name].period == 7:\n                plot_weekly(m=m, quantile=quantile, ax=ax, weekly_start=weekly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'yearly' or m.config_seasonality.periods[name].period == 365.25:\n                plot_yearly(m=m, quantile=quantile, ax=ax, yearly_start=yearly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'daily' or m.config_seasonality.periods[name].period == 1:\n                plot_daily(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n            else:\n                plot_custom_season(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n        elif plot_name == 'lagged weights':\n            plot_lagged_weights(weights=comp['weights'], comp_name=comp['comp_name'], focus=comp['focus'], ax=ax)\n        else:\n            if plot_name == 'additive future regressor':\n                weights = additive_future_regressors\n            elif plot_name == 'multiplicative future regressor':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_future_regressors\n            elif plot_name == 'lagged scalar regressor':\n                weights = lagged_scalar_regressors\n            elif plot_name == 'additive event':\n                weights = additive_events\n            elif plot_name == 'multiplicative event':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_events\n            plot_scalar_weights(weights=weights, plot_name=comp['plot_name'], focus=forecast_in_focus, ax=ax)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    if overwriting_unknown_data_normalization:\n        m.config_normalization.unknown_data_normalization = False\n    return fig",
            "def plot_parameters(m, plot_configuration, quantile=0.5, weekly_start=0, yearly_start=0, figsize=None, df_name=None, forecast_in_focus=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the parameters that the model is composed of, visually.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        plot_configuration: dict\\n            dict of configured parameters to plot\\n        quantile : float\\n            The quantile for which the model parameters are to be plotted\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot.\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        figsize : tuple\\n            Width, height in inches.\\n\\n            Note\\n            ----\\n            Default value is set to ``None`` ->  automatic ``figsize = (10, 3 * npanel)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n        forecast_in_focus: int\\n            optinal, i-th step ahead forecast to plot\\n\\n            Note\\n            ----\\n            None (default): plot self.highlight_forecast_step_n by default\\n\\n    Returns\\n    -------\\n        matplotlib.pyplot.figure\\n            Figure showing the NeuralProphet parameters\\n\\n    Examples\\n    --------\\n    Base usage of :meth:`plot_parameters`\\n\\n    >>> from neuralprophet import NeuralProphet\\n    >>> m = NeuralProphet()\\n    >>> metrics = m.fit(df, freq=\"D\")\\n    >>> future = m.make_future_dataframe(df=df, periods=365)\\n    >>> forecast = m.predict(df=future)\\n    >>> m.plot_parameters()\\n\\n    '\n    components_to_plot = plot_configuration['components_list']\n    additive_future_regressors = plot_configuration['additive_future_regressors']\n    additive_events = plot_configuration['additive_events']\n    multiplicative_future_regressors = plot_configuration['multiplicative_future_regressors']\n    multiplicative_events = plot_configuration['multiplicative_events']\n    lagged_scalar_regressors = plot_configuration['lagged_scalar_regressors']\n    overwriting_unknown_data_normalization = plot_configuration['overwriting_unknown_data_normalization']\n    npanel = len(components_to_plot)\n    figsize = figsize if figsize else (10, 3 * npanel)\n    (fig, axes) = plt.subplots(npanel, 1, facecolor='w', figsize=figsize)\n    if npanel == 1:\n        axes = [axes]\n    multiplicative_axes = []\n    for (ax, comp) in zip(axes, components_to_plot):\n        plot_name = comp['plot_name'].lower()\n        if plot_name.startswith('trend'):\n            if 'change' in plot_name:\n                plot_trend_change(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n            else:\n                plot_trend(m=m, quantile=quantile, ax=ax, plot_name=comp['plot_name'], df_name=df_name)\n        elif plot_name.startswith('seasonality'):\n            name = comp['comp_name']\n            if m.config_seasonality.mode == 'multiplicative':\n                multiplicative_axes.append(ax)\n            if name.lower() == 'weekly' or m.config_seasonality.periods[name].period == 7:\n                plot_weekly(m=m, quantile=quantile, ax=ax, weekly_start=weekly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'yearly' or m.config_seasonality.periods[name].period == 365.25:\n                plot_yearly(m=m, quantile=quantile, ax=ax, yearly_start=yearly_start, comp_name=name, df_name=df_name)\n            elif name.lower() == 'daily' or m.config_seasonality.periods[name].period == 1:\n                plot_daily(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n            else:\n                plot_custom_season(m=m, quantile=quantile, ax=ax, comp_name=name, df_name=df_name)\n        elif plot_name == 'lagged weights':\n            plot_lagged_weights(weights=comp['weights'], comp_name=comp['comp_name'], focus=comp['focus'], ax=ax)\n        else:\n            if plot_name == 'additive future regressor':\n                weights = additive_future_regressors\n            elif plot_name == 'multiplicative future regressor':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_future_regressors\n            elif plot_name == 'lagged scalar regressor':\n                weights = lagged_scalar_regressors\n            elif plot_name == 'additive event':\n                weights = additive_events\n            elif plot_name == 'multiplicative event':\n                multiplicative_axes.append(ax)\n                weights = multiplicative_events\n            plot_scalar_weights(weights=weights, plot_name=comp['plot_name'], focus=forecast_in_focus, ax=ax)\n    fig = fig.tight_layout()\n    for ax in multiplicative_axes:\n        ax = set_y_as_percent(ax)\n    if overwriting_unknown_data_normalization:\n        m.config_normalization.unknown_data_normalization = False\n    return fig"
        ]
    },
    {
        "func_name": "plot_trend_change",
        "original": "def plot_trend_change(m, quantile, ax=None, plot_name='Trend Change', figsize=(10, 6), df_name='__df__'):\n    \"\"\"Make a barplot of the magnitudes of trend-changes.\n\n    Parameters\n    ----------\n        m : NeuralProphet\n            Fitted model\n        quantile : float\n            The quantile for which the trend changes are plotted\n        ax : matplotlib axis\n            Matplotlib Axes to plot on\n        plot_name : str\n            Name of the plot Title\n        figsize : tuple\n            Width, height in inches, ignored if ax is not None.\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n\n        df_name : str\n            Name of dataframe to refer to data params from original keys of train dataframes\n\n            Note\n            ----\n            Only used for local normalization in global modeling\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing barplot\n    \"\"\"\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if isinstance(df_name, list):\n        df_name = df_name[0]\n    data_params = m.config_normalization.get_data_params(df_name)\n    start = data_params['ds'].shift\n    scale = data_params['ds'].scale\n    time_span_seconds = scale.total_seconds()\n    cp_t = []\n    for cp in m.model.config_trend.changepoints:\n        cp_t.append(start + datetime.timedelta(seconds=cp * time_span_seconds))\n    if m.model.config_trend.trend_global_local == 'local':\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, m.model.id_dict[df_name], :].numpy()\n    else:\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, 0, :].numpy()\n    cp_t.append(start + scale)\n    weights = np.append(weights, [0.0])\n    width = time_span_seconds / 175000 / m.config_trend.n_changepoints\n    artists += ax.bar(cp_t, weights, width=width, color='#0072B2')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('Trend Segment')\n    ax.set_ylabel(plot_name)\n    return artists",
        "mutated": [
            "def plot_trend_change(m, quantile, ax=None, plot_name='Trend Change', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if isinstance(df_name, list):\n        df_name = df_name[0]\n    data_params = m.config_normalization.get_data_params(df_name)\n    start = data_params['ds'].shift\n    scale = data_params['ds'].scale\n    time_span_seconds = scale.total_seconds()\n    cp_t = []\n    for cp in m.model.config_trend.changepoints:\n        cp_t.append(start + datetime.timedelta(seconds=cp * time_span_seconds))\n    if m.model.config_trend.trend_global_local == 'local':\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, m.model.id_dict[df_name], :].numpy()\n    else:\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, 0, :].numpy()\n    cp_t.append(start + scale)\n    weights = np.append(weights, [0.0])\n    width = time_span_seconds / 175000 / m.config_trend.n_changepoints\n    artists += ax.bar(cp_t, weights, width=width, color='#0072B2')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('Trend Segment')\n    ax.set_ylabel(plot_name)\n    return artists",
            "def plot_trend_change(m, quantile, ax=None, plot_name='Trend Change', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if isinstance(df_name, list):\n        df_name = df_name[0]\n    data_params = m.config_normalization.get_data_params(df_name)\n    start = data_params['ds'].shift\n    scale = data_params['ds'].scale\n    time_span_seconds = scale.total_seconds()\n    cp_t = []\n    for cp in m.model.config_trend.changepoints:\n        cp_t.append(start + datetime.timedelta(seconds=cp * time_span_seconds))\n    if m.model.config_trend.trend_global_local == 'local':\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, m.model.id_dict[df_name], :].numpy()\n    else:\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, 0, :].numpy()\n    cp_t.append(start + scale)\n    weights = np.append(weights, [0.0])\n    width = time_span_seconds / 175000 / m.config_trend.n_changepoints\n    artists += ax.bar(cp_t, weights, width=width, color='#0072B2')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('Trend Segment')\n    ax.set_ylabel(plot_name)\n    return artists",
            "def plot_trend_change(m, quantile, ax=None, plot_name='Trend Change', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if isinstance(df_name, list):\n        df_name = df_name[0]\n    data_params = m.config_normalization.get_data_params(df_name)\n    start = data_params['ds'].shift\n    scale = data_params['ds'].scale\n    time_span_seconds = scale.total_seconds()\n    cp_t = []\n    for cp in m.model.config_trend.changepoints:\n        cp_t.append(start + datetime.timedelta(seconds=cp * time_span_seconds))\n    if m.model.config_trend.trend_global_local == 'local':\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, m.model.id_dict[df_name], :].numpy()\n    else:\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, 0, :].numpy()\n    cp_t.append(start + scale)\n    weights = np.append(weights, [0.0])\n    width = time_span_seconds / 175000 / m.config_trend.n_changepoints\n    artists += ax.bar(cp_t, weights, width=width, color='#0072B2')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('Trend Segment')\n    ax.set_ylabel(plot_name)\n    return artists",
            "def plot_trend_change(m, quantile, ax=None, plot_name='Trend Change', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if isinstance(df_name, list):\n        df_name = df_name[0]\n    data_params = m.config_normalization.get_data_params(df_name)\n    start = data_params['ds'].shift\n    scale = data_params['ds'].scale\n    time_span_seconds = scale.total_seconds()\n    cp_t = []\n    for cp in m.model.config_trend.changepoints:\n        cp_t.append(start + datetime.timedelta(seconds=cp * time_span_seconds))\n    if m.model.config_trend.trend_global_local == 'local':\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, m.model.id_dict[df_name], :].numpy()\n    else:\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, 0, :].numpy()\n    cp_t.append(start + scale)\n    weights = np.append(weights, [0.0])\n    width = time_span_seconds / 175000 / m.config_trend.n_changepoints\n    artists += ax.bar(cp_t, weights, width=width, color='#0072B2')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('Trend Segment')\n    ax.set_ylabel(plot_name)\n    return artists",
            "def plot_trend_change(m, quantile, ax=None, plot_name='Trend Change', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if isinstance(df_name, list):\n        df_name = df_name[0]\n    data_params = m.config_normalization.get_data_params(df_name)\n    start = data_params['ds'].shift\n    scale = data_params['ds'].scale\n    time_span_seconds = scale.total_seconds()\n    cp_t = []\n    for cp in m.model.config_trend.changepoints:\n        cp_t.append(start + datetime.timedelta(seconds=cp * time_span_seconds))\n    if m.model.config_trend.trend_global_local == 'local':\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, m.model.id_dict[df_name], :].numpy()\n    else:\n        quantile_index = m.model.quantiles.index(quantile)\n        weights = m.model.trend.get_trend_deltas.detach()[quantile_index, 0, :].numpy()\n    cp_t.append(start + scale)\n    weights = np.append(weights, [0.0])\n    width = time_span_seconds / 175000 / m.config_trend.n_changepoints\n    artists += ax.bar(cp_t, weights, width=width, color='#0072B2')\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('Trend Segment')\n    ax.set_ylabel(plot_name)\n    return artists"
        ]
    },
    {
        "func_name": "plot_trend",
        "original": "def plot_trend(m, quantile, ax=None, plot_name='Trend', figsize=(10, 6), df_name='__df__'):\n    \"\"\"Make a barplot of the magnitudes of trend-changes.\n\n    Parameters\n    ----------\n        m : NeuralProphet\n            Fitted model\n        quantile : float\n            The quantile for which the trend changes are plotted\n        ax : matplotlib axis\n            Matplotlib Axes to plot on\n        plot_name : str\n            Name of the plot Title\n        figsize : tuple\n            Width, height in inches, ignored if ax is not None.\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n\n        df_name : str\n            Name of dataframe to refer to data params from original keys of train dataframes\n\n            Note\n            ----\n            Only used for local normalization in global modeling\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing barplot\n    \"\"\"\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if m.config_trend.n_changepoints == 0:\n        if isinstance(df_name, list):\n            df_name = df_name[0]\n        data_params = m.config_normalization.get_data_params(df_name)\n        t_start = data_params['ds'].shift\n        t_end = t_start + data_params['ds'].scale\n        quantile_index = m.model.quantiles.index(quantile)\n        fcst_t = pd.Series([t_start, t_end]).dt.to_pydatetime()\n        trend_0 = m.model.trend.bias[quantile_index].detach().numpy().squeeze()\n        if m.config_trend.growth == 'off':\n            trend_1 = trend_0\n        elif m.model.config_trend.trend_global_local == 'local':\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, m.model.id_dict[df_name]].detach().numpy().squeeze()\n        else:\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, 0].detach().numpy().squeeze()\n        data_params = m.config_normalization.get_data_params(df_name)\n        shift = data_params['y'].shift\n        scale = data_params['y'].scale\n        trend_0 = trend_0 * scale + shift\n        trend_1 = trend_1 * scale + shift\n        artists += ax.plot(fcst_t, [trend_0, trend_1], ls='-', c='#0072B2')\n    else:\n        mean_std = True\n        if not isinstance(df_name, list):\n            df_name = [df_name]\n            mean_std = False\n        df_y = pd.DataFrame()\n        for df_name_i in df_name:\n            data_params = m.config_normalization.get_data_params(df_name_i)\n            t_start = data_params['ds'].shift\n            t_end = t_start + data_params['ds'].scale\n            quantile_index = m.model.quantiles.index(quantile)\n            days = pd.date_range(start=t_start, end=t_end, freq=m.data_freq)\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = df_name_i\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n        df_trend = m.predict_trend(df=df_y, quantile=quantile)\n        if mean_std:\n            df_trend_q90 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.9))\n            df_trend_q10 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.1))\n            df_trend = df_trend.groupby('ds')[['trend']].apply(lambda x: x.mean())\n            df_trend['ID'] = m.id_list[0]\n            df_y = df_y[df_y['ID'] == m.id_list[0]]\n        artists += ax.plot(df_y['ds'], df_trend['trend'], ls='-', c='#0072B2', label='Mean' if mean_std else None)\n        if mean_std:\n            ax.fill_between(df_y['ds'].dt.to_pydatetime(), df_trend_q10['trend'], df_trend_q90['trend'], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n            ax.legend()\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    ax.set_ylabel(plot_name)\n    return artists",
        "mutated": [
            "def plot_trend(m, quantile, ax=None, plot_name='Trend', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if m.config_trend.n_changepoints == 0:\n        if isinstance(df_name, list):\n            df_name = df_name[0]\n        data_params = m.config_normalization.get_data_params(df_name)\n        t_start = data_params['ds'].shift\n        t_end = t_start + data_params['ds'].scale\n        quantile_index = m.model.quantiles.index(quantile)\n        fcst_t = pd.Series([t_start, t_end]).dt.to_pydatetime()\n        trend_0 = m.model.trend.bias[quantile_index].detach().numpy().squeeze()\n        if m.config_trend.growth == 'off':\n            trend_1 = trend_0\n        elif m.model.config_trend.trend_global_local == 'local':\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, m.model.id_dict[df_name]].detach().numpy().squeeze()\n        else:\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, 0].detach().numpy().squeeze()\n        data_params = m.config_normalization.get_data_params(df_name)\n        shift = data_params['y'].shift\n        scale = data_params['y'].scale\n        trend_0 = trend_0 * scale + shift\n        trend_1 = trend_1 * scale + shift\n        artists += ax.plot(fcst_t, [trend_0, trend_1], ls='-', c='#0072B2')\n    else:\n        mean_std = True\n        if not isinstance(df_name, list):\n            df_name = [df_name]\n            mean_std = False\n        df_y = pd.DataFrame()\n        for df_name_i in df_name:\n            data_params = m.config_normalization.get_data_params(df_name_i)\n            t_start = data_params['ds'].shift\n            t_end = t_start + data_params['ds'].scale\n            quantile_index = m.model.quantiles.index(quantile)\n            days = pd.date_range(start=t_start, end=t_end, freq=m.data_freq)\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = df_name_i\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n        df_trend = m.predict_trend(df=df_y, quantile=quantile)\n        if mean_std:\n            df_trend_q90 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.9))\n            df_trend_q10 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.1))\n            df_trend = df_trend.groupby('ds')[['trend']].apply(lambda x: x.mean())\n            df_trend['ID'] = m.id_list[0]\n            df_y = df_y[df_y['ID'] == m.id_list[0]]\n        artists += ax.plot(df_y['ds'], df_trend['trend'], ls='-', c='#0072B2', label='Mean' if mean_std else None)\n        if mean_std:\n            ax.fill_between(df_y['ds'].dt.to_pydatetime(), df_trend_q10['trend'], df_trend_q90['trend'], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n            ax.legend()\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    ax.set_ylabel(plot_name)\n    return artists",
            "def plot_trend(m, quantile, ax=None, plot_name='Trend', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if m.config_trend.n_changepoints == 0:\n        if isinstance(df_name, list):\n            df_name = df_name[0]\n        data_params = m.config_normalization.get_data_params(df_name)\n        t_start = data_params['ds'].shift\n        t_end = t_start + data_params['ds'].scale\n        quantile_index = m.model.quantiles.index(quantile)\n        fcst_t = pd.Series([t_start, t_end]).dt.to_pydatetime()\n        trend_0 = m.model.trend.bias[quantile_index].detach().numpy().squeeze()\n        if m.config_trend.growth == 'off':\n            trend_1 = trend_0\n        elif m.model.config_trend.trend_global_local == 'local':\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, m.model.id_dict[df_name]].detach().numpy().squeeze()\n        else:\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, 0].detach().numpy().squeeze()\n        data_params = m.config_normalization.get_data_params(df_name)\n        shift = data_params['y'].shift\n        scale = data_params['y'].scale\n        trend_0 = trend_0 * scale + shift\n        trend_1 = trend_1 * scale + shift\n        artists += ax.plot(fcst_t, [trend_0, trend_1], ls='-', c='#0072B2')\n    else:\n        mean_std = True\n        if not isinstance(df_name, list):\n            df_name = [df_name]\n            mean_std = False\n        df_y = pd.DataFrame()\n        for df_name_i in df_name:\n            data_params = m.config_normalization.get_data_params(df_name_i)\n            t_start = data_params['ds'].shift\n            t_end = t_start + data_params['ds'].scale\n            quantile_index = m.model.quantiles.index(quantile)\n            days = pd.date_range(start=t_start, end=t_end, freq=m.data_freq)\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = df_name_i\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n        df_trend = m.predict_trend(df=df_y, quantile=quantile)\n        if mean_std:\n            df_trend_q90 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.9))\n            df_trend_q10 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.1))\n            df_trend = df_trend.groupby('ds')[['trend']].apply(lambda x: x.mean())\n            df_trend['ID'] = m.id_list[0]\n            df_y = df_y[df_y['ID'] == m.id_list[0]]\n        artists += ax.plot(df_y['ds'], df_trend['trend'], ls='-', c='#0072B2', label='Mean' if mean_std else None)\n        if mean_std:\n            ax.fill_between(df_y['ds'].dt.to_pydatetime(), df_trend_q10['trend'], df_trend_q90['trend'], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n            ax.legend()\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    ax.set_ylabel(plot_name)\n    return artists",
            "def plot_trend(m, quantile, ax=None, plot_name='Trend', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if m.config_trend.n_changepoints == 0:\n        if isinstance(df_name, list):\n            df_name = df_name[0]\n        data_params = m.config_normalization.get_data_params(df_name)\n        t_start = data_params['ds'].shift\n        t_end = t_start + data_params['ds'].scale\n        quantile_index = m.model.quantiles.index(quantile)\n        fcst_t = pd.Series([t_start, t_end]).dt.to_pydatetime()\n        trend_0 = m.model.trend.bias[quantile_index].detach().numpy().squeeze()\n        if m.config_trend.growth == 'off':\n            trend_1 = trend_0\n        elif m.model.config_trend.trend_global_local == 'local':\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, m.model.id_dict[df_name]].detach().numpy().squeeze()\n        else:\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, 0].detach().numpy().squeeze()\n        data_params = m.config_normalization.get_data_params(df_name)\n        shift = data_params['y'].shift\n        scale = data_params['y'].scale\n        trend_0 = trend_0 * scale + shift\n        trend_1 = trend_1 * scale + shift\n        artists += ax.plot(fcst_t, [trend_0, trend_1], ls='-', c='#0072B2')\n    else:\n        mean_std = True\n        if not isinstance(df_name, list):\n            df_name = [df_name]\n            mean_std = False\n        df_y = pd.DataFrame()\n        for df_name_i in df_name:\n            data_params = m.config_normalization.get_data_params(df_name_i)\n            t_start = data_params['ds'].shift\n            t_end = t_start + data_params['ds'].scale\n            quantile_index = m.model.quantiles.index(quantile)\n            days = pd.date_range(start=t_start, end=t_end, freq=m.data_freq)\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = df_name_i\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n        df_trend = m.predict_trend(df=df_y, quantile=quantile)\n        if mean_std:\n            df_trend_q90 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.9))\n            df_trend_q10 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.1))\n            df_trend = df_trend.groupby('ds')[['trend']].apply(lambda x: x.mean())\n            df_trend['ID'] = m.id_list[0]\n            df_y = df_y[df_y['ID'] == m.id_list[0]]\n        artists += ax.plot(df_y['ds'], df_trend['trend'], ls='-', c='#0072B2', label='Mean' if mean_std else None)\n        if mean_std:\n            ax.fill_between(df_y['ds'].dt.to_pydatetime(), df_trend_q10['trend'], df_trend_q90['trend'], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n            ax.legend()\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    ax.set_ylabel(plot_name)\n    return artists",
            "def plot_trend(m, quantile, ax=None, plot_name='Trend', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if m.config_trend.n_changepoints == 0:\n        if isinstance(df_name, list):\n            df_name = df_name[0]\n        data_params = m.config_normalization.get_data_params(df_name)\n        t_start = data_params['ds'].shift\n        t_end = t_start + data_params['ds'].scale\n        quantile_index = m.model.quantiles.index(quantile)\n        fcst_t = pd.Series([t_start, t_end]).dt.to_pydatetime()\n        trend_0 = m.model.trend.bias[quantile_index].detach().numpy().squeeze()\n        if m.config_trend.growth == 'off':\n            trend_1 = trend_0\n        elif m.model.config_trend.trend_global_local == 'local':\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, m.model.id_dict[df_name]].detach().numpy().squeeze()\n        else:\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, 0].detach().numpy().squeeze()\n        data_params = m.config_normalization.get_data_params(df_name)\n        shift = data_params['y'].shift\n        scale = data_params['y'].scale\n        trend_0 = trend_0 * scale + shift\n        trend_1 = trend_1 * scale + shift\n        artists += ax.plot(fcst_t, [trend_0, trend_1], ls='-', c='#0072B2')\n    else:\n        mean_std = True\n        if not isinstance(df_name, list):\n            df_name = [df_name]\n            mean_std = False\n        df_y = pd.DataFrame()\n        for df_name_i in df_name:\n            data_params = m.config_normalization.get_data_params(df_name_i)\n            t_start = data_params['ds'].shift\n            t_end = t_start + data_params['ds'].scale\n            quantile_index = m.model.quantiles.index(quantile)\n            days = pd.date_range(start=t_start, end=t_end, freq=m.data_freq)\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = df_name_i\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n        df_trend = m.predict_trend(df=df_y, quantile=quantile)\n        if mean_std:\n            df_trend_q90 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.9))\n            df_trend_q10 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.1))\n            df_trend = df_trend.groupby('ds')[['trend']].apply(lambda x: x.mean())\n            df_trend['ID'] = m.id_list[0]\n            df_y = df_y[df_y['ID'] == m.id_list[0]]\n        artists += ax.plot(df_y['ds'], df_trend['trend'], ls='-', c='#0072B2', label='Mean' if mean_std else None)\n        if mean_std:\n            ax.fill_between(df_y['ds'].dt.to_pydatetime(), df_trend_q10['trend'], df_trend_q90['trend'], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n            ax.legend()\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    ax.set_ylabel(plot_name)\n    return artists",
            "def plot_trend(m, quantile, ax=None, plot_name='Trend', figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Make a barplot of the magnitudes of trend-changes.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the trend changes are plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        plot_name : str\\n            Name of the plot Title\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    if m.config_trend.n_changepoints == 0:\n        if isinstance(df_name, list):\n            df_name = df_name[0]\n        data_params = m.config_normalization.get_data_params(df_name)\n        t_start = data_params['ds'].shift\n        t_end = t_start + data_params['ds'].scale\n        quantile_index = m.model.quantiles.index(quantile)\n        fcst_t = pd.Series([t_start, t_end]).dt.to_pydatetime()\n        trend_0 = m.model.trend.bias[quantile_index].detach().numpy().squeeze()\n        if m.config_trend.growth == 'off':\n            trend_1 = trend_0\n        elif m.model.config_trend.trend_global_local == 'local':\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, m.model.id_dict[df_name]].detach().numpy().squeeze()\n        else:\n            trend_1 = trend_0 + m.model.trend.trend_k0[quantile_index, 0].detach().numpy().squeeze()\n        data_params = m.config_normalization.get_data_params(df_name)\n        shift = data_params['y'].shift\n        scale = data_params['y'].scale\n        trend_0 = trend_0 * scale + shift\n        trend_1 = trend_1 * scale + shift\n        artists += ax.plot(fcst_t, [trend_0, trend_1], ls='-', c='#0072B2')\n    else:\n        mean_std = True\n        if not isinstance(df_name, list):\n            df_name = [df_name]\n            mean_std = False\n        df_y = pd.DataFrame()\n        for df_name_i in df_name:\n            data_params = m.config_normalization.get_data_params(df_name_i)\n            t_start = data_params['ds'].shift\n            t_end = t_start + data_params['ds'].scale\n            quantile_index = m.model.quantiles.index(quantile)\n            days = pd.date_range(start=t_start, end=t_end, freq=m.data_freq)\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = df_name_i\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n        df_trend = m.predict_trend(df=df_y, quantile=quantile)\n        if mean_std:\n            df_trend_q90 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.9))\n            df_trend_q10 = df_trend.groupby('ds')[['trend']].apply(lambda x: x.quantile(0.1))\n            df_trend = df_trend.groupby('ds')[['trend']].apply(lambda x: x.mean())\n            df_trend['ID'] = m.id_list[0]\n            df_y = df_y[df_y['ID'] == m.id_list[0]]\n        artists += ax.plot(df_y['ds'], df_trend['trend'], ls='-', c='#0072B2', label='Mean' if mean_std else None)\n        if mean_std:\n            ax.fill_between(df_y['ds'].dt.to_pydatetime(), df_trend_q10['trend'], df_trend_q90['trend'], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n            ax.legend()\n    locator = AutoDateLocator(interval_multiples=False)\n    formatter = AutoDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel('ds')\n    ax.set_ylabel(plot_name)\n    return artists"
        ]
    },
    {
        "func_name": "plot_scalar_weights",
        "original": "def plot_scalar_weights(weights, plot_name, focus=None, ax=None, figsize=(10, 6)):\n    \"\"\"Make a barplot of the regressor weights.\n\n    Parameters\n    ----------\n        weights : list\n            tuples of (name, weights)\n        plot_name : str\n            Name of the plot Title\n        focus : int\n            Show weights for this forecast, if provided\n        ax : matplotlib axis\n            Matplotlib Axes to plot on\n        figsize : tuple\n            Width, height in inches, ignored if ax is not None.\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing barplot\n    \"\"\"\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    names = []\n    values = []\n    for (name, weights) in weights:\n        names.append(name)\n        weight = np.squeeze(weights)\n        if len(weight.shape) > 1:\n            raise ValueError('Not scalar ' + plot_name)\n        if len(weight.shape) == 1 and len(weight) > 1:\n            if focus is not None:\n                weight = weight[focus - 1]\n            else:\n                weight = np.mean(weight)\n        values.append(weight)\n    artists += ax.bar(names, values, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(plot_name + ' name')\n    xticks = ax.get_xticklabels()\n    if len('_'.join(names)) > 100:\n        for tick in xticks:\n            tick.set_ha('right')\n            tick.set_rotation(20)\n    if 'lagged' in plot_name.lower():\n        if focus is None:\n            ax.set_ylabel(plot_name + ' weight (avg)')\n        else:\n            ax.set_ylabel(plot_name + f' weight ({focus})-ahead')\n    else:\n        ax.set_ylabel(plot_name + ' weight')\n    return artists",
        "mutated": [
            "def plot_scalar_weights(weights, plot_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n    'Make a barplot of the regressor weights.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        plot_name : str\\n            Name of the plot Title\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    names = []\n    values = []\n    for (name, weights) in weights:\n        names.append(name)\n        weight = np.squeeze(weights)\n        if len(weight.shape) > 1:\n            raise ValueError('Not scalar ' + plot_name)\n        if len(weight.shape) == 1 and len(weight) > 1:\n            if focus is not None:\n                weight = weight[focus - 1]\n            else:\n                weight = np.mean(weight)\n        values.append(weight)\n    artists += ax.bar(names, values, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(plot_name + ' name')\n    xticks = ax.get_xticklabels()\n    if len('_'.join(names)) > 100:\n        for tick in xticks:\n            tick.set_ha('right')\n            tick.set_rotation(20)\n    if 'lagged' in plot_name.lower():\n        if focus is None:\n            ax.set_ylabel(plot_name + ' weight (avg)')\n        else:\n            ax.set_ylabel(plot_name + f' weight ({focus})-ahead')\n    else:\n        ax.set_ylabel(plot_name + ' weight')\n    return artists",
            "def plot_scalar_weights(weights, plot_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Make a barplot of the regressor weights.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        plot_name : str\\n            Name of the plot Title\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    names = []\n    values = []\n    for (name, weights) in weights:\n        names.append(name)\n        weight = np.squeeze(weights)\n        if len(weight.shape) > 1:\n            raise ValueError('Not scalar ' + plot_name)\n        if len(weight.shape) == 1 and len(weight) > 1:\n            if focus is not None:\n                weight = weight[focus - 1]\n            else:\n                weight = np.mean(weight)\n        values.append(weight)\n    artists += ax.bar(names, values, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(plot_name + ' name')\n    xticks = ax.get_xticklabels()\n    if len('_'.join(names)) > 100:\n        for tick in xticks:\n            tick.set_ha('right')\n            tick.set_rotation(20)\n    if 'lagged' in plot_name.lower():\n        if focus is None:\n            ax.set_ylabel(plot_name + ' weight (avg)')\n        else:\n            ax.set_ylabel(plot_name + f' weight ({focus})-ahead')\n    else:\n        ax.set_ylabel(plot_name + ' weight')\n    return artists",
            "def plot_scalar_weights(weights, plot_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Make a barplot of the regressor weights.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        plot_name : str\\n            Name of the plot Title\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    names = []\n    values = []\n    for (name, weights) in weights:\n        names.append(name)\n        weight = np.squeeze(weights)\n        if len(weight.shape) > 1:\n            raise ValueError('Not scalar ' + plot_name)\n        if len(weight.shape) == 1 and len(weight) > 1:\n            if focus is not None:\n                weight = weight[focus - 1]\n            else:\n                weight = np.mean(weight)\n        values.append(weight)\n    artists += ax.bar(names, values, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(plot_name + ' name')\n    xticks = ax.get_xticklabels()\n    if len('_'.join(names)) > 100:\n        for tick in xticks:\n            tick.set_ha('right')\n            tick.set_rotation(20)\n    if 'lagged' in plot_name.lower():\n        if focus is None:\n            ax.set_ylabel(plot_name + ' weight (avg)')\n        else:\n            ax.set_ylabel(plot_name + f' weight ({focus})-ahead')\n    else:\n        ax.set_ylabel(plot_name + ' weight')\n    return artists",
            "def plot_scalar_weights(weights, plot_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Make a barplot of the regressor weights.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        plot_name : str\\n            Name of the plot Title\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    names = []\n    values = []\n    for (name, weights) in weights:\n        names.append(name)\n        weight = np.squeeze(weights)\n        if len(weight.shape) > 1:\n            raise ValueError('Not scalar ' + plot_name)\n        if len(weight.shape) == 1 and len(weight) > 1:\n            if focus is not None:\n                weight = weight[focus - 1]\n            else:\n                weight = np.mean(weight)\n        values.append(weight)\n    artists += ax.bar(names, values, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(plot_name + ' name')\n    xticks = ax.get_xticklabels()\n    if len('_'.join(names)) > 100:\n        for tick in xticks:\n            tick.set_ha('right')\n            tick.set_rotation(20)\n    if 'lagged' in plot_name.lower():\n        if focus is None:\n            ax.set_ylabel(plot_name + ' weight (avg)')\n        else:\n            ax.set_ylabel(plot_name + f' weight ({focus})-ahead')\n    else:\n        ax.set_ylabel(plot_name + ' weight')\n    return artists",
            "def plot_scalar_weights(weights, plot_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Make a barplot of the regressor weights.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        plot_name : str\\n            Name of the plot Title\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    names = []\n    values = []\n    for (name, weights) in weights:\n        names.append(name)\n        weight = np.squeeze(weights)\n        if len(weight.shape) > 1:\n            raise ValueError('Not scalar ' + plot_name)\n        if len(weight.shape) == 1 and len(weight) > 1:\n            if focus is not None:\n                weight = weight[focus - 1]\n            else:\n                weight = np.mean(weight)\n        values.append(weight)\n    artists += ax.bar(names, values, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(plot_name + ' name')\n    xticks = ax.get_xticklabels()\n    if len('_'.join(names)) > 100:\n        for tick in xticks:\n            tick.set_ha('right')\n            tick.set_rotation(20)\n    if 'lagged' in plot_name.lower():\n        if focus is None:\n            ax.set_ylabel(plot_name + ' weight (avg)')\n        else:\n            ax.set_ylabel(plot_name + f' weight ({focus})-ahead')\n    else:\n        ax.set_ylabel(plot_name + ' weight')\n    return artists"
        ]
    },
    {
        "func_name": "plot_lagged_weights",
        "original": "def plot_lagged_weights(weights, comp_name, focus=None, ax=None, figsize=(10, 6)):\n    \"\"\"Make a barplot of the importance of lagged inputs.\n\n    Parameters\n    ----------\n        weights : list\n            tuples of (name, weights)\n        comp_name : str\n            Name of lagged inputs\n        focus : int\n            Show weights for this forecast, if provided\n        ax : matplotlib axis\n            Matplotlib Axes to plot on\n        figsize : tuple\n            Width, height in inches, ignored if ax is not None.\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing barplot\n    \"\"\"\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    n_lags = weights.shape[1]\n    lags_range = list(range(1, 1 + n_lags))[::-1]\n    if focus is None:\n        weights = np.sum(np.abs(weights), axis=0)\n        weights = weights / np.sum(weights)\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    else:\n        if len(weights.shape) == 2:\n            weights = weights[focus - 1, :]\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'{comp_name} lag number')\n    if focus is None:\n        ax.set_ylabel(f'{comp_name} relevance')\n        ax = set_y_as_percent(ax)\n    else:\n        ax.set_ylabel(f'{comp_name} weight ({focus})-ahead')\n    return artists",
        "mutated": [
            "def plot_lagged_weights(weights, comp_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n    'Make a barplot of the importance of lagged inputs.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        comp_name : str\\n            Name of lagged inputs\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    n_lags = weights.shape[1]\n    lags_range = list(range(1, 1 + n_lags))[::-1]\n    if focus is None:\n        weights = np.sum(np.abs(weights), axis=0)\n        weights = weights / np.sum(weights)\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    else:\n        if len(weights.shape) == 2:\n            weights = weights[focus - 1, :]\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'{comp_name} lag number')\n    if focus is None:\n        ax.set_ylabel(f'{comp_name} relevance')\n        ax = set_y_as_percent(ax)\n    else:\n        ax.set_ylabel(f'{comp_name} weight ({focus})-ahead')\n    return artists",
            "def plot_lagged_weights(weights, comp_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Make a barplot of the importance of lagged inputs.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        comp_name : str\\n            Name of lagged inputs\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    n_lags = weights.shape[1]\n    lags_range = list(range(1, 1 + n_lags))[::-1]\n    if focus is None:\n        weights = np.sum(np.abs(weights), axis=0)\n        weights = weights / np.sum(weights)\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    else:\n        if len(weights.shape) == 2:\n            weights = weights[focus - 1, :]\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'{comp_name} lag number')\n    if focus is None:\n        ax.set_ylabel(f'{comp_name} relevance')\n        ax = set_y_as_percent(ax)\n    else:\n        ax.set_ylabel(f'{comp_name} weight ({focus})-ahead')\n    return artists",
            "def plot_lagged_weights(weights, comp_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Make a barplot of the importance of lagged inputs.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        comp_name : str\\n            Name of lagged inputs\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    n_lags = weights.shape[1]\n    lags_range = list(range(1, 1 + n_lags))[::-1]\n    if focus is None:\n        weights = np.sum(np.abs(weights), axis=0)\n        weights = weights / np.sum(weights)\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    else:\n        if len(weights.shape) == 2:\n            weights = weights[focus - 1, :]\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'{comp_name} lag number')\n    if focus is None:\n        ax.set_ylabel(f'{comp_name} relevance')\n        ax = set_y_as_percent(ax)\n    else:\n        ax.set_ylabel(f'{comp_name} weight ({focus})-ahead')\n    return artists",
            "def plot_lagged_weights(weights, comp_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Make a barplot of the importance of lagged inputs.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        comp_name : str\\n            Name of lagged inputs\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    n_lags = weights.shape[1]\n    lags_range = list(range(1, 1 + n_lags))[::-1]\n    if focus is None:\n        weights = np.sum(np.abs(weights), axis=0)\n        weights = weights / np.sum(weights)\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    else:\n        if len(weights.shape) == 2:\n            weights = weights[focus - 1, :]\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'{comp_name} lag number')\n    if focus is None:\n        ax.set_ylabel(f'{comp_name} relevance')\n        ax = set_y_as_percent(ax)\n    else:\n        ax.set_ylabel(f'{comp_name} weight ({focus})-ahead')\n    return artists",
            "def plot_lagged_weights(weights, comp_name, focus=None, ax=None, figsize=(10, 6)):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Make a barplot of the importance of lagged inputs.\\n\\n    Parameters\\n    ----------\\n        weights : list\\n            tuples of (name, weights)\\n        comp_name : str\\n            Name of lagged inputs\\n        focus : int\\n            Show weights for this forecast, if provided\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing barplot\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    n_lags = weights.shape[1]\n    lags_range = list(range(1, 1 + n_lags))[::-1]\n    if focus is None:\n        weights = np.sum(np.abs(weights), axis=0)\n        weights = weights / np.sum(weights)\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    else:\n        if len(weights.shape) == 2:\n            weights = weights[focus - 1, :]\n        artists += ax.bar(lags_range, weights, width=0.8, color='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'{comp_name} lag number')\n    if focus is None:\n        ax.set_ylabel(f'{comp_name} relevance')\n        ax = set_y_as_percent(ax)\n    else:\n        ax.set_ylabel(f'{comp_name} weight ({focus})-ahead')\n    return artists"
        ]
    },
    {
        "func_name": "plot_custom_season",
        "original": "def plot_custom_season(m, comp_name, quantile, ax=None, figsize=(10, 6), df_name='__df__'):\n    \"\"\"Plot any seasonal component of the forecast.\n\n    Parameters\n    ----------\n        m : NeuralProphet\n            Fitted model\n        comp_name : str\n            Name of seasonality component\n        quantile : float\n            The quantile for which the custom season is plotted\n        ax : matplotlib axis\n            Matplotlib Axes to plot on\n        focus : int\n            Show weights for this forecast, if provided\n        figsize : tuple\n            Width, height in inches, ignored if ax is not None.\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n        df_name : str\n            Name of dataframe to refer to data params from original keys of train dataframes\n\n            Note\n            ----\n            Only used for local normalization in global modeling\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing seasonal forecast component\n\n    \"\"\"\n    (t_i, predicted) = predict_one_season(m, name=comp_name, n_steps=300, quantile=quantile, df_name=df_name)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    artists += ax.plot(t_i, predicted, ls='-', c='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'One period: {comp_name}')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
        "mutated": [
            "def plot_custom_season(m, comp_name, quantile, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n    'Plot any seasonal component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        comp_name : str\\n            Name of seasonality component\\n        quantile : float\\n            The quantile for which the custom season is plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        focus : int\\n            Show weights for this forecast, if provided\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing seasonal forecast component\\n\\n    '\n    (t_i, predicted) = predict_one_season(m, name=comp_name, n_steps=300, quantile=quantile, df_name=df_name)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    artists += ax.plot(t_i, predicted, ls='-', c='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'One period: {comp_name}')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_custom_season(m, comp_name, quantile, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot any seasonal component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        comp_name : str\\n            Name of seasonality component\\n        quantile : float\\n            The quantile for which the custom season is plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        focus : int\\n            Show weights for this forecast, if provided\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing seasonal forecast component\\n\\n    '\n    (t_i, predicted) = predict_one_season(m, name=comp_name, n_steps=300, quantile=quantile, df_name=df_name)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    artists += ax.plot(t_i, predicted, ls='-', c='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'One period: {comp_name}')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_custom_season(m, comp_name, quantile, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot any seasonal component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        comp_name : str\\n            Name of seasonality component\\n        quantile : float\\n            The quantile for which the custom season is plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        focus : int\\n            Show weights for this forecast, if provided\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing seasonal forecast component\\n\\n    '\n    (t_i, predicted) = predict_one_season(m, name=comp_name, n_steps=300, quantile=quantile, df_name=df_name)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    artists += ax.plot(t_i, predicted, ls='-', c='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'One period: {comp_name}')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_custom_season(m, comp_name, quantile, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot any seasonal component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        comp_name : str\\n            Name of seasonality component\\n        quantile : float\\n            The quantile for which the custom season is plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        focus : int\\n            Show weights for this forecast, if provided\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing seasonal forecast component\\n\\n    '\n    (t_i, predicted) = predict_one_season(m, name=comp_name, n_steps=300, quantile=quantile, df_name=df_name)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    artists += ax.plot(t_i, predicted, ls='-', c='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'One period: {comp_name}')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_custom_season(m, comp_name, quantile, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot any seasonal component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        comp_name : str\\n            Name of seasonality component\\n        quantile : float\\n            The quantile for which the custom season is plotted\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        focus : int\\n            Show weights for this forecast, if provided\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing seasonal forecast component\\n\\n    '\n    (t_i, predicted) = predict_one_season(m, name=comp_name, n_steps=300, quantile=quantile, df_name=df_name)\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    artists += ax.plot(t_i, predicted, ls='-', c='#0072B2')\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xlabel(f'One period: {comp_name}')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists"
        ]
    },
    {
        "func_name": "plot_yearly",
        "original": "def plot_yearly(m, quantile, comp_name='yearly', yearly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    \"\"\"Plot the yearly component of the forecast.\n\n    Parameters\n    ----------\n        m : NeuralProphet\n            Fitted model\n        quantile : float\n            The quantile for which the yearly seasonality is plotted\n        comp_name : str\n            Name of seasonality component\n        yearly_start : int\n            Specifying the start day of the yearly seasonality plot\n\n            Options\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\n        quick : bool\n            Use quick low-level call of model\n        ax : matplotlib axis\n            Matplotlib Axes to plot on\n        figsize : tuple\n            Width, height in inches, ignored if ax is not None.\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n        df_name : str\n            Name of dataframe to refer to data params from original keys of train dataframes\n\n            Note\n            ----\n            Only used for local normalization in global modeling\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing yearly forecast component\n\n    \"\"\"\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=365) + pd.Timedelta(days=yearly_start)\n    df_y = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_y['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_y = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_y['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_y, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_y = df_y[df_y['ID'] == m.id_list[0]]\n    artists += ax.plot(df_y['ds'].dt.to_pydatetime(), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(df_y['ds'], predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n        ax.legend()\n    months = MonthLocator(range(1, 13), bymonthday=1, interval=2)\n    ax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos=None: f'{num2date(x):%B} {num2date(x).day}'))\n    ax.xaxis.set_major_locator(months)\n    ax.set_xlabel('Day of year')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
        "mutated": [
            "def plot_yearly(m, quantile, comp_name='yearly', yearly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n    'Plot the yearly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the yearly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing yearly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=365) + pd.Timedelta(days=yearly_start)\n    df_y = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_y['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_y = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_y['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_y, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_y = df_y[df_y['ID'] == m.id_list[0]]\n    artists += ax.plot(df_y['ds'].dt.to_pydatetime(), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(df_y['ds'], predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n        ax.legend()\n    months = MonthLocator(range(1, 13), bymonthday=1, interval=2)\n    ax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos=None: f'{num2date(x):%B} {num2date(x).day}'))\n    ax.xaxis.set_major_locator(months)\n    ax.set_xlabel('Day of year')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_yearly(m, quantile, comp_name='yearly', yearly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the yearly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the yearly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing yearly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=365) + pd.Timedelta(days=yearly_start)\n    df_y = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_y['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_y = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_y['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_y, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_y = df_y[df_y['ID'] == m.id_list[0]]\n    artists += ax.plot(df_y['ds'].dt.to_pydatetime(), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(df_y['ds'], predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n        ax.legend()\n    months = MonthLocator(range(1, 13), bymonthday=1, interval=2)\n    ax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos=None: f'{num2date(x):%B} {num2date(x).day}'))\n    ax.xaxis.set_major_locator(months)\n    ax.set_xlabel('Day of year')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_yearly(m, quantile, comp_name='yearly', yearly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the yearly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the yearly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing yearly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=365) + pd.Timedelta(days=yearly_start)\n    df_y = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_y['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_y = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_y['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_y, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_y = df_y[df_y['ID'] == m.id_list[0]]\n    artists += ax.plot(df_y['ds'].dt.to_pydatetime(), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(df_y['ds'], predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n        ax.legend()\n    months = MonthLocator(range(1, 13), bymonthday=1, interval=2)\n    ax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos=None: f'{num2date(x):%B} {num2date(x).day}'))\n    ax.xaxis.set_major_locator(months)\n    ax.set_xlabel('Day of year')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_yearly(m, quantile, comp_name='yearly', yearly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the yearly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the yearly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing yearly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=365) + pd.Timedelta(days=yearly_start)\n    df_y = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_y['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_y = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_y['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_y, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_y = df_y[df_y['ID'] == m.id_list[0]]\n    artists += ax.plot(df_y['ds'].dt.to_pydatetime(), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(df_y['ds'], predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n        ax.legend()\n    months = MonthLocator(range(1, 13), bymonthday=1, interval=2)\n    ax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos=None: f'{num2date(x):%B} {num2date(x).day}'))\n    ax.xaxis.set_major_locator(months)\n    ax.set_xlabel('Day of year')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_yearly(m, quantile, comp_name='yearly', yearly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the yearly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the yearly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        yearly_start : int\\n            Specifying the start day of the yearly seasonality plot\\n\\n            Options\\n                * (default) ``yearly_start = 0``: starts the year on Jan 1\\n                * ``yearly_start = 1``: shifts by 1 day to Jan 2, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing yearly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=365) + pd.Timedelta(days=yearly_start)\n    df_y = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_y['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_y = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_y = pd.concat((df_y, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_y['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_y, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_y = df_y[df_y['ID'] == m.id_list[0]]\n    artists += ax.plot(df_y['ds'].dt.to_pydatetime(), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(df_y['ds'], predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, color='#0072B2', label='Quants 10-90%')\n        ax.legend()\n    months = MonthLocator(range(1, 13), bymonthday=1, interval=2)\n    ax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos=None: f'{num2date(x):%B} {num2date(x).day}'))\n    ax.xaxis.set_major_locator(months)\n    ax.set_xlabel('Day of year')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists"
        ]
    },
    {
        "func_name": "plot_weekly",
        "original": "def plot_weekly(m, quantile, comp_name='weekly', weekly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    \"\"\"Plot the weekly component of the forecast.\n\n    Parameters\n    ----------\n        m : NeuralProphet\n            Fitted model\n        quantile : float\n            The quantile for which the weekly seasonality is plotted\n        comp_name : str\n            Name of seasonality component\n        weekly_start : int\n            Specifying the start day of the weekly seasonality plot\n\n            Options\n                * (default) ``weekly_start = 0``: starts the week on Sunday\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\n        quick : bool\n            Use quick low-level call of model\n        ax : matplotlib axis\n            Matplotlib Axes to plot on\n        figsize : tuple\n            Width, height in inches, ignored if ax is not None.\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n        df_name : str\n            Name of dataframe to refer to data params from original keys of train dataframes\n\n            Note\n            ----\n            Only used for local normalization in global modeling\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing weekly forecast component\n\n    \"\"\"\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    week_days = 7\n    if m.data_freq == 'B':\n        week_days = 5\n        weekly_start = 1\n    days_i = pd.date_range(start='2017-01-01', periods=week_days * 24, freq='H') + pd.Timedelta(days=weekly_start)\n    df_w = pd.DataFrame({'ds': days_i})\n    if not isinstance(df_name, list):\n        df_w['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_w = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days_i})\n            df_i['ID'] = m.id_list[i]\n            df_w = pd.concat((df_w, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_w['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_w, quantile=quantile)[['ds', 'ID', comp_name]]\n    days = pd.date_range(start='2017-01-01', periods=week_days) + pd.Timedelta(days=weekly_start)\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_w = df_w[df_w['ID'] == m.id_list[0]]\n    days = pd.date_range(start='2017-01-01', periods=7) + pd.Timedelta(days=weekly_start)\n    days = days.day_name()\n    artists += ax.plot(range(len(days_i)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(range(len(days_i)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.set_xticks(24 * np.arange(len(days) + 1 - weekly_start))\n    ax.set_xticklabels(list(days) + [days[0]] if m.data_freq != 'B' else list(days))\n    ax.set_xlabel('Day of week')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
        "mutated": [
            "def plot_weekly(m, quantile, comp_name='weekly', weekly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n    'Plot the weekly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the weekly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    week_days = 7\n    if m.data_freq == 'B':\n        week_days = 5\n        weekly_start = 1\n    days_i = pd.date_range(start='2017-01-01', periods=week_days * 24, freq='H') + pd.Timedelta(days=weekly_start)\n    df_w = pd.DataFrame({'ds': days_i})\n    if not isinstance(df_name, list):\n        df_w['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_w = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days_i})\n            df_i['ID'] = m.id_list[i]\n            df_w = pd.concat((df_w, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_w['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_w, quantile=quantile)[['ds', 'ID', comp_name]]\n    days = pd.date_range(start='2017-01-01', periods=week_days) + pd.Timedelta(days=weekly_start)\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_w = df_w[df_w['ID'] == m.id_list[0]]\n    days = pd.date_range(start='2017-01-01', periods=7) + pd.Timedelta(days=weekly_start)\n    days = days.day_name()\n    artists += ax.plot(range(len(days_i)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(range(len(days_i)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.set_xticks(24 * np.arange(len(days) + 1 - weekly_start))\n    ax.set_xticklabels(list(days) + [days[0]] if m.data_freq != 'B' else list(days))\n    ax.set_xlabel('Day of week')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_weekly(m, quantile, comp_name='weekly', weekly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the weekly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the weekly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    week_days = 7\n    if m.data_freq == 'B':\n        week_days = 5\n        weekly_start = 1\n    days_i = pd.date_range(start='2017-01-01', periods=week_days * 24, freq='H') + pd.Timedelta(days=weekly_start)\n    df_w = pd.DataFrame({'ds': days_i})\n    if not isinstance(df_name, list):\n        df_w['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_w = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days_i})\n            df_i['ID'] = m.id_list[i]\n            df_w = pd.concat((df_w, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_w['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_w, quantile=quantile)[['ds', 'ID', comp_name]]\n    days = pd.date_range(start='2017-01-01', periods=week_days) + pd.Timedelta(days=weekly_start)\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_w = df_w[df_w['ID'] == m.id_list[0]]\n    days = pd.date_range(start='2017-01-01', periods=7) + pd.Timedelta(days=weekly_start)\n    days = days.day_name()\n    artists += ax.plot(range(len(days_i)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(range(len(days_i)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.set_xticks(24 * np.arange(len(days) + 1 - weekly_start))\n    ax.set_xticklabels(list(days) + [days[0]] if m.data_freq != 'B' else list(days))\n    ax.set_xlabel('Day of week')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_weekly(m, quantile, comp_name='weekly', weekly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the weekly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the weekly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    week_days = 7\n    if m.data_freq == 'B':\n        week_days = 5\n        weekly_start = 1\n    days_i = pd.date_range(start='2017-01-01', periods=week_days * 24, freq='H') + pd.Timedelta(days=weekly_start)\n    df_w = pd.DataFrame({'ds': days_i})\n    if not isinstance(df_name, list):\n        df_w['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_w = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days_i})\n            df_i['ID'] = m.id_list[i]\n            df_w = pd.concat((df_w, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_w['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_w, quantile=quantile)[['ds', 'ID', comp_name]]\n    days = pd.date_range(start='2017-01-01', periods=week_days) + pd.Timedelta(days=weekly_start)\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_w = df_w[df_w['ID'] == m.id_list[0]]\n    days = pd.date_range(start='2017-01-01', periods=7) + pd.Timedelta(days=weekly_start)\n    days = days.day_name()\n    artists += ax.plot(range(len(days_i)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(range(len(days_i)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.set_xticks(24 * np.arange(len(days) + 1 - weekly_start))\n    ax.set_xticklabels(list(days) + [days[0]] if m.data_freq != 'B' else list(days))\n    ax.set_xlabel('Day of week')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_weekly(m, quantile, comp_name='weekly', weekly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the weekly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the weekly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    week_days = 7\n    if m.data_freq == 'B':\n        week_days = 5\n        weekly_start = 1\n    days_i = pd.date_range(start='2017-01-01', periods=week_days * 24, freq='H') + pd.Timedelta(days=weekly_start)\n    df_w = pd.DataFrame({'ds': days_i})\n    if not isinstance(df_name, list):\n        df_w['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_w = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days_i})\n            df_i['ID'] = m.id_list[i]\n            df_w = pd.concat((df_w, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_w['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_w, quantile=quantile)[['ds', 'ID', comp_name]]\n    days = pd.date_range(start='2017-01-01', periods=week_days) + pd.Timedelta(days=weekly_start)\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_w = df_w[df_w['ID'] == m.id_list[0]]\n    days = pd.date_range(start='2017-01-01', periods=7) + pd.Timedelta(days=weekly_start)\n    days = days.day_name()\n    artists += ax.plot(range(len(days_i)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(range(len(days_i)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.set_xticks(24 * np.arange(len(days) + 1 - weekly_start))\n    ax.set_xticklabels(list(days) + [days[0]] if m.data_freq != 'B' else list(days))\n    ax.set_xlabel('Day of week')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_weekly(m, quantile, comp_name='weekly', weekly_start=0, quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the weekly component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the weekly seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component\\n        weekly_start : int\\n            Specifying the start day of the weekly seasonality plot\\n\\n            Options\\n                * (default) ``weekly_start = 0``: starts the week on Sunday\\n                * ``weekly_start = 1``: shifts by 1 day to Monday, and so on\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    week_days = 7\n    if m.data_freq == 'B':\n        week_days = 5\n        weekly_start = 1\n    days_i = pd.date_range(start='2017-01-01', periods=week_days * 24, freq='H') + pd.Timedelta(days=weekly_start)\n    df_w = pd.DataFrame({'ds': days_i})\n    if not isinstance(df_name, list):\n        df_w['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_w = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days_i})\n            df_i['ID'] = m.id_list[i]\n            df_w = pd.concat((df_w, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_w['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_w, quantile=quantile)[['ds', 'ID', comp_name]]\n    days = pd.date_range(start='2017-01-01', periods=week_days) + pd.Timedelta(days=weekly_start)\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_w = df_w[df_w['ID'] == m.id_list[0]]\n    days = pd.date_range(start='2017-01-01', periods=7) + pd.Timedelta(days=weekly_start)\n    days = days.day_name()\n    artists += ax.plot(range(len(days_i)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    if mean_std:\n        ax.fill_between(range(len(days_i)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.set_xticks(24 * np.arange(len(days) + 1 - weekly_start))\n    ax.set_xticklabels(list(days) + [days[0]] if m.data_freq != 'B' else list(days))\n    ax.set_xlabel('Day of week')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists"
        ]
    },
    {
        "func_name": "plot_daily",
        "original": "def plot_daily(m, quantile, comp_name='daily', quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    \"\"\"Plot the daily component of the forecast.\n\n    Parameters\n    ----------\n        m : NeuralProphet\n            Fitted model\n        quantile : float\n            The quantile for which the daily seasonality is plotted\n        comp_name : str\n            Name of seasonality component if previously changed from default ``daily``\n        quick : bool\n            Use quick low-level call of model\n        ax : matplotlib axis\n            Matplotlib Axes to plot on\n        figsize : tuple\n            Width, height in inches, ignored if ax is not None.\n\n            Note\n            ----\n            Default value is set to ``figsize = (10, 6)``\n        df_name : str\n            Name of dataframe to refer to data params from original keys of train dataframes\n\n            Note\n            ----\n            Only used for local normalization in global modeling\n\n    Returns\n    -------\n        matplotlib.artist.Artist\n            List of Artist objects containing weekly forecast component\n    \"\"\"\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=24 * 12, freq='5min')\n    df_d = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_d['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_d = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_d = pd.concat((df_d, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_d['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_d, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_d = df_d[df_d['ID'] == m.id_list[0]]\n    artists += ax.plot(range(len(days)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    if mean_std:\n        ax.fill_between(range(len(days)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xticks(12 * np.arange(25))\n    ax.set_xticklabels(np.arange(25))\n    ax.set_xlabel('Hour of day')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
        "mutated": [
            "def plot_daily(m, quantile, comp_name='daily', quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n    'Plot the daily component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the daily seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component if previously changed from default ``daily``\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=24 * 12, freq='5min')\n    df_d = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_d['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_d = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_d = pd.concat((df_d, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_d['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_d, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_d = df_d[df_d['ID'] == m.id_list[0]]\n    artists += ax.plot(range(len(days)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    if mean_std:\n        ax.fill_between(range(len(days)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xticks(12 * np.arange(25))\n    ax.set_xticklabels(np.arange(25))\n    ax.set_xlabel('Hour of day')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_daily(m, quantile, comp_name='daily', quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the daily component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the daily seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component if previously changed from default ``daily``\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=24 * 12, freq='5min')\n    df_d = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_d['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_d = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_d = pd.concat((df_d, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_d['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_d, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_d = df_d[df_d['ID'] == m.id_list[0]]\n    artists += ax.plot(range(len(days)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    if mean_std:\n        ax.fill_between(range(len(days)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xticks(12 * np.arange(25))\n    ax.set_xticklabels(np.arange(25))\n    ax.set_xlabel('Hour of day')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_daily(m, quantile, comp_name='daily', quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the daily component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the daily seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component if previously changed from default ``daily``\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=24 * 12, freq='5min')\n    df_d = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_d['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_d = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_d = pd.concat((df_d, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_d['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_d, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_d = df_d[df_d['ID'] == m.id_list[0]]\n    artists += ax.plot(range(len(days)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    if mean_std:\n        ax.fill_between(range(len(days)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xticks(12 * np.arange(25))\n    ax.set_xticklabels(np.arange(25))\n    ax.set_xlabel('Hour of day')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_daily(m, quantile, comp_name='daily', quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the daily component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the daily seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component if previously changed from default ``daily``\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=24 * 12, freq='5min')\n    df_d = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_d['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_d = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_d = pd.concat((df_d, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_d['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_d, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_d = df_d[df_d['ID'] == m.id_list[0]]\n    artists += ax.plot(range(len(days)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    if mean_std:\n        ax.fill_between(range(len(days)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xticks(12 * np.arange(25))\n    ax.set_xticklabels(np.arange(25))\n    ax.set_xlabel('Hour of day')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists",
            "def plot_daily(m, quantile, comp_name='daily', quick=True, ax=None, figsize=(10, 6), df_name='__df__'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the daily component of the forecast.\\n\\n    Parameters\\n    ----------\\n        m : NeuralProphet\\n            Fitted model\\n        quantile : float\\n            The quantile for which the daily seasonality is plotted\\n        comp_name : str\\n            Name of seasonality component if previously changed from default ``daily``\\n        quick : bool\\n            Use quick low-level call of model\\n        ax : matplotlib axis\\n            Matplotlib Axes to plot on\\n        figsize : tuple\\n            Width, height in inches, ignored if ax is not None.\\n\\n            Note\\n            ----\\n            Default value is set to ``figsize = (10, 6)``\\n        df_name : str\\n            Name of dataframe to refer to data params from original keys of train dataframes\\n\\n            Note\\n            ----\\n            Only used for local normalization in global modeling\\n\\n    Returns\\n    -------\\n        matplotlib.artist.Artist\\n            List of Artist objects containing weekly forecast component\\n    '\n    artists = []\n    if not ax:\n        fig = plt.figure(facecolor='w', figsize=figsize)\n        ax = fig.add_subplot(111)\n    days = pd.date_range(start='2017-01-01', periods=24 * 12, freq='5min')\n    df_d = pd.DataFrame({'ds': days})\n    if not isinstance(df_name, list):\n        df_d['ID'] = df_name\n    mean_std = False\n    if isinstance(df_name, list):\n        df_d = pd.DataFrame()\n        mean_std = True\n        quick = False\n        for i in range(m.id_list.__len__()):\n            df_i = pd.DataFrame({'ds': days})\n            df_i['ID'] = m.id_list[i]\n            df_d = pd.concat((df_d, df_i), ignore_index=True)\n    if quick:\n        predicted = predict_season_from_dates(m, dates=df_d['ds'], name=comp_name, quantile=quantile, df_name=df_name)\n    else:\n        predicted = m.predict_seasonal_components(df_d, quantile=quantile)[['ds', 'ID', comp_name]]\n    if mean_std:\n        predicted_q90 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.9))\n        predicted_q10 = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.quantile(0.1))\n        predicted = predicted.groupby('ds')[[comp_name]].apply(lambda x: x.mean())\n        predicted['ID'] = m.id_list[0]\n        df_d = df_d[df_d['ID'] == m.id_list[0]]\n    artists += ax.plot(range(len(days)), predicted[comp_name], ls='-', c='#0072B2', label=comp_name + ' Mean' if mean_std else None)\n    if mean_std:\n        ax.fill_between(range(len(days)), predicted_q10[comp_name], predicted_q90[comp_name], alpha=0.2, label='Quants 10-90%', color='#0072B2')\n        ax.legend()\n    ax.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n    ax.set_xticks(12 * np.arange(25))\n    ax.set_xticklabels(np.arange(25))\n    ax.set_xlabel('Hour of day')\n    ax.set_ylabel(f'Seasonality: {comp_name}')\n    return artists"
        ]
    }
]