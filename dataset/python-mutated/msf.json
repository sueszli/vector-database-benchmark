[
    {
        "func_name": "_read_next_alignment",
        "original": "def _read_next_alignment(self, stream):\n    try:\n        line = next(stream)\n    except StopIteration:\n        if stream.tell() == 0:\n            raise ValueError('Empty file.') from None\n        return\n    known_headers = ['!!NA_MULTIPLE_ALIGNMENT', '!!AA_MULTIPLE_ALIGNMENT', 'PileUp']\n    if line.strip().split()[0] not in known_headers:\n        raise ValueError('%s is not a known GCG MSF header: %s' % (line.strip().split()[0], ', '.join(known_headers)))\n    for line in stream:\n        line = line.rstrip('\\n')\n        if 'MSF: ' in line and line.endswith('..'):\n            break\n    else:\n        raise ValueError('Reached end of file without MSF/Type/Check header line')\n    parts = line.split()\n    offset = parts.index('MSF:')\n    if parts[offset + 2] != 'Type:' or parts[-3] not in ('Check:', 'CompCheck:'):\n        raise ValueError(\"GCG MSF header line should be '<optional text> MSF: <int> Type: <letter> <optional date> Check: <int> ..',  not: %r\" % line)\n    try:\n        aln_length = int(parts[offset + 1])\n    except ValueError:\n        raise ValueError('GCG MSF header line should have MSF: <int> for column count, not %r' % parts[offset + 1]) from None\n    seq_type = parts[offset + 3]\n    if seq_type not in ['P', 'N']:\n        raise ValueError(\"GCG MSF header line should have 'Type: P' (protein) or 'Type: N' (nucleotide), not 'Type: %s'\" % seq_type)\n    names = []\n    remaining = []\n    checks = []\n    weights = []\n    for line in stream:\n        line = line.strip()\n        if line == '//':\n            break\n        if line.startswith('Name: '):\n            words = line.split()\n            try:\n                index_name = words.index('Name:')\n                index_len = words.index('Len:')\n                index_weight = words.index('Weight:')\n                index_check = words.index('Check:')\n            except ValueError:\n                raise ValueError(f'Malformed GCG MSF name line: {line!r}') from None\n            name = words[index_name + 1]\n            length = int(words[index_len + 1])\n            weight = float(words[index_weight + 1])\n            check = words[index_check + 1]\n            if name in names:\n                raise ValueError(f'Duplicated ID of {name!r}')\n            names.append(name)\n            remaining.append(length)\n            checks.append(check)\n            weights.append(weight)\n    else:\n        raise ValueError('End of file while looking for end of header // line.')\n    try:\n        line = next(stream)\n    except StopIteration:\n        raise ValueError('End of file after // line, expected sequences.') from None\n    if line.strip():\n        raise ValueError('After // line, expected blank line before sequences.')\n    seqs = [''] * len(names)\n    for line in stream:\n        words = line.split()\n        if not words:\n            continue\n        name = words[0]\n        try:\n            index = names.index(name)\n        except ValueError:\n            for word in words:\n                if not word.isdigit():\n                    break\n            else:\n                continue\n            raise ValueError(f\"Unexpected line '{line}' in input\") from None\n        seq = ''.join(words[1:])\n        length = remaining[index] - (len(seq) - seq.count('-'))\n        if length < 0:\n            raise ValueError('Received longer sequence than expected for %s' % name)\n        seqs[index] += seq\n        remaining[index] = length\n        if all((length == 0 for length in remaining)):\n            break\n    else:\n        raise ValueError('End of file where expecting sequence data.')\n    for line in stream:\n        assert line.strip() == ''\n    length = max((len(seq) for seq in seqs))\n    if length != aln_length:\n        warnings.warn('GCG MSF headers said alignment length %i, but found %i' % (aln_length, length), BiopythonParserWarning, stacklevel=2)\n        aln_length = length\n    for (index, seq) in enumerate(seqs):\n        seq = ''.join(seq).replace('~', '-').replace('.', '-')\n        if len(seq) < aln_length:\n            seq += '-' * (aln_length - len(seq))\n        seqs[index] = seq\n    coordinates = Alignment.infer_coordinates(seqs)\n    seqs = (Seq(seq.replace('-', '')) for seq in seqs)\n    records = [SeqRecord(seq, id=name, name=name, description=name, annotations={'weight': weight}) for (name, seq, weight) in zip(names, seqs, weights)]\n    alignment = Alignment(records, coordinates)\n    columns = alignment.length\n    if columns != aln_length:\n        raise ValueError('GCG MSF headers said alignment length %i, but found %i' % (aln_length, columns))\n    return alignment",
        "mutated": [
            "def _read_next_alignment(self, stream):\n    if False:\n        i = 10\n    try:\n        line = next(stream)\n    except StopIteration:\n        if stream.tell() == 0:\n            raise ValueError('Empty file.') from None\n        return\n    known_headers = ['!!NA_MULTIPLE_ALIGNMENT', '!!AA_MULTIPLE_ALIGNMENT', 'PileUp']\n    if line.strip().split()[0] not in known_headers:\n        raise ValueError('%s is not a known GCG MSF header: %s' % (line.strip().split()[0], ', '.join(known_headers)))\n    for line in stream:\n        line = line.rstrip('\\n')\n        if 'MSF: ' in line and line.endswith('..'):\n            break\n    else:\n        raise ValueError('Reached end of file without MSF/Type/Check header line')\n    parts = line.split()\n    offset = parts.index('MSF:')\n    if parts[offset + 2] != 'Type:' or parts[-3] not in ('Check:', 'CompCheck:'):\n        raise ValueError(\"GCG MSF header line should be '<optional text> MSF: <int> Type: <letter> <optional date> Check: <int> ..',  not: %r\" % line)\n    try:\n        aln_length = int(parts[offset + 1])\n    except ValueError:\n        raise ValueError('GCG MSF header line should have MSF: <int> for column count, not %r' % parts[offset + 1]) from None\n    seq_type = parts[offset + 3]\n    if seq_type not in ['P', 'N']:\n        raise ValueError(\"GCG MSF header line should have 'Type: P' (protein) or 'Type: N' (nucleotide), not 'Type: %s'\" % seq_type)\n    names = []\n    remaining = []\n    checks = []\n    weights = []\n    for line in stream:\n        line = line.strip()\n        if line == '//':\n            break\n        if line.startswith('Name: '):\n            words = line.split()\n            try:\n                index_name = words.index('Name:')\n                index_len = words.index('Len:')\n                index_weight = words.index('Weight:')\n                index_check = words.index('Check:')\n            except ValueError:\n                raise ValueError(f'Malformed GCG MSF name line: {line!r}') from None\n            name = words[index_name + 1]\n            length = int(words[index_len + 1])\n            weight = float(words[index_weight + 1])\n            check = words[index_check + 1]\n            if name in names:\n                raise ValueError(f'Duplicated ID of {name!r}')\n            names.append(name)\n            remaining.append(length)\n            checks.append(check)\n            weights.append(weight)\n    else:\n        raise ValueError('End of file while looking for end of header // line.')\n    try:\n        line = next(stream)\n    except StopIteration:\n        raise ValueError('End of file after // line, expected sequences.') from None\n    if line.strip():\n        raise ValueError('After // line, expected blank line before sequences.')\n    seqs = [''] * len(names)\n    for line in stream:\n        words = line.split()\n        if not words:\n            continue\n        name = words[0]\n        try:\n            index = names.index(name)\n        except ValueError:\n            for word in words:\n                if not word.isdigit():\n                    break\n            else:\n                continue\n            raise ValueError(f\"Unexpected line '{line}' in input\") from None\n        seq = ''.join(words[1:])\n        length = remaining[index] - (len(seq) - seq.count('-'))\n        if length < 0:\n            raise ValueError('Received longer sequence than expected for %s' % name)\n        seqs[index] += seq\n        remaining[index] = length\n        if all((length == 0 for length in remaining)):\n            break\n    else:\n        raise ValueError('End of file where expecting sequence data.')\n    for line in stream:\n        assert line.strip() == ''\n    length = max((len(seq) for seq in seqs))\n    if length != aln_length:\n        warnings.warn('GCG MSF headers said alignment length %i, but found %i' % (aln_length, length), BiopythonParserWarning, stacklevel=2)\n        aln_length = length\n    for (index, seq) in enumerate(seqs):\n        seq = ''.join(seq).replace('~', '-').replace('.', '-')\n        if len(seq) < aln_length:\n            seq += '-' * (aln_length - len(seq))\n        seqs[index] = seq\n    coordinates = Alignment.infer_coordinates(seqs)\n    seqs = (Seq(seq.replace('-', '')) for seq in seqs)\n    records = [SeqRecord(seq, id=name, name=name, description=name, annotations={'weight': weight}) for (name, seq, weight) in zip(names, seqs, weights)]\n    alignment = Alignment(records, coordinates)\n    columns = alignment.length\n    if columns != aln_length:\n        raise ValueError('GCG MSF headers said alignment length %i, but found %i' % (aln_length, columns))\n    return alignment",
            "def _read_next_alignment(self, stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        line = next(stream)\n    except StopIteration:\n        if stream.tell() == 0:\n            raise ValueError('Empty file.') from None\n        return\n    known_headers = ['!!NA_MULTIPLE_ALIGNMENT', '!!AA_MULTIPLE_ALIGNMENT', 'PileUp']\n    if line.strip().split()[0] not in known_headers:\n        raise ValueError('%s is not a known GCG MSF header: %s' % (line.strip().split()[0], ', '.join(known_headers)))\n    for line in stream:\n        line = line.rstrip('\\n')\n        if 'MSF: ' in line and line.endswith('..'):\n            break\n    else:\n        raise ValueError('Reached end of file without MSF/Type/Check header line')\n    parts = line.split()\n    offset = parts.index('MSF:')\n    if parts[offset + 2] != 'Type:' or parts[-3] not in ('Check:', 'CompCheck:'):\n        raise ValueError(\"GCG MSF header line should be '<optional text> MSF: <int> Type: <letter> <optional date> Check: <int> ..',  not: %r\" % line)\n    try:\n        aln_length = int(parts[offset + 1])\n    except ValueError:\n        raise ValueError('GCG MSF header line should have MSF: <int> for column count, not %r' % parts[offset + 1]) from None\n    seq_type = parts[offset + 3]\n    if seq_type not in ['P', 'N']:\n        raise ValueError(\"GCG MSF header line should have 'Type: P' (protein) or 'Type: N' (nucleotide), not 'Type: %s'\" % seq_type)\n    names = []\n    remaining = []\n    checks = []\n    weights = []\n    for line in stream:\n        line = line.strip()\n        if line == '//':\n            break\n        if line.startswith('Name: '):\n            words = line.split()\n            try:\n                index_name = words.index('Name:')\n                index_len = words.index('Len:')\n                index_weight = words.index('Weight:')\n                index_check = words.index('Check:')\n            except ValueError:\n                raise ValueError(f'Malformed GCG MSF name line: {line!r}') from None\n            name = words[index_name + 1]\n            length = int(words[index_len + 1])\n            weight = float(words[index_weight + 1])\n            check = words[index_check + 1]\n            if name in names:\n                raise ValueError(f'Duplicated ID of {name!r}')\n            names.append(name)\n            remaining.append(length)\n            checks.append(check)\n            weights.append(weight)\n    else:\n        raise ValueError('End of file while looking for end of header // line.')\n    try:\n        line = next(stream)\n    except StopIteration:\n        raise ValueError('End of file after // line, expected sequences.') from None\n    if line.strip():\n        raise ValueError('After // line, expected blank line before sequences.')\n    seqs = [''] * len(names)\n    for line in stream:\n        words = line.split()\n        if not words:\n            continue\n        name = words[0]\n        try:\n            index = names.index(name)\n        except ValueError:\n            for word in words:\n                if not word.isdigit():\n                    break\n            else:\n                continue\n            raise ValueError(f\"Unexpected line '{line}' in input\") from None\n        seq = ''.join(words[1:])\n        length = remaining[index] - (len(seq) - seq.count('-'))\n        if length < 0:\n            raise ValueError('Received longer sequence than expected for %s' % name)\n        seqs[index] += seq\n        remaining[index] = length\n        if all((length == 0 for length in remaining)):\n            break\n    else:\n        raise ValueError('End of file where expecting sequence data.')\n    for line in stream:\n        assert line.strip() == ''\n    length = max((len(seq) for seq in seqs))\n    if length != aln_length:\n        warnings.warn('GCG MSF headers said alignment length %i, but found %i' % (aln_length, length), BiopythonParserWarning, stacklevel=2)\n        aln_length = length\n    for (index, seq) in enumerate(seqs):\n        seq = ''.join(seq).replace('~', '-').replace('.', '-')\n        if len(seq) < aln_length:\n            seq += '-' * (aln_length - len(seq))\n        seqs[index] = seq\n    coordinates = Alignment.infer_coordinates(seqs)\n    seqs = (Seq(seq.replace('-', '')) for seq in seqs)\n    records = [SeqRecord(seq, id=name, name=name, description=name, annotations={'weight': weight}) for (name, seq, weight) in zip(names, seqs, weights)]\n    alignment = Alignment(records, coordinates)\n    columns = alignment.length\n    if columns != aln_length:\n        raise ValueError('GCG MSF headers said alignment length %i, but found %i' % (aln_length, columns))\n    return alignment",
            "def _read_next_alignment(self, stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        line = next(stream)\n    except StopIteration:\n        if stream.tell() == 0:\n            raise ValueError('Empty file.') from None\n        return\n    known_headers = ['!!NA_MULTIPLE_ALIGNMENT', '!!AA_MULTIPLE_ALIGNMENT', 'PileUp']\n    if line.strip().split()[0] not in known_headers:\n        raise ValueError('%s is not a known GCG MSF header: %s' % (line.strip().split()[0], ', '.join(known_headers)))\n    for line in stream:\n        line = line.rstrip('\\n')\n        if 'MSF: ' in line and line.endswith('..'):\n            break\n    else:\n        raise ValueError('Reached end of file without MSF/Type/Check header line')\n    parts = line.split()\n    offset = parts.index('MSF:')\n    if parts[offset + 2] != 'Type:' or parts[-3] not in ('Check:', 'CompCheck:'):\n        raise ValueError(\"GCG MSF header line should be '<optional text> MSF: <int> Type: <letter> <optional date> Check: <int> ..',  not: %r\" % line)\n    try:\n        aln_length = int(parts[offset + 1])\n    except ValueError:\n        raise ValueError('GCG MSF header line should have MSF: <int> for column count, not %r' % parts[offset + 1]) from None\n    seq_type = parts[offset + 3]\n    if seq_type not in ['P', 'N']:\n        raise ValueError(\"GCG MSF header line should have 'Type: P' (protein) or 'Type: N' (nucleotide), not 'Type: %s'\" % seq_type)\n    names = []\n    remaining = []\n    checks = []\n    weights = []\n    for line in stream:\n        line = line.strip()\n        if line == '//':\n            break\n        if line.startswith('Name: '):\n            words = line.split()\n            try:\n                index_name = words.index('Name:')\n                index_len = words.index('Len:')\n                index_weight = words.index('Weight:')\n                index_check = words.index('Check:')\n            except ValueError:\n                raise ValueError(f'Malformed GCG MSF name line: {line!r}') from None\n            name = words[index_name + 1]\n            length = int(words[index_len + 1])\n            weight = float(words[index_weight + 1])\n            check = words[index_check + 1]\n            if name in names:\n                raise ValueError(f'Duplicated ID of {name!r}')\n            names.append(name)\n            remaining.append(length)\n            checks.append(check)\n            weights.append(weight)\n    else:\n        raise ValueError('End of file while looking for end of header // line.')\n    try:\n        line = next(stream)\n    except StopIteration:\n        raise ValueError('End of file after // line, expected sequences.') from None\n    if line.strip():\n        raise ValueError('After // line, expected blank line before sequences.')\n    seqs = [''] * len(names)\n    for line in stream:\n        words = line.split()\n        if not words:\n            continue\n        name = words[0]\n        try:\n            index = names.index(name)\n        except ValueError:\n            for word in words:\n                if not word.isdigit():\n                    break\n            else:\n                continue\n            raise ValueError(f\"Unexpected line '{line}' in input\") from None\n        seq = ''.join(words[1:])\n        length = remaining[index] - (len(seq) - seq.count('-'))\n        if length < 0:\n            raise ValueError('Received longer sequence than expected for %s' % name)\n        seqs[index] += seq\n        remaining[index] = length\n        if all((length == 0 for length in remaining)):\n            break\n    else:\n        raise ValueError('End of file where expecting sequence data.')\n    for line in stream:\n        assert line.strip() == ''\n    length = max((len(seq) for seq in seqs))\n    if length != aln_length:\n        warnings.warn('GCG MSF headers said alignment length %i, but found %i' % (aln_length, length), BiopythonParserWarning, stacklevel=2)\n        aln_length = length\n    for (index, seq) in enumerate(seqs):\n        seq = ''.join(seq).replace('~', '-').replace('.', '-')\n        if len(seq) < aln_length:\n            seq += '-' * (aln_length - len(seq))\n        seqs[index] = seq\n    coordinates = Alignment.infer_coordinates(seqs)\n    seqs = (Seq(seq.replace('-', '')) for seq in seqs)\n    records = [SeqRecord(seq, id=name, name=name, description=name, annotations={'weight': weight}) for (name, seq, weight) in zip(names, seqs, weights)]\n    alignment = Alignment(records, coordinates)\n    columns = alignment.length\n    if columns != aln_length:\n        raise ValueError('GCG MSF headers said alignment length %i, but found %i' % (aln_length, columns))\n    return alignment",
            "def _read_next_alignment(self, stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        line = next(stream)\n    except StopIteration:\n        if stream.tell() == 0:\n            raise ValueError('Empty file.') from None\n        return\n    known_headers = ['!!NA_MULTIPLE_ALIGNMENT', '!!AA_MULTIPLE_ALIGNMENT', 'PileUp']\n    if line.strip().split()[0] not in known_headers:\n        raise ValueError('%s is not a known GCG MSF header: %s' % (line.strip().split()[0], ', '.join(known_headers)))\n    for line in stream:\n        line = line.rstrip('\\n')\n        if 'MSF: ' in line and line.endswith('..'):\n            break\n    else:\n        raise ValueError('Reached end of file without MSF/Type/Check header line')\n    parts = line.split()\n    offset = parts.index('MSF:')\n    if parts[offset + 2] != 'Type:' or parts[-3] not in ('Check:', 'CompCheck:'):\n        raise ValueError(\"GCG MSF header line should be '<optional text> MSF: <int> Type: <letter> <optional date> Check: <int> ..',  not: %r\" % line)\n    try:\n        aln_length = int(parts[offset + 1])\n    except ValueError:\n        raise ValueError('GCG MSF header line should have MSF: <int> for column count, not %r' % parts[offset + 1]) from None\n    seq_type = parts[offset + 3]\n    if seq_type not in ['P', 'N']:\n        raise ValueError(\"GCG MSF header line should have 'Type: P' (protein) or 'Type: N' (nucleotide), not 'Type: %s'\" % seq_type)\n    names = []\n    remaining = []\n    checks = []\n    weights = []\n    for line in stream:\n        line = line.strip()\n        if line == '//':\n            break\n        if line.startswith('Name: '):\n            words = line.split()\n            try:\n                index_name = words.index('Name:')\n                index_len = words.index('Len:')\n                index_weight = words.index('Weight:')\n                index_check = words.index('Check:')\n            except ValueError:\n                raise ValueError(f'Malformed GCG MSF name line: {line!r}') from None\n            name = words[index_name + 1]\n            length = int(words[index_len + 1])\n            weight = float(words[index_weight + 1])\n            check = words[index_check + 1]\n            if name in names:\n                raise ValueError(f'Duplicated ID of {name!r}')\n            names.append(name)\n            remaining.append(length)\n            checks.append(check)\n            weights.append(weight)\n    else:\n        raise ValueError('End of file while looking for end of header // line.')\n    try:\n        line = next(stream)\n    except StopIteration:\n        raise ValueError('End of file after // line, expected sequences.') from None\n    if line.strip():\n        raise ValueError('After // line, expected blank line before sequences.')\n    seqs = [''] * len(names)\n    for line in stream:\n        words = line.split()\n        if not words:\n            continue\n        name = words[0]\n        try:\n            index = names.index(name)\n        except ValueError:\n            for word in words:\n                if not word.isdigit():\n                    break\n            else:\n                continue\n            raise ValueError(f\"Unexpected line '{line}' in input\") from None\n        seq = ''.join(words[1:])\n        length = remaining[index] - (len(seq) - seq.count('-'))\n        if length < 0:\n            raise ValueError('Received longer sequence than expected for %s' % name)\n        seqs[index] += seq\n        remaining[index] = length\n        if all((length == 0 for length in remaining)):\n            break\n    else:\n        raise ValueError('End of file where expecting sequence data.')\n    for line in stream:\n        assert line.strip() == ''\n    length = max((len(seq) for seq in seqs))\n    if length != aln_length:\n        warnings.warn('GCG MSF headers said alignment length %i, but found %i' % (aln_length, length), BiopythonParserWarning, stacklevel=2)\n        aln_length = length\n    for (index, seq) in enumerate(seqs):\n        seq = ''.join(seq).replace('~', '-').replace('.', '-')\n        if len(seq) < aln_length:\n            seq += '-' * (aln_length - len(seq))\n        seqs[index] = seq\n    coordinates = Alignment.infer_coordinates(seqs)\n    seqs = (Seq(seq.replace('-', '')) for seq in seqs)\n    records = [SeqRecord(seq, id=name, name=name, description=name, annotations={'weight': weight}) for (name, seq, weight) in zip(names, seqs, weights)]\n    alignment = Alignment(records, coordinates)\n    columns = alignment.length\n    if columns != aln_length:\n        raise ValueError('GCG MSF headers said alignment length %i, but found %i' % (aln_length, columns))\n    return alignment",
            "def _read_next_alignment(self, stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        line = next(stream)\n    except StopIteration:\n        if stream.tell() == 0:\n            raise ValueError('Empty file.') from None\n        return\n    known_headers = ['!!NA_MULTIPLE_ALIGNMENT', '!!AA_MULTIPLE_ALIGNMENT', 'PileUp']\n    if line.strip().split()[0] not in known_headers:\n        raise ValueError('%s is not a known GCG MSF header: %s' % (line.strip().split()[0], ', '.join(known_headers)))\n    for line in stream:\n        line = line.rstrip('\\n')\n        if 'MSF: ' in line and line.endswith('..'):\n            break\n    else:\n        raise ValueError('Reached end of file without MSF/Type/Check header line')\n    parts = line.split()\n    offset = parts.index('MSF:')\n    if parts[offset + 2] != 'Type:' or parts[-3] not in ('Check:', 'CompCheck:'):\n        raise ValueError(\"GCG MSF header line should be '<optional text> MSF: <int> Type: <letter> <optional date> Check: <int> ..',  not: %r\" % line)\n    try:\n        aln_length = int(parts[offset + 1])\n    except ValueError:\n        raise ValueError('GCG MSF header line should have MSF: <int> for column count, not %r' % parts[offset + 1]) from None\n    seq_type = parts[offset + 3]\n    if seq_type not in ['P', 'N']:\n        raise ValueError(\"GCG MSF header line should have 'Type: P' (protein) or 'Type: N' (nucleotide), not 'Type: %s'\" % seq_type)\n    names = []\n    remaining = []\n    checks = []\n    weights = []\n    for line in stream:\n        line = line.strip()\n        if line == '//':\n            break\n        if line.startswith('Name: '):\n            words = line.split()\n            try:\n                index_name = words.index('Name:')\n                index_len = words.index('Len:')\n                index_weight = words.index('Weight:')\n                index_check = words.index('Check:')\n            except ValueError:\n                raise ValueError(f'Malformed GCG MSF name line: {line!r}') from None\n            name = words[index_name + 1]\n            length = int(words[index_len + 1])\n            weight = float(words[index_weight + 1])\n            check = words[index_check + 1]\n            if name in names:\n                raise ValueError(f'Duplicated ID of {name!r}')\n            names.append(name)\n            remaining.append(length)\n            checks.append(check)\n            weights.append(weight)\n    else:\n        raise ValueError('End of file while looking for end of header // line.')\n    try:\n        line = next(stream)\n    except StopIteration:\n        raise ValueError('End of file after // line, expected sequences.') from None\n    if line.strip():\n        raise ValueError('After // line, expected blank line before sequences.')\n    seqs = [''] * len(names)\n    for line in stream:\n        words = line.split()\n        if not words:\n            continue\n        name = words[0]\n        try:\n            index = names.index(name)\n        except ValueError:\n            for word in words:\n                if not word.isdigit():\n                    break\n            else:\n                continue\n            raise ValueError(f\"Unexpected line '{line}' in input\") from None\n        seq = ''.join(words[1:])\n        length = remaining[index] - (len(seq) - seq.count('-'))\n        if length < 0:\n            raise ValueError('Received longer sequence than expected for %s' % name)\n        seqs[index] += seq\n        remaining[index] = length\n        if all((length == 0 for length in remaining)):\n            break\n    else:\n        raise ValueError('End of file where expecting sequence data.')\n    for line in stream:\n        assert line.strip() == ''\n    length = max((len(seq) for seq in seqs))\n    if length != aln_length:\n        warnings.warn('GCG MSF headers said alignment length %i, but found %i' % (aln_length, length), BiopythonParserWarning, stacklevel=2)\n        aln_length = length\n    for (index, seq) in enumerate(seqs):\n        seq = ''.join(seq).replace('~', '-').replace('.', '-')\n        if len(seq) < aln_length:\n            seq += '-' * (aln_length - len(seq))\n        seqs[index] = seq\n    coordinates = Alignment.infer_coordinates(seqs)\n    seqs = (Seq(seq.replace('-', '')) for seq in seqs)\n    records = [SeqRecord(seq, id=name, name=name, description=name, annotations={'weight': weight}) for (name, seq, weight) in zip(names, seqs, weights)]\n    alignment = Alignment(records, coordinates)\n    columns = alignment.length\n    if columns != aln_length:\n        raise ValueError('GCG MSF headers said alignment length %i, but found %i' % (aln_length, columns))\n    return alignment"
        ]
    }
]