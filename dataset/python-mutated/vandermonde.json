[
    {
        "func_name": "symbol_gen",
        "original": "def symbol_gen(sym_str):\n    \"\"\"Symbol generator\n\n    Generates sym_str_n where n is the number of times the generator\n    has been called.\n    \"\"\"\n    n = 0\n    while True:\n        yield Symbol('%s_%d' % (sym_str, n))\n        n += 1",
        "mutated": [
            "def symbol_gen(sym_str):\n    if False:\n        i = 10\n    'Symbol generator\\n\\n    Generates sym_str_n where n is the number of times the generator\\n    has been called.\\n    '\n    n = 0\n    while True:\n        yield Symbol('%s_%d' % (sym_str, n))\n        n += 1",
            "def symbol_gen(sym_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Symbol generator\\n\\n    Generates sym_str_n where n is the number of times the generator\\n    has been called.\\n    '\n    n = 0\n    while True:\n        yield Symbol('%s_%d' % (sym_str, n))\n        n += 1",
            "def symbol_gen(sym_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Symbol generator\\n\\n    Generates sym_str_n where n is the number of times the generator\\n    has been called.\\n    '\n    n = 0\n    while True:\n        yield Symbol('%s_%d' % (sym_str, n))\n        n += 1",
            "def symbol_gen(sym_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Symbol generator\\n\\n    Generates sym_str_n where n is the number of times the generator\\n    has been called.\\n    '\n    n = 0\n    while True:\n        yield Symbol('%s_%d' % (sym_str, n))\n        n += 1",
            "def symbol_gen(sym_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Symbol generator\\n\\n    Generates sym_str_n where n is the number of times the generator\\n    has been called.\\n    '\n    n = 0\n    while True:\n        yield Symbol('%s_%d' % (sym_str, n))\n        n += 1"
        ]
    },
    {
        "func_name": "comb_w_rep",
        "original": "def comb_w_rep(n, k):\n    \"\"\"Combinations with repetition\n\n    Returns the list of k combinations with repetition from n objects.\n    \"\"\"\n    if k == 0:\n        return [[]]\n    combs = [[i] for i in range(n)]\n    for i in range(k - 1):\n        curr = []\n        for p in combs:\n            for m in range(p[-1], n):\n                curr.append(p + [m])\n        combs = curr\n    return combs",
        "mutated": [
            "def comb_w_rep(n, k):\n    if False:\n        i = 10\n    'Combinations with repetition\\n\\n    Returns the list of k combinations with repetition from n objects.\\n    '\n    if k == 0:\n        return [[]]\n    combs = [[i] for i in range(n)]\n    for i in range(k - 1):\n        curr = []\n        for p in combs:\n            for m in range(p[-1], n):\n                curr.append(p + [m])\n        combs = curr\n    return combs",
            "def comb_w_rep(n, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Combinations with repetition\\n\\n    Returns the list of k combinations with repetition from n objects.\\n    '\n    if k == 0:\n        return [[]]\n    combs = [[i] for i in range(n)]\n    for i in range(k - 1):\n        curr = []\n        for p in combs:\n            for m in range(p[-1], n):\n                curr.append(p + [m])\n        combs = curr\n    return combs",
            "def comb_w_rep(n, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Combinations with repetition\\n\\n    Returns the list of k combinations with repetition from n objects.\\n    '\n    if k == 0:\n        return [[]]\n    combs = [[i] for i in range(n)]\n    for i in range(k - 1):\n        curr = []\n        for p in combs:\n            for m in range(p[-1], n):\n                curr.append(p + [m])\n        combs = curr\n    return combs",
            "def comb_w_rep(n, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Combinations with repetition\\n\\n    Returns the list of k combinations with repetition from n objects.\\n    '\n    if k == 0:\n        return [[]]\n    combs = [[i] for i in range(n)]\n    for i in range(k - 1):\n        curr = []\n        for p in combs:\n            for m in range(p[-1], n):\n                curr.append(p + [m])\n        combs = curr\n    return combs",
            "def comb_w_rep(n, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Combinations with repetition\\n\\n    Returns the list of k combinations with repetition from n objects.\\n    '\n    if k == 0:\n        return [[]]\n    combs = [[i] for i in range(n)]\n    for i in range(k - 1):\n        curr = []\n        for p in combs:\n            for m in range(p[-1], n):\n                curr.append(p + [m])\n        combs = curr\n    return combs"
        ]
    },
    {
        "func_name": "vandermonde",
        "original": "def vandermonde(order, dim=1, syms='a b c d'):\n    \"\"\"Computes a Vandermonde matrix of given order and dimension.\n\n    Define syms to give beginning strings for temporary variables.\n\n    Returns the Matrix, the temporary variables, and the terms for the\n    polynomials.\n    \"\"\"\n    syms = syms.split()\n    n = len(syms)\n    if n < dim:\n        new_syms = []\n        for i in range(dim - n):\n            (j, rem) = divmod(i, n)\n            new_syms.append(syms[rem] + str(j))\n        syms.extend(new_syms)\n    terms = []\n    for i in range(order + 1):\n        terms.extend(comb_w_rep(dim, i))\n    rank = len(terms)\n    V = zeros(rank)\n    generators = [symbol_gen(syms[i]) for i in range(dim)]\n    all_syms = []\n    for i in range(rank):\n        row_syms = [next(g) for g in generators]\n        all_syms.append(row_syms)\n        for (j, term) in enumerate(terms):\n            v_entry = 1\n            for k in term:\n                v_entry *= row_syms[k]\n            V[i * rank + j] = v_entry\n    return (V, all_syms, terms)",
        "mutated": [
            "def vandermonde(order, dim=1, syms='a b c d'):\n    if False:\n        i = 10\n    'Computes a Vandermonde matrix of given order and dimension.\\n\\n    Define syms to give beginning strings for temporary variables.\\n\\n    Returns the Matrix, the temporary variables, and the terms for the\\n    polynomials.\\n    '\n    syms = syms.split()\n    n = len(syms)\n    if n < dim:\n        new_syms = []\n        for i in range(dim - n):\n            (j, rem) = divmod(i, n)\n            new_syms.append(syms[rem] + str(j))\n        syms.extend(new_syms)\n    terms = []\n    for i in range(order + 1):\n        terms.extend(comb_w_rep(dim, i))\n    rank = len(terms)\n    V = zeros(rank)\n    generators = [symbol_gen(syms[i]) for i in range(dim)]\n    all_syms = []\n    for i in range(rank):\n        row_syms = [next(g) for g in generators]\n        all_syms.append(row_syms)\n        for (j, term) in enumerate(terms):\n            v_entry = 1\n            for k in term:\n                v_entry *= row_syms[k]\n            V[i * rank + j] = v_entry\n    return (V, all_syms, terms)",
            "def vandermonde(order, dim=1, syms='a b c d'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes a Vandermonde matrix of given order and dimension.\\n\\n    Define syms to give beginning strings for temporary variables.\\n\\n    Returns the Matrix, the temporary variables, and the terms for the\\n    polynomials.\\n    '\n    syms = syms.split()\n    n = len(syms)\n    if n < dim:\n        new_syms = []\n        for i in range(dim - n):\n            (j, rem) = divmod(i, n)\n            new_syms.append(syms[rem] + str(j))\n        syms.extend(new_syms)\n    terms = []\n    for i in range(order + 1):\n        terms.extend(comb_w_rep(dim, i))\n    rank = len(terms)\n    V = zeros(rank)\n    generators = [symbol_gen(syms[i]) for i in range(dim)]\n    all_syms = []\n    for i in range(rank):\n        row_syms = [next(g) for g in generators]\n        all_syms.append(row_syms)\n        for (j, term) in enumerate(terms):\n            v_entry = 1\n            for k in term:\n                v_entry *= row_syms[k]\n            V[i * rank + j] = v_entry\n    return (V, all_syms, terms)",
            "def vandermonde(order, dim=1, syms='a b c d'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes a Vandermonde matrix of given order and dimension.\\n\\n    Define syms to give beginning strings for temporary variables.\\n\\n    Returns the Matrix, the temporary variables, and the terms for the\\n    polynomials.\\n    '\n    syms = syms.split()\n    n = len(syms)\n    if n < dim:\n        new_syms = []\n        for i in range(dim - n):\n            (j, rem) = divmod(i, n)\n            new_syms.append(syms[rem] + str(j))\n        syms.extend(new_syms)\n    terms = []\n    for i in range(order + 1):\n        terms.extend(comb_w_rep(dim, i))\n    rank = len(terms)\n    V = zeros(rank)\n    generators = [symbol_gen(syms[i]) for i in range(dim)]\n    all_syms = []\n    for i in range(rank):\n        row_syms = [next(g) for g in generators]\n        all_syms.append(row_syms)\n        for (j, term) in enumerate(terms):\n            v_entry = 1\n            for k in term:\n                v_entry *= row_syms[k]\n            V[i * rank + j] = v_entry\n    return (V, all_syms, terms)",
            "def vandermonde(order, dim=1, syms='a b c d'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes a Vandermonde matrix of given order and dimension.\\n\\n    Define syms to give beginning strings for temporary variables.\\n\\n    Returns the Matrix, the temporary variables, and the terms for the\\n    polynomials.\\n    '\n    syms = syms.split()\n    n = len(syms)\n    if n < dim:\n        new_syms = []\n        for i in range(dim - n):\n            (j, rem) = divmod(i, n)\n            new_syms.append(syms[rem] + str(j))\n        syms.extend(new_syms)\n    terms = []\n    for i in range(order + 1):\n        terms.extend(comb_w_rep(dim, i))\n    rank = len(terms)\n    V = zeros(rank)\n    generators = [symbol_gen(syms[i]) for i in range(dim)]\n    all_syms = []\n    for i in range(rank):\n        row_syms = [next(g) for g in generators]\n        all_syms.append(row_syms)\n        for (j, term) in enumerate(terms):\n            v_entry = 1\n            for k in term:\n                v_entry *= row_syms[k]\n            V[i * rank + j] = v_entry\n    return (V, all_syms, terms)",
            "def vandermonde(order, dim=1, syms='a b c d'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes a Vandermonde matrix of given order and dimension.\\n\\n    Define syms to give beginning strings for temporary variables.\\n\\n    Returns the Matrix, the temporary variables, and the terms for the\\n    polynomials.\\n    '\n    syms = syms.split()\n    n = len(syms)\n    if n < dim:\n        new_syms = []\n        for i in range(dim - n):\n            (j, rem) = divmod(i, n)\n            new_syms.append(syms[rem] + str(j))\n        syms.extend(new_syms)\n    terms = []\n    for i in range(order + 1):\n        terms.extend(comb_w_rep(dim, i))\n    rank = len(terms)\n    V = zeros(rank)\n    generators = [symbol_gen(syms[i]) for i in range(dim)]\n    all_syms = []\n    for i in range(rank):\n        row_syms = [next(g) for g in generators]\n        all_syms.append(row_syms)\n        for (j, term) in enumerate(terms):\n            v_entry = 1\n            for k in term:\n                v_entry *= row_syms[k]\n            V[i * rank + j] = v_entry\n    return (V, all_syms, terms)"
        ]
    },
    {
        "func_name": "gen_poly",
        "original": "def gen_poly(points, order, syms):\n    \"\"\"Generates a polynomial using a Vandermonde system\"\"\"\n    num_pts = len(points)\n    if num_pts == 0:\n        raise ValueError('Must provide points')\n    dim = len(points[0]) - 1\n    if dim > len(syms):\n        raise ValueError('Must provide at least %d symbols for the polynomial' % dim)\n    (V, tmp_syms, terms) = vandermonde(order, dim)\n    if num_pts < V.shape[0]:\n        raise ValueError('Must provide %d points for order %d, dimension %d polynomial, given %d points' % (V.shape[0], order, dim, num_pts))\n    elif num_pts > V.shape[0]:\n        print('gen_poly given %d points but only requires %d, continuing using the first %d points' % (num_pts, V.shape[0], V.shape[0]))\n        num_pts = V.shape[0]\n    subs_dict = {}\n    for j in range(dim):\n        for i in range(num_pts):\n            subs_dict[tmp_syms[i][j]] = points[i][j]\n    V_pts = V.subs(subs_dict)\n    V_inv = V_pts.inv()\n    coeffs = V_inv.multiply(Matrix([points[i][-1] for i in range(num_pts)]))\n    f = 0\n    for (j, term) in enumerate(terms):\n        t = 1\n        for k in term:\n            t *= syms[k]\n        f += coeffs[j] * t\n    return f",
        "mutated": [
            "def gen_poly(points, order, syms):\n    if False:\n        i = 10\n    'Generates a polynomial using a Vandermonde system'\n    num_pts = len(points)\n    if num_pts == 0:\n        raise ValueError('Must provide points')\n    dim = len(points[0]) - 1\n    if dim > len(syms):\n        raise ValueError('Must provide at least %d symbols for the polynomial' % dim)\n    (V, tmp_syms, terms) = vandermonde(order, dim)\n    if num_pts < V.shape[0]:\n        raise ValueError('Must provide %d points for order %d, dimension %d polynomial, given %d points' % (V.shape[0], order, dim, num_pts))\n    elif num_pts > V.shape[0]:\n        print('gen_poly given %d points but only requires %d, continuing using the first %d points' % (num_pts, V.shape[0], V.shape[0]))\n        num_pts = V.shape[0]\n    subs_dict = {}\n    for j in range(dim):\n        for i in range(num_pts):\n            subs_dict[tmp_syms[i][j]] = points[i][j]\n    V_pts = V.subs(subs_dict)\n    V_inv = V_pts.inv()\n    coeffs = V_inv.multiply(Matrix([points[i][-1] for i in range(num_pts)]))\n    f = 0\n    for (j, term) in enumerate(terms):\n        t = 1\n        for k in term:\n            t *= syms[k]\n        f += coeffs[j] * t\n    return f",
            "def gen_poly(points, order, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates a polynomial using a Vandermonde system'\n    num_pts = len(points)\n    if num_pts == 0:\n        raise ValueError('Must provide points')\n    dim = len(points[0]) - 1\n    if dim > len(syms):\n        raise ValueError('Must provide at least %d symbols for the polynomial' % dim)\n    (V, tmp_syms, terms) = vandermonde(order, dim)\n    if num_pts < V.shape[0]:\n        raise ValueError('Must provide %d points for order %d, dimension %d polynomial, given %d points' % (V.shape[0], order, dim, num_pts))\n    elif num_pts > V.shape[0]:\n        print('gen_poly given %d points but only requires %d, continuing using the first %d points' % (num_pts, V.shape[0], V.shape[0]))\n        num_pts = V.shape[0]\n    subs_dict = {}\n    for j in range(dim):\n        for i in range(num_pts):\n            subs_dict[tmp_syms[i][j]] = points[i][j]\n    V_pts = V.subs(subs_dict)\n    V_inv = V_pts.inv()\n    coeffs = V_inv.multiply(Matrix([points[i][-1] for i in range(num_pts)]))\n    f = 0\n    for (j, term) in enumerate(terms):\n        t = 1\n        for k in term:\n            t *= syms[k]\n        f += coeffs[j] * t\n    return f",
            "def gen_poly(points, order, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates a polynomial using a Vandermonde system'\n    num_pts = len(points)\n    if num_pts == 0:\n        raise ValueError('Must provide points')\n    dim = len(points[0]) - 1\n    if dim > len(syms):\n        raise ValueError('Must provide at least %d symbols for the polynomial' % dim)\n    (V, tmp_syms, terms) = vandermonde(order, dim)\n    if num_pts < V.shape[0]:\n        raise ValueError('Must provide %d points for order %d, dimension %d polynomial, given %d points' % (V.shape[0], order, dim, num_pts))\n    elif num_pts > V.shape[0]:\n        print('gen_poly given %d points but only requires %d, continuing using the first %d points' % (num_pts, V.shape[0], V.shape[0]))\n        num_pts = V.shape[0]\n    subs_dict = {}\n    for j in range(dim):\n        for i in range(num_pts):\n            subs_dict[tmp_syms[i][j]] = points[i][j]\n    V_pts = V.subs(subs_dict)\n    V_inv = V_pts.inv()\n    coeffs = V_inv.multiply(Matrix([points[i][-1] for i in range(num_pts)]))\n    f = 0\n    for (j, term) in enumerate(terms):\n        t = 1\n        for k in term:\n            t *= syms[k]\n        f += coeffs[j] * t\n    return f",
            "def gen_poly(points, order, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates a polynomial using a Vandermonde system'\n    num_pts = len(points)\n    if num_pts == 0:\n        raise ValueError('Must provide points')\n    dim = len(points[0]) - 1\n    if dim > len(syms):\n        raise ValueError('Must provide at least %d symbols for the polynomial' % dim)\n    (V, tmp_syms, terms) = vandermonde(order, dim)\n    if num_pts < V.shape[0]:\n        raise ValueError('Must provide %d points for order %d, dimension %d polynomial, given %d points' % (V.shape[0], order, dim, num_pts))\n    elif num_pts > V.shape[0]:\n        print('gen_poly given %d points but only requires %d, continuing using the first %d points' % (num_pts, V.shape[0], V.shape[0]))\n        num_pts = V.shape[0]\n    subs_dict = {}\n    for j in range(dim):\n        for i in range(num_pts):\n            subs_dict[tmp_syms[i][j]] = points[i][j]\n    V_pts = V.subs(subs_dict)\n    V_inv = V_pts.inv()\n    coeffs = V_inv.multiply(Matrix([points[i][-1] for i in range(num_pts)]))\n    f = 0\n    for (j, term) in enumerate(terms):\n        t = 1\n        for k in term:\n            t *= syms[k]\n        f += coeffs[j] * t\n    return f",
            "def gen_poly(points, order, syms):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates a polynomial using a Vandermonde system'\n    num_pts = len(points)\n    if num_pts == 0:\n        raise ValueError('Must provide points')\n    dim = len(points[0]) - 1\n    if dim > len(syms):\n        raise ValueError('Must provide at least %d symbols for the polynomial' % dim)\n    (V, tmp_syms, terms) = vandermonde(order, dim)\n    if num_pts < V.shape[0]:\n        raise ValueError('Must provide %d points for order %d, dimension %d polynomial, given %d points' % (V.shape[0], order, dim, num_pts))\n    elif num_pts > V.shape[0]:\n        print('gen_poly given %d points but only requires %d, continuing using the first %d points' % (num_pts, V.shape[0], V.shape[0]))\n        num_pts = V.shape[0]\n    subs_dict = {}\n    for j in range(dim):\n        for i in range(num_pts):\n            subs_dict[tmp_syms[i][j]] = points[i][j]\n    V_pts = V.subs(subs_dict)\n    V_inv = V_pts.inv()\n    coeffs = V_inv.multiply(Matrix([points[i][-1] for i in range(num_pts)]))\n    f = 0\n    for (j, term) in enumerate(terms):\n        t = 1\n        for k in term:\n            t *= syms[k]\n        f += coeffs[j] * t\n    return f"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    order = 2\n    (V, tmp_syms, _) = vandermonde(order)\n    print('Vandermonde matrix of order 2 in 1 dimension')\n    pprint(V)\n    print('-' * 79)\n    print('Computing the determinant and comparing to \\\\sum_{0<i<j<=3}(a_j - a_i)')\n    det_sum = 1\n    for j in range(order + 1):\n        for i in range(j):\n            det_sum *= tmp_syms[j][0] - tmp_syms[i][0]\n    print('\\n    det(V) = {det}\\n    \\\\sum   = {sum}\\n           = {sum_expand}\\n    '.format(det=V.det(), sum=det_sum, sum_expand=det_sum.expand()))\n    print('-' * 79)\n    print('Polynomial fitting with a Vandermonde Matrix:')\n    (x, y, z) = symbols('x,y,z')\n    points = [(0, 3), (1, 2), (2, 3)]\n    print('\\n    Quadratic function, represented by 3 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x])))\n    points = [(0, 1, 1), (1, 0, 0), (1, 1, 0), (Rational(1, 2), 0, 0), (0, Rational(1, 2), 0), (Rational(1, 2), Rational(1, 2), 0)]\n    print('\\n    2D Quadratic function, represented by 6 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x, y])))\n    points = [(0, 1, 1, 1), (1, 1, 0, 0), (1, 0, 1, 0), (1, 1, 1, 1)]\n    print('\\n    3D linear function, represented by 4 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 1, [x, y, z])))",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    order = 2\n    (V, tmp_syms, _) = vandermonde(order)\n    print('Vandermonde matrix of order 2 in 1 dimension')\n    pprint(V)\n    print('-' * 79)\n    print('Computing the determinant and comparing to \\\\sum_{0<i<j<=3}(a_j - a_i)')\n    det_sum = 1\n    for j in range(order + 1):\n        for i in range(j):\n            det_sum *= tmp_syms[j][0] - tmp_syms[i][0]\n    print('\\n    det(V) = {det}\\n    \\\\sum   = {sum}\\n           = {sum_expand}\\n    '.format(det=V.det(), sum=det_sum, sum_expand=det_sum.expand()))\n    print('-' * 79)\n    print('Polynomial fitting with a Vandermonde Matrix:')\n    (x, y, z) = symbols('x,y,z')\n    points = [(0, 3), (1, 2), (2, 3)]\n    print('\\n    Quadratic function, represented by 3 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x])))\n    points = [(0, 1, 1), (1, 0, 0), (1, 1, 0), (Rational(1, 2), 0, 0), (0, Rational(1, 2), 0), (Rational(1, 2), Rational(1, 2), 0)]\n    print('\\n    2D Quadratic function, represented by 6 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x, y])))\n    points = [(0, 1, 1, 1), (1, 1, 0, 0), (1, 0, 1, 0), (1, 1, 1, 1)]\n    print('\\n    3D linear function, represented by 4 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 1, [x, y, z])))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    order = 2\n    (V, tmp_syms, _) = vandermonde(order)\n    print('Vandermonde matrix of order 2 in 1 dimension')\n    pprint(V)\n    print('-' * 79)\n    print('Computing the determinant and comparing to \\\\sum_{0<i<j<=3}(a_j - a_i)')\n    det_sum = 1\n    for j in range(order + 1):\n        for i in range(j):\n            det_sum *= tmp_syms[j][0] - tmp_syms[i][0]\n    print('\\n    det(V) = {det}\\n    \\\\sum   = {sum}\\n           = {sum_expand}\\n    '.format(det=V.det(), sum=det_sum, sum_expand=det_sum.expand()))\n    print('-' * 79)\n    print('Polynomial fitting with a Vandermonde Matrix:')\n    (x, y, z) = symbols('x,y,z')\n    points = [(0, 3), (1, 2), (2, 3)]\n    print('\\n    Quadratic function, represented by 3 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x])))\n    points = [(0, 1, 1), (1, 0, 0), (1, 1, 0), (Rational(1, 2), 0, 0), (0, Rational(1, 2), 0), (Rational(1, 2), Rational(1, 2), 0)]\n    print('\\n    2D Quadratic function, represented by 6 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x, y])))\n    points = [(0, 1, 1, 1), (1, 1, 0, 0), (1, 0, 1, 0), (1, 1, 1, 1)]\n    print('\\n    3D linear function, represented by 4 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 1, [x, y, z])))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    order = 2\n    (V, tmp_syms, _) = vandermonde(order)\n    print('Vandermonde matrix of order 2 in 1 dimension')\n    pprint(V)\n    print('-' * 79)\n    print('Computing the determinant and comparing to \\\\sum_{0<i<j<=3}(a_j - a_i)')\n    det_sum = 1\n    for j in range(order + 1):\n        for i in range(j):\n            det_sum *= tmp_syms[j][0] - tmp_syms[i][0]\n    print('\\n    det(V) = {det}\\n    \\\\sum   = {sum}\\n           = {sum_expand}\\n    '.format(det=V.det(), sum=det_sum, sum_expand=det_sum.expand()))\n    print('-' * 79)\n    print('Polynomial fitting with a Vandermonde Matrix:')\n    (x, y, z) = symbols('x,y,z')\n    points = [(0, 3), (1, 2), (2, 3)]\n    print('\\n    Quadratic function, represented by 3 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x])))\n    points = [(0, 1, 1), (1, 0, 0), (1, 1, 0), (Rational(1, 2), 0, 0), (0, Rational(1, 2), 0), (Rational(1, 2), Rational(1, 2), 0)]\n    print('\\n    2D Quadratic function, represented by 6 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x, y])))\n    points = [(0, 1, 1, 1), (1, 1, 0, 0), (1, 0, 1, 0), (1, 1, 1, 1)]\n    print('\\n    3D linear function, represented by 4 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 1, [x, y, z])))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    order = 2\n    (V, tmp_syms, _) = vandermonde(order)\n    print('Vandermonde matrix of order 2 in 1 dimension')\n    pprint(V)\n    print('-' * 79)\n    print('Computing the determinant and comparing to \\\\sum_{0<i<j<=3}(a_j - a_i)')\n    det_sum = 1\n    for j in range(order + 1):\n        for i in range(j):\n            det_sum *= tmp_syms[j][0] - tmp_syms[i][0]\n    print('\\n    det(V) = {det}\\n    \\\\sum   = {sum}\\n           = {sum_expand}\\n    '.format(det=V.det(), sum=det_sum, sum_expand=det_sum.expand()))\n    print('-' * 79)\n    print('Polynomial fitting with a Vandermonde Matrix:')\n    (x, y, z) = symbols('x,y,z')\n    points = [(0, 3), (1, 2), (2, 3)]\n    print('\\n    Quadratic function, represented by 3 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x])))\n    points = [(0, 1, 1), (1, 0, 0), (1, 1, 0), (Rational(1, 2), 0, 0), (0, Rational(1, 2), 0), (Rational(1, 2), Rational(1, 2), 0)]\n    print('\\n    2D Quadratic function, represented by 6 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x, y])))\n    points = [(0, 1, 1, 1), (1, 1, 0, 0), (1, 0, 1, 0), (1, 1, 1, 1)]\n    print('\\n    3D linear function, represented by 4 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 1, [x, y, z])))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    order = 2\n    (V, tmp_syms, _) = vandermonde(order)\n    print('Vandermonde matrix of order 2 in 1 dimension')\n    pprint(V)\n    print('-' * 79)\n    print('Computing the determinant and comparing to \\\\sum_{0<i<j<=3}(a_j - a_i)')\n    det_sum = 1\n    for j in range(order + 1):\n        for i in range(j):\n            det_sum *= tmp_syms[j][0] - tmp_syms[i][0]\n    print('\\n    det(V) = {det}\\n    \\\\sum   = {sum}\\n           = {sum_expand}\\n    '.format(det=V.det(), sum=det_sum, sum_expand=det_sum.expand()))\n    print('-' * 79)\n    print('Polynomial fitting with a Vandermonde Matrix:')\n    (x, y, z) = symbols('x,y,z')\n    points = [(0, 3), (1, 2), (2, 3)]\n    print('\\n    Quadratic function, represented by 3 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x])))\n    points = [(0, 1, 1), (1, 0, 0), (1, 1, 0), (Rational(1, 2), 0, 0), (0, Rational(1, 2), 0), (Rational(1, 2), Rational(1, 2), 0)]\n    print('\\n    2D Quadratic function, represented by 6 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 2, [x, y])))\n    points = [(0, 1, 1, 1), (1, 1, 0, 0), (1, 0, 1, 0), (1, 1, 1, 1)]\n    print('\\n    3D linear function, represented by 4 points:\\n       points = {pts}\\n       f = {f}\\n    '.format(pts=points, f=gen_poly(points, 1, [x, y, z])))"
        ]
    }
]