[
    {
        "func_name": "row_splits_to_segment_ids",
        "original": "@tf_export('ragged.row_splits_to_segment_ids')\n@dispatch.add_dispatch_support\ndef row_splits_to_segment_ids(splits, name=None, out_type=None):\n    \"\"\"Generates the segmentation corresponding to a RaggedTensor `row_splits`.\n\n  Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if\n  `splits[j] <= i < splits[j+1]`.  Example:\n\n  >>> print(tf.ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]))\n   tf.Tensor([0 0 0 2 2 3 4 4 4], shape=(9,), dtype=int64)\n\n  Args:\n    splits: A sorted 1-D integer Tensor.  `splits[0]` must be zero.\n    name: A name prefix for the returned tensor (optional).\n    out_type: The dtype for the return value.  Defaults to `splits.dtype`,\n      or `tf.int64` if `splits` does not have a dtype.\n\n  Returns:\n    A sorted 1-D integer Tensor, with `shape=[splits[-1]]`\n\n  Raises:\n    ValueError: If `splits` is invalid.\n  \"\"\"\n    with ops.name_scope(name, 'RaggedSplitsToSegmentIds', [splits]) as name:\n        splits = ops.convert_to_tensor(splits, name='splits', preferred_dtype=dtypes.int64)\n        if splits.dtype not in (dtypes.int32, dtypes.int64):\n            raise ValueError('splits must have dtype int32 or int64')\n        splits.shape.assert_has_rank(1)\n        if tensor_shape.dimension_value(splits.shape[0]) == 0:\n            raise ValueError('Invalid row_splits: []')\n        if out_type is None:\n            out_type = splits.dtype\n        else:\n            out_type = dtypes.as_dtype(out_type)\n        row_lengths = splits[1:] - splits[:-1]\n        nrows = array_ops.shape(splits, out_type=out_type)[-1] - 1\n        indices = math_ops.range(nrows)\n        return ragged_util.repeat(indices, repeats=row_lengths, axis=0)",
        "mutated": [
            "@tf_export('ragged.row_splits_to_segment_ids')\n@dispatch.add_dispatch_support\ndef row_splits_to_segment_ids(splits, name=None, out_type=None):\n    if False:\n        i = 10\n    'Generates the segmentation corresponding to a RaggedTensor `row_splits`.\\n\\n  Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if\\n  `splits[j] <= i < splits[j+1]`.  Example:\\n\\n  >>> print(tf.ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]))\\n   tf.Tensor([0 0 0 2 2 3 4 4 4], shape=(9,), dtype=int64)\\n\\n  Args:\\n    splits: A sorted 1-D integer Tensor.  `splits[0]` must be zero.\\n    name: A name prefix for the returned tensor (optional).\\n    out_type: The dtype for the return value.  Defaults to `splits.dtype`,\\n      or `tf.int64` if `splits` does not have a dtype.\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[splits[-1]]`\\n\\n  Raises:\\n    ValueError: If `splits` is invalid.\\n  '\n    with ops.name_scope(name, 'RaggedSplitsToSegmentIds', [splits]) as name:\n        splits = ops.convert_to_tensor(splits, name='splits', preferred_dtype=dtypes.int64)\n        if splits.dtype not in (dtypes.int32, dtypes.int64):\n            raise ValueError('splits must have dtype int32 or int64')\n        splits.shape.assert_has_rank(1)\n        if tensor_shape.dimension_value(splits.shape[0]) == 0:\n            raise ValueError('Invalid row_splits: []')\n        if out_type is None:\n            out_type = splits.dtype\n        else:\n            out_type = dtypes.as_dtype(out_type)\n        row_lengths = splits[1:] - splits[:-1]\n        nrows = array_ops.shape(splits, out_type=out_type)[-1] - 1\n        indices = math_ops.range(nrows)\n        return ragged_util.repeat(indices, repeats=row_lengths, axis=0)",
            "@tf_export('ragged.row_splits_to_segment_ids')\n@dispatch.add_dispatch_support\ndef row_splits_to_segment_ids(splits, name=None, out_type=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates the segmentation corresponding to a RaggedTensor `row_splits`.\\n\\n  Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if\\n  `splits[j] <= i < splits[j+1]`.  Example:\\n\\n  >>> print(tf.ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]))\\n   tf.Tensor([0 0 0 2 2 3 4 4 4], shape=(9,), dtype=int64)\\n\\n  Args:\\n    splits: A sorted 1-D integer Tensor.  `splits[0]` must be zero.\\n    name: A name prefix for the returned tensor (optional).\\n    out_type: The dtype for the return value.  Defaults to `splits.dtype`,\\n      or `tf.int64` if `splits` does not have a dtype.\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[splits[-1]]`\\n\\n  Raises:\\n    ValueError: If `splits` is invalid.\\n  '\n    with ops.name_scope(name, 'RaggedSplitsToSegmentIds', [splits]) as name:\n        splits = ops.convert_to_tensor(splits, name='splits', preferred_dtype=dtypes.int64)\n        if splits.dtype not in (dtypes.int32, dtypes.int64):\n            raise ValueError('splits must have dtype int32 or int64')\n        splits.shape.assert_has_rank(1)\n        if tensor_shape.dimension_value(splits.shape[0]) == 0:\n            raise ValueError('Invalid row_splits: []')\n        if out_type is None:\n            out_type = splits.dtype\n        else:\n            out_type = dtypes.as_dtype(out_type)\n        row_lengths = splits[1:] - splits[:-1]\n        nrows = array_ops.shape(splits, out_type=out_type)[-1] - 1\n        indices = math_ops.range(nrows)\n        return ragged_util.repeat(indices, repeats=row_lengths, axis=0)",
            "@tf_export('ragged.row_splits_to_segment_ids')\n@dispatch.add_dispatch_support\ndef row_splits_to_segment_ids(splits, name=None, out_type=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates the segmentation corresponding to a RaggedTensor `row_splits`.\\n\\n  Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if\\n  `splits[j] <= i < splits[j+1]`.  Example:\\n\\n  >>> print(tf.ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]))\\n   tf.Tensor([0 0 0 2 2 3 4 4 4], shape=(9,), dtype=int64)\\n\\n  Args:\\n    splits: A sorted 1-D integer Tensor.  `splits[0]` must be zero.\\n    name: A name prefix for the returned tensor (optional).\\n    out_type: The dtype for the return value.  Defaults to `splits.dtype`,\\n      or `tf.int64` if `splits` does not have a dtype.\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[splits[-1]]`\\n\\n  Raises:\\n    ValueError: If `splits` is invalid.\\n  '\n    with ops.name_scope(name, 'RaggedSplitsToSegmentIds', [splits]) as name:\n        splits = ops.convert_to_tensor(splits, name='splits', preferred_dtype=dtypes.int64)\n        if splits.dtype not in (dtypes.int32, dtypes.int64):\n            raise ValueError('splits must have dtype int32 or int64')\n        splits.shape.assert_has_rank(1)\n        if tensor_shape.dimension_value(splits.shape[0]) == 0:\n            raise ValueError('Invalid row_splits: []')\n        if out_type is None:\n            out_type = splits.dtype\n        else:\n            out_type = dtypes.as_dtype(out_type)\n        row_lengths = splits[1:] - splits[:-1]\n        nrows = array_ops.shape(splits, out_type=out_type)[-1] - 1\n        indices = math_ops.range(nrows)\n        return ragged_util.repeat(indices, repeats=row_lengths, axis=0)",
            "@tf_export('ragged.row_splits_to_segment_ids')\n@dispatch.add_dispatch_support\ndef row_splits_to_segment_ids(splits, name=None, out_type=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates the segmentation corresponding to a RaggedTensor `row_splits`.\\n\\n  Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if\\n  `splits[j] <= i < splits[j+1]`.  Example:\\n\\n  >>> print(tf.ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]))\\n   tf.Tensor([0 0 0 2 2 3 4 4 4], shape=(9,), dtype=int64)\\n\\n  Args:\\n    splits: A sorted 1-D integer Tensor.  `splits[0]` must be zero.\\n    name: A name prefix for the returned tensor (optional).\\n    out_type: The dtype for the return value.  Defaults to `splits.dtype`,\\n      or `tf.int64` if `splits` does not have a dtype.\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[splits[-1]]`\\n\\n  Raises:\\n    ValueError: If `splits` is invalid.\\n  '\n    with ops.name_scope(name, 'RaggedSplitsToSegmentIds', [splits]) as name:\n        splits = ops.convert_to_tensor(splits, name='splits', preferred_dtype=dtypes.int64)\n        if splits.dtype not in (dtypes.int32, dtypes.int64):\n            raise ValueError('splits must have dtype int32 or int64')\n        splits.shape.assert_has_rank(1)\n        if tensor_shape.dimension_value(splits.shape[0]) == 0:\n            raise ValueError('Invalid row_splits: []')\n        if out_type is None:\n            out_type = splits.dtype\n        else:\n            out_type = dtypes.as_dtype(out_type)\n        row_lengths = splits[1:] - splits[:-1]\n        nrows = array_ops.shape(splits, out_type=out_type)[-1] - 1\n        indices = math_ops.range(nrows)\n        return ragged_util.repeat(indices, repeats=row_lengths, axis=0)",
            "@tf_export('ragged.row_splits_to_segment_ids')\n@dispatch.add_dispatch_support\ndef row_splits_to_segment_ids(splits, name=None, out_type=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates the segmentation corresponding to a RaggedTensor `row_splits`.\\n\\n  Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if\\n  `splits[j] <= i < splits[j+1]`.  Example:\\n\\n  >>> print(tf.ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]))\\n   tf.Tensor([0 0 0 2 2 3 4 4 4], shape=(9,), dtype=int64)\\n\\n  Args:\\n    splits: A sorted 1-D integer Tensor.  `splits[0]` must be zero.\\n    name: A name prefix for the returned tensor (optional).\\n    out_type: The dtype for the return value.  Defaults to `splits.dtype`,\\n      or `tf.int64` if `splits` does not have a dtype.\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[splits[-1]]`\\n\\n  Raises:\\n    ValueError: If `splits` is invalid.\\n  '\n    with ops.name_scope(name, 'RaggedSplitsToSegmentIds', [splits]) as name:\n        splits = ops.convert_to_tensor(splits, name='splits', preferred_dtype=dtypes.int64)\n        if splits.dtype not in (dtypes.int32, dtypes.int64):\n            raise ValueError('splits must have dtype int32 or int64')\n        splits.shape.assert_has_rank(1)\n        if tensor_shape.dimension_value(splits.shape[0]) == 0:\n            raise ValueError('Invalid row_splits: []')\n        if out_type is None:\n            out_type = splits.dtype\n        else:\n            out_type = dtypes.as_dtype(out_type)\n        row_lengths = splits[1:] - splits[:-1]\n        nrows = array_ops.shape(splits, out_type=out_type)[-1] - 1\n        indices = math_ops.range(nrows)\n        return ragged_util.repeat(indices, repeats=row_lengths, axis=0)"
        ]
    },
    {
        "func_name": "segment_ids_to_row_splits",
        "original": "@tf_export('ragged.segment_ids_to_row_splits')\n@dispatch.add_dispatch_support\ndef segment_ids_to_row_splits(segment_ids, num_segments=None, out_type=None, name=None):\n    \"\"\"Generates the RaggedTensor `row_splits` corresponding to a segmentation.\n\n  Returns an integer vector `splits`, where `splits[0] = 0` and\n  `splits[i] = splits[i-1] + count(segment_ids==i)`.  Example:\n\n  >>> print(tf.ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]))\n  tf.Tensor([0 3 3 5 6 9], shape=(6,), dtype=int64)\n\n  Args:\n    segment_ids: A 1-D integer Tensor.\n    num_segments: A scalar integer indicating the number of segments.  Defaults\n      to `max(segment_ids) + 1` (or zero if `segment_ids` is empty).\n    out_type: The dtype for the return value.  Defaults to `segment_ids.dtype`,\n      or `tf.int64` if `segment_ids` does not have a dtype.\n    name: A name prefix for the returned tensor (optional).\n\n  Returns:\n    A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`.\n  \"\"\"\n    from tensorflow.python.ops import bincount_ops\n    if out_type is None:\n        if isinstance(segment_ids, tensor.Tensor):\n            out_type = segment_ids.dtype\n        elif isinstance(num_segments, tensor.Tensor):\n            out_type = num_segments.dtype\n        else:\n            out_type = dtypes.int64\n    else:\n        out_type = dtypes.as_dtype(out_type)\n    with ops.name_scope(name, 'SegmentIdsToRaggedSplits', [segment_ids]) as name:\n        segment_ids = ragged_util.convert_to_int_tensor(segment_ids, 'segment_ids', dtype=dtypes.int32)\n        segment_ids.shape.assert_has_rank(1)\n        if num_segments is not None:\n            num_segments = ragged_util.convert_to_int_tensor(num_segments, 'num_segments', dtype=dtypes.int32)\n            num_segments.shape.assert_has_rank(0)\n        row_lengths = bincount_ops.bincount(segment_ids, minlength=num_segments, maxlength=num_segments, dtype=out_type)\n        splits = array_ops.concat([[0], math_ops.cumsum(row_lengths)], axis=0)\n        if num_segments is not None:\n            const_num_segments = tensor_util.constant_value(num_segments)\n            if const_num_segments is not None:\n                splits.set_shape(tensor_shape.TensorShape([const_num_segments + 1]))\n        return splits",
        "mutated": [
            "@tf_export('ragged.segment_ids_to_row_splits')\n@dispatch.add_dispatch_support\ndef segment_ids_to_row_splits(segment_ids, num_segments=None, out_type=None, name=None):\n    if False:\n        i = 10\n    'Generates the RaggedTensor `row_splits` corresponding to a segmentation.\\n\\n  Returns an integer vector `splits`, where `splits[0] = 0` and\\n  `splits[i] = splits[i-1] + count(segment_ids==i)`.  Example:\\n\\n  >>> print(tf.ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]))\\n  tf.Tensor([0 3 3 5 6 9], shape=(6,), dtype=int64)\\n\\n  Args:\\n    segment_ids: A 1-D integer Tensor.\\n    num_segments: A scalar integer indicating the number of segments.  Defaults\\n      to `max(segment_ids) + 1` (or zero if `segment_ids` is empty).\\n    out_type: The dtype for the return value.  Defaults to `segment_ids.dtype`,\\n      or `tf.int64` if `segment_ids` does not have a dtype.\\n    name: A name prefix for the returned tensor (optional).\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`.\\n  '\n    from tensorflow.python.ops import bincount_ops\n    if out_type is None:\n        if isinstance(segment_ids, tensor.Tensor):\n            out_type = segment_ids.dtype\n        elif isinstance(num_segments, tensor.Tensor):\n            out_type = num_segments.dtype\n        else:\n            out_type = dtypes.int64\n    else:\n        out_type = dtypes.as_dtype(out_type)\n    with ops.name_scope(name, 'SegmentIdsToRaggedSplits', [segment_ids]) as name:\n        segment_ids = ragged_util.convert_to_int_tensor(segment_ids, 'segment_ids', dtype=dtypes.int32)\n        segment_ids.shape.assert_has_rank(1)\n        if num_segments is not None:\n            num_segments = ragged_util.convert_to_int_tensor(num_segments, 'num_segments', dtype=dtypes.int32)\n            num_segments.shape.assert_has_rank(0)\n        row_lengths = bincount_ops.bincount(segment_ids, minlength=num_segments, maxlength=num_segments, dtype=out_type)\n        splits = array_ops.concat([[0], math_ops.cumsum(row_lengths)], axis=0)\n        if num_segments is not None:\n            const_num_segments = tensor_util.constant_value(num_segments)\n            if const_num_segments is not None:\n                splits.set_shape(tensor_shape.TensorShape([const_num_segments + 1]))\n        return splits",
            "@tf_export('ragged.segment_ids_to_row_splits')\n@dispatch.add_dispatch_support\ndef segment_ids_to_row_splits(segment_ids, num_segments=None, out_type=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates the RaggedTensor `row_splits` corresponding to a segmentation.\\n\\n  Returns an integer vector `splits`, where `splits[0] = 0` and\\n  `splits[i] = splits[i-1] + count(segment_ids==i)`.  Example:\\n\\n  >>> print(tf.ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]))\\n  tf.Tensor([0 3 3 5 6 9], shape=(6,), dtype=int64)\\n\\n  Args:\\n    segment_ids: A 1-D integer Tensor.\\n    num_segments: A scalar integer indicating the number of segments.  Defaults\\n      to `max(segment_ids) + 1` (or zero if `segment_ids` is empty).\\n    out_type: The dtype for the return value.  Defaults to `segment_ids.dtype`,\\n      or `tf.int64` if `segment_ids` does not have a dtype.\\n    name: A name prefix for the returned tensor (optional).\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`.\\n  '\n    from tensorflow.python.ops import bincount_ops\n    if out_type is None:\n        if isinstance(segment_ids, tensor.Tensor):\n            out_type = segment_ids.dtype\n        elif isinstance(num_segments, tensor.Tensor):\n            out_type = num_segments.dtype\n        else:\n            out_type = dtypes.int64\n    else:\n        out_type = dtypes.as_dtype(out_type)\n    with ops.name_scope(name, 'SegmentIdsToRaggedSplits', [segment_ids]) as name:\n        segment_ids = ragged_util.convert_to_int_tensor(segment_ids, 'segment_ids', dtype=dtypes.int32)\n        segment_ids.shape.assert_has_rank(1)\n        if num_segments is not None:\n            num_segments = ragged_util.convert_to_int_tensor(num_segments, 'num_segments', dtype=dtypes.int32)\n            num_segments.shape.assert_has_rank(0)\n        row_lengths = bincount_ops.bincount(segment_ids, minlength=num_segments, maxlength=num_segments, dtype=out_type)\n        splits = array_ops.concat([[0], math_ops.cumsum(row_lengths)], axis=0)\n        if num_segments is not None:\n            const_num_segments = tensor_util.constant_value(num_segments)\n            if const_num_segments is not None:\n                splits.set_shape(tensor_shape.TensorShape([const_num_segments + 1]))\n        return splits",
            "@tf_export('ragged.segment_ids_to_row_splits')\n@dispatch.add_dispatch_support\ndef segment_ids_to_row_splits(segment_ids, num_segments=None, out_type=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates the RaggedTensor `row_splits` corresponding to a segmentation.\\n\\n  Returns an integer vector `splits`, where `splits[0] = 0` and\\n  `splits[i] = splits[i-1] + count(segment_ids==i)`.  Example:\\n\\n  >>> print(tf.ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]))\\n  tf.Tensor([0 3 3 5 6 9], shape=(6,), dtype=int64)\\n\\n  Args:\\n    segment_ids: A 1-D integer Tensor.\\n    num_segments: A scalar integer indicating the number of segments.  Defaults\\n      to `max(segment_ids) + 1` (or zero if `segment_ids` is empty).\\n    out_type: The dtype for the return value.  Defaults to `segment_ids.dtype`,\\n      or `tf.int64` if `segment_ids` does not have a dtype.\\n    name: A name prefix for the returned tensor (optional).\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`.\\n  '\n    from tensorflow.python.ops import bincount_ops\n    if out_type is None:\n        if isinstance(segment_ids, tensor.Tensor):\n            out_type = segment_ids.dtype\n        elif isinstance(num_segments, tensor.Tensor):\n            out_type = num_segments.dtype\n        else:\n            out_type = dtypes.int64\n    else:\n        out_type = dtypes.as_dtype(out_type)\n    with ops.name_scope(name, 'SegmentIdsToRaggedSplits', [segment_ids]) as name:\n        segment_ids = ragged_util.convert_to_int_tensor(segment_ids, 'segment_ids', dtype=dtypes.int32)\n        segment_ids.shape.assert_has_rank(1)\n        if num_segments is not None:\n            num_segments = ragged_util.convert_to_int_tensor(num_segments, 'num_segments', dtype=dtypes.int32)\n            num_segments.shape.assert_has_rank(0)\n        row_lengths = bincount_ops.bincount(segment_ids, minlength=num_segments, maxlength=num_segments, dtype=out_type)\n        splits = array_ops.concat([[0], math_ops.cumsum(row_lengths)], axis=0)\n        if num_segments is not None:\n            const_num_segments = tensor_util.constant_value(num_segments)\n            if const_num_segments is not None:\n                splits.set_shape(tensor_shape.TensorShape([const_num_segments + 1]))\n        return splits",
            "@tf_export('ragged.segment_ids_to_row_splits')\n@dispatch.add_dispatch_support\ndef segment_ids_to_row_splits(segment_ids, num_segments=None, out_type=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates the RaggedTensor `row_splits` corresponding to a segmentation.\\n\\n  Returns an integer vector `splits`, where `splits[0] = 0` and\\n  `splits[i] = splits[i-1] + count(segment_ids==i)`.  Example:\\n\\n  >>> print(tf.ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]))\\n  tf.Tensor([0 3 3 5 6 9], shape=(6,), dtype=int64)\\n\\n  Args:\\n    segment_ids: A 1-D integer Tensor.\\n    num_segments: A scalar integer indicating the number of segments.  Defaults\\n      to `max(segment_ids) + 1` (or zero if `segment_ids` is empty).\\n    out_type: The dtype for the return value.  Defaults to `segment_ids.dtype`,\\n      or `tf.int64` if `segment_ids` does not have a dtype.\\n    name: A name prefix for the returned tensor (optional).\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`.\\n  '\n    from tensorflow.python.ops import bincount_ops\n    if out_type is None:\n        if isinstance(segment_ids, tensor.Tensor):\n            out_type = segment_ids.dtype\n        elif isinstance(num_segments, tensor.Tensor):\n            out_type = num_segments.dtype\n        else:\n            out_type = dtypes.int64\n    else:\n        out_type = dtypes.as_dtype(out_type)\n    with ops.name_scope(name, 'SegmentIdsToRaggedSplits', [segment_ids]) as name:\n        segment_ids = ragged_util.convert_to_int_tensor(segment_ids, 'segment_ids', dtype=dtypes.int32)\n        segment_ids.shape.assert_has_rank(1)\n        if num_segments is not None:\n            num_segments = ragged_util.convert_to_int_tensor(num_segments, 'num_segments', dtype=dtypes.int32)\n            num_segments.shape.assert_has_rank(0)\n        row_lengths = bincount_ops.bincount(segment_ids, minlength=num_segments, maxlength=num_segments, dtype=out_type)\n        splits = array_ops.concat([[0], math_ops.cumsum(row_lengths)], axis=0)\n        if num_segments is not None:\n            const_num_segments = tensor_util.constant_value(num_segments)\n            if const_num_segments is not None:\n                splits.set_shape(tensor_shape.TensorShape([const_num_segments + 1]))\n        return splits",
            "@tf_export('ragged.segment_ids_to_row_splits')\n@dispatch.add_dispatch_support\ndef segment_ids_to_row_splits(segment_ids, num_segments=None, out_type=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates the RaggedTensor `row_splits` corresponding to a segmentation.\\n\\n  Returns an integer vector `splits`, where `splits[0] = 0` and\\n  `splits[i] = splits[i-1] + count(segment_ids==i)`.  Example:\\n\\n  >>> print(tf.ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]))\\n  tf.Tensor([0 3 3 5 6 9], shape=(6,), dtype=int64)\\n\\n  Args:\\n    segment_ids: A 1-D integer Tensor.\\n    num_segments: A scalar integer indicating the number of segments.  Defaults\\n      to `max(segment_ids) + 1` (or zero if `segment_ids` is empty).\\n    out_type: The dtype for the return value.  Defaults to `segment_ids.dtype`,\\n      or `tf.int64` if `segment_ids` does not have a dtype.\\n    name: A name prefix for the returned tensor (optional).\\n\\n  Returns:\\n    A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`.\\n  '\n    from tensorflow.python.ops import bincount_ops\n    if out_type is None:\n        if isinstance(segment_ids, tensor.Tensor):\n            out_type = segment_ids.dtype\n        elif isinstance(num_segments, tensor.Tensor):\n            out_type = num_segments.dtype\n        else:\n            out_type = dtypes.int64\n    else:\n        out_type = dtypes.as_dtype(out_type)\n    with ops.name_scope(name, 'SegmentIdsToRaggedSplits', [segment_ids]) as name:\n        segment_ids = ragged_util.convert_to_int_tensor(segment_ids, 'segment_ids', dtype=dtypes.int32)\n        segment_ids.shape.assert_has_rank(1)\n        if num_segments is not None:\n            num_segments = ragged_util.convert_to_int_tensor(num_segments, 'num_segments', dtype=dtypes.int32)\n            num_segments.shape.assert_has_rank(0)\n        row_lengths = bincount_ops.bincount(segment_ids, minlength=num_segments, maxlength=num_segments, dtype=out_type)\n        splits = array_ops.concat([[0], math_ops.cumsum(row_lengths)], axis=0)\n        if num_segments is not None:\n            const_num_segments = tensor_util.constant_value(num_segments)\n            if const_num_segments is not None:\n                splits.set_shape(tensor_shape.TensorShape([const_num_segments + 1]))\n        return splits"
        ]
    }
]