[
    {
        "func_name": "get_target_type",
        "original": "def get_target_type(tvar: TypeVarLikeType, type: Type, callable: CallableType, report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool) -> Type | None:\n    p_type = get_proper_type(type)\n    if isinstance(p_type, UninhabitedType) and tvar.has_default():\n        return tvar.default\n    if isinstance(tvar, ParamSpecType):\n        return type\n    if isinstance(tvar, TypeVarTupleType):\n        return type\n    assert isinstance(tvar, TypeVarType)\n    values = tvar.values\n    if values:\n        if isinstance(p_type, AnyType):\n            return type\n        if isinstance(p_type, TypeVarType) and p_type.values:\n            if all((any((mypy.subtypes.is_same_type(v, v1) for v in values)) for v1 in p_type.values)):\n                return type\n        matching = []\n        for value in values:\n            if mypy.subtypes.is_subtype(type, value):\n                matching.append(value)\n        if matching:\n            best = matching[0]\n            for match in matching[1:]:\n                if mypy.subtypes.is_subtype(match, best):\n                    best = match\n            return best\n        if skip_unsatisfied:\n            return None\n        report_incompatible_typevar_value(callable, type, tvar.name, context)\n    else:\n        upper_bound = tvar.upper_bound\n        if tvar.name == 'Self':\n            upper_bound = erase_typevars(upper_bound)\n        if not mypy.subtypes.is_subtype(type, upper_bound):\n            if skip_unsatisfied:\n                return None\n            report_incompatible_typevar_value(callable, type, tvar.name, context)\n    return type",
        "mutated": [
            "def get_target_type(tvar: TypeVarLikeType, type: Type, callable: CallableType, report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool) -> Type | None:\n    if False:\n        i = 10\n    p_type = get_proper_type(type)\n    if isinstance(p_type, UninhabitedType) and tvar.has_default():\n        return tvar.default\n    if isinstance(tvar, ParamSpecType):\n        return type\n    if isinstance(tvar, TypeVarTupleType):\n        return type\n    assert isinstance(tvar, TypeVarType)\n    values = tvar.values\n    if values:\n        if isinstance(p_type, AnyType):\n            return type\n        if isinstance(p_type, TypeVarType) and p_type.values:\n            if all((any((mypy.subtypes.is_same_type(v, v1) for v in values)) for v1 in p_type.values)):\n                return type\n        matching = []\n        for value in values:\n            if mypy.subtypes.is_subtype(type, value):\n                matching.append(value)\n        if matching:\n            best = matching[0]\n            for match in matching[1:]:\n                if mypy.subtypes.is_subtype(match, best):\n                    best = match\n            return best\n        if skip_unsatisfied:\n            return None\n        report_incompatible_typevar_value(callable, type, tvar.name, context)\n    else:\n        upper_bound = tvar.upper_bound\n        if tvar.name == 'Self':\n            upper_bound = erase_typevars(upper_bound)\n        if not mypy.subtypes.is_subtype(type, upper_bound):\n            if skip_unsatisfied:\n                return None\n            report_incompatible_typevar_value(callable, type, tvar.name, context)\n    return type",
            "def get_target_type(tvar: TypeVarLikeType, type: Type, callable: CallableType, report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool) -> Type | None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    p_type = get_proper_type(type)\n    if isinstance(p_type, UninhabitedType) and tvar.has_default():\n        return tvar.default\n    if isinstance(tvar, ParamSpecType):\n        return type\n    if isinstance(tvar, TypeVarTupleType):\n        return type\n    assert isinstance(tvar, TypeVarType)\n    values = tvar.values\n    if values:\n        if isinstance(p_type, AnyType):\n            return type\n        if isinstance(p_type, TypeVarType) and p_type.values:\n            if all((any((mypy.subtypes.is_same_type(v, v1) for v in values)) for v1 in p_type.values)):\n                return type\n        matching = []\n        for value in values:\n            if mypy.subtypes.is_subtype(type, value):\n                matching.append(value)\n        if matching:\n            best = matching[0]\n            for match in matching[1:]:\n                if mypy.subtypes.is_subtype(match, best):\n                    best = match\n            return best\n        if skip_unsatisfied:\n            return None\n        report_incompatible_typevar_value(callable, type, tvar.name, context)\n    else:\n        upper_bound = tvar.upper_bound\n        if tvar.name == 'Self':\n            upper_bound = erase_typevars(upper_bound)\n        if not mypy.subtypes.is_subtype(type, upper_bound):\n            if skip_unsatisfied:\n                return None\n            report_incompatible_typevar_value(callable, type, tvar.name, context)\n    return type",
            "def get_target_type(tvar: TypeVarLikeType, type: Type, callable: CallableType, report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool) -> Type | None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    p_type = get_proper_type(type)\n    if isinstance(p_type, UninhabitedType) and tvar.has_default():\n        return tvar.default\n    if isinstance(tvar, ParamSpecType):\n        return type\n    if isinstance(tvar, TypeVarTupleType):\n        return type\n    assert isinstance(tvar, TypeVarType)\n    values = tvar.values\n    if values:\n        if isinstance(p_type, AnyType):\n            return type\n        if isinstance(p_type, TypeVarType) and p_type.values:\n            if all((any((mypy.subtypes.is_same_type(v, v1) for v in values)) for v1 in p_type.values)):\n                return type\n        matching = []\n        for value in values:\n            if mypy.subtypes.is_subtype(type, value):\n                matching.append(value)\n        if matching:\n            best = matching[0]\n            for match in matching[1:]:\n                if mypy.subtypes.is_subtype(match, best):\n                    best = match\n            return best\n        if skip_unsatisfied:\n            return None\n        report_incompatible_typevar_value(callable, type, tvar.name, context)\n    else:\n        upper_bound = tvar.upper_bound\n        if tvar.name == 'Self':\n            upper_bound = erase_typevars(upper_bound)\n        if not mypy.subtypes.is_subtype(type, upper_bound):\n            if skip_unsatisfied:\n                return None\n            report_incompatible_typevar_value(callable, type, tvar.name, context)\n    return type",
            "def get_target_type(tvar: TypeVarLikeType, type: Type, callable: CallableType, report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool) -> Type | None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    p_type = get_proper_type(type)\n    if isinstance(p_type, UninhabitedType) and tvar.has_default():\n        return tvar.default\n    if isinstance(tvar, ParamSpecType):\n        return type\n    if isinstance(tvar, TypeVarTupleType):\n        return type\n    assert isinstance(tvar, TypeVarType)\n    values = tvar.values\n    if values:\n        if isinstance(p_type, AnyType):\n            return type\n        if isinstance(p_type, TypeVarType) and p_type.values:\n            if all((any((mypy.subtypes.is_same_type(v, v1) for v in values)) for v1 in p_type.values)):\n                return type\n        matching = []\n        for value in values:\n            if mypy.subtypes.is_subtype(type, value):\n                matching.append(value)\n        if matching:\n            best = matching[0]\n            for match in matching[1:]:\n                if mypy.subtypes.is_subtype(match, best):\n                    best = match\n            return best\n        if skip_unsatisfied:\n            return None\n        report_incompatible_typevar_value(callable, type, tvar.name, context)\n    else:\n        upper_bound = tvar.upper_bound\n        if tvar.name == 'Self':\n            upper_bound = erase_typevars(upper_bound)\n        if not mypy.subtypes.is_subtype(type, upper_bound):\n            if skip_unsatisfied:\n                return None\n            report_incompatible_typevar_value(callable, type, tvar.name, context)\n    return type",
            "def get_target_type(tvar: TypeVarLikeType, type: Type, callable: CallableType, report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool) -> Type | None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    p_type = get_proper_type(type)\n    if isinstance(p_type, UninhabitedType) and tvar.has_default():\n        return tvar.default\n    if isinstance(tvar, ParamSpecType):\n        return type\n    if isinstance(tvar, TypeVarTupleType):\n        return type\n    assert isinstance(tvar, TypeVarType)\n    values = tvar.values\n    if values:\n        if isinstance(p_type, AnyType):\n            return type\n        if isinstance(p_type, TypeVarType) and p_type.values:\n            if all((any((mypy.subtypes.is_same_type(v, v1) for v in values)) for v1 in p_type.values)):\n                return type\n        matching = []\n        for value in values:\n            if mypy.subtypes.is_subtype(type, value):\n                matching.append(value)\n        if matching:\n            best = matching[0]\n            for match in matching[1:]:\n                if mypy.subtypes.is_subtype(match, best):\n                    best = match\n            return best\n        if skip_unsatisfied:\n            return None\n        report_incompatible_typevar_value(callable, type, tvar.name, context)\n    else:\n        upper_bound = tvar.upper_bound\n        if tvar.name == 'Self':\n            upper_bound = erase_typevars(upper_bound)\n        if not mypy.subtypes.is_subtype(type, upper_bound):\n            if skip_unsatisfied:\n                return None\n            report_incompatible_typevar_value(callable, type, tvar.name, context)\n    return type"
        ]
    },
    {
        "func_name": "apply_generic_arguments",
        "original": "def apply_generic_arguments(callable: CallableType, orig_types: Sequence[Type | None], report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool=False) -> CallableType:\n    \"\"\"Apply generic type arguments to a callable type.\n\n    For example, applying [int] to 'def [T] (T) -> T' results in\n    'def (int) -> int'.\n\n    Note that each type can be None; in this case, it will not be applied.\n\n    If `skip_unsatisfied` is True, then just skip the types that don't satisfy type variable\n    bound or constraints, instead of giving an error.\n    \"\"\"\n    tvars = callable.variables\n    assert len(tvars) == len(orig_types)\n    id_to_type: dict[TypeVarId, Type] = {}\n    for (tvar, type) in zip(tvars, orig_types):\n        assert not isinstance(type, PartialType), 'Internal error: must never apply partial type'\n        if type is None:\n            continue\n        target_type = get_target_type(tvar, type, callable, report_incompatible_typevar_value, context, skip_unsatisfied)\n        if target_type is not None:\n            id_to_type[tvar.id] = target_type\n    param_spec = callable.param_spec()\n    if param_spec is not None:\n        nt = id_to_type.get(param_spec.id)\n        if nt is not None:\n            callable = expand_type(callable, id_to_type)\n            assert isinstance(callable, CallableType)\n            return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    var_arg = callable.var_arg()\n    if var_arg is not None and isinstance(var_arg.typ, UnpackType):\n        callable = expand_type(callable, id_to_type)\n        assert isinstance(callable, CallableType)\n        return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    else:\n        callable = callable.copy_modified(arg_types=[expand_type(at, id_to_type) for at in callable.arg_types])\n    if callable.type_guard is not None:\n        type_guard = expand_type(callable.type_guard, id_to_type)\n    else:\n        type_guard = None\n    remaining_tvars = [tv for tv in tvars if tv.id not in id_to_type]\n    return callable.copy_modified(ret_type=expand_type(callable.ret_type, id_to_type), variables=remaining_tvars, type_guard=type_guard)",
        "mutated": [
            "def apply_generic_arguments(callable: CallableType, orig_types: Sequence[Type | None], report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool=False) -> CallableType:\n    if False:\n        i = 10\n    \"Apply generic type arguments to a callable type.\\n\\n    For example, applying [int] to 'def [T] (T) -> T' results in\\n    'def (int) -> int'.\\n\\n    Note that each type can be None; in this case, it will not be applied.\\n\\n    If `skip_unsatisfied` is True, then just skip the types that don't satisfy type variable\\n    bound or constraints, instead of giving an error.\\n    \"\n    tvars = callable.variables\n    assert len(tvars) == len(orig_types)\n    id_to_type: dict[TypeVarId, Type] = {}\n    for (tvar, type) in zip(tvars, orig_types):\n        assert not isinstance(type, PartialType), 'Internal error: must never apply partial type'\n        if type is None:\n            continue\n        target_type = get_target_type(tvar, type, callable, report_incompatible_typevar_value, context, skip_unsatisfied)\n        if target_type is not None:\n            id_to_type[tvar.id] = target_type\n    param_spec = callable.param_spec()\n    if param_spec is not None:\n        nt = id_to_type.get(param_spec.id)\n        if nt is not None:\n            callable = expand_type(callable, id_to_type)\n            assert isinstance(callable, CallableType)\n            return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    var_arg = callable.var_arg()\n    if var_arg is not None and isinstance(var_arg.typ, UnpackType):\n        callable = expand_type(callable, id_to_type)\n        assert isinstance(callable, CallableType)\n        return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    else:\n        callable = callable.copy_modified(arg_types=[expand_type(at, id_to_type) for at in callable.arg_types])\n    if callable.type_guard is not None:\n        type_guard = expand_type(callable.type_guard, id_to_type)\n    else:\n        type_guard = None\n    remaining_tvars = [tv for tv in tvars if tv.id not in id_to_type]\n    return callable.copy_modified(ret_type=expand_type(callable.ret_type, id_to_type), variables=remaining_tvars, type_guard=type_guard)",
            "def apply_generic_arguments(callable: CallableType, orig_types: Sequence[Type | None], report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool=False) -> CallableType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Apply generic type arguments to a callable type.\\n\\n    For example, applying [int] to 'def [T] (T) -> T' results in\\n    'def (int) -> int'.\\n\\n    Note that each type can be None; in this case, it will not be applied.\\n\\n    If `skip_unsatisfied` is True, then just skip the types that don't satisfy type variable\\n    bound or constraints, instead of giving an error.\\n    \"\n    tvars = callable.variables\n    assert len(tvars) == len(orig_types)\n    id_to_type: dict[TypeVarId, Type] = {}\n    for (tvar, type) in zip(tvars, orig_types):\n        assert not isinstance(type, PartialType), 'Internal error: must never apply partial type'\n        if type is None:\n            continue\n        target_type = get_target_type(tvar, type, callable, report_incompatible_typevar_value, context, skip_unsatisfied)\n        if target_type is not None:\n            id_to_type[tvar.id] = target_type\n    param_spec = callable.param_spec()\n    if param_spec is not None:\n        nt = id_to_type.get(param_spec.id)\n        if nt is not None:\n            callable = expand_type(callable, id_to_type)\n            assert isinstance(callable, CallableType)\n            return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    var_arg = callable.var_arg()\n    if var_arg is not None and isinstance(var_arg.typ, UnpackType):\n        callable = expand_type(callable, id_to_type)\n        assert isinstance(callable, CallableType)\n        return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    else:\n        callable = callable.copy_modified(arg_types=[expand_type(at, id_to_type) for at in callable.arg_types])\n    if callable.type_guard is not None:\n        type_guard = expand_type(callable.type_guard, id_to_type)\n    else:\n        type_guard = None\n    remaining_tvars = [tv for tv in tvars if tv.id not in id_to_type]\n    return callable.copy_modified(ret_type=expand_type(callable.ret_type, id_to_type), variables=remaining_tvars, type_guard=type_guard)",
            "def apply_generic_arguments(callable: CallableType, orig_types: Sequence[Type | None], report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool=False) -> CallableType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Apply generic type arguments to a callable type.\\n\\n    For example, applying [int] to 'def [T] (T) -> T' results in\\n    'def (int) -> int'.\\n\\n    Note that each type can be None; in this case, it will not be applied.\\n\\n    If `skip_unsatisfied` is True, then just skip the types that don't satisfy type variable\\n    bound or constraints, instead of giving an error.\\n    \"\n    tvars = callable.variables\n    assert len(tvars) == len(orig_types)\n    id_to_type: dict[TypeVarId, Type] = {}\n    for (tvar, type) in zip(tvars, orig_types):\n        assert not isinstance(type, PartialType), 'Internal error: must never apply partial type'\n        if type is None:\n            continue\n        target_type = get_target_type(tvar, type, callable, report_incompatible_typevar_value, context, skip_unsatisfied)\n        if target_type is not None:\n            id_to_type[tvar.id] = target_type\n    param_spec = callable.param_spec()\n    if param_spec is not None:\n        nt = id_to_type.get(param_spec.id)\n        if nt is not None:\n            callable = expand_type(callable, id_to_type)\n            assert isinstance(callable, CallableType)\n            return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    var_arg = callable.var_arg()\n    if var_arg is not None and isinstance(var_arg.typ, UnpackType):\n        callable = expand_type(callable, id_to_type)\n        assert isinstance(callable, CallableType)\n        return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    else:\n        callable = callable.copy_modified(arg_types=[expand_type(at, id_to_type) for at in callable.arg_types])\n    if callable.type_guard is not None:\n        type_guard = expand_type(callable.type_guard, id_to_type)\n    else:\n        type_guard = None\n    remaining_tvars = [tv for tv in tvars if tv.id not in id_to_type]\n    return callable.copy_modified(ret_type=expand_type(callable.ret_type, id_to_type), variables=remaining_tvars, type_guard=type_guard)",
            "def apply_generic_arguments(callable: CallableType, orig_types: Sequence[Type | None], report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool=False) -> CallableType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Apply generic type arguments to a callable type.\\n\\n    For example, applying [int] to 'def [T] (T) -> T' results in\\n    'def (int) -> int'.\\n\\n    Note that each type can be None; in this case, it will not be applied.\\n\\n    If `skip_unsatisfied` is True, then just skip the types that don't satisfy type variable\\n    bound or constraints, instead of giving an error.\\n    \"\n    tvars = callable.variables\n    assert len(tvars) == len(orig_types)\n    id_to_type: dict[TypeVarId, Type] = {}\n    for (tvar, type) in zip(tvars, orig_types):\n        assert not isinstance(type, PartialType), 'Internal error: must never apply partial type'\n        if type is None:\n            continue\n        target_type = get_target_type(tvar, type, callable, report_incompatible_typevar_value, context, skip_unsatisfied)\n        if target_type is not None:\n            id_to_type[tvar.id] = target_type\n    param_spec = callable.param_spec()\n    if param_spec is not None:\n        nt = id_to_type.get(param_spec.id)\n        if nt is not None:\n            callable = expand_type(callable, id_to_type)\n            assert isinstance(callable, CallableType)\n            return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    var_arg = callable.var_arg()\n    if var_arg is not None and isinstance(var_arg.typ, UnpackType):\n        callable = expand_type(callable, id_to_type)\n        assert isinstance(callable, CallableType)\n        return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    else:\n        callable = callable.copy_modified(arg_types=[expand_type(at, id_to_type) for at in callable.arg_types])\n    if callable.type_guard is not None:\n        type_guard = expand_type(callable.type_guard, id_to_type)\n    else:\n        type_guard = None\n    remaining_tvars = [tv for tv in tvars if tv.id not in id_to_type]\n    return callable.copy_modified(ret_type=expand_type(callable.ret_type, id_to_type), variables=remaining_tvars, type_guard=type_guard)",
            "def apply_generic_arguments(callable: CallableType, orig_types: Sequence[Type | None], report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None], context: Context, skip_unsatisfied: bool=False) -> CallableType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Apply generic type arguments to a callable type.\\n\\n    For example, applying [int] to 'def [T] (T) -> T' results in\\n    'def (int) -> int'.\\n\\n    Note that each type can be None; in this case, it will not be applied.\\n\\n    If `skip_unsatisfied` is True, then just skip the types that don't satisfy type variable\\n    bound or constraints, instead of giving an error.\\n    \"\n    tvars = callable.variables\n    assert len(tvars) == len(orig_types)\n    id_to_type: dict[TypeVarId, Type] = {}\n    for (tvar, type) in zip(tvars, orig_types):\n        assert not isinstance(type, PartialType), 'Internal error: must never apply partial type'\n        if type is None:\n            continue\n        target_type = get_target_type(tvar, type, callable, report_incompatible_typevar_value, context, skip_unsatisfied)\n        if target_type is not None:\n            id_to_type[tvar.id] = target_type\n    param_spec = callable.param_spec()\n    if param_spec is not None:\n        nt = id_to_type.get(param_spec.id)\n        if nt is not None:\n            callable = expand_type(callable, id_to_type)\n            assert isinstance(callable, CallableType)\n            return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    var_arg = callable.var_arg()\n    if var_arg is not None and isinstance(var_arg.typ, UnpackType):\n        callable = expand_type(callable, id_to_type)\n        assert isinstance(callable, CallableType)\n        return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])\n    else:\n        callable = callable.copy_modified(arg_types=[expand_type(at, id_to_type) for at in callable.arg_types])\n    if callable.type_guard is not None:\n        type_guard = expand_type(callable.type_guard, id_to_type)\n    else:\n        type_guard = None\n    remaining_tvars = [tv for tv in tvars if tv.id not in id_to_type]\n    return callable.copy_modified(ret_type=expand_type(callable.ret_type, id_to_type), variables=remaining_tvars, type_guard=type_guard)"
        ]
    }
]