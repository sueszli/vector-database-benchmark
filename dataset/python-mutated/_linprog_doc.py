"""
Created on Sat Aug 22 19:49:17 2020

@author: matth
"""

def _linprog_highs_doc(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='highs', callback=None, maxiter=None, disp=False, presolve=True, time_limit=None, dual_feasibility_tolerance=None, primal_feasibility_tolerance=None, ipm_optimality_tolerance=None, simplex_dual_edge_weight_strategy=None, mip_rel_gap=None, **unknown_options):
    if False:
        i = 10
        return i + 15
    '\n    Linear programming: minimize a linear objective function subject to linear\n    equality and inequality constraints using one of the HiGHS solvers.\n\n    Linear programming solves problems of the following form:\n\n    .. math::\n\n        \\min_x \\ & c^T x \\\\\n        \\mbox{such that} \\ & A_{ub} x \\leq b_{ub},\\\\\n        & A_{eq} x = b_{eq},\\\\\n        & l \\leq x \\leq u ,\n\n    where :math:`x` is a vector of decision variables; :math:`c`,\n    :math:`b_{ub}`, :math:`b_{eq}`, :math:`l`, and :math:`u` are vectors; and\n    :math:`A_{ub}` and :math:`A_{eq}` are matrices.\n\n    Alternatively, that\'s:\n\n    minimize::\n\n        c @ x\n\n    such that::\n\n        A_ub @ x <= b_ub\n        A_eq @ x == b_eq\n        lb <= x <= ub\n\n    Note that by default ``lb = 0`` and ``ub = None`` unless specified with\n    ``bounds``.\n\n    Parameters\n    ----------\n    c : 1-D array\n        The coefficients of the linear objective function to be minimized.\n    A_ub : 2-D array, optional\n        The inequality constraint matrix. Each row of ``A_ub`` specifies the\n        coefficients of a linear inequality constraint on ``x``.\n    b_ub : 1-D array, optional\n        The inequality constraint vector. Each element represents an\n        upper bound on the corresponding value of ``A_ub @ x``.\n    A_eq : 2-D array, optional\n        The equality constraint matrix. Each row of ``A_eq`` specifies the\n        coefficients of a linear equality constraint on ``x``.\n    b_eq : 1-D array, optional\n        The equality constraint vector. Each element of ``A_eq @ x`` must equal\n        the corresponding element of ``b_eq``.\n    bounds : sequence, optional\n        A sequence of ``(min, max)`` pairs for each element in ``x``, defining\n        the minimum and maximum values of that decision variable. Use ``None``\n        to indicate that there is no bound. By default, bounds are\n        ``(0, None)`` (all decision variables are non-negative).\n        If a single tuple ``(min, max)`` is provided, then ``min`` and\n        ``max`` will serve as bounds for all decision variables.\n    method : str\n\n        This is the method-specific documentation for \'highs\', which chooses\n        automatically between\n        :ref:`\'highs-ds\' <optimize.linprog-highs-ds>` and\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`.\n        :ref:`\'interior-point\' <optimize.linprog-interior-point>` (default),\n        :ref:`\'revised simplex\' <optimize.linprog-revised_simplex>`, and\n        :ref:`\'simplex\' <optimize.linprog-simplex>` (legacy)\n        are also available.\n    integrality : 1-D array or int, optional\n        Indicates the type of integrality constraint on each decision variable.\n\n        ``0`` : Continuous variable; no integrality constraint.\n\n        ``1`` : Integer variable; decision variable must be an integer\n        within `bounds`.\n\n        ``2`` : Semi-continuous variable; decision variable must be within\n        `bounds` or take value ``0``.\n\n        ``3`` : Semi-integer variable; decision variable must be an integer\n        within `bounds` or take value ``0``.\n\n        By default, all variables are continuous.\n\n        For mixed integrality constraints, supply an array of shape `c.shape`.\n        To infer a constraint on each decision variable from shorter inputs,\n        the argument will be broadcasted to `c.shape` using `np.broadcast_to`.\n\n        This argument is currently used only by the ``\'highs\'`` method and\n        ignored otherwise.\n\n    Options\n    -------\n    maxiter : int\n        The maximum number of iterations to perform in either phase.\n        For :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`, this does not\n        include the number of crossover iterations. Default is the largest\n        possible value for an ``int`` on the platform.\n    disp : bool (default: ``False``)\n        Set to ``True`` if indicators of optimization status are to be\n        printed to the console during optimization.\n    presolve : bool (default: ``True``)\n        Presolve attempts to identify trivial infeasibilities,\n        identify trivial unboundedness, and simplify the problem before\n        sending it to the main solver. It is generally recommended\n        to keep the default setting ``True``; set to ``False`` if\n        presolve is to be disabled.\n    time_limit : float\n        The maximum time in seconds allotted to solve the problem;\n        default is the largest possible value for a ``double`` on the\n        platform.\n    dual_feasibility_tolerance : double (default: 1e-07)\n        Dual feasibility tolerance for\n        :ref:`\'highs-ds\' <optimize.linprog-highs-ds>`.\n        The minimum of this and ``primal_feasibility_tolerance``\n        is used for the feasibility tolerance of\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`.\n    primal_feasibility_tolerance : double (default: 1e-07)\n        Primal feasibility tolerance for\n        :ref:`\'highs-ds\' <optimize.linprog-highs-ds>`.\n        The minimum of this and ``dual_feasibility_tolerance``\n        is used for the feasibility tolerance of\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`.\n    ipm_optimality_tolerance : double (default: ``1e-08``)\n        Optimality tolerance for\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`.\n        Minimum allowable value is 1e-12.\n    simplex_dual_edge_weight_strategy : str (default: None)\n        Strategy for simplex dual edge weights. The default, ``None``,\n        automatically selects one of the following.\n\n        ``\'dantzig\'`` uses Dantzig\'s original strategy of choosing the most\n        negative reduced cost.\n\n        ``\'devex\'`` uses the strategy described in [15]_.\n\n        ``steepest`` uses the exact steepest edge strategy as described in\n        [16]_.\n\n        ``\'steepest-devex\'`` begins with the exact steepest edge strategy\n        until the computation is too costly or inexact and then switches to\n        the devex method.\n\n        Currently, ``None`` always selects ``\'steepest-devex\'``, but this\n        may change as new options become available.\n    mip_rel_gap : double (default: None)\n        Termination criterion for MIP solver: solver will terminate when the\n        gap between the primal objective value and the dual objective bound,\n        scaled by the primal objective value, is <= mip_rel_gap.\n    unknown_options : dict\n        Optional arguments not used by this particular solver. If\n        ``unknown_options`` is non-empty, a warning is issued listing\n        all unused options.\n\n    Returns\n    -------\n    res : OptimizeResult\n        A :class:`scipy.optimize.OptimizeResult` consisting of the fields:\n\n        x : 1D array\n            The values of the decision variables that minimizes the\n            objective function while satisfying the constraints.\n        fun : float\n            The optimal value of the objective function ``c @ x``.\n        slack : 1D array\n            The (nominally positive) values of the slack,\n            ``b_ub - A_ub @ x``.\n        con : 1D array\n            The (nominally zero) residuals of the equality constraints,\n            ``b_eq - A_eq @ x``.\n        success : bool\n            ``True`` when the algorithm succeeds in finding an optimal\n            solution.\n        status : int\n            An integer representing the exit status of the algorithm.\n\n            ``0`` : Optimization terminated successfully.\n\n            ``1`` : Iteration or time limit reached.\n\n            ``2`` : Problem appears to be infeasible.\n\n            ``3`` : Problem appears to be unbounded.\n\n            ``4`` : The HiGHS solver ran into a problem.\n\n        message : str\n            A string descriptor of the exit status of the algorithm.\n        nit : int\n            The total number of iterations performed.\n            For the HiGHS simplex method, this includes iterations in all\n            phases. For the HiGHS interior-point method, this does not include\n            crossover iterations.\n        crossover_nit : int\n            The number of primal/dual pushes performed during the\n            crossover routine for the HiGHS interior-point method.\n            This is ``0`` for the HiGHS simplex method.\n        ineqlin : OptimizeResult\n            Solution and sensitivity information corresponding to the\n            inequality constraints, `b_ub`. A dictionary consisting of the\n            fields:\n\n            residual : np.ndnarray\n                The (nominally positive) values of the slack variables,\n                ``b_ub - A_ub @ x``.  This quantity is also commonly\n                referred to as "slack".\n\n            marginals : np.ndarray\n                The sensitivity (partial derivative) of the objective\n                function with respect to the right-hand side of the\n                inequality constraints, `b_ub`.\n\n        eqlin : OptimizeResult\n            Solution and sensitivity information corresponding to the\n            equality constraints, `b_eq`.  A dictionary consisting of the\n            fields:\n\n            residual : np.ndarray\n                The (nominally zero) residuals of the equality constraints,\n                ``b_eq - A_eq @ x``.\n\n            marginals : np.ndarray\n                The sensitivity (partial derivative) of the objective\n                function with respect to the right-hand side of the\n                equality constraints, `b_eq`.\n\n        lower, upper : OptimizeResult\n            Solution and sensitivity information corresponding to the\n            lower and upper bounds on decision variables, `bounds`.\n\n            residual : np.ndarray\n                The (nominally positive) values of the quantity\n                ``x - lb`` (lower) or ``ub - x`` (upper).\n\n            marginals : np.ndarray\n                The sensitivity (partial derivative) of the objective\n                function with respect to the lower and upper\n                `bounds`.\n\n    Notes\n    -----\n\n    Method :ref:`\'highs-ds\' <optimize.linprog-highs-ds>` is a wrapper\n    of the C++ high performance dual revised simplex implementation (HSOL)\n    [13]_, [14]_. Method :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`\n    is a wrapper of a C++ implementation of an **i**\\ nterior-\\ **p**\\ oint\n    **m**\\ ethod [13]_; it features a crossover routine, so it is as accurate\n    as a simplex solver. Method :ref:`\'highs\' <optimize.linprog-highs>` chooses\n    between the two automatically. For new code involving `linprog`, we\n    recommend explicitly choosing one of these three method values instead of\n    :ref:`\'interior-point\' <optimize.linprog-interior-point>` (default),\n    :ref:`\'revised simplex\' <optimize.linprog-revised_simplex>`, and\n    :ref:`\'simplex\' <optimize.linprog-simplex>` (legacy).\n\n    The result fields `ineqlin`, `eqlin`, `lower`, and `upper` all contain\n    `marginals`, or partial derivatives of the objective function with respect\n    to the right-hand side of each constraint. These partial derivatives are\n    also referred to as "Lagrange multipliers", "dual values", and\n    "shadow prices". The sign convention of `marginals` is opposite that\n    of Lagrange multipliers produced by many nonlinear solvers.\n\n    References\n    ----------\n    .. [13] Huangfu, Q., Galabova, I., Feldmeier, M., and Hall, J. A. J.\n           "HiGHS - high performance software for linear optimization."\n           https://highs.dev/\n    .. [14] Huangfu, Q. and Hall, J. A. J. "Parallelizing the dual revised\n           simplex method." Mathematical Programming Computation, 10 (1),\n           119-142, 2018. DOI: 10.1007/s12532-017-0130-5\n    .. [15] Harris, Paula MJ. "Pivot selection methods of the Devex LP code."\n            Mathematical programming 5.1 (1973): 1-28.\n    .. [16] Goldfarb, Donald, and John Ker Reid. "A practicable steepest-edge\n            simplex algorithm." Mathematical Programming 12.1 (1977): 361-371.\n    '
    pass

def _linprog_highs_ds_doc(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='highs-ds', callback=None, maxiter=None, disp=False, presolve=True, time_limit=None, dual_feasibility_tolerance=None, primal_feasibility_tolerance=None, simplex_dual_edge_weight_strategy=None, **unknown_options):
    if False:
        i = 10
        return i + 15
    '\n    Linear programming: minimize a linear objective function subject to linear\n    equality and inequality constraints using the HiGHS dual simplex solver.\n\n    Linear programming solves problems of the following form:\n\n    .. math::\n\n        \\min_x \\ & c^T x \\\\\n        \\mbox{such that} \\ & A_{ub} x \\leq b_{ub},\\\\\n        & A_{eq} x = b_{eq},\\\\\n        & l \\leq x \\leq u ,\n\n    where :math:`x` is a vector of decision variables; :math:`c`,\n    :math:`b_{ub}`, :math:`b_{eq}`, :math:`l`, and :math:`u` are vectors; and\n    :math:`A_{ub}` and :math:`A_{eq}` are matrices.\n\n    Alternatively, that\'s:\n\n    minimize::\n\n        c @ x\n\n    such that::\n\n        A_ub @ x <= b_ub\n        A_eq @ x == b_eq\n        lb <= x <= ub\n\n    Note that by default ``lb = 0`` and ``ub = None`` unless specified with\n    ``bounds``.\n\n    Parameters\n    ----------\n    c : 1-D array\n        The coefficients of the linear objective function to be minimized.\n    A_ub : 2-D array, optional\n        The inequality constraint matrix. Each row of ``A_ub`` specifies the\n        coefficients of a linear inequality constraint on ``x``.\n    b_ub : 1-D array, optional\n        The inequality constraint vector. Each element represents an\n        upper bound on the corresponding value of ``A_ub @ x``.\n    A_eq : 2-D array, optional\n        The equality constraint matrix. Each row of ``A_eq`` specifies the\n        coefficients of a linear equality constraint on ``x``.\n    b_eq : 1-D array, optional\n        The equality constraint vector. Each element of ``A_eq @ x`` must equal\n        the corresponding element of ``b_eq``.\n    bounds : sequence, optional\n        A sequence of ``(min, max)`` pairs for each element in ``x``, defining\n        the minimum and maximum values of that decision variable. Use ``None``\n        to indicate that there is no bound. By default, bounds are\n        ``(0, None)`` (all decision variables are non-negative).\n        If a single tuple ``(min, max)`` is provided, then ``min`` and\n        ``max`` will serve as bounds for all decision variables.\n    method : str\n\n        This is the method-specific documentation for \'highs-ds\'.\n        :ref:`\'highs\' <optimize.linprog-highs>`,\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`,\n        :ref:`\'interior-point\' <optimize.linprog-interior-point>` (default),\n        :ref:`\'revised simplex\' <optimize.linprog-revised_simplex>`, and\n        :ref:`\'simplex\' <optimize.linprog-simplex>` (legacy)\n        are also available.\n\n    Options\n    -------\n    maxiter : int\n        The maximum number of iterations to perform in either phase.\n        Default is the largest possible value for an ``int`` on the platform.\n    disp : bool (default: ``False``)\n        Set to ``True`` if indicators of optimization status are to be\n        printed to the console during optimization.\n    presolve : bool (default: ``True``)\n        Presolve attempts to identify trivial infeasibilities,\n        identify trivial unboundedness, and simplify the problem before\n        sending it to the main solver. It is generally recommended\n        to keep the default setting ``True``; set to ``False`` if\n        presolve is to be disabled.\n    time_limit : float\n        The maximum time in seconds allotted to solve the problem;\n        default is the largest possible value for a ``double`` on the\n        platform.\n    dual_feasibility_tolerance : double (default: 1e-07)\n        Dual feasibility tolerance for\n        :ref:`\'highs-ds\' <optimize.linprog-highs-ds>`.\n    primal_feasibility_tolerance : double (default: 1e-07)\n        Primal feasibility tolerance for\n        :ref:`\'highs-ds\' <optimize.linprog-highs-ds>`.\n    simplex_dual_edge_weight_strategy : str (default: None)\n        Strategy for simplex dual edge weights. The default, ``None``,\n        automatically selects one of the following.\n\n        ``\'dantzig\'`` uses Dantzig\'s original strategy of choosing the most\n        negative reduced cost.\n\n        ``\'devex\'`` uses the strategy described in [15]_.\n\n        ``steepest`` uses the exact steepest edge strategy as described in\n        [16]_.\n\n        ``\'steepest-devex\'`` begins with the exact steepest edge strategy\n        until the computation is too costly or inexact and then switches to\n        the devex method.\n\n        Currently, ``None`` always selects ``\'steepest-devex\'``, but this\n        may change as new options become available.\n    unknown_options : dict\n        Optional arguments not used by this particular solver. If\n        ``unknown_options`` is non-empty, a warning is issued listing\n        all unused options.\n\n    Returns\n    -------\n    res : OptimizeResult\n        A :class:`scipy.optimize.OptimizeResult` consisting of the fields:\n\n        x : 1D array\n            The values of the decision variables that minimizes the\n            objective function while satisfying the constraints.\n        fun : float\n            The optimal value of the objective function ``c @ x``.\n        slack : 1D array\n            The (nominally positive) values of the slack,\n            ``b_ub - A_ub @ x``.\n        con : 1D array\n            The (nominally zero) residuals of the equality constraints,\n            ``b_eq - A_eq @ x``.\n        success : bool\n            ``True`` when the algorithm succeeds in finding an optimal\n            solution.\n        status : int\n            An integer representing the exit status of the algorithm.\n\n            ``0`` : Optimization terminated successfully.\n\n            ``1`` : Iteration or time limit reached.\n\n            ``2`` : Problem appears to be infeasible.\n\n            ``3`` : Problem appears to be unbounded.\n\n            ``4`` : The HiGHS solver ran into a problem.\n\n        message : str\n            A string descriptor of the exit status of the algorithm.\n        nit : int\n            The total number of iterations performed. This includes iterations\n            in all phases.\n        crossover_nit : int\n            This is always ``0`` for the HiGHS simplex method.\n            For the HiGHS interior-point method, this is the number of\n            primal/dual pushes performed during the crossover routine.\n        ineqlin : OptimizeResult\n            Solution and sensitivity information corresponding to the\n            inequality constraints, `b_ub`. A dictionary consisting of the\n            fields:\n\n            residual : np.ndnarray\n                The (nominally positive) values of the slack variables,\n                ``b_ub - A_ub @ x``.  This quantity is also commonly\n                referred to as "slack".\n\n            marginals : np.ndarray\n                The sensitivity (partial derivative) of the objective\n                function with respect to the right-hand side of the\n                inequality constraints, `b_ub`.\n\n        eqlin : OptimizeResult\n            Solution and sensitivity information corresponding to the\n            equality constraints, `b_eq`.  A dictionary consisting of the\n            fields:\n\n            residual : np.ndarray\n                The (nominally zero) residuals of the equality constraints,\n                ``b_eq - A_eq @ x``.\n\n            marginals : np.ndarray\n                The sensitivity (partial derivative) of the objective\n                function with respect to the right-hand side of the\n                equality constraints, `b_eq`.\n\n        lower, upper : OptimizeResult\n            Solution and sensitivity information corresponding to the\n            lower and upper bounds on decision variables, `bounds`.\n\n            residual : np.ndarray\n                The (nominally positive) values of the quantity\n                ``x - lb`` (lower) or ``ub - x`` (upper).\n\n            marginals : np.ndarray\n                The sensitivity (partial derivative) of the objective\n                function with respect to the lower and upper\n                `bounds`.\n\n    Notes\n    -----\n\n    Method :ref:`\'highs-ds\' <optimize.linprog-highs-ds>` is a wrapper\n    of the C++ high performance dual revised simplex implementation (HSOL)\n    [13]_, [14]_. Method :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`\n    is a wrapper of a C++ implementation of an **i**\\ nterior-\\ **p**\\ oint\n    **m**\\ ethod [13]_; it features a crossover routine, so it is as accurate\n    as a simplex solver. Method :ref:`\'highs\' <optimize.linprog-highs>` chooses\n    between the two automatically. For new code involving `linprog`, we\n    recommend explicitly choosing one of these three method values instead of\n    :ref:`\'interior-point\' <optimize.linprog-interior-point>` (default),\n    :ref:`\'revised simplex\' <optimize.linprog-revised_simplex>`, and\n    :ref:`\'simplex\' <optimize.linprog-simplex>` (legacy).\n\n    The result fields `ineqlin`, `eqlin`, `lower`, and `upper` all contain\n    `marginals`, or partial derivatives of the objective function with respect\n    to the right-hand side of each constraint. These partial derivatives are\n    also referred to as "Lagrange multipliers", "dual values", and\n    "shadow prices". The sign convention of `marginals` is opposite that\n    of Lagrange multipliers produced by many nonlinear solvers.\n\n    References\n    ----------\n    .. [13] Huangfu, Q., Galabova, I., Feldmeier, M., and Hall, J. A. J.\n           "HiGHS - high performance software for linear optimization."\n           https://highs.dev/\n    .. [14] Huangfu, Q. and Hall, J. A. J. "Parallelizing the dual revised\n           simplex method." Mathematical Programming Computation, 10 (1),\n           119-142, 2018. DOI: 10.1007/s12532-017-0130-5\n    .. [15] Harris, Paula MJ. "Pivot selection methods of the Devex LP code."\n            Mathematical programming 5.1 (1973): 1-28.\n    .. [16] Goldfarb, Donald, and John Ker Reid. "A practicable steepest-edge\n            simplex algorithm." Mathematical Programming 12.1 (1977): 361-371.\n    '
    pass

def _linprog_highs_ipm_doc(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='highs-ipm', callback=None, maxiter=None, disp=False, presolve=True, time_limit=None, dual_feasibility_tolerance=None, primal_feasibility_tolerance=None, ipm_optimality_tolerance=None, **unknown_options):
    if False:
        return 10
    '\n    Linear programming: minimize a linear objective function subject to linear\n    equality and inequality constraints using the HiGHS interior point solver.\n\n    Linear programming solves problems of the following form:\n\n    .. math::\n\n        \\min_x \\ & c^T x \\\\\n        \\mbox{such that} \\ & A_{ub} x \\leq b_{ub},\\\\\n        & A_{eq} x = b_{eq},\\\\\n        & l \\leq x \\leq u ,\n\n    where :math:`x` is a vector of decision variables; :math:`c`,\n    :math:`b_{ub}`, :math:`b_{eq}`, :math:`l`, and :math:`u` are vectors; and\n    :math:`A_{ub}` and :math:`A_{eq}` are matrices.\n\n    Alternatively, that\'s:\n\n    minimize::\n\n        c @ x\n\n    such that::\n\n        A_ub @ x <= b_ub\n        A_eq @ x == b_eq\n        lb <= x <= ub\n\n    Note that by default ``lb = 0`` and ``ub = None`` unless specified with\n    ``bounds``.\n\n    Parameters\n    ----------\n    c : 1-D array\n        The coefficients of the linear objective function to be minimized.\n    A_ub : 2-D array, optional\n        The inequality constraint matrix. Each row of ``A_ub`` specifies the\n        coefficients of a linear inequality constraint on ``x``.\n    b_ub : 1-D array, optional\n        The inequality constraint vector. Each element represents an\n        upper bound on the corresponding value of ``A_ub @ x``.\n    A_eq : 2-D array, optional\n        The equality constraint matrix. Each row of ``A_eq`` specifies the\n        coefficients of a linear equality constraint on ``x``.\n    b_eq : 1-D array, optional\n        The equality constraint vector. Each element of ``A_eq @ x`` must equal\n        the corresponding element of ``b_eq``.\n    bounds : sequence, optional\n        A sequence of ``(min, max)`` pairs for each element in ``x``, defining\n        the minimum and maximum values of that decision variable. Use ``None``\n        to indicate that there is no bound. By default, bounds are\n        ``(0, None)`` (all decision variables are non-negative).\n        If a single tuple ``(min, max)`` is provided, then ``min`` and\n        ``max`` will serve as bounds for all decision variables.\n    method : str\n\n        This is the method-specific documentation for \'highs-ipm\'.\n        :ref:`\'highs-ipm\' <optimize.linprog-highs>`,\n        :ref:`\'highs-ds\' <optimize.linprog-highs-ds>`,\n        :ref:`\'interior-point\' <optimize.linprog-interior-point>` (default),\n        :ref:`\'revised simplex\' <optimize.linprog-revised_simplex>`, and\n        :ref:`\'simplex\' <optimize.linprog-simplex>` (legacy)\n        are also available.\n\n    Options\n    -------\n    maxiter : int\n        The maximum number of iterations to perform in either phase.\n        For :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`, this does not\n        include the number of crossover iterations. Default is the largest\n        possible value for an ``int`` on the platform.\n    disp : bool (default: ``False``)\n        Set to ``True`` if indicators of optimization status are to be\n        printed to the console during optimization.\n    presolve : bool (default: ``True``)\n        Presolve attempts to identify trivial infeasibilities,\n        identify trivial unboundedness, and simplify the problem before\n        sending it to the main solver. It is generally recommended\n        to keep the default setting ``True``; set to ``False`` if\n        presolve is to be disabled.\n    time_limit : float\n        The maximum time in seconds allotted to solve the problem;\n        default is the largest possible value for a ``double`` on the\n        platform.\n    dual_feasibility_tolerance : double (default: 1e-07)\n        The minimum of this and ``primal_feasibility_tolerance``\n        is used for the feasibility tolerance of\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`.\n    primal_feasibility_tolerance : double (default: 1e-07)\n        The minimum of this and ``dual_feasibility_tolerance``\n        is used for the feasibility tolerance of\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`.\n    ipm_optimality_tolerance : double (default: ``1e-08``)\n        Optimality tolerance for\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`.\n        Minimum allowable value is 1e-12.\n    unknown_options : dict\n        Optional arguments not used by this particular solver. If\n        ``unknown_options`` is non-empty, a warning is issued listing\n        all unused options.\n\n    Returns\n    -------\n    res : OptimizeResult\n        A :class:`scipy.optimize.OptimizeResult` consisting of the fields:\n\n        x : 1D array\n            The values of the decision variables that minimizes the\n            objective function while satisfying the constraints.\n        fun : float\n            The optimal value of the objective function ``c @ x``.\n        slack : 1D array\n            The (nominally positive) values of the slack,\n            ``b_ub - A_ub @ x``.\n        con : 1D array\n            The (nominally zero) residuals of the equality constraints,\n            ``b_eq - A_eq @ x``.\n        success : bool\n            ``True`` when the algorithm succeeds in finding an optimal\n            solution.\n        status : int\n            An integer representing the exit status of the algorithm.\n\n            ``0`` : Optimization terminated successfully.\n\n            ``1`` : Iteration or time limit reached.\n\n            ``2`` : Problem appears to be infeasible.\n\n            ``3`` : Problem appears to be unbounded.\n\n            ``4`` : The HiGHS solver ran into a problem.\n\n        message : str\n            A string descriptor of the exit status of the algorithm.\n        nit : int\n            The total number of iterations performed.\n            For the HiGHS interior-point method, this does not include\n            crossover iterations.\n        crossover_nit : int\n            The number of primal/dual pushes performed during the\n            crossover routine for the HiGHS interior-point method.\n        ineqlin : OptimizeResult\n            Solution and sensitivity information corresponding to the\n            inequality constraints, `b_ub`. A dictionary consisting of the\n            fields:\n\n            residual : np.ndnarray\n                The (nominally positive) values of the slack variables,\n                ``b_ub - A_ub @ x``.  This quantity is also commonly\n                referred to as "slack".\n\n            marginals : np.ndarray\n                The sensitivity (partial derivative) of the objective\n                function with respect to the right-hand side of the\n                inequality constraints, `b_ub`.\n\n        eqlin : OptimizeResult\n            Solution and sensitivity information corresponding to the\n            equality constraints, `b_eq`.  A dictionary consisting of the\n            fields:\n\n            residual : np.ndarray\n                The (nominally zero) residuals of the equality constraints,\n                ``b_eq - A_eq @ x``.\n\n            marginals : np.ndarray\n                The sensitivity (partial derivative) of the objective\n                function with respect to the right-hand side of the\n                equality constraints, `b_eq`.\n\n        lower, upper : OptimizeResult\n            Solution and sensitivity information corresponding to the\n            lower and upper bounds on decision variables, `bounds`.\n\n            residual : np.ndarray\n                The (nominally positive) values of the quantity\n                ``x - lb`` (lower) or ``ub - x`` (upper).\n\n            marginals : np.ndarray\n                The sensitivity (partial derivative) of the objective\n                function with respect to the lower and upper\n                `bounds`.\n\n    Notes\n    -----\n\n    Method :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`\n    is a wrapper of a C++ implementation of an **i**\\ nterior-\\ **p**\\ oint\n    **m**\\ ethod [13]_; it features a crossover routine, so it is as accurate\n    as a simplex solver.\n    Method :ref:`\'highs-ds\' <optimize.linprog-highs-ds>` is a wrapper\n    of the C++ high performance dual revised simplex implementation (HSOL)\n    [13]_, [14]_. Method :ref:`\'highs\' <optimize.linprog-highs>` chooses\n    between the two automatically. For new code involving `linprog`, we\n    recommend explicitly choosing one of these three method values instead of\n    :ref:`\'interior-point\' <optimize.linprog-interior-point>` (default),\n    :ref:`\'revised simplex\' <optimize.linprog-revised_simplex>`, and\n    :ref:`\'simplex\' <optimize.linprog-simplex>` (legacy).\n\n    The result fields `ineqlin`, `eqlin`, `lower`, and `upper` all contain\n    `marginals`, or partial derivatives of the objective function with respect\n    to the right-hand side of each constraint. These partial derivatives are\n    also referred to as "Lagrange multipliers", "dual values", and\n    "shadow prices". The sign convention of `marginals` is opposite that\n    of Lagrange multipliers produced by many nonlinear solvers.\n\n    References\n    ----------\n    .. [13] Huangfu, Q., Galabova, I., Feldmeier, M., and Hall, J. A. J.\n           "HiGHS - high performance software for linear optimization."\n           https://highs.dev/\n    .. [14] Huangfu, Q. and Hall, J. A. J. "Parallelizing the dual revised\n           simplex method." Mathematical Programming Computation, 10 (1),\n           119-142, 2018. DOI: 10.1007/s12532-017-0130-5\n    '
    pass

def _linprog_ip_doc(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='interior-point', callback=None, maxiter=1000, disp=False, presolve=True, tol=1e-08, autoscale=False, rr=True, alpha0=0.99995, beta=0.1, sparse=False, lstsq=False, sym_pos=True, cholesky=True, pc=True, ip=False, permc_spec='MMD_AT_PLUS_A', **unknown_options):
    if False:
        return 10
    '\n    Linear programming: minimize a linear objective function subject to linear\n    equality and inequality constraints using the interior-point method of\n    [4]_.\n\n    .. deprecated:: 1.9.0\n        `method=\'interior-point\'` will be removed in SciPy 1.11.0.\n        It is replaced by `method=\'highs\'` because the latter is\n        faster and more robust.\n\n    Linear programming solves problems of the following form:\n\n    .. math::\n\n        \\min_x \\ & c^T x \\\\\n        \\mbox{such that} \\ & A_{ub} x \\leq b_{ub},\\\\\n        & A_{eq} x = b_{eq},\\\\\n        & l \\leq x \\leq u ,\n\n    where :math:`x` is a vector of decision variables; :math:`c`,\n    :math:`b_{ub}`, :math:`b_{eq}`, :math:`l`, and :math:`u` are vectors; and\n    :math:`A_{ub}` and :math:`A_{eq}` are matrices.\n\n    Alternatively, that\'s:\n\n    minimize::\n\n        c @ x\n\n    such that::\n\n        A_ub @ x <= b_ub\n        A_eq @ x == b_eq\n        lb <= x <= ub\n\n    Note that by default ``lb = 0`` and ``ub = None`` unless specified with\n    ``bounds``.\n\n    Parameters\n    ----------\n    c : 1-D array\n        The coefficients of the linear objective function to be minimized.\n    A_ub : 2-D array, optional\n        The inequality constraint matrix. Each row of ``A_ub`` specifies the\n        coefficients of a linear inequality constraint on ``x``.\n    b_ub : 1-D array, optional\n        The inequality constraint vector. Each element represents an\n        upper bound on the corresponding value of ``A_ub @ x``.\n    A_eq : 2-D array, optional\n        The equality constraint matrix. Each row of ``A_eq`` specifies the\n        coefficients of a linear equality constraint on ``x``.\n    b_eq : 1-D array, optional\n        The equality constraint vector. Each element of ``A_eq @ x`` must equal\n        the corresponding element of ``b_eq``.\n    bounds : sequence, optional\n        A sequence of ``(min, max)`` pairs for each element in ``x``, defining\n        the minimum and maximum values of that decision variable. Use ``None``\n        to indicate that there is no bound. By default, bounds are\n        ``(0, None)`` (all decision variables are non-negative).\n        If a single tuple ``(min, max)`` is provided, then ``min`` and\n        ``max`` will serve as bounds for all decision variables.\n    method : str\n        This is the method-specific documentation for \'interior-point\'.\n        :ref:`\'highs\' <optimize.linprog-highs>`,\n        :ref:`\'highs-ds\' <optimize.linprog-highs-ds>`,\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`,\n        :ref:`\'revised simplex\' <optimize.linprog-revised_simplex>`, and\n        :ref:`\'simplex\' <optimize.linprog-simplex>` (legacy)\n        are also available.\n    callback : callable, optional\n        Callback function to be executed once per iteration.\n\n    Options\n    -------\n    maxiter : int (default: 1000)\n        The maximum number of iterations of the algorithm.\n    disp : bool (default: False)\n        Set to ``True`` if indicators of optimization status are to be printed\n        to the console each iteration.\n    presolve : bool (default: True)\n        Presolve attempts to identify trivial infeasibilities,\n        identify trivial unboundedness, and simplify the problem before\n        sending it to the main solver. It is generally recommended\n        to keep the default setting ``True``; set to ``False`` if\n        presolve is to be disabled.\n    tol : float (default: 1e-8)\n        Termination tolerance to be used for all termination criteria;\n        see [4]_ Section 4.5.\n    autoscale : bool (default: False)\n        Set to ``True`` to automatically perform equilibration.\n        Consider using this option if the numerical values in the\n        constraints are separated by several orders of magnitude.\n    rr : bool (default: True)\n        Set to ``False`` to disable automatic redundancy removal.\n    alpha0 : float (default: 0.99995)\n        The maximal step size for Mehrota\'s predictor-corrector search\n        direction; see :math:`\\beta_{3}` of [4]_ Table 8.1.\n    beta : float (default: 0.1)\n        The desired reduction of the path parameter :math:`\\mu` (see [6]_)\n        when Mehrota\'s predictor-corrector is not in use (uncommon).\n    sparse : bool (default: False)\n        Set to ``True`` if the problem is to be treated as sparse after\n        presolve. If either ``A_eq`` or ``A_ub`` is a sparse matrix,\n        this option will automatically be set ``True``, and the problem\n        will be treated as sparse even during presolve. If your constraint\n        matrices contain mostly zeros and the problem is not very small (less\n        than about 100 constraints or variables), consider setting ``True``\n        or providing ``A_eq`` and ``A_ub`` as sparse matrices.\n    lstsq : bool (default: ``False``)\n        Set to ``True`` if the problem is expected to be very poorly\n        conditioned. This should always be left ``False`` unless severe\n        numerical difficulties are encountered. Leave this at the default\n        unless you receive a warning message suggesting otherwise.\n    sym_pos : bool (default: True)\n        Leave ``True`` if the problem is expected to yield a well conditioned\n        symmetric positive definite normal equation matrix\n        (almost always). Leave this at the default unless you receive\n        a warning message suggesting otherwise.\n    cholesky : bool (default: True)\n        Set to ``True`` if the normal equations are to be solved by explicit\n        Cholesky decomposition followed by explicit forward/backward\n        substitution. This is typically faster for problems\n        that are numerically well-behaved.\n    pc : bool (default: True)\n        Leave ``True`` if the predictor-corrector method of Mehrota is to be\n        used. This is almost always (if not always) beneficial.\n    ip : bool (default: False)\n        Set to ``True`` if the improved initial point suggestion due to [4]_\n        Section 4.3 is desired. Whether this is beneficial or not\n        depends on the problem.\n    permc_spec : str (default: \'MMD_AT_PLUS_A\')\n        (Has effect only with ``sparse = True``, ``lstsq = False``, ``sym_pos =\n        True``, and no SuiteSparse.)\n        A matrix is factorized in each iteration of the algorithm.\n        This option specifies how to permute the columns of the matrix for\n        sparsity preservation. Acceptable values are:\n\n        - ``NATURAL``: natural ordering.\n        - ``MMD_ATA``: minimum degree ordering on the structure of A^T A.\n        - ``MMD_AT_PLUS_A``: minimum degree ordering on the structure of A^T+A.\n        - ``COLAMD``: approximate minimum degree column ordering.\n\n        This option can impact the convergence of the\n        interior point algorithm; test different values to determine which\n        performs best for your problem. For more information, refer to\n        ``scipy.sparse.linalg.splu``.\n    unknown_options : dict\n        Optional arguments not used by this particular solver. If\n        `unknown_options` is non-empty a warning is issued listing all\n        unused options.\n\n    Returns\n    -------\n    res : OptimizeResult\n        A :class:`scipy.optimize.OptimizeResult` consisting of the fields:\n\n        x : 1-D array\n            The values of the decision variables that minimizes the\n            objective function while satisfying the constraints.\n        fun : float\n            The optimal value of the objective function ``c @ x``.\n        slack : 1-D array\n            The (nominally positive) values of the slack variables,\n            ``b_ub - A_ub @ x``.\n        con : 1-D array\n            The (nominally zero) residuals of the equality constraints,\n            ``b_eq - A_eq @ x``.\n        success : bool\n            ``True`` when the algorithm succeeds in finding an optimal\n            solution.\n        status : int\n            An integer representing the exit status of the algorithm.\n\n            ``0`` : Optimization terminated successfully.\n\n            ``1`` : Iteration limit reached.\n\n            ``2`` : Problem appears to be infeasible.\n\n            ``3`` : Problem appears to be unbounded.\n\n            ``4`` : Numerical difficulties encountered.\n\n        message : str\n            A string descriptor of the exit status of the algorithm.\n        nit : int\n            The total number of iterations performed in all phases.\n\n\n    Notes\n    -----\n    This method implements the algorithm outlined in [4]_ with ideas from [8]_\n    and a structure inspired by the simpler methods of [6]_.\n\n    The primal-dual path following method begins with initial \'guesses\' of\n    the primal and dual variables of the standard form problem and iteratively\n    attempts to solve the (nonlinear) Karush-Kuhn-Tucker conditions for the\n    problem with a gradually reduced logarithmic barrier term added to the\n    objective. This particular implementation uses a homogeneous self-dual\n    formulation, which provides certificates of infeasibility or unboundedness\n    where applicable.\n\n    The default initial point for the primal and dual variables is that\n    defined in [4]_ Section 4.4 Equation 8.22. Optionally (by setting initial\n    point option ``ip=True``), an alternate (potentially improved) starting\n    point can be calculated according to the additional recommendations of\n    [4]_ Section 4.4.\n\n    A search direction is calculated using the predictor-corrector method\n    (single correction) proposed by Mehrota and detailed in [4]_ Section 4.1.\n    (A potential improvement would be to implement the method of multiple\n    corrections described in [4]_ Section 4.2.) In practice, this is\n    accomplished by solving the normal equations, [4]_ Section 5.1 Equations\n    8.31 and 8.32, derived from the Newton equations [4]_ Section 5 Equations\n    8.25 (compare to [4]_ Section 4 Equations 8.6-8.8). The advantage of\n    solving the normal equations rather than 8.25 directly is that the\n    matrices involved are symmetric positive definite, so Cholesky\n    decomposition can be used rather than the more expensive LU factorization.\n\n    With default options, the solver used to perform the factorization depends\n    on third-party software availability and the conditioning of the problem.\n\n    For dense problems, solvers are tried in the following order:\n\n    1. ``scipy.linalg.cho_factor``\n\n    2. ``scipy.linalg.solve`` with option ``sym_pos=True``\n\n    3. ``scipy.linalg.solve`` with option ``sym_pos=False``\n\n    4. ``scipy.linalg.lstsq``\n\n    For sparse problems:\n\n    1. ``sksparse.cholmod.cholesky`` (if scikit-sparse and SuiteSparse are\n       installed)\n\n    2. ``scipy.sparse.linalg.factorized`` (if scikit-umfpack and SuiteSparse\n       are installed)\n\n    3. ``scipy.sparse.linalg.splu`` (which uses SuperLU distributed with SciPy)\n\n    4. ``scipy.sparse.linalg.lsqr``\n\n    If the solver fails for any reason, successively more robust (but slower)\n    solvers are attempted in the order indicated. Attempting, failing, and\n    re-starting factorization can be time consuming, so if the problem is\n    numerically challenging, options can be set to  bypass solvers that are\n    failing. Setting ``cholesky=False`` skips to solver 2,\n    ``sym_pos=False`` skips to solver 3, and ``lstsq=True`` skips\n    to solver 4 for both sparse and dense problems.\n\n    Potential improvements for combatting issues associated with dense\n    columns in otherwise sparse problems are outlined in [4]_ Section 5.3 and\n    [10]_ Section 4.1-4.2; the latter also discusses the alleviation of\n    accuracy issues associated with the substitution approach to free\n    variables.\n\n    After calculating the search direction, the maximum possible step size\n    that does not activate the non-negativity constraints is calculated, and\n    the smaller of this step size and unity is applied (as in [4]_ Section\n    4.1.) [4]_ Section 4.3 suggests improvements for choosing the step size.\n\n    The new point is tested according to the termination conditions of [4]_\n    Section 4.5. The same tolerance, which can be set using the ``tol`` option,\n    is used for all checks. (A potential improvement would be to expose\n    the different tolerances to be set independently.) If optimality,\n    unboundedness, or infeasibility is detected, the solve procedure\n    terminates; otherwise it repeats.\n\n    Whereas the top level ``linprog`` module expects a problem of form:\n\n    Minimize::\n\n        c @ x\n\n    Subject to::\n\n        A_ub @ x <= b_ub\n        A_eq @ x == b_eq\n         lb <= x <= ub\n\n    where ``lb = 0`` and ``ub = None`` unless set in ``bounds``. The problem\n    is automatically converted to the form:\n\n    Minimize::\n\n        c @ x\n\n    Subject to::\n\n        A @ x == b\n            x >= 0\n\n    for solution. That is, the original problem contains equality, upper-bound\n    and variable constraints whereas the method specific solver requires\n    equality constraints and variable non-negativity. ``linprog`` converts the\n    original problem to standard form by converting the simple bounds to upper\n    bound constraints, introducing non-negative slack variables for inequality\n    constraints, and expressing unbounded variables as the difference between\n    two non-negative variables. The problem is converted back to the original\n    form before results are reported.\n\n    References\n    ----------\n    .. [4] Andersen, Erling D., and Knud D. Andersen. "The MOSEK interior point\n           optimizer for linear programming: an implementation of the\n           homogeneous algorithm." High performance optimization. Springer US,\n           2000. 197-232.\n    .. [6] Freund, Robert M. "Primal-Dual Interior-Point Methods for Linear\n           Programming based on Newton\'s Method." Unpublished Course Notes,\n           March 2004. Available 2/25/2017 at\n           https://ocw.mit.edu/courses/sloan-school-of-management/15-084j-nonlinear-programming-spring-2004/lecture-notes/lec14_int_pt_mthd.pdf\n    .. [8] Andersen, Erling D., and Knud D. Andersen. "Presolving in linear\n           programming." Mathematical Programming 71.2 (1995): 221-245.\n    .. [9] Bertsimas, Dimitris, and J. Tsitsiklis. "Introduction to linear\n           programming." Athena Scientific 1 (1997): 997.\n    .. [10] Andersen, Erling D., et al. Implementation of interior point\n            methods for large scale linear programming. HEC/Universite de\n            Geneve, 1996.\n    '
    pass

def _linprog_rs_doc(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='interior-point', callback=None, x0=None, maxiter=5000, disp=False, presolve=True, tol=1e-12, autoscale=False, rr=True, maxupdate=10, mast=False, pivot='mrc', **unknown_options):
    if False:
        return 10
    '\n    Linear programming: minimize a linear objective function subject to linear\n    equality and inequality constraints using the revised simplex method.\n\n    .. deprecated:: 1.9.0\n        `method=\'revised simplex\'` will be removed in SciPy 1.11.0.\n        It is replaced by `method=\'highs\'` because the latter is\n        faster and more robust.\n\n    Linear programming solves problems of the following form:\n\n    .. math::\n\n        \\min_x \\ & c^T x \\\\\n        \\mbox{such that} \\ & A_{ub} x \\leq b_{ub},\\\\\n        & A_{eq} x = b_{eq},\\\\\n        & l \\leq x \\leq u ,\n\n    where :math:`x` is a vector of decision variables; :math:`c`,\n    :math:`b_{ub}`, :math:`b_{eq}`, :math:`l`, and :math:`u` are vectors; and\n    :math:`A_{ub}` and :math:`A_{eq}` are matrices.\n\n    Alternatively, that\'s:\n\n    minimize::\n\n        c @ x\n\n    such that::\n\n        A_ub @ x <= b_ub\n        A_eq @ x == b_eq\n        lb <= x <= ub\n\n    Note that by default ``lb = 0`` and ``ub = None`` unless specified with\n    ``bounds``.\n\n    Parameters\n    ----------\n    c : 1-D array\n        The coefficients of the linear objective function to be minimized.\n    A_ub : 2-D array, optional\n        The inequality constraint matrix. Each row of ``A_ub`` specifies the\n        coefficients of a linear inequality constraint on ``x``.\n    b_ub : 1-D array, optional\n        The inequality constraint vector. Each element represents an\n        upper bound on the corresponding value of ``A_ub @ x``.\n    A_eq : 2-D array, optional\n        The equality constraint matrix. Each row of ``A_eq`` specifies the\n        coefficients of a linear equality constraint on ``x``.\n    b_eq : 1-D array, optional\n        The equality constraint vector. Each element of ``A_eq @ x`` must equal\n        the corresponding element of ``b_eq``.\n    bounds : sequence, optional\n        A sequence of ``(min, max)`` pairs for each element in ``x``, defining\n        the minimum and maximum values of that decision variable. Use ``None``\n        to indicate that there is no bound. By default, bounds are\n        ``(0, None)`` (all decision variables are non-negative).\n        If a single tuple ``(min, max)`` is provided, then ``min`` and\n        ``max`` will serve as bounds for all decision variables.\n    method : str\n        This is the method-specific documentation for \'revised simplex\'.\n        :ref:`\'highs\' <optimize.linprog-highs>`,\n        :ref:`\'highs-ds\' <optimize.linprog-highs-ds>`,\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`,\n        :ref:`\'interior-point\' <optimize.linprog-interior-point>` (default),\n        and :ref:`\'simplex\' <optimize.linprog-simplex>` (legacy)\n        are also available.\n    callback : callable, optional\n        Callback function to be executed once per iteration.\n    x0 : 1-D array, optional\n        Guess values of the decision variables, which will be refined by\n        the optimization algorithm. This argument is currently used only by the\n        \'revised simplex\' method, and can only be used if `x0` represents a\n        basic feasible solution.\n\n    Options\n    -------\n    maxiter : int (default: 5000)\n       The maximum number of iterations to perform in either phase.\n    disp : bool (default: False)\n        Set to ``True`` if indicators of optimization status are to be printed\n        to the console each iteration.\n    presolve : bool (default: True)\n        Presolve attempts to identify trivial infeasibilities,\n        identify trivial unboundedness, and simplify the problem before\n        sending it to the main solver. It is generally recommended\n        to keep the default setting ``True``; set to ``False`` if\n        presolve is to be disabled.\n    tol : float (default: 1e-12)\n        The tolerance which determines when a solution is "close enough" to\n        zero in Phase 1 to be considered a basic feasible solution or close\n        enough to positive to serve as an optimal solution.\n    autoscale : bool (default: False)\n        Set to ``True`` to automatically perform equilibration.\n        Consider using this option if the numerical values in the\n        constraints are separated by several orders of magnitude.\n    rr : bool (default: True)\n        Set to ``False`` to disable automatic redundancy removal.\n    maxupdate : int (default: 10)\n        The maximum number of updates performed on the LU factorization.\n        After this many updates is reached, the basis matrix is factorized\n        from scratch.\n    mast : bool (default: False)\n        Minimize Amortized Solve Time. If enabled, the average time to solve\n        a linear system using the basis factorization is measured. Typically,\n        the average solve time will decrease with each successive solve after\n        initial factorization, as factorization takes much more time than the\n        solve operation (and updates). Eventually, however, the updated\n        factorization becomes sufficiently complex that the average solve time\n        begins to increase. When this is detected, the basis is refactorized\n        from scratch. Enable this option to maximize speed at the risk of\n        nondeterministic behavior. Ignored if ``maxupdate`` is 0.\n    pivot : "mrc" or "bland" (default: "mrc")\n        Pivot rule: Minimum Reduced Cost ("mrc") or Bland\'s rule ("bland").\n        Choose Bland\'s rule if iteration limit is reached and cycling is\n        suspected.\n    unknown_options : dict\n        Optional arguments not used by this particular solver. If\n        `unknown_options` is non-empty a warning is issued listing all\n        unused options.\n\n    Returns\n    -------\n    res : OptimizeResult\n        A :class:`scipy.optimize.OptimizeResult` consisting of the fields:\n\n        x : 1-D array\n            The values of the decision variables that minimizes the\n            objective function while satisfying the constraints.\n        fun : float\n            The optimal value of the objective function ``c @ x``.\n        slack : 1-D array\n            The (nominally positive) values of the slack variables,\n            ``b_ub - A_ub @ x``.\n        con : 1-D array\n            The (nominally zero) residuals of the equality constraints,\n            ``b_eq - A_eq @ x``.\n        success : bool\n            ``True`` when the algorithm succeeds in finding an optimal\n            solution.\n        status : int\n            An integer representing the exit status of the algorithm.\n\n            ``0`` : Optimization terminated successfully.\n\n            ``1`` : Iteration limit reached.\n\n            ``2`` : Problem appears to be infeasible.\n\n            ``3`` : Problem appears to be unbounded.\n\n            ``4`` : Numerical difficulties encountered.\n\n            ``5`` : Problem has no constraints; turn presolve on.\n\n            ``6`` : Invalid guess provided.\n\n        message : str\n            A string descriptor of the exit status of the algorithm.\n        nit : int\n            The total number of iterations performed in all phases.\n\n\n    Notes\n    -----\n    Method *revised simplex* uses the revised simplex method as described in\n    [9]_, except that a factorization [11]_ of the basis matrix, rather than\n    its inverse, is efficiently maintained and used to solve the linear systems\n    at each iteration of the algorithm.\n\n    References\n    ----------\n    .. [9] Bertsimas, Dimitris, and J. Tsitsiklis. "Introduction to linear\n           programming." Athena Scientific 1 (1997): 997.\n    .. [11] Bartels, Richard H. "A stabilization of the simplex method."\n            Journal in  Numerische Mathematik 16.5 (1971): 414-434.\n    '
    pass

def _linprog_simplex_doc(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='interior-point', callback=None, maxiter=5000, disp=False, presolve=True, tol=1e-12, autoscale=False, rr=True, bland=False, **unknown_options):
    if False:
        print('Hello World!')
    '\n    Linear programming: minimize a linear objective function subject to linear\n    equality and inequality constraints using the tableau-based simplex method.\n\n    .. deprecated:: 1.9.0\n        `method=\'simplex\'` will be removed in SciPy 1.11.0.\n        It is replaced by `method=\'highs\'` because the latter is\n        faster and more robust.\n\n    Linear programming solves problems of the following form:\n\n    .. math::\n\n        \\min_x \\ & c^T x \\\\\n        \\mbox{such that} \\ & A_{ub} x \\leq b_{ub},\\\\\n        & A_{eq} x = b_{eq},\\\\\n        & l \\leq x \\leq u ,\n\n    where :math:`x` is a vector of decision variables; :math:`c`,\n    :math:`b_{ub}`, :math:`b_{eq}`, :math:`l`, and :math:`u` are vectors; and\n    :math:`A_{ub}` and :math:`A_{eq}` are matrices.\n\n    Alternatively, that\'s:\n\n    minimize::\n\n        c @ x\n\n    such that::\n\n        A_ub @ x <= b_ub\n        A_eq @ x == b_eq\n        lb <= x <= ub\n\n    Note that by default ``lb = 0`` and ``ub = None`` unless specified with\n    ``bounds``.\n\n    Parameters\n    ----------\n    c : 1-D array\n        The coefficients of the linear objective function to be minimized.\n    A_ub : 2-D array, optional\n        The inequality constraint matrix. Each row of ``A_ub`` specifies the\n        coefficients of a linear inequality constraint on ``x``.\n    b_ub : 1-D array, optional\n        The inequality constraint vector. Each element represents an\n        upper bound on the corresponding value of ``A_ub @ x``.\n    A_eq : 2-D array, optional\n        The equality constraint matrix. Each row of ``A_eq`` specifies the\n        coefficients of a linear equality constraint on ``x``.\n    b_eq : 1-D array, optional\n        The equality constraint vector. Each element of ``A_eq @ x`` must equal\n        the corresponding element of ``b_eq``.\n    bounds : sequence, optional\n        A sequence of ``(min, max)`` pairs for each element in ``x``, defining\n        the minimum and maximum values of that decision variable. Use ``None``\n        to indicate that there is no bound. By default, bounds are\n        ``(0, None)`` (all decision variables are non-negative).\n        If a single tuple ``(min, max)`` is provided, then ``min`` and\n        ``max`` will serve as bounds for all decision variables.\n    method : str\n        This is the method-specific documentation for \'simplex\'.\n        :ref:`\'highs\' <optimize.linprog-highs>`,\n        :ref:`\'highs-ds\' <optimize.linprog-highs-ds>`,\n        :ref:`\'highs-ipm\' <optimize.linprog-highs-ipm>`,\n        :ref:`\'interior-point\' <optimize.linprog-interior-point>` (default),\n        and :ref:`\'revised simplex\' <optimize.linprog-revised_simplex>`\n        are also available.\n    callback : callable, optional\n        Callback function to be executed once per iteration.\n\n    Options\n    -------\n    maxiter : int (default: 5000)\n       The maximum number of iterations to perform in either phase.\n    disp : bool (default: False)\n        Set to ``True`` if indicators of optimization status are to be printed\n        to the console each iteration.\n    presolve : bool (default: True)\n        Presolve attempts to identify trivial infeasibilities,\n        identify trivial unboundedness, and simplify the problem before\n        sending it to the main solver. It is generally recommended\n        to keep the default setting ``True``; set to ``False`` if\n        presolve is to be disabled.\n    tol : float (default: 1e-12)\n        The tolerance which determines when a solution is "close enough" to\n        zero in Phase 1 to be considered a basic feasible solution or close\n        enough to positive to serve as an optimal solution.\n    autoscale : bool (default: False)\n        Set to ``True`` to automatically perform equilibration.\n        Consider using this option if the numerical values in the\n        constraints are separated by several orders of magnitude.\n    rr : bool (default: True)\n        Set to ``False`` to disable automatic redundancy removal.\n    bland : bool\n        If True, use Bland\'s anti-cycling rule [3]_ to choose pivots to\n        prevent cycling. If False, choose pivots which should lead to a\n        converged solution more quickly. The latter method is subject to\n        cycling (non-convergence) in rare instances.\n    unknown_options : dict\n        Optional arguments not used by this particular solver. If\n        `unknown_options` is non-empty a warning is issued listing all\n        unused options.\n\n    Returns\n    -------\n    res : OptimizeResult\n        A :class:`scipy.optimize.OptimizeResult` consisting of the fields:\n\n        x : 1-D array\n            The values of the decision variables that minimizes the\n            objective function while satisfying the constraints.\n        fun : float\n            The optimal value of the objective function ``c @ x``.\n        slack : 1-D array\n            The (nominally positive) values of the slack variables,\n            ``b_ub - A_ub @ x``.\n        con : 1-D array\n            The (nominally zero) residuals of the equality constraints,\n            ``b_eq - A_eq @ x``.\n        success : bool\n            ``True`` when the algorithm succeeds in finding an optimal\n            solution.\n        status : int\n            An integer representing the exit status of the algorithm.\n\n            ``0`` : Optimization terminated successfully.\n\n            ``1`` : Iteration limit reached.\n\n            ``2`` : Problem appears to be infeasible.\n\n            ``3`` : Problem appears to be unbounded.\n\n            ``4`` : Numerical difficulties encountered.\n\n        message : str\n            A string descriptor of the exit status of the algorithm.\n        nit : int\n            The total number of iterations performed in all phases.\n\n    References\n    ----------\n    .. [1] Dantzig, George B., Linear programming and extensions. Rand\n           Corporation Research Study Princeton Univ. Press, Princeton, NJ,\n           1963\n    .. [2] Hillier, S.H. and Lieberman, G.J. (1995), "Introduction to\n           Mathematical Programming", McGraw-Hill, Chapter 4.\n    .. [3] Bland, Robert G. New finite pivoting rules for the simplex method.\n           Mathematics of Operations Research (2), 1977: pp. 103-107.\n    '
    pass