[
    {
        "func_name": "rolling_ball",
        "original": "def rolling_ball(image, *, radius=100, kernel=None, nansafe=False, num_threads=None):\n    \"\"\"Estimate background intensity by rolling/translating a kernel.\n\n    This rolling ball algorithm estimates background intensity for a\n    ndimage in case of uneven exposure. It is a generalization of the\n    frequently used rolling ball algorithm [1]_.\n\n    Parameters\n    ----------\n    image : ndarray\n        The image to be filtered.\n    radius : int, optional\n        Radius of a ball-shaped kernel to be rolled/translated in the image.\n        Used if ``kernel = None``.\n    kernel : ndarray, optional\n        The kernel to be rolled/translated in the image. It must have the\n        same number of dimensions as ``image``. Kernel is filled with the\n        intensity of the kernel at that position.\n    nansafe: bool, optional\n        If ``False`` (default) assumes that none of the values in ``image``\n        are ``np.nan``, and uses a faster implementation.\n    num_threads: int, optional\n        The maximum number of threads to use. If ``None`` use the OpenMP\n        default value; typically equal to the maximum number of virtual cores.\n        Note: This is an upper limit to the number of threads. The exact number\n        is determined by the system's OpenMP library.\n\n    Returns\n    -------\n    background : ndarray\n        The estimated background of the image.\n\n    Notes\n    -----\n    For the pixel that has its background intensity estimated (without loss\n    of generality at ``center``) the rolling ball method centers ``kernel``\n    under it and raises the kernel until the surface touches the image umbra\n    at some ``pos=(y,x)``. The background intensity is then estimated\n    using the image intensity at that position (``image[pos]``) plus the\n    difference of ``kernel[center] - kernel[pos]``.\n\n    This algorithm assumes that dark pixels correspond to the background. If\n    you have a bright background, invert the image before passing it to the\n    function, e.g., using `utils.invert`. See the gallery example for details.\n\n    This algorithm is sensitive to noise (in particular salt-and-pepper\n    noise). If this is a problem in your image, you can apply mild\n    gaussian smoothing before passing the image to this function.\n\n    References\n    ----------\n    .. [1] Sternberg, Stanley R. \"Biomedical image processing.\" Computer 1\n           (1983): 22-34. :DOI:`10.1109/MC.1983.1654163`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage import data\n    >>> from skimage.restoration import rolling_ball\n    >>> image = data.coins()\n    >>> background = rolling_ball(data.coins())\n    >>> filtered_image = image - background\n\n\n    >>> import numpy as np\n    >>> from skimage import data\n    >>> from skimage.restoration import rolling_ball, ellipsoid_kernel\n    >>> image = data.coins()\n    >>> kernel = ellipsoid_kernel((101, 101), 75)\n    >>> background = rolling_ball(data.coins(), kernel=kernel)\n    >>> filtered_image = image - background\n    \"\"\"\n    image = np.asarray(image)\n    float_type = _supported_float_type(image.dtype)\n    img = image.astype(float_type, copy=False)\n    if num_threads is None:\n        num_threads = 0\n    if kernel is None:\n        kernel = ball_kernel(radius, image.ndim)\n    kernel = kernel.astype(float_type)\n    kernel_shape = np.asarray(kernel.shape)\n    kernel_center = kernel_shape // 2\n    center_intensity = kernel[tuple(kernel_center)]\n    intensity_difference = center_intensity - kernel\n    intensity_difference[kernel == np.inf] = np.inf\n    intensity_difference = intensity_difference.astype(img.dtype)\n    intensity_difference = intensity_difference.reshape(-1)\n    img = np.pad(img, kernel_center[:, np.newaxis], constant_values=np.inf, mode='constant')\n    func = apply_kernel_nan if nansafe else apply_kernel\n    background = func(img.reshape(-1), intensity_difference, np.zeros_like(image, dtype=img.dtype).reshape(-1), np.array(image.shape, dtype=np.intp), np.array(img.shape, dtype=np.intp), kernel_shape.astype(np.intp), num_threads)\n    background = background.astype(image.dtype, copy=False)\n    return background",
        "mutated": [
            "def rolling_ball(image, *, radius=100, kernel=None, nansafe=False, num_threads=None):\n    if False:\n        i = 10\n    'Estimate background intensity by rolling/translating a kernel.\\n\\n    This rolling ball algorithm estimates background intensity for a\\n    ndimage in case of uneven exposure. It is a generalization of the\\n    frequently used rolling ball algorithm [1]_.\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        The image to be filtered.\\n    radius : int, optional\\n        Radius of a ball-shaped kernel to be rolled/translated in the image.\\n        Used if ``kernel = None``.\\n    kernel : ndarray, optional\\n        The kernel to be rolled/translated in the image. It must have the\\n        same number of dimensions as ``image``. Kernel is filled with the\\n        intensity of the kernel at that position.\\n    nansafe: bool, optional\\n        If ``False`` (default) assumes that none of the values in ``image``\\n        are ``np.nan``, and uses a faster implementation.\\n    num_threads: int, optional\\n        The maximum number of threads to use. If ``None`` use the OpenMP\\n        default value; typically equal to the maximum number of virtual cores.\\n        Note: This is an upper limit to the number of threads. The exact number\\n        is determined by the system\\'s OpenMP library.\\n\\n    Returns\\n    -------\\n    background : ndarray\\n        The estimated background of the image.\\n\\n    Notes\\n    -----\\n    For the pixel that has its background intensity estimated (without loss\\n    of generality at ``center``) the rolling ball method centers ``kernel``\\n    under it and raises the kernel until the surface touches the image umbra\\n    at some ``pos=(y,x)``. The background intensity is then estimated\\n    using the image intensity at that position (``image[pos]``) plus the\\n    difference of ``kernel[center] - kernel[pos]``.\\n\\n    This algorithm assumes that dark pixels correspond to the background. If\\n    you have a bright background, invert the image before passing it to the\\n    function, e.g., using `utils.invert`. See the gallery example for details.\\n\\n    This algorithm is sensitive to noise (in particular salt-and-pepper\\n    noise). If this is a problem in your image, you can apply mild\\n    gaussian smoothing before passing the image to this function.\\n\\n    References\\n    ----------\\n    .. [1] Sternberg, Stanley R. \"Biomedical image processing.\" Computer 1\\n           (1983): 22-34. :DOI:`10.1109/MC.1983.1654163`\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball\\n    >>> image = data.coins()\\n    >>> background = rolling_ball(data.coins())\\n    >>> filtered_image = image - background\\n\\n\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball, ellipsoid_kernel\\n    >>> image = data.coins()\\n    >>> kernel = ellipsoid_kernel((101, 101), 75)\\n    >>> background = rolling_ball(data.coins(), kernel=kernel)\\n    >>> filtered_image = image - background\\n    '\n    image = np.asarray(image)\n    float_type = _supported_float_type(image.dtype)\n    img = image.astype(float_type, copy=False)\n    if num_threads is None:\n        num_threads = 0\n    if kernel is None:\n        kernel = ball_kernel(radius, image.ndim)\n    kernel = kernel.astype(float_type)\n    kernel_shape = np.asarray(kernel.shape)\n    kernel_center = kernel_shape // 2\n    center_intensity = kernel[tuple(kernel_center)]\n    intensity_difference = center_intensity - kernel\n    intensity_difference[kernel == np.inf] = np.inf\n    intensity_difference = intensity_difference.astype(img.dtype)\n    intensity_difference = intensity_difference.reshape(-1)\n    img = np.pad(img, kernel_center[:, np.newaxis], constant_values=np.inf, mode='constant')\n    func = apply_kernel_nan if nansafe else apply_kernel\n    background = func(img.reshape(-1), intensity_difference, np.zeros_like(image, dtype=img.dtype).reshape(-1), np.array(image.shape, dtype=np.intp), np.array(img.shape, dtype=np.intp), kernel_shape.astype(np.intp), num_threads)\n    background = background.astype(image.dtype, copy=False)\n    return background",
            "def rolling_ball(image, *, radius=100, kernel=None, nansafe=False, num_threads=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Estimate background intensity by rolling/translating a kernel.\\n\\n    This rolling ball algorithm estimates background intensity for a\\n    ndimage in case of uneven exposure. It is a generalization of the\\n    frequently used rolling ball algorithm [1]_.\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        The image to be filtered.\\n    radius : int, optional\\n        Radius of a ball-shaped kernel to be rolled/translated in the image.\\n        Used if ``kernel = None``.\\n    kernel : ndarray, optional\\n        The kernel to be rolled/translated in the image. It must have the\\n        same number of dimensions as ``image``. Kernel is filled with the\\n        intensity of the kernel at that position.\\n    nansafe: bool, optional\\n        If ``False`` (default) assumes that none of the values in ``image``\\n        are ``np.nan``, and uses a faster implementation.\\n    num_threads: int, optional\\n        The maximum number of threads to use. If ``None`` use the OpenMP\\n        default value; typically equal to the maximum number of virtual cores.\\n        Note: This is an upper limit to the number of threads. The exact number\\n        is determined by the system\\'s OpenMP library.\\n\\n    Returns\\n    -------\\n    background : ndarray\\n        The estimated background of the image.\\n\\n    Notes\\n    -----\\n    For the pixel that has its background intensity estimated (without loss\\n    of generality at ``center``) the rolling ball method centers ``kernel``\\n    under it and raises the kernel until the surface touches the image umbra\\n    at some ``pos=(y,x)``. The background intensity is then estimated\\n    using the image intensity at that position (``image[pos]``) plus the\\n    difference of ``kernel[center] - kernel[pos]``.\\n\\n    This algorithm assumes that dark pixels correspond to the background. If\\n    you have a bright background, invert the image before passing it to the\\n    function, e.g., using `utils.invert`. See the gallery example for details.\\n\\n    This algorithm is sensitive to noise (in particular salt-and-pepper\\n    noise). If this is a problem in your image, you can apply mild\\n    gaussian smoothing before passing the image to this function.\\n\\n    References\\n    ----------\\n    .. [1] Sternberg, Stanley R. \"Biomedical image processing.\" Computer 1\\n           (1983): 22-34. :DOI:`10.1109/MC.1983.1654163`\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball\\n    >>> image = data.coins()\\n    >>> background = rolling_ball(data.coins())\\n    >>> filtered_image = image - background\\n\\n\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball, ellipsoid_kernel\\n    >>> image = data.coins()\\n    >>> kernel = ellipsoid_kernel((101, 101), 75)\\n    >>> background = rolling_ball(data.coins(), kernel=kernel)\\n    >>> filtered_image = image - background\\n    '\n    image = np.asarray(image)\n    float_type = _supported_float_type(image.dtype)\n    img = image.astype(float_type, copy=False)\n    if num_threads is None:\n        num_threads = 0\n    if kernel is None:\n        kernel = ball_kernel(radius, image.ndim)\n    kernel = kernel.astype(float_type)\n    kernel_shape = np.asarray(kernel.shape)\n    kernel_center = kernel_shape // 2\n    center_intensity = kernel[tuple(kernel_center)]\n    intensity_difference = center_intensity - kernel\n    intensity_difference[kernel == np.inf] = np.inf\n    intensity_difference = intensity_difference.astype(img.dtype)\n    intensity_difference = intensity_difference.reshape(-1)\n    img = np.pad(img, kernel_center[:, np.newaxis], constant_values=np.inf, mode='constant')\n    func = apply_kernel_nan if nansafe else apply_kernel\n    background = func(img.reshape(-1), intensity_difference, np.zeros_like(image, dtype=img.dtype).reshape(-1), np.array(image.shape, dtype=np.intp), np.array(img.shape, dtype=np.intp), kernel_shape.astype(np.intp), num_threads)\n    background = background.astype(image.dtype, copy=False)\n    return background",
            "def rolling_ball(image, *, radius=100, kernel=None, nansafe=False, num_threads=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Estimate background intensity by rolling/translating a kernel.\\n\\n    This rolling ball algorithm estimates background intensity for a\\n    ndimage in case of uneven exposure. It is a generalization of the\\n    frequently used rolling ball algorithm [1]_.\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        The image to be filtered.\\n    radius : int, optional\\n        Radius of a ball-shaped kernel to be rolled/translated in the image.\\n        Used if ``kernel = None``.\\n    kernel : ndarray, optional\\n        The kernel to be rolled/translated in the image. It must have the\\n        same number of dimensions as ``image``. Kernel is filled with the\\n        intensity of the kernel at that position.\\n    nansafe: bool, optional\\n        If ``False`` (default) assumes that none of the values in ``image``\\n        are ``np.nan``, and uses a faster implementation.\\n    num_threads: int, optional\\n        The maximum number of threads to use. If ``None`` use the OpenMP\\n        default value; typically equal to the maximum number of virtual cores.\\n        Note: This is an upper limit to the number of threads. The exact number\\n        is determined by the system\\'s OpenMP library.\\n\\n    Returns\\n    -------\\n    background : ndarray\\n        The estimated background of the image.\\n\\n    Notes\\n    -----\\n    For the pixel that has its background intensity estimated (without loss\\n    of generality at ``center``) the rolling ball method centers ``kernel``\\n    under it and raises the kernel until the surface touches the image umbra\\n    at some ``pos=(y,x)``. The background intensity is then estimated\\n    using the image intensity at that position (``image[pos]``) plus the\\n    difference of ``kernel[center] - kernel[pos]``.\\n\\n    This algorithm assumes that dark pixels correspond to the background. If\\n    you have a bright background, invert the image before passing it to the\\n    function, e.g., using `utils.invert`. See the gallery example for details.\\n\\n    This algorithm is sensitive to noise (in particular salt-and-pepper\\n    noise). If this is a problem in your image, you can apply mild\\n    gaussian smoothing before passing the image to this function.\\n\\n    References\\n    ----------\\n    .. [1] Sternberg, Stanley R. \"Biomedical image processing.\" Computer 1\\n           (1983): 22-34. :DOI:`10.1109/MC.1983.1654163`\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball\\n    >>> image = data.coins()\\n    >>> background = rolling_ball(data.coins())\\n    >>> filtered_image = image - background\\n\\n\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball, ellipsoid_kernel\\n    >>> image = data.coins()\\n    >>> kernel = ellipsoid_kernel((101, 101), 75)\\n    >>> background = rolling_ball(data.coins(), kernel=kernel)\\n    >>> filtered_image = image - background\\n    '\n    image = np.asarray(image)\n    float_type = _supported_float_type(image.dtype)\n    img = image.astype(float_type, copy=False)\n    if num_threads is None:\n        num_threads = 0\n    if kernel is None:\n        kernel = ball_kernel(radius, image.ndim)\n    kernel = kernel.astype(float_type)\n    kernel_shape = np.asarray(kernel.shape)\n    kernel_center = kernel_shape // 2\n    center_intensity = kernel[tuple(kernel_center)]\n    intensity_difference = center_intensity - kernel\n    intensity_difference[kernel == np.inf] = np.inf\n    intensity_difference = intensity_difference.astype(img.dtype)\n    intensity_difference = intensity_difference.reshape(-1)\n    img = np.pad(img, kernel_center[:, np.newaxis], constant_values=np.inf, mode='constant')\n    func = apply_kernel_nan if nansafe else apply_kernel\n    background = func(img.reshape(-1), intensity_difference, np.zeros_like(image, dtype=img.dtype).reshape(-1), np.array(image.shape, dtype=np.intp), np.array(img.shape, dtype=np.intp), kernel_shape.astype(np.intp), num_threads)\n    background = background.astype(image.dtype, copy=False)\n    return background",
            "def rolling_ball(image, *, radius=100, kernel=None, nansafe=False, num_threads=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Estimate background intensity by rolling/translating a kernel.\\n\\n    This rolling ball algorithm estimates background intensity for a\\n    ndimage in case of uneven exposure. It is a generalization of the\\n    frequently used rolling ball algorithm [1]_.\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        The image to be filtered.\\n    radius : int, optional\\n        Radius of a ball-shaped kernel to be rolled/translated in the image.\\n        Used if ``kernel = None``.\\n    kernel : ndarray, optional\\n        The kernel to be rolled/translated in the image. It must have the\\n        same number of dimensions as ``image``. Kernel is filled with the\\n        intensity of the kernel at that position.\\n    nansafe: bool, optional\\n        If ``False`` (default) assumes that none of the values in ``image``\\n        are ``np.nan``, and uses a faster implementation.\\n    num_threads: int, optional\\n        The maximum number of threads to use. If ``None`` use the OpenMP\\n        default value; typically equal to the maximum number of virtual cores.\\n        Note: This is an upper limit to the number of threads. The exact number\\n        is determined by the system\\'s OpenMP library.\\n\\n    Returns\\n    -------\\n    background : ndarray\\n        The estimated background of the image.\\n\\n    Notes\\n    -----\\n    For the pixel that has its background intensity estimated (without loss\\n    of generality at ``center``) the rolling ball method centers ``kernel``\\n    under it and raises the kernel until the surface touches the image umbra\\n    at some ``pos=(y,x)``. The background intensity is then estimated\\n    using the image intensity at that position (``image[pos]``) plus the\\n    difference of ``kernel[center] - kernel[pos]``.\\n\\n    This algorithm assumes that dark pixels correspond to the background. If\\n    you have a bright background, invert the image before passing it to the\\n    function, e.g., using `utils.invert`. See the gallery example for details.\\n\\n    This algorithm is sensitive to noise (in particular salt-and-pepper\\n    noise). If this is a problem in your image, you can apply mild\\n    gaussian smoothing before passing the image to this function.\\n\\n    References\\n    ----------\\n    .. [1] Sternberg, Stanley R. \"Biomedical image processing.\" Computer 1\\n           (1983): 22-34. :DOI:`10.1109/MC.1983.1654163`\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball\\n    >>> image = data.coins()\\n    >>> background = rolling_ball(data.coins())\\n    >>> filtered_image = image - background\\n\\n\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball, ellipsoid_kernel\\n    >>> image = data.coins()\\n    >>> kernel = ellipsoid_kernel((101, 101), 75)\\n    >>> background = rolling_ball(data.coins(), kernel=kernel)\\n    >>> filtered_image = image - background\\n    '\n    image = np.asarray(image)\n    float_type = _supported_float_type(image.dtype)\n    img = image.astype(float_type, copy=False)\n    if num_threads is None:\n        num_threads = 0\n    if kernel is None:\n        kernel = ball_kernel(radius, image.ndim)\n    kernel = kernel.astype(float_type)\n    kernel_shape = np.asarray(kernel.shape)\n    kernel_center = kernel_shape // 2\n    center_intensity = kernel[tuple(kernel_center)]\n    intensity_difference = center_intensity - kernel\n    intensity_difference[kernel == np.inf] = np.inf\n    intensity_difference = intensity_difference.astype(img.dtype)\n    intensity_difference = intensity_difference.reshape(-1)\n    img = np.pad(img, kernel_center[:, np.newaxis], constant_values=np.inf, mode='constant')\n    func = apply_kernel_nan if nansafe else apply_kernel\n    background = func(img.reshape(-1), intensity_difference, np.zeros_like(image, dtype=img.dtype).reshape(-1), np.array(image.shape, dtype=np.intp), np.array(img.shape, dtype=np.intp), kernel_shape.astype(np.intp), num_threads)\n    background = background.astype(image.dtype, copy=False)\n    return background",
            "def rolling_ball(image, *, radius=100, kernel=None, nansafe=False, num_threads=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Estimate background intensity by rolling/translating a kernel.\\n\\n    This rolling ball algorithm estimates background intensity for a\\n    ndimage in case of uneven exposure. It is a generalization of the\\n    frequently used rolling ball algorithm [1]_.\\n\\n    Parameters\\n    ----------\\n    image : ndarray\\n        The image to be filtered.\\n    radius : int, optional\\n        Radius of a ball-shaped kernel to be rolled/translated in the image.\\n        Used if ``kernel = None``.\\n    kernel : ndarray, optional\\n        The kernel to be rolled/translated in the image. It must have the\\n        same number of dimensions as ``image``. Kernel is filled with the\\n        intensity of the kernel at that position.\\n    nansafe: bool, optional\\n        If ``False`` (default) assumes that none of the values in ``image``\\n        are ``np.nan``, and uses a faster implementation.\\n    num_threads: int, optional\\n        The maximum number of threads to use. If ``None`` use the OpenMP\\n        default value; typically equal to the maximum number of virtual cores.\\n        Note: This is an upper limit to the number of threads. The exact number\\n        is determined by the system\\'s OpenMP library.\\n\\n    Returns\\n    -------\\n    background : ndarray\\n        The estimated background of the image.\\n\\n    Notes\\n    -----\\n    For the pixel that has its background intensity estimated (without loss\\n    of generality at ``center``) the rolling ball method centers ``kernel``\\n    under it and raises the kernel until the surface touches the image umbra\\n    at some ``pos=(y,x)``. The background intensity is then estimated\\n    using the image intensity at that position (``image[pos]``) plus the\\n    difference of ``kernel[center] - kernel[pos]``.\\n\\n    This algorithm assumes that dark pixels correspond to the background. If\\n    you have a bright background, invert the image before passing it to the\\n    function, e.g., using `utils.invert`. See the gallery example for details.\\n\\n    This algorithm is sensitive to noise (in particular salt-and-pepper\\n    noise). If this is a problem in your image, you can apply mild\\n    gaussian smoothing before passing the image to this function.\\n\\n    References\\n    ----------\\n    .. [1] Sternberg, Stanley R. \"Biomedical image processing.\" Computer 1\\n           (1983): 22-34. :DOI:`10.1109/MC.1983.1654163`\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball\\n    >>> image = data.coins()\\n    >>> background = rolling_ball(data.coins())\\n    >>> filtered_image = image - background\\n\\n\\n    >>> import numpy as np\\n    >>> from skimage import data\\n    >>> from skimage.restoration import rolling_ball, ellipsoid_kernel\\n    >>> image = data.coins()\\n    >>> kernel = ellipsoid_kernel((101, 101), 75)\\n    >>> background = rolling_ball(data.coins(), kernel=kernel)\\n    >>> filtered_image = image - background\\n    '\n    image = np.asarray(image)\n    float_type = _supported_float_type(image.dtype)\n    img = image.astype(float_type, copy=False)\n    if num_threads is None:\n        num_threads = 0\n    if kernel is None:\n        kernel = ball_kernel(radius, image.ndim)\n    kernel = kernel.astype(float_type)\n    kernel_shape = np.asarray(kernel.shape)\n    kernel_center = kernel_shape // 2\n    center_intensity = kernel[tuple(kernel_center)]\n    intensity_difference = center_intensity - kernel\n    intensity_difference[kernel == np.inf] = np.inf\n    intensity_difference = intensity_difference.astype(img.dtype)\n    intensity_difference = intensity_difference.reshape(-1)\n    img = np.pad(img, kernel_center[:, np.newaxis], constant_values=np.inf, mode='constant')\n    func = apply_kernel_nan if nansafe else apply_kernel\n    background = func(img.reshape(-1), intensity_difference, np.zeros_like(image, dtype=img.dtype).reshape(-1), np.array(image.shape, dtype=np.intp), np.array(img.shape, dtype=np.intp), kernel_shape.astype(np.intp), num_threads)\n    background = background.astype(image.dtype, copy=False)\n    return background"
        ]
    },
    {
        "func_name": "ball_kernel",
        "original": "def ball_kernel(radius, ndim):\n    \"\"\"Create a ball kernel for restoration.rolling_ball.\n\n    Parameters\n    ----------\n    radius : int\n        Radius of the ball.\n    ndim : int\n        Number of dimensions of the ball. ``ndim`` should match the\n        dimensionality of the image the kernel will be applied to.\n\n    Returns\n    -------\n    kernel : ndarray\n        The kernel containing the surface intensity of the top half\n        of the ellipsoid.\n\n    See Also\n    --------\n    rolling_ball\n    \"\"\"\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in [np.ceil(radius)] * ndim], indexing='ij'), axis=-1)\n    sum_of_squares = np.sum(kernel_coords ** 2, axis=-1)\n    distance_from_center = np.sqrt(sum_of_squares)\n    kernel = np.sqrt(np.clip(radius ** 2 - sum_of_squares, 0, None))\n    kernel[distance_from_center > radius] = np.inf\n    return kernel",
        "mutated": [
            "def ball_kernel(radius, ndim):\n    if False:\n        i = 10\n    'Create a ball kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    radius : int\\n        Radius of the ball.\\n    ndim : int\\n        Number of dimensions of the ball. ``ndim`` should match the\\n        dimensionality of the image the kernel will be applied to.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in [np.ceil(radius)] * ndim], indexing='ij'), axis=-1)\n    sum_of_squares = np.sum(kernel_coords ** 2, axis=-1)\n    distance_from_center = np.sqrt(sum_of_squares)\n    kernel = np.sqrt(np.clip(radius ** 2 - sum_of_squares, 0, None))\n    kernel[distance_from_center > radius] = np.inf\n    return kernel",
            "def ball_kernel(radius, ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create a ball kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    radius : int\\n        Radius of the ball.\\n    ndim : int\\n        Number of dimensions of the ball. ``ndim`` should match the\\n        dimensionality of the image the kernel will be applied to.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in [np.ceil(radius)] * ndim], indexing='ij'), axis=-1)\n    sum_of_squares = np.sum(kernel_coords ** 2, axis=-1)\n    distance_from_center = np.sqrt(sum_of_squares)\n    kernel = np.sqrt(np.clip(radius ** 2 - sum_of_squares, 0, None))\n    kernel[distance_from_center > radius] = np.inf\n    return kernel",
            "def ball_kernel(radius, ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create a ball kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    radius : int\\n        Radius of the ball.\\n    ndim : int\\n        Number of dimensions of the ball. ``ndim`` should match the\\n        dimensionality of the image the kernel will be applied to.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in [np.ceil(radius)] * ndim], indexing='ij'), axis=-1)\n    sum_of_squares = np.sum(kernel_coords ** 2, axis=-1)\n    distance_from_center = np.sqrt(sum_of_squares)\n    kernel = np.sqrt(np.clip(radius ** 2 - sum_of_squares, 0, None))\n    kernel[distance_from_center > radius] = np.inf\n    return kernel",
            "def ball_kernel(radius, ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create a ball kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    radius : int\\n        Radius of the ball.\\n    ndim : int\\n        Number of dimensions of the ball. ``ndim`` should match the\\n        dimensionality of the image the kernel will be applied to.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in [np.ceil(radius)] * ndim], indexing='ij'), axis=-1)\n    sum_of_squares = np.sum(kernel_coords ** 2, axis=-1)\n    distance_from_center = np.sqrt(sum_of_squares)\n    kernel = np.sqrt(np.clip(radius ** 2 - sum_of_squares, 0, None))\n    kernel[distance_from_center > radius] = np.inf\n    return kernel",
            "def ball_kernel(radius, ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create a ball kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    radius : int\\n        Radius of the ball.\\n    ndim : int\\n        Number of dimensions of the ball. ``ndim`` should match the\\n        dimensionality of the image the kernel will be applied to.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in [np.ceil(radius)] * ndim], indexing='ij'), axis=-1)\n    sum_of_squares = np.sum(kernel_coords ** 2, axis=-1)\n    distance_from_center = np.sqrt(sum_of_squares)\n    kernel = np.sqrt(np.clip(radius ** 2 - sum_of_squares, 0, None))\n    kernel[distance_from_center > radius] = np.inf\n    return kernel"
        ]
    },
    {
        "func_name": "ellipsoid_kernel",
        "original": "def ellipsoid_kernel(shape, intensity):\n    \"\"\"Create an ellipoid kernel for restoration.rolling_ball.\n\n    Parameters\n    ----------\n    shape : array-like\n        Length of the principal axis of the ellipsoid (excluding\n        the intensity axis). The kernel needs to have the same\n        dimensionality as the image it will be applied to.\n    intensity : int\n        Length of the intensity axis of the ellipsoid.\n\n    Returns\n    -------\n    kernel : ndarray\n        The kernel containing the surface intensity of the top half\n        of the ellipsoid.\n\n    See Also\n    --------\n    rolling_ball\n    \"\"\"\n    shape = np.asarray(shape)\n    semi_axis = np.clip(shape // 2, 1, None)\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in semi_axis], indexing='ij'), axis=-1)\n    intensity_scaling = 1 - np.sum((kernel_coords / semi_axis) ** 2, axis=-1)\n    kernel = intensity * np.sqrt(np.clip(intensity_scaling, 0, None))\n    kernel[intensity_scaling < 0] = np.inf\n    return kernel",
        "mutated": [
            "def ellipsoid_kernel(shape, intensity):\n    if False:\n        i = 10\n    'Create an ellipoid kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    shape : array-like\\n        Length of the principal axis of the ellipsoid (excluding\\n        the intensity axis). The kernel needs to have the same\\n        dimensionality as the image it will be applied to.\\n    intensity : int\\n        Length of the intensity axis of the ellipsoid.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    shape = np.asarray(shape)\n    semi_axis = np.clip(shape // 2, 1, None)\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in semi_axis], indexing='ij'), axis=-1)\n    intensity_scaling = 1 - np.sum((kernel_coords / semi_axis) ** 2, axis=-1)\n    kernel = intensity * np.sqrt(np.clip(intensity_scaling, 0, None))\n    kernel[intensity_scaling < 0] = np.inf\n    return kernel",
            "def ellipsoid_kernel(shape, intensity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create an ellipoid kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    shape : array-like\\n        Length of the principal axis of the ellipsoid (excluding\\n        the intensity axis). The kernel needs to have the same\\n        dimensionality as the image it will be applied to.\\n    intensity : int\\n        Length of the intensity axis of the ellipsoid.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    shape = np.asarray(shape)\n    semi_axis = np.clip(shape // 2, 1, None)\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in semi_axis], indexing='ij'), axis=-1)\n    intensity_scaling = 1 - np.sum((kernel_coords / semi_axis) ** 2, axis=-1)\n    kernel = intensity * np.sqrt(np.clip(intensity_scaling, 0, None))\n    kernel[intensity_scaling < 0] = np.inf\n    return kernel",
            "def ellipsoid_kernel(shape, intensity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create an ellipoid kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    shape : array-like\\n        Length of the principal axis of the ellipsoid (excluding\\n        the intensity axis). The kernel needs to have the same\\n        dimensionality as the image it will be applied to.\\n    intensity : int\\n        Length of the intensity axis of the ellipsoid.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    shape = np.asarray(shape)\n    semi_axis = np.clip(shape // 2, 1, None)\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in semi_axis], indexing='ij'), axis=-1)\n    intensity_scaling = 1 - np.sum((kernel_coords / semi_axis) ** 2, axis=-1)\n    kernel = intensity * np.sqrt(np.clip(intensity_scaling, 0, None))\n    kernel[intensity_scaling < 0] = np.inf\n    return kernel",
            "def ellipsoid_kernel(shape, intensity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create an ellipoid kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    shape : array-like\\n        Length of the principal axis of the ellipsoid (excluding\\n        the intensity axis). The kernel needs to have the same\\n        dimensionality as the image it will be applied to.\\n    intensity : int\\n        Length of the intensity axis of the ellipsoid.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    shape = np.asarray(shape)\n    semi_axis = np.clip(shape // 2, 1, None)\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in semi_axis], indexing='ij'), axis=-1)\n    intensity_scaling = 1 - np.sum((kernel_coords / semi_axis) ** 2, axis=-1)\n    kernel = intensity * np.sqrt(np.clip(intensity_scaling, 0, None))\n    kernel[intensity_scaling < 0] = np.inf\n    return kernel",
            "def ellipsoid_kernel(shape, intensity):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create an ellipoid kernel for restoration.rolling_ball.\\n\\n    Parameters\\n    ----------\\n    shape : array-like\\n        Length of the principal axis of the ellipsoid (excluding\\n        the intensity axis). The kernel needs to have the same\\n        dimensionality as the image it will be applied to.\\n    intensity : int\\n        Length of the intensity axis of the ellipsoid.\\n\\n    Returns\\n    -------\\n    kernel : ndarray\\n        The kernel containing the surface intensity of the top half\\n        of the ellipsoid.\\n\\n    See Also\\n    --------\\n    rolling_ball\\n    '\n    shape = np.asarray(shape)\n    semi_axis = np.clip(shape // 2, 1, None)\n    kernel_coords = np.stack(np.meshgrid(*[np.arange(-x, x + 1) for x in semi_axis], indexing='ij'), axis=-1)\n    intensity_scaling = 1 - np.sum((kernel_coords / semi_axis) ** 2, axis=-1)\n    kernel = intensity * np.sqrt(np.clip(intensity_scaling, 0, None))\n    kernel[intensity_scaling < 0] = np.inf\n    return kernel"
        ]
    }
]