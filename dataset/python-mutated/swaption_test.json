[
    {
        "func_name": "zero_rate_fn",
        "original": "def zero_rate_fn(t):\n    return 0.01 * tf.ones_like(t)",
        "mutated": [
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n    return 0.01 * tf.ones_like(t)",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 0.01 * tf.ones_like(t)",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 0.01 * tf.ones_like(t)",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 0.01 * tf.ones_like(t)",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 0.01 * tf.ones_like(t)"
        ]
    },
    {
        "func_name": "setUp",
        "original": "def setUp(self):\n    self.mean_reversion_1d = 0.03\n    self.volatility_1d = 0.02\n    self.volatility_time_dep_1d = [0.01, 0.02]\n    self.mean_reversion_2d = [0.03, 0.03]\n    self.volatility_2d = [0.02, 0.02]\n    self.expiries = np.array(1.0)\n    self.float_leg_start_times = np.array([1.0, 1.25, 1.5, 1.75])\n    self.float_leg_end_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.float_leg_daycount_fractions = 0.25 * np.ones_like(self.float_leg_start_times)\n    self.fixed_leg_daycount_fractions = 0.25 * np.ones_like(self.fixed_leg_payment_times)\n    self.fixed_leg_coupon = 0.011 * np.ones_like(self.fixed_leg_payment_times)\n    self.expiries_1d = np.array([1.0, 1.0])\n    self.float_leg_start_times_1d = np.array([[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]])\n    self.float_leg_end_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.fixed_leg_payment_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.float_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.float_leg_start_times_1d)\n    self.fixed_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.fixed_leg_coupon_1d = 0.011 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.expiries_2d = np.array([[0.5, 1.5], [1.0, 1.25]])\n    self.float_leg_start_times_2d = np.array([[[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]], [[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]]])\n    self.float_leg_end_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.float_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.float_leg_start_times_2d)\n    self.fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.fixed_leg_payment_times_2d)\n    self.fixed_leg_coupon_2d = 0.011 * np.ones_like(self.fixed_leg_payment_times_2d)\n\n    def zero_rate_fn(t):\n        return 0.01 * tf.ones_like(t)\n    self.zero_rate_fn = zero_rate_fn\n    super(HullWhiteSwaptionTest, self).setUp()",
        "mutated": [
            "def setUp(self):\n    if False:\n        i = 10\n    self.mean_reversion_1d = 0.03\n    self.volatility_1d = 0.02\n    self.volatility_time_dep_1d = [0.01, 0.02]\n    self.mean_reversion_2d = [0.03, 0.03]\n    self.volatility_2d = [0.02, 0.02]\n    self.expiries = np.array(1.0)\n    self.float_leg_start_times = np.array([1.0, 1.25, 1.5, 1.75])\n    self.float_leg_end_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.float_leg_daycount_fractions = 0.25 * np.ones_like(self.float_leg_start_times)\n    self.fixed_leg_daycount_fractions = 0.25 * np.ones_like(self.fixed_leg_payment_times)\n    self.fixed_leg_coupon = 0.011 * np.ones_like(self.fixed_leg_payment_times)\n    self.expiries_1d = np.array([1.0, 1.0])\n    self.float_leg_start_times_1d = np.array([[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]])\n    self.float_leg_end_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.fixed_leg_payment_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.float_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.float_leg_start_times_1d)\n    self.fixed_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.fixed_leg_coupon_1d = 0.011 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.expiries_2d = np.array([[0.5, 1.5], [1.0, 1.25]])\n    self.float_leg_start_times_2d = np.array([[[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]], [[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]]])\n    self.float_leg_end_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.float_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.float_leg_start_times_2d)\n    self.fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.fixed_leg_payment_times_2d)\n    self.fixed_leg_coupon_2d = 0.011 * np.ones_like(self.fixed_leg_payment_times_2d)\n\n    def zero_rate_fn(t):\n        return 0.01 * tf.ones_like(t)\n    self.zero_rate_fn = zero_rate_fn\n    super(HullWhiteSwaptionTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.mean_reversion_1d = 0.03\n    self.volatility_1d = 0.02\n    self.volatility_time_dep_1d = [0.01, 0.02]\n    self.mean_reversion_2d = [0.03, 0.03]\n    self.volatility_2d = [0.02, 0.02]\n    self.expiries = np.array(1.0)\n    self.float_leg_start_times = np.array([1.0, 1.25, 1.5, 1.75])\n    self.float_leg_end_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.float_leg_daycount_fractions = 0.25 * np.ones_like(self.float_leg_start_times)\n    self.fixed_leg_daycount_fractions = 0.25 * np.ones_like(self.fixed_leg_payment_times)\n    self.fixed_leg_coupon = 0.011 * np.ones_like(self.fixed_leg_payment_times)\n    self.expiries_1d = np.array([1.0, 1.0])\n    self.float_leg_start_times_1d = np.array([[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]])\n    self.float_leg_end_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.fixed_leg_payment_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.float_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.float_leg_start_times_1d)\n    self.fixed_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.fixed_leg_coupon_1d = 0.011 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.expiries_2d = np.array([[0.5, 1.5], [1.0, 1.25]])\n    self.float_leg_start_times_2d = np.array([[[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]], [[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]]])\n    self.float_leg_end_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.float_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.float_leg_start_times_2d)\n    self.fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.fixed_leg_payment_times_2d)\n    self.fixed_leg_coupon_2d = 0.011 * np.ones_like(self.fixed_leg_payment_times_2d)\n\n    def zero_rate_fn(t):\n        return 0.01 * tf.ones_like(t)\n    self.zero_rate_fn = zero_rate_fn\n    super(HullWhiteSwaptionTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.mean_reversion_1d = 0.03\n    self.volatility_1d = 0.02\n    self.volatility_time_dep_1d = [0.01, 0.02]\n    self.mean_reversion_2d = [0.03, 0.03]\n    self.volatility_2d = [0.02, 0.02]\n    self.expiries = np.array(1.0)\n    self.float_leg_start_times = np.array([1.0, 1.25, 1.5, 1.75])\n    self.float_leg_end_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.float_leg_daycount_fractions = 0.25 * np.ones_like(self.float_leg_start_times)\n    self.fixed_leg_daycount_fractions = 0.25 * np.ones_like(self.fixed_leg_payment_times)\n    self.fixed_leg_coupon = 0.011 * np.ones_like(self.fixed_leg_payment_times)\n    self.expiries_1d = np.array([1.0, 1.0])\n    self.float_leg_start_times_1d = np.array([[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]])\n    self.float_leg_end_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.fixed_leg_payment_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.float_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.float_leg_start_times_1d)\n    self.fixed_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.fixed_leg_coupon_1d = 0.011 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.expiries_2d = np.array([[0.5, 1.5], [1.0, 1.25]])\n    self.float_leg_start_times_2d = np.array([[[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]], [[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]]])\n    self.float_leg_end_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.float_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.float_leg_start_times_2d)\n    self.fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.fixed_leg_payment_times_2d)\n    self.fixed_leg_coupon_2d = 0.011 * np.ones_like(self.fixed_leg_payment_times_2d)\n\n    def zero_rate_fn(t):\n        return 0.01 * tf.ones_like(t)\n    self.zero_rate_fn = zero_rate_fn\n    super(HullWhiteSwaptionTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.mean_reversion_1d = 0.03\n    self.volatility_1d = 0.02\n    self.volatility_time_dep_1d = [0.01, 0.02]\n    self.mean_reversion_2d = [0.03, 0.03]\n    self.volatility_2d = [0.02, 0.02]\n    self.expiries = np.array(1.0)\n    self.float_leg_start_times = np.array([1.0, 1.25, 1.5, 1.75])\n    self.float_leg_end_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.float_leg_daycount_fractions = 0.25 * np.ones_like(self.float_leg_start_times)\n    self.fixed_leg_daycount_fractions = 0.25 * np.ones_like(self.fixed_leg_payment_times)\n    self.fixed_leg_coupon = 0.011 * np.ones_like(self.fixed_leg_payment_times)\n    self.expiries_1d = np.array([1.0, 1.0])\n    self.float_leg_start_times_1d = np.array([[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]])\n    self.float_leg_end_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.fixed_leg_payment_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.float_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.float_leg_start_times_1d)\n    self.fixed_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.fixed_leg_coupon_1d = 0.011 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.expiries_2d = np.array([[0.5, 1.5], [1.0, 1.25]])\n    self.float_leg_start_times_2d = np.array([[[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]], [[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]]])\n    self.float_leg_end_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.float_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.float_leg_start_times_2d)\n    self.fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.fixed_leg_payment_times_2d)\n    self.fixed_leg_coupon_2d = 0.011 * np.ones_like(self.fixed_leg_payment_times_2d)\n\n    def zero_rate_fn(t):\n        return 0.01 * tf.ones_like(t)\n    self.zero_rate_fn = zero_rate_fn\n    super(HullWhiteSwaptionTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.mean_reversion_1d = 0.03\n    self.volatility_1d = 0.02\n    self.volatility_time_dep_1d = [0.01, 0.02]\n    self.mean_reversion_2d = [0.03, 0.03]\n    self.volatility_2d = [0.02, 0.02]\n    self.expiries = np.array(1.0)\n    self.float_leg_start_times = np.array([1.0, 1.25, 1.5, 1.75])\n    self.float_leg_end_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    self.float_leg_daycount_fractions = 0.25 * np.ones_like(self.float_leg_start_times)\n    self.fixed_leg_daycount_fractions = 0.25 * np.ones_like(self.fixed_leg_payment_times)\n    self.fixed_leg_coupon = 0.011 * np.ones_like(self.fixed_leg_payment_times)\n    self.expiries_1d = np.array([1.0, 1.0])\n    self.float_leg_start_times_1d = np.array([[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]])\n    self.float_leg_end_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.fixed_leg_payment_times_1d = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    self.float_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.float_leg_start_times_1d)\n    self.fixed_leg_daycount_fractions_1d = 0.25 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.fixed_leg_coupon_1d = 0.011 * np.ones_like(self.fixed_leg_payment_times_1d)\n    self.expiries_2d = np.array([[0.5, 1.5], [1.0, 1.25]])\n    self.float_leg_start_times_2d = np.array([[[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]], [[1.0, 1.25, 1.5, 1.75], [1.0, 1.25, 1.5, 1.75]]])\n    self.float_leg_end_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    self.float_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.float_leg_start_times_2d)\n    self.fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(self.fixed_leg_payment_times_2d)\n    self.fixed_leg_coupon_2d = 0.011 * np.ones_like(self.fixed_leg_payment_times_2d)\n\n    def zero_rate_fn(t):\n        return 0.01 * tf.ones_like(t)\n    self.zero_rate_fn = zero_rate_fn\n    super(HullWhiteSwaptionTest, self).setUp()"
        ]
    },
    {
        "func_name": "test_correctness",
        "original": "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_correctness(self, use_analytic_pricing, error_tol):\n    \"\"\"Tests model with constant parameters in 1 dimension.\"\"\"\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.71632434, rtol=error_tol, atol=error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_correctness(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.71632434, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_correctness(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.71632434, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_correctness(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.71632434, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_correctness(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.71632434, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_correctness(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.71632434, rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_receiver_1d",
        "original": "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.005})\ndef test_receiver_1d(self, use_analytic_pricing, error_tol):\n    \"\"\"Tests model with constant parameters in 1 dimension.\"\"\"\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, is_payer_swaption=False, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.813482544626056, rtol=error_tol, atol=error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.005})\ndef test_receiver_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, is_payer_swaption=False, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.813482544626056, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.005})\ndef test_receiver_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, is_payer_swaption=False, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.813482544626056, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.005})\ndef test_receiver_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, is_payer_swaption=False, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.813482544626056, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.005})\ndef test_receiver_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, is_payer_swaption=False, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.813482544626056, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.005})\ndef test_receiver_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, is_payer_swaption=False, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.813482544626056, rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_time_dep_1d",
        "original": "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_time_dep_1d(self, use_analytic_pricing, error_tol):\n    \"\"\"Tests model with time-dependent parameters in 1 dimension.\"\"\"\n    dtype = tf.float64\n    volatility = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=self.volatility_time_dep_1d, dtype=dtype)\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=volatility, use_analytic_pricing=use_analytic_pricing, num_samples=1000000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.5593057004094042, rtol=error_tol, atol=error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_time_dep_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    volatility = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=self.volatility_time_dep_1d, dtype=dtype)\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=volatility, use_analytic_pricing=use_analytic_pricing, num_samples=1000000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.5593057004094042, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_time_dep_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    volatility = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=self.volatility_time_dep_1d, dtype=dtype)\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=volatility, use_analytic_pricing=use_analytic_pricing, num_samples=1000000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.5593057004094042, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_time_dep_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    volatility = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=self.volatility_time_dep_1d, dtype=dtype)\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=volatility, use_analytic_pricing=use_analytic_pricing, num_samples=1000000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.5593057004094042, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_time_dep_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    volatility = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=self.volatility_time_dep_1d, dtype=dtype)\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=volatility, use_analytic_pricing=use_analytic_pricing, num_samples=1000000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.5593057004094042, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_time_dep_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    volatility = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=self.volatility_time_dep_1d, dtype=dtype)\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries, floating_leg_start_times=self.float_leg_start_times, floating_leg_end_times=self.float_leg_end_times, fixed_leg_payment_times=self.fixed_leg_payment_times, floating_leg_daycount_fractions=self.float_leg_daycount_fractions, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions, fixed_leg_coupon=self.fixed_leg_coupon, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=volatility, use_analytic_pricing=use_analytic_pricing, num_samples=1000000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [])\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.5593057004094042, rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_1d_batch_1d",
        "original": "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_1d_batch_1d(self, use_analytic_pricing, error_tol):\n    \"\"\"Tests 1-d batch.\"\"\"\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 0.7163243383624043], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_1d_batch_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n    'Tests 1-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_1d_batch_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests 1-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_1d_batch_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests 1-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_1d_batch_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests 1-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_1d_batch_1d(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests 1-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 0.7163243383624043], rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_1d_batch_1d_notional",
        "original": "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.01})\ndef test_1d_batch_1d_notional(self, use_analytic_pricing, error_tol):\n    \"\"\"Tests 1-d batch with different notionals.\"\"\"\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=[100.0, 200.0], mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=100000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.01})\ndef test_1d_batch_1d_notional(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=[100.0, 200.0], mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=100000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.01})\ndef test_1d_batch_1d_notional(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=[100.0, 200.0], mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=100000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.01})\ndef test_1d_batch_1d_notional(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=[100.0, 200.0], mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=100000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.01})\ndef test_1d_batch_1d_notional(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=[100.0, 200.0], mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=100000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.01})\ndef test_1d_batch_1d_notional(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_1d, floating_leg_start_times=self.float_leg_start_times_1d, floating_leg_end_times=self.float_leg_end_times_1d, fixed_leg_payment_times=self.fixed_leg_payment_times_1d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_1d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_1d, fixed_leg_coupon=self.fixed_leg_coupon_1d, reference_rate_fn=self.zero_rate_fn, notional=[100.0, 200.0], mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=100000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_2d_batch",
        "original": "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_2d_batch(self, use_analytic_pricing, error_tol):\n    \"\"\"Tests 2-d batch.\"\"\"\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_2d, floating_leg_start_times=self.float_leg_start_times_2d, floating_leg_end_times=self.float_leg_end_times_2d, fixed_leg_payment_times=self.fixed_leg_payment_times_2d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_2d, fixed_leg_coupon=self.fixed_leg_coupon_2d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[1.02849462, 0.22811866], [0.71632434, 0.48142959]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_2d_batch(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_2d, floating_leg_start_times=self.float_leg_start_times_2d, floating_leg_end_times=self.float_leg_end_times_2d, fixed_leg_payment_times=self.fixed_leg_payment_times_2d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_2d, fixed_leg_coupon=self.fixed_leg_coupon_2d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[1.02849462, 0.22811866], [0.71632434, 0.48142959]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_2d_batch(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_2d, floating_leg_start_times=self.float_leg_start_times_2d, floating_leg_end_times=self.float_leg_end_times_2d, fixed_leg_payment_times=self.fixed_leg_payment_times_2d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_2d, fixed_leg_coupon=self.fixed_leg_coupon_2d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[1.02849462, 0.22811866], [0.71632434, 0.48142959]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_2d_batch(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_2d, floating_leg_start_times=self.float_leg_start_times_2d, floating_leg_end_times=self.float_leg_end_times_2d, fixed_leg_payment_times=self.fixed_leg_payment_times_2d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_2d, fixed_leg_coupon=self.fixed_leg_coupon_2d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[1.02849462, 0.22811866], [0.71632434, 0.48142959]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_2d_batch(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_2d, floating_leg_start_times=self.float_leg_start_times_2d, floating_leg_end_times=self.float_leg_end_times_2d, fixed_leg_payment_times=self.fixed_leg_payment_times_2d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_2d, fixed_leg_coupon=self.fixed_leg_coupon_2d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[1.02849462, 0.22811866], [0.71632434, 0.48142959]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'analytic', 'use_analytic_pricing': True, 'error_tol': 1e-08}, {'testcase_name': 'simulation', 'use_analytic_pricing': False, 'error_tol': 0.001})\ndef test_2d_batch(self, use_analytic_pricing, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    price = tff.models.hull_white.swaption_price(expiries=self.expiries_2d, floating_leg_start_times=self.float_leg_start_times_2d, floating_leg_end_times=self.float_leg_end_times_2d, fixed_leg_payment_times=self.fixed_leg_payment_times_2d, floating_leg_daycount_fractions=self.float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions_2d, fixed_leg_coupon=self.fixed_leg_coupon_2d, reference_rate_fn=self.zero_rate_fn, notional=100.0, mean_reversion=self.mean_reversion_1d, volatility=self.volatility_1d, use_analytic_pricing=use_analytic_pricing, num_samples=500000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[4, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[1.02849462, 0.22811866], [0.71632434, 0.48142959]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)"
        ]
    }
]