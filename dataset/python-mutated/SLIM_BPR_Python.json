[
    {
        "func_name": "__init__",
        "original": "def __init__(self, URM_train):\n    super(SLIM_BPR_Python, self).__init__(URM_train)",
        "mutated": [
            "def __init__(self, URM_train):\n    if False:\n        i = 10\n    super(SLIM_BPR_Python, self).__init__(URM_train)",
            "def __init__(self, URM_train):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(SLIM_BPR_Python, self).__init__(URM_train)",
            "def __init__(self, URM_train):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(SLIM_BPR_Python, self).__init__(URM_train)",
            "def __init__(self, URM_train):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(SLIM_BPR_Python, self).__init__(URM_train)",
            "def __init__(self, URM_train):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(SLIM_BPR_Python, self).__init__(URM_train)"
        ]
    },
    {
        "func_name": "fit",
        "original": "def fit(self, topK=100, epochs=25, lambda_i=0.0025, lambda_j=0.00025, learning_rate=0.05):\n    \"\"\"\n\n        :param topK:\n        :param epochs:\n        :param lambda_i:\n        :param lambda_j:\n        :param learning_rate:\n        :return:\n        \"\"\"\n    self.item_item_S = np.zeros((self.n_items, self.n_items), dtype=np.float)\n    self.lambda_i = lambda_i\n    self.lambda_j = lambda_j\n    self.learning_rate = learning_rate\n    start_time_train = time.time()\n    for n_epoch in range(epochs):\n        self._run_epoch(n_epoch)\n    print('Train completed in {:.2f} minutes'.format(float(time.time() - start_time_train) / 60))\n    self.W_sparse = similarityMatrixTopK(self.item_item_S, k=topK, verbose=False)\n    self.W_sparse = sps.csr_matrix(self.W_sparse)",
        "mutated": [
            "def fit(self, topK=100, epochs=25, lambda_i=0.0025, lambda_j=0.00025, learning_rate=0.05):\n    if False:\n        i = 10\n    '\\n\\n        :param topK:\\n        :param epochs:\\n        :param lambda_i:\\n        :param lambda_j:\\n        :param learning_rate:\\n        :return:\\n        '\n    self.item_item_S = np.zeros((self.n_items, self.n_items), dtype=np.float)\n    self.lambda_i = lambda_i\n    self.lambda_j = lambda_j\n    self.learning_rate = learning_rate\n    start_time_train = time.time()\n    for n_epoch in range(epochs):\n        self._run_epoch(n_epoch)\n    print('Train completed in {:.2f} minutes'.format(float(time.time() - start_time_train) / 60))\n    self.W_sparse = similarityMatrixTopK(self.item_item_S, k=topK, verbose=False)\n    self.W_sparse = sps.csr_matrix(self.W_sparse)",
            "def fit(self, topK=100, epochs=25, lambda_i=0.0025, lambda_j=0.00025, learning_rate=0.05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n        :param topK:\\n        :param epochs:\\n        :param lambda_i:\\n        :param lambda_j:\\n        :param learning_rate:\\n        :return:\\n        '\n    self.item_item_S = np.zeros((self.n_items, self.n_items), dtype=np.float)\n    self.lambda_i = lambda_i\n    self.lambda_j = lambda_j\n    self.learning_rate = learning_rate\n    start_time_train = time.time()\n    for n_epoch in range(epochs):\n        self._run_epoch(n_epoch)\n    print('Train completed in {:.2f} minutes'.format(float(time.time() - start_time_train) / 60))\n    self.W_sparse = similarityMatrixTopK(self.item_item_S, k=topK, verbose=False)\n    self.W_sparse = sps.csr_matrix(self.W_sparse)",
            "def fit(self, topK=100, epochs=25, lambda_i=0.0025, lambda_j=0.00025, learning_rate=0.05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n        :param topK:\\n        :param epochs:\\n        :param lambda_i:\\n        :param lambda_j:\\n        :param learning_rate:\\n        :return:\\n        '\n    self.item_item_S = np.zeros((self.n_items, self.n_items), dtype=np.float)\n    self.lambda_i = lambda_i\n    self.lambda_j = lambda_j\n    self.learning_rate = learning_rate\n    start_time_train = time.time()\n    for n_epoch in range(epochs):\n        self._run_epoch(n_epoch)\n    print('Train completed in {:.2f} minutes'.format(float(time.time() - start_time_train) / 60))\n    self.W_sparse = similarityMatrixTopK(self.item_item_S, k=topK, verbose=False)\n    self.W_sparse = sps.csr_matrix(self.W_sparse)",
            "def fit(self, topK=100, epochs=25, lambda_i=0.0025, lambda_j=0.00025, learning_rate=0.05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n        :param topK:\\n        :param epochs:\\n        :param lambda_i:\\n        :param lambda_j:\\n        :param learning_rate:\\n        :return:\\n        '\n    self.item_item_S = np.zeros((self.n_items, self.n_items), dtype=np.float)\n    self.lambda_i = lambda_i\n    self.lambda_j = lambda_j\n    self.learning_rate = learning_rate\n    start_time_train = time.time()\n    for n_epoch in range(epochs):\n        self._run_epoch(n_epoch)\n    print('Train completed in {:.2f} minutes'.format(float(time.time() - start_time_train) / 60))\n    self.W_sparse = similarityMatrixTopK(self.item_item_S, k=topK, verbose=False)\n    self.W_sparse = sps.csr_matrix(self.W_sparse)",
            "def fit(self, topK=100, epochs=25, lambda_i=0.0025, lambda_j=0.00025, learning_rate=0.05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n        :param topK:\\n        :param epochs:\\n        :param lambda_i:\\n        :param lambda_j:\\n        :param learning_rate:\\n        :return:\\n        '\n    self.item_item_S = np.zeros((self.n_items, self.n_items), dtype=np.float)\n    self.lambda_i = lambda_i\n    self.lambda_j = lambda_j\n    self.learning_rate = learning_rate\n    start_time_train = time.time()\n    for n_epoch in range(epochs):\n        self._run_epoch(n_epoch)\n    print('Train completed in {:.2f} minutes'.format(float(time.time() - start_time_train) / 60))\n    self.W_sparse = similarityMatrixTopK(self.item_item_S, k=topK, verbose=False)\n    self.W_sparse = sps.csr_matrix(self.W_sparse)"
        ]
    },
    {
        "func_name": "_run_epoch",
        "original": "def _run_epoch(self, n_epoch):\n    start_time = time.time()\n    for sample_num in range(self.n_users):\n        (user_id, pos_item_id, neg_item_id) = self._sample_triplet()\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        x_ui = self.item_item_S[pos_item_id, user_seen_items].sum()\n        x_uj = self.item_item_S[neg_item_id, user_seen_items].sum()\n        x_uij = x_ui - x_uj\n        sigmoid_gradient = 1 / (1 + np.exp(x_uij))\n        self.item_item_S[pos_item_id, user_seen_items] += self.learning_rate * (sigmoid_gradient - self.lambda_i * self.item_item_S[pos_item_id, user_seen_items])\n        self.item_item_S[pos_item_id, pos_item_id] = 0\n        self.item_item_S[neg_item_id, user_seen_items] -= self.learning_rate * (sigmoid_gradient - self.lambda_j * self.item_item_S[neg_item_id, user_seen_items])\n        self.item_item_S[neg_item_id, neg_item_id] = 0\n        if (sample_num + 1) % 150000 == 0 or sample_num + 1 == self.n_users:\n            elapsed_time = time.time() - start_time\n            samples_per_second = (sample_num + 1) / elapsed_time\n            print('Epoch {}, Iteration {} in {:.2f} seconds. Samples per second {:.2f}'.format(n_epoch + 1, sample_num + 1, elapsed_time, samples_per_second))\n            start_time = time.time()",
        "mutated": [
            "def _run_epoch(self, n_epoch):\n    if False:\n        i = 10\n    start_time = time.time()\n    for sample_num in range(self.n_users):\n        (user_id, pos_item_id, neg_item_id) = self._sample_triplet()\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        x_ui = self.item_item_S[pos_item_id, user_seen_items].sum()\n        x_uj = self.item_item_S[neg_item_id, user_seen_items].sum()\n        x_uij = x_ui - x_uj\n        sigmoid_gradient = 1 / (1 + np.exp(x_uij))\n        self.item_item_S[pos_item_id, user_seen_items] += self.learning_rate * (sigmoid_gradient - self.lambda_i * self.item_item_S[pos_item_id, user_seen_items])\n        self.item_item_S[pos_item_id, pos_item_id] = 0\n        self.item_item_S[neg_item_id, user_seen_items] -= self.learning_rate * (sigmoid_gradient - self.lambda_j * self.item_item_S[neg_item_id, user_seen_items])\n        self.item_item_S[neg_item_id, neg_item_id] = 0\n        if (sample_num + 1) % 150000 == 0 or sample_num + 1 == self.n_users:\n            elapsed_time = time.time() - start_time\n            samples_per_second = (sample_num + 1) / elapsed_time\n            print('Epoch {}, Iteration {} in {:.2f} seconds. Samples per second {:.2f}'.format(n_epoch + 1, sample_num + 1, elapsed_time, samples_per_second))\n            start_time = time.time()",
            "def _run_epoch(self, n_epoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start_time = time.time()\n    for sample_num in range(self.n_users):\n        (user_id, pos_item_id, neg_item_id) = self._sample_triplet()\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        x_ui = self.item_item_S[pos_item_id, user_seen_items].sum()\n        x_uj = self.item_item_S[neg_item_id, user_seen_items].sum()\n        x_uij = x_ui - x_uj\n        sigmoid_gradient = 1 / (1 + np.exp(x_uij))\n        self.item_item_S[pos_item_id, user_seen_items] += self.learning_rate * (sigmoid_gradient - self.lambda_i * self.item_item_S[pos_item_id, user_seen_items])\n        self.item_item_S[pos_item_id, pos_item_id] = 0\n        self.item_item_S[neg_item_id, user_seen_items] -= self.learning_rate * (sigmoid_gradient - self.lambda_j * self.item_item_S[neg_item_id, user_seen_items])\n        self.item_item_S[neg_item_id, neg_item_id] = 0\n        if (sample_num + 1) % 150000 == 0 or sample_num + 1 == self.n_users:\n            elapsed_time = time.time() - start_time\n            samples_per_second = (sample_num + 1) / elapsed_time\n            print('Epoch {}, Iteration {} in {:.2f} seconds. Samples per second {:.2f}'.format(n_epoch + 1, sample_num + 1, elapsed_time, samples_per_second))\n            start_time = time.time()",
            "def _run_epoch(self, n_epoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start_time = time.time()\n    for sample_num in range(self.n_users):\n        (user_id, pos_item_id, neg_item_id) = self._sample_triplet()\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        x_ui = self.item_item_S[pos_item_id, user_seen_items].sum()\n        x_uj = self.item_item_S[neg_item_id, user_seen_items].sum()\n        x_uij = x_ui - x_uj\n        sigmoid_gradient = 1 / (1 + np.exp(x_uij))\n        self.item_item_S[pos_item_id, user_seen_items] += self.learning_rate * (sigmoid_gradient - self.lambda_i * self.item_item_S[pos_item_id, user_seen_items])\n        self.item_item_S[pos_item_id, pos_item_id] = 0\n        self.item_item_S[neg_item_id, user_seen_items] -= self.learning_rate * (sigmoid_gradient - self.lambda_j * self.item_item_S[neg_item_id, user_seen_items])\n        self.item_item_S[neg_item_id, neg_item_id] = 0\n        if (sample_num + 1) % 150000 == 0 or sample_num + 1 == self.n_users:\n            elapsed_time = time.time() - start_time\n            samples_per_second = (sample_num + 1) / elapsed_time\n            print('Epoch {}, Iteration {} in {:.2f} seconds. Samples per second {:.2f}'.format(n_epoch + 1, sample_num + 1, elapsed_time, samples_per_second))\n            start_time = time.time()",
            "def _run_epoch(self, n_epoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start_time = time.time()\n    for sample_num in range(self.n_users):\n        (user_id, pos_item_id, neg_item_id) = self._sample_triplet()\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        x_ui = self.item_item_S[pos_item_id, user_seen_items].sum()\n        x_uj = self.item_item_S[neg_item_id, user_seen_items].sum()\n        x_uij = x_ui - x_uj\n        sigmoid_gradient = 1 / (1 + np.exp(x_uij))\n        self.item_item_S[pos_item_id, user_seen_items] += self.learning_rate * (sigmoid_gradient - self.lambda_i * self.item_item_S[pos_item_id, user_seen_items])\n        self.item_item_S[pos_item_id, pos_item_id] = 0\n        self.item_item_S[neg_item_id, user_seen_items] -= self.learning_rate * (sigmoid_gradient - self.lambda_j * self.item_item_S[neg_item_id, user_seen_items])\n        self.item_item_S[neg_item_id, neg_item_id] = 0\n        if (sample_num + 1) % 150000 == 0 or sample_num + 1 == self.n_users:\n            elapsed_time = time.time() - start_time\n            samples_per_second = (sample_num + 1) / elapsed_time\n            print('Epoch {}, Iteration {} in {:.2f} seconds. Samples per second {:.2f}'.format(n_epoch + 1, sample_num + 1, elapsed_time, samples_per_second))\n            start_time = time.time()",
            "def _run_epoch(self, n_epoch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start_time = time.time()\n    for sample_num in range(self.n_users):\n        (user_id, pos_item_id, neg_item_id) = self._sample_triplet()\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        x_ui = self.item_item_S[pos_item_id, user_seen_items].sum()\n        x_uj = self.item_item_S[neg_item_id, user_seen_items].sum()\n        x_uij = x_ui - x_uj\n        sigmoid_gradient = 1 / (1 + np.exp(x_uij))\n        self.item_item_S[pos_item_id, user_seen_items] += self.learning_rate * (sigmoid_gradient - self.lambda_i * self.item_item_S[pos_item_id, user_seen_items])\n        self.item_item_S[pos_item_id, pos_item_id] = 0\n        self.item_item_S[neg_item_id, user_seen_items] -= self.learning_rate * (sigmoid_gradient - self.lambda_j * self.item_item_S[neg_item_id, user_seen_items])\n        self.item_item_S[neg_item_id, neg_item_id] = 0\n        if (sample_num + 1) % 150000 == 0 or sample_num + 1 == self.n_users:\n            elapsed_time = time.time() - start_time\n            samples_per_second = (sample_num + 1) / elapsed_time\n            print('Epoch {}, Iteration {} in {:.2f} seconds. Samples per second {:.2f}'.format(n_epoch + 1, sample_num + 1, elapsed_time, samples_per_second))\n            start_time = time.time()"
        ]
    },
    {
        "func_name": "_sample_triplet",
        "original": "def _sample_triplet(self):\n    non_empty_user = False\n    while not non_empty_user:\n        user_id = np.random.choice(self.n_users)\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        if len(user_seen_items) > 0:\n            non_empty_user = True\n    pos_item_id = np.random.choice(user_seen_items)\n    neg_item_selected = False\n    while not neg_item_selected:\n        neg_item_id = np.random.randint(0, self.n_items)\n        if neg_item_id not in user_seen_items:\n            neg_item_selected = True\n    return (user_id, pos_item_id, neg_item_id)",
        "mutated": [
            "def _sample_triplet(self):\n    if False:\n        i = 10\n    non_empty_user = False\n    while not non_empty_user:\n        user_id = np.random.choice(self.n_users)\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        if len(user_seen_items) > 0:\n            non_empty_user = True\n    pos_item_id = np.random.choice(user_seen_items)\n    neg_item_selected = False\n    while not neg_item_selected:\n        neg_item_id = np.random.randint(0, self.n_items)\n        if neg_item_id not in user_seen_items:\n            neg_item_selected = True\n    return (user_id, pos_item_id, neg_item_id)",
            "def _sample_triplet(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    non_empty_user = False\n    while not non_empty_user:\n        user_id = np.random.choice(self.n_users)\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        if len(user_seen_items) > 0:\n            non_empty_user = True\n    pos_item_id = np.random.choice(user_seen_items)\n    neg_item_selected = False\n    while not neg_item_selected:\n        neg_item_id = np.random.randint(0, self.n_items)\n        if neg_item_id not in user_seen_items:\n            neg_item_selected = True\n    return (user_id, pos_item_id, neg_item_id)",
            "def _sample_triplet(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    non_empty_user = False\n    while not non_empty_user:\n        user_id = np.random.choice(self.n_users)\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        if len(user_seen_items) > 0:\n            non_empty_user = True\n    pos_item_id = np.random.choice(user_seen_items)\n    neg_item_selected = False\n    while not neg_item_selected:\n        neg_item_id = np.random.randint(0, self.n_items)\n        if neg_item_id not in user_seen_items:\n            neg_item_selected = True\n    return (user_id, pos_item_id, neg_item_id)",
            "def _sample_triplet(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    non_empty_user = False\n    while not non_empty_user:\n        user_id = np.random.choice(self.n_users)\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        if len(user_seen_items) > 0:\n            non_empty_user = True\n    pos_item_id = np.random.choice(user_seen_items)\n    neg_item_selected = False\n    while not neg_item_selected:\n        neg_item_id = np.random.randint(0, self.n_items)\n        if neg_item_id not in user_seen_items:\n            neg_item_selected = True\n    return (user_id, pos_item_id, neg_item_id)",
            "def _sample_triplet(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    non_empty_user = False\n    while not non_empty_user:\n        user_id = np.random.choice(self.n_users)\n        user_seen_items = self.URM_train.indices[self.URM_train.indptr[user_id]:self.URM_train.indptr[user_id + 1]]\n        if len(user_seen_items) > 0:\n            non_empty_user = True\n    pos_item_id = np.random.choice(user_seen_items)\n    neg_item_selected = False\n    while not neg_item_selected:\n        neg_item_id = np.random.randint(0, self.n_items)\n        if neg_item_id not in user_seen_items:\n            neg_item_selected = True\n    return (user_id, pos_item_id, neg_item_id)"
        ]
    }
]