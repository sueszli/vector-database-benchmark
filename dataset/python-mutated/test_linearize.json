[
    {
        "func_name": "test_linearize_rolling_disc_kane",
        "original": "@slow\ndef test_linearize_rolling_disc_kane():\n    (t, r, m, g, v) = symbols('t r m g v')\n    (q1, q2, q3, q4, q5, q6) = q = dynamicsymbols('q1:7')\n    (q1d, q2d, q3d, q4d, q5d, q6d) = qd = [qi.diff(t) for qi in q]\n    u = dynamicsymbols('u:6')\n    (u1, u2, u3, u4, u5, u6) = u = dynamicsymbols('u1:7')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = [ui.diff(t) for ui in u]\n    N = ReferenceFrame('N')\n    NO = Point('NO')\n    A = N.orientnew('A', 'Axis', [q1, N.z])\n    B = A.orientnew('B', 'Axis', [q2, A.x])\n    C = B.orientnew('C', 'Axis', [q3, B.y])\n    CO = NO.locatenew('CO', q4 * N.x + q5 * N.y + q6 * N.z)\n    w_c_n_qd = C.ang_vel_in(N)\n    w_b_n_qd = B.ang_vel_in(N)\n    C.set_ang_vel(N, u1 * B.x + u2 * B.y + u3 * B.z)\n    v_co_n_qd = CO.pos_from(NO).dt(N)\n    CO.set_vel(N, u4 * C.x + u5 * C.y + u6 * C.z)\n    P = CO.locatenew('P', r * B.z)\n    P.v2pt_theory(CO, N, C)\n    f_c = Matrix([q6 - dot(CO.pos_from(P), N.z)])\n    f_v = Matrix([dot(P.vel(N), uv) for uv in C])\n    kindiffs = Matrix([dot(w_c_n_qd - C.ang_vel_in(N), uv) for uv in B] + [dot(v_co_n_qd - CO.vel(N), uv) for uv in N])\n    qdots = solve(kindiffs, qd)\n    B.set_ang_vel(N, w_b_n_qd.subs(qdots))\n    C.set_ang_acc(N, C.ang_vel_in(N).dt(B) + cross(B.ang_vel_in(N), C.ang_vel_in(N)))\n    F_CO = m * g * A.z\n    I = m * r ** 2 / 4\n    J = m * r ** 2 / 2\n    I_C_CO = inertia(C, I, J, I)\n    Disc = RigidBody('Disc', CO, C, m, (I_C_CO, CO))\n    BL = [Disc]\n    FL = [(CO, F_CO)]\n    KM = KanesMethod(N, [q1, q2, q3, q4, q5], [u1, u2, u3], kd_eqs=kindiffs, q_dependent=[q6], configuration_constraints=f_c, u_dependent=[u4, u5, u6], velocity_constraints=f_v)\n    (fr, fr_star) = KM.kanes_equations(BL, FL)\n    linearizer = KM.to_linearizer()\n    assert linearizer.f_c == f_c\n    assert linearizer.f_v == f_v\n    assert linearizer.f_a == f_v.diff(t).subs(KM.kindiffdict())\n    sol = solve(linearizer.f_0 + linearizer.f_1, qd)\n    for qi in qdots.keys():\n        assert sol[qi] == qdots[qi]\n    assert simplify(linearizer.f_2 + linearizer.f_3 - fr - fr_star) == Matrix([0, 0, 0])\n    q_op = {q6: -r * cos(q2)}\n    u_op = {u1: 0, u2: sin(q2) * q1d + q3d, u3: cos(q2) * q1d, u4: -r * (sin(q2) * q1d + q3d) * cos(q3), u5: 0, u6: -r * (sin(q2) * q1d + q3d) * sin(q3)}\n    qd_op = {q2d: 0, q4d: -r * (sin(q2) * q1d + q3d) * cos(q1), q5d: -r * (sin(q2) * q1d + q3d) * sin(q1), q6d: 0}\n    ud_op = {u1d: 4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5, u2d: 0, u3d: 0, u4d: r * (sin(q2) * sin(q3) * q1d * q3d + sin(q3) * q3d ** 2), u5d: r * (4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5), u6d: -r * (sin(q2) * cos(q3) * q1d * q3d + cos(q3) * q3d ** 2)}\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    upright_nominal = {q1d: 0, q2: 0, m: 1, r: 1, g: 1}\n    A_sol = Matrix([[0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [sin(q1) * q3d, 0, 0, 0, 0, -sin(q1), -cos(q1), 0], [-cos(q1) * q3d, 0, 0, 0, 0, cos(q1), -sin(q1), 0], [0, Rational(4, 5), 0, 0, 0, 0, 0, 6 * q3d / 5], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, -2 * q3d, 0, 0]])\n    B_sol = Matrix([])\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol\n    assert sympify(A.subs(upright_nominal).subs(q3d, 1 / sqrt(3))).eigenvals() == {0: 8}\n    linearizer = KM.to_linearizer(linear_solver='GJ')\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol",
        "mutated": [
            "@slow\ndef test_linearize_rolling_disc_kane():\n    if False:\n        i = 10\n    (t, r, m, g, v) = symbols('t r m g v')\n    (q1, q2, q3, q4, q5, q6) = q = dynamicsymbols('q1:7')\n    (q1d, q2d, q3d, q4d, q5d, q6d) = qd = [qi.diff(t) for qi in q]\n    u = dynamicsymbols('u:6')\n    (u1, u2, u3, u4, u5, u6) = u = dynamicsymbols('u1:7')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = [ui.diff(t) for ui in u]\n    N = ReferenceFrame('N')\n    NO = Point('NO')\n    A = N.orientnew('A', 'Axis', [q1, N.z])\n    B = A.orientnew('B', 'Axis', [q2, A.x])\n    C = B.orientnew('C', 'Axis', [q3, B.y])\n    CO = NO.locatenew('CO', q4 * N.x + q5 * N.y + q6 * N.z)\n    w_c_n_qd = C.ang_vel_in(N)\n    w_b_n_qd = B.ang_vel_in(N)\n    C.set_ang_vel(N, u1 * B.x + u2 * B.y + u3 * B.z)\n    v_co_n_qd = CO.pos_from(NO).dt(N)\n    CO.set_vel(N, u4 * C.x + u5 * C.y + u6 * C.z)\n    P = CO.locatenew('P', r * B.z)\n    P.v2pt_theory(CO, N, C)\n    f_c = Matrix([q6 - dot(CO.pos_from(P), N.z)])\n    f_v = Matrix([dot(P.vel(N), uv) for uv in C])\n    kindiffs = Matrix([dot(w_c_n_qd - C.ang_vel_in(N), uv) for uv in B] + [dot(v_co_n_qd - CO.vel(N), uv) for uv in N])\n    qdots = solve(kindiffs, qd)\n    B.set_ang_vel(N, w_b_n_qd.subs(qdots))\n    C.set_ang_acc(N, C.ang_vel_in(N).dt(B) + cross(B.ang_vel_in(N), C.ang_vel_in(N)))\n    F_CO = m * g * A.z\n    I = m * r ** 2 / 4\n    J = m * r ** 2 / 2\n    I_C_CO = inertia(C, I, J, I)\n    Disc = RigidBody('Disc', CO, C, m, (I_C_CO, CO))\n    BL = [Disc]\n    FL = [(CO, F_CO)]\n    KM = KanesMethod(N, [q1, q2, q3, q4, q5], [u1, u2, u3], kd_eqs=kindiffs, q_dependent=[q6], configuration_constraints=f_c, u_dependent=[u4, u5, u6], velocity_constraints=f_v)\n    (fr, fr_star) = KM.kanes_equations(BL, FL)\n    linearizer = KM.to_linearizer()\n    assert linearizer.f_c == f_c\n    assert linearizer.f_v == f_v\n    assert linearizer.f_a == f_v.diff(t).subs(KM.kindiffdict())\n    sol = solve(linearizer.f_0 + linearizer.f_1, qd)\n    for qi in qdots.keys():\n        assert sol[qi] == qdots[qi]\n    assert simplify(linearizer.f_2 + linearizer.f_3 - fr - fr_star) == Matrix([0, 0, 0])\n    q_op = {q6: -r * cos(q2)}\n    u_op = {u1: 0, u2: sin(q2) * q1d + q3d, u3: cos(q2) * q1d, u4: -r * (sin(q2) * q1d + q3d) * cos(q3), u5: 0, u6: -r * (sin(q2) * q1d + q3d) * sin(q3)}\n    qd_op = {q2d: 0, q4d: -r * (sin(q2) * q1d + q3d) * cos(q1), q5d: -r * (sin(q2) * q1d + q3d) * sin(q1), q6d: 0}\n    ud_op = {u1d: 4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5, u2d: 0, u3d: 0, u4d: r * (sin(q2) * sin(q3) * q1d * q3d + sin(q3) * q3d ** 2), u5d: r * (4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5), u6d: -r * (sin(q2) * cos(q3) * q1d * q3d + cos(q3) * q3d ** 2)}\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    upright_nominal = {q1d: 0, q2: 0, m: 1, r: 1, g: 1}\n    A_sol = Matrix([[0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [sin(q1) * q3d, 0, 0, 0, 0, -sin(q1), -cos(q1), 0], [-cos(q1) * q3d, 0, 0, 0, 0, cos(q1), -sin(q1), 0], [0, Rational(4, 5), 0, 0, 0, 0, 0, 6 * q3d / 5], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, -2 * q3d, 0, 0]])\n    B_sol = Matrix([])\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol\n    assert sympify(A.subs(upright_nominal).subs(q3d, 1 / sqrt(3))).eigenvals() == {0: 8}\n    linearizer = KM.to_linearizer(linear_solver='GJ')\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol",
            "@slow\ndef test_linearize_rolling_disc_kane():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (t, r, m, g, v) = symbols('t r m g v')\n    (q1, q2, q3, q4, q5, q6) = q = dynamicsymbols('q1:7')\n    (q1d, q2d, q3d, q4d, q5d, q6d) = qd = [qi.diff(t) for qi in q]\n    u = dynamicsymbols('u:6')\n    (u1, u2, u3, u4, u5, u6) = u = dynamicsymbols('u1:7')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = [ui.diff(t) for ui in u]\n    N = ReferenceFrame('N')\n    NO = Point('NO')\n    A = N.orientnew('A', 'Axis', [q1, N.z])\n    B = A.orientnew('B', 'Axis', [q2, A.x])\n    C = B.orientnew('C', 'Axis', [q3, B.y])\n    CO = NO.locatenew('CO', q4 * N.x + q5 * N.y + q6 * N.z)\n    w_c_n_qd = C.ang_vel_in(N)\n    w_b_n_qd = B.ang_vel_in(N)\n    C.set_ang_vel(N, u1 * B.x + u2 * B.y + u3 * B.z)\n    v_co_n_qd = CO.pos_from(NO).dt(N)\n    CO.set_vel(N, u4 * C.x + u5 * C.y + u6 * C.z)\n    P = CO.locatenew('P', r * B.z)\n    P.v2pt_theory(CO, N, C)\n    f_c = Matrix([q6 - dot(CO.pos_from(P), N.z)])\n    f_v = Matrix([dot(P.vel(N), uv) for uv in C])\n    kindiffs = Matrix([dot(w_c_n_qd - C.ang_vel_in(N), uv) for uv in B] + [dot(v_co_n_qd - CO.vel(N), uv) for uv in N])\n    qdots = solve(kindiffs, qd)\n    B.set_ang_vel(N, w_b_n_qd.subs(qdots))\n    C.set_ang_acc(N, C.ang_vel_in(N).dt(B) + cross(B.ang_vel_in(N), C.ang_vel_in(N)))\n    F_CO = m * g * A.z\n    I = m * r ** 2 / 4\n    J = m * r ** 2 / 2\n    I_C_CO = inertia(C, I, J, I)\n    Disc = RigidBody('Disc', CO, C, m, (I_C_CO, CO))\n    BL = [Disc]\n    FL = [(CO, F_CO)]\n    KM = KanesMethod(N, [q1, q2, q3, q4, q5], [u1, u2, u3], kd_eqs=kindiffs, q_dependent=[q6], configuration_constraints=f_c, u_dependent=[u4, u5, u6], velocity_constraints=f_v)\n    (fr, fr_star) = KM.kanes_equations(BL, FL)\n    linearizer = KM.to_linearizer()\n    assert linearizer.f_c == f_c\n    assert linearizer.f_v == f_v\n    assert linearizer.f_a == f_v.diff(t).subs(KM.kindiffdict())\n    sol = solve(linearizer.f_0 + linearizer.f_1, qd)\n    for qi in qdots.keys():\n        assert sol[qi] == qdots[qi]\n    assert simplify(linearizer.f_2 + linearizer.f_3 - fr - fr_star) == Matrix([0, 0, 0])\n    q_op = {q6: -r * cos(q2)}\n    u_op = {u1: 0, u2: sin(q2) * q1d + q3d, u3: cos(q2) * q1d, u4: -r * (sin(q2) * q1d + q3d) * cos(q3), u5: 0, u6: -r * (sin(q2) * q1d + q3d) * sin(q3)}\n    qd_op = {q2d: 0, q4d: -r * (sin(q2) * q1d + q3d) * cos(q1), q5d: -r * (sin(q2) * q1d + q3d) * sin(q1), q6d: 0}\n    ud_op = {u1d: 4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5, u2d: 0, u3d: 0, u4d: r * (sin(q2) * sin(q3) * q1d * q3d + sin(q3) * q3d ** 2), u5d: r * (4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5), u6d: -r * (sin(q2) * cos(q3) * q1d * q3d + cos(q3) * q3d ** 2)}\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    upright_nominal = {q1d: 0, q2: 0, m: 1, r: 1, g: 1}\n    A_sol = Matrix([[0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [sin(q1) * q3d, 0, 0, 0, 0, -sin(q1), -cos(q1), 0], [-cos(q1) * q3d, 0, 0, 0, 0, cos(q1), -sin(q1), 0], [0, Rational(4, 5), 0, 0, 0, 0, 0, 6 * q3d / 5], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, -2 * q3d, 0, 0]])\n    B_sol = Matrix([])\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol\n    assert sympify(A.subs(upright_nominal).subs(q3d, 1 / sqrt(3))).eigenvals() == {0: 8}\n    linearizer = KM.to_linearizer(linear_solver='GJ')\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol",
            "@slow\ndef test_linearize_rolling_disc_kane():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (t, r, m, g, v) = symbols('t r m g v')\n    (q1, q2, q3, q4, q5, q6) = q = dynamicsymbols('q1:7')\n    (q1d, q2d, q3d, q4d, q5d, q6d) = qd = [qi.diff(t) for qi in q]\n    u = dynamicsymbols('u:6')\n    (u1, u2, u3, u4, u5, u6) = u = dynamicsymbols('u1:7')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = [ui.diff(t) for ui in u]\n    N = ReferenceFrame('N')\n    NO = Point('NO')\n    A = N.orientnew('A', 'Axis', [q1, N.z])\n    B = A.orientnew('B', 'Axis', [q2, A.x])\n    C = B.orientnew('C', 'Axis', [q3, B.y])\n    CO = NO.locatenew('CO', q4 * N.x + q5 * N.y + q6 * N.z)\n    w_c_n_qd = C.ang_vel_in(N)\n    w_b_n_qd = B.ang_vel_in(N)\n    C.set_ang_vel(N, u1 * B.x + u2 * B.y + u3 * B.z)\n    v_co_n_qd = CO.pos_from(NO).dt(N)\n    CO.set_vel(N, u4 * C.x + u5 * C.y + u6 * C.z)\n    P = CO.locatenew('P', r * B.z)\n    P.v2pt_theory(CO, N, C)\n    f_c = Matrix([q6 - dot(CO.pos_from(P), N.z)])\n    f_v = Matrix([dot(P.vel(N), uv) for uv in C])\n    kindiffs = Matrix([dot(w_c_n_qd - C.ang_vel_in(N), uv) for uv in B] + [dot(v_co_n_qd - CO.vel(N), uv) for uv in N])\n    qdots = solve(kindiffs, qd)\n    B.set_ang_vel(N, w_b_n_qd.subs(qdots))\n    C.set_ang_acc(N, C.ang_vel_in(N).dt(B) + cross(B.ang_vel_in(N), C.ang_vel_in(N)))\n    F_CO = m * g * A.z\n    I = m * r ** 2 / 4\n    J = m * r ** 2 / 2\n    I_C_CO = inertia(C, I, J, I)\n    Disc = RigidBody('Disc', CO, C, m, (I_C_CO, CO))\n    BL = [Disc]\n    FL = [(CO, F_CO)]\n    KM = KanesMethod(N, [q1, q2, q3, q4, q5], [u1, u2, u3], kd_eqs=kindiffs, q_dependent=[q6], configuration_constraints=f_c, u_dependent=[u4, u5, u6], velocity_constraints=f_v)\n    (fr, fr_star) = KM.kanes_equations(BL, FL)\n    linearizer = KM.to_linearizer()\n    assert linearizer.f_c == f_c\n    assert linearizer.f_v == f_v\n    assert linearizer.f_a == f_v.diff(t).subs(KM.kindiffdict())\n    sol = solve(linearizer.f_0 + linearizer.f_1, qd)\n    for qi in qdots.keys():\n        assert sol[qi] == qdots[qi]\n    assert simplify(linearizer.f_2 + linearizer.f_3 - fr - fr_star) == Matrix([0, 0, 0])\n    q_op = {q6: -r * cos(q2)}\n    u_op = {u1: 0, u2: sin(q2) * q1d + q3d, u3: cos(q2) * q1d, u4: -r * (sin(q2) * q1d + q3d) * cos(q3), u5: 0, u6: -r * (sin(q2) * q1d + q3d) * sin(q3)}\n    qd_op = {q2d: 0, q4d: -r * (sin(q2) * q1d + q3d) * cos(q1), q5d: -r * (sin(q2) * q1d + q3d) * sin(q1), q6d: 0}\n    ud_op = {u1d: 4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5, u2d: 0, u3d: 0, u4d: r * (sin(q2) * sin(q3) * q1d * q3d + sin(q3) * q3d ** 2), u5d: r * (4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5), u6d: -r * (sin(q2) * cos(q3) * q1d * q3d + cos(q3) * q3d ** 2)}\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    upright_nominal = {q1d: 0, q2: 0, m: 1, r: 1, g: 1}\n    A_sol = Matrix([[0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [sin(q1) * q3d, 0, 0, 0, 0, -sin(q1), -cos(q1), 0], [-cos(q1) * q3d, 0, 0, 0, 0, cos(q1), -sin(q1), 0], [0, Rational(4, 5), 0, 0, 0, 0, 0, 6 * q3d / 5], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, -2 * q3d, 0, 0]])\n    B_sol = Matrix([])\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol\n    assert sympify(A.subs(upright_nominal).subs(q3d, 1 / sqrt(3))).eigenvals() == {0: 8}\n    linearizer = KM.to_linearizer(linear_solver='GJ')\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol",
            "@slow\ndef test_linearize_rolling_disc_kane():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (t, r, m, g, v) = symbols('t r m g v')\n    (q1, q2, q3, q4, q5, q6) = q = dynamicsymbols('q1:7')\n    (q1d, q2d, q3d, q4d, q5d, q6d) = qd = [qi.diff(t) for qi in q]\n    u = dynamicsymbols('u:6')\n    (u1, u2, u3, u4, u5, u6) = u = dynamicsymbols('u1:7')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = [ui.diff(t) for ui in u]\n    N = ReferenceFrame('N')\n    NO = Point('NO')\n    A = N.orientnew('A', 'Axis', [q1, N.z])\n    B = A.orientnew('B', 'Axis', [q2, A.x])\n    C = B.orientnew('C', 'Axis', [q3, B.y])\n    CO = NO.locatenew('CO', q4 * N.x + q5 * N.y + q6 * N.z)\n    w_c_n_qd = C.ang_vel_in(N)\n    w_b_n_qd = B.ang_vel_in(N)\n    C.set_ang_vel(N, u1 * B.x + u2 * B.y + u3 * B.z)\n    v_co_n_qd = CO.pos_from(NO).dt(N)\n    CO.set_vel(N, u4 * C.x + u5 * C.y + u6 * C.z)\n    P = CO.locatenew('P', r * B.z)\n    P.v2pt_theory(CO, N, C)\n    f_c = Matrix([q6 - dot(CO.pos_from(P), N.z)])\n    f_v = Matrix([dot(P.vel(N), uv) for uv in C])\n    kindiffs = Matrix([dot(w_c_n_qd - C.ang_vel_in(N), uv) for uv in B] + [dot(v_co_n_qd - CO.vel(N), uv) for uv in N])\n    qdots = solve(kindiffs, qd)\n    B.set_ang_vel(N, w_b_n_qd.subs(qdots))\n    C.set_ang_acc(N, C.ang_vel_in(N).dt(B) + cross(B.ang_vel_in(N), C.ang_vel_in(N)))\n    F_CO = m * g * A.z\n    I = m * r ** 2 / 4\n    J = m * r ** 2 / 2\n    I_C_CO = inertia(C, I, J, I)\n    Disc = RigidBody('Disc', CO, C, m, (I_C_CO, CO))\n    BL = [Disc]\n    FL = [(CO, F_CO)]\n    KM = KanesMethod(N, [q1, q2, q3, q4, q5], [u1, u2, u3], kd_eqs=kindiffs, q_dependent=[q6], configuration_constraints=f_c, u_dependent=[u4, u5, u6], velocity_constraints=f_v)\n    (fr, fr_star) = KM.kanes_equations(BL, FL)\n    linearizer = KM.to_linearizer()\n    assert linearizer.f_c == f_c\n    assert linearizer.f_v == f_v\n    assert linearizer.f_a == f_v.diff(t).subs(KM.kindiffdict())\n    sol = solve(linearizer.f_0 + linearizer.f_1, qd)\n    for qi in qdots.keys():\n        assert sol[qi] == qdots[qi]\n    assert simplify(linearizer.f_2 + linearizer.f_3 - fr - fr_star) == Matrix([0, 0, 0])\n    q_op = {q6: -r * cos(q2)}\n    u_op = {u1: 0, u2: sin(q2) * q1d + q3d, u3: cos(q2) * q1d, u4: -r * (sin(q2) * q1d + q3d) * cos(q3), u5: 0, u6: -r * (sin(q2) * q1d + q3d) * sin(q3)}\n    qd_op = {q2d: 0, q4d: -r * (sin(q2) * q1d + q3d) * cos(q1), q5d: -r * (sin(q2) * q1d + q3d) * sin(q1), q6d: 0}\n    ud_op = {u1d: 4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5, u2d: 0, u3d: 0, u4d: r * (sin(q2) * sin(q3) * q1d * q3d + sin(q3) * q3d ** 2), u5d: r * (4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5), u6d: -r * (sin(q2) * cos(q3) * q1d * q3d + cos(q3) * q3d ** 2)}\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    upright_nominal = {q1d: 0, q2: 0, m: 1, r: 1, g: 1}\n    A_sol = Matrix([[0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [sin(q1) * q3d, 0, 0, 0, 0, -sin(q1), -cos(q1), 0], [-cos(q1) * q3d, 0, 0, 0, 0, cos(q1), -sin(q1), 0], [0, Rational(4, 5), 0, 0, 0, 0, 0, 6 * q3d / 5], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, -2 * q3d, 0, 0]])\n    B_sol = Matrix([])\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol\n    assert sympify(A.subs(upright_nominal).subs(q3d, 1 / sqrt(3))).eigenvals() == {0: 8}\n    linearizer = KM.to_linearizer(linear_solver='GJ')\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol",
            "@slow\ndef test_linearize_rolling_disc_kane():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (t, r, m, g, v) = symbols('t r m g v')\n    (q1, q2, q3, q4, q5, q6) = q = dynamicsymbols('q1:7')\n    (q1d, q2d, q3d, q4d, q5d, q6d) = qd = [qi.diff(t) for qi in q]\n    u = dynamicsymbols('u:6')\n    (u1, u2, u3, u4, u5, u6) = u = dynamicsymbols('u1:7')\n    (u1d, u2d, u3d, u4d, u5d, u6d) = [ui.diff(t) for ui in u]\n    N = ReferenceFrame('N')\n    NO = Point('NO')\n    A = N.orientnew('A', 'Axis', [q1, N.z])\n    B = A.orientnew('B', 'Axis', [q2, A.x])\n    C = B.orientnew('C', 'Axis', [q3, B.y])\n    CO = NO.locatenew('CO', q4 * N.x + q5 * N.y + q6 * N.z)\n    w_c_n_qd = C.ang_vel_in(N)\n    w_b_n_qd = B.ang_vel_in(N)\n    C.set_ang_vel(N, u1 * B.x + u2 * B.y + u3 * B.z)\n    v_co_n_qd = CO.pos_from(NO).dt(N)\n    CO.set_vel(N, u4 * C.x + u5 * C.y + u6 * C.z)\n    P = CO.locatenew('P', r * B.z)\n    P.v2pt_theory(CO, N, C)\n    f_c = Matrix([q6 - dot(CO.pos_from(P), N.z)])\n    f_v = Matrix([dot(P.vel(N), uv) for uv in C])\n    kindiffs = Matrix([dot(w_c_n_qd - C.ang_vel_in(N), uv) for uv in B] + [dot(v_co_n_qd - CO.vel(N), uv) for uv in N])\n    qdots = solve(kindiffs, qd)\n    B.set_ang_vel(N, w_b_n_qd.subs(qdots))\n    C.set_ang_acc(N, C.ang_vel_in(N).dt(B) + cross(B.ang_vel_in(N), C.ang_vel_in(N)))\n    F_CO = m * g * A.z\n    I = m * r ** 2 / 4\n    J = m * r ** 2 / 2\n    I_C_CO = inertia(C, I, J, I)\n    Disc = RigidBody('Disc', CO, C, m, (I_C_CO, CO))\n    BL = [Disc]\n    FL = [(CO, F_CO)]\n    KM = KanesMethod(N, [q1, q2, q3, q4, q5], [u1, u2, u3], kd_eqs=kindiffs, q_dependent=[q6], configuration_constraints=f_c, u_dependent=[u4, u5, u6], velocity_constraints=f_v)\n    (fr, fr_star) = KM.kanes_equations(BL, FL)\n    linearizer = KM.to_linearizer()\n    assert linearizer.f_c == f_c\n    assert linearizer.f_v == f_v\n    assert linearizer.f_a == f_v.diff(t).subs(KM.kindiffdict())\n    sol = solve(linearizer.f_0 + linearizer.f_1, qd)\n    for qi in qdots.keys():\n        assert sol[qi] == qdots[qi]\n    assert simplify(linearizer.f_2 + linearizer.f_3 - fr - fr_star) == Matrix([0, 0, 0])\n    q_op = {q6: -r * cos(q2)}\n    u_op = {u1: 0, u2: sin(q2) * q1d + q3d, u3: cos(q2) * q1d, u4: -r * (sin(q2) * q1d + q3d) * cos(q3), u5: 0, u6: -r * (sin(q2) * q1d + q3d) * sin(q3)}\n    qd_op = {q2d: 0, q4d: -r * (sin(q2) * q1d + q3d) * cos(q1), q5d: -r * (sin(q2) * q1d + q3d) * sin(q1), q6d: 0}\n    ud_op = {u1d: 4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5, u2d: 0, u3d: 0, u4d: r * (sin(q2) * sin(q3) * q1d * q3d + sin(q3) * q3d ** 2), u5d: r * (4 * g * sin(q2) / (5 * r) + sin(2 * q2) * q1d ** 2 / 2 + 6 * cos(q2) * q1d * q3d / 5), u6d: -r * (sin(q2) * cos(q3) * q1d * q3d + cos(q3) * q3d ** 2)}\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    upright_nominal = {q1d: 0, q2: 0, m: 1, r: 1, g: 1}\n    A_sol = Matrix([[0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [sin(q1) * q3d, 0, 0, 0, 0, -sin(q1), -cos(q1), 0], [-cos(q1) * q3d, 0, 0, 0, 0, cos(q1), -sin(q1), 0], [0, Rational(4, 5), 0, 0, 0, 0, 0, 6 * q3d / 5], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, -2 * q3d, 0, 0]])\n    B_sol = Matrix([])\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol\n    assert sympify(A.subs(upright_nominal).subs(q3d, 1 / sqrt(3))).eigenvals() == {0: 8}\n    linearizer = KM.to_linearizer(linear_solver='GJ')\n    (A, B) = linearizer.linearize(op_point=[q_op, u_op, qd_op, ud_op], A_and_B=True, simplify=True)\n    assert A.subs(upright_nominal) == A_sol\n    assert B.subs(upright_nominal) == B_sol"
        ]
    },
    {
        "func_name": "test_linearize_pendulum_kane_minimal",
        "original": "def test_linearize_pendulum_kane_minimal():\n    q1 = dynamicsymbols('q1')\n    u1 = dynamicsymbols('u1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, u1 * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1])\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q1], u_ind=[u1], kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    (A, B, inp_vec) = KM.linearize(A_and_B=True, simplify=True)\n    assert A == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
        "mutated": [
            "def test_linearize_pendulum_kane_minimal():\n    if False:\n        i = 10\n    q1 = dynamicsymbols('q1')\n    u1 = dynamicsymbols('u1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, u1 * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1])\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q1], u_ind=[u1], kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    (A, B, inp_vec) = KM.linearize(A_and_B=True, simplify=True)\n    assert A == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_kane_minimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    q1 = dynamicsymbols('q1')\n    u1 = dynamicsymbols('u1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, u1 * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1])\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q1], u_ind=[u1], kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    (A, B, inp_vec) = KM.linearize(A_and_B=True, simplify=True)\n    assert A == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_kane_minimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    q1 = dynamicsymbols('q1')\n    u1 = dynamicsymbols('u1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, u1 * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1])\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q1], u_ind=[u1], kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    (A, B, inp_vec) = KM.linearize(A_and_B=True, simplify=True)\n    assert A == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_kane_minimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    q1 = dynamicsymbols('q1')\n    u1 = dynamicsymbols('u1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, u1 * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1])\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q1], u_ind=[u1], kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    (A, B, inp_vec) = KM.linearize(A_and_B=True, simplify=True)\n    assert A == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_kane_minimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    q1 = dynamicsymbols('q1')\n    u1 = dynamicsymbols('u1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, u1 * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1])\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q1], u_ind=[u1], kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    (A, B, inp_vec) = KM.linearize(A_and_B=True, simplify=True)\n    assert A == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])"
        ]
    },
    {
        "func_name": "test_linearize_pendulum_kane_nonminimal",
        "original": "def test_linearize_pendulum_kane_nonminimal():\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (u1, u2) = dynamicsymbols('u1:3')\n    (u1d, u2d) = dynamicsymbols('u1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1, q2d - u2])\n    dq_dict = solve(kde, [q1d, q2d])\n    P.set_vel(N, P.pos_from(pN).dt(N).subs(dq_dict))\n    f_c = Matrix([P.pos_from(pN).magnitude() - L])\n    f_v = Matrix([P.vel(N).express(A).dot(A.x)])\n    f_v.simplify()\n    f_a = f_v.diff(t)\n    f_a.simplify()\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q2], u_ind=[u2], q_dependent=[q1], u_dependent=[u1], configuration_constraints=f_c, velocity_constraints=f_v, acceleration_constraints=f_a, kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    q_op = {q1: L, q2: 0}\n    u_op = {u1: 0, u2: 0}\n    ud_op = {u1d: 0, u2d: 0}\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True)\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver='GJ')\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
        "mutated": [
            "def test_linearize_pendulum_kane_nonminimal():\n    if False:\n        i = 10\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (u1, u2) = dynamicsymbols('u1:3')\n    (u1d, u2d) = dynamicsymbols('u1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1, q2d - u2])\n    dq_dict = solve(kde, [q1d, q2d])\n    P.set_vel(N, P.pos_from(pN).dt(N).subs(dq_dict))\n    f_c = Matrix([P.pos_from(pN).magnitude() - L])\n    f_v = Matrix([P.vel(N).express(A).dot(A.x)])\n    f_v.simplify()\n    f_a = f_v.diff(t)\n    f_a.simplify()\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q2], u_ind=[u2], q_dependent=[q1], u_dependent=[u1], configuration_constraints=f_c, velocity_constraints=f_v, acceleration_constraints=f_a, kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    q_op = {q1: L, q2: 0}\n    u_op = {u1: 0, u2: 0}\n    ud_op = {u1d: 0, u2d: 0}\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True)\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver='GJ')\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_kane_nonminimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (u1, u2) = dynamicsymbols('u1:3')\n    (u1d, u2d) = dynamicsymbols('u1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1, q2d - u2])\n    dq_dict = solve(kde, [q1d, q2d])\n    P.set_vel(N, P.pos_from(pN).dt(N).subs(dq_dict))\n    f_c = Matrix([P.pos_from(pN).magnitude() - L])\n    f_v = Matrix([P.vel(N).express(A).dot(A.x)])\n    f_v.simplify()\n    f_a = f_v.diff(t)\n    f_a.simplify()\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q2], u_ind=[u2], q_dependent=[q1], u_dependent=[u1], configuration_constraints=f_c, velocity_constraints=f_v, acceleration_constraints=f_a, kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    q_op = {q1: L, q2: 0}\n    u_op = {u1: 0, u2: 0}\n    ud_op = {u1d: 0, u2d: 0}\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True)\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver='GJ')\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_kane_nonminimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (u1, u2) = dynamicsymbols('u1:3')\n    (u1d, u2d) = dynamicsymbols('u1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1, q2d - u2])\n    dq_dict = solve(kde, [q1d, q2d])\n    P.set_vel(N, P.pos_from(pN).dt(N).subs(dq_dict))\n    f_c = Matrix([P.pos_from(pN).magnitude() - L])\n    f_v = Matrix([P.vel(N).express(A).dot(A.x)])\n    f_v.simplify()\n    f_a = f_v.diff(t)\n    f_a.simplify()\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q2], u_ind=[u2], q_dependent=[q1], u_dependent=[u1], configuration_constraints=f_c, velocity_constraints=f_v, acceleration_constraints=f_a, kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    q_op = {q1: L, q2: 0}\n    u_op = {u1: 0, u2: 0}\n    ud_op = {u1d: 0, u2d: 0}\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True)\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver='GJ')\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_kane_nonminimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (u1, u2) = dynamicsymbols('u1:3')\n    (u1d, u2d) = dynamicsymbols('u1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1, q2d - u2])\n    dq_dict = solve(kde, [q1d, q2d])\n    P.set_vel(N, P.pos_from(pN).dt(N).subs(dq_dict))\n    f_c = Matrix([P.pos_from(pN).magnitude() - L])\n    f_v = Matrix([P.vel(N).express(A).dot(A.x)])\n    f_v.simplify()\n    f_a = f_v.diff(t)\n    f_a.simplify()\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q2], u_ind=[u2], q_dependent=[q1], u_dependent=[u1], configuration_constraints=f_c, velocity_constraints=f_v, acceleration_constraints=f_a, kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    q_op = {q1: L, q2: 0}\n    u_op = {u1: 0, u2: 0}\n    ud_op = {u1d: 0, u2d: 0}\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True)\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver='GJ')\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_kane_nonminimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (u1, u2) = dynamicsymbols('u1:3')\n    (u1d, u2d) = dynamicsymbols('u1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    pP = Particle('pP', P, m)\n    kde = Matrix([q1d - u1, q2d - u2])\n    dq_dict = solve(kde, [q1d, q2d])\n    P.set_vel(N, P.pos_from(pN).dt(N).subs(dq_dict))\n    f_c = Matrix([P.pos_from(pN).magnitude() - L])\n    f_v = Matrix([P.vel(N).express(A).dot(A.x)])\n    f_v.simplify()\n    f_a = f_v.diff(t)\n    f_a.simplify()\n    R = m * g * N.x\n    KM = KanesMethod(N, q_ind=[q2], u_ind=[u2], q_dependent=[q1], u_dependent=[u1], configuration_constraints=f_c, velocity_constraints=f_v, acceleration_constraints=f_a, kd_eqs=kde)\n    (fr, frstar) = KM.kanes_equations([pP], [(P, R)])\n    q_op = {q1: L, q2: 0}\n    u_op = {u1: 0, u2: 0}\n    ud_op = {u1d: 0, u2d: 0}\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True)\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver='GJ')\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True, simplify=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert A.expand() == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])"
        ]
    },
    {
        "func_name": "test_linearize_pendulum_lagrange_minimal",
        "original": "def test_linearize_pendulum_lagrange_minimal():\n    q1 = dynamicsymbols('q1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, q1d * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1], forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True, linear_solver='GJ')\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
        "mutated": [
            "def test_linearize_pendulum_lagrange_minimal():\n    if False:\n        i = 10\n    q1 = dynamicsymbols('q1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, q1d * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1], forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True, linear_solver='GJ')\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_lagrange_minimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    q1 = dynamicsymbols('q1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, q1d * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1], forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True, linear_solver='GJ')\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_lagrange_minimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    q1 = dynamicsymbols('q1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, q1d * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1], forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True, linear_solver='GJ')\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_lagrange_minimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    q1 = dynamicsymbols('q1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, q1d * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1], forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True, linear_solver='GJ')\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_lagrange_minimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    q1 = dynamicsymbols('q1')\n    q1d = dynamicsymbols('q1', 1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    A = N.orientnew('A', 'axis', [q1, N.z])\n    A.set_ang_vel(N, q1d * N.z)\n    P = pN.locatenew('P', L * A.x)\n    P.v2pt_theory(pN, N, A)\n    pP = Particle('pP', P, m)\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1], forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q1], [q1d], A_and_B=True, linear_solver='GJ')\n    assert simplify(A) == Matrix([[0, 1], [-9.8 * cos(q1) / L, 0]])\n    assert B == Matrix([])"
        ]
    },
    {
        "func_name": "test_linearize_pendulum_lagrange_nonminimal",
        "original": "def test_linearize_pendulum_lagrange_nonminimal():\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    P.set_vel(N, P.pos_from(pN).dt(N))\n    pP = Particle('pP', P, m)\n    f_c = Matrix([q1 ** 2 + q2 ** 2 - L ** 2])\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1, q2], hol_coneqs=f_c, forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    op_point = {q1: L, q2: 0, q1d: 0, q2d: 0, q1d.diff(t): 0, q2d.diff(t): 0}\n    lam_op = LM.solve_multipliers(op_point=op_point)\n    op_point.update(lam_op)\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
        "mutated": [
            "def test_linearize_pendulum_lagrange_nonminimal():\n    if False:\n        i = 10\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    P.set_vel(N, P.pos_from(pN).dt(N))\n    pP = Particle('pP', P, m)\n    f_c = Matrix([q1 ** 2 + q2 ** 2 - L ** 2])\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1, q2], hol_coneqs=f_c, forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    op_point = {q1: L, q2: 0, q1d: 0, q2d: 0, q1d.diff(t): 0, q2d.diff(t): 0}\n    lam_op = LM.solve_multipliers(op_point=op_point)\n    op_point.update(lam_op)\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_lagrange_nonminimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    P.set_vel(N, P.pos_from(pN).dt(N))\n    pP = Particle('pP', P, m)\n    f_c = Matrix([q1 ** 2 + q2 ** 2 - L ** 2])\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1, q2], hol_coneqs=f_c, forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    op_point = {q1: L, q2: 0, q1d: 0, q2d: 0, q1d.diff(t): 0, q2d.diff(t): 0}\n    lam_op = LM.solve_multipliers(op_point=op_point)\n    op_point.update(lam_op)\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_lagrange_nonminimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    P.set_vel(N, P.pos_from(pN).dt(N))\n    pP = Particle('pP', P, m)\n    f_c = Matrix([q1 ** 2 + q2 ** 2 - L ** 2])\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1, q2], hol_coneqs=f_c, forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    op_point = {q1: L, q2: 0, q1d: 0, q2d: 0, q1d.diff(t): 0, q2d.diff(t): 0}\n    lam_op = LM.solve_multipliers(op_point=op_point)\n    op_point.update(lam_op)\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_lagrange_nonminimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    P.set_vel(N, P.pos_from(pN).dt(N))\n    pP = Particle('pP', P, m)\n    f_c = Matrix([q1 ** 2 + q2 ** 2 - L ** 2])\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1, q2], hol_coneqs=f_c, forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    op_point = {q1: L, q2: 0, q1d: 0, q2d: 0, q1d.diff(t): 0, q2d.diff(t): 0}\n    lam_op = LM.solve_multipliers(op_point=op_point)\n    op_point.update(lam_op)\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])",
            "def test_linearize_pendulum_lagrange_nonminimal():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (q1, q2) = dynamicsymbols('q1:3')\n    (q1d, q2d) = dynamicsymbols('q1:3', level=1)\n    (L, m, t) = symbols('L, m, t')\n    g = 9.8\n    N = ReferenceFrame('N')\n    pN = Point('N*')\n    pN.set_vel(N, 0)\n    theta1 = atan(q2 / q1)\n    A = N.orientnew('A', 'axis', [theta1, N.z])\n    P = pN.locatenew('P1', q1 * N.x + q2 * N.y)\n    P.set_vel(N, P.pos_from(pN).dt(N))\n    pP = Particle('pP', P, m)\n    f_c = Matrix([q1 ** 2 + q2 ** 2 - L ** 2])\n    Lag = Lagrangian(N, pP)\n    LM = LagrangesMethod(Lag, [q1, q2], hol_coneqs=f_c, forcelist=[(P, m * g * N.x)], frame=N)\n    LM.form_lagranges_equations()\n    op_point = {q1: L, q2: 0, q1d: 0, q2d: 0, q1d.diff(t): 0, q2d.diff(t): 0}\n    lam_op = LM.solve_multipliers(op_point=op_point)\n    op_point.update(lam_op)\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True)\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])\n    (A, B, inp_vec) = LM.linearize([q2], [q2d], [q1], [q1d], op_point=op_point, A_and_B=True, linear_solver=lambda A, b: A.LUsolve(b))\n    assert simplify(A) == Matrix([[0, 1], [-9.8 / L, 0]])\n    assert B == Matrix([])"
        ]
    },
    {
        "func_name": "test_linearize_rolling_disc_lagrange",
        "original": "def test_linearize_rolling_disc_lagrange():\n    (q1, q2, q3) = q = dynamicsymbols('q1 q2 q3')\n    (q1d, q2d, q3d) = qd = dynamicsymbols('q1 q2 q3', 1)\n    (r, m, g) = symbols('r m g')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    L = Y.orientnew('L', 'Axis', [q2, Y.x])\n    R = L.orientnew('R', 'Axis', [q3, L.y])\n    C = Point('C')\n    C.set_vel(N, 0)\n    Dmc = C.locatenew('Dmc', r * L.z)\n    Dmc.v2pt_theory(C, N, R)\n    I = inertia(L, m / 4 * r ** 2, m / 2 * r ** 2, m / 4 * r ** 2)\n    BodyD = RigidBody('BodyD', Dmc, R, m, (I, Dmc))\n    BodyD.potential_energy = -m * g * r * cos(q2)\n    Lag = Lagrangian(N, BodyD)\n    l = LagrangesMethod(Lag, q)\n    l.form_lagranges_equations()\n    op_point = {q1: 0, q2: 0, q3: 0, q1d: 0, q2d: 0, q1d.diff(): 0, q2d.diff(): 0, q3d.diff(): 0}\n    A = l.linearize(q_ind=q, qd_ind=qd, op_point=op_point, A_and_B=True)[0]\n    sol = Matrix([[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, -6 * q3d, 0], [0, -4 * g / (5 * r), 0, 6 * q3d / 5, 0, 0], [0, 0, 0, 0, 0, 0]])\n    assert A == sol",
        "mutated": [
            "def test_linearize_rolling_disc_lagrange():\n    if False:\n        i = 10\n    (q1, q2, q3) = q = dynamicsymbols('q1 q2 q3')\n    (q1d, q2d, q3d) = qd = dynamicsymbols('q1 q2 q3', 1)\n    (r, m, g) = symbols('r m g')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    L = Y.orientnew('L', 'Axis', [q2, Y.x])\n    R = L.orientnew('R', 'Axis', [q3, L.y])\n    C = Point('C')\n    C.set_vel(N, 0)\n    Dmc = C.locatenew('Dmc', r * L.z)\n    Dmc.v2pt_theory(C, N, R)\n    I = inertia(L, m / 4 * r ** 2, m / 2 * r ** 2, m / 4 * r ** 2)\n    BodyD = RigidBody('BodyD', Dmc, R, m, (I, Dmc))\n    BodyD.potential_energy = -m * g * r * cos(q2)\n    Lag = Lagrangian(N, BodyD)\n    l = LagrangesMethod(Lag, q)\n    l.form_lagranges_equations()\n    op_point = {q1: 0, q2: 0, q3: 0, q1d: 0, q2d: 0, q1d.diff(): 0, q2d.diff(): 0, q3d.diff(): 0}\n    A = l.linearize(q_ind=q, qd_ind=qd, op_point=op_point, A_and_B=True)[0]\n    sol = Matrix([[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, -6 * q3d, 0], [0, -4 * g / (5 * r), 0, 6 * q3d / 5, 0, 0], [0, 0, 0, 0, 0, 0]])\n    assert A == sol",
            "def test_linearize_rolling_disc_lagrange():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (q1, q2, q3) = q = dynamicsymbols('q1 q2 q3')\n    (q1d, q2d, q3d) = qd = dynamicsymbols('q1 q2 q3', 1)\n    (r, m, g) = symbols('r m g')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    L = Y.orientnew('L', 'Axis', [q2, Y.x])\n    R = L.orientnew('R', 'Axis', [q3, L.y])\n    C = Point('C')\n    C.set_vel(N, 0)\n    Dmc = C.locatenew('Dmc', r * L.z)\n    Dmc.v2pt_theory(C, N, R)\n    I = inertia(L, m / 4 * r ** 2, m / 2 * r ** 2, m / 4 * r ** 2)\n    BodyD = RigidBody('BodyD', Dmc, R, m, (I, Dmc))\n    BodyD.potential_energy = -m * g * r * cos(q2)\n    Lag = Lagrangian(N, BodyD)\n    l = LagrangesMethod(Lag, q)\n    l.form_lagranges_equations()\n    op_point = {q1: 0, q2: 0, q3: 0, q1d: 0, q2d: 0, q1d.diff(): 0, q2d.diff(): 0, q3d.diff(): 0}\n    A = l.linearize(q_ind=q, qd_ind=qd, op_point=op_point, A_and_B=True)[0]\n    sol = Matrix([[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, -6 * q3d, 0], [0, -4 * g / (5 * r), 0, 6 * q3d / 5, 0, 0], [0, 0, 0, 0, 0, 0]])\n    assert A == sol",
            "def test_linearize_rolling_disc_lagrange():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (q1, q2, q3) = q = dynamicsymbols('q1 q2 q3')\n    (q1d, q2d, q3d) = qd = dynamicsymbols('q1 q2 q3', 1)\n    (r, m, g) = symbols('r m g')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    L = Y.orientnew('L', 'Axis', [q2, Y.x])\n    R = L.orientnew('R', 'Axis', [q3, L.y])\n    C = Point('C')\n    C.set_vel(N, 0)\n    Dmc = C.locatenew('Dmc', r * L.z)\n    Dmc.v2pt_theory(C, N, R)\n    I = inertia(L, m / 4 * r ** 2, m / 2 * r ** 2, m / 4 * r ** 2)\n    BodyD = RigidBody('BodyD', Dmc, R, m, (I, Dmc))\n    BodyD.potential_energy = -m * g * r * cos(q2)\n    Lag = Lagrangian(N, BodyD)\n    l = LagrangesMethod(Lag, q)\n    l.form_lagranges_equations()\n    op_point = {q1: 0, q2: 0, q3: 0, q1d: 0, q2d: 0, q1d.diff(): 0, q2d.diff(): 0, q3d.diff(): 0}\n    A = l.linearize(q_ind=q, qd_ind=qd, op_point=op_point, A_and_B=True)[0]\n    sol = Matrix([[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, -6 * q3d, 0], [0, -4 * g / (5 * r), 0, 6 * q3d / 5, 0, 0], [0, 0, 0, 0, 0, 0]])\n    assert A == sol",
            "def test_linearize_rolling_disc_lagrange():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (q1, q2, q3) = q = dynamicsymbols('q1 q2 q3')\n    (q1d, q2d, q3d) = qd = dynamicsymbols('q1 q2 q3', 1)\n    (r, m, g) = symbols('r m g')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    L = Y.orientnew('L', 'Axis', [q2, Y.x])\n    R = L.orientnew('R', 'Axis', [q3, L.y])\n    C = Point('C')\n    C.set_vel(N, 0)\n    Dmc = C.locatenew('Dmc', r * L.z)\n    Dmc.v2pt_theory(C, N, R)\n    I = inertia(L, m / 4 * r ** 2, m / 2 * r ** 2, m / 4 * r ** 2)\n    BodyD = RigidBody('BodyD', Dmc, R, m, (I, Dmc))\n    BodyD.potential_energy = -m * g * r * cos(q2)\n    Lag = Lagrangian(N, BodyD)\n    l = LagrangesMethod(Lag, q)\n    l.form_lagranges_equations()\n    op_point = {q1: 0, q2: 0, q3: 0, q1d: 0, q2d: 0, q1d.diff(): 0, q2d.diff(): 0, q3d.diff(): 0}\n    A = l.linearize(q_ind=q, qd_ind=qd, op_point=op_point, A_and_B=True)[0]\n    sol = Matrix([[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, -6 * q3d, 0], [0, -4 * g / (5 * r), 0, 6 * q3d / 5, 0, 0], [0, 0, 0, 0, 0, 0]])\n    assert A == sol",
            "def test_linearize_rolling_disc_lagrange():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (q1, q2, q3) = q = dynamicsymbols('q1 q2 q3')\n    (q1d, q2d, q3d) = qd = dynamicsymbols('q1 q2 q3', 1)\n    (r, m, g) = symbols('r m g')\n    N = ReferenceFrame('N')\n    Y = N.orientnew('Y', 'Axis', [q1, N.z])\n    L = Y.orientnew('L', 'Axis', [q2, Y.x])\n    R = L.orientnew('R', 'Axis', [q3, L.y])\n    C = Point('C')\n    C.set_vel(N, 0)\n    Dmc = C.locatenew('Dmc', r * L.z)\n    Dmc.v2pt_theory(C, N, R)\n    I = inertia(L, m / 4 * r ** 2, m / 2 * r ** 2, m / 4 * r ** 2)\n    BodyD = RigidBody('BodyD', Dmc, R, m, (I, Dmc))\n    BodyD.potential_energy = -m * g * r * cos(q2)\n    Lag = Lagrangian(N, BodyD)\n    l = LagrangesMethod(Lag, q)\n    l.form_lagranges_equations()\n    op_point = {q1: 0, q2: 0, q3: 0, q1d: 0, q2d: 0, q1d.diff(): 0, q2d.diff(): 0, q3d.diff(): 0}\n    A = l.linearize(q_ind=q, qd_ind=qd, op_point=op_point, A_and_B=True)[0]\n    sol = Matrix([[0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, -6 * q3d, 0], [0, -4 * g / (5 * r), 0, 6 * q3d / 5, 0, 0], [0, 0, 0, 0, 0, 0]])\n    assert A == sol"
        ]
    }
]