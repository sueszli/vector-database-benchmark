from __future__ import division
from __future__ import print_function
import numpy as np
import pandas as pd
from scipy.stats import spearmanr, pearsonr
from ..data import D
from collections import OrderedDict

def _get_position_value_from_df(evaluate_date, position, close_data_df):
    if False:
        for i in range(10):
            print('nop')
    "Get position value by existed close data df\n    close_data_df:\n        pd.DataFrame\n        multi-index\n        close_data_df['$close'][stock_id][evaluate_date]: close price for (stock_id, evaluate_date)\n    position:\n        same in get_position_value()\n    "
    value = 0
    for (stock_id, report) in position.items():
        if stock_id != 'cash':
            value += report['amount'] * close_data_df['$close'][stock_id][evaluate_date]
    if 'cash' in position:
        value += position['cash']
    return value

def get_position_value(evaluate_date, position):
    if False:
        i = 10
        return i + 15
    "sum of close*amount\n\n    get value of position\n\n    use close price\n\n        positions:\n        {\n            Timestamp('2016-01-05 00:00:00'):\n            {\n                'SH600022':\n                {\n                    'amount':100.00,\n                    'price':12.00\n                },\n\n                'cash':100000.0\n            }\n        }\n\n    It means Hold 100.0 'SH600022' and 100000.0 RMB in '2016-01-05'\n    "
    instruments = list(position.keys())
    instruments = list(set(instruments) - {'cash'})
    fields = ['$close']
    close_data_df = D.features(instruments, fields, start_time=evaluate_date, end_time=evaluate_date, freq='day', disk_cache=0)
    value = _get_position_value_from_df(evaluate_date, position, close_data_df)
    return value

def get_position_list_value(positions):
    if False:
        i = 10
        return i + 15
    instruments = set()
    for (day, position) in positions.items():
        instruments.update(position.keys())
    instruments = list(set(instruments) - {'cash'})
    instruments.sort()
    day_list = list(positions.keys())
    day_list.sort()
    (start_date, end_date) = (day_list[0], day_list[-1])
    fields = ['$close']
    close_data_df = D.features(instruments, fields, start_time=start_date, end_time=end_date, freq='day', disk_cache=0)
    value_dict = OrderedDict()
    for (day, position) in positions.items():
        value = _get_position_value_from_df(evaluate_date=day, position=position, close_data_df=close_data_df)
        value_dict[day] = value
    return value_dict

def get_daily_return_series_from_positions(positions, init_asset_value):
    if False:
        print('Hello World!')
    'Parameters\n    generate daily return series from  position view\n    positions: positions generated by strategy\n    init_asset_value : init asset value\n    return: pd.Series of daily return , return_series[date] = daily return rate\n    '
    value_dict = get_position_list_value(positions)
    value_series = pd.Series(value_dict)
    value_series = value_series.sort_index()
    return_series = value_series.pct_change()
    return_series[value_series.index[0]] = value_series[value_series.index[0]] / init_asset_value - 1
    return return_series

def get_annual_return_from_positions(positions, init_asset_value):
    if False:
        for i in range(10):
            print('nop')
    'Annualized Returns\n\n    p_r = (p_end / p_start)^{(250/n)} - 1\n\n    p_r     annual return\n    p_end   final value\n    p_start init value\n    n       days of backtest\n\n    '
    date_range_list = sorted(list(positions.keys()))
    end_time = date_range_list[-1]
    p_end = get_position_value(end_time, positions[end_time])
    p_start = init_asset_value
    n_period = len(date_range_list)
    annual = pow(p_end / p_start, 250 / n_period) - 1
    return annual

def get_annaul_return_from_return_series(r, method='ci'):
    if False:
        i = 10
        return i + 15
    'Risk Analysis from daily return series\n\n    Parameters\n    ----------\n    r : pandas.Series\n        daily return series\n    method : str\n        interest calculation method, ci(compound interest)/si(simple interest)\n    '
    mean = r.mean()
    annual = (1 + mean) ** 250 - 1 if method == 'ci' else mean * 250
    return annual

def get_sharpe_ratio_from_return_series(r, risk_free_rate=0.0, method='ci'):
    if False:
        for i in range(10):
            print('nop')
    'Risk Analysis\n\n    Parameters\n    ----------\n    r : pandas.Series\n        daily return series\n    method : str\n        interest calculation method, ci(compound interest)/si(simple interest)\n    risk_free_rate : float\n        risk_free_rate, default as 0.00, can set as 0.03 etc\n    '
    std = r.std(ddof=1)
    annual = get_annaul_return_from_return_series(r, method=method)
    sharpe = (annual - risk_free_rate) / std / np.sqrt(250)
    return sharpe

def get_max_drawdown_from_series(r):
    if False:
        print('Hello World!')
    'Risk Analysis from asset value\n\n    cumprod way\n\n    Parameters\n    ----------\n    r : pandas.Series\n        daily return series\n    '
    mdd = (((1 + r).cumprod() - (1 + r).cumprod().cummax()) / (1 + r).cumprod().cummax()).min()
    return mdd

def get_turnover_rate():
    if False:
        i = 10
        return i + 15
    pass

def get_beta(r, b):
    if False:
        for i in range(10):
            print('nop')
    'Risk Analysis  beta\n\n    Parameters\n    ----------\n    r : pandas.Series\n        daily return series of strategy\n    b : pandas.Series\n        daily return series of baseline\n    '
    cov_r_b = np.cov(r, b)
    var_b = np.var(b)
    return cov_r_b / var_b

def get_alpha(r, b, risk_free_rate=0.03):
    if False:
        i = 10
        return i + 15
    beta = get_beta(r, b)
    annaul_r = get_annaul_return_from_return_series(r)
    annaul_b = get_annaul_return_from_return_series(b)
    alpha = annaul_r - risk_free_rate - beta * (annaul_b - risk_free_rate)
    return alpha

def get_volatility_from_series(r):
    if False:
        while True:
            i = 10
    return r.std(ddof=1)

def get_rank_ic(a, b):
    if False:
        for i in range(10):
            print('nop')
    'Rank IC\n\n    Parameters\n    ----------\n    r : pandas.Series\n        daily score series of feature\n    b : pandas.Series\n        daily return series\n\n    '
    return spearmanr(a, b).correlation

def get_normal_ic(a, b):
    if False:
        i = 10
        return i + 15
    return pearsonr(a, b)[0]