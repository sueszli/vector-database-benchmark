[
    {
        "func_name": "filter_targets",
        "original": "def filter_targets(self, targets: list[TestTarget]) -> list[TestTarget]:\n    \"\"\"Return the given list of test targets, filtered to include only those relevant for the test.\"\"\"\n    plugin_paths = [plugin_path for (plugin_type, plugin_path) in data_context().content.plugin_paths.items() if plugin_type in DOCUMENTABLE_PLUGINS]\n    return [target for target in targets if os.path.splitext(target.path)[1] == '.py' and os.path.basename(target.path) != '__init__.py' and any((is_subdir(target.path, path) for path in plugin_paths))]",
        "mutated": [
            "def filter_targets(self, targets: list[TestTarget]) -> list[TestTarget]:\n    if False:\n        i = 10\n    'Return the given list of test targets, filtered to include only those relevant for the test.'\n    plugin_paths = [plugin_path for (plugin_type, plugin_path) in data_context().content.plugin_paths.items() if plugin_type in DOCUMENTABLE_PLUGINS]\n    return [target for target in targets if os.path.splitext(target.path)[1] == '.py' and os.path.basename(target.path) != '__init__.py' and any((is_subdir(target.path, path) for path in plugin_paths))]",
            "def filter_targets(self, targets: list[TestTarget]) -> list[TestTarget]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the given list of test targets, filtered to include only those relevant for the test.'\n    plugin_paths = [plugin_path for (plugin_type, plugin_path) in data_context().content.plugin_paths.items() if plugin_type in DOCUMENTABLE_PLUGINS]\n    return [target for target in targets if os.path.splitext(target.path)[1] == '.py' and os.path.basename(target.path) != '__init__.py' and any((is_subdir(target.path, path) for path in plugin_paths))]",
            "def filter_targets(self, targets: list[TestTarget]) -> list[TestTarget]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the given list of test targets, filtered to include only those relevant for the test.'\n    plugin_paths = [plugin_path for (plugin_type, plugin_path) in data_context().content.plugin_paths.items() if plugin_type in DOCUMENTABLE_PLUGINS]\n    return [target for target in targets if os.path.splitext(target.path)[1] == '.py' and os.path.basename(target.path) != '__init__.py' and any((is_subdir(target.path, path) for path in plugin_paths))]",
            "def filter_targets(self, targets: list[TestTarget]) -> list[TestTarget]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the given list of test targets, filtered to include only those relevant for the test.'\n    plugin_paths = [plugin_path for (plugin_type, plugin_path) in data_context().content.plugin_paths.items() if plugin_type in DOCUMENTABLE_PLUGINS]\n    return [target for target in targets if os.path.splitext(target.path)[1] == '.py' and os.path.basename(target.path) != '__init__.py' and any((is_subdir(target.path, path) for path in plugin_paths))]",
            "def filter_targets(self, targets: list[TestTarget]) -> list[TestTarget]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the given list of test targets, filtered to include only those relevant for the test.'\n    plugin_paths = [plugin_path for (plugin_type, plugin_path) in data_context().content.plugin_paths.items() if plugin_type in DOCUMENTABLE_PLUGINS]\n    return [target for target in targets if os.path.splitext(target.path)[1] == '.py' and os.path.basename(target.path) != '__init__.py' and any((is_subdir(target.path, path) for path in plugin_paths))]"
        ]
    },
    {
        "func_name": "test",
        "original": "def test(self, args: SanityConfig, targets: SanityTargets, python: PythonConfig) -> TestResult:\n    settings = self.load_processor(args)\n    paths = [target.path for target in targets.include]\n    doc_targets: dict[str, list[str]] = collections.defaultdict(list)\n    remap_types = dict(modules='module')\n    for (plugin_type, plugin_path) in data_context().content.plugin_paths.items():\n        plugin_type = remap_types.get(plugin_type, plugin_type)\n        for plugin_file_path in [target.name for target in targets.include if is_subdir(target.path, plugin_path)]:\n            plugin_parts = os.path.relpath(plugin_file_path, plugin_path).split(os.path.sep)\n            plugin_name = os.path.splitext(plugin_parts[-1])[0]\n            if plugin_name.startswith('_'):\n                plugin_name = plugin_name[1:]\n            plugin_fqcn = data_context().content.prefix + '.'.join(plugin_parts[:-1] + [plugin_name])\n            doc_targets[plugin_type].append(plugin_fqcn)\n    env = ansible_environment(args, color=False)\n    for doc_type in MULTI_FILE_PLUGINS:\n        if doc_targets.get(doc_type):\n            cmd = ['ansible-doc', '-l', '--json', '-t', doc_type]\n            prefix = data_context().content.prefix if data_context().content.collection else 'ansible.builtin.'\n            cmd.append(prefix[:-1])\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if args.explain:\n                continue\n            plugin_list_json = json.loads(stdout)\n            doc_targets[doc_type] = []\n            for (plugin_name, plugin_value) in sorted(plugin_list_json.items()):\n                if plugin_value != 'UNDOCUMENTED':\n                    doc_targets[doc_type].append(plugin_name)\n            if not doc_targets[doc_type]:\n                del doc_targets[doc_type]\n    error_messages: list[SanityMessage] = []\n    for doc_type in sorted(doc_targets):\n        for format_option in [None, '--json']:\n            cmd = ['ansible-doc', '-t', doc_type]\n            if format_option is not None:\n                cmd.append(format_option)\n            cmd.extend(sorted(doc_targets[doc_type]))\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                stderr = re.sub('\\\\[WARNING]: [^ ]+ [^ ]+ has been removed\\\\n', '', stderr).strip()\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n    if args.explain:\n        return SanitySuccess(self.name)\n    error_messages = settings.process_errors(error_messages, paths)\n    if error_messages:\n        return SanityFailure(self.name, messages=error_messages)\n    return SanitySuccess(self.name)",
        "mutated": [
            "def test(self, args: SanityConfig, targets: SanityTargets, python: PythonConfig) -> TestResult:\n    if False:\n        i = 10\n    settings = self.load_processor(args)\n    paths = [target.path for target in targets.include]\n    doc_targets: dict[str, list[str]] = collections.defaultdict(list)\n    remap_types = dict(modules='module')\n    for (plugin_type, plugin_path) in data_context().content.plugin_paths.items():\n        plugin_type = remap_types.get(plugin_type, plugin_type)\n        for plugin_file_path in [target.name for target in targets.include if is_subdir(target.path, plugin_path)]:\n            plugin_parts = os.path.relpath(plugin_file_path, plugin_path).split(os.path.sep)\n            plugin_name = os.path.splitext(plugin_parts[-1])[0]\n            if plugin_name.startswith('_'):\n                plugin_name = plugin_name[1:]\n            plugin_fqcn = data_context().content.prefix + '.'.join(plugin_parts[:-1] + [plugin_name])\n            doc_targets[plugin_type].append(plugin_fqcn)\n    env = ansible_environment(args, color=False)\n    for doc_type in MULTI_FILE_PLUGINS:\n        if doc_targets.get(doc_type):\n            cmd = ['ansible-doc', '-l', '--json', '-t', doc_type]\n            prefix = data_context().content.prefix if data_context().content.collection else 'ansible.builtin.'\n            cmd.append(prefix[:-1])\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if args.explain:\n                continue\n            plugin_list_json = json.loads(stdout)\n            doc_targets[doc_type] = []\n            for (plugin_name, plugin_value) in sorted(plugin_list_json.items()):\n                if plugin_value != 'UNDOCUMENTED':\n                    doc_targets[doc_type].append(plugin_name)\n            if not doc_targets[doc_type]:\n                del doc_targets[doc_type]\n    error_messages: list[SanityMessage] = []\n    for doc_type in sorted(doc_targets):\n        for format_option in [None, '--json']:\n            cmd = ['ansible-doc', '-t', doc_type]\n            if format_option is not None:\n                cmd.append(format_option)\n            cmd.extend(sorted(doc_targets[doc_type]))\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                stderr = re.sub('\\\\[WARNING]: [^ ]+ [^ ]+ has been removed\\\\n', '', stderr).strip()\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n    if args.explain:\n        return SanitySuccess(self.name)\n    error_messages = settings.process_errors(error_messages, paths)\n    if error_messages:\n        return SanityFailure(self.name, messages=error_messages)\n    return SanitySuccess(self.name)",
            "def test(self, args: SanityConfig, targets: SanityTargets, python: PythonConfig) -> TestResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    settings = self.load_processor(args)\n    paths = [target.path for target in targets.include]\n    doc_targets: dict[str, list[str]] = collections.defaultdict(list)\n    remap_types = dict(modules='module')\n    for (plugin_type, plugin_path) in data_context().content.plugin_paths.items():\n        plugin_type = remap_types.get(plugin_type, plugin_type)\n        for plugin_file_path in [target.name for target in targets.include if is_subdir(target.path, plugin_path)]:\n            plugin_parts = os.path.relpath(plugin_file_path, plugin_path).split(os.path.sep)\n            plugin_name = os.path.splitext(plugin_parts[-1])[0]\n            if plugin_name.startswith('_'):\n                plugin_name = plugin_name[1:]\n            plugin_fqcn = data_context().content.prefix + '.'.join(plugin_parts[:-1] + [plugin_name])\n            doc_targets[plugin_type].append(plugin_fqcn)\n    env = ansible_environment(args, color=False)\n    for doc_type in MULTI_FILE_PLUGINS:\n        if doc_targets.get(doc_type):\n            cmd = ['ansible-doc', '-l', '--json', '-t', doc_type]\n            prefix = data_context().content.prefix if data_context().content.collection else 'ansible.builtin.'\n            cmd.append(prefix[:-1])\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if args.explain:\n                continue\n            plugin_list_json = json.loads(stdout)\n            doc_targets[doc_type] = []\n            for (plugin_name, plugin_value) in sorted(plugin_list_json.items()):\n                if plugin_value != 'UNDOCUMENTED':\n                    doc_targets[doc_type].append(plugin_name)\n            if not doc_targets[doc_type]:\n                del doc_targets[doc_type]\n    error_messages: list[SanityMessage] = []\n    for doc_type in sorted(doc_targets):\n        for format_option in [None, '--json']:\n            cmd = ['ansible-doc', '-t', doc_type]\n            if format_option is not None:\n                cmd.append(format_option)\n            cmd.extend(sorted(doc_targets[doc_type]))\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                stderr = re.sub('\\\\[WARNING]: [^ ]+ [^ ]+ has been removed\\\\n', '', stderr).strip()\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n    if args.explain:\n        return SanitySuccess(self.name)\n    error_messages = settings.process_errors(error_messages, paths)\n    if error_messages:\n        return SanityFailure(self.name, messages=error_messages)\n    return SanitySuccess(self.name)",
            "def test(self, args: SanityConfig, targets: SanityTargets, python: PythonConfig) -> TestResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    settings = self.load_processor(args)\n    paths = [target.path for target in targets.include]\n    doc_targets: dict[str, list[str]] = collections.defaultdict(list)\n    remap_types = dict(modules='module')\n    for (plugin_type, plugin_path) in data_context().content.plugin_paths.items():\n        plugin_type = remap_types.get(plugin_type, plugin_type)\n        for plugin_file_path in [target.name for target in targets.include if is_subdir(target.path, plugin_path)]:\n            plugin_parts = os.path.relpath(plugin_file_path, plugin_path).split(os.path.sep)\n            plugin_name = os.path.splitext(plugin_parts[-1])[0]\n            if plugin_name.startswith('_'):\n                plugin_name = plugin_name[1:]\n            plugin_fqcn = data_context().content.prefix + '.'.join(plugin_parts[:-1] + [plugin_name])\n            doc_targets[plugin_type].append(plugin_fqcn)\n    env = ansible_environment(args, color=False)\n    for doc_type in MULTI_FILE_PLUGINS:\n        if doc_targets.get(doc_type):\n            cmd = ['ansible-doc', '-l', '--json', '-t', doc_type]\n            prefix = data_context().content.prefix if data_context().content.collection else 'ansible.builtin.'\n            cmd.append(prefix[:-1])\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if args.explain:\n                continue\n            plugin_list_json = json.loads(stdout)\n            doc_targets[doc_type] = []\n            for (plugin_name, plugin_value) in sorted(plugin_list_json.items()):\n                if plugin_value != 'UNDOCUMENTED':\n                    doc_targets[doc_type].append(plugin_name)\n            if not doc_targets[doc_type]:\n                del doc_targets[doc_type]\n    error_messages: list[SanityMessage] = []\n    for doc_type in sorted(doc_targets):\n        for format_option in [None, '--json']:\n            cmd = ['ansible-doc', '-t', doc_type]\n            if format_option is not None:\n                cmd.append(format_option)\n            cmd.extend(sorted(doc_targets[doc_type]))\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                stderr = re.sub('\\\\[WARNING]: [^ ]+ [^ ]+ has been removed\\\\n', '', stderr).strip()\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n    if args.explain:\n        return SanitySuccess(self.name)\n    error_messages = settings.process_errors(error_messages, paths)\n    if error_messages:\n        return SanityFailure(self.name, messages=error_messages)\n    return SanitySuccess(self.name)",
            "def test(self, args: SanityConfig, targets: SanityTargets, python: PythonConfig) -> TestResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    settings = self.load_processor(args)\n    paths = [target.path for target in targets.include]\n    doc_targets: dict[str, list[str]] = collections.defaultdict(list)\n    remap_types = dict(modules='module')\n    for (plugin_type, plugin_path) in data_context().content.plugin_paths.items():\n        plugin_type = remap_types.get(plugin_type, plugin_type)\n        for plugin_file_path in [target.name for target in targets.include if is_subdir(target.path, plugin_path)]:\n            plugin_parts = os.path.relpath(plugin_file_path, plugin_path).split(os.path.sep)\n            plugin_name = os.path.splitext(plugin_parts[-1])[0]\n            if plugin_name.startswith('_'):\n                plugin_name = plugin_name[1:]\n            plugin_fqcn = data_context().content.prefix + '.'.join(plugin_parts[:-1] + [plugin_name])\n            doc_targets[plugin_type].append(plugin_fqcn)\n    env = ansible_environment(args, color=False)\n    for doc_type in MULTI_FILE_PLUGINS:\n        if doc_targets.get(doc_type):\n            cmd = ['ansible-doc', '-l', '--json', '-t', doc_type]\n            prefix = data_context().content.prefix if data_context().content.collection else 'ansible.builtin.'\n            cmd.append(prefix[:-1])\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if args.explain:\n                continue\n            plugin_list_json = json.loads(stdout)\n            doc_targets[doc_type] = []\n            for (plugin_name, plugin_value) in sorted(plugin_list_json.items()):\n                if plugin_value != 'UNDOCUMENTED':\n                    doc_targets[doc_type].append(plugin_name)\n            if not doc_targets[doc_type]:\n                del doc_targets[doc_type]\n    error_messages: list[SanityMessage] = []\n    for doc_type in sorted(doc_targets):\n        for format_option in [None, '--json']:\n            cmd = ['ansible-doc', '-t', doc_type]\n            if format_option is not None:\n                cmd.append(format_option)\n            cmd.extend(sorted(doc_targets[doc_type]))\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                stderr = re.sub('\\\\[WARNING]: [^ ]+ [^ ]+ has been removed\\\\n', '', stderr).strip()\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n    if args.explain:\n        return SanitySuccess(self.name)\n    error_messages = settings.process_errors(error_messages, paths)\n    if error_messages:\n        return SanityFailure(self.name, messages=error_messages)\n    return SanitySuccess(self.name)",
            "def test(self, args: SanityConfig, targets: SanityTargets, python: PythonConfig) -> TestResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    settings = self.load_processor(args)\n    paths = [target.path for target in targets.include]\n    doc_targets: dict[str, list[str]] = collections.defaultdict(list)\n    remap_types = dict(modules='module')\n    for (plugin_type, plugin_path) in data_context().content.plugin_paths.items():\n        plugin_type = remap_types.get(plugin_type, plugin_type)\n        for plugin_file_path in [target.name for target in targets.include if is_subdir(target.path, plugin_path)]:\n            plugin_parts = os.path.relpath(plugin_file_path, plugin_path).split(os.path.sep)\n            plugin_name = os.path.splitext(plugin_parts[-1])[0]\n            if plugin_name.startswith('_'):\n                plugin_name = plugin_name[1:]\n            plugin_fqcn = data_context().content.prefix + '.'.join(plugin_parts[:-1] + [plugin_name])\n            doc_targets[plugin_type].append(plugin_fqcn)\n    env = ansible_environment(args, color=False)\n    for doc_type in MULTI_FILE_PLUGINS:\n        if doc_targets.get(doc_type):\n            cmd = ['ansible-doc', '-l', '--json', '-t', doc_type]\n            prefix = data_context().content.prefix if data_context().content.collection else 'ansible.builtin.'\n            cmd.append(prefix[:-1])\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if args.explain:\n                continue\n            plugin_list_json = json.loads(stdout)\n            doc_targets[doc_type] = []\n            for (plugin_name, plugin_value) in sorted(plugin_list_json.items()):\n                if plugin_value != 'UNDOCUMENTED':\n                    doc_targets[doc_type].append(plugin_name)\n            if not doc_targets[doc_type]:\n                del doc_targets[doc_type]\n    error_messages: list[SanityMessage] = []\n    for doc_type in sorted(doc_targets):\n        for format_option in [None, '--json']:\n            cmd = ['ansible-doc', '-t', doc_type]\n            if format_option is not None:\n                cmd.append(format_option)\n            cmd.extend(sorted(doc_targets[doc_type]))\n            try:\n                (stdout, stderr) = intercept_python(args, python, cmd, env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n            if status:\n                summary = '%s' % SubprocessError(cmd=cmd, status=status, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n            if stdout:\n                display.info(stdout.strip(), verbosity=3)\n            if stderr:\n                stderr = re.sub('\\\\[WARNING]: [^ ]+ [^ ]+ has been removed\\\\n', '', stderr).strip()\n            if stderr:\n                summary = 'Output on stderr from ansible-doc is considered an error.\\n\\n%s' % SubprocessError(cmd, stderr=stderr)\n                return SanityFailure(self.name, summary=summary)\n    if args.explain:\n        return SanitySuccess(self.name)\n    error_messages = settings.process_errors(error_messages, paths)\n    if error_messages:\n        return SanityFailure(self.name, messages=error_messages)\n    return SanitySuccess(self.name)"
        ]
    }
]