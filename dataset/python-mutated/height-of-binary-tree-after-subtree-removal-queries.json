[
    {
        "func_name": "__init__",
        "original": "def __init__(self, val=0, left=None, right=None):\n    pass",
        "mutated": [
            "def __init__(self, val=0, left=None, right=None):\n    if False:\n        i = 10\n    pass",
            "def __init__(self, val=0, left=None, right=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def __init__(self, val=0, left=None, right=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def __init__(self, val=0, left=None, right=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def __init__(self, val=0, left=None, right=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "iter_dfs",
        "original": "def iter_dfs(root):\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    stk = [(1, (root, 0))]\n    while stk:\n        (step, (curr, d)) = stk.pop()\n        if step == 1:\n            if not curr:\n                continue\n            stk.append((2, (curr, d)))\n            stk.append((1, (curr.right, d + 1)))\n            stk.append((1, (curr.left, d + 1)))\n        elif step == 2:\n            h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n            if h > top[d][0]:\n                (top[d][0], top[d][1]) = (h, top[d][0])\n            elif h > top[d][1]:\n                top[d][1] = h\n            (depth[curr.val], height[curr.val]) = (d, h)\n    return (top, depth, height)",
        "mutated": [
            "def iter_dfs(root):\n    if False:\n        i = 10\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    stk = [(1, (root, 0))]\n    while stk:\n        (step, (curr, d)) = stk.pop()\n        if step == 1:\n            if not curr:\n                continue\n            stk.append((2, (curr, d)))\n            stk.append((1, (curr.right, d + 1)))\n            stk.append((1, (curr.left, d + 1)))\n        elif step == 2:\n            h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n            if h > top[d][0]:\n                (top[d][0], top[d][1]) = (h, top[d][0])\n            elif h > top[d][1]:\n                top[d][1] = h\n            (depth[curr.val], height[curr.val]) = (d, h)\n    return (top, depth, height)",
            "def iter_dfs(root):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    stk = [(1, (root, 0))]\n    while stk:\n        (step, (curr, d)) = stk.pop()\n        if step == 1:\n            if not curr:\n                continue\n            stk.append((2, (curr, d)))\n            stk.append((1, (curr.right, d + 1)))\n            stk.append((1, (curr.left, d + 1)))\n        elif step == 2:\n            h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n            if h > top[d][0]:\n                (top[d][0], top[d][1]) = (h, top[d][0])\n            elif h > top[d][1]:\n                top[d][1] = h\n            (depth[curr.val], height[curr.val]) = (d, h)\n    return (top, depth, height)",
            "def iter_dfs(root):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    stk = [(1, (root, 0))]\n    while stk:\n        (step, (curr, d)) = stk.pop()\n        if step == 1:\n            if not curr:\n                continue\n            stk.append((2, (curr, d)))\n            stk.append((1, (curr.right, d + 1)))\n            stk.append((1, (curr.left, d + 1)))\n        elif step == 2:\n            h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n            if h > top[d][0]:\n                (top[d][0], top[d][1]) = (h, top[d][0])\n            elif h > top[d][1]:\n                top[d][1] = h\n            (depth[curr.val], height[curr.val]) = (d, h)\n    return (top, depth, height)",
            "def iter_dfs(root):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    stk = [(1, (root, 0))]\n    while stk:\n        (step, (curr, d)) = stk.pop()\n        if step == 1:\n            if not curr:\n                continue\n            stk.append((2, (curr, d)))\n            stk.append((1, (curr.right, d + 1)))\n            stk.append((1, (curr.left, d + 1)))\n        elif step == 2:\n            h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n            if h > top[d][0]:\n                (top[d][0], top[d][1]) = (h, top[d][0])\n            elif h > top[d][1]:\n                top[d][1] = h\n            (depth[curr.val], height[curr.val]) = (d, h)\n    return (top, depth, height)",
            "def iter_dfs(root):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    stk = [(1, (root, 0))]\n    while stk:\n        (step, (curr, d)) = stk.pop()\n        if step == 1:\n            if not curr:\n                continue\n            stk.append((2, (curr, d)))\n            stk.append((1, (curr.right, d + 1)))\n            stk.append((1, (curr.left, d + 1)))\n        elif step == 2:\n            h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n            if h > top[d][0]:\n                (top[d][0], top[d][1]) = (h, top[d][0])\n            elif h > top[d][1]:\n                top[d][1] = h\n            (depth[curr.val], height[curr.val]) = (d, h)\n    return (top, depth, height)"
        ]
    },
    {
        "func_name": "treeQueries",
        "original": "def treeQueries(self, root, queries):\n    \"\"\"\n        :type root: Optional[TreeNode]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n\n    def iter_dfs(root):\n        top = collections.defaultdict(lambda : [0] * 2)\n        (depth, height) = ({}, {})\n        stk = [(1, (root, 0))]\n        while stk:\n            (step, (curr, d)) = stk.pop()\n            if step == 1:\n                if not curr:\n                    continue\n                stk.append((2, (curr, d)))\n                stk.append((1, (curr.right, d + 1)))\n                stk.append((1, (curr.left, d + 1)))\n            elif step == 2:\n                h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n                if h > top[d][0]:\n                    (top[d][0], top[d][1]) = (h, top[d][0])\n                elif h > top[d][1]:\n                    top[d][1] = h\n                (depth[curr.val], height[curr.val]) = (d, h)\n        return (top, depth, height)\n    (top, depth, height) = iter_dfs(root)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
        "mutated": [
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def iter_dfs(root):\n        top = collections.defaultdict(lambda : [0] * 2)\n        (depth, height) = ({}, {})\n        stk = [(1, (root, 0))]\n        while stk:\n            (step, (curr, d)) = stk.pop()\n            if step == 1:\n                if not curr:\n                    continue\n                stk.append((2, (curr, d)))\n                stk.append((1, (curr.right, d + 1)))\n                stk.append((1, (curr.left, d + 1)))\n            elif step == 2:\n                h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n                if h > top[d][0]:\n                    (top[d][0], top[d][1]) = (h, top[d][0])\n                elif h > top[d][1]:\n                    top[d][1] = h\n                (depth[curr.val], height[curr.val]) = (d, h)\n        return (top, depth, height)\n    (top, depth, height) = iter_dfs(root)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def iter_dfs(root):\n        top = collections.defaultdict(lambda : [0] * 2)\n        (depth, height) = ({}, {})\n        stk = [(1, (root, 0))]\n        while stk:\n            (step, (curr, d)) = stk.pop()\n            if step == 1:\n                if not curr:\n                    continue\n                stk.append((2, (curr, d)))\n                stk.append((1, (curr.right, d + 1)))\n                stk.append((1, (curr.left, d + 1)))\n            elif step == 2:\n                h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n                if h > top[d][0]:\n                    (top[d][0], top[d][1]) = (h, top[d][0])\n                elif h > top[d][1]:\n                    top[d][1] = h\n                (depth[curr.val], height[curr.val]) = (d, h)\n        return (top, depth, height)\n    (top, depth, height) = iter_dfs(root)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def iter_dfs(root):\n        top = collections.defaultdict(lambda : [0] * 2)\n        (depth, height) = ({}, {})\n        stk = [(1, (root, 0))]\n        while stk:\n            (step, (curr, d)) = stk.pop()\n            if step == 1:\n                if not curr:\n                    continue\n                stk.append((2, (curr, d)))\n                stk.append((1, (curr.right, d + 1)))\n                stk.append((1, (curr.left, d + 1)))\n            elif step == 2:\n                h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n                if h > top[d][0]:\n                    (top[d][0], top[d][1]) = (h, top[d][0])\n                elif h > top[d][1]:\n                    top[d][1] = h\n                (depth[curr.val], height[curr.val]) = (d, h)\n        return (top, depth, height)\n    (top, depth, height) = iter_dfs(root)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def iter_dfs(root):\n        top = collections.defaultdict(lambda : [0] * 2)\n        (depth, height) = ({}, {})\n        stk = [(1, (root, 0))]\n        while stk:\n            (step, (curr, d)) = stk.pop()\n            if step == 1:\n                if not curr:\n                    continue\n                stk.append((2, (curr, d)))\n                stk.append((1, (curr.right, d + 1)))\n                stk.append((1, (curr.left, d + 1)))\n            elif step == 2:\n                h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n                if h > top[d][0]:\n                    (top[d][0], top[d][1]) = (h, top[d][0])\n                elif h > top[d][1]:\n                    top[d][1] = h\n                (depth[curr.val], height[curr.val]) = (d, h)\n        return (top, depth, height)\n    (top, depth, height) = iter_dfs(root)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def iter_dfs(root):\n        top = collections.defaultdict(lambda : [0] * 2)\n        (depth, height) = ({}, {})\n        stk = [(1, (root, 0))]\n        while stk:\n            (step, (curr, d)) = stk.pop()\n            if step == 1:\n                if not curr:\n                    continue\n                stk.append((2, (curr, d)))\n                stk.append((1, (curr.right, d + 1)))\n                stk.append((1, (curr.left, d + 1)))\n            elif step == 2:\n                h = 1 + max(height[curr.left.val] if curr.left else 0, height[curr.right.val] if curr.right else 0)\n                if h > top[d][0]:\n                    (top[d][0], top[d][1]) = (h, top[d][0])\n                elif h > top[d][1]:\n                    top[d][1] = h\n                (depth[curr.val], height[curr.val]) = (d, h)\n        return (top, depth, height)\n    (top, depth, height) = iter_dfs(root)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]"
        ]
    },
    {
        "func_name": "dfs",
        "original": "def dfs(curr, d):\n    if not curr:\n        return 0\n    h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n    if h > top[d][0]:\n        (top[d][0], top[d][1]) = (h, top[d][0])\n    elif h > top[d][1]:\n        top[d][1] = h\n    (depth[curr.val], height[curr.val]) = (d, h)\n    return h",
        "mutated": [
            "def dfs(curr, d):\n    if False:\n        i = 10\n    if not curr:\n        return 0\n    h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n    if h > top[d][0]:\n        (top[d][0], top[d][1]) = (h, top[d][0])\n    elif h > top[d][1]:\n        top[d][1] = h\n    (depth[curr.val], height[curr.val]) = (d, h)\n    return h",
            "def dfs(curr, d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not curr:\n        return 0\n    h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n    if h > top[d][0]:\n        (top[d][0], top[d][1]) = (h, top[d][0])\n    elif h > top[d][1]:\n        top[d][1] = h\n    (depth[curr.val], height[curr.val]) = (d, h)\n    return h",
            "def dfs(curr, d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not curr:\n        return 0\n    h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n    if h > top[d][0]:\n        (top[d][0], top[d][1]) = (h, top[d][0])\n    elif h > top[d][1]:\n        top[d][1] = h\n    (depth[curr.val], height[curr.val]) = (d, h)\n    return h",
            "def dfs(curr, d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not curr:\n        return 0\n    h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n    if h > top[d][0]:\n        (top[d][0], top[d][1]) = (h, top[d][0])\n    elif h > top[d][1]:\n        top[d][1] = h\n    (depth[curr.val], height[curr.val]) = (d, h)\n    return h",
            "def dfs(curr, d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not curr:\n        return 0\n    h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n    if h > top[d][0]:\n        (top[d][0], top[d][1]) = (h, top[d][0])\n    elif h > top[d][1]:\n        top[d][1] = h\n    (depth[curr.val], height[curr.val]) = (d, h)\n    return h"
        ]
    },
    {
        "func_name": "treeQueries",
        "original": "def treeQueries(self, root, queries):\n    \"\"\"\n        :type root: Optional[TreeNode]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n\n    def dfs(curr, d):\n        if not curr:\n            return 0\n        h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n        if h > top[d][0]:\n            (top[d][0], top[d][1]) = (h, top[d][0])\n        elif h > top[d][1]:\n            top[d][1] = h\n        (depth[curr.val], height[curr.val]) = (d, h)\n        return h\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    dfs(root, 0)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
        "mutated": [
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def dfs(curr, d):\n        if not curr:\n            return 0\n        h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n        if h > top[d][0]:\n            (top[d][0], top[d][1]) = (h, top[d][0])\n        elif h > top[d][1]:\n            top[d][1] = h\n        (depth[curr.val], height[curr.val]) = (d, h)\n        return h\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    dfs(root, 0)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def dfs(curr, d):\n        if not curr:\n            return 0\n        h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n        if h > top[d][0]:\n            (top[d][0], top[d][1]) = (h, top[d][0])\n        elif h > top[d][1]:\n            top[d][1] = h\n        (depth[curr.val], height[curr.val]) = (d, h)\n        return h\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    dfs(root, 0)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def dfs(curr, d):\n        if not curr:\n            return 0\n        h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n        if h > top[d][0]:\n            (top[d][0], top[d][1]) = (h, top[d][0])\n        elif h > top[d][1]:\n            top[d][1] = h\n        (depth[curr.val], height[curr.val]) = (d, h)\n        return h\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    dfs(root, 0)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def dfs(curr, d):\n        if not curr:\n            return 0\n        h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n        if h > top[d][0]:\n            (top[d][0], top[d][1]) = (h, top[d][0])\n        elif h > top[d][1]:\n            top[d][1] = h\n        (depth[curr.val], height[curr.val]) = (d, h)\n        return h\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    dfs(root, 0)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]",
            "def treeQueries(self, root, queries):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        '\n\n    def dfs(curr, d):\n        if not curr:\n            return 0\n        h = 1 + max(dfs(curr.left, d + 1), dfs(curr.right, d + 1))\n        if h > top[d][0]:\n            (top[d][0], top[d][1]) = (h, top[d][0])\n        elif h > top[d][1]:\n            top[d][1] = h\n        (depth[curr.val], height[curr.val]) = (d, h)\n        return h\n    top = collections.defaultdict(lambda : [0] * 2)\n    (depth, height) = ({}, {})\n    dfs(root, 0)\n    return [depth[q] - 1 + (top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]"
        ]
    }
]