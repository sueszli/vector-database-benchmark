[
    {
        "func_name": "__init__",
        "original": "def __init__(self, lifter, ircfg, state):\n    super(SymbExecState, self).__init__(lifter, {})\n    self.set_state(state)",
        "mutated": [
            "def __init__(self, lifter, ircfg, state):\n    if False:\n        i = 10\n    super(SymbExecState, self).__init__(lifter, {})\n    self.set_state(state)",
            "def __init__(self, lifter, ircfg, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(SymbExecState, self).__init__(lifter, {})\n    self.set_state(state)",
            "def __init__(self, lifter, ircfg, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(SymbExecState, self).__init__(lifter, {})\n    self.set_state(state)",
            "def __init__(self, lifter, ircfg, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(SymbExecState, self).__init__(lifter, {})\n    self.set_state(state)",
            "def __init__(self, lifter, ircfg, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(SymbExecState, self).__init__(lifter, {})\n    self.set_state(state)"
        ]
    },
    {
        "func_name": "add_state",
        "original": "def add_state(ircfg, todo, states, addr, state):\n    \"\"\"\n    Add or merge the computed @state for the block at @addr. Update @todo\n    @todo: modified block set\n    @states: dictionary linking a label to its entering state.\n    @addr: address of the considered block\n    @state: computed state\n    \"\"\"\n    addr = ircfg.get_loc_key(addr)\n    todo.add(addr)\n    if addr not in states:\n        states[addr] = state\n    else:\n        states[addr] = states[addr].merge(state)",
        "mutated": [
            "def add_state(ircfg, todo, states, addr, state):\n    if False:\n        i = 10\n    '\\n    Add or merge the computed @state for the block at @addr. Update @todo\\n    @todo: modified block set\\n    @states: dictionary linking a label to its entering state.\\n    @addr: address of the considered block\\n    @state: computed state\\n    '\n    addr = ircfg.get_loc_key(addr)\n    todo.add(addr)\n    if addr not in states:\n        states[addr] = state\n    else:\n        states[addr] = states[addr].merge(state)",
            "def add_state(ircfg, todo, states, addr, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Add or merge the computed @state for the block at @addr. Update @todo\\n    @todo: modified block set\\n    @states: dictionary linking a label to its entering state.\\n    @addr: address of the considered block\\n    @state: computed state\\n    '\n    addr = ircfg.get_loc_key(addr)\n    todo.add(addr)\n    if addr not in states:\n        states[addr] = state\n    else:\n        states[addr] = states[addr].merge(state)",
            "def add_state(ircfg, todo, states, addr, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Add or merge the computed @state for the block at @addr. Update @todo\\n    @todo: modified block set\\n    @states: dictionary linking a label to its entering state.\\n    @addr: address of the considered block\\n    @state: computed state\\n    '\n    addr = ircfg.get_loc_key(addr)\n    todo.add(addr)\n    if addr not in states:\n        states[addr] = state\n    else:\n        states[addr] = states[addr].merge(state)",
            "def add_state(ircfg, todo, states, addr, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Add or merge the computed @state for the block at @addr. Update @todo\\n    @todo: modified block set\\n    @states: dictionary linking a label to its entering state.\\n    @addr: address of the considered block\\n    @state: computed state\\n    '\n    addr = ircfg.get_loc_key(addr)\n    todo.add(addr)\n    if addr not in states:\n        states[addr] = state\n    else:\n        states[addr] = states[addr].merge(state)",
            "def add_state(ircfg, todo, states, addr, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Add or merge the computed @state for the block at @addr. Update @todo\\n    @todo: modified block set\\n    @states: dictionary linking a label to its entering state.\\n    @addr: address of the considered block\\n    @state: computed state\\n    '\n    addr = ircfg.get_loc_key(addr)\n    todo.add(addr)\n    if addr not in states:\n        states[addr] = state\n    else:\n        states[addr] = states[addr].merge(state)"
        ]
    },
    {
        "func_name": "is_expr_cst",
        "original": "def is_expr_cst(lifter, expr):\n    \"\"\"Return true if @expr is only composed of ExprInt and init_regs\n    @lifter: Lifter instance\n    @expr: Expression to test\"\"\"\n    elements = expr.get_r(mem_read=True)\n    for element in elements:\n        if element.is_mem():\n            continue\n        if element.is_id() and element in lifter.arch.regs.all_regs_ids_init:\n            continue\n        if element.is_int():\n            continue\n        return False\n    return True",
        "mutated": [
            "def is_expr_cst(lifter, expr):\n    if False:\n        i = 10\n    'Return true if @expr is only composed of ExprInt and init_regs\\n    @lifter: Lifter instance\\n    @expr: Expression to test'\n    elements = expr.get_r(mem_read=True)\n    for element in elements:\n        if element.is_mem():\n            continue\n        if element.is_id() and element in lifter.arch.regs.all_regs_ids_init:\n            continue\n        if element.is_int():\n            continue\n        return False\n    return True",
            "def is_expr_cst(lifter, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return true if @expr is only composed of ExprInt and init_regs\\n    @lifter: Lifter instance\\n    @expr: Expression to test'\n    elements = expr.get_r(mem_read=True)\n    for element in elements:\n        if element.is_mem():\n            continue\n        if element.is_id() and element in lifter.arch.regs.all_regs_ids_init:\n            continue\n        if element.is_int():\n            continue\n        return False\n    return True",
            "def is_expr_cst(lifter, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return true if @expr is only composed of ExprInt and init_regs\\n    @lifter: Lifter instance\\n    @expr: Expression to test'\n    elements = expr.get_r(mem_read=True)\n    for element in elements:\n        if element.is_mem():\n            continue\n        if element.is_id() and element in lifter.arch.regs.all_regs_ids_init:\n            continue\n        if element.is_int():\n            continue\n        return False\n    return True",
            "def is_expr_cst(lifter, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return true if @expr is only composed of ExprInt and init_regs\\n    @lifter: Lifter instance\\n    @expr: Expression to test'\n    elements = expr.get_r(mem_read=True)\n    for element in elements:\n        if element.is_mem():\n            continue\n        if element.is_id() and element in lifter.arch.regs.all_regs_ids_init:\n            continue\n        if element.is_int():\n            continue\n        return False\n    return True",
            "def is_expr_cst(lifter, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return true if @expr is only composed of ExprInt and init_regs\\n    @lifter: Lifter instance\\n    @expr: Expression to test'\n    elements = expr.get_r(mem_read=True)\n    for element in elements:\n        if element.is_mem():\n            continue\n        if element.is_id() and element in lifter.arch.regs.all_regs_ids_init:\n            continue\n        if element.is_int():\n            continue\n        return False\n    return True"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lifter, ircfg, state, cst_propag_link):\n    self.ircfg = ircfg\n    super(SymbExecStateFix, self).__init__(lifter, {})\n    self.set_state(state)\n    self.cst_propag_link = cst_propag_link",
        "mutated": [
            "def __init__(self, lifter, ircfg, state, cst_propag_link):\n    if False:\n        i = 10\n    self.ircfg = ircfg\n    super(SymbExecStateFix, self).__init__(lifter, {})\n    self.set_state(state)\n    self.cst_propag_link = cst_propag_link",
            "def __init__(self, lifter, ircfg, state, cst_propag_link):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.ircfg = ircfg\n    super(SymbExecStateFix, self).__init__(lifter, {})\n    self.set_state(state)\n    self.cst_propag_link = cst_propag_link",
            "def __init__(self, lifter, ircfg, state, cst_propag_link):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.ircfg = ircfg\n    super(SymbExecStateFix, self).__init__(lifter, {})\n    self.set_state(state)\n    self.cst_propag_link = cst_propag_link",
            "def __init__(self, lifter, ircfg, state, cst_propag_link):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.ircfg = ircfg\n    super(SymbExecStateFix, self).__init__(lifter, {})\n    self.set_state(state)\n    self.cst_propag_link = cst_propag_link",
            "def __init__(self, lifter, ircfg, state, cst_propag_link):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.ircfg = ircfg\n    super(SymbExecStateFix, self).__init__(lifter, {})\n    self.set_state(state)\n    self.cst_propag_link = cst_propag_link"
        ]
    },
    {
        "func_name": "propag_expr_cst",
        "original": "def propag_expr_cst(self, expr):\n    \"\"\"Propagate constant expressions in @expr\n        @expr: Expression to update\"\"\"\n    elements = expr.get_r(mem_read=True)\n    to_propag = {}\n    for element in elements:\n        if not element.is_id():\n            continue\n        value = self.eval_expr(element)\n        if self.is_expr_cst(self.lifter, value):\n            to_propag[element] = value\n    return expr_simp(expr.replace_expr(to_propag))",
        "mutated": [
            "def propag_expr_cst(self, expr):\n    if False:\n        i = 10\n    'Propagate constant expressions in @expr\\n        @expr: Expression to update'\n    elements = expr.get_r(mem_read=True)\n    to_propag = {}\n    for element in elements:\n        if not element.is_id():\n            continue\n        value = self.eval_expr(element)\n        if self.is_expr_cst(self.lifter, value):\n            to_propag[element] = value\n    return expr_simp(expr.replace_expr(to_propag))",
            "def propag_expr_cst(self, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Propagate constant expressions in @expr\\n        @expr: Expression to update'\n    elements = expr.get_r(mem_read=True)\n    to_propag = {}\n    for element in elements:\n        if not element.is_id():\n            continue\n        value = self.eval_expr(element)\n        if self.is_expr_cst(self.lifter, value):\n            to_propag[element] = value\n    return expr_simp(expr.replace_expr(to_propag))",
            "def propag_expr_cst(self, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Propagate constant expressions in @expr\\n        @expr: Expression to update'\n    elements = expr.get_r(mem_read=True)\n    to_propag = {}\n    for element in elements:\n        if not element.is_id():\n            continue\n        value = self.eval_expr(element)\n        if self.is_expr_cst(self.lifter, value):\n            to_propag[element] = value\n    return expr_simp(expr.replace_expr(to_propag))",
            "def propag_expr_cst(self, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Propagate constant expressions in @expr\\n        @expr: Expression to update'\n    elements = expr.get_r(mem_read=True)\n    to_propag = {}\n    for element in elements:\n        if not element.is_id():\n            continue\n        value = self.eval_expr(element)\n        if self.is_expr_cst(self.lifter, value):\n            to_propag[element] = value\n    return expr_simp(expr.replace_expr(to_propag))",
            "def propag_expr_cst(self, expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Propagate constant expressions in @expr\\n        @expr: Expression to update'\n    elements = expr.get_r(mem_read=True)\n    to_propag = {}\n    for element in elements:\n        if not element.is_id():\n            continue\n        value = self.eval_expr(element)\n        if self.is_expr_cst(self.lifter, value):\n            to_propag[element] = value\n    return expr_simp(expr.replace_expr(to_propag))"
        ]
    },
    {
        "func_name": "eval_updt_irblock",
        "original": "def eval_updt_irblock(self, irb, step=False):\n    \"\"\"\n        Symbolic execution of the @irb on the current state\n        @irb: IRBlock instance\n        @step: display intermediate steps\n        \"\"\"\n    assignblks = []\n    for (index, assignblk) in enumerate(irb):\n        new_assignblk = {}\n        links = {}\n        for (dst, src) in viewitems(assignblk):\n            src = self.propag_expr_cst(src)\n            if dst.is_mem():\n                ptr = dst.ptr\n                ptr = self.propag_expr_cst(ptr)\n                dst = ExprMem(ptr, dst.size)\n            new_assignblk[dst] = src\n        if assignblk.instr is not None:\n            for arg in assignblk.instr.args:\n                new_arg = self.propag_expr_cst(arg)\n                links[new_arg] = arg\n            self.cst_propag_link[irb.loc_key, index] = links\n        self.eval_updt_assignblk(assignblk)\n        assignblks.append(AssignBlock(new_assignblk, assignblk.instr))\n    self.ircfg.blocks[irb.loc_key] = IRBlock(irb.loc_db, irb.loc_key, assignblks)",
        "mutated": [
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: IRBlock instance\\n        @step: display intermediate steps\\n        '\n    assignblks = []\n    for (index, assignblk) in enumerate(irb):\n        new_assignblk = {}\n        links = {}\n        for (dst, src) in viewitems(assignblk):\n            src = self.propag_expr_cst(src)\n            if dst.is_mem():\n                ptr = dst.ptr\n                ptr = self.propag_expr_cst(ptr)\n                dst = ExprMem(ptr, dst.size)\n            new_assignblk[dst] = src\n        if assignblk.instr is not None:\n            for arg in assignblk.instr.args:\n                new_arg = self.propag_expr_cst(arg)\n                links[new_arg] = arg\n            self.cst_propag_link[irb.loc_key, index] = links\n        self.eval_updt_assignblk(assignblk)\n        assignblks.append(AssignBlock(new_assignblk, assignblk.instr))\n    self.ircfg.blocks[irb.loc_key] = IRBlock(irb.loc_db, irb.loc_key, assignblks)",
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: IRBlock instance\\n        @step: display intermediate steps\\n        '\n    assignblks = []\n    for (index, assignblk) in enumerate(irb):\n        new_assignblk = {}\n        links = {}\n        for (dst, src) in viewitems(assignblk):\n            src = self.propag_expr_cst(src)\n            if dst.is_mem():\n                ptr = dst.ptr\n                ptr = self.propag_expr_cst(ptr)\n                dst = ExprMem(ptr, dst.size)\n            new_assignblk[dst] = src\n        if assignblk.instr is not None:\n            for arg in assignblk.instr.args:\n                new_arg = self.propag_expr_cst(arg)\n                links[new_arg] = arg\n            self.cst_propag_link[irb.loc_key, index] = links\n        self.eval_updt_assignblk(assignblk)\n        assignblks.append(AssignBlock(new_assignblk, assignblk.instr))\n    self.ircfg.blocks[irb.loc_key] = IRBlock(irb.loc_db, irb.loc_key, assignblks)",
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: IRBlock instance\\n        @step: display intermediate steps\\n        '\n    assignblks = []\n    for (index, assignblk) in enumerate(irb):\n        new_assignblk = {}\n        links = {}\n        for (dst, src) in viewitems(assignblk):\n            src = self.propag_expr_cst(src)\n            if dst.is_mem():\n                ptr = dst.ptr\n                ptr = self.propag_expr_cst(ptr)\n                dst = ExprMem(ptr, dst.size)\n            new_assignblk[dst] = src\n        if assignblk.instr is not None:\n            for arg in assignblk.instr.args:\n                new_arg = self.propag_expr_cst(arg)\n                links[new_arg] = arg\n            self.cst_propag_link[irb.loc_key, index] = links\n        self.eval_updt_assignblk(assignblk)\n        assignblks.append(AssignBlock(new_assignblk, assignblk.instr))\n    self.ircfg.blocks[irb.loc_key] = IRBlock(irb.loc_db, irb.loc_key, assignblks)",
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: IRBlock instance\\n        @step: display intermediate steps\\n        '\n    assignblks = []\n    for (index, assignblk) in enumerate(irb):\n        new_assignblk = {}\n        links = {}\n        for (dst, src) in viewitems(assignblk):\n            src = self.propag_expr_cst(src)\n            if dst.is_mem():\n                ptr = dst.ptr\n                ptr = self.propag_expr_cst(ptr)\n                dst = ExprMem(ptr, dst.size)\n            new_assignblk[dst] = src\n        if assignblk.instr is not None:\n            for arg in assignblk.instr.args:\n                new_arg = self.propag_expr_cst(arg)\n                links[new_arg] = arg\n            self.cst_propag_link[irb.loc_key, index] = links\n        self.eval_updt_assignblk(assignblk)\n        assignblks.append(AssignBlock(new_assignblk, assignblk.instr))\n    self.ircfg.blocks[irb.loc_key] = IRBlock(irb.loc_db, irb.loc_key, assignblks)",
            "def eval_updt_irblock(self, irb, step=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Symbolic execution of the @irb on the current state\\n        @irb: IRBlock instance\\n        @step: display intermediate steps\\n        '\n    assignblks = []\n    for (index, assignblk) in enumerate(irb):\n        new_assignblk = {}\n        links = {}\n        for (dst, src) in viewitems(assignblk):\n            src = self.propag_expr_cst(src)\n            if dst.is_mem():\n                ptr = dst.ptr\n                ptr = self.propag_expr_cst(ptr)\n                dst = ExprMem(ptr, dst.size)\n            new_assignblk[dst] = src\n        if assignblk.instr is not None:\n            for arg in assignblk.instr.args:\n                new_arg = self.propag_expr_cst(arg)\n                links[new_arg] = arg\n            self.cst_propag_link[irb.loc_key, index] = links\n        self.eval_updt_assignblk(assignblk)\n        assignblks.append(AssignBlock(new_assignblk, assignblk.instr))\n    self.ircfg.blocks[irb.loc_key] = IRBlock(irb.loc_db, irb.loc_key, assignblks)"
        ]
    },
    {
        "func_name": "compute_cst_propagation_states",
        "original": "def compute_cst_propagation_states(lifter, ircfg, init_addr, init_infos):\n    \"\"\"\n    Propagate \"constant expressions\" in a function.\n    The attribute \"constant expression\" is true if the expression is based on\n    constants or \"init\" regs values.\n\n    @lifter: Lifter instance\n    @init_addr: analysis start address\n    @init_infos: dictionary linking expressions to their values at @init_addr\n    \"\"\"\n    done = set()\n    state = SymbExecState.StateEngine(init_infos)\n    lbl = ircfg.get_loc_key(init_addr)\n    todo = set([lbl])\n    states = {lbl: state}\n    while todo:\n        if not todo:\n            break\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = SymbExecState(lifter, ircfg, state)\n        addr = symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        for dst in possible_values(addr):\n            value = dst.value\n            if value.is_mem():\n                LOG_CST_PROPAG.warning('Bad destination: %s', value)\n                continue\n            elif value.is_int():\n                value = ircfg.get_loc_key(value)\n            add_state(ircfg, todo, states, value, symbexec_engine.get_state())\n    return states",
        "mutated": [
            "def compute_cst_propagation_states(lifter, ircfg, init_addr, init_infos):\n    if False:\n        i = 10\n    '\\n    Propagate \"constant expressions\" in a function.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @init_addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n    '\n    done = set()\n    state = SymbExecState.StateEngine(init_infos)\n    lbl = ircfg.get_loc_key(init_addr)\n    todo = set([lbl])\n    states = {lbl: state}\n    while todo:\n        if not todo:\n            break\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = SymbExecState(lifter, ircfg, state)\n        addr = symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        for dst in possible_values(addr):\n            value = dst.value\n            if value.is_mem():\n                LOG_CST_PROPAG.warning('Bad destination: %s', value)\n                continue\n            elif value.is_int():\n                value = ircfg.get_loc_key(value)\n            add_state(ircfg, todo, states, value, symbexec_engine.get_state())\n    return states",
            "def compute_cst_propagation_states(lifter, ircfg, init_addr, init_infos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Propagate \"constant expressions\" in a function.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @init_addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n    '\n    done = set()\n    state = SymbExecState.StateEngine(init_infos)\n    lbl = ircfg.get_loc_key(init_addr)\n    todo = set([lbl])\n    states = {lbl: state}\n    while todo:\n        if not todo:\n            break\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = SymbExecState(lifter, ircfg, state)\n        addr = symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        for dst in possible_values(addr):\n            value = dst.value\n            if value.is_mem():\n                LOG_CST_PROPAG.warning('Bad destination: %s', value)\n                continue\n            elif value.is_int():\n                value = ircfg.get_loc_key(value)\n            add_state(ircfg, todo, states, value, symbexec_engine.get_state())\n    return states",
            "def compute_cst_propagation_states(lifter, ircfg, init_addr, init_infos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Propagate \"constant expressions\" in a function.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @init_addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n    '\n    done = set()\n    state = SymbExecState.StateEngine(init_infos)\n    lbl = ircfg.get_loc_key(init_addr)\n    todo = set([lbl])\n    states = {lbl: state}\n    while todo:\n        if not todo:\n            break\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = SymbExecState(lifter, ircfg, state)\n        addr = symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        for dst in possible_values(addr):\n            value = dst.value\n            if value.is_mem():\n                LOG_CST_PROPAG.warning('Bad destination: %s', value)\n                continue\n            elif value.is_int():\n                value = ircfg.get_loc_key(value)\n            add_state(ircfg, todo, states, value, symbexec_engine.get_state())\n    return states",
            "def compute_cst_propagation_states(lifter, ircfg, init_addr, init_infos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Propagate \"constant expressions\" in a function.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @init_addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n    '\n    done = set()\n    state = SymbExecState.StateEngine(init_infos)\n    lbl = ircfg.get_loc_key(init_addr)\n    todo = set([lbl])\n    states = {lbl: state}\n    while todo:\n        if not todo:\n            break\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = SymbExecState(lifter, ircfg, state)\n        addr = symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        for dst in possible_values(addr):\n            value = dst.value\n            if value.is_mem():\n                LOG_CST_PROPAG.warning('Bad destination: %s', value)\n                continue\n            elif value.is_int():\n                value = ircfg.get_loc_key(value)\n            add_state(ircfg, todo, states, value, symbexec_engine.get_state())\n    return states",
            "def compute_cst_propagation_states(lifter, ircfg, init_addr, init_infos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Propagate \"constant expressions\" in a function.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @init_addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n    '\n    done = set()\n    state = SymbExecState.StateEngine(init_infos)\n    lbl = ircfg.get_loc_key(init_addr)\n    todo = set([lbl])\n    states = {lbl: state}\n    while todo:\n        if not todo:\n            break\n        lbl = todo.pop()\n        state = states[lbl]\n        if (lbl, state) in done:\n            continue\n        done.add((lbl, state))\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec_engine = SymbExecState(lifter, ircfg, state)\n        addr = symbexec_engine.run_block_at(ircfg, lbl)\n        symbexec_engine.del_mem_above_stack(lifter.sp)\n        for dst in possible_values(addr):\n            value = dst.value\n            if value.is_mem():\n                LOG_CST_PROPAG.warning('Bad destination: %s', value)\n                continue\n            elif value.is_int():\n                value = ircfg.get_loc_key(value)\n            add_state(ircfg, todo, states, value, symbexec_engine.get_state())\n    return states"
        ]
    },
    {
        "func_name": "propagate_cst_expr",
        "original": "def propagate_cst_expr(lifter, ircfg, addr, init_infos):\n    \"\"\"\n    Propagate \"constant expressions\" in a @lifter.\n    The attribute \"constant expression\" is true if the expression is based on\n    constants or \"init\" regs values.\n\n    @lifter: Lifter instance\n    @addr: analysis start address\n    @init_infos: dictionary linking expressions to their values at @init_addr\n\n    Returns a mapping between replaced Expression and their new values.\n    \"\"\"\n    states = compute_cst_propagation_states(lifter, ircfg, addr, init_infos)\n    cst_propag_link = {}\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec = SymbExecStateFix(lifter, ircfg, state, cst_propag_link)\n        symbexec.eval_updt_irblock(ircfg.blocks[lbl])\n    return cst_propag_link",
        "mutated": [
            "def propagate_cst_expr(lifter, ircfg, addr, init_infos):\n    if False:\n        i = 10\n    '\\n    Propagate \"constant expressions\" in a @lifter.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n\\n    Returns a mapping between replaced Expression and their new values.\\n    '\n    states = compute_cst_propagation_states(lifter, ircfg, addr, init_infos)\n    cst_propag_link = {}\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec = SymbExecStateFix(lifter, ircfg, state, cst_propag_link)\n        symbexec.eval_updt_irblock(ircfg.blocks[lbl])\n    return cst_propag_link",
            "def propagate_cst_expr(lifter, ircfg, addr, init_infos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Propagate \"constant expressions\" in a @lifter.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n\\n    Returns a mapping between replaced Expression and their new values.\\n    '\n    states = compute_cst_propagation_states(lifter, ircfg, addr, init_infos)\n    cst_propag_link = {}\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec = SymbExecStateFix(lifter, ircfg, state, cst_propag_link)\n        symbexec.eval_updt_irblock(ircfg.blocks[lbl])\n    return cst_propag_link",
            "def propagate_cst_expr(lifter, ircfg, addr, init_infos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Propagate \"constant expressions\" in a @lifter.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n\\n    Returns a mapping between replaced Expression and their new values.\\n    '\n    states = compute_cst_propagation_states(lifter, ircfg, addr, init_infos)\n    cst_propag_link = {}\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec = SymbExecStateFix(lifter, ircfg, state, cst_propag_link)\n        symbexec.eval_updt_irblock(ircfg.blocks[lbl])\n    return cst_propag_link",
            "def propagate_cst_expr(lifter, ircfg, addr, init_infos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Propagate \"constant expressions\" in a @lifter.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n\\n    Returns a mapping between replaced Expression and their new values.\\n    '\n    states = compute_cst_propagation_states(lifter, ircfg, addr, init_infos)\n    cst_propag_link = {}\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec = SymbExecStateFix(lifter, ircfg, state, cst_propag_link)\n        symbexec.eval_updt_irblock(ircfg.blocks[lbl])\n    return cst_propag_link",
            "def propagate_cst_expr(lifter, ircfg, addr, init_infos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Propagate \"constant expressions\" in a @lifter.\\n    The attribute \"constant expression\" is true if the expression is based on\\n    constants or \"init\" regs values.\\n\\n    @lifter: Lifter instance\\n    @addr: analysis start address\\n    @init_infos: dictionary linking expressions to their values at @init_addr\\n\\n    Returns a mapping between replaced Expression and their new values.\\n    '\n    states = compute_cst_propagation_states(lifter, ircfg, addr, init_infos)\n    cst_propag_link = {}\n    for (lbl, state) in viewitems(states):\n        if lbl not in ircfg.blocks:\n            continue\n        symbexec = SymbExecStateFix(lifter, ircfg, state, cst_propag_link)\n        symbexec.eval_updt_irblock(ircfg.blocks[lbl])\n    return cst_propag_link"
        ]
    }
]