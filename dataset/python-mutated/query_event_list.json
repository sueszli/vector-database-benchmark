[
    {
        "func_name": "determine_event_conditions",
        "original": "def determine_event_conditions(conditions: Dict[str, Union[None, str, List[str]]], team: Team, tzinfo: ZoneInfo) -> Tuple[str, Dict]:\n    result = ''\n    params: Dict[str, Union[str, List[str]]] = {}\n    for (k, v) in conditions.items():\n        if not isinstance(v, str):\n            continue\n        if k == 'after':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp > %(after)s '\n            params.update({'after': timestamp})\n        elif k == 'before':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp < %(before)s '\n            params.update({'before': timestamp})\n        elif k == 'person_id':\n            result += 'AND distinct_id IN (%(distinct_ids)s) '\n            person = get_pk_or_uuid(Person.objects.filter(team=team), v).first()\n            params.update({'distinct_ids': get_distinct_ids_for_subquery(person, team)})\n        elif k == 'distinct_id':\n            result += 'AND distinct_id = %(distinct_id)s '\n            params.update({'distinct_id': v})\n        elif k == 'event':\n            result += 'AND event = %(event)s '\n            params.update({'event': v})\n    return (result, params)",
        "mutated": [
            "def determine_event_conditions(conditions: Dict[str, Union[None, str, List[str]]], team: Team, tzinfo: ZoneInfo) -> Tuple[str, Dict]:\n    if False:\n        i = 10\n    result = ''\n    params: Dict[str, Union[str, List[str]]] = {}\n    for (k, v) in conditions.items():\n        if not isinstance(v, str):\n            continue\n        if k == 'after':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp > %(after)s '\n            params.update({'after': timestamp})\n        elif k == 'before':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp < %(before)s '\n            params.update({'before': timestamp})\n        elif k == 'person_id':\n            result += 'AND distinct_id IN (%(distinct_ids)s) '\n            person = get_pk_or_uuid(Person.objects.filter(team=team), v).first()\n            params.update({'distinct_ids': get_distinct_ids_for_subquery(person, team)})\n        elif k == 'distinct_id':\n            result += 'AND distinct_id = %(distinct_id)s '\n            params.update({'distinct_id': v})\n        elif k == 'event':\n            result += 'AND event = %(event)s '\n            params.update({'event': v})\n    return (result, params)",
            "def determine_event_conditions(conditions: Dict[str, Union[None, str, List[str]]], team: Team, tzinfo: ZoneInfo) -> Tuple[str, Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = ''\n    params: Dict[str, Union[str, List[str]]] = {}\n    for (k, v) in conditions.items():\n        if not isinstance(v, str):\n            continue\n        if k == 'after':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp > %(after)s '\n            params.update({'after': timestamp})\n        elif k == 'before':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp < %(before)s '\n            params.update({'before': timestamp})\n        elif k == 'person_id':\n            result += 'AND distinct_id IN (%(distinct_ids)s) '\n            person = get_pk_or_uuid(Person.objects.filter(team=team), v).first()\n            params.update({'distinct_ids': get_distinct_ids_for_subquery(person, team)})\n        elif k == 'distinct_id':\n            result += 'AND distinct_id = %(distinct_id)s '\n            params.update({'distinct_id': v})\n        elif k == 'event':\n            result += 'AND event = %(event)s '\n            params.update({'event': v})\n    return (result, params)",
            "def determine_event_conditions(conditions: Dict[str, Union[None, str, List[str]]], team: Team, tzinfo: ZoneInfo) -> Tuple[str, Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = ''\n    params: Dict[str, Union[str, List[str]]] = {}\n    for (k, v) in conditions.items():\n        if not isinstance(v, str):\n            continue\n        if k == 'after':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp > %(after)s '\n            params.update({'after': timestamp})\n        elif k == 'before':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp < %(before)s '\n            params.update({'before': timestamp})\n        elif k == 'person_id':\n            result += 'AND distinct_id IN (%(distinct_ids)s) '\n            person = get_pk_or_uuid(Person.objects.filter(team=team), v).first()\n            params.update({'distinct_ids': get_distinct_ids_for_subquery(person, team)})\n        elif k == 'distinct_id':\n            result += 'AND distinct_id = %(distinct_id)s '\n            params.update({'distinct_id': v})\n        elif k == 'event':\n            result += 'AND event = %(event)s '\n            params.update({'event': v})\n    return (result, params)",
            "def determine_event_conditions(conditions: Dict[str, Union[None, str, List[str]]], team: Team, tzinfo: ZoneInfo) -> Tuple[str, Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = ''\n    params: Dict[str, Union[str, List[str]]] = {}\n    for (k, v) in conditions.items():\n        if not isinstance(v, str):\n            continue\n        if k == 'after':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp > %(after)s '\n            params.update({'after': timestamp})\n        elif k == 'before':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp < %(before)s '\n            params.update({'before': timestamp})\n        elif k == 'person_id':\n            result += 'AND distinct_id IN (%(distinct_ids)s) '\n            person = get_pk_or_uuid(Person.objects.filter(team=team), v).first()\n            params.update({'distinct_ids': get_distinct_ids_for_subquery(person, team)})\n        elif k == 'distinct_id':\n            result += 'AND distinct_id = %(distinct_id)s '\n            params.update({'distinct_id': v})\n        elif k == 'event':\n            result += 'AND event = %(event)s '\n            params.update({'event': v})\n    return (result, params)",
            "def determine_event_conditions(conditions: Dict[str, Union[None, str, List[str]]], team: Team, tzinfo: ZoneInfo) -> Tuple[str, Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = ''\n    params: Dict[str, Union[str, List[str]]] = {}\n    for (k, v) in conditions.items():\n        if not isinstance(v, str):\n            continue\n        if k == 'after':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp > %(after)s '\n            params.update({'after': timestamp})\n        elif k == 'before':\n            try:\n                timestamp = isoparse(v).strftime('%Y-%m-%d %H:%M:%S.%f')\n            except ValueError:\n                timestamp = relative_date_parse(v, tzinfo).strftime('%Y-%m-%d %H:%M:%S.%f')\n            result += 'AND timestamp < %(before)s '\n            params.update({'before': timestamp})\n        elif k == 'person_id':\n            result += 'AND distinct_id IN (%(distinct_ids)s) '\n            person = get_pk_or_uuid(Person.objects.filter(team=team), v).first()\n            params.update({'distinct_ids': get_distinct_ids_for_subquery(person, team)})\n        elif k == 'distinct_id':\n            result += 'AND distinct_id = %(distinct_id)s '\n            params.update({'distinct_id': v})\n        elif k == 'event':\n            result += 'AND event = %(event)s '\n            params.update({'event': v})\n    return (result, params)"
        ]
    },
    {
        "func_name": "query_events_list",
        "original": "def query_events_list(filter: Filter, team: Team, request_get_query_dict: Dict, order_by: List[str], action_id: Optional[str], unbounded_date_from: bool=False, limit: int=DEFAULT_RETURNED_ROWS, offset: int=0) -> List:\n    hogql_context = HogQLContext(within_non_hogql_query=True, team_id=team.pk, enable_select_queries=True)\n    limit += 1\n    limit_sql = 'LIMIT %(limit)s'\n    if offset > 0:\n        limit_sql += ' OFFSET %(offset)s'\n    workload = Workload.OFFLINE if unbounded_date_from else Workload.ONLINE\n    (conditions, condition_params) = determine_event_conditions({'after': None if unbounded_date_from else (now() - timedelta(days=1)).isoformat(), 'before': (now() + timedelta(seconds=5)).isoformat(), **request_get_query_dict}, team, tzinfo=team.timezone_info)\n    (prop_filters, prop_filter_params) = parse_prop_grouped_clauses(team_id=team.pk, property_group=filter.property_groups, has_person_id_joined=False, hogql_context=hogql_context)\n    if action_id:\n        try:\n            action = Action.objects.get(pk=action_id, team_id=team.pk)\n        except Action.DoesNotExist:\n            return []\n        if action.steps.count() == 0:\n            return []\n        (action_query, params) = format_action_filter(team_id=team.pk, action=action, hogql_context=hogql_context)\n        prop_filters += ' AND {}'.format(action_query)\n        prop_filter_params = {**prop_filter_params, **params}\n    order = 'DESC' if len(order_by) == 1 and order_by[0] == '-timestamp' else 'ASC'\n    if prop_filters != '':\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_FILTERS_SQL.format(conditions=conditions, limit=limit_sql, filters=prop_filters, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **prop_filter_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)\n    else:\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_SQL.format(conditions=conditions, limit=limit_sql, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)",
        "mutated": [
            "def query_events_list(filter: Filter, team: Team, request_get_query_dict: Dict, order_by: List[str], action_id: Optional[str], unbounded_date_from: bool=False, limit: int=DEFAULT_RETURNED_ROWS, offset: int=0) -> List:\n    if False:\n        i = 10\n    hogql_context = HogQLContext(within_non_hogql_query=True, team_id=team.pk, enable_select_queries=True)\n    limit += 1\n    limit_sql = 'LIMIT %(limit)s'\n    if offset > 0:\n        limit_sql += ' OFFSET %(offset)s'\n    workload = Workload.OFFLINE if unbounded_date_from else Workload.ONLINE\n    (conditions, condition_params) = determine_event_conditions({'after': None if unbounded_date_from else (now() - timedelta(days=1)).isoformat(), 'before': (now() + timedelta(seconds=5)).isoformat(), **request_get_query_dict}, team, tzinfo=team.timezone_info)\n    (prop_filters, prop_filter_params) = parse_prop_grouped_clauses(team_id=team.pk, property_group=filter.property_groups, has_person_id_joined=False, hogql_context=hogql_context)\n    if action_id:\n        try:\n            action = Action.objects.get(pk=action_id, team_id=team.pk)\n        except Action.DoesNotExist:\n            return []\n        if action.steps.count() == 0:\n            return []\n        (action_query, params) = format_action_filter(team_id=team.pk, action=action, hogql_context=hogql_context)\n        prop_filters += ' AND {}'.format(action_query)\n        prop_filter_params = {**prop_filter_params, **params}\n    order = 'DESC' if len(order_by) == 1 and order_by[0] == '-timestamp' else 'ASC'\n    if prop_filters != '':\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_FILTERS_SQL.format(conditions=conditions, limit=limit_sql, filters=prop_filters, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **prop_filter_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)\n    else:\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_SQL.format(conditions=conditions, limit=limit_sql, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)",
            "def query_events_list(filter: Filter, team: Team, request_get_query_dict: Dict, order_by: List[str], action_id: Optional[str], unbounded_date_from: bool=False, limit: int=DEFAULT_RETURNED_ROWS, offset: int=0) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    hogql_context = HogQLContext(within_non_hogql_query=True, team_id=team.pk, enable_select_queries=True)\n    limit += 1\n    limit_sql = 'LIMIT %(limit)s'\n    if offset > 0:\n        limit_sql += ' OFFSET %(offset)s'\n    workload = Workload.OFFLINE if unbounded_date_from else Workload.ONLINE\n    (conditions, condition_params) = determine_event_conditions({'after': None if unbounded_date_from else (now() - timedelta(days=1)).isoformat(), 'before': (now() + timedelta(seconds=5)).isoformat(), **request_get_query_dict}, team, tzinfo=team.timezone_info)\n    (prop_filters, prop_filter_params) = parse_prop_grouped_clauses(team_id=team.pk, property_group=filter.property_groups, has_person_id_joined=False, hogql_context=hogql_context)\n    if action_id:\n        try:\n            action = Action.objects.get(pk=action_id, team_id=team.pk)\n        except Action.DoesNotExist:\n            return []\n        if action.steps.count() == 0:\n            return []\n        (action_query, params) = format_action_filter(team_id=team.pk, action=action, hogql_context=hogql_context)\n        prop_filters += ' AND {}'.format(action_query)\n        prop_filter_params = {**prop_filter_params, **params}\n    order = 'DESC' if len(order_by) == 1 and order_by[0] == '-timestamp' else 'ASC'\n    if prop_filters != '':\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_FILTERS_SQL.format(conditions=conditions, limit=limit_sql, filters=prop_filters, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **prop_filter_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)\n    else:\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_SQL.format(conditions=conditions, limit=limit_sql, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)",
            "def query_events_list(filter: Filter, team: Team, request_get_query_dict: Dict, order_by: List[str], action_id: Optional[str], unbounded_date_from: bool=False, limit: int=DEFAULT_RETURNED_ROWS, offset: int=0) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    hogql_context = HogQLContext(within_non_hogql_query=True, team_id=team.pk, enable_select_queries=True)\n    limit += 1\n    limit_sql = 'LIMIT %(limit)s'\n    if offset > 0:\n        limit_sql += ' OFFSET %(offset)s'\n    workload = Workload.OFFLINE if unbounded_date_from else Workload.ONLINE\n    (conditions, condition_params) = determine_event_conditions({'after': None if unbounded_date_from else (now() - timedelta(days=1)).isoformat(), 'before': (now() + timedelta(seconds=5)).isoformat(), **request_get_query_dict}, team, tzinfo=team.timezone_info)\n    (prop_filters, prop_filter_params) = parse_prop_grouped_clauses(team_id=team.pk, property_group=filter.property_groups, has_person_id_joined=False, hogql_context=hogql_context)\n    if action_id:\n        try:\n            action = Action.objects.get(pk=action_id, team_id=team.pk)\n        except Action.DoesNotExist:\n            return []\n        if action.steps.count() == 0:\n            return []\n        (action_query, params) = format_action_filter(team_id=team.pk, action=action, hogql_context=hogql_context)\n        prop_filters += ' AND {}'.format(action_query)\n        prop_filter_params = {**prop_filter_params, **params}\n    order = 'DESC' if len(order_by) == 1 and order_by[0] == '-timestamp' else 'ASC'\n    if prop_filters != '':\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_FILTERS_SQL.format(conditions=conditions, limit=limit_sql, filters=prop_filters, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **prop_filter_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)\n    else:\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_SQL.format(conditions=conditions, limit=limit_sql, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)",
            "def query_events_list(filter: Filter, team: Team, request_get_query_dict: Dict, order_by: List[str], action_id: Optional[str], unbounded_date_from: bool=False, limit: int=DEFAULT_RETURNED_ROWS, offset: int=0) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    hogql_context = HogQLContext(within_non_hogql_query=True, team_id=team.pk, enable_select_queries=True)\n    limit += 1\n    limit_sql = 'LIMIT %(limit)s'\n    if offset > 0:\n        limit_sql += ' OFFSET %(offset)s'\n    workload = Workload.OFFLINE if unbounded_date_from else Workload.ONLINE\n    (conditions, condition_params) = determine_event_conditions({'after': None if unbounded_date_from else (now() - timedelta(days=1)).isoformat(), 'before': (now() + timedelta(seconds=5)).isoformat(), **request_get_query_dict}, team, tzinfo=team.timezone_info)\n    (prop_filters, prop_filter_params) = parse_prop_grouped_clauses(team_id=team.pk, property_group=filter.property_groups, has_person_id_joined=False, hogql_context=hogql_context)\n    if action_id:\n        try:\n            action = Action.objects.get(pk=action_id, team_id=team.pk)\n        except Action.DoesNotExist:\n            return []\n        if action.steps.count() == 0:\n            return []\n        (action_query, params) = format_action_filter(team_id=team.pk, action=action, hogql_context=hogql_context)\n        prop_filters += ' AND {}'.format(action_query)\n        prop_filter_params = {**prop_filter_params, **params}\n    order = 'DESC' if len(order_by) == 1 and order_by[0] == '-timestamp' else 'ASC'\n    if prop_filters != '':\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_FILTERS_SQL.format(conditions=conditions, limit=limit_sql, filters=prop_filters, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **prop_filter_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)\n    else:\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_SQL.format(conditions=conditions, limit=limit_sql, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)",
            "def query_events_list(filter: Filter, team: Team, request_get_query_dict: Dict, order_by: List[str], action_id: Optional[str], unbounded_date_from: bool=False, limit: int=DEFAULT_RETURNED_ROWS, offset: int=0) -> List:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    hogql_context = HogQLContext(within_non_hogql_query=True, team_id=team.pk, enable_select_queries=True)\n    limit += 1\n    limit_sql = 'LIMIT %(limit)s'\n    if offset > 0:\n        limit_sql += ' OFFSET %(offset)s'\n    workload = Workload.OFFLINE if unbounded_date_from else Workload.ONLINE\n    (conditions, condition_params) = determine_event_conditions({'after': None if unbounded_date_from else (now() - timedelta(days=1)).isoformat(), 'before': (now() + timedelta(seconds=5)).isoformat(), **request_get_query_dict}, team, tzinfo=team.timezone_info)\n    (prop_filters, prop_filter_params) = parse_prop_grouped_clauses(team_id=team.pk, property_group=filter.property_groups, has_person_id_joined=False, hogql_context=hogql_context)\n    if action_id:\n        try:\n            action = Action.objects.get(pk=action_id, team_id=team.pk)\n        except Action.DoesNotExist:\n            return []\n        if action.steps.count() == 0:\n            return []\n        (action_query, params) = format_action_filter(team_id=team.pk, action=action, hogql_context=hogql_context)\n        prop_filters += ' AND {}'.format(action_query)\n        prop_filter_params = {**prop_filter_params, **params}\n    order = 'DESC' if len(order_by) == 1 and order_by[0] == '-timestamp' else 'ASC'\n    if prop_filters != '':\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_FILTERS_SQL.format(conditions=conditions, limit=limit_sql, filters=prop_filters, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **prop_filter_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)\n    else:\n        return insight_query_with_columns(SELECT_EVENT_BY_TEAM_AND_CONDITIONS_SQL.format(conditions=conditions, limit=limit_sql, order=order), {'team_id': team.pk, 'limit': limit, 'offset': offset, **condition_params, **hogql_context.values}, query_type='events_list', workload=workload, team_id=team.pk)"
        ]
    }
]