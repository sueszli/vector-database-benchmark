[
    {
        "func_name": "output",
        "original": "def output(msg, msg_type, is_prompt=False, **kwargs):\n    json_output = getattr(logging.getLogger('borg'), 'json', False)\n    if json_output:\n        kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n        print(json.dumps(kwargs), file=sys.stderr)\n    elif is_prompt:\n        print(msg, file=ofile, end='', flush=True)\n    else:\n        print(msg, file=ofile)",
        "mutated": [
            "def output(msg, msg_type, is_prompt=False, **kwargs):\n    if False:\n        i = 10\n    json_output = getattr(logging.getLogger('borg'), 'json', False)\n    if json_output:\n        kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n        print(json.dumps(kwargs), file=sys.stderr)\n    elif is_prompt:\n        print(msg, file=ofile, end='', flush=True)\n    else:\n        print(msg, file=ofile)",
            "def output(msg, msg_type, is_prompt=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    json_output = getattr(logging.getLogger('borg'), 'json', False)\n    if json_output:\n        kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n        print(json.dumps(kwargs), file=sys.stderr)\n    elif is_prompt:\n        print(msg, file=ofile, end='', flush=True)\n    else:\n        print(msg, file=ofile)",
            "def output(msg, msg_type, is_prompt=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    json_output = getattr(logging.getLogger('borg'), 'json', False)\n    if json_output:\n        kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n        print(json.dumps(kwargs), file=sys.stderr)\n    elif is_prompt:\n        print(msg, file=ofile, end='', flush=True)\n    else:\n        print(msg, file=ofile)",
            "def output(msg, msg_type, is_prompt=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    json_output = getattr(logging.getLogger('borg'), 'json', False)\n    if json_output:\n        kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n        print(json.dumps(kwargs), file=sys.stderr)\n    elif is_prompt:\n        print(msg, file=ofile, end='', flush=True)\n    else:\n        print(msg, file=ofile)",
            "def output(msg, msg_type, is_prompt=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    json_output = getattr(logging.getLogger('borg'), 'json', False)\n    if json_output:\n        kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n        print(json.dumps(kwargs), file=sys.stderr)\n    elif is_prompt:\n        print(msg, file=ofile, end='', flush=True)\n    else:\n        print(msg, file=ofile)"
        ]
    },
    {
        "func_name": "yes",
        "original": "def yes(msg=None, false_msg=None, true_msg=None, default_msg=None, retry_msg=None, invalid_msg=None, env_msg='{} (from {})', falsish=FALSISH, truish=TRUISH, defaultish=DEFAULTISH, default=False, retry=True, env_var_override=None, ofile=None, input=input, prompt=True, msgid=None):\n    \"\"\"Output <msg> (usually a question) and let user input an answer.\n    Qualifies the answer according to falsish, truish and defaultish as True, False or <default>.\n    If it didn't qualify and retry is False (no retries wanted), return the default [which\n    defaults to False]. If retry is True let user retry answering until answer is qualified.\n\n    If env_var_override is given and this var is present in the environment, do not ask\n    the user, but just use the env var contents as answer as if it was typed in.\n    Otherwise read input from stdin and proceed as normal.\n    If EOF is received instead an input or an invalid input without retry possibility,\n    return default.\n\n    :param msg: introducing message to output on ofile, no \n is added [None]\n    :param retry_msg: retry message to output on ofile, no \n is added [None]\n    :param false_msg: message to output before returning False [None]\n    :param true_msg: message to output before returning True [None]\n    :param default_msg: message to output before returning a <default> [None]\n    :param invalid_msg: message to output after a invalid answer was given [None]\n    :param env_msg: message to output when using input from env_var_override ['{} (from {})'],\n           needs to have 2 placeholders for answer and env var name\n    :param falsish: sequence of answers qualifying as False\n    :param truish: sequence of answers qualifying as True\n    :param defaultish: sequence of answers qualifying as <default>\n    :param default: default return value (defaultish answer was given or no-answer condition) [False]\n    :param retry: if True and input is incorrect, retry. Otherwise return default. [True]\n    :param env_var_override: environment variable name [None]\n    :param ofile: output stream [sys.stderr]\n    :param input: input function [input from builtins]\n    :return: boolean answer value, True or False\n    \"\"\"\n\n    def output(msg, msg_type, is_prompt=False, **kwargs):\n        json_output = getattr(logging.getLogger('borg'), 'json', False)\n        if json_output:\n            kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n            print(json.dumps(kwargs), file=sys.stderr)\n        elif is_prompt:\n            print(msg, file=ofile, end='', flush=True)\n        else:\n            print(msg, file=ofile)\n    msgid = msgid or env_var_override\n    if ofile is None:\n        ofile = sys.stderr\n    if default not in (True, False):\n        raise ValueError('invalid default value, must be True or False')\n    if msg:\n        output(msg, 'prompt', is_prompt=True)\n    while True:\n        answer = None\n        if env_var_override:\n            answer = os.environ.get(env_var_override)\n            if answer is not None and env_msg:\n                output(env_msg.format(answer, env_var_override), 'env_answer', env_var=env_var_override)\n        if answer is None:\n            if not prompt:\n                return default\n            try:\n                answer = input()\n            except EOFError:\n                answer = truish[0] if default else falsish[0]\n        if answer in defaultish:\n            if default_msg:\n                output(default_msg, 'accepted_default')\n            return default\n        if answer in truish:\n            if true_msg:\n                output(true_msg, 'accepted_true')\n            return True\n        if answer in falsish:\n            if false_msg:\n                output(false_msg, 'accepted_false')\n            return False\n        if invalid_msg:\n            output(invalid_msg, 'invalid_answer')\n        if not retry:\n            return default\n        if retry_msg:\n            output(retry_msg, 'prompt_retry', is_prompt=True)\n        env_var_override = None",
        "mutated": [
            "def yes(msg=None, false_msg=None, true_msg=None, default_msg=None, retry_msg=None, invalid_msg=None, env_msg='{} (from {})', falsish=FALSISH, truish=TRUISH, defaultish=DEFAULTISH, default=False, retry=True, env_var_override=None, ofile=None, input=input, prompt=True, msgid=None):\n    if False:\n        i = 10\n    \"Output <msg> (usually a question) and let user input an answer.\\n    Qualifies the answer according to falsish, truish and defaultish as True, False or <default>.\\n    If it didn't qualify and retry is False (no retries wanted), return the default [which\\n    defaults to False]. If retry is True let user retry answering until answer is qualified.\\n\\n    If env_var_override is given and this var is present in the environment, do not ask\\n    the user, but just use the env var contents as answer as if it was typed in.\\n    Otherwise read input from stdin and proceed as normal.\\n    If EOF is received instead an input or an invalid input without retry possibility,\\n    return default.\\n\\n    :param msg: introducing message to output on ofile, no \\n is added [None]\\n    :param retry_msg: retry message to output on ofile, no \\n is added [None]\\n    :param false_msg: message to output before returning False [None]\\n    :param true_msg: message to output before returning True [None]\\n    :param default_msg: message to output before returning a <default> [None]\\n    :param invalid_msg: message to output after a invalid answer was given [None]\\n    :param env_msg: message to output when using input from env_var_override ['{} (from {})'],\\n           needs to have 2 placeholders for answer and env var name\\n    :param falsish: sequence of answers qualifying as False\\n    :param truish: sequence of answers qualifying as True\\n    :param defaultish: sequence of answers qualifying as <default>\\n    :param default: default return value (defaultish answer was given or no-answer condition) [False]\\n    :param retry: if True and input is incorrect, retry. Otherwise return default. [True]\\n    :param env_var_override: environment variable name [None]\\n    :param ofile: output stream [sys.stderr]\\n    :param input: input function [input from builtins]\\n    :return: boolean answer value, True or False\\n    \"\n\n    def output(msg, msg_type, is_prompt=False, **kwargs):\n        json_output = getattr(logging.getLogger('borg'), 'json', False)\n        if json_output:\n            kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n            print(json.dumps(kwargs), file=sys.stderr)\n        elif is_prompt:\n            print(msg, file=ofile, end='', flush=True)\n        else:\n            print(msg, file=ofile)\n    msgid = msgid or env_var_override\n    if ofile is None:\n        ofile = sys.stderr\n    if default not in (True, False):\n        raise ValueError('invalid default value, must be True or False')\n    if msg:\n        output(msg, 'prompt', is_prompt=True)\n    while True:\n        answer = None\n        if env_var_override:\n            answer = os.environ.get(env_var_override)\n            if answer is not None and env_msg:\n                output(env_msg.format(answer, env_var_override), 'env_answer', env_var=env_var_override)\n        if answer is None:\n            if not prompt:\n                return default\n            try:\n                answer = input()\n            except EOFError:\n                answer = truish[0] if default else falsish[0]\n        if answer in defaultish:\n            if default_msg:\n                output(default_msg, 'accepted_default')\n            return default\n        if answer in truish:\n            if true_msg:\n                output(true_msg, 'accepted_true')\n            return True\n        if answer in falsish:\n            if false_msg:\n                output(false_msg, 'accepted_false')\n            return False\n        if invalid_msg:\n            output(invalid_msg, 'invalid_answer')\n        if not retry:\n            return default\n        if retry_msg:\n            output(retry_msg, 'prompt_retry', is_prompt=True)\n        env_var_override = None",
            "def yes(msg=None, false_msg=None, true_msg=None, default_msg=None, retry_msg=None, invalid_msg=None, env_msg='{} (from {})', falsish=FALSISH, truish=TRUISH, defaultish=DEFAULTISH, default=False, retry=True, env_var_override=None, ofile=None, input=input, prompt=True, msgid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Output <msg> (usually a question) and let user input an answer.\\n    Qualifies the answer according to falsish, truish and defaultish as True, False or <default>.\\n    If it didn't qualify and retry is False (no retries wanted), return the default [which\\n    defaults to False]. If retry is True let user retry answering until answer is qualified.\\n\\n    If env_var_override is given and this var is present in the environment, do not ask\\n    the user, but just use the env var contents as answer as if it was typed in.\\n    Otherwise read input from stdin and proceed as normal.\\n    If EOF is received instead an input or an invalid input without retry possibility,\\n    return default.\\n\\n    :param msg: introducing message to output on ofile, no \\n is added [None]\\n    :param retry_msg: retry message to output on ofile, no \\n is added [None]\\n    :param false_msg: message to output before returning False [None]\\n    :param true_msg: message to output before returning True [None]\\n    :param default_msg: message to output before returning a <default> [None]\\n    :param invalid_msg: message to output after a invalid answer was given [None]\\n    :param env_msg: message to output when using input from env_var_override ['{} (from {})'],\\n           needs to have 2 placeholders for answer and env var name\\n    :param falsish: sequence of answers qualifying as False\\n    :param truish: sequence of answers qualifying as True\\n    :param defaultish: sequence of answers qualifying as <default>\\n    :param default: default return value (defaultish answer was given or no-answer condition) [False]\\n    :param retry: if True and input is incorrect, retry. Otherwise return default. [True]\\n    :param env_var_override: environment variable name [None]\\n    :param ofile: output stream [sys.stderr]\\n    :param input: input function [input from builtins]\\n    :return: boolean answer value, True or False\\n    \"\n\n    def output(msg, msg_type, is_prompt=False, **kwargs):\n        json_output = getattr(logging.getLogger('borg'), 'json', False)\n        if json_output:\n            kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n            print(json.dumps(kwargs), file=sys.stderr)\n        elif is_prompt:\n            print(msg, file=ofile, end='', flush=True)\n        else:\n            print(msg, file=ofile)\n    msgid = msgid or env_var_override\n    if ofile is None:\n        ofile = sys.stderr\n    if default not in (True, False):\n        raise ValueError('invalid default value, must be True or False')\n    if msg:\n        output(msg, 'prompt', is_prompt=True)\n    while True:\n        answer = None\n        if env_var_override:\n            answer = os.environ.get(env_var_override)\n            if answer is not None and env_msg:\n                output(env_msg.format(answer, env_var_override), 'env_answer', env_var=env_var_override)\n        if answer is None:\n            if not prompt:\n                return default\n            try:\n                answer = input()\n            except EOFError:\n                answer = truish[0] if default else falsish[0]\n        if answer in defaultish:\n            if default_msg:\n                output(default_msg, 'accepted_default')\n            return default\n        if answer in truish:\n            if true_msg:\n                output(true_msg, 'accepted_true')\n            return True\n        if answer in falsish:\n            if false_msg:\n                output(false_msg, 'accepted_false')\n            return False\n        if invalid_msg:\n            output(invalid_msg, 'invalid_answer')\n        if not retry:\n            return default\n        if retry_msg:\n            output(retry_msg, 'prompt_retry', is_prompt=True)\n        env_var_override = None",
            "def yes(msg=None, false_msg=None, true_msg=None, default_msg=None, retry_msg=None, invalid_msg=None, env_msg='{} (from {})', falsish=FALSISH, truish=TRUISH, defaultish=DEFAULTISH, default=False, retry=True, env_var_override=None, ofile=None, input=input, prompt=True, msgid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Output <msg> (usually a question) and let user input an answer.\\n    Qualifies the answer according to falsish, truish and defaultish as True, False or <default>.\\n    If it didn't qualify and retry is False (no retries wanted), return the default [which\\n    defaults to False]. If retry is True let user retry answering until answer is qualified.\\n\\n    If env_var_override is given and this var is present in the environment, do not ask\\n    the user, but just use the env var contents as answer as if it was typed in.\\n    Otherwise read input from stdin and proceed as normal.\\n    If EOF is received instead an input or an invalid input without retry possibility,\\n    return default.\\n\\n    :param msg: introducing message to output on ofile, no \\n is added [None]\\n    :param retry_msg: retry message to output on ofile, no \\n is added [None]\\n    :param false_msg: message to output before returning False [None]\\n    :param true_msg: message to output before returning True [None]\\n    :param default_msg: message to output before returning a <default> [None]\\n    :param invalid_msg: message to output after a invalid answer was given [None]\\n    :param env_msg: message to output when using input from env_var_override ['{} (from {})'],\\n           needs to have 2 placeholders for answer and env var name\\n    :param falsish: sequence of answers qualifying as False\\n    :param truish: sequence of answers qualifying as True\\n    :param defaultish: sequence of answers qualifying as <default>\\n    :param default: default return value (defaultish answer was given or no-answer condition) [False]\\n    :param retry: if True and input is incorrect, retry. Otherwise return default. [True]\\n    :param env_var_override: environment variable name [None]\\n    :param ofile: output stream [sys.stderr]\\n    :param input: input function [input from builtins]\\n    :return: boolean answer value, True or False\\n    \"\n\n    def output(msg, msg_type, is_prompt=False, **kwargs):\n        json_output = getattr(logging.getLogger('borg'), 'json', False)\n        if json_output:\n            kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n            print(json.dumps(kwargs), file=sys.stderr)\n        elif is_prompt:\n            print(msg, file=ofile, end='', flush=True)\n        else:\n            print(msg, file=ofile)\n    msgid = msgid or env_var_override\n    if ofile is None:\n        ofile = sys.stderr\n    if default not in (True, False):\n        raise ValueError('invalid default value, must be True or False')\n    if msg:\n        output(msg, 'prompt', is_prompt=True)\n    while True:\n        answer = None\n        if env_var_override:\n            answer = os.environ.get(env_var_override)\n            if answer is not None and env_msg:\n                output(env_msg.format(answer, env_var_override), 'env_answer', env_var=env_var_override)\n        if answer is None:\n            if not prompt:\n                return default\n            try:\n                answer = input()\n            except EOFError:\n                answer = truish[0] if default else falsish[0]\n        if answer in defaultish:\n            if default_msg:\n                output(default_msg, 'accepted_default')\n            return default\n        if answer in truish:\n            if true_msg:\n                output(true_msg, 'accepted_true')\n            return True\n        if answer in falsish:\n            if false_msg:\n                output(false_msg, 'accepted_false')\n            return False\n        if invalid_msg:\n            output(invalid_msg, 'invalid_answer')\n        if not retry:\n            return default\n        if retry_msg:\n            output(retry_msg, 'prompt_retry', is_prompt=True)\n        env_var_override = None",
            "def yes(msg=None, false_msg=None, true_msg=None, default_msg=None, retry_msg=None, invalid_msg=None, env_msg='{} (from {})', falsish=FALSISH, truish=TRUISH, defaultish=DEFAULTISH, default=False, retry=True, env_var_override=None, ofile=None, input=input, prompt=True, msgid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Output <msg> (usually a question) and let user input an answer.\\n    Qualifies the answer according to falsish, truish and defaultish as True, False or <default>.\\n    If it didn't qualify and retry is False (no retries wanted), return the default [which\\n    defaults to False]. If retry is True let user retry answering until answer is qualified.\\n\\n    If env_var_override is given and this var is present in the environment, do not ask\\n    the user, but just use the env var contents as answer as if it was typed in.\\n    Otherwise read input from stdin and proceed as normal.\\n    If EOF is received instead an input or an invalid input without retry possibility,\\n    return default.\\n\\n    :param msg: introducing message to output on ofile, no \\n is added [None]\\n    :param retry_msg: retry message to output on ofile, no \\n is added [None]\\n    :param false_msg: message to output before returning False [None]\\n    :param true_msg: message to output before returning True [None]\\n    :param default_msg: message to output before returning a <default> [None]\\n    :param invalid_msg: message to output after a invalid answer was given [None]\\n    :param env_msg: message to output when using input from env_var_override ['{} (from {})'],\\n           needs to have 2 placeholders for answer and env var name\\n    :param falsish: sequence of answers qualifying as False\\n    :param truish: sequence of answers qualifying as True\\n    :param defaultish: sequence of answers qualifying as <default>\\n    :param default: default return value (defaultish answer was given or no-answer condition) [False]\\n    :param retry: if True and input is incorrect, retry. Otherwise return default. [True]\\n    :param env_var_override: environment variable name [None]\\n    :param ofile: output stream [sys.stderr]\\n    :param input: input function [input from builtins]\\n    :return: boolean answer value, True or False\\n    \"\n\n    def output(msg, msg_type, is_prompt=False, **kwargs):\n        json_output = getattr(logging.getLogger('borg'), 'json', False)\n        if json_output:\n            kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n            print(json.dumps(kwargs), file=sys.stderr)\n        elif is_prompt:\n            print(msg, file=ofile, end='', flush=True)\n        else:\n            print(msg, file=ofile)\n    msgid = msgid or env_var_override\n    if ofile is None:\n        ofile = sys.stderr\n    if default not in (True, False):\n        raise ValueError('invalid default value, must be True or False')\n    if msg:\n        output(msg, 'prompt', is_prompt=True)\n    while True:\n        answer = None\n        if env_var_override:\n            answer = os.environ.get(env_var_override)\n            if answer is not None and env_msg:\n                output(env_msg.format(answer, env_var_override), 'env_answer', env_var=env_var_override)\n        if answer is None:\n            if not prompt:\n                return default\n            try:\n                answer = input()\n            except EOFError:\n                answer = truish[0] if default else falsish[0]\n        if answer in defaultish:\n            if default_msg:\n                output(default_msg, 'accepted_default')\n            return default\n        if answer in truish:\n            if true_msg:\n                output(true_msg, 'accepted_true')\n            return True\n        if answer in falsish:\n            if false_msg:\n                output(false_msg, 'accepted_false')\n            return False\n        if invalid_msg:\n            output(invalid_msg, 'invalid_answer')\n        if not retry:\n            return default\n        if retry_msg:\n            output(retry_msg, 'prompt_retry', is_prompt=True)\n        env_var_override = None",
            "def yes(msg=None, false_msg=None, true_msg=None, default_msg=None, retry_msg=None, invalid_msg=None, env_msg='{} (from {})', falsish=FALSISH, truish=TRUISH, defaultish=DEFAULTISH, default=False, retry=True, env_var_override=None, ofile=None, input=input, prompt=True, msgid=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Output <msg> (usually a question) and let user input an answer.\\n    Qualifies the answer according to falsish, truish and defaultish as True, False or <default>.\\n    If it didn't qualify and retry is False (no retries wanted), return the default [which\\n    defaults to False]. If retry is True let user retry answering until answer is qualified.\\n\\n    If env_var_override is given and this var is present in the environment, do not ask\\n    the user, but just use the env var contents as answer as if it was typed in.\\n    Otherwise read input from stdin and proceed as normal.\\n    If EOF is received instead an input or an invalid input without retry possibility,\\n    return default.\\n\\n    :param msg: introducing message to output on ofile, no \\n is added [None]\\n    :param retry_msg: retry message to output on ofile, no \\n is added [None]\\n    :param false_msg: message to output before returning False [None]\\n    :param true_msg: message to output before returning True [None]\\n    :param default_msg: message to output before returning a <default> [None]\\n    :param invalid_msg: message to output after a invalid answer was given [None]\\n    :param env_msg: message to output when using input from env_var_override ['{} (from {})'],\\n           needs to have 2 placeholders for answer and env var name\\n    :param falsish: sequence of answers qualifying as False\\n    :param truish: sequence of answers qualifying as True\\n    :param defaultish: sequence of answers qualifying as <default>\\n    :param default: default return value (defaultish answer was given or no-answer condition) [False]\\n    :param retry: if True and input is incorrect, retry. Otherwise return default. [True]\\n    :param env_var_override: environment variable name [None]\\n    :param ofile: output stream [sys.stderr]\\n    :param input: input function [input from builtins]\\n    :return: boolean answer value, True or False\\n    \"\n\n    def output(msg, msg_type, is_prompt=False, **kwargs):\n        json_output = getattr(logging.getLogger('borg'), 'json', False)\n        if json_output:\n            kwargs.update(dict(type='question_%s' % msg_type, msgid=msgid, message=msg))\n            print(json.dumps(kwargs), file=sys.stderr)\n        elif is_prompt:\n            print(msg, file=ofile, end='', flush=True)\n        else:\n            print(msg, file=ofile)\n    msgid = msgid or env_var_override\n    if ofile is None:\n        ofile = sys.stderr\n    if default not in (True, False):\n        raise ValueError('invalid default value, must be True or False')\n    if msg:\n        output(msg, 'prompt', is_prompt=True)\n    while True:\n        answer = None\n        if env_var_override:\n            answer = os.environ.get(env_var_override)\n            if answer is not None and env_msg:\n                output(env_msg.format(answer, env_var_override), 'env_answer', env_var=env_var_override)\n        if answer is None:\n            if not prompt:\n                return default\n            try:\n                answer = input()\n            except EOFError:\n                answer = truish[0] if default else falsish[0]\n        if answer in defaultish:\n            if default_msg:\n                output(default_msg, 'accepted_default')\n            return default\n        if answer in truish:\n            if true_msg:\n                output(true_msg, 'accepted_true')\n            return True\n        if answer in falsish:\n            if false_msg:\n                output(false_msg, 'accepted_false')\n            return False\n        if invalid_msg:\n            output(invalid_msg, 'invalid_answer')\n        if not retry:\n            return default\n        if retry_msg:\n            output(retry_msg, 'prompt_retry', is_prompt=True)\n        env_var_override = None"
        ]
    }
]