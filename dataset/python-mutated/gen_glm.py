def update_param(name, param):
    if False:
        for i in range(10):
            print('nop')
    if name == 'distribution':
        param['values'].remove('custom')
        return param
    return None
extensions = dict(validate_params="\n# if (!is.null(beta_constraints)) {\n#     if (!inherits(beta_constraints, 'data.frame') && !is.H2OFrame(beta_constraints))\n#       stop(paste('`beta_constraints` must be an H2OH2OFrame or R data.frame. Got: ', class(beta_constraints)))\n#     if (inherits(beta_constraints, 'data.frame')) {\n#       beta_constraints <- as.h2o(beta_constraints)\n#     }\n# }\nif (inherits(beta_constraints, 'data.frame')) {\n  beta_constraints <- as.h2o(beta_constraints)\n}\n", skip_default_set_params_for=['training_frame', 'ignored_columns', 'response_column', 'max_confusion_matrix_size', 'interactions', 'nfolds', 'beta_constraints', 'missing_values_handling'], set_params='\nif( !missing(interactions) ) {\n  # interactions are column names => as-is\n  if( is.character(interactions) )       parms$interactions <- interactions\n  else if( is.numeric(interactions) )    parms$interactions <- names(training_frame)[interactions]\n  else stop("Don\'t know what to do with interactions. Supply vector of indices or names")\n}\n# For now, accept nfolds in the R interface if it is 0 or 1, since those values really mean do nothing.\n# For any other value, error out.\n# Expunge nfolds from the message sent to H2O, since H2O doesn\'t understand it.\nif (!missing(nfolds) && nfolds > 1)\n  parms$nfolds <- nfolds\nif(!missing(beta_constraints))\n  parms$beta_constraints <- beta_constraints\n  if(!missing(missing_values_handling))\n    parms$missing_values_handling <- missing_values_handling\n', set_required_params='\nparms$training_frame <- training_frame\nargs <- .verify_dataxy(training_frame, x, y)\nif (HGLM && is.null(random_columns)) stop("HGLM: must specify random effect column!")\nif (HGLM && (!is.null(random_columns))) {\n  temp <- .verify_dataxy(training_frame, random_columns, y)\n  random_columns <- temp$x_i-1  # change column index to numeric column indices starting from 0\n}\nif( !missing(offset_column) && !is.null(offset_column))  args$x_ignore <- args$x_ignore[!( offset_column == args$x_ignore )]\nif( !missing(weights_column) && !is.null(weights_column)) args$x_ignore <- args$x_ignore[!( weights_column == args$x_ignore )]\nif( !missing(fold_column) && !is.null(fold_column)) args$x_ignore <- args$x_ignore[!( fold_column == args$x_ignore )]\nparms$ignored_columns <- args$x_ignore\nparms$response_column <- args$y    \n    ', with_model='\nmodel@model$coefficients <- model@model$coefficients_table[,2]\nnames(model@model$coefficients) <- model@model$coefficients_table[,1]\nif (!(is.null(model@model$random_coefficients_table))) {\n    model@model$random_coefficients <- model@model$random_coefficients_table[,2]\n    names(model@model$random_coefficients) <- model@model$random_coefficients_table[,1]\n}\n', module='\n#\' Set betas of an existing H2O GLM Model\n#\'\n#\' This function allows setting betas of an existing glm model.\n#\' @param model an \\linkS4class{H2OModel} corresponding from a \\code{h2o.glm} call.\n#\' @param beta a new set of betas (a named vector)\n#\' @export\nh2o.makeGLMModel <- function(model,beta) {\n  res = .h2o.__remoteSend(method="POST", .h2o.__GLMMakeModel, model=model@model_id, names = paste("[",paste(paste("\\"",names(beta),"\\"",sep=""), collapse=","),"]",sep=""), beta = paste("[",paste(as.vector(beta),collapse=","),"]",sep=""))\n  m <- h2o.getModel(model_id=res$model_id$name)\n  m@model$coefficients <- m@model$coefficients_table[,2]\n  names(m@model$coefficients) <- m@model$coefficients_table[,1]\n  m\n}\n\n#\' Extract best lambda value found from glm model.\n#\'\n#\' This function allows setting betas of an existing glm model.\n#\' @param model an \\linkS4class{H2OModel} corresponding from a \\code{h2o.glm} call.\n#\' @export\nh2o.getLambdaBest <- function(model) {\n  model@model$lambda_best\n}\n\n#\' Extract the maximum lambda value used during lambda search from glm model.\n#\'\n#\' This function allows setting betas of an existing glm model.\n#\' @param model an \\linkS4class{H2OModel} corresponding from a \\code{h2o.glm} call.\n#\' @export\nh2o.getLambdaMax <- function(model) {\n  lambdaMax <- model@model$lambda_max\n  if (lambdaMax < 0) # -1 if lambda_search=FALSE\n    stop("getLambdaMax(model) can only be called when lambda_search=True or when you have multiple lambda values to try.")\n  else \n    lambdaMax\n}\n\n#\' Extract best alpha value found from glm model.\n#\'\n#\' This function allows setting betas of an existing glm model.\n#\' @param model an \\linkS4class{H2OModel} corresponding from a \\code{h2o.glm} call.\n#\' @export\nh2o.getAlphaBest <- function(model) {\n  model@model$alpha_best\n}\n\n#\' Extract the minimum lambda value calculated during lambda search from glm model.\n#\' Note that due to early stop, this minimum lambda value may not be used in the actual lambda search.\n#\'\n#\' This function allows setting betas of an existing glm model.\n#\' @param model an \\linkS4class{H2OModel} corresponding from a \\code{h2o.glm} call.\n#\' @export\nh2o.getLambdaMin <- function(model) {\n  lambdaMin <- model@model$lambda_min # will be -1 if lambda_search=FALSE\n  if (lambdaMin < 0)\n    stop("getLambdaMin(model) can only be called when lambda_search=True or when you have multiple lambda values to try.")\n  else \n    lambdaMin\n}\n\n#\' Extract full regularization path from a GLM model\n#\'\n#\' Extract the full regularization path from a GLM model (assuming it was run with the lambda search option).\n#\'\n#\' @param model an \\linkS4class{H2OModel} corresponding from a \\code{h2o.glm} call.\n#\' @export\nh2o.getGLMFullRegularizationPath <- function(model) {\n  res = .h2o.__remoteSend(method="GET", .h2o.__GLMRegPath, model=model@model_id)\n  colnames(res$coefficients) <- res$coefficient_names\n  if(!is.null(res$coefficients_std) && length(res$coefficients_std) > 0L) {\n    colnames(res$coefficients_std) <- res$coefficient_names\n  }\n  res\n}\n\n#\' Compute weighted gram matrix.\n#\'\n#\' @param X an \\linkS4class{H2OModel} corresponding to H2O framel.\n#\' @param weights character corresponding to name of weight vector in frame.\n#\' @param use_all_factor_levels logical flag telling h2o whether or not to skip first level of categorical variables during one-hot encoding.\n#\' @param standardize logical flag telling h2o whether or not to standardize data\n#\' @param skip_missing logical flag telling h2o whether skip rows with missing data or impute them with mean\n#\' @export\nh2o.computeGram <- function(X,weights="", use_all_factor_levels=FALSE,standardize=TRUE,skip_missing=FALSE) {\n  res = .h2o.__remoteSend(method="GET", .h2o.__ComputeGram, X=h2o.getId(X),W=weights,use_all_factor_levels=use_all_factor_levels,standardize=standardize,skip_missing=skip_missing)\n  h2o.getFrame(res$destination_frame$name)\n}\n\n##\' Start an H2O Generalized Linear Model Job\n##\'\n##\' Creates a background H2O GLM job.\n##\' @inheritParams h2o.glm\n##\' @return Returns a \\linkS4class{H2OModelFuture} class object.\n##\' @export\n#h2o.startGLMJob <- function(x, y, training_frame, model_id, validation_frame,\n#                    #AUTOGENERATED Params\n#                    max_iterations = 50,\n#                    beta_epsilon = 0,\n#                    solver = c("IRLSM", "L_BFGS"),\n#                    standardize = TRUE,\n#                    family = c("gaussian", "binomial", "poisson", "gamma", "tweedie"),\n#                    link = c("family_default", "identity", "logit", "log", "inverse", "tweedie"),\n#                    tweedie_variance_power = NaN,\n#                    tweedie_link_power = NaN,\n#                    alpha = 0.5,\n#                    prior = 0.0,\n#                    lambda = 1e-05,\n#                    lambda_search = FALSE,\n#                    nlambdas = -1,\n#                    lambda_min_ratio = 1.0,\n#                    nfolds = 0,\n#                    beta_constraints = NULL,\n#                    ...\n#                    )\n#{\n#  # if (!is.null(beta_constraints)) {\n#  #     if (!inherits(beta_constraints, "data.frame") && !is.H2OFrame("H2OFrame"))\n#  #       stop(paste("`beta_constraints` must be an H2OH2OFrame or R data.frame. Got: ", class(beta_constraints)))\n#  #     if (inherits(beta_constraints, "data.frame")) {\n#  #       beta_constraints <- as.h2o(beta_constraints)\n#  #     }\n#  # }\n#\n#  if (!is.H2OFrame(training_frame))\n#      tryCatch(training_frame <- h2o.getFrame(training_frame),\n#               error = function(err) {\n#                 stop("argument "training_frame" must be a valid H2OFrame or model ID")\n#              })\n#\n#    parms <- list()\n#    args <- .verify_dataxy(training_frame, x, y)\n#    parms$ignored_columns <- args$x_ignore\n#    parms$response_column <- args$y\n#    parms$training_frame  <- training_frame\n#    parms$beta_constraints <- beta_constraints\n#    if(!missing(model_id))\n#      parms$model_id <- model_id\n#    if(!missing(validation_frame))\n#      parms$validation_frame <- validation_frame\n#    if(!missing(max_iterations))\n#      parms$max_iterations <- max_iterations\n#    if(!missing(beta_epsilon))\n#      parms$beta_epsilon <- beta_epsilon\n#    if(!missing(solver))\n#      parms$solver <- solver\n#    if(!missing(standardize))\n#      parms$standardize <- standardize\n#    if(!missing(family))\n#      parms$family <- family\n#    if(!missing(link))\n#      parms$link <- link\n#    if(!missing(tweedie_variance_power))\n#      parms$tweedie_variance_power <- tweedie_variance_power\n#    if(!missing(tweedie_link_power))\n#      parms$tweedie_link_power <- tweedie_link_power\n#    if(!missing(alpha))\n#      parms$alpha <- alpha\n#    if(!missing(prior))\n#      parms$prior <- prior\n#    if(!missing(lambda))\n#      parms$lambda <- lambda\n#    if(!missing(lambda_search))\n#      parms$lambda_search <- lambda_search\n#    if(!missing(nlambdas))\n#      parms$nlambdas <- nlambdas\n#    if(!missing(lambda_min_ratio))\n#      parms$lambda_min_ratio <- lambda_min_ratio\n#    if(!missing(nfolds))\n#      parms$nfolds <- nfolds\n#\n#    .h2o.startModelJob(\'glm\', parms, h2oRestApiVersion=.h2o.__REST_API_VERSION)\n#}\n')
doc = dict(preamble='\nFit a generalized linear model\n\nFits a generalized linear model, specified by a response variable, a set of predictors, and a\ndescription of the error distribution.\n', returns="\nA subclass of \\code{\\linkS4class{H2OModel}} is returned. The specific subclass depends on the machine\nlearning task at hand (if it's binomial classification, then an \\code{\\linkS4class{H2OBinomialModel}} is\nreturned, if it's regression then a \\code{\\linkS4class{H2ORegressionModel}} is returned). The default print-\nout of the models is shown, but further GLM-specifc information can be queried out of the object. To access\nthese various items, please refer to the seealso section below. Upon completion of the GLM, the resulting\nobject has coefficients, normalized coefficients, residual/null deviance, aic, and a host of model metrics\nincluding MSE, AUC (for logistic regression), degrees of freedom, and confusion matrices. Please refer to the\nmore in-depth GLM documentation available here:\n\\url{https://h2o-release.s3.amazonaws.com/h2o-dev/rel-shannon/2/docs-website/h2o-docs/index.html#Data+Science+Algorithms-GLM}\n", seealso='\n\\code{\\link{predict.H2OModel}} for prediction, \\code{\\link{h2o.mse}}, \\code{\\link{h2o.auc}},\n\\code{\\link{h2o.confusionMatrix}}, \\code{\\link{h2o.performance}}, \\code{\\link{h2o.giniCoef}},\n\\code{\\link{h2o.logloss}}, \\code{\\link{h2o.varimp}}, \\code{\\link{h2o.scoreHistory}}\n', examples='\nh2o.init()\n\n# Run GLM of CAPSULE ~ AGE + RACE + PSA + DCAPS\nprostate_path = system.file("extdata", "prostate.csv", package = "h2o")\nprostate = h2o.importFile(path = prostate_path)\nh2o.glm(y = "CAPSULE", x = c("AGE", "RACE", "PSA", "DCAPS"), training_frame = prostate,\n        family = "binomial", nfolds = 0, alpha = 0.5, lambda_search = FALSE)\n\n# Run GLM of VOL ~ CAPSULE + AGE + RACE + PSA + GLEASON\npredictors = setdiff(colnames(prostate), c("ID", "DPROS", "DCAPS", "VOL"))\nh2o.glm(y = "VOL", x = predictors, training_frame = prostate, family = "gaussian",\n        nfolds = 0, alpha = 0.1, lambda_search = FALSE)\n\n\n# GLM variable importance\n# Also see:\n#   https://github.com/h2oai/h2o/blob/master/R/tests/testdir_demos/runit_demo_VI_all_algos.R\nbank = h2o.importFile(\n  path="https://s3.amazonaws.com/h2o-public-test-data/smalldata/demos/bank-additional-full.csv"\n)\npredictors = 1:20\ntarget = "y"\nglm = h2o.glm(x = predictors, \n              y = target, \n              training_frame = bank, \n              family = "binomial", \n              standardize = TRUE,\n              lambda_search = TRUE)\nh2o.std_coef_plot(glm, num_of_features = 20)\n')