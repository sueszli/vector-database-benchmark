[
    {
        "func_name": "continued_fraction",
        "original": "def continued_fraction(a) -> list:\n    \"\"\"Return the continued fraction representation of a Rational or\n    quadratic irrational.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.continued_fraction import continued_fraction\n    >>> from sympy import sqrt\n    >>> continued_fraction((1 + 2*sqrt(3))/5)\n    [0, 1, [8, 3, 34, 3]]\n\n    See Also\n    ========\n    continued_fraction_periodic, continued_fraction_reduce, continued_fraction_convergents\n    \"\"\"\n    e = _sympify(a)\n    if all((i.is_Rational for i in e.atoms())):\n        if e.is_Integer:\n            return continued_fraction_periodic(e, 1, 0)\n        elif e.is_Rational:\n            return continued_fraction_periodic(e.p, e.q, 0)\n        elif e.is_Pow and e.exp is S.Half and e.base.is_Integer:\n            return continued_fraction_periodic(0, 1, e.base)\n        elif e.is_Mul and len(e.args) == 2 and (e.args[0].is_Rational and e.args[1].is_Pow and e.args[1].base.is_Integer and (e.args[1].exp is S.Half)):\n            (a, b) = e.args\n            return continued_fraction_periodic(0, a.q, b.base, a.p)\n        else:\n            (p, d) = e.expand().as_numer_denom()\n            if d.is_Integer:\n                if p.is_Rational:\n                    return continued_fraction_periodic(p, d)\n                if p.is_Add and len(p.args) == 2:\n                    (a, bc) = p.args\n                else:\n                    a = S.Zero\n                    bc = p\n                if a.is_Integer:\n                    b = S.NaN\n                    if bc.is_Mul and len(bc.args) == 2:\n                        (b, c) = bc.args\n                    elif bc.is_Pow:\n                        b = Integer(1)\n                        c = bc\n                    if b.is_Integer and (c.is_Pow and c.exp is S.Half and c.base.is_Integer):\n                        c = c.base\n                        return continued_fraction_periodic(a, d, c, b)\n    raise ValueError('expecting a rational or quadratic irrational, not %s' % e)",
        "mutated": [
            "def continued_fraction(a) -> list:\n    if False:\n        i = 10\n    'Return the continued fraction representation of a Rational or\\n    quadratic irrational.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction\\n    >>> from sympy import sqrt\\n    >>> continued_fraction((1 + 2*sqrt(3))/5)\\n    [0, 1, [8, 3, 34, 3]]\\n\\n    See Also\\n    ========\\n    continued_fraction_periodic, continued_fraction_reduce, continued_fraction_convergents\\n    '\n    e = _sympify(a)\n    if all((i.is_Rational for i in e.atoms())):\n        if e.is_Integer:\n            return continued_fraction_periodic(e, 1, 0)\n        elif e.is_Rational:\n            return continued_fraction_periodic(e.p, e.q, 0)\n        elif e.is_Pow and e.exp is S.Half and e.base.is_Integer:\n            return continued_fraction_periodic(0, 1, e.base)\n        elif e.is_Mul and len(e.args) == 2 and (e.args[0].is_Rational and e.args[1].is_Pow and e.args[1].base.is_Integer and (e.args[1].exp is S.Half)):\n            (a, b) = e.args\n            return continued_fraction_periodic(0, a.q, b.base, a.p)\n        else:\n            (p, d) = e.expand().as_numer_denom()\n            if d.is_Integer:\n                if p.is_Rational:\n                    return continued_fraction_periodic(p, d)\n                if p.is_Add and len(p.args) == 2:\n                    (a, bc) = p.args\n                else:\n                    a = S.Zero\n                    bc = p\n                if a.is_Integer:\n                    b = S.NaN\n                    if bc.is_Mul and len(bc.args) == 2:\n                        (b, c) = bc.args\n                    elif bc.is_Pow:\n                        b = Integer(1)\n                        c = bc\n                    if b.is_Integer and (c.is_Pow and c.exp is S.Half and c.base.is_Integer):\n                        c = c.base\n                        return continued_fraction_periodic(a, d, c, b)\n    raise ValueError('expecting a rational or quadratic irrational, not %s' % e)",
            "def continued_fraction(a) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the continued fraction representation of a Rational or\\n    quadratic irrational.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction\\n    >>> from sympy import sqrt\\n    >>> continued_fraction((1 + 2*sqrt(3))/5)\\n    [0, 1, [8, 3, 34, 3]]\\n\\n    See Also\\n    ========\\n    continued_fraction_periodic, continued_fraction_reduce, continued_fraction_convergents\\n    '\n    e = _sympify(a)\n    if all((i.is_Rational for i in e.atoms())):\n        if e.is_Integer:\n            return continued_fraction_periodic(e, 1, 0)\n        elif e.is_Rational:\n            return continued_fraction_periodic(e.p, e.q, 0)\n        elif e.is_Pow and e.exp is S.Half and e.base.is_Integer:\n            return continued_fraction_periodic(0, 1, e.base)\n        elif e.is_Mul and len(e.args) == 2 and (e.args[0].is_Rational and e.args[1].is_Pow and e.args[1].base.is_Integer and (e.args[1].exp is S.Half)):\n            (a, b) = e.args\n            return continued_fraction_periodic(0, a.q, b.base, a.p)\n        else:\n            (p, d) = e.expand().as_numer_denom()\n            if d.is_Integer:\n                if p.is_Rational:\n                    return continued_fraction_periodic(p, d)\n                if p.is_Add and len(p.args) == 2:\n                    (a, bc) = p.args\n                else:\n                    a = S.Zero\n                    bc = p\n                if a.is_Integer:\n                    b = S.NaN\n                    if bc.is_Mul and len(bc.args) == 2:\n                        (b, c) = bc.args\n                    elif bc.is_Pow:\n                        b = Integer(1)\n                        c = bc\n                    if b.is_Integer and (c.is_Pow and c.exp is S.Half and c.base.is_Integer):\n                        c = c.base\n                        return continued_fraction_periodic(a, d, c, b)\n    raise ValueError('expecting a rational or quadratic irrational, not %s' % e)",
            "def continued_fraction(a) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the continued fraction representation of a Rational or\\n    quadratic irrational.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction\\n    >>> from sympy import sqrt\\n    >>> continued_fraction((1 + 2*sqrt(3))/5)\\n    [0, 1, [8, 3, 34, 3]]\\n\\n    See Also\\n    ========\\n    continued_fraction_periodic, continued_fraction_reduce, continued_fraction_convergents\\n    '\n    e = _sympify(a)\n    if all((i.is_Rational for i in e.atoms())):\n        if e.is_Integer:\n            return continued_fraction_periodic(e, 1, 0)\n        elif e.is_Rational:\n            return continued_fraction_periodic(e.p, e.q, 0)\n        elif e.is_Pow and e.exp is S.Half and e.base.is_Integer:\n            return continued_fraction_periodic(0, 1, e.base)\n        elif e.is_Mul and len(e.args) == 2 and (e.args[0].is_Rational and e.args[1].is_Pow and e.args[1].base.is_Integer and (e.args[1].exp is S.Half)):\n            (a, b) = e.args\n            return continued_fraction_periodic(0, a.q, b.base, a.p)\n        else:\n            (p, d) = e.expand().as_numer_denom()\n            if d.is_Integer:\n                if p.is_Rational:\n                    return continued_fraction_periodic(p, d)\n                if p.is_Add and len(p.args) == 2:\n                    (a, bc) = p.args\n                else:\n                    a = S.Zero\n                    bc = p\n                if a.is_Integer:\n                    b = S.NaN\n                    if bc.is_Mul and len(bc.args) == 2:\n                        (b, c) = bc.args\n                    elif bc.is_Pow:\n                        b = Integer(1)\n                        c = bc\n                    if b.is_Integer and (c.is_Pow and c.exp is S.Half and c.base.is_Integer):\n                        c = c.base\n                        return continued_fraction_periodic(a, d, c, b)\n    raise ValueError('expecting a rational or quadratic irrational, not %s' % e)",
            "def continued_fraction(a) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the continued fraction representation of a Rational or\\n    quadratic irrational.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction\\n    >>> from sympy import sqrt\\n    >>> continued_fraction((1 + 2*sqrt(3))/5)\\n    [0, 1, [8, 3, 34, 3]]\\n\\n    See Also\\n    ========\\n    continued_fraction_periodic, continued_fraction_reduce, continued_fraction_convergents\\n    '\n    e = _sympify(a)\n    if all((i.is_Rational for i in e.atoms())):\n        if e.is_Integer:\n            return continued_fraction_periodic(e, 1, 0)\n        elif e.is_Rational:\n            return continued_fraction_periodic(e.p, e.q, 0)\n        elif e.is_Pow and e.exp is S.Half and e.base.is_Integer:\n            return continued_fraction_periodic(0, 1, e.base)\n        elif e.is_Mul and len(e.args) == 2 and (e.args[0].is_Rational and e.args[1].is_Pow and e.args[1].base.is_Integer and (e.args[1].exp is S.Half)):\n            (a, b) = e.args\n            return continued_fraction_periodic(0, a.q, b.base, a.p)\n        else:\n            (p, d) = e.expand().as_numer_denom()\n            if d.is_Integer:\n                if p.is_Rational:\n                    return continued_fraction_periodic(p, d)\n                if p.is_Add and len(p.args) == 2:\n                    (a, bc) = p.args\n                else:\n                    a = S.Zero\n                    bc = p\n                if a.is_Integer:\n                    b = S.NaN\n                    if bc.is_Mul and len(bc.args) == 2:\n                        (b, c) = bc.args\n                    elif bc.is_Pow:\n                        b = Integer(1)\n                        c = bc\n                    if b.is_Integer and (c.is_Pow and c.exp is S.Half and c.base.is_Integer):\n                        c = c.base\n                        return continued_fraction_periodic(a, d, c, b)\n    raise ValueError('expecting a rational or quadratic irrational, not %s' % e)",
            "def continued_fraction(a) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the continued fraction representation of a Rational or\\n    quadratic irrational.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction\\n    >>> from sympy import sqrt\\n    >>> continued_fraction((1 + 2*sqrt(3))/5)\\n    [0, 1, [8, 3, 34, 3]]\\n\\n    See Also\\n    ========\\n    continued_fraction_periodic, continued_fraction_reduce, continued_fraction_convergents\\n    '\n    e = _sympify(a)\n    if all((i.is_Rational for i in e.atoms())):\n        if e.is_Integer:\n            return continued_fraction_periodic(e, 1, 0)\n        elif e.is_Rational:\n            return continued_fraction_periodic(e.p, e.q, 0)\n        elif e.is_Pow and e.exp is S.Half and e.base.is_Integer:\n            return continued_fraction_periodic(0, 1, e.base)\n        elif e.is_Mul and len(e.args) == 2 and (e.args[0].is_Rational and e.args[1].is_Pow and e.args[1].base.is_Integer and (e.args[1].exp is S.Half)):\n            (a, b) = e.args\n            return continued_fraction_periodic(0, a.q, b.base, a.p)\n        else:\n            (p, d) = e.expand().as_numer_denom()\n            if d.is_Integer:\n                if p.is_Rational:\n                    return continued_fraction_periodic(p, d)\n                if p.is_Add and len(p.args) == 2:\n                    (a, bc) = p.args\n                else:\n                    a = S.Zero\n                    bc = p\n                if a.is_Integer:\n                    b = S.NaN\n                    if bc.is_Mul and len(bc.args) == 2:\n                        (b, c) = bc.args\n                    elif bc.is_Pow:\n                        b = Integer(1)\n                        c = bc\n                    if b.is_Integer and (c.is_Pow and c.exp is S.Half and c.base.is_Integer):\n                        c = c.base\n                        return continued_fraction_periodic(a, d, c, b)\n    raise ValueError('expecting a rational or quadratic irrational, not %s' % e)"
        ]
    },
    {
        "func_name": "continued_fraction_periodic",
        "original": "def continued_fraction_periodic(p, q, d=0, s=1) -> list:\n    \"\"\"\n    Find the periodic continued fraction expansion of a quadratic irrational.\n\n    Compute the continued fraction expansion of a rational or a\n    quadratic irrational number, i.e. `\\\\frac{p + s\\\\sqrt{d}}{q}`, where\n    `p`, `q \\\\ne 0` and `d \\\\ge 0` are integers.\n\n    Returns the continued fraction representation (canonical form) as\n    a list of integers, optionally ending (for quadratic irrationals)\n    with list of integers representing the repeating digits.\n\n    Parameters\n    ==========\n\n    p : int\n        the rational part of the number's numerator\n    q : int\n        the denominator of the number\n    d : int, optional\n        the irrational part (discriminator) of the number's numerator\n    s : int, optional\n        the coefficient of the irrational part\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\n    >>> continued_fraction_periodic(3, 2, 7)\n    [2, [1, 4, 1, 1]]\n\n    Golden ratio has the simplest continued fraction expansion:\n\n    >>> continued_fraction_periodic(1, 2, 5)\n    [[1]]\n\n    If the discriminator is zero or a perfect square then the number will be a\n    rational number:\n\n    >>> continued_fraction_periodic(4, 3, 0)\n    [1, 3]\n    >>> continued_fraction_periodic(4, 3, 49)\n    [3, 1, 2]\n\n    See Also\n    ========\n\n    continued_fraction_iterator, continued_fraction_reduce\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Periodic_continued_fraction\n    .. [2] K. Rosen. Elementary Number theory and its applications.\n           Addison-Wesley, 3 Sub edition, pages 379-381, January 1992.\n\n    \"\"\"\n    from sympy.functions import sqrt, floor\n    (p, q, d, s) = list(map(as_int, [p, q, d, s]))\n    if d < 0:\n        raise ValueError('expected non-negative for `d` but got %s' % d)\n    if q == 0:\n        raise ValueError('The denominator cannot be 0.')\n    if not s:\n        d = 0\n    sd = sqrt(d)\n    if sd.is_Integer:\n        return list(continued_fraction_iterator(Rational(p + s * sd, q)))\n    if q < 0:\n        (p, q, s) = (-p, -q, -s)\n    n = (p + s * sd) / q\n    if n < 0:\n        w = floor(-n)\n        f = -n - w\n        one_f = continued_fraction(1 - f)\n        one_f[0] -= w + 1\n        return one_f\n    d *= s ** 2\n    sd *= s\n    if (d - p ** 2) % q:\n        d *= q ** 2\n        sd *= q\n        p *= q\n        q *= q\n    terms: list[int] = []\n    pq = {}\n    while (p, q) not in pq:\n        pq[p, q] = len(terms)\n        terms.append((p + sd) // q)\n        p = terms[-1] * q - p\n        q = (d - p ** 2) // q\n    i = pq[p, q]\n    return terms[:i] + [terms[i:]]",
        "mutated": [
            "def continued_fraction_periodic(p, q, d=0, s=1) -> list:\n    if False:\n        i = 10\n    \"\\n    Find the periodic continued fraction expansion of a quadratic irrational.\\n\\n    Compute the continued fraction expansion of a rational or a\\n    quadratic irrational number, i.e. `\\\\frac{p + s\\\\sqrt{d}}{q}`, where\\n    `p`, `q \\\\ne 0` and `d \\\\ge 0` are integers.\\n\\n    Returns the continued fraction representation (canonical form) as\\n    a list of integers, optionally ending (for quadratic irrationals)\\n    with list of integers representing the repeating digits.\\n\\n    Parameters\\n    ==========\\n\\n    p : int\\n        the rational part of the number's numerator\\n    q : int\\n        the denominator of the number\\n    d : int, optional\\n        the irrational part (discriminator) of the number's numerator\\n    s : int, optional\\n        the coefficient of the irrational part\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_periodic(3, 2, 7)\\n    [2, [1, 4, 1, 1]]\\n\\n    Golden ratio has the simplest continued fraction expansion:\\n\\n    >>> continued_fraction_periodic(1, 2, 5)\\n    [[1]]\\n\\n    If the discriminator is zero or a perfect square then the number will be a\\n    rational number:\\n\\n    >>> continued_fraction_periodic(4, 3, 0)\\n    [1, 3]\\n    >>> continued_fraction_periodic(4, 3, 49)\\n    [3, 1, 2]\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction_reduce\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Periodic_continued_fraction\\n    .. [2] K. Rosen. Elementary Number theory and its applications.\\n           Addison-Wesley, 3 Sub edition, pages 379-381, January 1992.\\n\\n    \"\n    from sympy.functions import sqrt, floor\n    (p, q, d, s) = list(map(as_int, [p, q, d, s]))\n    if d < 0:\n        raise ValueError('expected non-negative for `d` but got %s' % d)\n    if q == 0:\n        raise ValueError('The denominator cannot be 0.')\n    if not s:\n        d = 0\n    sd = sqrt(d)\n    if sd.is_Integer:\n        return list(continued_fraction_iterator(Rational(p + s * sd, q)))\n    if q < 0:\n        (p, q, s) = (-p, -q, -s)\n    n = (p + s * sd) / q\n    if n < 0:\n        w = floor(-n)\n        f = -n - w\n        one_f = continued_fraction(1 - f)\n        one_f[0] -= w + 1\n        return one_f\n    d *= s ** 2\n    sd *= s\n    if (d - p ** 2) % q:\n        d *= q ** 2\n        sd *= q\n        p *= q\n        q *= q\n    terms: list[int] = []\n    pq = {}\n    while (p, q) not in pq:\n        pq[p, q] = len(terms)\n        terms.append((p + sd) // q)\n        p = terms[-1] * q - p\n        q = (d - p ** 2) // q\n    i = pq[p, q]\n    return terms[:i] + [terms[i:]]",
            "def continued_fraction_periodic(p, q, d=0, s=1) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Find the periodic continued fraction expansion of a quadratic irrational.\\n\\n    Compute the continued fraction expansion of a rational or a\\n    quadratic irrational number, i.e. `\\\\frac{p + s\\\\sqrt{d}}{q}`, where\\n    `p`, `q \\\\ne 0` and `d \\\\ge 0` are integers.\\n\\n    Returns the continued fraction representation (canonical form) as\\n    a list of integers, optionally ending (for quadratic irrationals)\\n    with list of integers representing the repeating digits.\\n\\n    Parameters\\n    ==========\\n\\n    p : int\\n        the rational part of the number's numerator\\n    q : int\\n        the denominator of the number\\n    d : int, optional\\n        the irrational part (discriminator) of the number's numerator\\n    s : int, optional\\n        the coefficient of the irrational part\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_periodic(3, 2, 7)\\n    [2, [1, 4, 1, 1]]\\n\\n    Golden ratio has the simplest continued fraction expansion:\\n\\n    >>> continued_fraction_periodic(1, 2, 5)\\n    [[1]]\\n\\n    If the discriminator is zero or a perfect square then the number will be a\\n    rational number:\\n\\n    >>> continued_fraction_periodic(4, 3, 0)\\n    [1, 3]\\n    >>> continued_fraction_periodic(4, 3, 49)\\n    [3, 1, 2]\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction_reduce\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Periodic_continued_fraction\\n    .. [2] K. Rosen. Elementary Number theory and its applications.\\n           Addison-Wesley, 3 Sub edition, pages 379-381, January 1992.\\n\\n    \"\n    from sympy.functions import sqrt, floor\n    (p, q, d, s) = list(map(as_int, [p, q, d, s]))\n    if d < 0:\n        raise ValueError('expected non-negative for `d` but got %s' % d)\n    if q == 0:\n        raise ValueError('The denominator cannot be 0.')\n    if not s:\n        d = 0\n    sd = sqrt(d)\n    if sd.is_Integer:\n        return list(continued_fraction_iterator(Rational(p + s * sd, q)))\n    if q < 0:\n        (p, q, s) = (-p, -q, -s)\n    n = (p + s * sd) / q\n    if n < 0:\n        w = floor(-n)\n        f = -n - w\n        one_f = continued_fraction(1 - f)\n        one_f[0] -= w + 1\n        return one_f\n    d *= s ** 2\n    sd *= s\n    if (d - p ** 2) % q:\n        d *= q ** 2\n        sd *= q\n        p *= q\n        q *= q\n    terms: list[int] = []\n    pq = {}\n    while (p, q) not in pq:\n        pq[p, q] = len(terms)\n        terms.append((p + sd) // q)\n        p = terms[-1] * q - p\n        q = (d - p ** 2) // q\n    i = pq[p, q]\n    return terms[:i] + [terms[i:]]",
            "def continued_fraction_periodic(p, q, d=0, s=1) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Find the periodic continued fraction expansion of a quadratic irrational.\\n\\n    Compute the continued fraction expansion of a rational or a\\n    quadratic irrational number, i.e. `\\\\frac{p + s\\\\sqrt{d}}{q}`, where\\n    `p`, `q \\\\ne 0` and `d \\\\ge 0` are integers.\\n\\n    Returns the continued fraction representation (canonical form) as\\n    a list of integers, optionally ending (for quadratic irrationals)\\n    with list of integers representing the repeating digits.\\n\\n    Parameters\\n    ==========\\n\\n    p : int\\n        the rational part of the number's numerator\\n    q : int\\n        the denominator of the number\\n    d : int, optional\\n        the irrational part (discriminator) of the number's numerator\\n    s : int, optional\\n        the coefficient of the irrational part\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_periodic(3, 2, 7)\\n    [2, [1, 4, 1, 1]]\\n\\n    Golden ratio has the simplest continued fraction expansion:\\n\\n    >>> continued_fraction_periodic(1, 2, 5)\\n    [[1]]\\n\\n    If the discriminator is zero or a perfect square then the number will be a\\n    rational number:\\n\\n    >>> continued_fraction_periodic(4, 3, 0)\\n    [1, 3]\\n    >>> continued_fraction_periodic(4, 3, 49)\\n    [3, 1, 2]\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction_reduce\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Periodic_continued_fraction\\n    .. [2] K. Rosen. Elementary Number theory and its applications.\\n           Addison-Wesley, 3 Sub edition, pages 379-381, January 1992.\\n\\n    \"\n    from sympy.functions import sqrt, floor\n    (p, q, d, s) = list(map(as_int, [p, q, d, s]))\n    if d < 0:\n        raise ValueError('expected non-negative for `d` but got %s' % d)\n    if q == 0:\n        raise ValueError('The denominator cannot be 0.')\n    if not s:\n        d = 0\n    sd = sqrt(d)\n    if sd.is_Integer:\n        return list(continued_fraction_iterator(Rational(p + s * sd, q)))\n    if q < 0:\n        (p, q, s) = (-p, -q, -s)\n    n = (p + s * sd) / q\n    if n < 0:\n        w = floor(-n)\n        f = -n - w\n        one_f = continued_fraction(1 - f)\n        one_f[0] -= w + 1\n        return one_f\n    d *= s ** 2\n    sd *= s\n    if (d - p ** 2) % q:\n        d *= q ** 2\n        sd *= q\n        p *= q\n        q *= q\n    terms: list[int] = []\n    pq = {}\n    while (p, q) not in pq:\n        pq[p, q] = len(terms)\n        terms.append((p + sd) // q)\n        p = terms[-1] * q - p\n        q = (d - p ** 2) // q\n    i = pq[p, q]\n    return terms[:i] + [terms[i:]]",
            "def continued_fraction_periodic(p, q, d=0, s=1) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Find the periodic continued fraction expansion of a quadratic irrational.\\n\\n    Compute the continued fraction expansion of a rational or a\\n    quadratic irrational number, i.e. `\\\\frac{p + s\\\\sqrt{d}}{q}`, where\\n    `p`, `q \\\\ne 0` and `d \\\\ge 0` are integers.\\n\\n    Returns the continued fraction representation (canonical form) as\\n    a list of integers, optionally ending (for quadratic irrationals)\\n    with list of integers representing the repeating digits.\\n\\n    Parameters\\n    ==========\\n\\n    p : int\\n        the rational part of the number's numerator\\n    q : int\\n        the denominator of the number\\n    d : int, optional\\n        the irrational part (discriminator) of the number's numerator\\n    s : int, optional\\n        the coefficient of the irrational part\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_periodic(3, 2, 7)\\n    [2, [1, 4, 1, 1]]\\n\\n    Golden ratio has the simplest continued fraction expansion:\\n\\n    >>> continued_fraction_periodic(1, 2, 5)\\n    [[1]]\\n\\n    If the discriminator is zero or a perfect square then the number will be a\\n    rational number:\\n\\n    >>> continued_fraction_periodic(4, 3, 0)\\n    [1, 3]\\n    >>> continued_fraction_periodic(4, 3, 49)\\n    [3, 1, 2]\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction_reduce\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Periodic_continued_fraction\\n    .. [2] K. Rosen. Elementary Number theory and its applications.\\n           Addison-Wesley, 3 Sub edition, pages 379-381, January 1992.\\n\\n    \"\n    from sympy.functions import sqrt, floor\n    (p, q, d, s) = list(map(as_int, [p, q, d, s]))\n    if d < 0:\n        raise ValueError('expected non-negative for `d` but got %s' % d)\n    if q == 0:\n        raise ValueError('The denominator cannot be 0.')\n    if not s:\n        d = 0\n    sd = sqrt(d)\n    if sd.is_Integer:\n        return list(continued_fraction_iterator(Rational(p + s * sd, q)))\n    if q < 0:\n        (p, q, s) = (-p, -q, -s)\n    n = (p + s * sd) / q\n    if n < 0:\n        w = floor(-n)\n        f = -n - w\n        one_f = continued_fraction(1 - f)\n        one_f[0] -= w + 1\n        return one_f\n    d *= s ** 2\n    sd *= s\n    if (d - p ** 2) % q:\n        d *= q ** 2\n        sd *= q\n        p *= q\n        q *= q\n    terms: list[int] = []\n    pq = {}\n    while (p, q) not in pq:\n        pq[p, q] = len(terms)\n        terms.append((p + sd) // q)\n        p = terms[-1] * q - p\n        q = (d - p ** 2) // q\n    i = pq[p, q]\n    return terms[:i] + [terms[i:]]",
            "def continued_fraction_periodic(p, q, d=0, s=1) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Find the periodic continued fraction expansion of a quadratic irrational.\\n\\n    Compute the continued fraction expansion of a rational or a\\n    quadratic irrational number, i.e. `\\\\frac{p + s\\\\sqrt{d}}{q}`, where\\n    `p`, `q \\\\ne 0` and `d \\\\ge 0` are integers.\\n\\n    Returns the continued fraction representation (canonical form) as\\n    a list of integers, optionally ending (for quadratic irrationals)\\n    with list of integers representing the repeating digits.\\n\\n    Parameters\\n    ==========\\n\\n    p : int\\n        the rational part of the number's numerator\\n    q : int\\n        the denominator of the number\\n    d : int, optional\\n        the irrational part (discriminator) of the number's numerator\\n    s : int, optional\\n        the coefficient of the irrational part\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_periodic(3, 2, 7)\\n    [2, [1, 4, 1, 1]]\\n\\n    Golden ratio has the simplest continued fraction expansion:\\n\\n    >>> continued_fraction_periodic(1, 2, 5)\\n    [[1]]\\n\\n    If the discriminator is zero or a perfect square then the number will be a\\n    rational number:\\n\\n    >>> continued_fraction_periodic(4, 3, 0)\\n    [1, 3]\\n    >>> continued_fraction_periodic(4, 3, 49)\\n    [3, 1, 2]\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction_reduce\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Periodic_continued_fraction\\n    .. [2] K. Rosen. Elementary Number theory and its applications.\\n           Addison-Wesley, 3 Sub edition, pages 379-381, January 1992.\\n\\n    \"\n    from sympy.functions import sqrt, floor\n    (p, q, d, s) = list(map(as_int, [p, q, d, s]))\n    if d < 0:\n        raise ValueError('expected non-negative for `d` but got %s' % d)\n    if q == 0:\n        raise ValueError('The denominator cannot be 0.')\n    if not s:\n        d = 0\n    sd = sqrt(d)\n    if sd.is_Integer:\n        return list(continued_fraction_iterator(Rational(p + s * sd, q)))\n    if q < 0:\n        (p, q, s) = (-p, -q, -s)\n    n = (p + s * sd) / q\n    if n < 0:\n        w = floor(-n)\n        f = -n - w\n        one_f = continued_fraction(1 - f)\n        one_f[0] -= w + 1\n        return one_f\n    d *= s ** 2\n    sd *= s\n    if (d - p ** 2) % q:\n        d *= q ** 2\n        sd *= q\n        p *= q\n        q *= q\n    terms: list[int] = []\n    pq = {}\n    while (p, q) not in pq:\n        pq[p, q] = len(terms)\n        terms.append((p + sd) // q)\n        p = terms[-1] * q - p\n        q = (d - p ** 2) // q\n    i = pq[p, q]\n    return terms[:i] + [terms[i:]]"
        ]
    },
    {
        "func_name": "untillist",
        "original": "def untillist(cf):\n    for nxt in cf:\n        if isinstance(nxt, list):\n            period.extend(nxt)\n            yield x\n            break\n        yield nxt",
        "mutated": [
            "def untillist(cf):\n    if False:\n        i = 10\n    for nxt in cf:\n        if isinstance(nxt, list):\n            period.extend(nxt)\n            yield x\n            break\n        yield nxt",
            "def untillist(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for nxt in cf:\n        if isinstance(nxt, list):\n            period.extend(nxt)\n            yield x\n            break\n        yield nxt",
            "def untillist(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for nxt in cf:\n        if isinstance(nxt, list):\n            period.extend(nxt)\n            yield x\n            break\n        yield nxt",
            "def untillist(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for nxt in cf:\n        if isinstance(nxt, list):\n            period.extend(nxt)\n            yield x\n            break\n        yield nxt",
            "def untillist(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for nxt in cf:\n        if isinstance(nxt, list):\n            period.extend(nxt)\n            yield x\n            break\n        yield nxt"
        ]
    },
    {
        "func_name": "continued_fraction_reduce",
        "original": "def continued_fraction_reduce(cf):\n    \"\"\"\n    Reduce a continued fraction to a rational or quadratic irrational.\n\n    Compute the rational or quadratic irrational number from its\n    terminating or periodic continued fraction expansion.  The\n    continued fraction expansion (cf) should be supplied as a\n    terminating iterator supplying the terms of the expansion.  For\n    terminating continued fractions, this is equivalent to\n    ``list(continued_fraction_convergents(cf))[-1]``, only a little more\n    efficient.  If the expansion has a repeating part, a list of the\n    repeating terms should be returned as the last element from the\n    iterator.  This is the format returned by\n    continued_fraction_periodic.\n\n    For quadratic irrationals, returns the largest solution found,\n    which is generally the one sought, if the fraction is in canonical\n    form (all terms positive except possibly the first).\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_reduce\n    >>> continued_fraction_reduce([1, 2, 3, 4, 5])\n    225/157\n    >>> continued_fraction_reduce([-2, 1, 9, 7, 1, 2])\n    -256/233\n    >>> continued_fraction_reduce([2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8]).n(10)\n    2.718281835\n    >>> continued_fraction_reduce([1, 4, 2, [3, 1]])\n    (sqrt(21) + 287)/238\n    >>> continued_fraction_reduce([[1]])\n    (1 + sqrt(5))/2\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\n    >>> continued_fraction_reduce(continued_fraction_periodic(8, 5, 13))\n    (sqrt(13) + 8)/5\n\n    See Also\n    ========\n\n    continued_fraction_periodic\n\n    \"\"\"\n    from sympy.solvers import solve\n    period = []\n    x = Dummy('x')\n\n    def untillist(cf):\n        for nxt in cf:\n            if isinstance(nxt, list):\n                period.extend(nxt)\n                yield x\n                break\n            yield nxt\n    a = S.Zero\n    for a in continued_fraction_convergents(untillist(cf)):\n        pass\n    if period:\n        y = Dummy('y')\n        solns = solve(continued_fraction_reduce(period + [y]) - y, y)\n        solns.sort()\n        pure = solns[-1]\n        rv = a.subs(x, pure).radsimp()\n    else:\n        rv = a\n    if rv.is_Add:\n        rv = factor_terms(rv)\n        if rv.is_Mul and rv.args[0] == -1:\n            rv = rv.func(*rv.args)\n    return rv",
        "mutated": [
            "def continued_fraction_reduce(cf):\n    if False:\n        i = 10\n    '\\n    Reduce a continued fraction to a rational or quadratic irrational.\\n\\n    Compute the rational or quadratic irrational number from its\\n    terminating or periodic continued fraction expansion.  The\\n    continued fraction expansion (cf) should be supplied as a\\n    terminating iterator supplying the terms of the expansion.  For\\n    terminating continued fractions, this is equivalent to\\n    ``list(continued_fraction_convergents(cf))[-1]``, only a little more\\n    efficient.  If the expansion has a repeating part, a list of the\\n    repeating terms should be returned as the last element from the\\n    iterator.  This is the format returned by\\n    continued_fraction_periodic.\\n\\n    For quadratic irrationals, returns the largest solution found,\\n    which is generally the one sought, if the fraction is in canonical\\n    form (all terms positive except possibly the first).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_reduce\\n    >>> continued_fraction_reduce([1, 2, 3, 4, 5])\\n    225/157\\n    >>> continued_fraction_reduce([-2, 1, 9, 7, 1, 2])\\n    -256/233\\n    >>> continued_fraction_reduce([2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8]).n(10)\\n    2.718281835\\n    >>> continued_fraction_reduce([1, 4, 2, [3, 1]])\\n    (sqrt(21) + 287)/238\\n    >>> continued_fraction_reduce([[1]])\\n    (1 + sqrt(5))/2\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_reduce(continued_fraction_periodic(8, 5, 13))\\n    (sqrt(13) + 8)/5\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_periodic\\n\\n    '\n    from sympy.solvers import solve\n    period = []\n    x = Dummy('x')\n\n    def untillist(cf):\n        for nxt in cf:\n            if isinstance(nxt, list):\n                period.extend(nxt)\n                yield x\n                break\n            yield nxt\n    a = S.Zero\n    for a in continued_fraction_convergents(untillist(cf)):\n        pass\n    if period:\n        y = Dummy('y')\n        solns = solve(continued_fraction_reduce(period + [y]) - y, y)\n        solns.sort()\n        pure = solns[-1]\n        rv = a.subs(x, pure).radsimp()\n    else:\n        rv = a\n    if rv.is_Add:\n        rv = factor_terms(rv)\n        if rv.is_Mul and rv.args[0] == -1:\n            rv = rv.func(*rv.args)\n    return rv",
            "def continued_fraction_reduce(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Reduce a continued fraction to a rational or quadratic irrational.\\n\\n    Compute the rational or quadratic irrational number from its\\n    terminating or periodic continued fraction expansion.  The\\n    continued fraction expansion (cf) should be supplied as a\\n    terminating iterator supplying the terms of the expansion.  For\\n    terminating continued fractions, this is equivalent to\\n    ``list(continued_fraction_convergents(cf))[-1]``, only a little more\\n    efficient.  If the expansion has a repeating part, a list of the\\n    repeating terms should be returned as the last element from the\\n    iterator.  This is the format returned by\\n    continued_fraction_periodic.\\n\\n    For quadratic irrationals, returns the largest solution found,\\n    which is generally the one sought, if the fraction is in canonical\\n    form (all terms positive except possibly the first).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_reduce\\n    >>> continued_fraction_reduce([1, 2, 3, 4, 5])\\n    225/157\\n    >>> continued_fraction_reduce([-2, 1, 9, 7, 1, 2])\\n    -256/233\\n    >>> continued_fraction_reduce([2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8]).n(10)\\n    2.718281835\\n    >>> continued_fraction_reduce([1, 4, 2, [3, 1]])\\n    (sqrt(21) + 287)/238\\n    >>> continued_fraction_reduce([[1]])\\n    (1 + sqrt(5))/2\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_reduce(continued_fraction_periodic(8, 5, 13))\\n    (sqrt(13) + 8)/5\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_periodic\\n\\n    '\n    from sympy.solvers import solve\n    period = []\n    x = Dummy('x')\n\n    def untillist(cf):\n        for nxt in cf:\n            if isinstance(nxt, list):\n                period.extend(nxt)\n                yield x\n                break\n            yield nxt\n    a = S.Zero\n    for a in continued_fraction_convergents(untillist(cf)):\n        pass\n    if period:\n        y = Dummy('y')\n        solns = solve(continued_fraction_reduce(period + [y]) - y, y)\n        solns.sort()\n        pure = solns[-1]\n        rv = a.subs(x, pure).radsimp()\n    else:\n        rv = a\n    if rv.is_Add:\n        rv = factor_terms(rv)\n        if rv.is_Mul and rv.args[0] == -1:\n            rv = rv.func(*rv.args)\n    return rv",
            "def continued_fraction_reduce(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Reduce a continued fraction to a rational or quadratic irrational.\\n\\n    Compute the rational or quadratic irrational number from its\\n    terminating or periodic continued fraction expansion.  The\\n    continued fraction expansion (cf) should be supplied as a\\n    terminating iterator supplying the terms of the expansion.  For\\n    terminating continued fractions, this is equivalent to\\n    ``list(continued_fraction_convergents(cf))[-1]``, only a little more\\n    efficient.  If the expansion has a repeating part, a list of the\\n    repeating terms should be returned as the last element from the\\n    iterator.  This is the format returned by\\n    continued_fraction_periodic.\\n\\n    For quadratic irrationals, returns the largest solution found,\\n    which is generally the one sought, if the fraction is in canonical\\n    form (all terms positive except possibly the first).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_reduce\\n    >>> continued_fraction_reduce([1, 2, 3, 4, 5])\\n    225/157\\n    >>> continued_fraction_reduce([-2, 1, 9, 7, 1, 2])\\n    -256/233\\n    >>> continued_fraction_reduce([2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8]).n(10)\\n    2.718281835\\n    >>> continued_fraction_reduce([1, 4, 2, [3, 1]])\\n    (sqrt(21) + 287)/238\\n    >>> continued_fraction_reduce([[1]])\\n    (1 + sqrt(5))/2\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_reduce(continued_fraction_periodic(8, 5, 13))\\n    (sqrt(13) + 8)/5\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_periodic\\n\\n    '\n    from sympy.solvers import solve\n    period = []\n    x = Dummy('x')\n\n    def untillist(cf):\n        for nxt in cf:\n            if isinstance(nxt, list):\n                period.extend(nxt)\n                yield x\n                break\n            yield nxt\n    a = S.Zero\n    for a in continued_fraction_convergents(untillist(cf)):\n        pass\n    if period:\n        y = Dummy('y')\n        solns = solve(continued_fraction_reduce(period + [y]) - y, y)\n        solns.sort()\n        pure = solns[-1]\n        rv = a.subs(x, pure).radsimp()\n    else:\n        rv = a\n    if rv.is_Add:\n        rv = factor_terms(rv)\n        if rv.is_Mul and rv.args[0] == -1:\n            rv = rv.func(*rv.args)\n    return rv",
            "def continued_fraction_reduce(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Reduce a continued fraction to a rational or quadratic irrational.\\n\\n    Compute the rational or quadratic irrational number from its\\n    terminating or periodic continued fraction expansion.  The\\n    continued fraction expansion (cf) should be supplied as a\\n    terminating iterator supplying the terms of the expansion.  For\\n    terminating continued fractions, this is equivalent to\\n    ``list(continued_fraction_convergents(cf))[-1]``, only a little more\\n    efficient.  If the expansion has a repeating part, a list of the\\n    repeating terms should be returned as the last element from the\\n    iterator.  This is the format returned by\\n    continued_fraction_periodic.\\n\\n    For quadratic irrationals, returns the largest solution found,\\n    which is generally the one sought, if the fraction is in canonical\\n    form (all terms positive except possibly the first).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_reduce\\n    >>> continued_fraction_reduce([1, 2, 3, 4, 5])\\n    225/157\\n    >>> continued_fraction_reduce([-2, 1, 9, 7, 1, 2])\\n    -256/233\\n    >>> continued_fraction_reduce([2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8]).n(10)\\n    2.718281835\\n    >>> continued_fraction_reduce([1, 4, 2, [3, 1]])\\n    (sqrt(21) + 287)/238\\n    >>> continued_fraction_reduce([[1]])\\n    (1 + sqrt(5))/2\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_reduce(continued_fraction_periodic(8, 5, 13))\\n    (sqrt(13) + 8)/5\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_periodic\\n\\n    '\n    from sympy.solvers import solve\n    period = []\n    x = Dummy('x')\n\n    def untillist(cf):\n        for nxt in cf:\n            if isinstance(nxt, list):\n                period.extend(nxt)\n                yield x\n                break\n            yield nxt\n    a = S.Zero\n    for a in continued_fraction_convergents(untillist(cf)):\n        pass\n    if period:\n        y = Dummy('y')\n        solns = solve(continued_fraction_reduce(period + [y]) - y, y)\n        solns.sort()\n        pure = solns[-1]\n        rv = a.subs(x, pure).radsimp()\n    else:\n        rv = a\n    if rv.is_Add:\n        rv = factor_terms(rv)\n        if rv.is_Mul and rv.args[0] == -1:\n            rv = rv.func(*rv.args)\n    return rv",
            "def continued_fraction_reduce(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Reduce a continued fraction to a rational or quadratic irrational.\\n\\n    Compute the rational or quadratic irrational number from its\\n    terminating or periodic continued fraction expansion.  The\\n    continued fraction expansion (cf) should be supplied as a\\n    terminating iterator supplying the terms of the expansion.  For\\n    terminating continued fractions, this is equivalent to\\n    ``list(continued_fraction_convergents(cf))[-1]``, only a little more\\n    efficient.  If the expansion has a repeating part, a list of the\\n    repeating terms should be returned as the last element from the\\n    iterator.  This is the format returned by\\n    continued_fraction_periodic.\\n\\n    For quadratic irrationals, returns the largest solution found,\\n    which is generally the one sought, if the fraction is in canonical\\n    form (all terms positive except possibly the first).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_reduce\\n    >>> continued_fraction_reduce([1, 2, 3, 4, 5])\\n    225/157\\n    >>> continued_fraction_reduce([-2, 1, 9, 7, 1, 2])\\n    -256/233\\n    >>> continued_fraction_reduce([2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8]).n(10)\\n    2.718281835\\n    >>> continued_fraction_reduce([1, 4, 2, [3, 1]])\\n    (sqrt(21) + 287)/238\\n    >>> continued_fraction_reduce([[1]])\\n    (1 + sqrt(5))/2\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\\n    >>> continued_fraction_reduce(continued_fraction_periodic(8, 5, 13))\\n    (sqrt(13) + 8)/5\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_periodic\\n\\n    '\n    from sympy.solvers import solve\n    period = []\n    x = Dummy('x')\n\n    def untillist(cf):\n        for nxt in cf:\n            if isinstance(nxt, list):\n                period.extend(nxt)\n                yield x\n                break\n            yield nxt\n    a = S.Zero\n    for a in continued_fraction_convergents(untillist(cf)):\n        pass\n    if period:\n        y = Dummy('y')\n        solns = solve(continued_fraction_reduce(period + [y]) - y, y)\n        solns.sort()\n        pure = solns[-1]\n        rv = a.subs(x, pure).radsimp()\n    else:\n        rv = a\n    if rv.is_Add:\n        rv = factor_terms(rv)\n        if rv.is_Mul and rv.args[0] == -1:\n            rv = rv.func(*rv.args)\n    return rv"
        ]
    },
    {
        "func_name": "continued_fraction_iterator",
        "original": "def continued_fraction_iterator(x):\n    \"\"\"\n    Return continued fraction expansion of x as iterator.\n\n    Examples\n    ========\n\n    >>> from sympy import Rational, pi\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_iterator\n\n    >>> list(continued_fraction_iterator(Rational(3, 8)))\n    [0, 2, 1, 2]\n    >>> list(continued_fraction_iterator(Rational(-3, 8)))\n    [-1, 1, 1, 1, 2]\n\n    >>> for i, v in enumerate(continued_fraction_iterator(pi)):\n    ...     if i > 7:\n    ...         break\n    ...     print(v)\n    3\n    7\n    15\n    1\n    292\n    1\n    1\n    1\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Continued_fraction\n\n    \"\"\"\n    from sympy.functions import floor\n    while True:\n        i = floor(x)\n        yield i\n        x -= i\n        if not x:\n            break\n        x = 1 / x",
        "mutated": [
            "def continued_fraction_iterator(x):\n    if False:\n        i = 10\n    '\\n    Return continued fraction expansion of x as iterator.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational, pi\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_iterator\\n\\n    >>> list(continued_fraction_iterator(Rational(3, 8)))\\n    [0, 2, 1, 2]\\n    >>> list(continued_fraction_iterator(Rational(-3, 8)))\\n    [-1, 1, 1, 1, 2]\\n\\n    >>> for i, v in enumerate(continued_fraction_iterator(pi)):\\n    ...     if i > 7:\\n    ...         break\\n    ...     print(v)\\n    3\\n    7\\n    15\\n    1\\n    292\\n    1\\n    1\\n    1\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Continued_fraction\\n\\n    '\n    from sympy.functions import floor\n    while True:\n        i = floor(x)\n        yield i\n        x -= i\n        if not x:\n            break\n        x = 1 / x",
            "def continued_fraction_iterator(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return continued fraction expansion of x as iterator.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational, pi\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_iterator\\n\\n    >>> list(continued_fraction_iterator(Rational(3, 8)))\\n    [0, 2, 1, 2]\\n    >>> list(continued_fraction_iterator(Rational(-3, 8)))\\n    [-1, 1, 1, 1, 2]\\n\\n    >>> for i, v in enumerate(continued_fraction_iterator(pi)):\\n    ...     if i > 7:\\n    ...         break\\n    ...     print(v)\\n    3\\n    7\\n    15\\n    1\\n    292\\n    1\\n    1\\n    1\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Continued_fraction\\n\\n    '\n    from sympy.functions import floor\n    while True:\n        i = floor(x)\n        yield i\n        x -= i\n        if not x:\n            break\n        x = 1 / x",
            "def continued_fraction_iterator(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return continued fraction expansion of x as iterator.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational, pi\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_iterator\\n\\n    >>> list(continued_fraction_iterator(Rational(3, 8)))\\n    [0, 2, 1, 2]\\n    >>> list(continued_fraction_iterator(Rational(-3, 8)))\\n    [-1, 1, 1, 1, 2]\\n\\n    >>> for i, v in enumerate(continued_fraction_iterator(pi)):\\n    ...     if i > 7:\\n    ...         break\\n    ...     print(v)\\n    3\\n    7\\n    15\\n    1\\n    292\\n    1\\n    1\\n    1\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Continued_fraction\\n\\n    '\n    from sympy.functions import floor\n    while True:\n        i = floor(x)\n        yield i\n        x -= i\n        if not x:\n            break\n        x = 1 / x",
            "def continued_fraction_iterator(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return continued fraction expansion of x as iterator.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational, pi\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_iterator\\n\\n    >>> list(continued_fraction_iterator(Rational(3, 8)))\\n    [0, 2, 1, 2]\\n    >>> list(continued_fraction_iterator(Rational(-3, 8)))\\n    [-1, 1, 1, 1, 2]\\n\\n    >>> for i, v in enumerate(continued_fraction_iterator(pi)):\\n    ...     if i > 7:\\n    ...         break\\n    ...     print(v)\\n    3\\n    7\\n    15\\n    1\\n    292\\n    1\\n    1\\n    1\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Continued_fraction\\n\\n    '\n    from sympy.functions import floor\n    while True:\n        i = floor(x)\n        yield i\n        x -= i\n        if not x:\n            break\n        x = 1 / x",
            "def continued_fraction_iterator(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return continued fraction expansion of x as iterator.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Rational, pi\\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_iterator\\n\\n    >>> list(continued_fraction_iterator(Rational(3, 8)))\\n    [0, 2, 1, 2]\\n    >>> list(continued_fraction_iterator(Rational(-3, 8)))\\n    [-1, 1, 1, 1, 2]\\n\\n    >>> for i, v in enumerate(continued_fraction_iterator(pi)):\\n    ...     if i > 7:\\n    ...         break\\n    ...     print(v)\\n    3\\n    7\\n    15\\n    1\\n    292\\n    1\\n    1\\n    1\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Continued_fraction\\n\\n    '\n    from sympy.functions import floor\n    while True:\n        i = floor(x)\n        yield i\n        x -= i\n        if not x:\n            break\n        x = 1 / x"
        ]
    },
    {
        "func_name": "continued_fraction_convergents",
        "original": "def continued_fraction_convergents(cf):\n    \"\"\"\n    Return an iterator over the convergents of a continued fraction (cf).\n\n    The parameter should be in either of the following to forms:\n    - A list of partial quotients, possibly with the last element being a list\n    of repeating partial quotients, such as might be returned by\n    continued_fraction and continued_fraction_periodic.\n    - An iterable returning successive partial quotients of the continued\n    fraction, such as might be returned by continued_fraction_iterator.\n\n    In computing the convergents, the continued fraction need not be strictly\n    in canonical form (all integers, all but the first positive).\n    Rational and negative elements may be present in the expansion.\n\n    Examples\n    ========\n\n    >>> from sympy.core import pi\n    >>> from sympy import S\n    >>> from sympy.ntheory.continued_fraction import             continued_fraction_convergents, continued_fraction_iterator\n\n    >>> list(continued_fraction_convergents([0, 2, 1, 2]))\n    [0, 1/2, 1/3, 3/8]\n\n    >>> list(continued_fraction_convergents([1, S('1/2'), -7, S('1/4')]))\n    [1, 3, 19/5, 7]\n\n    >>> it = continued_fraction_convergents(continued_fraction_iterator(pi))\n    >>> for n in range(7):\n    ...     print(next(it))\n    3\n    22/7\n    333/106\n    355/113\n    103993/33102\n    104348/33215\n    208341/66317\n\n    >>> it = continued_fraction_convergents([1, [1, 2]])  # sqrt(3)\n    >>> for n in range(7):\n    ...     print(next(it))\n    1\n    2\n    5/3\n    7/4\n    19/11\n    26/15\n    71/41\n\n    See Also\n    ========\n\n    continued_fraction_iterator, continued_fraction, continued_fraction_periodic\n\n    \"\"\"\n    if isinstance(cf, list) and isinstance(cf[-1], list):\n        cf = itertools.chain(cf[:-1], itertools.cycle(cf[-1]))\n    (p_2, q_2) = (S.Zero, S.One)\n    (p_1, q_1) = (S.One, S.Zero)\n    for a in cf:\n        (p, q) = (a * p_1 + p_2, a * q_1 + q_2)\n        (p_2, q_2) = (p_1, q_1)\n        (p_1, q_1) = (p, q)\n        yield (p / q)",
        "mutated": [
            "def continued_fraction_convergents(cf):\n    if False:\n        i = 10\n    \"\\n    Return an iterator over the convergents of a continued fraction (cf).\\n\\n    The parameter should be in either of the following to forms:\\n    - A list of partial quotients, possibly with the last element being a list\\n    of repeating partial quotients, such as might be returned by\\n    continued_fraction and continued_fraction_periodic.\\n    - An iterable returning successive partial quotients of the continued\\n    fraction, such as might be returned by continued_fraction_iterator.\\n\\n    In computing the convergents, the continued fraction need not be strictly\\n    in canonical form (all integers, all but the first positive).\\n    Rational and negative elements may be present in the expansion.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.core import pi\\n    >>> from sympy import S\\n    >>> from sympy.ntheory.continued_fraction import             continued_fraction_convergents, continued_fraction_iterator\\n\\n    >>> list(continued_fraction_convergents([0, 2, 1, 2]))\\n    [0, 1/2, 1/3, 3/8]\\n\\n    >>> list(continued_fraction_convergents([1, S('1/2'), -7, S('1/4')]))\\n    [1, 3, 19/5, 7]\\n\\n    >>> it = continued_fraction_convergents(continued_fraction_iterator(pi))\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    3\\n    22/7\\n    333/106\\n    355/113\\n    103993/33102\\n    104348/33215\\n    208341/66317\\n\\n    >>> it = continued_fraction_convergents([1, [1, 2]])  # sqrt(3)\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    1\\n    2\\n    5/3\\n    7/4\\n    19/11\\n    26/15\\n    71/41\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction, continued_fraction_periodic\\n\\n    \"\n    if isinstance(cf, list) and isinstance(cf[-1], list):\n        cf = itertools.chain(cf[:-1], itertools.cycle(cf[-1]))\n    (p_2, q_2) = (S.Zero, S.One)\n    (p_1, q_1) = (S.One, S.Zero)\n    for a in cf:\n        (p, q) = (a * p_1 + p_2, a * q_1 + q_2)\n        (p_2, q_2) = (p_1, q_1)\n        (p_1, q_1) = (p, q)\n        yield (p / q)",
            "def continued_fraction_convergents(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Return an iterator over the convergents of a continued fraction (cf).\\n\\n    The parameter should be in either of the following to forms:\\n    - A list of partial quotients, possibly with the last element being a list\\n    of repeating partial quotients, such as might be returned by\\n    continued_fraction and continued_fraction_periodic.\\n    - An iterable returning successive partial quotients of the continued\\n    fraction, such as might be returned by continued_fraction_iterator.\\n\\n    In computing the convergents, the continued fraction need not be strictly\\n    in canonical form (all integers, all but the first positive).\\n    Rational and negative elements may be present in the expansion.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.core import pi\\n    >>> from sympy import S\\n    >>> from sympy.ntheory.continued_fraction import             continued_fraction_convergents, continued_fraction_iterator\\n\\n    >>> list(continued_fraction_convergents([0, 2, 1, 2]))\\n    [0, 1/2, 1/3, 3/8]\\n\\n    >>> list(continued_fraction_convergents([1, S('1/2'), -7, S('1/4')]))\\n    [1, 3, 19/5, 7]\\n\\n    >>> it = continued_fraction_convergents(continued_fraction_iterator(pi))\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    3\\n    22/7\\n    333/106\\n    355/113\\n    103993/33102\\n    104348/33215\\n    208341/66317\\n\\n    >>> it = continued_fraction_convergents([1, [1, 2]])  # sqrt(3)\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    1\\n    2\\n    5/3\\n    7/4\\n    19/11\\n    26/15\\n    71/41\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction, continued_fraction_periodic\\n\\n    \"\n    if isinstance(cf, list) and isinstance(cf[-1], list):\n        cf = itertools.chain(cf[:-1], itertools.cycle(cf[-1]))\n    (p_2, q_2) = (S.Zero, S.One)\n    (p_1, q_1) = (S.One, S.Zero)\n    for a in cf:\n        (p, q) = (a * p_1 + p_2, a * q_1 + q_2)\n        (p_2, q_2) = (p_1, q_1)\n        (p_1, q_1) = (p, q)\n        yield (p / q)",
            "def continued_fraction_convergents(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Return an iterator over the convergents of a continued fraction (cf).\\n\\n    The parameter should be in either of the following to forms:\\n    - A list of partial quotients, possibly with the last element being a list\\n    of repeating partial quotients, such as might be returned by\\n    continued_fraction and continued_fraction_periodic.\\n    - An iterable returning successive partial quotients of the continued\\n    fraction, such as might be returned by continued_fraction_iterator.\\n\\n    In computing the convergents, the continued fraction need not be strictly\\n    in canonical form (all integers, all but the first positive).\\n    Rational and negative elements may be present in the expansion.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.core import pi\\n    >>> from sympy import S\\n    >>> from sympy.ntheory.continued_fraction import             continued_fraction_convergents, continued_fraction_iterator\\n\\n    >>> list(continued_fraction_convergents([0, 2, 1, 2]))\\n    [0, 1/2, 1/3, 3/8]\\n\\n    >>> list(continued_fraction_convergents([1, S('1/2'), -7, S('1/4')]))\\n    [1, 3, 19/5, 7]\\n\\n    >>> it = continued_fraction_convergents(continued_fraction_iterator(pi))\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    3\\n    22/7\\n    333/106\\n    355/113\\n    103993/33102\\n    104348/33215\\n    208341/66317\\n\\n    >>> it = continued_fraction_convergents([1, [1, 2]])  # sqrt(3)\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    1\\n    2\\n    5/3\\n    7/4\\n    19/11\\n    26/15\\n    71/41\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction, continued_fraction_periodic\\n\\n    \"\n    if isinstance(cf, list) and isinstance(cf[-1], list):\n        cf = itertools.chain(cf[:-1], itertools.cycle(cf[-1]))\n    (p_2, q_2) = (S.Zero, S.One)\n    (p_1, q_1) = (S.One, S.Zero)\n    for a in cf:\n        (p, q) = (a * p_1 + p_2, a * q_1 + q_2)\n        (p_2, q_2) = (p_1, q_1)\n        (p_1, q_1) = (p, q)\n        yield (p / q)",
            "def continued_fraction_convergents(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Return an iterator over the convergents of a continued fraction (cf).\\n\\n    The parameter should be in either of the following to forms:\\n    - A list of partial quotients, possibly with the last element being a list\\n    of repeating partial quotients, such as might be returned by\\n    continued_fraction and continued_fraction_periodic.\\n    - An iterable returning successive partial quotients of the continued\\n    fraction, such as might be returned by continued_fraction_iterator.\\n\\n    In computing the convergents, the continued fraction need not be strictly\\n    in canonical form (all integers, all but the first positive).\\n    Rational and negative elements may be present in the expansion.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.core import pi\\n    >>> from sympy import S\\n    >>> from sympy.ntheory.continued_fraction import             continued_fraction_convergents, continued_fraction_iterator\\n\\n    >>> list(continued_fraction_convergents([0, 2, 1, 2]))\\n    [0, 1/2, 1/3, 3/8]\\n\\n    >>> list(continued_fraction_convergents([1, S('1/2'), -7, S('1/4')]))\\n    [1, 3, 19/5, 7]\\n\\n    >>> it = continued_fraction_convergents(continued_fraction_iterator(pi))\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    3\\n    22/7\\n    333/106\\n    355/113\\n    103993/33102\\n    104348/33215\\n    208341/66317\\n\\n    >>> it = continued_fraction_convergents([1, [1, 2]])  # sqrt(3)\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    1\\n    2\\n    5/3\\n    7/4\\n    19/11\\n    26/15\\n    71/41\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction, continued_fraction_periodic\\n\\n    \"\n    if isinstance(cf, list) and isinstance(cf[-1], list):\n        cf = itertools.chain(cf[:-1], itertools.cycle(cf[-1]))\n    (p_2, q_2) = (S.Zero, S.One)\n    (p_1, q_1) = (S.One, S.Zero)\n    for a in cf:\n        (p, q) = (a * p_1 + p_2, a * q_1 + q_2)\n        (p_2, q_2) = (p_1, q_1)\n        (p_1, q_1) = (p, q)\n        yield (p / q)",
            "def continued_fraction_convergents(cf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Return an iterator over the convergents of a continued fraction (cf).\\n\\n    The parameter should be in either of the following to forms:\\n    - A list of partial quotients, possibly with the last element being a list\\n    of repeating partial quotients, such as might be returned by\\n    continued_fraction and continued_fraction_periodic.\\n    - An iterable returning successive partial quotients of the continued\\n    fraction, such as might be returned by continued_fraction_iterator.\\n\\n    In computing the convergents, the continued fraction need not be strictly\\n    in canonical form (all integers, all but the first positive).\\n    Rational and negative elements may be present in the expansion.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.core import pi\\n    >>> from sympy import S\\n    >>> from sympy.ntheory.continued_fraction import             continued_fraction_convergents, continued_fraction_iterator\\n\\n    >>> list(continued_fraction_convergents([0, 2, 1, 2]))\\n    [0, 1/2, 1/3, 3/8]\\n\\n    >>> list(continued_fraction_convergents([1, S('1/2'), -7, S('1/4')]))\\n    [1, 3, 19/5, 7]\\n\\n    >>> it = continued_fraction_convergents(continued_fraction_iterator(pi))\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    3\\n    22/7\\n    333/106\\n    355/113\\n    103993/33102\\n    104348/33215\\n    208341/66317\\n\\n    >>> it = continued_fraction_convergents([1, [1, 2]])  # sqrt(3)\\n    >>> for n in range(7):\\n    ...     print(next(it))\\n    1\\n    2\\n    5/3\\n    7/4\\n    19/11\\n    26/15\\n    71/41\\n\\n    See Also\\n    ========\\n\\n    continued_fraction_iterator, continued_fraction, continued_fraction_periodic\\n\\n    \"\n    if isinstance(cf, list) and isinstance(cf[-1], list):\n        cf = itertools.chain(cf[:-1], itertools.cycle(cf[-1]))\n    (p_2, q_2) = (S.Zero, S.One)\n    (p_1, q_1) = (S.One, S.Zero)\n    for a in cf:\n        (p, q) = (a * p_1 + p_2, a * q_1 + q_2)\n        (p_2, q_2) = (p_1, q_1)\n        (p_1, q_1) = (p, q)\n        yield (p / q)"
        ]
    }
]