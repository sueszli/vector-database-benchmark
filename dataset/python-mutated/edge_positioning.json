[
    {
        "func_name": "__init__",
        "original": "def __init__(self, config: Config, exchange, strategy) -> None:\n    self.config = config\n    self.exchange = exchange\n    self.strategy: IStrategy = strategy\n    self.edge_config = self.config.get('edge', {})\n    self._cached_pairs: Dict[str, Any] = {}\n    self._final_pairs: list = []\n    if self.config['max_open_trades'] != float('inf'):\n        logger.critical('max_open_trades should be -1 in config !')\n    if self.config['stake_amount'] != UNLIMITED_STAKE_AMOUNT:\n        raise OperationalException('Edge works only with unlimited stake amount')\n    self._capital_ratio: float = self.config['tradable_balance_ratio']\n    self._allowed_risk: float = self.edge_config.get('allowed_risk')\n    self._since_number_of_days: int = self.edge_config.get('calculate_since_number_of_days', 14)\n    self._last_updated: int = 0\n    self._refresh_pairs = True\n    self._stoploss_range_min = float(self.edge_config.get('stoploss_range_min', -0.01))\n    self._stoploss_range_max = float(self.edge_config.get('stoploss_range_max', -0.05))\n    self._stoploss_range_step = float(self.edge_config.get('stoploss_range_step', -0.001))\n    self._stoploss_range = np.arange(self._stoploss_range_min, self._stoploss_range_max, self._stoploss_range_step)\n    self._timerange: TimeRange = TimeRange.parse_timerange(f\"{(dt_now() - timedelta(days=self._since_number_of_days)).strftime('%Y%m%d')}-\")\n    if config.get('fee'):\n        self.fee = config['fee']\n    else:\n        try:\n            self.fee = self.exchange.get_fee(symbol=expand_pairlist(self.config['exchange']['pair_whitelist'], list(self.exchange.markets))[0])\n        except IndexError:\n            self.fee = None",
        "mutated": [
            "def __init__(self, config: Config, exchange, strategy) -> None:\n    if False:\n        i = 10\n    self.config = config\n    self.exchange = exchange\n    self.strategy: IStrategy = strategy\n    self.edge_config = self.config.get('edge', {})\n    self._cached_pairs: Dict[str, Any] = {}\n    self._final_pairs: list = []\n    if self.config['max_open_trades'] != float('inf'):\n        logger.critical('max_open_trades should be -1 in config !')\n    if self.config['stake_amount'] != UNLIMITED_STAKE_AMOUNT:\n        raise OperationalException('Edge works only with unlimited stake amount')\n    self._capital_ratio: float = self.config['tradable_balance_ratio']\n    self._allowed_risk: float = self.edge_config.get('allowed_risk')\n    self._since_number_of_days: int = self.edge_config.get('calculate_since_number_of_days', 14)\n    self._last_updated: int = 0\n    self._refresh_pairs = True\n    self._stoploss_range_min = float(self.edge_config.get('stoploss_range_min', -0.01))\n    self._stoploss_range_max = float(self.edge_config.get('stoploss_range_max', -0.05))\n    self._stoploss_range_step = float(self.edge_config.get('stoploss_range_step', -0.001))\n    self._stoploss_range = np.arange(self._stoploss_range_min, self._stoploss_range_max, self._stoploss_range_step)\n    self._timerange: TimeRange = TimeRange.parse_timerange(f\"{(dt_now() - timedelta(days=self._since_number_of_days)).strftime('%Y%m%d')}-\")\n    if config.get('fee'):\n        self.fee = config['fee']\n    else:\n        try:\n            self.fee = self.exchange.get_fee(symbol=expand_pairlist(self.config['exchange']['pair_whitelist'], list(self.exchange.markets))[0])\n        except IndexError:\n            self.fee = None",
            "def __init__(self, config: Config, exchange, strategy) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.config = config\n    self.exchange = exchange\n    self.strategy: IStrategy = strategy\n    self.edge_config = self.config.get('edge', {})\n    self._cached_pairs: Dict[str, Any] = {}\n    self._final_pairs: list = []\n    if self.config['max_open_trades'] != float('inf'):\n        logger.critical('max_open_trades should be -1 in config !')\n    if self.config['stake_amount'] != UNLIMITED_STAKE_AMOUNT:\n        raise OperationalException('Edge works only with unlimited stake amount')\n    self._capital_ratio: float = self.config['tradable_balance_ratio']\n    self._allowed_risk: float = self.edge_config.get('allowed_risk')\n    self._since_number_of_days: int = self.edge_config.get('calculate_since_number_of_days', 14)\n    self._last_updated: int = 0\n    self._refresh_pairs = True\n    self._stoploss_range_min = float(self.edge_config.get('stoploss_range_min', -0.01))\n    self._stoploss_range_max = float(self.edge_config.get('stoploss_range_max', -0.05))\n    self._stoploss_range_step = float(self.edge_config.get('stoploss_range_step', -0.001))\n    self._stoploss_range = np.arange(self._stoploss_range_min, self._stoploss_range_max, self._stoploss_range_step)\n    self._timerange: TimeRange = TimeRange.parse_timerange(f\"{(dt_now() - timedelta(days=self._since_number_of_days)).strftime('%Y%m%d')}-\")\n    if config.get('fee'):\n        self.fee = config['fee']\n    else:\n        try:\n            self.fee = self.exchange.get_fee(symbol=expand_pairlist(self.config['exchange']['pair_whitelist'], list(self.exchange.markets))[0])\n        except IndexError:\n            self.fee = None",
            "def __init__(self, config: Config, exchange, strategy) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.config = config\n    self.exchange = exchange\n    self.strategy: IStrategy = strategy\n    self.edge_config = self.config.get('edge', {})\n    self._cached_pairs: Dict[str, Any] = {}\n    self._final_pairs: list = []\n    if self.config['max_open_trades'] != float('inf'):\n        logger.critical('max_open_trades should be -1 in config !')\n    if self.config['stake_amount'] != UNLIMITED_STAKE_AMOUNT:\n        raise OperationalException('Edge works only with unlimited stake amount')\n    self._capital_ratio: float = self.config['tradable_balance_ratio']\n    self._allowed_risk: float = self.edge_config.get('allowed_risk')\n    self._since_number_of_days: int = self.edge_config.get('calculate_since_number_of_days', 14)\n    self._last_updated: int = 0\n    self._refresh_pairs = True\n    self._stoploss_range_min = float(self.edge_config.get('stoploss_range_min', -0.01))\n    self._stoploss_range_max = float(self.edge_config.get('stoploss_range_max', -0.05))\n    self._stoploss_range_step = float(self.edge_config.get('stoploss_range_step', -0.001))\n    self._stoploss_range = np.arange(self._stoploss_range_min, self._stoploss_range_max, self._stoploss_range_step)\n    self._timerange: TimeRange = TimeRange.parse_timerange(f\"{(dt_now() - timedelta(days=self._since_number_of_days)).strftime('%Y%m%d')}-\")\n    if config.get('fee'):\n        self.fee = config['fee']\n    else:\n        try:\n            self.fee = self.exchange.get_fee(symbol=expand_pairlist(self.config['exchange']['pair_whitelist'], list(self.exchange.markets))[0])\n        except IndexError:\n            self.fee = None",
            "def __init__(self, config: Config, exchange, strategy) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.config = config\n    self.exchange = exchange\n    self.strategy: IStrategy = strategy\n    self.edge_config = self.config.get('edge', {})\n    self._cached_pairs: Dict[str, Any] = {}\n    self._final_pairs: list = []\n    if self.config['max_open_trades'] != float('inf'):\n        logger.critical('max_open_trades should be -1 in config !')\n    if self.config['stake_amount'] != UNLIMITED_STAKE_AMOUNT:\n        raise OperationalException('Edge works only with unlimited stake amount')\n    self._capital_ratio: float = self.config['tradable_balance_ratio']\n    self._allowed_risk: float = self.edge_config.get('allowed_risk')\n    self._since_number_of_days: int = self.edge_config.get('calculate_since_number_of_days', 14)\n    self._last_updated: int = 0\n    self._refresh_pairs = True\n    self._stoploss_range_min = float(self.edge_config.get('stoploss_range_min', -0.01))\n    self._stoploss_range_max = float(self.edge_config.get('stoploss_range_max', -0.05))\n    self._stoploss_range_step = float(self.edge_config.get('stoploss_range_step', -0.001))\n    self._stoploss_range = np.arange(self._stoploss_range_min, self._stoploss_range_max, self._stoploss_range_step)\n    self._timerange: TimeRange = TimeRange.parse_timerange(f\"{(dt_now() - timedelta(days=self._since_number_of_days)).strftime('%Y%m%d')}-\")\n    if config.get('fee'):\n        self.fee = config['fee']\n    else:\n        try:\n            self.fee = self.exchange.get_fee(symbol=expand_pairlist(self.config['exchange']['pair_whitelist'], list(self.exchange.markets))[0])\n        except IndexError:\n            self.fee = None",
            "def __init__(self, config: Config, exchange, strategy) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.config = config\n    self.exchange = exchange\n    self.strategy: IStrategy = strategy\n    self.edge_config = self.config.get('edge', {})\n    self._cached_pairs: Dict[str, Any] = {}\n    self._final_pairs: list = []\n    if self.config['max_open_trades'] != float('inf'):\n        logger.critical('max_open_trades should be -1 in config !')\n    if self.config['stake_amount'] != UNLIMITED_STAKE_AMOUNT:\n        raise OperationalException('Edge works only with unlimited stake amount')\n    self._capital_ratio: float = self.config['tradable_balance_ratio']\n    self._allowed_risk: float = self.edge_config.get('allowed_risk')\n    self._since_number_of_days: int = self.edge_config.get('calculate_since_number_of_days', 14)\n    self._last_updated: int = 0\n    self._refresh_pairs = True\n    self._stoploss_range_min = float(self.edge_config.get('stoploss_range_min', -0.01))\n    self._stoploss_range_max = float(self.edge_config.get('stoploss_range_max', -0.05))\n    self._stoploss_range_step = float(self.edge_config.get('stoploss_range_step', -0.001))\n    self._stoploss_range = np.arange(self._stoploss_range_min, self._stoploss_range_max, self._stoploss_range_step)\n    self._timerange: TimeRange = TimeRange.parse_timerange(f\"{(dt_now() - timedelta(days=self._since_number_of_days)).strftime('%Y%m%d')}-\")\n    if config.get('fee'):\n        self.fee = config['fee']\n    else:\n        try:\n            self.fee = self.exchange.get_fee(symbol=expand_pairlist(self.config['exchange']['pair_whitelist'], list(self.exchange.markets))[0])\n        except IndexError:\n            self.fee = None"
        ]
    },
    {
        "func_name": "calculate",
        "original": "def calculate(self, pairs: List[str]) -> bool:\n    if self.fee is None and pairs:\n        self.fee = self.exchange.get_fee(pairs[0])\n    heartbeat = self.edge_config.get('process_throttle_secs')\n    if self._last_updated > 0 and self._last_updated + heartbeat > int(dt_now().timestamp()):\n        return False\n    data: Dict[str, Any] = {}\n    logger.info('Using stake_currency: %s ...', self.config['stake_currency'])\n    logger.info('Using local backtesting data (using whitelist in given config) ...')\n    if self._refresh_pairs:\n        timerange_startup = deepcopy(self._timerange)\n        timerange_startup.subtract_start(timeframe_to_seconds(self.strategy.timeframe) * self.strategy.startup_candle_count)\n        refresh_data(datadir=self.config['datadir'], pairs=pairs, exchange=self.exchange, timeframe=self.strategy.timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n        res = defaultdict(list)\n        for (pair, timeframe, _) in self.strategy.gather_informative_pairs():\n            res[timeframe].append(pair)\n        for (timeframe, inf_pairs) in res.items():\n            timerange_startup = deepcopy(self._timerange)\n            timerange_startup.subtract_start(timeframe_to_seconds(timeframe) * self.strategy.startup_candle_count)\n            refresh_data(datadir=self.config['datadir'], pairs=inf_pairs, exchange=self.exchange, timeframe=timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    data = load_data(datadir=self.config['datadir'], pairs=pairs, timeframe=self.strategy.timeframe, timerange=self._timerange, startup_candles=self.strategy.startup_candle_count, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    if not data:\n        self._cached_pairs = {}\n        logger.critical('No data found. Edge is stopped ...')\n        return False\n    prior_rm = self.config['runmode']\n    self.config['runmode'] = RunMode.EDGE\n    preprocessed = self.strategy.advise_all_indicators(data)\n    self.config['runmode'] = prior_rm\n    (min_date, max_date) = get_timerange(preprocessed)\n    logger.info(f'Measuring data from {min_date.strftime(DATETIME_PRINT_FORMAT)} up to {max_date.strftime(DATETIME_PRINT_FORMAT)} ({(max_date - min_date).days} days)..')\n    headers = ['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long']\n    trades: list = []\n    for (pair, pair_data) in preprocessed.items():\n        pair_data = pair_data.sort_values(by=['date'])\n        pair_data = pair_data.reset_index(drop=True)\n        df_analyzed = self.strategy.ft_advise_signals(pair_data, {'pair': pair})[headers].copy()\n        trades += self._find_trades_for_stoploss_range(df_analyzed, pair, self._stoploss_range)\n    if len(trades) == 0:\n        logger.info('No trades found.')\n        return False\n    trades_df = self._fill_calculable_fields(DataFrame(trades))\n    self._cached_pairs = self._process_expectancy(trades_df)\n    self._last_updated = int(dt_now().timestamp())\n    return True",
        "mutated": [
            "def calculate(self, pairs: List[str]) -> bool:\n    if False:\n        i = 10\n    if self.fee is None and pairs:\n        self.fee = self.exchange.get_fee(pairs[0])\n    heartbeat = self.edge_config.get('process_throttle_secs')\n    if self._last_updated > 0 and self._last_updated + heartbeat > int(dt_now().timestamp()):\n        return False\n    data: Dict[str, Any] = {}\n    logger.info('Using stake_currency: %s ...', self.config['stake_currency'])\n    logger.info('Using local backtesting data (using whitelist in given config) ...')\n    if self._refresh_pairs:\n        timerange_startup = deepcopy(self._timerange)\n        timerange_startup.subtract_start(timeframe_to_seconds(self.strategy.timeframe) * self.strategy.startup_candle_count)\n        refresh_data(datadir=self.config['datadir'], pairs=pairs, exchange=self.exchange, timeframe=self.strategy.timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n        res = defaultdict(list)\n        for (pair, timeframe, _) in self.strategy.gather_informative_pairs():\n            res[timeframe].append(pair)\n        for (timeframe, inf_pairs) in res.items():\n            timerange_startup = deepcopy(self._timerange)\n            timerange_startup.subtract_start(timeframe_to_seconds(timeframe) * self.strategy.startup_candle_count)\n            refresh_data(datadir=self.config['datadir'], pairs=inf_pairs, exchange=self.exchange, timeframe=timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    data = load_data(datadir=self.config['datadir'], pairs=pairs, timeframe=self.strategy.timeframe, timerange=self._timerange, startup_candles=self.strategy.startup_candle_count, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    if not data:\n        self._cached_pairs = {}\n        logger.critical('No data found. Edge is stopped ...')\n        return False\n    prior_rm = self.config['runmode']\n    self.config['runmode'] = RunMode.EDGE\n    preprocessed = self.strategy.advise_all_indicators(data)\n    self.config['runmode'] = prior_rm\n    (min_date, max_date) = get_timerange(preprocessed)\n    logger.info(f'Measuring data from {min_date.strftime(DATETIME_PRINT_FORMAT)} up to {max_date.strftime(DATETIME_PRINT_FORMAT)} ({(max_date - min_date).days} days)..')\n    headers = ['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long']\n    trades: list = []\n    for (pair, pair_data) in preprocessed.items():\n        pair_data = pair_data.sort_values(by=['date'])\n        pair_data = pair_data.reset_index(drop=True)\n        df_analyzed = self.strategy.ft_advise_signals(pair_data, {'pair': pair})[headers].copy()\n        trades += self._find_trades_for_stoploss_range(df_analyzed, pair, self._stoploss_range)\n    if len(trades) == 0:\n        logger.info('No trades found.')\n        return False\n    trades_df = self._fill_calculable_fields(DataFrame(trades))\n    self._cached_pairs = self._process_expectancy(trades_df)\n    self._last_updated = int(dt_now().timestamp())\n    return True",
            "def calculate(self, pairs: List[str]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.fee is None and pairs:\n        self.fee = self.exchange.get_fee(pairs[0])\n    heartbeat = self.edge_config.get('process_throttle_secs')\n    if self._last_updated > 0 and self._last_updated + heartbeat > int(dt_now().timestamp()):\n        return False\n    data: Dict[str, Any] = {}\n    logger.info('Using stake_currency: %s ...', self.config['stake_currency'])\n    logger.info('Using local backtesting data (using whitelist in given config) ...')\n    if self._refresh_pairs:\n        timerange_startup = deepcopy(self._timerange)\n        timerange_startup.subtract_start(timeframe_to_seconds(self.strategy.timeframe) * self.strategy.startup_candle_count)\n        refresh_data(datadir=self.config['datadir'], pairs=pairs, exchange=self.exchange, timeframe=self.strategy.timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n        res = defaultdict(list)\n        for (pair, timeframe, _) in self.strategy.gather_informative_pairs():\n            res[timeframe].append(pair)\n        for (timeframe, inf_pairs) in res.items():\n            timerange_startup = deepcopy(self._timerange)\n            timerange_startup.subtract_start(timeframe_to_seconds(timeframe) * self.strategy.startup_candle_count)\n            refresh_data(datadir=self.config['datadir'], pairs=inf_pairs, exchange=self.exchange, timeframe=timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    data = load_data(datadir=self.config['datadir'], pairs=pairs, timeframe=self.strategy.timeframe, timerange=self._timerange, startup_candles=self.strategy.startup_candle_count, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    if not data:\n        self._cached_pairs = {}\n        logger.critical('No data found. Edge is stopped ...')\n        return False\n    prior_rm = self.config['runmode']\n    self.config['runmode'] = RunMode.EDGE\n    preprocessed = self.strategy.advise_all_indicators(data)\n    self.config['runmode'] = prior_rm\n    (min_date, max_date) = get_timerange(preprocessed)\n    logger.info(f'Measuring data from {min_date.strftime(DATETIME_PRINT_FORMAT)} up to {max_date.strftime(DATETIME_PRINT_FORMAT)} ({(max_date - min_date).days} days)..')\n    headers = ['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long']\n    trades: list = []\n    for (pair, pair_data) in preprocessed.items():\n        pair_data = pair_data.sort_values(by=['date'])\n        pair_data = pair_data.reset_index(drop=True)\n        df_analyzed = self.strategy.ft_advise_signals(pair_data, {'pair': pair})[headers].copy()\n        trades += self._find_trades_for_stoploss_range(df_analyzed, pair, self._stoploss_range)\n    if len(trades) == 0:\n        logger.info('No trades found.')\n        return False\n    trades_df = self._fill_calculable_fields(DataFrame(trades))\n    self._cached_pairs = self._process_expectancy(trades_df)\n    self._last_updated = int(dt_now().timestamp())\n    return True",
            "def calculate(self, pairs: List[str]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.fee is None and pairs:\n        self.fee = self.exchange.get_fee(pairs[0])\n    heartbeat = self.edge_config.get('process_throttle_secs')\n    if self._last_updated > 0 and self._last_updated + heartbeat > int(dt_now().timestamp()):\n        return False\n    data: Dict[str, Any] = {}\n    logger.info('Using stake_currency: %s ...', self.config['stake_currency'])\n    logger.info('Using local backtesting data (using whitelist in given config) ...')\n    if self._refresh_pairs:\n        timerange_startup = deepcopy(self._timerange)\n        timerange_startup.subtract_start(timeframe_to_seconds(self.strategy.timeframe) * self.strategy.startup_candle_count)\n        refresh_data(datadir=self.config['datadir'], pairs=pairs, exchange=self.exchange, timeframe=self.strategy.timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n        res = defaultdict(list)\n        for (pair, timeframe, _) in self.strategy.gather_informative_pairs():\n            res[timeframe].append(pair)\n        for (timeframe, inf_pairs) in res.items():\n            timerange_startup = deepcopy(self._timerange)\n            timerange_startup.subtract_start(timeframe_to_seconds(timeframe) * self.strategy.startup_candle_count)\n            refresh_data(datadir=self.config['datadir'], pairs=inf_pairs, exchange=self.exchange, timeframe=timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    data = load_data(datadir=self.config['datadir'], pairs=pairs, timeframe=self.strategy.timeframe, timerange=self._timerange, startup_candles=self.strategy.startup_candle_count, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    if not data:\n        self._cached_pairs = {}\n        logger.critical('No data found. Edge is stopped ...')\n        return False\n    prior_rm = self.config['runmode']\n    self.config['runmode'] = RunMode.EDGE\n    preprocessed = self.strategy.advise_all_indicators(data)\n    self.config['runmode'] = prior_rm\n    (min_date, max_date) = get_timerange(preprocessed)\n    logger.info(f'Measuring data from {min_date.strftime(DATETIME_PRINT_FORMAT)} up to {max_date.strftime(DATETIME_PRINT_FORMAT)} ({(max_date - min_date).days} days)..')\n    headers = ['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long']\n    trades: list = []\n    for (pair, pair_data) in preprocessed.items():\n        pair_data = pair_data.sort_values(by=['date'])\n        pair_data = pair_data.reset_index(drop=True)\n        df_analyzed = self.strategy.ft_advise_signals(pair_data, {'pair': pair})[headers].copy()\n        trades += self._find_trades_for_stoploss_range(df_analyzed, pair, self._stoploss_range)\n    if len(trades) == 0:\n        logger.info('No trades found.')\n        return False\n    trades_df = self._fill_calculable_fields(DataFrame(trades))\n    self._cached_pairs = self._process_expectancy(trades_df)\n    self._last_updated = int(dt_now().timestamp())\n    return True",
            "def calculate(self, pairs: List[str]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.fee is None and pairs:\n        self.fee = self.exchange.get_fee(pairs[0])\n    heartbeat = self.edge_config.get('process_throttle_secs')\n    if self._last_updated > 0 and self._last_updated + heartbeat > int(dt_now().timestamp()):\n        return False\n    data: Dict[str, Any] = {}\n    logger.info('Using stake_currency: %s ...', self.config['stake_currency'])\n    logger.info('Using local backtesting data (using whitelist in given config) ...')\n    if self._refresh_pairs:\n        timerange_startup = deepcopy(self._timerange)\n        timerange_startup.subtract_start(timeframe_to_seconds(self.strategy.timeframe) * self.strategy.startup_candle_count)\n        refresh_data(datadir=self.config['datadir'], pairs=pairs, exchange=self.exchange, timeframe=self.strategy.timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n        res = defaultdict(list)\n        for (pair, timeframe, _) in self.strategy.gather_informative_pairs():\n            res[timeframe].append(pair)\n        for (timeframe, inf_pairs) in res.items():\n            timerange_startup = deepcopy(self._timerange)\n            timerange_startup.subtract_start(timeframe_to_seconds(timeframe) * self.strategy.startup_candle_count)\n            refresh_data(datadir=self.config['datadir'], pairs=inf_pairs, exchange=self.exchange, timeframe=timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    data = load_data(datadir=self.config['datadir'], pairs=pairs, timeframe=self.strategy.timeframe, timerange=self._timerange, startup_candles=self.strategy.startup_candle_count, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    if not data:\n        self._cached_pairs = {}\n        logger.critical('No data found. Edge is stopped ...')\n        return False\n    prior_rm = self.config['runmode']\n    self.config['runmode'] = RunMode.EDGE\n    preprocessed = self.strategy.advise_all_indicators(data)\n    self.config['runmode'] = prior_rm\n    (min_date, max_date) = get_timerange(preprocessed)\n    logger.info(f'Measuring data from {min_date.strftime(DATETIME_PRINT_FORMAT)} up to {max_date.strftime(DATETIME_PRINT_FORMAT)} ({(max_date - min_date).days} days)..')\n    headers = ['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long']\n    trades: list = []\n    for (pair, pair_data) in preprocessed.items():\n        pair_data = pair_data.sort_values(by=['date'])\n        pair_data = pair_data.reset_index(drop=True)\n        df_analyzed = self.strategy.ft_advise_signals(pair_data, {'pair': pair})[headers].copy()\n        trades += self._find_trades_for_stoploss_range(df_analyzed, pair, self._stoploss_range)\n    if len(trades) == 0:\n        logger.info('No trades found.')\n        return False\n    trades_df = self._fill_calculable_fields(DataFrame(trades))\n    self._cached_pairs = self._process_expectancy(trades_df)\n    self._last_updated = int(dt_now().timestamp())\n    return True",
            "def calculate(self, pairs: List[str]) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.fee is None and pairs:\n        self.fee = self.exchange.get_fee(pairs[0])\n    heartbeat = self.edge_config.get('process_throttle_secs')\n    if self._last_updated > 0 and self._last_updated + heartbeat > int(dt_now().timestamp()):\n        return False\n    data: Dict[str, Any] = {}\n    logger.info('Using stake_currency: %s ...', self.config['stake_currency'])\n    logger.info('Using local backtesting data (using whitelist in given config) ...')\n    if self._refresh_pairs:\n        timerange_startup = deepcopy(self._timerange)\n        timerange_startup.subtract_start(timeframe_to_seconds(self.strategy.timeframe) * self.strategy.startup_candle_count)\n        refresh_data(datadir=self.config['datadir'], pairs=pairs, exchange=self.exchange, timeframe=self.strategy.timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n        res = defaultdict(list)\n        for (pair, timeframe, _) in self.strategy.gather_informative_pairs():\n            res[timeframe].append(pair)\n        for (timeframe, inf_pairs) in res.items():\n            timerange_startup = deepcopy(self._timerange)\n            timerange_startup.subtract_start(timeframe_to_seconds(timeframe) * self.strategy.startup_candle_count)\n            refresh_data(datadir=self.config['datadir'], pairs=inf_pairs, exchange=self.exchange, timeframe=timeframe, timerange=timerange_startup, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    data = load_data(datadir=self.config['datadir'], pairs=pairs, timeframe=self.strategy.timeframe, timerange=self._timerange, startup_candles=self.strategy.startup_candle_count, data_format=self.config['dataformat_ohlcv'], candle_type=self.config.get('candle_type_def', CandleType.SPOT))\n    if not data:\n        self._cached_pairs = {}\n        logger.critical('No data found. Edge is stopped ...')\n        return False\n    prior_rm = self.config['runmode']\n    self.config['runmode'] = RunMode.EDGE\n    preprocessed = self.strategy.advise_all_indicators(data)\n    self.config['runmode'] = prior_rm\n    (min_date, max_date) = get_timerange(preprocessed)\n    logger.info(f'Measuring data from {min_date.strftime(DATETIME_PRINT_FORMAT)} up to {max_date.strftime(DATETIME_PRINT_FORMAT)} ({(max_date - min_date).days} days)..')\n    headers = ['date', 'open', 'high', 'low', 'close', 'enter_long', 'exit_long']\n    trades: list = []\n    for (pair, pair_data) in preprocessed.items():\n        pair_data = pair_data.sort_values(by=['date'])\n        pair_data = pair_data.reset_index(drop=True)\n        df_analyzed = self.strategy.ft_advise_signals(pair_data, {'pair': pair})[headers].copy()\n        trades += self._find_trades_for_stoploss_range(df_analyzed, pair, self._stoploss_range)\n    if len(trades) == 0:\n        logger.info('No trades found.')\n        return False\n    trades_df = self._fill_calculable_fields(DataFrame(trades))\n    self._cached_pairs = self._process_expectancy(trades_df)\n    self._last_updated = int(dt_now().timestamp())\n    return True"
        ]
    },
    {
        "func_name": "stake_amount",
        "original": "def stake_amount(self, pair: str, free_capital: float, total_capital: float, capital_in_trade: float) -> float:\n    stoploss = self.get_stoploss(pair)\n    available_capital = (total_capital + capital_in_trade) * self._capital_ratio\n    allowed_capital_at_risk = available_capital * self._allowed_risk\n    max_position_size = abs(allowed_capital_at_risk / stoploss)\n    position_size = min(min(max_position_size, free_capital), available_capital)\n    if pair in self._cached_pairs:\n        logger.info('winrate: %s, expectancy: %s, position size: %s, pair: %s, capital in trade: %s, free capital: %s, total capital: %s, stoploss: %s, available capital: %s.', self._cached_pairs[pair].winrate, self._cached_pairs[pair].expectancy, position_size, pair, capital_in_trade, free_capital, total_capital, stoploss, available_capital)\n    return round(position_size, 15)",
        "mutated": [
            "def stake_amount(self, pair: str, free_capital: float, total_capital: float, capital_in_trade: float) -> float:\n    if False:\n        i = 10\n    stoploss = self.get_stoploss(pair)\n    available_capital = (total_capital + capital_in_trade) * self._capital_ratio\n    allowed_capital_at_risk = available_capital * self._allowed_risk\n    max_position_size = abs(allowed_capital_at_risk / stoploss)\n    position_size = min(min(max_position_size, free_capital), available_capital)\n    if pair in self._cached_pairs:\n        logger.info('winrate: %s, expectancy: %s, position size: %s, pair: %s, capital in trade: %s, free capital: %s, total capital: %s, stoploss: %s, available capital: %s.', self._cached_pairs[pair].winrate, self._cached_pairs[pair].expectancy, position_size, pair, capital_in_trade, free_capital, total_capital, stoploss, available_capital)\n    return round(position_size, 15)",
            "def stake_amount(self, pair: str, free_capital: float, total_capital: float, capital_in_trade: float) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    stoploss = self.get_stoploss(pair)\n    available_capital = (total_capital + capital_in_trade) * self._capital_ratio\n    allowed_capital_at_risk = available_capital * self._allowed_risk\n    max_position_size = abs(allowed_capital_at_risk / stoploss)\n    position_size = min(min(max_position_size, free_capital), available_capital)\n    if pair in self._cached_pairs:\n        logger.info('winrate: %s, expectancy: %s, position size: %s, pair: %s, capital in trade: %s, free capital: %s, total capital: %s, stoploss: %s, available capital: %s.', self._cached_pairs[pair].winrate, self._cached_pairs[pair].expectancy, position_size, pair, capital_in_trade, free_capital, total_capital, stoploss, available_capital)\n    return round(position_size, 15)",
            "def stake_amount(self, pair: str, free_capital: float, total_capital: float, capital_in_trade: float) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    stoploss = self.get_stoploss(pair)\n    available_capital = (total_capital + capital_in_trade) * self._capital_ratio\n    allowed_capital_at_risk = available_capital * self._allowed_risk\n    max_position_size = abs(allowed_capital_at_risk / stoploss)\n    position_size = min(min(max_position_size, free_capital), available_capital)\n    if pair in self._cached_pairs:\n        logger.info('winrate: %s, expectancy: %s, position size: %s, pair: %s, capital in trade: %s, free capital: %s, total capital: %s, stoploss: %s, available capital: %s.', self._cached_pairs[pair].winrate, self._cached_pairs[pair].expectancy, position_size, pair, capital_in_trade, free_capital, total_capital, stoploss, available_capital)\n    return round(position_size, 15)",
            "def stake_amount(self, pair: str, free_capital: float, total_capital: float, capital_in_trade: float) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    stoploss = self.get_stoploss(pair)\n    available_capital = (total_capital + capital_in_trade) * self._capital_ratio\n    allowed_capital_at_risk = available_capital * self._allowed_risk\n    max_position_size = abs(allowed_capital_at_risk / stoploss)\n    position_size = min(min(max_position_size, free_capital), available_capital)\n    if pair in self._cached_pairs:\n        logger.info('winrate: %s, expectancy: %s, position size: %s, pair: %s, capital in trade: %s, free capital: %s, total capital: %s, stoploss: %s, available capital: %s.', self._cached_pairs[pair].winrate, self._cached_pairs[pair].expectancy, position_size, pair, capital_in_trade, free_capital, total_capital, stoploss, available_capital)\n    return round(position_size, 15)",
            "def stake_amount(self, pair: str, free_capital: float, total_capital: float, capital_in_trade: float) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    stoploss = self.get_stoploss(pair)\n    available_capital = (total_capital + capital_in_trade) * self._capital_ratio\n    allowed_capital_at_risk = available_capital * self._allowed_risk\n    max_position_size = abs(allowed_capital_at_risk / stoploss)\n    position_size = min(min(max_position_size, free_capital), available_capital)\n    if pair in self._cached_pairs:\n        logger.info('winrate: %s, expectancy: %s, position size: %s, pair: %s, capital in trade: %s, free capital: %s, total capital: %s, stoploss: %s, available capital: %s.', self._cached_pairs[pair].winrate, self._cached_pairs[pair].expectancy, position_size, pair, capital_in_trade, free_capital, total_capital, stoploss, available_capital)\n    return round(position_size, 15)"
        ]
    },
    {
        "func_name": "get_stoploss",
        "original": "def get_stoploss(self, pair: str) -> float:\n    if pair in self._cached_pairs:\n        return self._cached_pairs[pair].stoploss\n    else:\n        logger.warning(f'Tried to access stoploss of non-existing pair {pair}, strategy stoploss is returned instead.')\n        return self.strategy.stoploss",
        "mutated": [
            "def get_stoploss(self, pair: str) -> float:\n    if False:\n        i = 10\n    if pair in self._cached_pairs:\n        return self._cached_pairs[pair].stoploss\n    else:\n        logger.warning(f'Tried to access stoploss of non-existing pair {pair}, strategy stoploss is returned instead.')\n        return self.strategy.stoploss",
            "def get_stoploss(self, pair: str) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if pair in self._cached_pairs:\n        return self._cached_pairs[pair].stoploss\n    else:\n        logger.warning(f'Tried to access stoploss of non-existing pair {pair}, strategy stoploss is returned instead.')\n        return self.strategy.stoploss",
            "def get_stoploss(self, pair: str) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if pair in self._cached_pairs:\n        return self._cached_pairs[pair].stoploss\n    else:\n        logger.warning(f'Tried to access stoploss of non-existing pair {pair}, strategy stoploss is returned instead.')\n        return self.strategy.stoploss",
            "def get_stoploss(self, pair: str) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if pair in self._cached_pairs:\n        return self._cached_pairs[pair].stoploss\n    else:\n        logger.warning(f'Tried to access stoploss of non-existing pair {pair}, strategy stoploss is returned instead.')\n        return self.strategy.stoploss",
            "def get_stoploss(self, pair: str) -> float:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if pair in self._cached_pairs:\n        return self._cached_pairs[pair].stoploss\n    else:\n        logger.warning(f'Tried to access stoploss of non-existing pair {pair}, strategy stoploss is returned instead.')\n        return self.strategy.stoploss"
        ]
    },
    {
        "func_name": "adjust",
        "original": "def adjust(self, pairs: List[str]) -> list:\n    \"\"\"\n        Filters out and sorts \"pairs\" according to Edge calculated pairs\n        \"\"\"\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)) and (pair in pairs):\n            final.append(pair)\n    if self._final_pairs != final:\n        self._final_pairs = final\n        if self._final_pairs:\n            logger.info('Minimum expectancy and minimum winrate are met only for %s, so other pairs are filtered out.', self._final_pairs)\n        else:\n            logger.info('Edge removed all pairs as no pair with minimum expectancy and minimum winrate was found !')\n    return self._final_pairs",
        "mutated": [
            "def adjust(self, pairs: List[str]) -> list:\n    if False:\n        i = 10\n    '\\n        Filters out and sorts \"pairs\" according to Edge calculated pairs\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)) and (pair in pairs):\n            final.append(pair)\n    if self._final_pairs != final:\n        self._final_pairs = final\n        if self._final_pairs:\n            logger.info('Minimum expectancy and minimum winrate are met only for %s, so other pairs are filtered out.', self._final_pairs)\n        else:\n            logger.info('Edge removed all pairs as no pair with minimum expectancy and minimum winrate was found !')\n    return self._final_pairs",
            "def adjust(self, pairs: List[str]) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Filters out and sorts \"pairs\" according to Edge calculated pairs\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)) and (pair in pairs):\n            final.append(pair)\n    if self._final_pairs != final:\n        self._final_pairs = final\n        if self._final_pairs:\n            logger.info('Minimum expectancy and minimum winrate are met only for %s, so other pairs are filtered out.', self._final_pairs)\n        else:\n            logger.info('Edge removed all pairs as no pair with minimum expectancy and minimum winrate was found !')\n    return self._final_pairs",
            "def adjust(self, pairs: List[str]) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Filters out and sorts \"pairs\" according to Edge calculated pairs\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)) and (pair in pairs):\n            final.append(pair)\n    if self._final_pairs != final:\n        self._final_pairs = final\n        if self._final_pairs:\n            logger.info('Minimum expectancy and minimum winrate are met only for %s, so other pairs are filtered out.', self._final_pairs)\n        else:\n            logger.info('Edge removed all pairs as no pair with minimum expectancy and minimum winrate was found !')\n    return self._final_pairs",
            "def adjust(self, pairs: List[str]) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Filters out and sorts \"pairs\" according to Edge calculated pairs\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)) and (pair in pairs):\n            final.append(pair)\n    if self._final_pairs != final:\n        self._final_pairs = final\n        if self._final_pairs:\n            logger.info('Minimum expectancy and minimum winrate are met only for %s, so other pairs are filtered out.', self._final_pairs)\n        else:\n            logger.info('Edge removed all pairs as no pair with minimum expectancy and minimum winrate was found !')\n    return self._final_pairs",
            "def adjust(self, pairs: List[str]) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Filters out and sorts \"pairs\" according to Edge calculated pairs\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)) and (pair in pairs):\n            final.append(pair)\n    if self._final_pairs != final:\n        self._final_pairs = final\n        if self._final_pairs:\n            logger.info('Minimum expectancy and minimum winrate are met only for %s, so other pairs are filtered out.', self._final_pairs)\n        else:\n            logger.info('Edge removed all pairs as no pair with minimum expectancy and minimum winrate was found !')\n    return self._final_pairs"
        ]
    },
    {
        "func_name": "accepted_pairs",
        "original": "def accepted_pairs(self) -> List[Dict[str, Any]]:\n    \"\"\"\n        return a list of accepted pairs along with their winrate, expectancy and stoploss\n        \"\"\"\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)):\n            final.append({'Pair': pair, 'Winrate': info.winrate, 'Expectancy': info.expectancy, 'Stoploss': info.stoploss})\n    return final",
        "mutated": [
            "def accepted_pairs(self) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n    '\\n        return a list of accepted pairs along with their winrate, expectancy and stoploss\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)):\n            final.append({'Pair': pair, 'Winrate': info.winrate, 'Expectancy': info.expectancy, 'Stoploss': info.stoploss})\n    return final",
            "def accepted_pairs(self) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        return a list of accepted pairs along with their winrate, expectancy and stoploss\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)):\n            final.append({'Pair': pair, 'Winrate': info.winrate, 'Expectancy': info.expectancy, 'Stoploss': info.stoploss})\n    return final",
            "def accepted_pairs(self) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        return a list of accepted pairs along with their winrate, expectancy and stoploss\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)):\n            final.append({'Pair': pair, 'Winrate': info.winrate, 'Expectancy': info.expectancy, 'Stoploss': info.stoploss})\n    return final",
            "def accepted_pairs(self) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        return a list of accepted pairs along with their winrate, expectancy and stoploss\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)):\n            final.append({'Pair': pair, 'Winrate': info.winrate, 'Expectancy': info.expectancy, 'Stoploss': info.stoploss})\n    return final",
            "def accepted_pairs(self) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        return a list of accepted pairs along with their winrate, expectancy and stoploss\\n        '\n    final = []\n    for (pair, info) in self._cached_pairs.items():\n        if info.expectancy > float(self.edge_config.get('minimum_expectancy', 0.2)) and info.winrate > float(self.edge_config.get('minimum_winrate', 0.6)):\n            final.append({'Pair': pair, 'Winrate': info.winrate, 'Expectancy': info.expectancy, 'Stoploss': info.stoploss})\n    return final"
        ]
    },
    {
        "func_name": "_fill_calculable_fields",
        "original": "def _fill_calculable_fields(self, result: DataFrame) -> DataFrame:\n    \"\"\"\n        The result frame contains a number of columns that are calculable\n        from other columns. These are left blank till all rows are added,\n        to be populated in single vector calls.\n\n        Columns to be populated are:\n        - Profit\n        - trade duration\n        - profit abs\n        :param result Dataframe\n        :return: result Dataframe\n        \"\"\"\n    stake = 0.015\n    result['trade_duration'] = result['close_date'] - result['open_date']\n    result['trade_duration'] = result['trade_duration'].map(lambda x: int(x.total_seconds() / 60))\n    result['buy_vol'] = stake / result['open_rate']\n    result['buy_fee'] = stake * self.fee\n    result['buy_spend'] = stake + result['buy_fee']\n    result['sell_sum'] = result['buy_vol'] * result['close_rate']\n    result['sell_fee'] = result['sell_sum'] * self.fee\n    result['sell_take'] = result['sell_sum'] - result['sell_fee']\n    result['profit_ratio'] = (result['sell_take'] - result['buy_spend']) / result['buy_spend']\n    result['profit_abs'] = result['sell_take'] - result['buy_spend']\n    return result",
        "mutated": [
            "def _fill_calculable_fields(self, result: DataFrame) -> DataFrame:\n    if False:\n        i = 10\n    '\\n        The result frame contains a number of columns that are calculable\\n        from other columns. These are left blank till all rows are added,\\n        to be populated in single vector calls.\\n\\n        Columns to be populated are:\\n        - Profit\\n        - trade duration\\n        - profit abs\\n        :param result Dataframe\\n        :return: result Dataframe\\n        '\n    stake = 0.015\n    result['trade_duration'] = result['close_date'] - result['open_date']\n    result['trade_duration'] = result['trade_duration'].map(lambda x: int(x.total_seconds() / 60))\n    result['buy_vol'] = stake / result['open_rate']\n    result['buy_fee'] = stake * self.fee\n    result['buy_spend'] = stake + result['buy_fee']\n    result['sell_sum'] = result['buy_vol'] * result['close_rate']\n    result['sell_fee'] = result['sell_sum'] * self.fee\n    result['sell_take'] = result['sell_sum'] - result['sell_fee']\n    result['profit_ratio'] = (result['sell_take'] - result['buy_spend']) / result['buy_spend']\n    result['profit_abs'] = result['sell_take'] - result['buy_spend']\n    return result",
            "def _fill_calculable_fields(self, result: DataFrame) -> DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        The result frame contains a number of columns that are calculable\\n        from other columns. These are left blank till all rows are added,\\n        to be populated in single vector calls.\\n\\n        Columns to be populated are:\\n        - Profit\\n        - trade duration\\n        - profit abs\\n        :param result Dataframe\\n        :return: result Dataframe\\n        '\n    stake = 0.015\n    result['trade_duration'] = result['close_date'] - result['open_date']\n    result['trade_duration'] = result['trade_duration'].map(lambda x: int(x.total_seconds() / 60))\n    result['buy_vol'] = stake / result['open_rate']\n    result['buy_fee'] = stake * self.fee\n    result['buy_spend'] = stake + result['buy_fee']\n    result['sell_sum'] = result['buy_vol'] * result['close_rate']\n    result['sell_fee'] = result['sell_sum'] * self.fee\n    result['sell_take'] = result['sell_sum'] - result['sell_fee']\n    result['profit_ratio'] = (result['sell_take'] - result['buy_spend']) / result['buy_spend']\n    result['profit_abs'] = result['sell_take'] - result['buy_spend']\n    return result",
            "def _fill_calculable_fields(self, result: DataFrame) -> DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        The result frame contains a number of columns that are calculable\\n        from other columns. These are left blank till all rows are added,\\n        to be populated in single vector calls.\\n\\n        Columns to be populated are:\\n        - Profit\\n        - trade duration\\n        - profit abs\\n        :param result Dataframe\\n        :return: result Dataframe\\n        '\n    stake = 0.015\n    result['trade_duration'] = result['close_date'] - result['open_date']\n    result['trade_duration'] = result['trade_duration'].map(lambda x: int(x.total_seconds() / 60))\n    result['buy_vol'] = stake / result['open_rate']\n    result['buy_fee'] = stake * self.fee\n    result['buy_spend'] = stake + result['buy_fee']\n    result['sell_sum'] = result['buy_vol'] * result['close_rate']\n    result['sell_fee'] = result['sell_sum'] * self.fee\n    result['sell_take'] = result['sell_sum'] - result['sell_fee']\n    result['profit_ratio'] = (result['sell_take'] - result['buy_spend']) / result['buy_spend']\n    result['profit_abs'] = result['sell_take'] - result['buy_spend']\n    return result",
            "def _fill_calculable_fields(self, result: DataFrame) -> DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        The result frame contains a number of columns that are calculable\\n        from other columns. These are left blank till all rows are added,\\n        to be populated in single vector calls.\\n\\n        Columns to be populated are:\\n        - Profit\\n        - trade duration\\n        - profit abs\\n        :param result Dataframe\\n        :return: result Dataframe\\n        '\n    stake = 0.015\n    result['trade_duration'] = result['close_date'] - result['open_date']\n    result['trade_duration'] = result['trade_duration'].map(lambda x: int(x.total_seconds() / 60))\n    result['buy_vol'] = stake / result['open_rate']\n    result['buy_fee'] = stake * self.fee\n    result['buy_spend'] = stake + result['buy_fee']\n    result['sell_sum'] = result['buy_vol'] * result['close_rate']\n    result['sell_fee'] = result['sell_sum'] * self.fee\n    result['sell_take'] = result['sell_sum'] - result['sell_fee']\n    result['profit_ratio'] = (result['sell_take'] - result['buy_spend']) / result['buy_spend']\n    result['profit_abs'] = result['sell_take'] - result['buy_spend']\n    return result",
            "def _fill_calculable_fields(self, result: DataFrame) -> DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        The result frame contains a number of columns that are calculable\\n        from other columns. These are left blank till all rows are added,\\n        to be populated in single vector calls.\\n\\n        Columns to be populated are:\\n        - Profit\\n        - trade duration\\n        - profit abs\\n        :param result Dataframe\\n        :return: result Dataframe\\n        '\n    stake = 0.015\n    result['trade_duration'] = result['close_date'] - result['open_date']\n    result['trade_duration'] = result['trade_duration'].map(lambda x: int(x.total_seconds() / 60))\n    result['buy_vol'] = stake / result['open_rate']\n    result['buy_fee'] = stake * self.fee\n    result['buy_spend'] = stake + result['buy_fee']\n    result['sell_sum'] = result['buy_vol'] * result['close_rate']\n    result['sell_fee'] = result['sell_sum'] * self.fee\n    result['sell_take'] = result['sell_sum'] - result['sell_fee']\n    result['profit_ratio'] = (result['sell_take'] - result['buy_spend']) / result['buy_spend']\n    result['profit_abs'] = result['sell_take'] - result['buy_spend']\n    return result"
        ]
    },
    {
        "func_name": "_process_expectancy",
        "original": "def _process_expectancy(self, results: DataFrame) -> Dict[str, Any]:\n    \"\"\"\n        This calculates WinRate, Required Risk Reward, Risk Reward and Expectancy of all pairs\n        The calculation will be done per pair and per strategy.\n        \"\"\"\n    min_trades_number = self.edge_config.get('min_trade_number', 10)\n    results = results.groupby(['pair', 'stoploss']).filter(lambda x: len(x) > min_trades_number)\n    if self.edge_config.get('remove_pumps', False):\n        results = results[results['profit_abs'] < 2 * results['profit_abs'].std() + results['profit_abs'].mean()]\n    max_trade_duration = self.edge_config.get('max_trade_duration_minute', 1440)\n    results = results[results.trade_duration < max_trade_duration]\n    if results.empty:\n        return {}\n    groupby_aggregator = {'profit_abs': [('nb_trades', 'count'), ('profit_sum', lambda x: x[x > 0].sum()), ('loss_sum', lambda x: abs(x[x < 0].sum())), ('nb_win_trades', lambda x: x[x > 0].count())], 'trade_duration': [('avg_trade_duration', 'mean')]}\n    df = results.groupby(['pair', 'stoploss'])[['profit_abs', 'trade_duration']].agg(groupby_aggregator).reset_index(col_level=1)\n    df.columns = df.columns.droplevel(0)\n    df['nb_loss_trades'] = df['nb_trades'] - df['nb_win_trades']\n    df['average_win'] = np.where(df['nb_win_trades'] == 0, 0.0, df['profit_sum'] / df['nb_win_trades'])\n    df['average_loss'] = np.where(df['nb_loss_trades'] == 0, 0.0, df['loss_sum'] / df['nb_loss_trades'])\n    df['winrate'] = df['nb_win_trades'] / df['nb_trades']\n    df['risk_reward_ratio'] = df['average_win'] / df['average_loss']\n    df['required_risk_reward'] = 1 / df['winrate'] - 1\n    df['expectancy'] = df['risk_reward_ratio'] * df['winrate'] - (1 - df['winrate'])\n    df = df.sort_values(by=['expectancy', 'stoploss'], ascending=False).groupby('pair').first().sort_values(by=['expectancy'], ascending=False).reset_index()\n    final = {}\n    for x in df.itertuples():\n        final[x.pair] = PairInfo(x.stoploss, x.winrate, x.risk_reward_ratio, x.required_risk_reward, x.expectancy, x.nb_trades, x.avg_trade_duration)\n    return final",
        "mutated": [
            "def _process_expectancy(self, results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n    '\\n        This calculates WinRate, Required Risk Reward, Risk Reward and Expectancy of all pairs\\n        The calculation will be done per pair and per strategy.\\n        '\n    min_trades_number = self.edge_config.get('min_trade_number', 10)\n    results = results.groupby(['pair', 'stoploss']).filter(lambda x: len(x) > min_trades_number)\n    if self.edge_config.get('remove_pumps', False):\n        results = results[results['profit_abs'] < 2 * results['profit_abs'].std() + results['profit_abs'].mean()]\n    max_trade_duration = self.edge_config.get('max_trade_duration_minute', 1440)\n    results = results[results.trade_duration < max_trade_duration]\n    if results.empty:\n        return {}\n    groupby_aggregator = {'profit_abs': [('nb_trades', 'count'), ('profit_sum', lambda x: x[x > 0].sum()), ('loss_sum', lambda x: abs(x[x < 0].sum())), ('nb_win_trades', lambda x: x[x > 0].count())], 'trade_duration': [('avg_trade_duration', 'mean')]}\n    df = results.groupby(['pair', 'stoploss'])[['profit_abs', 'trade_duration']].agg(groupby_aggregator).reset_index(col_level=1)\n    df.columns = df.columns.droplevel(0)\n    df['nb_loss_trades'] = df['nb_trades'] - df['nb_win_trades']\n    df['average_win'] = np.where(df['nb_win_trades'] == 0, 0.0, df['profit_sum'] / df['nb_win_trades'])\n    df['average_loss'] = np.where(df['nb_loss_trades'] == 0, 0.0, df['loss_sum'] / df['nb_loss_trades'])\n    df['winrate'] = df['nb_win_trades'] / df['nb_trades']\n    df['risk_reward_ratio'] = df['average_win'] / df['average_loss']\n    df['required_risk_reward'] = 1 / df['winrate'] - 1\n    df['expectancy'] = df['risk_reward_ratio'] * df['winrate'] - (1 - df['winrate'])\n    df = df.sort_values(by=['expectancy', 'stoploss'], ascending=False).groupby('pair').first().sort_values(by=['expectancy'], ascending=False).reset_index()\n    final = {}\n    for x in df.itertuples():\n        final[x.pair] = PairInfo(x.stoploss, x.winrate, x.risk_reward_ratio, x.required_risk_reward, x.expectancy, x.nb_trades, x.avg_trade_duration)\n    return final",
            "def _process_expectancy(self, results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        This calculates WinRate, Required Risk Reward, Risk Reward and Expectancy of all pairs\\n        The calculation will be done per pair and per strategy.\\n        '\n    min_trades_number = self.edge_config.get('min_trade_number', 10)\n    results = results.groupby(['pair', 'stoploss']).filter(lambda x: len(x) > min_trades_number)\n    if self.edge_config.get('remove_pumps', False):\n        results = results[results['profit_abs'] < 2 * results['profit_abs'].std() + results['profit_abs'].mean()]\n    max_trade_duration = self.edge_config.get('max_trade_duration_minute', 1440)\n    results = results[results.trade_duration < max_trade_duration]\n    if results.empty:\n        return {}\n    groupby_aggregator = {'profit_abs': [('nb_trades', 'count'), ('profit_sum', lambda x: x[x > 0].sum()), ('loss_sum', lambda x: abs(x[x < 0].sum())), ('nb_win_trades', lambda x: x[x > 0].count())], 'trade_duration': [('avg_trade_duration', 'mean')]}\n    df = results.groupby(['pair', 'stoploss'])[['profit_abs', 'trade_duration']].agg(groupby_aggregator).reset_index(col_level=1)\n    df.columns = df.columns.droplevel(0)\n    df['nb_loss_trades'] = df['nb_trades'] - df['nb_win_trades']\n    df['average_win'] = np.where(df['nb_win_trades'] == 0, 0.0, df['profit_sum'] / df['nb_win_trades'])\n    df['average_loss'] = np.where(df['nb_loss_trades'] == 0, 0.0, df['loss_sum'] / df['nb_loss_trades'])\n    df['winrate'] = df['nb_win_trades'] / df['nb_trades']\n    df['risk_reward_ratio'] = df['average_win'] / df['average_loss']\n    df['required_risk_reward'] = 1 / df['winrate'] - 1\n    df['expectancy'] = df['risk_reward_ratio'] * df['winrate'] - (1 - df['winrate'])\n    df = df.sort_values(by=['expectancy', 'stoploss'], ascending=False).groupby('pair').first().sort_values(by=['expectancy'], ascending=False).reset_index()\n    final = {}\n    for x in df.itertuples():\n        final[x.pair] = PairInfo(x.stoploss, x.winrate, x.risk_reward_ratio, x.required_risk_reward, x.expectancy, x.nb_trades, x.avg_trade_duration)\n    return final",
            "def _process_expectancy(self, results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        This calculates WinRate, Required Risk Reward, Risk Reward and Expectancy of all pairs\\n        The calculation will be done per pair and per strategy.\\n        '\n    min_trades_number = self.edge_config.get('min_trade_number', 10)\n    results = results.groupby(['pair', 'stoploss']).filter(lambda x: len(x) > min_trades_number)\n    if self.edge_config.get('remove_pumps', False):\n        results = results[results['profit_abs'] < 2 * results['profit_abs'].std() + results['profit_abs'].mean()]\n    max_trade_duration = self.edge_config.get('max_trade_duration_minute', 1440)\n    results = results[results.trade_duration < max_trade_duration]\n    if results.empty:\n        return {}\n    groupby_aggregator = {'profit_abs': [('nb_trades', 'count'), ('profit_sum', lambda x: x[x > 0].sum()), ('loss_sum', lambda x: abs(x[x < 0].sum())), ('nb_win_trades', lambda x: x[x > 0].count())], 'trade_duration': [('avg_trade_duration', 'mean')]}\n    df = results.groupby(['pair', 'stoploss'])[['profit_abs', 'trade_duration']].agg(groupby_aggregator).reset_index(col_level=1)\n    df.columns = df.columns.droplevel(0)\n    df['nb_loss_trades'] = df['nb_trades'] - df['nb_win_trades']\n    df['average_win'] = np.where(df['nb_win_trades'] == 0, 0.0, df['profit_sum'] / df['nb_win_trades'])\n    df['average_loss'] = np.where(df['nb_loss_trades'] == 0, 0.0, df['loss_sum'] / df['nb_loss_trades'])\n    df['winrate'] = df['nb_win_trades'] / df['nb_trades']\n    df['risk_reward_ratio'] = df['average_win'] / df['average_loss']\n    df['required_risk_reward'] = 1 / df['winrate'] - 1\n    df['expectancy'] = df['risk_reward_ratio'] * df['winrate'] - (1 - df['winrate'])\n    df = df.sort_values(by=['expectancy', 'stoploss'], ascending=False).groupby('pair').first().sort_values(by=['expectancy'], ascending=False).reset_index()\n    final = {}\n    for x in df.itertuples():\n        final[x.pair] = PairInfo(x.stoploss, x.winrate, x.risk_reward_ratio, x.required_risk_reward, x.expectancy, x.nb_trades, x.avg_trade_duration)\n    return final",
            "def _process_expectancy(self, results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        This calculates WinRate, Required Risk Reward, Risk Reward and Expectancy of all pairs\\n        The calculation will be done per pair and per strategy.\\n        '\n    min_trades_number = self.edge_config.get('min_trade_number', 10)\n    results = results.groupby(['pair', 'stoploss']).filter(lambda x: len(x) > min_trades_number)\n    if self.edge_config.get('remove_pumps', False):\n        results = results[results['profit_abs'] < 2 * results['profit_abs'].std() + results['profit_abs'].mean()]\n    max_trade_duration = self.edge_config.get('max_trade_duration_minute', 1440)\n    results = results[results.trade_duration < max_trade_duration]\n    if results.empty:\n        return {}\n    groupby_aggregator = {'profit_abs': [('nb_trades', 'count'), ('profit_sum', lambda x: x[x > 0].sum()), ('loss_sum', lambda x: abs(x[x < 0].sum())), ('nb_win_trades', lambda x: x[x > 0].count())], 'trade_duration': [('avg_trade_duration', 'mean')]}\n    df = results.groupby(['pair', 'stoploss'])[['profit_abs', 'trade_duration']].agg(groupby_aggregator).reset_index(col_level=1)\n    df.columns = df.columns.droplevel(0)\n    df['nb_loss_trades'] = df['nb_trades'] - df['nb_win_trades']\n    df['average_win'] = np.where(df['nb_win_trades'] == 0, 0.0, df['profit_sum'] / df['nb_win_trades'])\n    df['average_loss'] = np.where(df['nb_loss_trades'] == 0, 0.0, df['loss_sum'] / df['nb_loss_trades'])\n    df['winrate'] = df['nb_win_trades'] / df['nb_trades']\n    df['risk_reward_ratio'] = df['average_win'] / df['average_loss']\n    df['required_risk_reward'] = 1 / df['winrate'] - 1\n    df['expectancy'] = df['risk_reward_ratio'] * df['winrate'] - (1 - df['winrate'])\n    df = df.sort_values(by=['expectancy', 'stoploss'], ascending=False).groupby('pair').first().sort_values(by=['expectancy'], ascending=False).reset_index()\n    final = {}\n    for x in df.itertuples():\n        final[x.pair] = PairInfo(x.stoploss, x.winrate, x.risk_reward_ratio, x.required_risk_reward, x.expectancy, x.nb_trades, x.avg_trade_duration)\n    return final",
            "def _process_expectancy(self, results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        This calculates WinRate, Required Risk Reward, Risk Reward and Expectancy of all pairs\\n        The calculation will be done per pair and per strategy.\\n        '\n    min_trades_number = self.edge_config.get('min_trade_number', 10)\n    results = results.groupby(['pair', 'stoploss']).filter(lambda x: len(x) > min_trades_number)\n    if self.edge_config.get('remove_pumps', False):\n        results = results[results['profit_abs'] < 2 * results['profit_abs'].std() + results['profit_abs'].mean()]\n    max_trade_duration = self.edge_config.get('max_trade_duration_minute', 1440)\n    results = results[results.trade_duration < max_trade_duration]\n    if results.empty:\n        return {}\n    groupby_aggregator = {'profit_abs': [('nb_trades', 'count'), ('profit_sum', lambda x: x[x > 0].sum()), ('loss_sum', lambda x: abs(x[x < 0].sum())), ('nb_win_trades', lambda x: x[x > 0].count())], 'trade_duration': [('avg_trade_duration', 'mean')]}\n    df = results.groupby(['pair', 'stoploss'])[['profit_abs', 'trade_duration']].agg(groupby_aggregator).reset_index(col_level=1)\n    df.columns = df.columns.droplevel(0)\n    df['nb_loss_trades'] = df['nb_trades'] - df['nb_win_trades']\n    df['average_win'] = np.where(df['nb_win_trades'] == 0, 0.0, df['profit_sum'] / df['nb_win_trades'])\n    df['average_loss'] = np.where(df['nb_loss_trades'] == 0, 0.0, df['loss_sum'] / df['nb_loss_trades'])\n    df['winrate'] = df['nb_win_trades'] / df['nb_trades']\n    df['risk_reward_ratio'] = df['average_win'] / df['average_loss']\n    df['required_risk_reward'] = 1 / df['winrate'] - 1\n    df['expectancy'] = df['risk_reward_ratio'] * df['winrate'] - (1 - df['winrate'])\n    df = df.sort_values(by=['expectancy', 'stoploss'], ascending=False).groupby('pair').first().sort_values(by=['expectancy'], ascending=False).reset_index()\n    final = {}\n    for x in df.itertuples():\n        final[x.pair] = PairInfo(x.stoploss, x.winrate, x.risk_reward_ratio, x.required_risk_reward, x.expectancy, x.nb_trades, x.avg_trade_duration)\n    return final"
        ]
    },
    {
        "func_name": "_find_trades_for_stoploss_range",
        "original": "def _find_trades_for_stoploss_range(self, df, pair: str, stoploss_range) -> list:\n    buy_column = df['enter_long'].values\n    sell_column = df['exit_long'].values\n    date_column = df['date'].values\n    ohlc_columns = df[['open', 'high', 'low', 'close']].values\n    result: list = []\n    for stoploss in stoploss_range:\n        result += self._detect_next_stop_or_sell_point(buy_column, sell_column, date_column, ohlc_columns, round(stoploss, 6), pair)\n    return result",
        "mutated": [
            "def _find_trades_for_stoploss_range(self, df, pair: str, stoploss_range) -> list:\n    if False:\n        i = 10\n    buy_column = df['enter_long'].values\n    sell_column = df['exit_long'].values\n    date_column = df['date'].values\n    ohlc_columns = df[['open', 'high', 'low', 'close']].values\n    result: list = []\n    for stoploss in stoploss_range:\n        result += self._detect_next_stop_or_sell_point(buy_column, sell_column, date_column, ohlc_columns, round(stoploss, 6), pair)\n    return result",
            "def _find_trades_for_stoploss_range(self, df, pair: str, stoploss_range) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    buy_column = df['enter_long'].values\n    sell_column = df['exit_long'].values\n    date_column = df['date'].values\n    ohlc_columns = df[['open', 'high', 'low', 'close']].values\n    result: list = []\n    for stoploss in stoploss_range:\n        result += self._detect_next_stop_or_sell_point(buy_column, sell_column, date_column, ohlc_columns, round(stoploss, 6), pair)\n    return result",
            "def _find_trades_for_stoploss_range(self, df, pair: str, stoploss_range) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    buy_column = df['enter_long'].values\n    sell_column = df['exit_long'].values\n    date_column = df['date'].values\n    ohlc_columns = df[['open', 'high', 'low', 'close']].values\n    result: list = []\n    for stoploss in stoploss_range:\n        result += self._detect_next_stop_or_sell_point(buy_column, sell_column, date_column, ohlc_columns, round(stoploss, 6), pair)\n    return result",
            "def _find_trades_for_stoploss_range(self, df, pair: str, stoploss_range) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    buy_column = df['enter_long'].values\n    sell_column = df['exit_long'].values\n    date_column = df['date'].values\n    ohlc_columns = df[['open', 'high', 'low', 'close']].values\n    result: list = []\n    for stoploss in stoploss_range:\n        result += self._detect_next_stop_or_sell_point(buy_column, sell_column, date_column, ohlc_columns, round(stoploss, 6), pair)\n    return result",
            "def _find_trades_for_stoploss_range(self, df, pair: str, stoploss_range) -> list:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    buy_column = df['enter_long'].values\n    sell_column = df['exit_long'].values\n    date_column = df['date'].values\n    ohlc_columns = df[['open', 'high', 'low', 'close']].values\n    result: list = []\n    for stoploss in stoploss_range:\n        result += self._detect_next_stop_or_sell_point(buy_column, sell_column, date_column, ohlc_columns, round(stoploss, 6), pair)\n    return result"
        ]
    },
    {
        "func_name": "_detect_next_stop_or_sell_point",
        "original": "def _detect_next_stop_or_sell_point(self, buy_column, sell_column, date_column, ohlc_columns, stoploss, pair: str):\n    \"\"\"\n        Iterate through ohlc_columns in order to find the next trade\n        Next trade opens from the first buy signal noticed to\n        The sell or stoploss signal after it.\n        It then cuts OHLC, buy_column, sell_column and date_column.\n        Cut from (the exit trade index) + 1.\n\n        Author: https://github.com/mishaker\n        \"\"\"\n    result: list = []\n    start_point = 0\n    while True:\n        open_trade_index = utf1st.find_1st(buy_column, 1, utf1st.cmp_equal)\n        if open_trade_index == -1 or open_trade_index == len(buy_column) - 1:\n            break\n        else:\n            open_trade_index += 1\n        open_price = ohlc_columns[open_trade_index, 0]\n        stop_price = open_price * (stoploss + 1)\n        stop_index = utf1st.find_1st(ohlc_columns[open_trade_index:, 2], stop_price, utf1st.cmp_smaller)\n        if stop_index == -1:\n            stop_index = float('inf')\n        sell_index = utf1st.find_1st(sell_column[open_trade_index:], 1, utf1st.cmp_equal)\n        if sell_index == -1:\n            sell_index = float('inf')\n        if stop_index == sell_index == float('inf'):\n            break\n        if stop_index <= sell_index:\n            exit_index = open_trade_index + stop_index\n            exit_type = ExitType.STOP_LOSS\n            exit_price = stop_price\n        elif stop_index > sell_index:\n            exit_index = open_trade_index + sell_index + 1\n            if len(ohlc_columns) - 1 < exit_index:\n                break\n            exit_type = ExitType.EXIT_SIGNAL\n            exit_price = ohlc_columns[exit_index, 0]\n        trade = {'pair': pair, 'stoploss': stoploss, 'profit_ratio': '', 'profit_abs': '', 'open_date': date_column[open_trade_index], 'close_date': date_column[exit_index], 'trade_duration': '', 'open_rate': round(open_price, 15), 'close_rate': round(exit_price, 15), 'exit_type': exit_type}\n        result.append(trade)\n        buy_column = buy_column[exit_index:]\n        sell_column = sell_column[exit_index:]\n        date_column = date_column[exit_index:]\n        ohlc_columns = ohlc_columns[exit_index:]\n        start_point += exit_index\n    return result",
        "mutated": [
            "def _detect_next_stop_or_sell_point(self, buy_column, sell_column, date_column, ohlc_columns, stoploss, pair: str):\n    if False:\n        i = 10\n    '\\n        Iterate through ohlc_columns in order to find the next trade\\n        Next trade opens from the first buy signal noticed to\\n        The sell or stoploss signal after it.\\n        It then cuts OHLC, buy_column, sell_column and date_column.\\n        Cut from (the exit trade index) + 1.\\n\\n        Author: https://github.com/mishaker\\n        '\n    result: list = []\n    start_point = 0\n    while True:\n        open_trade_index = utf1st.find_1st(buy_column, 1, utf1st.cmp_equal)\n        if open_trade_index == -1 or open_trade_index == len(buy_column) - 1:\n            break\n        else:\n            open_trade_index += 1\n        open_price = ohlc_columns[open_trade_index, 0]\n        stop_price = open_price * (stoploss + 1)\n        stop_index = utf1st.find_1st(ohlc_columns[open_trade_index:, 2], stop_price, utf1st.cmp_smaller)\n        if stop_index == -1:\n            stop_index = float('inf')\n        sell_index = utf1st.find_1st(sell_column[open_trade_index:], 1, utf1st.cmp_equal)\n        if sell_index == -1:\n            sell_index = float('inf')\n        if stop_index == sell_index == float('inf'):\n            break\n        if stop_index <= sell_index:\n            exit_index = open_trade_index + stop_index\n            exit_type = ExitType.STOP_LOSS\n            exit_price = stop_price\n        elif stop_index > sell_index:\n            exit_index = open_trade_index + sell_index + 1\n            if len(ohlc_columns) - 1 < exit_index:\n                break\n            exit_type = ExitType.EXIT_SIGNAL\n            exit_price = ohlc_columns[exit_index, 0]\n        trade = {'pair': pair, 'stoploss': stoploss, 'profit_ratio': '', 'profit_abs': '', 'open_date': date_column[open_trade_index], 'close_date': date_column[exit_index], 'trade_duration': '', 'open_rate': round(open_price, 15), 'close_rate': round(exit_price, 15), 'exit_type': exit_type}\n        result.append(trade)\n        buy_column = buy_column[exit_index:]\n        sell_column = sell_column[exit_index:]\n        date_column = date_column[exit_index:]\n        ohlc_columns = ohlc_columns[exit_index:]\n        start_point += exit_index\n    return result",
            "def _detect_next_stop_or_sell_point(self, buy_column, sell_column, date_column, ohlc_columns, stoploss, pair: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Iterate through ohlc_columns in order to find the next trade\\n        Next trade opens from the first buy signal noticed to\\n        The sell or stoploss signal after it.\\n        It then cuts OHLC, buy_column, sell_column and date_column.\\n        Cut from (the exit trade index) + 1.\\n\\n        Author: https://github.com/mishaker\\n        '\n    result: list = []\n    start_point = 0\n    while True:\n        open_trade_index = utf1st.find_1st(buy_column, 1, utf1st.cmp_equal)\n        if open_trade_index == -1 or open_trade_index == len(buy_column) - 1:\n            break\n        else:\n            open_trade_index += 1\n        open_price = ohlc_columns[open_trade_index, 0]\n        stop_price = open_price * (stoploss + 1)\n        stop_index = utf1st.find_1st(ohlc_columns[open_trade_index:, 2], stop_price, utf1st.cmp_smaller)\n        if stop_index == -1:\n            stop_index = float('inf')\n        sell_index = utf1st.find_1st(sell_column[open_trade_index:], 1, utf1st.cmp_equal)\n        if sell_index == -1:\n            sell_index = float('inf')\n        if stop_index == sell_index == float('inf'):\n            break\n        if stop_index <= sell_index:\n            exit_index = open_trade_index + stop_index\n            exit_type = ExitType.STOP_LOSS\n            exit_price = stop_price\n        elif stop_index > sell_index:\n            exit_index = open_trade_index + sell_index + 1\n            if len(ohlc_columns) - 1 < exit_index:\n                break\n            exit_type = ExitType.EXIT_SIGNAL\n            exit_price = ohlc_columns[exit_index, 0]\n        trade = {'pair': pair, 'stoploss': stoploss, 'profit_ratio': '', 'profit_abs': '', 'open_date': date_column[open_trade_index], 'close_date': date_column[exit_index], 'trade_duration': '', 'open_rate': round(open_price, 15), 'close_rate': round(exit_price, 15), 'exit_type': exit_type}\n        result.append(trade)\n        buy_column = buy_column[exit_index:]\n        sell_column = sell_column[exit_index:]\n        date_column = date_column[exit_index:]\n        ohlc_columns = ohlc_columns[exit_index:]\n        start_point += exit_index\n    return result",
            "def _detect_next_stop_or_sell_point(self, buy_column, sell_column, date_column, ohlc_columns, stoploss, pair: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Iterate through ohlc_columns in order to find the next trade\\n        Next trade opens from the first buy signal noticed to\\n        The sell or stoploss signal after it.\\n        It then cuts OHLC, buy_column, sell_column and date_column.\\n        Cut from (the exit trade index) + 1.\\n\\n        Author: https://github.com/mishaker\\n        '\n    result: list = []\n    start_point = 0\n    while True:\n        open_trade_index = utf1st.find_1st(buy_column, 1, utf1st.cmp_equal)\n        if open_trade_index == -1 or open_trade_index == len(buy_column) - 1:\n            break\n        else:\n            open_trade_index += 1\n        open_price = ohlc_columns[open_trade_index, 0]\n        stop_price = open_price * (stoploss + 1)\n        stop_index = utf1st.find_1st(ohlc_columns[open_trade_index:, 2], stop_price, utf1st.cmp_smaller)\n        if stop_index == -1:\n            stop_index = float('inf')\n        sell_index = utf1st.find_1st(sell_column[open_trade_index:], 1, utf1st.cmp_equal)\n        if sell_index == -1:\n            sell_index = float('inf')\n        if stop_index == sell_index == float('inf'):\n            break\n        if stop_index <= sell_index:\n            exit_index = open_trade_index + stop_index\n            exit_type = ExitType.STOP_LOSS\n            exit_price = stop_price\n        elif stop_index > sell_index:\n            exit_index = open_trade_index + sell_index + 1\n            if len(ohlc_columns) - 1 < exit_index:\n                break\n            exit_type = ExitType.EXIT_SIGNAL\n            exit_price = ohlc_columns[exit_index, 0]\n        trade = {'pair': pair, 'stoploss': stoploss, 'profit_ratio': '', 'profit_abs': '', 'open_date': date_column[open_trade_index], 'close_date': date_column[exit_index], 'trade_duration': '', 'open_rate': round(open_price, 15), 'close_rate': round(exit_price, 15), 'exit_type': exit_type}\n        result.append(trade)\n        buy_column = buy_column[exit_index:]\n        sell_column = sell_column[exit_index:]\n        date_column = date_column[exit_index:]\n        ohlc_columns = ohlc_columns[exit_index:]\n        start_point += exit_index\n    return result",
            "def _detect_next_stop_or_sell_point(self, buy_column, sell_column, date_column, ohlc_columns, stoploss, pair: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Iterate through ohlc_columns in order to find the next trade\\n        Next trade opens from the first buy signal noticed to\\n        The sell or stoploss signal after it.\\n        It then cuts OHLC, buy_column, sell_column and date_column.\\n        Cut from (the exit trade index) + 1.\\n\\n        Author: https://github.com/mishaker\\n        '\n    result: list = []\n    start_point = 0\n    while True:\n        open_trade_index = utf1st.find_1st(buy_column, 1, utf1st.cmp_equal)\n        if open_trade_index == -1 or open_trade_index == len(buy_column) - 1:\n            break\n        else:\n            open_trade_index += 1\n        open_price = ohlc_columns[open_trade_index, 0]\n        stop_price = open_price * (stoploss + 1)\n        stop_index = utf1st.find_1st(ohlc_columns[open_trade_index:, 2], stop_price, utf1st.cmp_smaller)\n        if stop_index == -1:\n            stop_index = float('inf')\n        sell_index = utf1st.find_1st(sell_column[open_trade_index:], 1, utf1st.cmp_equal)\n        if sell_index == -1:\n            sell_index = float('inf')\n        if stop_index == sell_index == float('inf'):\n            break\n        if stop_index <= sell_index:\n            exit_index = open_trade_index + stop_index\n            exit_type = ExitType.STOP_LOSS\n            exit_price = stop_price\n        elif stop_index > sell_index:\n            exit_index = open_trade_index + sell_index + 1\n            if len(ohlc_columns) - 1 < exit_index:\n                break\n            exit_type = ExitType.EXIT_SIGNAL\n            exit_price = ohlc_columns[exit_index, 0]\n        trade = {'pair': pair, 'stoploss': stoploss, 'profit_ratio': '', 'profit_abs': '', 'open_date': date_column[open_trade_index], 'close_date': date_column[exit_index], 'trade_duration': '', 'open_rate': round(open_price, 15), 'close_rate': round(exit_price, 15), 'exit_type': exit_type}\n        result.append(trade)\n        buy_column = buy_column[exit_index:]\n        sell_column = sell_column[exit_index:]\n        date_column = date_column[exit_index:]\n        ohlc_columns = ohlc_columns[exit_index:]\n        start_point += exit_index\n    return result",
            "def _detect_next_stop_or_sell_point(self, buy_column, sell_column, date_column, ohlc_columns, stoploss, pair: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Iterate through ohlc_columns in order to find the next trade\\n        Next trade opens from the first buy signal noticed to\\n        The sell or stoploss signal after it.\\n        It then cuts OHLC, buy_column, sell_column and date_column.\\n        Cut from (the exit trade index) + 1.\\n\\n        Author: https://github.com/mishaker\\n        '\n    result: list = []\n    start_point = 0\n    while True:\n        open_trade_index = utf1st.find_1st(buy_column, 1, utf1st.cmp_equal)\n        if open_trade_index == -1 or open_trade_index == len(buy_column) - 1:\n            break\n        else:\n            open_trade_index += 1\n        open_price = ohlc_columns[open_trade_index, 0]\n        stop_price = open_price * (stoploss + 1)\n        stop_index = utf1st.find_1st(ohlc_columns[open_trade_index:, 2], stop_price, utf1st.cmp_smaller)\n        if stop_index == -1:\n            stop_index = float('inf')\n        sell_index = utf1st.find_1st(sell_column[open_trade_index:], 1, utf1st.cmp_equal)\n        if sell_index == -1:\n            sell_index = float('inf')\n        if stop_index == sell_index == float('inf'):\n            break\n        if stop_index <= sell_index:\n            exit_index = open_trade_index + stop_index\n            exit_type = ExitType.STOP_LOSS\n            exit_price = stop_price\n        elif stop_index > sell_index:\n            exit_index = open_trade_index + sell_index + 1\n            if len(ohlc_columns) - 1 < exit_index:\n                break\n            exit_type = ExitType.EXIT_SIGNAL\n            exit_price = ohlc_columns[exit_index, 0]\n        trade = {'pair': pair, 'stoploss': stoploss, 'profit_ratio': '', 'profit_abs': '', 'open_date': date_column[open_trade_index], 'close_date': date_column[exit_index], 'trade_duration': '', 'open_rate': round(open_price, 15), 'close_rate': round(exit_price, 15), 'exit_type': exit_type}\n        result.append(trade)\n        buy_column = buy_column[exit_index:]\n        sell_column = sell_column[exit_index:]\n        date_column = date_column[exit_index:]\n        ohlc_columns = ohlc_columns[exit_index:]\n        start_point += exit_index\n    return result"
        ]
    }
]