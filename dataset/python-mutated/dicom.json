[
    {
        "func_name": "_gen_items",
        "original": "def _gen_items(data: bytes) -> Generator[Tuple[int, bytes], None, None]:\n    while data:\n        if len(data) < 4:\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n            return\n        (itype, pad, ilen) = struct.unpack('>BBH', data[:4])\n        if pad:\n            utils.LOGGER.debug('Non zero padding: maybe a broken DICOM item [%r]', data)\n        data = data[4:]\n        if ilen < len(data):\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n        yield (itype, data[:ilen])\n        data = data[ilen:]",
        "mutated": [
            "def _gen_items(data: bytes) -> Generator[Tuple[int, bytes], None, None]:\n    if False:\n        i = 10\n    while data:\n        if len(data) < 4:\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n            return\n        (itype, pad, ilen) = struct.unpack('>BBH', data[:4])\n        if pad:\n            utils.LOGGER.debug('Non zero padding: maybe a broken DICOM item [%r]', data)\n        data = data[4:]\n        if ilen < len(data):\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n        yield (itype, data[:ilen])\n        data = data[ilen:]",
            "def _gen_items(data: bytes) -> Generator[Tuple[int, bytes], None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    while data:\n        if len(data) < 4:\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n            return\n        (itype, pad, ilen) = struct.unpack('>BBH', data[:4])\n        if pad:\n            utils.LOGGER.debug('Non zero padding: maybe a broken DICOM item [%r]', data)\n        data = data[4:]\n        if ilen < len(data):\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n        yield (itype, data[:ilen])\n        data = data[ilen:]",
            "def _gen_items(data: bytes) -> Generator[Tuple[int, bytes], None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    while data:\n        if len(data) < 4:\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n            return\n        (itype, pad, ilen) = struct.unpack('>BBH', data[:4])\n        if pad:\n            utils.LOGGER.debug('Non zero padding: maybe a broken DICOM item [%r]', data)\n        data = data[4:]\n        if ilen < len(data):\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n        yield (itype, data[:ilen])\n        data = data[ilen:]",
            "def _gen_items(data: bytes) -> Generator[Tuple[int, bytes], None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    while data:\n        if len(data) < 4:\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n            return\n        (itype, pad, ilen) = struct.unpack('>BBH', data[:4])\n        if pad:\n            utils.LOGGER.debug('Non zero padding: maybe a broken DICOM item [%r]', data)\n        data = data[4:]\n        if ilen < len(data):\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n        yield (itype, data[:ilen])\n        data = data[ilen:]",
            "def _gen_items(data: bytes) -> Generator[Tuple[int, bytes], None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    while data:\n        if len(data) < 4:\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n            return\n        (itype, pad, ilen) = struct.unpack('>BBH', data[:4])\n        if pad:\n            utils.LOGGER.debug('Non zero padding: maybe a broken DICOM item [%r]', data)\n        data = data[4:]\n        if ilen < len(data):\n            utils.LOGGER.debug('Item too short: maybe a broken DICOM item [%r]', data)\n        yield (itype, data[:ilen])\n        data = data[ilen:]"
        ]
    },
    {
        "func_name": "_parse_items",
        "original": "def _parse_items(data: bytes) -> Dict[str, Union[int, str]]:\n    res: Dict[str, Union[int, str]] = {}\n    items = dict(_gen_items(data))\n    if 80 not in items:\n        utils.LOGGER.warning('No User Info in items [%r]', items)\n        return res\n    ivalue: bytes\n    ivalue_parsed: Union[int, str]\n    for (itype, ivalue) in _gen_items(items[80]):\n        if itype == 81:\n            try:\n                ivalue_parsed = cast(int, struct.unpack('>I', ivalue)[0])\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert max_pdu_length value to an integer [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        else:\n            try:\n                ivalue_parsed = ivalue.decode('ascii')\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert value to an ASCII string [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        try:\n            itype_parsed = _USER_INFO_ITEMS[itype]\n        except KeyError:\n            utils.LOGGER.warning('Unknown item type in User Info %02x [%r]', itype, ivalue)\n            itype_parsed = 'unknown_%02x' % itype\n        res[itype_parsed] = ivalue_parsed\n    return res",
        "mutated": [
            "def _parse_items(data: bytes) -> Dict[str, Union[int, str]]:\n    if False:\n        i = 10\n    res: Dict[str, Union[int, str]] = {}\n    items = dict(_gen_items(data))\n    if 80 not in items:\n        utils.LOGGER.warning('No User Info in items [%r]', items)\n        return res\n    ivalue: bytes\n    ivalue_parsed: Union[int, str]\n    for (itype, ivalue) in _gen_items(items[80]):\n        if itype == 81:\n            try:\n                ivalue_parsed = cast(int, struct.unpack('>I', ivalue)[0])\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert max_pdu_length value to an integer [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        else:\n            try:\n                ivalue_parsed = ivalue.decode('ascii')\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert value to an ASCII string [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        try:\n            itype_parsed = _USER_INFO_ITEMS[itype]\n        except KeyError:\n            utils.LOGGER.warning('Unknown item type in User Info %02x [%r]', itype, ivalue)\n            itype_parsed = 'unknown_%02x' % itype\n        res[itype_parsed] = ivalue_parsed\n    return res",
            "def _parse_items(data: bytes) -> Dict[str, Union[int, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res: Dict[str, Union[int, str]] = {}\n    items = dict(_gen_items(data))\n    if 80 not in items:\n        utils.LOGGER.warning('No User Info in items [%r]', items)\n        return res\n    ivalue: bytes\n    ivalue_parsed: Union[int, str]\n    for (itype, ivalue) in _gen_items(items[80]):\n        if itype == 81:\n            try:\n                ivalue_parsed = cast(int, struct.unpack('>I', ivalue)[0])\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert max_pdu_length value to an integer [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        else:\n            try:\n                ivalue_parsed = ivalue.decode('ascii')\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert value to an ASCII string [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        try:\n            itype_parsed = _USER_INFO_ITEMS[itype]\n        except KeyError:\n            utils.LOGGER.warning('Unknown item type in User Info %02x [%r]', itype, ivalue)\n            itype_parsed = 'unknown_%02x' % itype\n        res[itype_parsed] = ivalue_parsed\n    return res",
            "def _parse_items(data: bytes) -> Dict[str, Union[int, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res: Dict[str, Union[int, str]] = {}\n    items = dict(_gen_items(data))\n    if 80 not in items:\n        utils.LOGGER.warning('No User Info in items [%r]', items)\n        return res\n    ivalue: bytes\n    ivalue_parsed: Union[int, str]\n    for (itype, ivalue) in _gen_items(items[80]):\n        if itype == 81:\n            try:\n                ivalue_parsed = cast(int, struct.unpack('>I', ivalue)[0])\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert max_pdu_length value to an integer [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        else:\n            try:\n                ivalue_parsed = ivalue.decode('ascii')\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert value to an ASCII string [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        try:\n            itype_parsed = _USER_INFO_ITEMS[itype]\n        except KeyError:\n            utils.LOGGER.warning('Unknown item type in User Info %02x [%r]', itype, ivalue)\n            itype_parsed = 'unknown_%02x' % itype\n        res[itype_parsed] = ivalue_parsed\n    return res",
            "def _parse_items(data: bytes) -> Dict[str, Union[int, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res: Dict[str, Union[int, str]] = {}\n    items = dict(_gen_items(data))\n    if 80 not in items:\n        utils.LOGGER.warning('No User Info in items [%r]', items)\n        return res\n    ivalue: bytes\n    ivalue_parsed: Union[int, str]\n    for (itype, ivalue) in _gen_items(items[80]):\n        if itype == 81:\n            try:\n                ivalue_parsed = cast(int, struct.unpack('>I', ivalue)[0])\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert max_pdu_length value to an integer [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        else:\n            try:\n                ivalue_parsed = ivalue.decode('ascii')\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert value to an ASCII string [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        try:\n            itype_parsed = _USER_INFO_ITEMS[itype]\n        except KeyError:\n            utils.LOGGER.warning('Unknown item type in User Info %02x [%r]', itype, ivalue)\n            itype_parsed = 'unknown_%02x' % itype\n        res[itype_parsed] = ivalue_parsed\n    return res",
            "def _parse_items(data: bytes) -> Dict[str, Union[int, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res: Dict[str, Union[int, str]] = {}\n    items = dict(_gen_items(data))\n    if 80 not in items:\n        utils.LOGGER.warning('No User Info in items [%r]', items)\n        return res\n    ivalue: bytes\n    ivalue_parsed: Union[int, str]\n    for (itype, ivalue) in _gen_items(items[80]):\n        if itype == 81:\n            try:\n                ivalue_parsed = cast(int, struct.unpack('>I', ivalue)[0])\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert max_pdu_length value to an integer [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        else:\n            try:\n                ivalue_parsed = ivalue.decode('ascii')\n            except struct.error:\n                utils.LOGGER.warning('Cannot convert value to an ASCII string [%r]', ivalue)\n                ivalue_parsed = utils.encode_b64(ivalue).decode()\n        try:\n            itype_parsed = _USER_INFO_ITEMS[itype]\n        except KeyError:\n            utils.LOGGER.warning('Unknown item type in User Info %02x [%r]', itype, ivalue)\n            itype_parsed = 'unknown_%02x' % itype\n        res[itype_parsed] = ivalue_parsed\n    return res"
        ]
    },
    {
        "func_name": "parse_message",
        "original": "def parse_message(data: bytes) -> NmapPort:\n    res: NmapPort = {}\n    if len(data) < 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    (rtype, pad, rlen) = struct.unpack('>BBI', data[:6])\n    if pad:\n        utils.LOGGER.debug('Non zero padding: probably not a DICOM message [%r]', data)\n        return res\n    if rlen > len(data) - 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    if rtype in [2, 3]:\n        res['service_name'] = 'dicom'\n        extra_info: Dict[str, Union[int, str]] = {}\n        if rtype == 2:\n            msg = 'Any AET is accepted (Insecure)'\n            if data[6:74] != b'\\x00\\x01\\x00\\x00ANY-SCP         ECHOSCU         \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n                extra_info = {'info': 'Unusual accept message'}\n            else:\n                extra_info = _parse_items(data[74:])\n        else:\n            msg = 'Called AET check enabled'\n            if data != b'\\x03\\x00\\x00\\x00\\x00\\x04\\x00\\x01\\x01\\x07':\n                extra_info = {'info': 'Unusual reject message'}\n        script_output = ['', 'dicom: DICOM Service Provider discovered!', 'config: %s' % msg]\n        script_data: Dict[str, Union[int, str]] = {'dicom': 'DICOM Service Provider discovered!', 'config': msg}\n        for (key, value) in extra_info.items():\n            script_output.append('%s: %s' % (key, value))\n            script_data[key] = value\n        res['scripts'] = [{'id': 'dicom-ping', 'output': '\\n  '.join(script_output), 'dicom-ping': script_data}]\n        return res\n    utils.LOGGER.debug('Unknown message type [%r]: probably not a DICOM message [%r]', rtype, data)\n    return res",
        "mutated": [
            "def parse_message(data: bytes) -> NmapPort:\n    if False:\n        i = 10\n    res: NmapPort = {}\n    if len(data) < 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    (rtype, pad, rlen) = struct.unpack('>BBI', data[:6])\n    if pad:\n        utils.LOGGER.debug('Non zero padding: probably not a DICOM message [%r]', data)\n        return res\n    if rlen > len(data) - 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    if rtype in [2, 3]:\n        res['service_name'] = 'dicom'\n        extra_info: Dict[str, Union[int, str]] = {}\n        if rtype == 2:\n            msg = 'Any AET is accepted (Insecure)'\n            if data[6:74] != b'\\x00\\x01\\x00\\x00ANY-SCP         ECHOSCU         \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n                extra_info = {'info': 'Unusual accept message'}\n            else:\n                extra_info = _parse_items(data[74:])\n        else:\n            msg = 'Called AET check enabled'\n            if data != b'\\x03\\x00\\x00\\x00\\x00\\x04\\x00\\x01\\x01\\x07':\n                extra_info = {'info': 'Unusual reject message'}\n        script_output = ['', 'dicom: DICOM Service Provider discovered!', 'config: %s' % msg]\n        script_data: Dict[str, Union[int, str]] = {'dicom': 'DICOM Service Provider discovered!', 'config': msg}\n        for (key, value) in extra_info.items():\n            script_output.append('%s: %s' % (key, value))\n            script_data[key] = value\n        res['scripts'] = [{'id': 'dicom-ping', 'output': '\\n  '.join(script_output), 'dicom-ping': script_data}]\n        return res\n    utils.LOGGER.debug('Unknown message type [%r]: probably not a DICOM message [%r]', rtype, data)\n    return res",
            "def parse_message(data: bytes) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res: NmapPort = {}\n    if len(data) < 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    (rtype, pad, rlen) = struct.unpack('>BBI', data[:6])\n    if pad:\n        utils.LOGGER.debug('Non zero padding: probably not a DICOM message [%r]', data)\n        return res\n    if rlen > len(data) - 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    if rtype in [2, 3]:\n        res['service_name'] = 'dicom'\n        extra_info: Dict[str, Union[int, str]] = {}\n        if rtype == 2:\n            msg = 'Any AET is accepted (Insecure)'\n            if data[6:74] != b'\\x00\\x01\\x00\\x00ANY-SCP         ECHOSCU         \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n                extra_info = {'info': 'Unusual accept message'}\n            else:\n                extra_info = _parse_items(data[74:])\n        else:\n            msg = 'Called AET check enabled'\n            if data != b'\\x03\\x00\\x00\\x00\\x00\\x04\\x00\\x01\\x01\\x07':\n                extra_info = {'info': 'Unusual reject message'}\n        script_output = ['', 'dicom: DICOM Service Provider discovered!', 'config: %s' % msg]\n        script_data: Dict[str, Union[int, str]] = {'dicom': 'DICOM Service Provider discovered!', 'config': msg}\n        for (key, value) in extra_info.items():\n            script_output.append('%s: %s' % (key, value))\n            script_data[key] = value\n        res['scripts'] = [{'id': 'dicom-ping', 'output': '\\n  '.join(script_output), 'dicom-ping': script_data}]\n        return res\n    utils.LOGGER.debug('Unknown message type [%r]: probably not a DICOM message [%r]', rtype, data)\n    return res",
            "def parse_message(data: bytes) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res: NmapPort = {}\n    if len(data) < 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    (rtype, pad, rlen) = struct.unpack('>BBI', data[:6])\n    if pad:\n        utils.LOGGER.debug('Non zero padding: probably not a DICOM message [%r]', data)\n        return res\n    if rlen > len(data) - 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    if rtype in [2, 3]:\n        res['service_name'] = 'dicom'\n        extra_info: Dict[str, Union[int, str]] = {}\n        if rtype == 2:\n            msg = 'Any AET is accepted (Insecure)'\n            if data[6:74] != b'\\x00\\x01\\x00\\x00ANY-SCP         ECHOSCU         \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n                extra_info = {'info': 'Unusual accept message'}\n            else:\n                extra_info = _parse_items(data[74:])\n        else:\n            msg = 'Called AET check enabled'\n            if data != b'\\x03\\x00\\x00\\x00\\x00\\x04\\x00\\x01\\x01\\x07':\n                extra_info = {'info': 'Unusual reject message'}\n        script_output = ['', 'dicom: DICOM Service Provider discovered!', 'config: %s' % msg]\n        script_data: Dict[str, Union[int, str]] = {'dicom': 'DICOM Service Provider discovered!', 'config': msg}\n        for (key, value) in extra_info.items():\n            script_output.append('%s: %s' % (key, value))\n            script_data[key] = value\n        res['scripts'] = [{'id': 'dicom-ping', 'output': '\\n  '.join(script_output), 'dicom-ping': script_data}]\n        return res\n    utils.LOGGER.debug('Unknown message type [%r]: probably not a DICOM message [%r]', rtype, data)\n    return res",
            "def parse_message(data: bytes) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res: NmapPort = {}\n    if len(data) < 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    (rtype, pad, rlen) = struct.unpack('>BBI', data[:6])\n    if pad:\n        utils.LOGGER.debug('Non zero padding: probably not a DICOM message [%r]', data)\n        return res\n    if rlen > len(data) - 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    if rtype in [2, 3]:\n        res['service_name'] = 'dicom'\n        extra_info: Dict[str, Union[int, str]] = {}\n        if rtype == 2:\n            msg = 'Any AET is accepted (Insecure)'\n            if data[6:74] != b'\\x00\\x01\\x00\\x00ANY-SCP         ECHOSCU         \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n                extra_info = {'info': 'Unusual accept message'}\n            else:\n                extra_info = _parse_items(data[74:])\n        else:\n            msg = 'Called AET check enabled'\n            if data != b'\\x03\\x00\\x00\\x00\\x00\\x04\\x00\\x01\\x01\\x07':\n                extra_info = {'info': 'Unusual reject message'}\n        script_output = ['', 'dicom: DICOM Service Provider discovered!', 'config: %s' % msg]\n        script_data: Dict[str, Union[int, str]] = {'dicom': 'DICOM Service Provider discovered!', 'config': msg}\n        for (key, value) in extra_info.items():\n            script_output.append('%s: %s' % (key, value))\n            script_data[key] = value\n        res['scripts'] = [{'id': 'dicom-ping', 'output': '\\n  '.join(script_output), 'dicom-ping': script_data}]\n        return res\n    utils.LOGGER.debug('Unknown message type [%r]: probably not a DICOM message [%r]', rtype, data)\n    return res",
            "def parse_message(data: bytes) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res: NmapPort = {}\n    if len(data) < 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    (rtype, pad, rlen) = struct.unpack('>BBI', data[:6])\n    if pad:\n        utils.LOGGER.debug('Non zero padding: probably not a DICOM message [%r]', data)\n        return res\n    if rlen > len(data) - 6:\n        utils.LOGGER.debug('Message too short: probably not a DICOM message [%r]', data)\n        return res\n    if rtype in [2, 3]:\n        res['service_name'] = 'dicom'\n        extra_info: Dict[str, Union[int, str]] = {}\n        if rtype == 2:\n            msg = 'Any AET is accepted (Insecure)'\n            if data[6:74] != b'\\x00\\x01\\x00\\x00ANY-SCP         ECHOSCU         \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n                extra_info = {'info': 'Unusual accept message'}\n            else:\n                extra_info = _parse_items(data[74:])\n        else:\n            msg = 'Called AET check enabled'\n            if data != b'\\x03\\x00\\x00\\x00\\x00\\x04\\x00\\x01\\x01\\x07':\n                extra_info = {'info': 'Unusual reject message'}\n        script_output = ['', 'dicom: DICOM Service Provider discovered!', 'config: %s' % msg]\n        script_data: Dict[str, Union[int, str]] = {'dicom': 'DICOM Service Provider discovered!', 'config': msg}\n        for (key, value) in extra_info.items():\n            script_output.append('%s: %s' % (key, value))\n            script_data[key] = value\n        res['scripts'] = [{'id': 'dicom-ping', 'output': '\\n  '.join(script_output), 'dicom-ping': script_data}]\n        return res\n    utils.LOGGER.debug('Unknown message type [%r]: probably not a DICOM message [%r]', rtype, data)\n    return res"
        ]
    }
]