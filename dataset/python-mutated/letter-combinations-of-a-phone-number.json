[
    {
        "func_name": "letterCombinations",
        "original": "def letterCombinations(self, digits):\n    \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n    if not digits:\n        return []\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    total = 1\n    for digit in digits:\n        total *= len(lookup[int(digit)])\n    result = []\n    for i in xrange(total):\n        (base, curr) = (total, [])\n        for digit in digits:\n            choices = lookup[int(digit)]\n            base //= len(choices)\n            curr.append(choices[i // base % len(choices)])\n        result.append(''.join(curr))\n    return result",
        "mutated": [
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    total = 1\n    for digit in digits:\n        total *= len(lookup[int(digit)])\n    result = []\n    for i in xrange(total):\n        (base, curr) = (total, [])\n        for digit in digits:\n            choices = lookup[int(digit)]\n            base //= len(choices)\n            curr.append(choices[i // base % len(choices)])\n        result.append(''.join(curr))\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    total = 1\n    for digit in digits:\n        total *= len(lookup[int(digit)])\n    result = []\n    for i in xrange(total):\n        (base, curr) = (total, [])\n        for digit in digits:\n            choices = lookup[int(digit)]\n            base //= len(choices)\n            curr.append(choices[i // base % len(choices)])\n        result.append(''.join(curr))\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    total = 1\n    for digit in digits:\n        total *= len(lookup[int(digit)])\n    result = []\n    for i in xrange(total):\n        (base, curr) = (total, [])\n        for digit in digits:\n            choices = lookup[int(digit)]\n            base //= len(choices)\n            curr.append(choices[i // base % len(choices)])\n        result.append(''.join(curr))\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    total = 1\n    for digit in digits:\n        total *= len(lookup[int(digit)])\n    result = []\n    for i in xrange(total):\n        (base, curr) = (total, [])\n        for digit in digits:\n            choices = lookup[int(digit)]\n            base //= len(choices)\n            curr.append(choices[i // base % len(choices)])\n        result.append(''.join(curr))\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    total = 1\n    for digit in digits:\n        total *= len(lookup[int(digit)])\n    result = []\n    for i in xrange(total):\n        (base, curr) = (total, [])\n        for digit in digits:\n            choices = lookup[int(digit)]\n            base //= len(choices)\n            curr.append(choices[i // base % len(choices)])\n        result.append(''.join(curr))\n    return result"
        ]
    },
    {
        "func_name": "letterCombinations",
        "original": "def letterCombinations(self, digits):\n    \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n    if not digits:\n        return []\n    result = ['']\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    for digit in reversed(digits):\n        choices = lookup[int(digit)]\n        (m, n) = (len(choices), len(result))\n        result.extend([result[i % n] for i in xrange(n, m * n)])\n        for i in xrange(m * n):\n            result[i] = choices[i // n] + result[i]\n    return result",
        "mutated": [
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    result = ['']\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    for digit in reversed(digits):\n        choices = lookup[int(digit)]\n        (m, n) = (len(choices), len(result))\n        result.extend([result[i % n] for i in xrange(n, m * n)])\n        for i in xrange(m * n):\n            result[i] = choices[i // n] + result[i]\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    result = ['']\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    for digit in reversed(digits):\n        choices = lookup[int(digit)]\n        (m, n) = (len(choices), len(result))\n        result.extend([result[i % n] for i in xrange(n, m * n)])\n        for i in xrange(m * n):\n            result[i] = choices[i // n] + result[i]\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    result = ['']\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    for digit in reversed(digits):\n        choices = lookup[int(digit)]\n        (m, n) = (len(choices), len(result))\n        result.extend([result[i % n] for i in xrange(n, m * n)])\n        for i in xrange(m * n):\n            result[i] = choices[i // n] + result[i]\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    result = ['']\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    for digit in reversed(digits):\n        choices = lookup[int(digit)]\n        (m, n) = (len(choices), len(result))\n        result.extend([result[i % n] for i in xrange(n, m * n)])\n        for i in xrange(m * n):\n            result[i] = choices[i // n] + result[i]\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    if not digits:\n        return []\n    result = ['']\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    for digit in reversed(digits):\n        choices = lookup[int(digit)]\n        (m, n) = (len(choices), len(result))\n        result.extend([result[i % n] for i in xrange(n, m * n)])\n        for i in xrange(m * n):\n            result[i] = choices[i // n] + result[i]\n    return result"
        ]
    },
    {
        "func_name": "letterCombinationsRecu",
        "original": "def letterCombinationsRecu(result, digits, curr, n):\n    if n == len(digits):\n        result.append(''.join(curr))\n        return\n    for choice in lookup[int(digits[n])]:\n        curr.append(choice)\n        letterCombinationsRecu(result, digits, curr, n + 1)\n        curr.pop()",
        "mutated": [
            "def letterCombinationsRecu(result, digits, curr, n):\n    if False:\n        i = 10\n    if n == len(digits):\n        result.append(''.join(curr))\n        return\n    for choice in lookup[int(digits[n])]:\n        curr.append(choice)\n        letterCombinationsRecu(result, digits, curr, n + 1)\n        curr.pop()",
            "def letterCombinationsRecu(result, digits, curr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if n == len(digits):\n        result.append(''.join(curr))\n        return\n    for choice in lookup[int(digits[n])]:\n        curr.append(choice)\n        letterCombinationsRecu(result, digits, curr, n + 1)\n        curr.pop()",
            "def letterCombinationsRecu(result, digits, curr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if n == len(digits):\n        result.append(''.join(curr))\n        return\n    for choice in lookup[int(digits[n])]:\n        curr.append(choice)\n        letterCombinationsRecu(result, digits, curr, n + 1)\n        curr.pop()",
            "def letterCombinationsRecu(result, digits, curr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if n == len(digits):\n        result.append(''.join(curr))\n        return\n    for choice in lookup[int(digits[n])]:\n        curr.append(choice)\n        letterCombinationsRecu(result, digits, curr, n + 1)\n        curr.pop()",
            "def letterCombinationsRecu(result, digits, curr, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if n == len(digits):\n        result.append(''.join(curr))\n        return\n    for choice in lookup[int(digits[n])]:\n        curr.append(choice)\n        letterCombinationsRecu(result, digits, curr, n + 1)\n        curr.pop()"
        ]
    },
    {
        "func_name": "letterCombinations",
        "original": "def letterCombinations(self, digits):\n    \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n\n    def letterCombinationsRecu(result, digits, curr, n):\n        if n == len(digits):\n            result.append(''.join(curr))\n            return\n        for choice in lookup[int(digits[n])]:\n            curr.append(choice)\n            letterCombinationsRecu(result, digits, curr, n + 1)\n            curr.pop()\n    if not digits:\n        return []\n    result = []\n    letterCombinationsRecu(result, digits, [], 0)\n    return result",
        "mutated": [
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n\n    def letterCombinationsRecu(result, digits, curr, n):\n        if n == len(digits):\n            result.append(''.join(curr))\n            return\n        for choice in lookup[int(digits[n])]:\n            curr.append(choice)\n            letterCombinationsRecu(result, digits, curr, n + 1)\n            curr.pop()\n    if not digits:\n        return []\n    result = []\n    letterCombinationsRecu(result, digits, [], 0)\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n\n    def letterCombinationsRecu(result, digits, curr, n):\n        if n == len(digits):\n            result.append(''.join(curr))\n            return\n        for choice in lookup[int(digits[n])]:\n            curr.append(choice)\n            letterCombinationsRecu(result, digits, curr, n + 1)\n            curr.pop()\n    if not digits:\n        return []\n    result = []\n    letterCombinationsRecu(result, digits, [], 0)\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n\n    def letterCombinationsRecu(result, digits, curr, n):\n        if n == len(digits):\n            result.append(''.join(curr))\n            return\n        for choice in lookup[int(digits[n])]:\n            curr.append(choice)\n            letterCombinationsRecu(result, digits, curr, n + 1)\n            curr.pop()\n    if not digits:\n        return []\n    result = []\n    letterCombinationsRecu(result, digits, [], 0)\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n\n    def letterCombinationsRecu(result, digits, curr, n):\n        if n == len(digits):\n            result.append(''.join(curr))\n            return\n        for choice in lookup[int(digits[n])]:\n            curr.append(choice)\n            letterCombinationsRecu(result, digits, curr, n + 1)\n            curr.pop()\n    if not digits:\n        return []\n    result = []\n    letterCombinationsRecu(result, digits, [], 0)\n    return result",
            "def letterCombinations(self, digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type digits: str\\n        :rtype: List[str]\\n        '\n    lookup = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n\n    def letterCombinationsRecu(result, digits, curr, n):\n        if n == len(digits):\n            result.append(''.join(curr))\n            return\n        for choice in lookup[int(digits[n])]:\n            curr.append(choice)\n            letterCombinationsRecu(result, digits, curr, n + 1)\n            curr.pop()\n    if not digits:\n        return []\n    result = []\n    letterCombinationsRecu(result, digits, [], 0)\n    return result"
        ]
    }
]